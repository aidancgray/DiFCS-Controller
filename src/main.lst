CCS PCH C Compiler, Version 5.117, 2138               25-Nov-25 21:15

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   45896 bytes (70%)
                           Largest free fragment is 19638
               RAM used:   1645 (46%) at main() level
                           1751 (48%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   ACBE
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025A
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0032E:  DATA 32,30
00330:  DATA 32,35
00332:  DATA 31,31
00334:  DATA 30,34
00336:  DATA 00,00
00338:  DATA 30,30
0033A:  DATA 30,30
0033C:  DATA 00,00
0033E:  DATA 25,64
00340:  DATA 2C,4D
00342:  DATA 41,4E
00344:  DATA 55,41
00346:  DATA 4C,2C
00348:  DATA 00,00
0034A:  DATA 25,64
0034C:  DATA 2C,4D
0034E:  DATA 41,47
00350:  DATA 53,4E
00352:  DATA 53,2C
00354:  DATA 00,00
00356:  DATA 23,44
00358:  DATA 30,2C
0035A:  DATA 43,4E
0035C:  DATA 54,2C
0035E:  DATA 25,75
00360:  DATA 2C,25
00362:  DATA 2E,30
00364:  DATA 66,2C
00366:  DATA 25,2E
00368:  DATA 30,66
0036A:  DATA 0A,00
0036C:  DATA 23,44
0036E:  DATA 30,2C
00370:  DATA 50,4F
00372:  DATA 53,2C
00374:  DATA 25,75
00376:  DATA 2C,25
00378:  DATA 33,2E
0037A:  DATA 33,66
0037C:  DATA 0A,00
0037E:  DATA 23,44
00380:  DATA 30,2C
00382:  DATA 4F,55
00384:  DATA 54,2C
00386:  DATA 25,75
00388:  DATA 2C,2D
0038A:  DATA 2C,25
0038C:  DATA 4C,75
0038E:  DATA 0A,00
00390:  DATA 23,44
00392:  DATA 30,2C
00394:  DATA 4F,55
00396:  DATA 54,2C
00398:  DATA 25,75
0039A:  DATA 2C,2B
0039C:  DATA 2C,25
0039E:  DATA 4C,75
003A0:  DATA 0A,00
*
006C8:  ADDWF  FE8,W
006CA:  CLRF   FF7
006CC:  RLCF   FF7,F
006CE:  ADDLW  E3
006D0:  MOVWF  FF6
006D2:  MOVLW  06
006D4:  ADDWFC FF7,F
006D6:  TBLRD*-
006D8:  MOVF   FF5,W
006DA:  MOVWF  FFA
006DC:  TBLRD*
006DE:  MOVF   FF5,W
006E0:  MOVWF  FF9
006E2:  DATA 92,06
006E4:  DATA 9C,06
006E6:  DATA A6,06
006E8:  DATA B0,06
*
00802:  MOVLB  6
00804:  MOVF   xB0,W
00806:  MULWF  xB2
00808:  MOVFF  FF3,01
0080C:  MOVFF  FF4,00
00810:  MULWF  xB3
00812:  MOVF   FF3,W
00814:  ADDWF  00,F
00816:  MOVF   xB1,W
00818:  MULWF  xB2
0081A:  MOVF   FF3,W
0081C:  ADDWFC 00,W
0081E:  MOVWF  02
00820:  MOVLB  0
00822:  RETURN 0
*
012D4:  MOVLW  8E
012D6:  MOVWF  00
012D8:  MOVFF  6B4,01
012DC:  MOVFF  6B3,02
012E0:  CLRF   03
012E2:  MOVF   01,F
012E4:  BNZ   12F8
012E6:  MOVFF  02,01
012EA:  CLRF   02
012EC:  MOVLW  08
012EE:  SUBWF  00,F
012F0:  MOVF   01,F
012F2:  BNZ   12F8
012F4:  CLRF   00
012F6:  BRA    1308
012F8:  BCF    FD8.0
012FA:  BTFSC  01.7
012FC:  BRA    1306
012FE:  RLCF   02,F
01300:  RLCF   01,F
01302:  DECF   00,F
01304:  BRA    12F8
01306:  BCF    01.7
01308:  RETURN 0
0130A:  MOVLB  6
0130C:  MOVF   xB4,W
0130E:  BTFSC  FD8.2
01310:  BRA    13F4
01312:  MOVWF  00
01314:  MOVF   xB8,W
01316:  BTFSC  FD8.2
01318:  BRA    13F4
0131A:  ADDWF  00,F
0131C:  BNC   1326
0131E:  MOVLW  81
01320:  ADDWF  00,F
01322:  BC    13F4
01324:  BRA    132E
01326:  MOVLW  7F
01328:  SUBWF  00,F
0132A:  BNC   13F4
0132C:  BZ    13F4
0132E:  MOVFF  6B5,6BC
01332:  MOVF   xB9,W
01334:  XORWF  xBC,F
01336:  BSF    xB5.7
01338:  BSF    xB9.7
0133A:  MOVF   xB7,W
0133C:  MULWF  xBB
0133E:  MOVFF  FF4,6BE
01342:  MOVF   xB6,W
01344:  MULWF  xBA
01346:  MOVFF  FF4,03
0134A:  MOVFF  FF3,6BD
0134E:  MULWF  xBB
01350:  MOVF   FF3,W
01352:  ADDWF  xBE,F
01354:  MOVF   FF4,W
01356:  ADDWFC xBD,F
01358:  MOVLW  00
0135A:  ADDWFC 03,F
0135C:  MOVF   xB7,W
0135E:  MULWF  xBA
01360:  MOVF   FF3,W
01362:  ADDWF  xBE,F
01364:  MOVF   FF4,W
01366:  ADDWFC xBD,F
01368:  MOVLW  00
0136A:  CLRF   02
0136C:  ADDWFC 03,F
0136E:  ADDWFC 02,F
01370:  MOVF   xB5,W
01372:  MULWF  xBB
01374:  MOVF   FF3,W
01376:  ADDWF  xBD,F
01378:  MOVF   FF4,W
0137A:  ADDWFC 03,F
0137C:  MOVLW  00
0137E:  ADDWFC 02,F
01380:  MOVF   xB5,W
01382:  MULWF  xBA
01384:  MOVF   FF3,W
01386:  ADDWF  03,F
01388:  MOVF   FF4,W
0138A:  ADDWFC 02,F
0138C:  MOVLW  00
0138E:  CLRF   01
01390:  ADDWFC 01,F
01392:  MOVF   xB7,W
01394:  MULWF  xB9
01396:  MOVF   FF3,W
01398:  ADDWF  xBD,F
0139A:  MOVF   FF4,W
0139C:  ADDWFC 03,F
0139E:  MOVLW  00
013A0:  ADDWFC 02,F
013A2:  ADDWFC 01,F
013A4:  MOVF   xB6,W
013A6:  MULWF  xB9
013A8:  MOVF   FF3,W
013AA:  ADDWF  03,F
013AC:  MOVF   FF4,W
013AE:  ADDWFC 02,F
013B0:  MOVLW  00
013B2:  ADDWFC 01,F
013B4:  MOVF   xB5,W
013B6:  MULWF  xB9
013B8:  MOVF   FF3,W
013BA:  ADDWF  02,F
013BC:  MOVF   FF4,W
013BE:  ADDWFC 01,F
013C0:  INCF   00,F
013C2:  BTFSC  01.7
013C4:  BRA    13D0
013C6:  RLCF   xBD,F
013C8:  RLCF   03,F
013CA:  RLCF   02,F
013CC:  RLCF   01,F
013CE:  DECF   00,F
013D0:  MOVLW  00
013D2:  BTFSS  xBD.7
013D4:  BRA    13EA
013D6:  INCF   03,F
013D8:  ADDWFC 02,F
013DA:  ADDWFC 01,F
013DC:  MOVF   01,W
013DE:  BNZ   13EA
013E0:  MOVF   02,W
013E2:  BNZ   13EA
013E4:  MOVF   03,W
013E6:  BNZ   13EA
013E8:  INCF   00,F
013EA:  BTFSC  xBC.7
013EC:  BSF    01.7
013EE:  BTFSS  xBC.7
013F0:  BCF    01.7
013F2:  BRA    13FC
013F4:  CLRF   00
013F6:  CLRF   01
013F8:  CLRF   02
013FA:  CLRF   03
013FC:  MOVLB  0
013FE:  RETURN 0
01400:  MOVLW  80
01402:  BTFSS  FD8.1
01404:  BRA    140A
01406:  MOVLB  6
01408:  XORWF  xB8,F
0140A:  MOVLB  6
0140C:  CLRF   xBD
0140E:  CLRF   xBE
01410:  MOVFF  6B4,6BC
01414:  MOVF   xB8,W
01416:  XORWF  xBC,F
01418:  MOVF   xB3,W
0141A:  BTFSC  FD8.2
0141C:  BRA    15DC
0141E:  MOVWF  xBB
01420:  MOVWF  00
01422:  MOVF   xB7,W
01424:  BTFSC  FD8.2
01426:  BRA    15EE
01428:  SUBWF  xBB,F
0142A:  BTFSC  FD8.2
0142C:  BRA    1534
0142E:  BNC   14AC
01430:  MOVFF  6B8,6C1
01434:  BSF    xC1.7
01436:  MOVFF  6B9,6C0
0143A:  MOVFF  6BA,6BF
0143E:  CLRF   xBE
01440:  BCF    FD8.0
01442:  RRCF   xC1,F
01444:  RRCF   xC0,F
01446:  RRCF   xBF,F
01448:  RRCF   xBE,F
0144A:  DECFSZ xBB,F
0144C:  BRA    143E
0144E:  BTFSS  xBC.7
01450:  BRA    1458
01452:  BSF    xBD.0
01454:  BRA    1616
01456:  BCF    xBD.0
01458:  BCF    xBB.0
0145A:  BSF    xBD.4
0145C:  MOVLW  06
0145E:  MOVWF  FEA
01460:  MOVLW  B6
01462:  MOVWF  FE9
01464:  BRA    163C
01466:  BCF    xBD.4
01468:  BTFSC  xBC.7
0146A:  BRA    1480
0146C:  BTFSS  xBB.0
0146E:  BRA    1496
01470:  RRCF   xC1,F
01472:  RRCF   xC0,F
01474:  RRCF   xBF,F
01476:  RRCF   xBE,F
01478:  INCF   00,F
0147A:  BTFSC  FD8.2
0147C:  BRA    160C
0147E:  BRA    1496
01480:  BTFSC  xC1.7
01482:  BRA    149C
01484:  BCF    FD8.0
01486:  RLCF   xBE,F
01488:  RLCF   xBF,F
0148A:  RLCF   xC0,F
0148C:  RLCF   xC1,F
0148E:  DECF   00,F
01490:  BTFSC  FD8.2
01492:  BRA    160C
01494:  BRA    1480
01496:  BSF    xBD.6
01498:  BRA    1574
0149A:  BCF    xBD.6
0149C:  MOVFF  6B4,6BC
014A0:  BTFSS  xB4.7
014A2:  BRA    14A8
014A4:  BSF    xC1.7
014A6:  BRA    15FE
014A8:  BCF    xC1.7
014AA:  BRA    15FE
014AC:  MOVFF  6B7,6BB
014B0:  MOVFF  6B7,00
014B4:  MOVF   xB3,W
014B6:  SUBWF  xBB,F
014B8:  MOVFF  6B4,6C1
014BC:  BSF    xC1.7
014BE:  MOVFF  6B5,6C0
014C2:  MOVFF  6B6,6BF
014C6:  CLRF   xBE
014C8:  BCF    FD8.0
014CA:  RRCF   xC1,F
014CC:  RRCF   xC0,F
014CE:  RRCF   xBF,F
014D0:  RRCF   xBE,F
014D2:  DECFSZ xBB,F
014D4:  BRA    14C6
014D6:  BTFSS  xBC.7
014D8:  BRA    14E0
014DA:  BSF    xBD.1
014DC:  BRA    1616
014DE:  BCF    xBD.1
014E0:  BCF    xBB.0
014E2:  BSF    xBD.5
014E4:  MOVLW  06
014E6:  MOVWF  FEA
014E8:  MOVLW  BA
014EA:  MOVWF  FE9
014EC:  BRA    163C
014EE:  BCF    xBD.5
014F0:  BTFSC  xBC.7
014F2:  BRA    1508
014F4:  BTFSS  xBB.0
014F6:  BRA    151E
014F8:  RRCF   xC1,F
014FA:  RRCF   xC0,F
014FC:  RRCF   xBF,F
014FE:  RRCF   xBE,F
01500:  INCF   00,F
01502:  BTFSC  FD8.2
01504:  BRA    160C
01506:  BRA    151E
01508:  BTFSC  xC1.7
0150A:  BRA    1524
0150C:  BCF    FD8.0
0150E:  RLCF   xBE,F
01510:  RLCF   xBF,F
01512:  RLCF   xC0,F
01514:  RLCF   xC1,F
01516:  DECF   00,F
01518:  BTFSC  FD8.2
0151A:  BRA    160C
0151C:  BRA    1508
0151E:  BSF    xBD.7
01520:  BRA    1574
01522:  BCF    xBD.7
01524:  MOVFF  6B8,6BC
01528:  BTFSS  xB8.7
0152A:  BRA    1530
0152C:  BSF    xC1.7
0152E:  BRA    15FE
01530:  BCF    xC1.7
01532:  BRA    15FE
01534:  MOVFF  6B8,6C1
01538:  BSF    xC1.7
0153A:  MOVFF  6B9,6C0
0153E:  MOVFF  6BA,6BF
01542:  BTFSS  xBC.7
01544:  BRA    154E
01546:  BCF    xC1.7
01548:  BSF    xBD.2
0154A:  BRA    1616
0154C:  BCF    xBD.2
0154E:  CLRF   xBE
01550:  BCF    xBB.0
01552:  MOVLW  06
01554:  MOVWF  FEA
01556:  MOVLW  B6
01558:  MOVWF  FE9
0155A:  BRA    163C
0155C:  BTFSC  xBC.7
0155E:  BRA    1598
01560:  MOVFF  6B4,6BC
01564:  BTFSS  xBB.0
01566:  BRA    1574
01568:  RRCF   xC1,F
0156A:  RRCF   xC0,F
0156C:  RRCF   xBF,F
0156E:  RRCF   xBE,F
01570:  INCF   00,F
01572:  BZ    160C
01574:  BTFSS  xBE.7
01576:  BRA    158E
01578:  INCF   xBF,F
0157A:  BNZ   158E
0157C:  INCF   xC0,F
0157E:  BNZ   158E
01580:  INCF   xC1,F
01582:  BNZ   158E
01584:  RRCF   xC1,F
01586:  RRCF   xC0,F
01588:  RRCF   xBF,F
0158A:  INCF   00,F
0158C:  BZ    160C
0158E:  BTFSC  xBD.6
01590:  BRA    149A
01592:  BTFSC  xBD.7
01594:  BRA    1522
01596:  BRA    15D0
01598:  MOVLW  80
0159A:  XORWF  xC1,F
0159C:  BTFSS  xC1.7
0159E:  BRA    15A8
015A0:  BRA    1616
015A2:  MOVFF  6B8,6BC
015A6:  BRA    15BC
015A8:  MOVFF  6B4,6BC
015AC:  MOVF   xC1,F
015AE:  BNZ   15BC
015B0:  MOVF   xC0,F
015B2:  BNZ   15BC
015B4:  MOVF   xBF,F
015B6:  BNZ   15BC
015B8:  CLRF   00
015BA:  BRA    15FE
015BC:  BTFSC  xC1.7
015BE:  BRA    15D0
015C0:  BCF    FD8.0
015C2:  RLCF   xBE,F
015C4:  RLCF   xBF,F
015C6:  RLCF   xC0,F
015C8:  RLCF   xC1,F
015CA:  DECFSZ 00,F
015CC:  BRA    15BC
015CE:  BRA    160C
015D0:  BTFSS  xBC.7
015D2:  BRA    15D8
015D4:  BSF    xC1.7
015D6:  BRA    15FE
015D8:  BCF    xC1.7
015DA:  BRA    15FE
015DC:  MOVFF  6B7,00
015E0:  MOVFF  6B8,6C1
015E4:  MOVFF  6B9,6C0
015E8:  MOVFF  6BA,6BF
015EC:  BRA    15FE
015EE:  MOVFF  6B3,00
015F2:  MOVFF  6B4,6C1
015F6:  MOVFF  6B5,6C0
015FA:  MOVFF  6B6,6BF
015FE:  MOVFF  6C1,01
01602:  MOVFF  6C0,02
01606:  MOVFF  6BF,03
0160A:  BRA    1674
0160C:  CLRF   00
0160E:  CLRF   01
01610:  CLRF   02
01612:  CLRF   03
01614:  BRA    1674
01616:  CLRF   xBE
01618:  COMF   xBF,F
0161A:  COMF   xC0,F
0161C:  COMF   xC1,F
0161E:  COMF   xBE,F
01620:  INCF   xBE,F
01622:  BNZ   162E
01624:  INCF   xBF,F
01626:  BNZ   162E
01628:  INCF   xC0,F
0162A:  BNZ   162E
0162C:  INCF   xC1,F
0162E:  BTFSC  xBD.0
01630:  BRA    1456
01632:  BTFSC  xBD.1
01634:  BRA    14DE
01636:  BTFSC  xBD.2
01638:  BRA    154C
0163A:  BRA    15A2
0163C:  MOVF   FEF,W
0163E:  ADDWF  xBF,F
01640:  BNC   164C
01642:  INCF   xC0,F
01644:  BNZ   164C
01646:  INCF   xC1,F
01648:  BTFSC  FD8.2
0164A:  BSF    xBB.0
0164C:  MOVF   FED,F
0164E:  MOVF   FEF,W
01650:  ADDWF  xC0,F
01652:  BNC   165A
01654:  INCF   xC1,F
01656:  BTFSC  FD8.2
01658:  BSF    xBB.0
0165A:  MOVF   FED,F
0165C:  MOVF   FEF,W
0165E:  BTFSC  FEF.7
01660:  BRA    1664
01662:  XORLW  80
01664:  ADDWF  xC1,F
01666:  BTFSC  FD8.0
01668:  BSF    xBB.0
0166A:  BTFSC  xBD.4
0166C:  BRA    1466
0166E:  BTFSC  xBD.5
01670:  BRA    14EE
01672:  BRA    155C
01674:  MOVLB  0
01676:  RETURN 0
*
01BCE:  ADDWF  FE8,W
01BD0:  CLRF   FF7
01BD2:  RLCF   FF7,F
01BD4:  ADDLW  E9
01BD6:  MOVWF  FF6
01BD8:  MOVLW  1B
01BDA:  ADDWFC FF7,F
01BDC:  TBLRD*-
01BDE:  MOVF   FF5,W
01BE0:  MOVWF  FFA
01BE2:  TBLRD*
01BE4:  MOVF   FF5,W
01BE6:  MOVWF  FF9
01BE8:  DATA 90,16
01BEA:  DATA 50,17
01BEC:  DATA 10,18
01BEE:  DATA D0,18
01BF0:  DATA 90,19
01BF2:  DATA 50,1A
01BF4:  DATA 10,1B
*
01D52:  BTFSC  FD8.1
01D54:  BRA    1D5E
01D56:  MOVLW  06
01D58:  MOVWF  FEA
01D5A:  MOVLW  B3
01D5C:  MOVWF  FE9
01D5E:  MOVLB  6
01D60:  MOVF   xAE,W
01D62:  XORWF  xB2,W
01D64:  ANDLW  80
01D66:  MOVWF  xB8
01D68:  BTFSS  xAE.7
01D6A:  BRA    1D82
01D6C:  COMF   xAB,F
01D6E:  COMF   xAC,F
01D70:  COMF   xAD,F
01D72:  COMF   xAE,F
01D74:  INCF   xAB,F
01D76:  BTFSC  FD8.2
01D78:  INCF   xAC,F
01D7A:  BTFSC  FD8.2
01D7C:  INCF   xAD,F
01D7E:  BTFSC  FD8.2
01D80:  INCF   xAE,F
01D82:  BTFSS  xB2.7
01D84:  BRA    1D9C
01D86:  COMF   xAF,F
01D88:  COMF   xB0,F
01D8A:  COMF   xB1,F
01D8C:  COMF   xB2,F
01D8E:  INCF   xAF,F
01D90:  BTFSC  FD8.2
01D92:  INCF   xB0,F
01D94:  BTFSC  FD8.2
01D96:  INCF   xB1,F
01D98:  BTFSC  FD8.2
01D9A:  INCF   xB2,F
01D9C:  CLRF   00
01D9E:  CLRF   01
01DA0:  CLRF   02
01DA2:  CLRF   03
01DA4:  CLRF   xB3
01DA6:  CLRF   xB4
01DA8:  CLRF   xB5
01DAA:  CLRF   xB6
01DAC:  MOVF   xB2,W
01DAE:  IORWF  xB1,W
01DB0:  IORWF  xB0,W
01DB2:  IORWF  xAF,W
01DB4:  BZ    1E0E
01DB6:  MOVLW  20
01DB8:  MOVWF  xB7
01DBA:  BCF    FD8.0
01DBC:  RLCF   xAB,F
01DBE:  RLCF   xAC,F
01DC0:  RLCF   xAD,F
01DC2:  RLCF   xAE,F
01DC4:  RLCF   xB3,F
01DC6:  RLCF   xB4,F
01DC8:  RLCF   xB5,F
01DCA:  RLCF   xB6,F
01DCC:  MOVF   xB2,W
01DCE:  SUBWF  xB6,W
01DD0:  BNZ   1DE2
01DD2:  MOVF   xB1,W
01DD4:  SUBWF  xB5,W
01DD6:  BNZ   1DE2
01DD8:  MOVF   xB0,W
01DDA:  SUBWF  xB4,W
01DDC:  BNZ   1DE2
01DDE:  MOVF   xAF,W
01DE0:  SUBWF  xB3,W
01DE2:  BNC   1E02
01DE4:  MOVF   xAF,W
01DE6:  SUBWF  xB3,F
01DE8:  MOVF   xB0,W
01DEA:  BTFSS  FD8.0
01DEC:  INCFSZ xB0,W
01DEE:  SUBWF  xB4,F
01DF0:  MOVF   xB1,W
01DF2:  BTFSS  FD8.0
01DF4:  INCFSZ xB1,W
01DF6:  SUBWF  xB5,F
01DF8:  MOVF   xB2,W
01DFA:  BTFSS  FD8.0
01DFC:  INCFSZ xB2,W
01DFE:  SUBWF  xB6,F
01E00:  BSF    FD8.0
01E02:  RLCF   00,F
01E04:  RLCF   01,F
01E06:  RLCF   02,F
01E08:  RLCF   03,F
01E0A:  DECFSZ xB7,F
01E0C:  BRA    1DBA
01E0E:  BTFSS  xB8.7
01E10:  BRA    1E28
01E12:  COMF   00,F
01E14:  COMF   01,F
01E16:  COMF   02,F
01E18:  COMF   03,F
01E1A:  INCF   00,F
01E1C:  BTFSC  FD8.2
01E1E:  INCF   01,F
01E20:  BTFSC  FD8.2
01E22:  INCF   02,F
01E24:  BTFSC  FD8.2
01E26:  INCF   03,F
01E28:  MOVFF  6B3,FEF
01E2C:  MOVFF  6B4,FEC
01E30:  MOVFF  6B5,FEC
01E34:  MOVFF  6B6,FEC
01E38:  MOVLB  0
01E3A:  RETURN 0
*
0277C:  MOVLW  B6
0277E:  MOVWF  00
02780:  CLRF   03
02782:  CLRF   02
02784:  CLRF   01
02786:  MOVLB  6
02788:  BCF    x7D.0
0278A:  BTFSS  x7C.7
0278C:  BRA    27A6
0278E:  BSF    x7D.0
02790:  COMF   x79,F
02792:  COMF   x7A,F
02794:  COMF   x7B,F
02796:  COMF   x7C,F
02798:  INCF   x79,F
0279A:  BNZ   27A6
0279C:  INCF   x7A,F
0279E:  BNZ   27A6
027A0:  INCF   x7B,F
027A2:  BTFSC  FD8.2
027A4:  INCF   x7C,F
027A6:  MOVF   x79,W
027A8:  IORWF  x7A,W
027AA:  IORWF  x7B,W
027AC:  IORWF  x7C,W
027AE:  BNZ   27B4
027B0:  CLRF   00
027B2:  BRA    27D2
027B4:  BCF    FD8.0
027B6:  BTFSC  01.7
027B8:  BRA    27CC
027BA:  RLCF   x79,F
027BC:  RLCF   x7A,F
027BE:  RLCF   x7B,F
027C0:  RLCF   x7C,F
027C2:  RLCF   03,F
027C4:  RLCF   02,F
027C6:  RLCF   01,F
027C8:  DECFSZ 00,F
027CA:  BRA    27B4
027CC:  BCF    01.7
027CE:  BTFSC  x7D.0
027D0:  BSF    01.7
027D2:  MOVLB  0
027D4:  RETURN 0
027D6:  MOVFF  6B0,6B7
027DA:  MOVLB  6
027DC:  MOVF   xB4,W
027DE:  XORWF  xB7,F
027E0:  BTFSS  xB7.7
027E2:  BRA    27EE
027E4:  BCF    FD8.2
027E6:  BCF    FD8.0
027E8:  BTFSC  xB0.7
027EA:  BSF    FD8.0
027EC:  BRA    284C
027EE:  MOVFF  6B0,6B7
027F2:  MOVFF  6B3,6B8
027F6:  MOVF   xAF,W
027F8:  SUBWF  xB8,F
027FA:  BZ    2808
027FC:  BTFSS  xB7.7
027FE:  BRA    284C
02800:  MOVF   FD8,W
02802:  XORLW  01
02804:  MOVWF  FD8
02806:  BRA    284C
02808:  MOVFF  6B4,6B8
0280C:  MOVF   xB0,W
0280E:  SUBWF  xB8,F
02810:  BZ    281E
02812:  BTFSS  xB7.7
02814:  BRA    284C
02816:  MOVF   FD8,W
02818:  XORLW  01
0281A:  MOVWF  FD8
0281C:  BRA    284C
0281E:  MOVFF  6B5,6B8
02822:  MOVF   xB1,W
02824:  SUBWF  xB8,F
02826:  BZ    2834
02828:  BTFSS  xB7.7
0282A:  BRA    284C
0282C:  MOVF   FD8,W
0282E:  XORLW  01
02830:  MOVWF  FD8
02832:  BRA    284C
02834:  MOVFF  6B6,6B8
02838:  MOVF   xB2,W
0283A:  SUBWF  xB8,F
0283C:  BZ    284A
0283E:  BTFSS  xB7.7
02840:  BRA    284C
02842:  MOVF   FD8,W
02844:  XORLW  01
02846:  MOVWF  FD8
02848:  BRA    284C
0284A:  BCF    FD8.0
0284C:  MOVLB  0
0284E:  RETURN 0
02850:  MOVLB  6
02852:  MOVF   xA8,W
02854:  BTFSC  FD8.2
02856:  BRA    29A2
02858:  MOVWF  xB4
0285A:  MOVF   xAC,W
0285C:  BTFSC  FD8.2
0285E:  BRA    29A2
02860:  SUBWF  xB4,F
02862:  BNC   286E
02864:  MOVLW  7F
02866:  ADDWF  xB4,F
02868:  BTFSC  FD8.0
0286A:  BRA    29A2
0286C:  BRA    287A
0286E:  MOVLW  81
02870:  SUBWF  xB4,F
02872:  BTFSS  FD8.0
02874:  BRA    29A2
02876:  BTFSC  FD8.2
02878:  BRA    29A2
0287A:  MOVFF  6B4,00
0287E:  CLRF   01
02880:  CLRF   02
02882:  CLRF   03
02884:  CLRF   xB3
02886:  MOVFF  6A9,6B2
0288A:  BSF    xB2.7
0288C:  MOVFF  6AA,6B1
02890:  MOVFF  6AB,6B0
02894:  MOVLW  19
02896:  MOVWF  xB4
02898:  MOVF   xAF,W
0289A:  SUBWF  xB0,F
0289C:  BC    28B8
0289E:  MOVLW  01
028A0:  SUBWF  xB1,F
028A2:  BC    28B8
028A4:  SUBWF  xB2,F
028A6:  BC    28B8
028A8:  SUBWF  xB3,F
028AA:  BC    28B8
028AC:  INCF   xB3,F
028AE:  INCF   xB2,F
028B0:  INCF   xB1,F
028B2:  MOVF   xAF,W
028B4:  ADDWF  xB0,F
028B6:  BRA    2908
028B8:  MOVF   xAE,W
028BA:  SUBWF  xB1,F
028BC:  BC    28E2
028BE:  MOVLW  01
028C0:  SUBWF  xB2,F
028C2:  BC    28E2
028C4:  SUBWF  xB3,F
028C6:  BC    28E2
028C8:  INCF   xB3,F
028CA:  INCF   xB2,F
028CC:  MOVF   xAE,W
028CE:  ADDWF  xB1,F
028D0:  MOVF   xAF,W
028D2:  ADDWF  xB0,F
028D4:  BNC   2908
028D6:  INCF   xB1,F
028D8:  BNZ   2908
028DA:  INCF   xB2,F
028DC:  BNZ   2908
028DE:  INCF   xB3,F
028E0:  BRA    2908
028E2:  MOVF   xAD,W
028E4:  IORLW  80
028E6:  SUBWF  xB2,F
028E8:  BC    2906
028EA:  MOVLW  01
028EC:  SUBWF  xB3,F
028EE:  BC    2906
028F0:  INCF   xB3,F
028F2:  MOVF   xAD,W
028F4:  IORLW  80
028F6:  ADDWF  xB2,F
028F8:  MOVF   xAE,W
028FA:  ADDWF  xB1,F
028FC:  BNC   28D0
028FE:  INCF   xB2,F
02900:  BNZ   28D0
02902:  INCF   xB3,F
02904:  BRA    28D0
02906:  BSF    03.0
02908:  DECFSZ xB4,F
0290A:  BRA    290E
0290C:  BRA    2924
0290E:  BCF    FD8.0
02910:  RLCF   xB0,F
02912:  RLCF   xB1,F
02914:  RLCF   xB2,F
02916:  RLCF   xB3,F
02918:  BCF    FD8.0
0291A:  RLCF   03,F
0291C:  RLCF   02,F
0291E:  RLCF   01,F
02920:  RLCF   xB5,F
02922:  BRA    2898
02924:  BTFSS  xB5.0
02926:  BRA    2934
02928:  BCF    FD8.0
0292A:  RRCF   01,F
0292C:  RRCF   02,F
0292E:  RRCF   03,F
02930:  RRCF   xB5,F
02932:  BRA    2938
02934:  DECF   00,F
02936:  BZ    29A2
02938:  BTFSC  xB5.7
0293A:  BRA    2978
0293C:  BCF    FD8.0
0293E:  RLCF   xB0,F
02940:  RLCF   xB1,F
02942:  RLCF   xB2,F
02944:  RLCF   xB3,F
02946:  MOVF   xAF,W
02948:  SUBWF  xB0,F
0294A:  BC    295A
0294C:  MOVLW  01
0294E:  SUBWF  xB1,F
02950:  BC    295A
02952:  SUBWF  xB2,F
02954:  BC    295A
02956:  SUBWF  xB3,F
02958:  BNC   298E
0295A:  MOVF   xAE,W
0295C:  SUBWF  xB1,F
0295E:  BC    296A
02960:  MOVLW  01
02962:  SUBWF  xB2,F
02964:  BC    296A
02966:  SUBWF  xB3,F
02968:  BNC   298E
0296A:  MOVF   xAD,W
0296C:  IORLW  80
0296E:  SUBWF  xB2,F
02970:  BC    2978
02972:  MOVLW  01
02974:  SUBWF  xB3,F
02976:  BNC   298E
02978:  INCF   03,F
0297A:  BNZ   298E
0297C:  INCF   02,F
0297E:  BNZ   298E
02980:  INCF   01,F
02982:  BNZ   298E
02984:  INCF   00,F
02986:  BZ    29A2
02988:  RRCF   01,F
0298A:  RRCF   02,F
0298C:  RRCF   03,F
0298E:  MOVFF  6A9,6B4
02992:  MOVF   xAD,W
02994:  XORWF  xB4,F
02996:  BTFSS  xB4.7
02998:  BRA    299E
0299A:  BSF    01.7
0299C:  BRA    29AA
0299E:  BCF    01.7
029A0:  BRA    29AA
029A2:  CLRF   00
029A4:  CLRF   01
029A6:  CLRF   02
029A8:  CLRF   03
029AA:  MOVLB  0
029AC:  RETURN 0
*
03158:  ADDWF  FE8,W
0315A:  CLRF   FF7
0315C:  RLCF   FF7,F
0315E:  ADDLW  73
03160:  MOVWF  FF6
03162:  MOVLW  31
03164:  ADDWFC FF7,F
03166:  TBLRD*-
03168:  MOVF   FF5,W
0316A:  MOVWF  FFA
0316C:  TBLRD*
0316E:  MOVF   FF5,W
03170:  MOVWF  FF9
03172:  DATA 60,30
03174:  DATA 7A,30
03176:  DATA CE,30
03178:  DATA 32,31
0317A:  MOVLW  8E
0317C:  MOVWF  00
0317E:  MOVFF  6A6,01
03182:  MOVFF  6A5,02
03186:  CLRF   03
03188:  BTFSS  01.7
0318A:  BRA    3196
0318C:  COMF   01,F
0318E:  COMF   02,F
03190:  INCF   02,F
03192:  BNZ   3196
03194:  INCF   01,F
03196:  MOVF   01,F
03198:  BNZ   31AC
0319A:  MOVFF  02,01
0319E:  CLRF   02
031A0:  MOVLW  08
031A2:  SUBWF  00,F
031A4:  MOVF   01,F
031A6:  BNZ   31AC
031A8:  CLRF   00
031AA:  BRA    31C8
031AC:  BCF    FD8.0
031AE:  BTFSC  01.7
031B0:  BRA    31BA
031B2:  RLCF   02,F
031B4:  RLCF   01,F
031B6:  DECF   00,F
031B8:  BRA    31AC
031BA:  MOVLB  6
031BC:  BTFSS  xA6.7
031BE:  BRA    31C4
031C0:  MOVLB  0
031C2:  BRA    31C8
031C4:  BCF    01.7
031C6:  MOVLB  0
031C8:  RETURN 0
031CA:  MOVLW  8E
031CC:  MOVWF  00
031CE:  MOVLB  6
031D0:  MOVF   xAF,W
031D2:  SUBWF  00,F
031D4:  MOVFF  6B0,02
031D8:  MOVFF  6B1,01
031DC:  BSF    02.7
031DE:  MOVF   00,F
031E0:  BZ    31F4
031E2:  BCF    FD8.0
031E4:  MOVF   02,F
031E6:  BNZ   31EC
031E8:  MOVF   01,F
031EA:  BZ    31F4
031EC:  RRCF   02,F
031EE:  RRCF   01,F
031F0:  DECFSZ 00,F
031F2:  BRA    31E2
031F4:  BTFSS  xB0.7
031F6:  BRA    3202
031F8:  COMF   01,F
031FA:  COMF   02,F
031FC:  INCF   01,F
031FE:  BTFSC  FD8.2
03200:  INCF   02,F
03202:  MOVLB  0
03204:  RETURN 0
*
05042:  MOVLB  6
05044:  MOVF   x71,W
05046:  ANDLW  07
05048:  MOVWF  00
0504A:  RRCF   x71,W
0504C:  MOVWF  01
0504E:  RRCF   01,F
05050:  RRCF   01,F
05052:  MOVLW  1F
05054:  ANDWF  01,F
05056:  MOVF   01,W
05058:  ADDWF  x72,W
0505A:  MOVWF  FE9
0505C:  MOVLW  00
0505E:  ADDWFC x73,W
05060:  MOVWF  FEA
05062:  MOVFF  FEF,01
05066:  INCF   00,F
05068:  BRA    506C
0506A:  RRCF   01,F
0506C:  DECFSZ 00,F
0506E:  BRA    506A
05070:  MOVLW  01
05072:  ANDWF  01,F
05074:  MOVLB  0
05076:  RETURN 0
*
05A78:  MOVF   FEF,F
05A7A:  BZ    5A9A
05A7C:  MOVFF  FEA,66A
05A80:  MOVFF  FE9,669
05A84:  MOVFF  FEF,67A
05A88:  RCALL  5A50
05A8A:  MOVFF  66A,FEA
05A8E:  MOVFF  669,FE9
05A92:  INCF   FE9,F
05A94:  BTFSC  FD8.2
05A96:  INCF   FEA,F
05A98:  BRA    5A78
05A9A:  RETURN 0
*
05F94:  TBLRD*+
05F96:  MOVFF  FF6,66E
05F9A:  MOVFF  FF7,66F
05F9E:  MOVFF  FF5,67A
05FA2:  RCALL  5A50
05FA4:  MOVFF  66E,FF6
05FA8:  MOVFF  66F,FF7
05FAC:  MOVLB  6
05FAE:  DECFSZ x6D,F
05FB0:  BRA    5FB4
05FB2:  BRA    5FB8
05FB4:  MOVLB  0
05FB6:  BRA    5F94
05FB8:  MOVLB  0
05FBA:  RETURN 0
05FBC:  MOVLB  6
05FBE:  MOVF   x9F,W
05FC0:  CLRF   01
05FC2:  SUBWF  x9E,W
05FC4:  BC    5FCC
05FC6:  MOVFF  69E,00
05FCA:  BRA    5FE4
05FCC:  CLRF   00
05FCE:  MOVLW  08
05FD0:  MOVWF  xA0
05FD2:  RLCF   x9E,F
05FD4:  RLCF   00,F
05FD6:  MOVF   x9F,W
05FD8:  SUBWF  00,W
05FDA:  BTFSC  FD8.0
05FDC:  MOVWF  00
05FDE:  RLCF   01,F
05FE0:  DECFSZ xA0,F
05FE2:  BRA    5FD2
05FE4:  MOVLB  0
05FE6:  RETURN 0
05FE8:  MOVF   01,W
05FEA:  MOVFF  66D,69E
05FEE:  MOVLW  64
05FF0:  MOVLB  6
05FF2:  MOVWF  x9F
05FF4:  MOVLB  0
05FF6:  RCALL  5FBC
05FF8:  MOVFF  00,66D
05FFC:  MOVF   01,W
05FFE:  MOVLW  30
06000:  BNZ   6012
06002:  MOVLB  6
06004:  BTFSS  x6E.1
06006:  BRA    6026
06008:  BTFSC  x6E.3
0600A:  BRA    6026
0600C:  BTFSC  x6E.4
0600E:  MOVLW  20
06010:  BRA    601A
06012:  MOVLB  6
06014:  BCF    x6E.3
06016:  BCF    x6E.4
06018:  BSF    x6E.0
0601A:  ADDWF  01,F
0601C:  MOVFF  01,67A
06020:  MOVLB  0
06022:  RCALL  5A50
06024:  MOVLB  6
06026:  MOVFF  66D,69E
0602A:  MOVLW  0A
0602C:  MOVWF  x9F
0602E:  MOVLB  0
06030:  RCALL  5FBC
06032:  MOVFF  00,66D
06036:  MOVF   01,W
06038:  MOVLW  30
0603A:  BNZ   604C
0603C:  MOVLB  6
0603E:  BTFSC  x6E.3
06040:  BRA    6056
06042:  BTFSS  x6E.0
06044:  BRA    6056
06046:  BTFSC  x6E.4
06048:  MOVLW  20
0604A:  MOVLB  0
0604C:  ADDWF  01,F
0604E:  MOVFF  01,67A
06052:  RCALL  5A50
06054:  MOVLB  6
06056:  MOVLW  30
06058:  ADDWF  x6D,F
0605A:  MOVFF  66D,67A
0605E:  MOVLB  0
06060:  RCALL  5A50
06062:  RETURN 0
06064:  MOVLB  6
06066:  MOVF   xB4,W
06068:  SUBLW  B6
0606A:  MOVWF  xB4
0606C:  CLRF   03
0606E:  MOVFF  6B5,6B8
06072:  BSF    xB5.7
06074:  BCF    FD8.0
06076:  RRCF   xB5,F
06078:  RRCF   xB6,F
0607A:  RRCF   xB7,F
0607C:  RRCF   03,F
0607E:  RRCF   02,F
06080:  RRCF   01,F
06082:  RRCF   00,F
06084:  DECFSZ xB4,F
06086:  BRA    6074
06088:  BTFSS  xB8.7
0608A:  BRA    60A2
0608C:  COMF   00,F
0608E:  COMF   01,F
06090:  COMF   02,F
06092:  COMF   03,F
06094:  INCF   00,F
06096:  BTFSC  FD8.2
06098:  INCF   01,F
0609A:  BTFSC  FD8.2
0609C:  INCF   02,F
0609E:  BTFSC  FD8.2
060A0:  INCF   03,F
060A2:  MOVLB  0
060A4:  RETURN 0
060A6:  BTFSC  FD8.1
060A8:  BRA    60B2
060AA:  MOVLW  06
060AC:  MOVWF  FEA
060AE:  MOVLW  BC
060B0:  MOVWF  FE9
060B2:  CLRF   00
060B4:  CLRF   01
060B6:  CLRF   02
060B8:  CLRF   03
060BA:  MOVLB  6
060BC:  CLRF   xBC
060BE:  CLRF   xBD
060C0:  CLRF   xBE
060C2:  CLRF   xBF
060C4:  MOVF   xBB,W
060C6:  IORWF  xBA,W
060C8:  IORWF  xB9,W
060CA:  IORWF  xB8,W
060CC:  BZ    6126
060CE:  MOVLW  20
060D0:  MOVWF  xC0
060D2:  BCF    FD8.0
060D4:  RLCF   xB4,F
060D6:  RLCF   xB5,F
060D8:  RLCF   xB6,F
060DA:  RLCF   xB7,F
060DC:  RLCF   xBC,F
060DE:  RLCF   xBD,F
060E0:  RLCF   xBE,F
060E2:  RLCF   xBF,F
060E4:  MOVF   xBB,W
060E6:  SUBWF  xBF,W
060E8:  BNZ   60FA
060EA:  MOVF   xBA,W
060EC:  SUBWF  xBE,W
060EE:  BNZ   60FA
060F0:  MOVF   xB9,W
060F2:  SUBWF  xBD,W
060F4:  BNZ   60FA
060F6:  MOVF   xB8,W
060F8:  SUBWF  xBC,W
060FA:  BNC   611A
060FC:  MOVF   xB8,W
060FE:  SUBWF  xBC,F
06100:  MOVF   xB9,W
06102:  BTFSS  FD8.0
06104:  INCFSZ xB9,W
06106:  SUBWF  xBD,F
06108:  MOVF   xBA,W
0610A:  BTFSS  FD8.0
0610C:  INCFSZ xBA,W
0610E:  SUBWF  xBE,F
06110:  MOVF   xBB,W
06112:  BTFSS  FD8.0
06114:  INCFSZ xBB,W
06116:  SUBWF  xBF,F
06118:  BSF    FD8.0
0611A:  RLCF   00,F
0611C:  RLCF   01,F
0611E:  RLCF   02,F
06120:  RLCF   03,F
06122:  DECFSZ xC0,F
06124:  BRA    60D2
06126:  MOVFF  6BC,FEF
0612A:  MOVFF  6BD,FEC
0612E:  MOVFF  6BE,FEC
06132:  MOVFF  6BF,FEC
06136:  MOVLB  0
06138:  RETURN 0
0613A:  MOVF   FE9,W
0613C:  MOVLB  6
0613E:  MOVWF  x72
06140:  MOVF   x71,W
06142:  MOVWF  x74
06144:  BZ    617E
06146:  MOVFF  670,6B7
0614A:  MOVFF  66F,6B6
0614E:  MOVFF  66E,6B5
06152:  MOVFF  66D,6B4
06156:  CLRF   xBB
06158:  CLRF   xBA
0615A:  MOVLW  20
0615C:  MOVWF  xB9
0615E:  MOVLW  82
06160:  MOVWF  xB8
06162:  MOVLB  0
06164:  CALL   130A
06168:  MOVFF  03,670
0616C:  MOVFF  02,66F
06170:  MOVFF  01,66E
06174:  MOVFF  00,66D
06178:  MOVLB  6
0617A:  DECFSZ x74,F
0617C:  BRA    6146
0617E:  MOVFF  670,6B7
06182:  MOVFF  66F,6B6
06186:  MOVFF  66E,6B5
0618A:  MOVFF  66D,6B4
0618E:  MOVLB  0
06190:  RCALL  6064
06192:  MOVFF  03,670
06196:  MOVFF  02,66F
0619A:  MOVFF  01,66E
0619E:  MOVFF  00,66D
061A2:  MOVLB  6
061A4:  BTFSS  x70.7
061A6:  BRA    61C2
061A8:  DECF   x72,F
061AA:  BSF    x72.5
061AC:  COMF   x6D,F
061AE:  COMF   x6E,F
061B0:  COMF   x6F,F
061B2:  COMF   x70,F
061B4:  INCF   x6D,F
061B6:  BTFSC  FD8.2
061B8:  INCF   x6E,F
061BA:  BTFSC  FD8.2
061BC:  INCF   x6F,F
061BE:  BTFSC  FD8.2
061C0:  INCF   x70,F
061C2:  MOVLW  3B
061C4:  MOVWF  x79
061C6:  MOVLW  9A
061C8:  MOVWF  x78
061CA:  MOVLW  CA
061CC:  MOVWF  x77
061CE:  CLRF   x76
061D0:  MOVLW  0A
061D2:  MOVWF  x74
061D4:  MOVF   x71,W
061D6:  BTFSC  FD8.2
061D8:  INCF   x72,F
061DA:  BSF    FD8.1
061DC:  MOVLW  06
061DE:  MOVWF  FEA
061E0:  MOVLW  6D
061E2:  MOVWF  FE9
061E4:  MOVFF  670,6B7
061E8:  MOVFF  66F,6B6
061EC:  MOVFF  66E,6B5
061F0:  MOVFF  66D,6B4
061F4:  MOVFF  679,6BB
061F8:  MOVFF  678,6BA
061FC:  MOVFF  677,6B9
06200:  MOVFF  676,6B8
06204:  MOVLB  0
06206:  RCALL  60A6
06208:  MOVF   01,W
0620A:  MOVF   00,F
0620C:  BNZ   6234
0620E:  MOVLB  6
06210:  INCF   x71,W
06212:  SUBWF  x74,W
06214:  BTFSS  FD8.2
06216:  BRA    621C
06218:  MOVLB  0
0621A:  BRA    6234
0621C:  MOVF   x72,W
0621E:  BZ    623A
06220:  ANDLW  0F
06222:  SUBWF  x74,W
06224:  BZ    6228
06226:  BC    62B0
06228:  BTFSC  x72.7
0622A:  BRA    62B0
0622C:  BTFSC  x72.6
0622E:  BRA    623A
06230:  MOVLW  20
06232:  BRA    62A2
06234:  MOVLW  20
06236:  MOVLB  6
06238:  ANDWF  x72,F
0623A:  BTFSS  x72.5
0623C:  BRA    625C
0623E:  BCF    x72.5
06240:  MOVF   x71,W
06242:  BTFSS  FD8.2
06244:  DECF   x72,F
06246:  MOVF   00,W
06248:  MOVWF  x72
0624A:  MOVLW  2D
0624C:  MOVWF  x7A
0624E:  MOVLB  0
06250:  CALL   5A50
06254:  MOVLB  6
06256:  MOVF   x72,W
06258:  MOVWF  00
0625A:  CLRF   x72
0625C:  MOVF   x71,W
0625E:  SUBWF  x74,W
06260:  BNZ   627C
06262:  MOVF   00,W
06264:  MOVWF  x72
06266:  MOVLW  2E
06268:  MOVWF  x7A
0626A:  MOVLB  0
0626C:  CALL   5A50
06270:  MOVLB  6
06272:  MOVF   x72,W
06274:  MOVWF  00
06276:  MOVLW  20
06278:  ANDWF  x72,F
0627A:  MOVLW  00
0627C:  MOVLW  30
0627E:  BTFSS  x72.5
06280:  BRA    62A2
06282:  BCF    x72.5
06284:  MOVF   x71,W
06286:  BTFSS  FD8.2
06288:  DECF   x72,F
0628A:  MOVF   00,W
0628C:  MOVWF  x72
0628E:  MOVLW  2D
06290:  MOVWF  x7A
06292:  MOVLB  0
06294:  CALL   5A50
06298:  MOVLB  6
0629A:  MOVF   x72,W
0629C:  MOVWF  00
0629E:  CLRF   x72
062A0:  MOVLW  30
062A2:  ADDWF  00,F
062A4:  MOVFF  00,67A
062A8:  MOVLB  0
062AA:  CALL   5A50
062AE:  MOVLB  6
062B0:  BCF    FD8.1
062B2:  MOVFF  679,6B7
062B6:  MOVFF  678,6B6
062BA:  MOVFF  677,6B5
062BE:  MOVFF  676,6B4
062C2:  CLRF   xBB
062C4:  CLRF   xBA
062C6:  CLRF   xB9
062C8:  MOVLW  0A
062CA:  MOVWF  xB8
062CC:  MOVLB  0
062CE:  RCALL  60A6
062D0:  MOVFF  03,679
062D4:  MOVFF  02,678
062D8:  MOVFF  01,677
062DC:  MOVFF  00,676
062E0:  MOVLB  6
062E2:  DECFSZ x74,F
062E4:  BRA    61DA
062E6:  MOVLB  0
062E8:  RETURN 0
062EA:  MOVFF  FEA,671
062EE:  MOVFF  FE9,670
062F2:  MOVLB  6
062F4:  SWAPF  x6A,W
062F6:  IORLW  F0
062F8:  MOVWF  x6C
062FA:  ADDWF  x6C,F
062FC:  ADDLW  E2
062FE:  MOVWF  x6D
06300:  ADDLW  32
06302:  MOVWF  x6F
06304:  MOVF   x6A,W
06306:  ANDLW  0F
06308:  ADDWF  x6D,F
0630A:  ADDWF  x6D,F
0630C:  ADDWF  x6F,F
0630E:  ADDLW  E9
06310:  MOVWF  x6E
06312:  ADDWF  x6E,F
06314:  ADDWF  x6E,F
06316:  SWAPF  x69,W
06318:  ANDLW  0F
0631A:  ADDWF  x6E,F
0631C:  ADDWF  x6F,F
0631E:  RLCF   x6E,F
06320:  RLCF   x6F,F
06322:  COMF   x6F,F
06324:  RLCF   x6F,F
06326:  MOVF   x69,W
06328:  ANDLW  0F
0632A:  ADDWF  x6F,F
0632C:  RLCF   x6C,F
0632E:  MOVLW  07
06330:  MOVWF  x6B
06332:  MOVLW  0A
06334:  DECF   x6E,F
06336:  ADDWF  x6F,F
06338:  BNC   6334
0633A:  DECF   x6D,F
0633C:  ADDWF  x6E,F
0633E:  BNC   633A
06340:  DECF   x6C,F
06342:  ADDWF  x6D,F
06344:  BNC   6340
06346:  DECF   x6B,F
06348:  ADDWF  x6C,F
0634A:  BNC   6346
0634C:  MOVLW  06
0634E:  MOVWF  FEA
06350:  MOVLW  6B
06352:  MOVWF  FE9
06354:  MOVLW  07
06356:  ANDWF  x70,W
06358:  BCF    x70.6
0635A:  ADDWF  FE9,F
0635C:  MOVLW  00
0635E:  ADDWFC FEA,F
06360:  MOVF   FE9,W
06362:  SUBLW  6F
06364:  BNZ   636E
06366:  MOVF   FEA,W
06368:  SUBLW  06
0636A:  BNZ   636E
0636C:  BSF    x70.6
0636E:  MOVF   FEF,W
06370:  MOVWF  00
06372:  BNZ   6384
06374:  BTFSC  x70.6
06376:  BRA    6384
06378:  BTFSC  x70.4
0637A:  BRA    63A8
0637C:  BTFSC  x70.3
0637E:  BRA    6384
06380:  MOVLW  20
06382:  BRA    638A
06384:  BSF    x70.3
06386:  BCF    x70.4
06388:  MOVLW  30
0638A:  ADDWF  00,F
0638C:  MOVFF  FEA,66A
06390:  MOVFF  FE9,669
06394:  MOVFF  00,67A
06398:  MOVLB  0
0639A:  CALL   5A50
0639E:  MOVFF  66A,FEA
063A2:  MOVFF  669,FE9
063A6:  MOVLB  6
063A8:  MOVF   FEE,W
063AA:  BTFSS  x70.6
063AC:  BRA    6360
063AE:  MOVLB  0
063B0:  RETURN 0
*
064F6:  MOVFF  557,FEA
064FA:  MOVFF  556,FE9
064FE:  MOVFF  6B4,FEF
06502:  INCF   FE9,F
06504:  BTFSC  FD8.2
06506:  INCF   FEA,F
06508:  CLRF   FEF
0650A:  MOVLB  5
0650C:  INCF   x56,F
0650E:  BTFSC  FD8.2
06510:  INCF   x57,F
06512:  MOVLB  0
06514:  RETURN 0
06516:  TBLRD*+
06518:  MOVF   FF5,F
0651A:  BZ    6534
0651C:  MOVFF  FF6,672
06520:  MOVFF  FF7,673
06524:  MOVFF  FF5,6B4
06528:  RCALL  64F6
0652A:  MOVFF  672,FF6
0652E:  MOVFF  673,FF7
06532:  BRA    6516
06534:  RETURN 0
*
06658:  MOVLB  6
0665A:  MOVF   xCC,W
0665C:  XORWF  xCE,W
0665E:  ANDLW  80
06660:  MOVWF  xD0
06662:  BTFSS  xCC.7
06664:  BRA    6670
06666:  COMF   xCB,F
06668:  COMF   xCC,F
0666A:  INCF   xCB,F
0666C:  BTFSC  FD8.2
0666E:  INCF   xCC,F
06670:  BTFSS  xCE.7
06672:  BRA    667E
06674:  COMF   xCD,F
06676:  COMF   xCE,F
06678:  INCF   xCD,F
0667A:  BTFSC  FD8.2
0667C:  INCF   xCE,F
0667E:  MOVF   xCB,W
06680:  MULWF  xCD
06682:  MOVFF  FF3,01
06686:  MOVFF  FF4,00
0668A:  MULWF  xCE
0668C:  MOVF   FF3,W
0668E:  ADDWF  00,F
06690:  MOVF   xCC,W
06692:  MULWF  xCD
06694:  MOVF   FF3,W
06696:  ADDWFC 00,W
06698:  MOVWF  02
0669A:  BTFSS  xD0.7
0669C:  BRA    66A8
0669E:  COMF   01,F
066A0:  COMF   02,F
066A2:  INCF   01,F
066A4:  BTFSC  FD8.2
066A6:  INCF   02,F
066A8:  MOVLB  0
066AA:  GOTO   693E (RETURN)
*
06A02:  MOVLW  20
06A04:  MOVLB  6
06A06:  BTFSS  x99.4
06A08:  MOVLW  30
06A0A:  MOVWF  x9A
06A0C:  MOVFF  698,00
06A10:  BTFSS  00.7
06A12:  BRA    6A24
06A14:  COMF   00,F
06A16:  INCF   00,F
06A18:  MOVFF  00,698
06A1C:  MOVLW  2D
06A1E:  MOVWF  x9A
06A20:  BSF    x99.7
06A22:  BSF    x99.0
06A24:  MOVF   01,W
06A26:  MOVFF  698,69E
06A2A:  MOVLW  64
06A2C:  MOVWF  x9F
06A2E:  MOVLB  0
06A30:  CALL   5FBC
06A34:  MOVFF  00,698
06A38:  MOVLW  30
06A3A:  ADDWF  01,W
06A3C:  MOVLB  6
06A3E:  MOVWF  x9B
06A40:  MOVFF  698,69E
06A44:  MOVLW  0A
06A46:  MOVWF  x9F
06A48:  MOVLB  0
06A4A:  CALL   5FBC
06A4E:  MOVLW  30
06A50:  ADDWF  00,W
06A52:  MOVLB  6
06A54:  MOVWF  x9D
06A56:  MOVLW  30
06A58:  ADDWF  01,W
06A5A:  MOVWF  x9C
06A5C:  MOVFF  69A,00
06A60:  MOVLW  30
06A62:  SUBWF  x9B,W
06A64:  BZ    6A6E
06A66:  BSF    x99.1
06A68:  BTFSC  x99.7
06A6A:  BSF    x99.2
06A6C:  BRA    6A92
06A6E:  MOVFF  69A,69B
06A72:  MOVLW  20
06A74:  MOVWF  x9A
06A76:  MOVLW  30
06A78:  SUBWF  x9C,W
06A7A:  BZ    6A84
06A7C:  BSF    x99.0
06A7E:  BTFSC  x99.7
06A80:  BSF    x99.1
06A82:  BRA    6A92
06A84:  BTFSS  FD8.2
06A86:  BSF    x99.0
06A88:  BNZ   6A92
06A8A:  MOVFF  69B,69C
06A8E:  MOVLW  20
06A90:  MOVWF  x9B
06A92:  BTFSC  x99.2
06A94:  BRA    6AA0
06A96:  BTFSC  x99.1
06A98:  BRA    6AA8
06A9A:  BTFSC  x99.0
06A9C:  BRA    6AB0
06A9E:  BRA    6AB8
06AA0:  MOVFF  69A,6B4
06AA4:  MOVLB  0
06AA6:  RCALL  64F6
06AA8:  MOVFF  69B,6B4
06AAC:  MOVLB  0
06AAE:  RCALL  64F6
06AB0:  MOVFF  69C,6B4
06AB4:  MOVLB  0
06AB6:  RCALL  64F6
06AB8:  MOVFF  69D,6B4
06ABC:  MOVLB  0
06ABE:  RCALL  64F6
06AC0:  RETURN 0
*
06C5E:  MOVLB  6
06C60:  MOVF   x86,W
06C62:  ANDLW  07
06C64:  MOVWF  00
06C66:  RRCF   x86,W
06C68:  MOVWF  01
06C6A:  RRCF   01,F
06C6C:  RRCF   01,F
06C6E:  MOVLW  1F
06C70:  ANDWF  01,F
06C72:  MOVF   01,W
06C74:  ADDWF  x88,W
06C76:  MOVWF  FE9
06C78:  MOVLW  00
06C7A:  ADDWFC x89,W
06C7C:  MOVWF  FEA
06C7E:  CLRF   01
06C80:  INCF   01,F
06C82:  INCF   00,F
06C84:  BRA    6C88
06C86:  RLCF   01,F
06C88:  DECFSZ 00,F
06C8A:  BRA    6C86
06C8C:  MOVF   x87,F
06C8E:  BZ    6C96
06C90:  MOVF   01,W
06C92:  IORWF  FEF,F
06C94:  BRA    6C9C
06C96:  COMF   01,F
06C98:  MOVF   01,W
06C9A:  ANDWF  FEF,F
06C9C:  MOVLB  0
06C9E:  RETURN 0
*
06E4E:  TBLRD*+
06E50:  MOVFF  FF6,674
06E54:  MOVFF  FF7,675
06E58:  MOVFF  FF5,6B4
06E5C:  CALL   64F6
06E60:  MOVFF  674,FF6
06E64:  MOVFF  675,FF7
06E68:  MOVLB  6
06E6A:  DECFSZ x73,F
06E6C:  BRA    6E70
06E6E:  BRA    6E74
06E70:  MOVLB  0
06E72:  BRA    6E4E
06E74:  MOVLB  0
06E76:  RETURN 0
*
0721E:  MOVF   FE9,W
07220:  MOVLB  6
07222:  MOVWF  xAC
07224:  MOVF   xAB,W
07226:  MOVWF  xAE
07228:  BZ    7262
0722A:  MOVFF  6AA,6B7
0722E:  MOVFF  6A9,6B6
07232:  MOVFF  6A8,6B5
07236:  MOVFF  6A7,6B4
0723A:  CLRF   xBB
0723C:  CLRF   xBA
0723E:  MOVLW  20
07240:  MOVWF  xB9
07242:  MOVLW  82
07244:  MOVWF  xB8
07246:  MOVLB  0
07248:  CALL   130A
0724C:  MOVFF  03,6AA
07250:  MOVFF  02,6A9
07254:  MOVFF  01,6A8
07258:  MOVFF  00,6A7
0725C:  MOVLB  6
0725E:  DECFSZ xAE,F
07260:  BRA    722A
07262:  MOVFF  6AA,6B7
07266:  MOVFF  6A9,6B6
0726A:  MOVFF  6A8,6B5
0726E:  MOVFF  6A7,6B4
07272:  MOVLB  0
07274:  CALL   6064
07278:  MOVFF  03,6AA
0727C:  MOVFF  02,6A9
07280:  MOVFF  01,6A8
07284:  MOVFF  00,6A7
07288:  MOVLB  6
0728A:  BTFSS  xAA.7
0728C:  BRA    72A8
0728E:  DECF   xAC,F
07290:  BSF    xAC.5
07292:  COMF   xA7,F
07294:  COMF   xA8,F
07296:  COMF   xA9,F
07298:  COMF   xAA,F
0729A:  INCF   xA7,F
0729C:  BTFSC  FD8.2
0729E:  INCF   xA8,F
072A0:  BTFSC  FD8.2
072A2:  INCF   xA9,F
072A4:  BTFSC  FD8.2
072A6:  INCF   xAA,F
072A8:  MOVLW  3B
072AA:  MOVWF  xB3
072AC:  MOVLW  9A
072AE:  MOVWF  xB2
072B0:  MOVLW  CA
072B2:  MOVWF  xB1
072B4:  CLRF   xB0
072B6:  MOVLW  0A
072B8:  MOVWF  xAE
072BA:  MOVF   xAB,W
072BC:  BTFSC  FD8.2
072BE:  INCF   xAC,F
072C0:  BSF    FD8.1
072C2:  MOVLW  06
072C4:  MOVWF  FEA
072C6:  MOVLW  A7
072C8:  MOVWF  FE9
072CA:  MOVFF  6AA,6B7
072CE:  MOVFF  6A9,6B6
072D2:  MOVFF  6A8,6B5
072D6:  MOVFF  6A7,6B4
072DA:  MOVFF  6B3,6BB
072DE:  MOVFF  6B2,6BA
072E2:  MOVFF  6B1,6B9
072E6:  MOVFF  6B0,6B8
072EA:  MOVLB  0
072EC:  CALL   60A6
072F0:  MOVF   01,W
072F2:  MOVF   00,F
072F4:  BNZ   731C
072F6:  MOVLB  6
072F8:  INCF   xAB,W
072FA:  SUBWF  xAE,W
072FC:  BTFSS  FD8.2
072FE:  BRA    7304
07300:  MOVLB  0
07302:  BRA    731C
07304:  MOVF   xAC,W
07306:  BZ    7322
07308:  ANDLW  0F
0730A:  SUBWF  xAE,W
0730C:  BZ    7310
0730E:  BC    7398
07310:  BTFSC  xAC.7
07312:  BRA    7398
07314:  BTFSC  xAC.6
07316:  BRA    7322
07318:  MOVLW  20
0731A:  BRA    738A
0731C:  MOVLW  20
0731E:  MOVLB  6
07320:  ANDWF  xAC,F
07322:  BTFSS  xAC.5
07324:  BRA    7344
07326:  BCF    xAC.5
07328:  MOVF   xAB,W
0732A:  BTFSS  FD8.2
0732C:  DECF   xAC,F
0732E:  MOVF   00,W
07330:  MOVWF  xAC
07332:  MOVLW  2D
07334:  MOVWF  xB4
07336:  MOVLB  0
07338:  CALL   64F6
0733C:  MOVLB  6
0733E:  MOVF   xAC,W
07340:  MOVWF  00
07342:  CLRF   xAC
07344:  MOVF   xAB,W
07346:  SUBWF  xAE,W
07348:  BNZ   7364
0734A:  MOVF   00,W
0734C:  MOVWF  xAC
0734E:  MOVLW  2E
07350:  MOVWF  xB4
07352:  MOVLB  0
07354:  CALL   64F6
07358:  MOVLB  6
0735A:  MOVF   xAC,W
0735C:  MOVWF  00
0735E:  MOVLW  20
07360:  ANDWF  xAC,F
07362:  MOVLW  00
07364:  MOVLW  30
07366:  BTFSS  xAC.5
07368:  BRA    738A
0736A:  BCF    xAC.5
0736C:  MOVF   xAB,W
0736E:  BTFSS  FD8.2
07370:  DECF   xAC,F
07372:  MOVF   00,W
07374:  MOVWF  xAC
07376:  MOVLW  2D
07378:  MOVWF  xB4
0737A:  MOVLB  0
0737C:  CALL   64F6
07380:  MOVLB  6
07382:  MOVF   xAC,W
07384:  MOVWF  00
07386:  CLRF   xAC
07388:  MOVLW  30
0738A:  ADDWF  00,F
0738C:  MOVFF  00,6B4
07390:  MOVLB  0
07392:  CALL   64F6
07396:  MOVLB  6
07398:  BCF    FD8.1
0739A:  MOVFF  6B3,6B7
0739E:  MOVFF  6B2,6B6
073A2:  MOVFF  6B1,6B5
073A6:  MOVFF  6B0,6B4
073AA:  CLRF   xBB
073AC:  CLRF   xBA
073AE:  CLRF   xB9
073B0:  MOVLW  0A
073B2:  MOVWF  xB8
073B4:  MOVLB  0
073B6:  CALL   60A6
073BA:  MOVFF  03,6B3
073BE:  MOVFF  02,6B2
073C2:  MOVFF  01,6B1
073C6:  MOVFF  00,6B0
073CA:  MOVLB  6
073CC:  DECFSZ xAE,F
073CE:  BRA    72C0
073D0:  MOVLB  0
073D2:  RETURN 0
*
09E3C:  MOVF   FE9,W
09E3E:  MOVLB  6
09E40:  MOVWF  xA1
09E42:  BTFSS  xA0.7
09E44:  BRA    9E60
09E46:  DECF   xA1,F
09E48:  BSF    xA1.5
09E4A:  COMF   x9D,F
09E4C:  COMF   x9E,F
09E4E:  COMF   x9F,F
09E50:  COMF   xA0,F
09E52:  INCF   x9D,F
09E54:  BTFSC  FD8.2
09E56:  INCF   x9E,F
09E58:  BTFSC  FD8.2
09E5A:  INCF   x9F,F
09E5C:  BTFSC  FD8.2
09E5E:  INCF   xA0,F
09E60:  MOVLW  3B
09E62:  MOVWF  xA8
09E64:  MOVLW  9A
09E66:  MOVWF  xA7
09E68:  MOVLW  CA
09E6A:  MOVWF  xA6
09E6C:  CLRF   xA5
09E6E:  MOVLW  0A
09E70:  MOVWF  xA3
09E72:  BSF    FD8.1
09E74:  MOVLW  06
09E76:  MOVWF  FEA
09E78:  MOVLW  9D
09E7A:  MOVWF  FE9
09E7C:  MOVFF  6A0,6B7
09E80:  MOVFF  69F,6B6
09E84:  MOVFF  69E,6B5
09E88:  MOVFF  69D,6B4
09E8C:  MOVFF  6A8,6BB
09E90:  MOVFF  6A7,6BA
09E94:  MOVFF  6A6,6B9
09E98:  MOVFF  6A5,6B8
09E9C:  MOVLB  0
09E9E:  CALL   60A6
09EA2:  MOVF   01,W
09EA4:  MOVF   00,F
09EA6:  BNZ   9ECE
09EA8:  MOVLB  6
09EAA:  MOVF   xA3,W
09EAC:  XORLW  01
09EAE:  BTFSS  FD8.2
09EB0:  BRA    9EB6
09EB2:  MOVLB  0
09EB4:  BRA    9ECE
09EB6:  MOVF   xA1,W
09EB8:  BZ    9ED4
09EBA:  ANDLW  0F
09EBC:  SUBWF  xA3,W
09EBE:  BZ    9EC2
09EC0:  BC    9F1E
09EC2:  BTFSC  xA1.7
09EC4:  BRA    9F1E
09EC6:  BTFSC  xA1.6
09EC8:  BRA    9ED4
09ECA:  MOVLW  20
09ECC:  BRA    9F10
09ECE:  MOVLW  20
09ED0:  MOVLB  6
09ED2:  ANDWF  xA1,F
09ED4:  BTFSS  xA1.5
09ED6:  BRA    9EF0
09ED8:  BCF    xA1.5
09EDA:  MOVFF  00,6A1
09EDE:  MOVLW  2D
09EE0:  MOVWF  xB4
09EE2:  MOVLB  0
09EE4:  CALL   64F6
09EE8:  MOVLB  6
09EEA:  MOVFF  6A1,00
09EEE:  CLRF   xA1
09EF0:  MOVLW  30
09EF2:  BTFSS  xA1.5
09EF4:  BRA    9F10
09EF6:  BCF    xA1.5
09EF8:  MOVFF  00,6A1
09EFC:  MOVLW  2D
09EFE:  MOVWF  xB4
09F00:  MOVLB  0
09F02:  CALL   64F6
09F06:  MOVLB  6
09F08:  MOVFF  6A1,00
09F0C:  CLRF   xA1
09F0E:  MOVLW  30
09F10:  ADDWF  00,F
09F12:  MOVFF  00,6B4
09F16:  MOVLB  0
09F18:  CALL   64F6
09F1C:  MOVLB  6
09F1E:  BCF    FD8.1
09F20:  MOVFF  6A8,6B7
09F24:  MOVFF  6A7,6B6
09F28:  MOVFF  6A6,6B5
09F2C:  MOVFF  6A5,6B4
09F30:  CLRF   xBB
09F32:  CLRF   xBA
09F34:  CLRF   xB9
09F36:  MOVLW  0A
09F38:  MOVWF  xB8
09F3A:  MOVLB  0
09F3C:  CALL   60A6
09F40:  MOVFF  03,6A8
09F44:  MOVFF  02,6A7
09F48:  MOVFF  01,6A6
09F4C:  MOVFF  00,6A5
09F50:  MOVLB  6
09F52:  DECFSZ xA3,F
09F54:  BRA    9E72
09F56:  MOVLB  0
09F58:  RETURN 0
*
0AB9C:  MOVF   FEF,F
0AB9E:  BZ    ABC0
0ABA0:  MOVFF  FEA,66A
0ABA4:  MOVFF  FE9,669
0ABA8:  MOVFF  FEF,6B4
0ABAC:  CALL   64F6
0ABB0:  MOVFF  66A,FEA
0ABB4:  MOVFF  669,FE9
0ABB8:  INCF   FE9,F
0ABBA:  BTFSC  FD8.2
0ABBC:  INCF   FEA,F
0ABBE:  BRA    AB9C
0ABC0:  GOTO   AC3E (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00438:  MOVLW  06
0043A:  MOVWF  FEA
0043C:  MOVLW  6C
0043E:  MOVWF  FE9
00440:  MOVF   FEF,W
00442:  BZ    0460
00444:  MOVLW  14
00446:  MOVWF  01
00448:  CLRF   00
0044A:  DECFSZ 00,F
0044C:  BRA    044A
0044E:  DECFSZ 01,F
00450:  BRA    0448
00452:  MOVLW  BF
00454:  MOVWF  00
00456:  DECFSZ 00,F
00458:  BRA    0456
0045A:  BRA    045C
0045C:  DECFSZ FEF,F
0045E:  BRA    0444
00460:  RETURN 0
*
00700:  MOVLW  01
00702:  MOVLB  6
00704:  SUBWF  x71,F
00706:  BNC   0720
00708:  MOVLW  06
0070A:  MOVWF  FEA
0070C:  MOVLW  71
0070E:  MOVWF  FE9
00710:  MOVF   FEF,W
00712:  BZ    0720
00714:  MOVLW  04
00716:  MOVWF  00
00718:  DECFSZ 00,F
0071A:  BRA    0718
0071C:  DECFSZ FEF,F
0071E:  BRA    0714
00720:  MOVLB  0
00722:  GOTO   0768 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003A2:  MOVLW  CF
003A4:  MOVWF  F87
003A6:  CLRF   F82
....................    output_b(portB_reset);
003A8:  MOVLW  C4
003AA:  MOVWF  F88
003AC:  CLRF   F83
....................    output_c(portC_reset);
003AE:  MOVLW  93
003B0:  MOVWF  F89
003B2:  CLRF   F84
....................    output_d(portD_reset);
003B4:  MOVLW  1F
003B6:  MOVWF  F8A
003B8:  CLRF   F85
....................    output_e(portE_reset);
003BA:  BCF    F8B.0
003BC:  BCF    F8B.1
003BE:  BCF    F8B.2
003C0:  BCF    F8B.3
003C2:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003C4:  MOVLB  F
003C6:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003C8:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003CA:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003CC:  SETF   x20
....................    port_e_pullups(portE_pullups);
003CE:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003D0:  MOVLW  40
003D2:  MOVWF  x0C
003D4:  CLRF   x14
003D6:  MOVLW  03
003D8:  MOVWF  x1C
003DA:  MOVLW  0F
003DC:  MOVWF  x21
003DE:  CLRF   x29
003E0:  MOVLB  0
003E2:  GOTO   B062 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
0647E:  MOVFF  6A6,FEA
06482:  MOVLB  6
06484:  MOVFF  6A5,FE9
06488:  MOVFF  FEF,6A9
0648C:  MOVFF  6A8,FEA
06490:  MOVFF  6A7,FE9
06494:  MOVF   FEF,W
06496:  SUBWF  xA9,W
06498:  BNZ   64C8
....................       if (*s1 == '\0')
0649A:  MOVFF  6A6,03
0649E:  MOVFF  6A5,FE9
064A2:  MOVFF  03,FEA
064A6:  MOVF   FEF,F
064A8:  BNZ   64B0
....................          return(0);
064AA:  MOVLW  00
064AC:  MOVWF  01
064AE:  BRA    64F2
064B0:  MOVFF  6A6,03
064B4:  MOVF   xA5,W
064B6:  INCF   xA5,F
064B8:  BTFSC  FD8.2
064BA:  INCF   xA6,F
064BC:  INCF   xA7,F
064BE:  BTFSC  FD8.2
064C0:  INCF   xA8,F
064C2:  MOVLB  0
064C4:  BRA    647E
064C6:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
064C8:  MOVFF  6A6,03
064CC:  MOVFF  6A5,FE9
064D0:  MOVFF  03,FEA
064D4:  MOVFF  FEF,6A9
064D8:  MOVFF  6A8,03
064DC:  MOVFF  6A7,FE9
064E0:  MOVFF  03,FEA
064E4:  MOVF   FEF,W
064E6:  SUBWF  xA9,W
064E8:  BC    64EE
064EA:  MOVLW  FF
064EC:  BRA    64F0
064EE:  MOVLW  01
064F0:  MOVWF  01
064F2:  MOVLB  0
064F4:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
0660E:  MOVFF  6CC,6CF
....................    for(su=s;0<n;++su,--n)
06612:  MOVFF  6CB,6D1
06616:  MOVFF  6CA,6D0
0661A:  MOVLB  6
0661C:  MOVF   xCE,F
0661E:  BNZ   6626
06620:  MOVF   xCD,W
06622:  SUBLW  00
06624:  BC    664E
....................       if(*su==uc)
06626:  MOVFF  6D1,FEA
0662A:  MOVFF  6D0,FE9
0662E:  MOVF   xCF,W
06630:  SUBWF  FEF,W
06632:  BNZ   663E
....................       return su;
06634:  MOVFF  6D0,01
06638:  MOVFF  6D1,02
0663C:  BRA    6654
0663E:  INCF   xD0,F
06640:  BTFSC  FD8.2
06642:  INCF   xD1,F
06644:  MOVF   xCD,W
06646:  BTFSC  FD8.2
06648:  DECF   xCE,F
0664A:  DECF   xCD,F
0664C:  BRA    661C
....................    return NULL;
0664E:  MOVLW  00
06650:  MOVWF  01
06652:  MOVWF  02
06654:  MOVLB  0
06656:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
06446:  MOVFF  6A6,6A8
0644A:  MOVFF  6A5,6A7
0644E:  MOVFF  6A8,FEA
06452:  MOVLB  6
06454:  MOVFF  6A7,FE9
06458:  MOVF   FEF,F
0645A:  BZ    6468
0645C:  INCF   xA7,F
0645E:  BTFSC  FD8.2
06460:  INCF   xA8,F
06462:  MOVLB  0
06464:  BRA    644E
06466:  MOVLB  6
....................    return(sc - s);
06468:  MOVF   xA5,W
0646A:  SUBWF  xA7,W
0646C:  MOVWF  00
0646E:  MOVF   xA6,W
06470:  SUBWFB xA8,W
06472:  MOVWF  03
06474:  MOVFF  00,01
06478:  MOVWF  02
0647A:  MOVLB  0
0647C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
0794C:  MOVLB  6
0794E:  CLRF   x7F
07950:  CLRF   x7E
07952:  CLRF   x7D
07954:  MOVLW  7F
07956:  MOVWF  x7C
07958:  CLRF   x83
0795A:  CLRF   x82
0795C:  CLRF   x81
0795E:  CLRF   x80
07960:  BSF    x84.0
07962:  BCF    x84.1
07964:  BCF    x84.2
07966:  CLRF   x86
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
07968:  MOVF   x78,W
0796A:  IORWF  x79,W
0796C:  BNZ   7978
....................       return 0;
0796E:  CLRF   00
07970:  CLRF   01
07972:  CLRF   02
07974:  CLRF   03
07976:  BRA    7BA2
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
07978:  MOVF   x86,W
0797A:  INCF   x86,F
0797C:  ADDWF  x78,W
0797E:  MOVWF  FE9
07980:  MOVLW  00
07982:  ADDWFC x79,W
07984:  MOVWF  FEA
07986:  MOVFF  FEF,685
0798A:  MOVF   x85,F
0798C:  BTFSC  FD8.2
0798E:  BRA    7B26
....................    {
....................       if (skip && !isspace(c))
07990:  BTFSS  x84.0
07992:  BRA    79B2
07994:  MOVF   x85,W
07996:  SUBLW  20
07998:  BZ    79B2
....................       {
....................          skip = 0;
0799A:  BCF    x84.0
....................          if (c == '+')
0799C:  MOVF   x85,W
0799E:  SUBLW  2B
079A0:  BNZ   79A8
....................          {
....................             sign = 0;
079A2:  BCF    x84.1
....................             continue;
079A4:  BRA    7B0E
....................          }            
079A6:  BRA    79B2
....................          else if (c == '-')
079A8:  MOVF   x85,W
079AA:  SUBLW  2D
079AC:  BNZ   79B2
....................          {
....................             sign = 1;
079AE:  BSF    x84.1
....................             continue;
079B0:  BRA    7B0E
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
079B2:  BTFSC  x84.0
079B4:  BRA    79C4
079B6:  MOVF   x85,W
079B8:  SUBLW  2E
079BA:  BNZ   79C4
079BC:  BTFSC  x84.2
079BE:  BRA    79C4
....................          point = 1;
079C0:  BSF    x84.2
079C2:  BRA    7B0E
....................       else if (!skip && isdigit(c))
079C4:  BTFSC  x84.0
079C6:  BRA    7B08
079C8:  MOVF   x85,W
079CA:  SUBLW  2F
079CC:  BTFSC  FD8.0
079CE:  BRA    7B08
079D0:  MOVF   x85,W
079D2:  SUBLW  39
079D4:  BTFSS  FD8.0
079D6:  BRA    7B08
....................       {
....................          c -= '0';
079D8:  MOVLW  30
079DA:  SUBWF  x85,F
....................          if (point)
079DC:  BTFSS  x84.2
079DE:  BRA    7A8E
....................          {
....................             pow10 = pow10 * 10.0;
079E0:  MOVFF  67F,6B7
079E4:  MOVFF  67E,6B6
079E8:  MOVFF  67D,6B5
079EC:  MOVFF  67C,6B4
079F0:  CLRF   xBB
079F2:  CLRF   xBA
079F4:  MOVLW  20
079F6:  MOVWF  xB9
079F8:  MOVLW  82
079FA:  MOVWF  xB8
079FC:  MOVLB  0
079FE:  CALL   130A
07A02:  MOVFF  03,67F
07A06:  MOVFF  02,67E
07A0A:  MOVFF  01,67D
07A0E:  MOVFF  00,67C
....................             result += (float)c / pow10;   
07A12:  MOVLB  6
07A14:  CLRF   xB4
07A16:  MOVFF  685,6B3
07A1A:  MOVLB  0
07A1C:  CALL   12D4
07A20:  MOVFF  03,68A
07A24:  MOVFF  02,689
07A28:  MOVFF  01,688
07A2C:  MOVFF  00,687
07A30:  MOVFF  03,6AB
07A34:  MOVFF  02,6AA
07A38:  MOVFF  01,6A9
07A3C:  MOVFF  00,6A8
07A40:  MOVFF  67F,6AF
07A44:  MOVFF  67E,6AE
07A48:  MOVFF  67D,6AD
07A4C:  MOVFF  67C,6AC
07A50:  CALL   2850
07A54:  BCF    FD8.1
07A56:  MOVFF  683,6B6
07A5A:  MOVFF  682,6B5
07A5E:  MOVFF  681,6B4
07A62:  MOVFF  680,6B3
07A66:  MOVFF  03,6BA
07A6A:  MOVFF  02,6B9
07A6E:  MOVFF  01,6B8
07A72:  MOVFF  00,6B7
07A76:  CALL   1400
07A7A:  MOVFF  03,683
07A7E:  MOVFF  02,682
07A82:  MOVFF  01,681
07A86:  MOVFF  00,680
....................          }
07A8A:  BRA    7B04
07A8C:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
07A8E:  CLRF   xB7
07A90:  CLRF   xB6
07A92:  MOVLW  20
07A94:  MOVWF  xB5
07A96:  MOVLW  82
07A98:  MOVWF  xB4
07A9A:  MOVFF  683,6BB
07A9E:  MOVFF  682,6BA
07AA2:  MOVFF  681,6B9
07AA6:  MOVFF  680,6B8
07AAA:  MOVLB  0
07AAC:  CALL   130A
07AB0:  MOVFF  03,68A
07AB4:  MOVFF  02,689
07AB8:  MOVFF  01,688
07ABC:  MOVFF  00,687
07AC0:  MOVLB  6
07AC2:  CLRF   xB4
07AC4:  MOVFF  685,6B3
07AC8:  MOVLB  0
07ACA:  CALL   12D4
07ACE:  BCF    FD8.1
07AD0:  MOVFF  68A,6B6
07AD4:  MOVFF  689,6B5
07AD8:  MOVFF  688,6B4
07ADC:  MOVFF  687,6B3
07AE0:  MOVFF  03,6BA
07AE4:  MOVFF  02,6B9
07AE8:  MOVFF  01,6B8
07AEC:  MOVFF  00,6B7
07AF0:  CALL   1400
07AF4:  MOVFF  03,683
07AF8:  MOVFF  02,682
07AFC:  MOVFF  01,681
07B00:  MOVFF  00,680
....................          }
....................       }
07B04:  BRA    7B10
07B06:  MOVLB  6
....................       else if (!skip)
07B08:  BTFSC  x84.0
07B0A:  BRA    7B0E
....................          break;
07B0C:  BRA    7B26
07B0E:  MOVLB  0
07B10:  MOVLB  6
07B12:  MOVF   x86,W
07B14:  INCF   x86,F
07B16:  ADDWF  x78,W
07B18:  MOVWF  FE9
07B1A:  MOVLW  00
07B1C:  ADDWFC x79,W
07B1E:  MOVWF  FEA
07B20:  MOVFF  FEF,685
07B24:  BRA    798A
....................    }
.................... 
....................    if (sign)
07B26:  BTFSS  x84.1
07B28:  BRA    7B5E
....................       result = -1*result;
07B2A:  CLRF   xB7
07B2C:  CLRF   xB6
07B2E:  MOVLW  80
07B30:  MOVWF  xB5
07B32:  MOVLW  7F
07B34:  MOVWF  xB4
07B36:  MOVFF  683,6BB
07B3A:  MOVFF  682,6BA
07B3E:  MOVFF  681,6B9
07B42:  MOVFF  680,6B8
07B46:  MOVLB  0
07B48:  CALL   130A
07B4C:  MOVFF  03,683
07B50:  MOVFF  02,682
07B54:  MOVFF  01,681
07B58:  MOVFF  00,680
07B5C:  MOVLB  6
....................       
....................    if(endptr)
07B5E:  MOVF   x7A,W
07B60:  IORWF  x7B,W
07B62:  BZ    7B92
....................    {
....................       if (ptr) {
07B64:  MOVF   x86,F
07B66:  BZ    7B80
....................          ptr--;
07B68:  DECF   x86,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07B6A:  MOVFF  67B,FEA
07B6E:  MOVFF  67A,FE9
07B72:  MOVF   x86,W
07B74:  ADDWF  x78,W
07B76:  MOVWF  FEF
07B78:  MOVLW  00
07B7A:  ADDWFC x79,W
07B7C:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
07B7E:  BRA    7B92
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
07B80:  MOVFF  67B,FEA
07B84:  MOVFF  67A,FE9
07B88:  MOVFF  679,FEC
07B8C:  MOVF   FED,F
07B8E:  MOVFF  678,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07B92:  MOVFF  680,00
07B96:  MOVFF  681,01
07B9A:  MOVFF  682,02
07B9E:  MOVFF  683,03
07BA2:  MOVLB  0
07BA4:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
066AE:  MOVLB  6
066B0:  CLRF   xA3
066B2:  CLRF   xA2
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
066B4:  MOVLW  30
066B6:  MOVWF  xA5
066B8:  MOVLW  31
066BA:  MOVWF  xA6
066BC:  MOVLW  32
066BE:  MOVWF  xA7
066C0:  MOVLW  33
066C2:  MOVWF  xA8
066C4:  MOVLW  34
066C6:  MOVWF  xA9
066C8:  MOVLW  35
066CA:  MOVWF  xAA
066CC:  MOVLW  36
066CE:  MOVWF  xAB
066D0:  MOVLW  37
066D2:  MOVWF  xAC
066D4:  MOVLW  38
066D6:  MOVWF  xAD
066D8:  MOVLW  39
066DA:  MOVWF  xAE
066DC:  MOVLW  61
066DE:  MOVWF  xAF
066E0:  MOVLW  62
066E2:  MOVWF  xB0
066E4:  MOVLW  63
066E6:  MOVWF  xB1
066E8:  MOVLW  64
066EA:  MOVWF  xB2
066EC:  MOVLW  65
066EE:  MOVWF  xB3
066F0:  MOVLW  66
066F2:  MOVWF  xB4
066F4:  MOVLW  67
066F6:  MOVWF  xB5
066F8:  MOVLW  68
066FA:  MOVWF  xB6
066FC:  MOVLW  69
066FE:  MOVWF  xB7
06700:  MOVLW  6A
06702:  MOVWF  xB8
06704:  MOVLW  6B
06706:  MOVWF  xB9
06708:  MOVLW  6C
0670A:  MOVWF  xBA
0670C:  MOVLW  6D
0670E:  MOVWF  xBB
06710:  MOVLW  6E
06712:  MOVWF  xBC
06714:  MOVLW  6F
06716:  MOVWF  xBD
06718:  MOVLW  70
0671A:  MOVWF  xBE
0671C:  MOVLW  71
0671E:  MOVWF  xBF
06720:  MOVLW  73
06722:  MOVWF  xC0
06724:  MOVLW  74
06726:  MOVWF  xC1
06728:  MOVLW  75
0672A:  MOVWF  xC2
0672C:  MOVLW  76
0672E:  MOVWF  xC3
06730:  MOVLW  77
06732:  MOVWF  xC4
06734:  MOVLW  78
06736:  MOVWF  xC5
06738:  MOVLW  79
0673A:  MOVWF  xC6
0673C:  MOVLW  7A
0673E:  MOVWF  xC7
06740:  CLRF   xC8
....................    for(sc=s;isspace(*sc);++sc);
06742:  MOVFF  698,69D
06746:  MOVFF  697,69C
0674A:  MOVFF  69D,FEA
0674E:  MOVFF  69C,FE9
06752:  MOVF   FEF,W
06754:  SUBLW  20
06756:  BNZ   6760
06758:  INCF   x9C,F
0675A:  BTFSC  FD8.2
0675C:  INCF   x9D,F
0675E:  BRA    674A
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
06760:  MOVFF  69D,03
06764:  MOVFF  69C,FE9
06768:  MOVFF  03,FEA
0676C:  MOVF   FEF,W
0676E:  SUBLW  2D
06770:  BZ    6780
06772:  MOVFF  69D,FEA
06776:  MOVFF  69C,FE9
0677A:  MOVF   FEF,W
0677C:  SUBLW  2B
0677E:  BNZ   6792
06780:  MOVFF  69D,FEA
06784:  MOVF   x9C,W
06786:  INCF   x9C,F
06788:  BTFSC  FD8.2
0678A:  INCF   x9D,F
0678C:  MOVWF  FE9
0678E:  MOVF   FEF,W
06790:  BRA    6794
06792:  MOVLW  2B
06794:  MOVWF  xA4
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
06796:  MOVF   xA4,W
06798:  SUBLW  2D
0679A:  BZ    67B0
0679C:  BTFSC  x9B.7
0679E:  BRA    67B0
067A0:  DECFSZ x9B,W
067A2:  BRA    67A6
067A4:  BRA    67B0
067A6:  BTFSC  x9B.7
067A8:  BRA    67B4
067AA:  MOVF   x9B,W
067AC:  SUBLW  24
067AE:  BC    67B4
....................    goto StrtoulGO;
067B0:  BRA    69BC
067B2:  BRA    68AC
.................... 
....................    else if (base)
067B4:  MOVF   x9B,F
067B6:  BZ    6844
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
067B8:  MOVF   x9B,W
067BA:  SUBLW  10
067BC:  BNZ   67F8
067BE:  MOVFF  69D,FEA
067C2:  MOVFF  69C,FE9
067C6:  MOVF   FEF,W
067C8:  SUBLW  30
067CA:  BNZ   67F8
067CC:  MOVLW  01
067CE:  ADDWF  x9C,W
067D0:  MOVWF  FE9
067D2:  MOVLW  00
067D4:  ADDWFC x9D,W
067D6:  MOVWF  FEA
067D8:  MOVF   FEF,W
067DA:  SUBLW  78
067DC:  BZ    67F0
067DE:  MOVLW  01
067E0:  ADDWF  x9C,W
067E2:  MOVWF  FE9
067E4:  MOVLW  00
067E6:  ADDWFC x9D,W
067E8:  MOVWF  FEA
067EA:  MOVF   FEF,W
067EC:  SUBLW  58
067EE:  BNZ   67F8
....................          sc+=2;
067F0:  MOVLW  02
067F2:  ADDWF  x9C,F
067F4:  MOVLW  00
067F6:  ADDWFC x9D,F
....................       if(base==8 && *sc =='0')
067F8:  MOVF   x9B,W
067FA:  SUBLW  08
067FC:  BNZ   6814
067FE:  MOVFF  69D,FEA
06802:  MOVFF  69C,FE9
06806:  MOVF   FEF,W
06808:  SUBLW  30
0680A:  BNZ   6814
....................          sc+=1;
0680C:  MOVLW  01
0680E:  ADDWF  x9C,F
06810:  MOVLW  00
06812:  ADDWFC x9D,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
06814:  MOVF   x9B,W
06816:  SUBLW  02
06818:  BNZ   6842
0681A:  MOVFF  69D,FEA
0681E:  MOVFF  69C,FE9
06822:  MOVF   FEF,W
06824:  SUBLW  30
06826:  BNZ   6842
06828:  MOVLW  01
0682A:  ADDWF  x9C,W
0682C:  MOVWF  FE9
0682E:  MOVLW  00
06830:  ADDWFC x9D,W
06832:  MOVWF  FEA
06834:  MOVF   FEF,W
06836:  SUBLW  62
06838:  BNZ   6842
....................          sc+=2;
0683A:  MOVLW  02
0683C:  ADDWF  x9C,F
0683E:  MOVLW  00
06840:  ADDWFC x9D,F
.................... 
....................    }
06842:  BRA    68AC
....................    else if(*sc!='0') // base is 0, find base
06844:  MOVFF  69D,FEA
06848:  MOVFF  69C,FE9
0684C:  MOVF   FEF,W
0684E:  SUBLW  30
06850:  BZ    6858
....................       base=10;
06852:  MOVLW  0A
06854:  MOVWF  x9B
06856:  BRA    68AC
....................    else if (sc[1]=='x' || sc[1]=='X')
06858:  MOVLW  01
0685A:  ADDWF  x9C,W
0685C:  MOVWF  FE9
0685E:  MOVLW  00
06860:  ADDWFC x9D,W
06862:  MOVWF  FEA
06864:  MOVF   FEF,W
06866:  SUBLW  78
06868:  BZ    687C
0686A:  MOVLW  01
0686C:  ADDWF  x9C,W
0686E:  MOVWF  FE9
06870:  MOVLW  00
06872:  ADDWFC x9D,W
06874:  MOVWF  FEA
06876:  MOVF   FEF,W
06878:  SUBLW  58
0687A:  BNZ   688A
....................       base =16,sc+=2;
0687C:  MOVLW  10
0687E:  MOVWF  x9B
06880:  MOVLW  02
06882:  ADDWF  x9C,F
06884:  MOVLW  00
06886:  ADDWFC x9D,F
06888:  BRA    68AC
....................    else if(sc[1]=='b')
0688A:  MOVLW  01
0688C:  ADDWF  x9C,W
0688E:  MOVWF  FE9
06890:  MOVLW  00
06892:  ADDWFC x9D,W
06894:  MOVWF  FEA
06896:  MOVF   FEF,W
06898:  SUBLW  62
0689A:  BNZ   68A8
....................       base=2,sc+=2;
0689C:  MOVLW  02
0689E:  MOVWF  x9B
068A0:  ADDWF  x9C,F
068A2:  MOVLW  00
068A4:  ADDWFC x9D,F
068A6:  BRA    68AC
....................    else
....................       base=8;
068A8:  MOVLW  08
068AA:  MOVWF  x9B
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
068AC:  MOVFF  69D,69F
068B0:  MOVFF  69C,69E
068B4:  MOVFF  69D,FEA
068B8:  MOVFF  69C,FE9
068BC:  MOVF   FEF,W
068BE:  SUBLW  30
068C0:  BNZ   68CA
068C2:  INCF   x9C,F
068C4:  BTFSC  FD8.2
068C6:  INCF   x9D,F
068C8:  BRA    68B4
....................    sd=memchr(digits,tolower(*sc),base);
068CA:  MOVFF  69D,03
068CE:  MOVFF  69C,FE9
068D2:  MOVFF  03,FEA
068D6:  MOVFF  FEF,6C9
068DA:  MOVF   xC9,W
068DC:  SUBLW  40
068DE:  BC    68EC
068E0:  MOVF   xC9,W
068E2:  SUBLW  5A
068E4:  BNC   68EC
068E6:  MOVF   xC9,W
068E8:  IORLW  20
068EA:  BRA    68EE
068EC:  MOVF   xC9,W
068EE:  MOVWF  xC9
068F0:  MOVLW  06
068F2:  MOVWF  xCB
068F4:  MOVLW  A5
068F6:  MOVWF  xCA
068F8:  MOVFF  6C9,6CC
068FC:  CLRF   xCE
068FE:  MOVFF  69B,6CD
06902:  BTFSC  xCD.7
06904:  DECF   xCE,F
06906:  MOVLB  0
06908:  RCALL  660E
0690A:  MOVFF  02,6A1
0690E:  MOVFF  01,6A0
....................    for(; sd!=0; )
06912:  MOVLB  6
06914:  MOVF   xA0,F
06916:  BNZ   691C
06918:  MOVF   xA1,F
0691A:  BZ    69B0
....................    {
....................       x=x*base+(int16)(sd-digits);
0691C:  CLRF   03
0691E:  MOVF   x9B,W
06920:  MOVWF  00
06922:  BTFSC  FE8.7
06924:  DECF   03,F
06926:  MOVWF  xC9
06928:  MOVFF  03,6CA
0692C:  MOVFF  6A3,6CC
06930:  MOVFF  6A2,6CB
06934:  MOVFF  03,6CE
06938:  MOVWF  xCD
0693A:  MOVLB  0
0693C:  BRA    6658
0693E:  MOVFF  01,6C9
06942:  MOVLW  A5
06944:  MOVLB  6
06946:  SUBWF  xA0,W
06948:  MOVWF  00
0694A:  MOVLW  06
0694C:  SUBWFB xA1,W
0694E:  MOVWF  03
06950:  MOVF   00,W
06952:  ADDWF  01,W
06954:  MOVWF  01
06956:  MOVF   02,W
06958:  ADDWFC 03,F
0695A:  MOVFF  01,6A2
0695E:  MOVFF  03,6A3
....................       ++sc;
06962:  INCF   x9C,F
06964:  BTFSC  FD8.2
06966:  INCF   x9D,F
....................       sd=memchr(digits,tolower(*sc),base);
06968:  MOVFF  69D,FEA
0696C:  MOVFF  69C,FE9
06970:  MOVFF  FEF,6C9
06974:  MOVF   xC9,W
06976:  SUBLW  40
06978:  BC    6986
0697A:  MOVF   xC9,W
0697C:  SUBLW  5A
0697E:  BNC   6986
06980:  MOVF   xC9,W
06982:  IORLW  20
06984:  BRA    6988
06986:  MOVF   xC9,W
06988:  MOVWF  xC9
0698A:  MOVLW  06
0698C:  MOVWF  xCB
0698E:  MOVLW  A5
06990:  MOVWF  xCA
06992:  MOVFF  6C9,6CC
06996:  CLRF   xCE
06998:  MOVFF  69B,6CD
0699C:  BTFSC  xCD.7
0699E:  DECF   xCE,F
069A0:  MOVLB  0
069A2:  RCALL  660E
069A4:  MOVFF  02,6A1
069A8:  MOVFF  01,6A0
069AC:  BRA    6912
069AE:  MOVLB  6
....................    }
....................    if(s1==sc)
069B0:  MOVF   x9C,W
069B2:  SUBWF  x9E,W
069B4:  BNZ   69DE
069B6:  MOVF   x9D,W
069B8:  SUBWF  x9F,W
069BA:  BNZ   69DE
....................    {
....................    StrtoulGO:
....................       if (endptr)
069BC:  MOVLB  6
069BE:  MOVF   x99,W
069C0:  IORWF  x9A,W
069C2:  BZ    69D6
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
069C4:  MOVFF  69A,FEA
069C8:  MOVFF  699,FE9
069CC:  MOVFF  698,FEC
069D0:  MOVF   FED,F
069D2:  MOVFF  697,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
069D6:  MOVLW  00
069D8:  MOVWF  01
069DA:  MOVWF  02
069DC:  BRA    69FE
....................    }
....................    if (endptr)
069DE:  MOVF   x99,W
069E0:  IORWF  x9A,W
069E2:  BZ    69F6
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
069E4:  MOVFF  69A,FEA
069E8:  MOVFF  699,FE9
069EC:  MOVFF  69D,FEC
069F0:  MOVF   FED,F
069F2:  MOVFF  69C,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
069F6:  MOVFF  6A2,01
069FA:  MOVFF  6A3,02
069FE:  MOVLB  0
06A00:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
*
01C2A:  BCF    FD8.0
01C2C:  MOVLB  6
01C2E:  RRCF   xAB,W
01C30:  MOVWF  xAF
....................    while( m > 0 ) {
01C32:  MOVF   xAF,F
01C34:  BTFSC  FD8.2
01C36:  BRA    1D4E
....................      for(j=0; j<(qitems-m); ++j) {
01C38:  CLRF   xB0
01C3A:  MOVF   xAF,W
01C3C:  SUBWF  xAB,W
01C3E:  SUBWF  xB0,W
01C40:  BTFSC  FD8.0
01C42:  BRA    1D48
....................         i = j;
01C44:  MOVFF  6B0,6B1
....................         do
....................         {
....................            done=1;
01C48:  BSF    xB3.0
....................            l = i+m;
01C4A:  MOVF   xAF,W
01C4C:  ADDWF  xB1,W
01C4E:  MOVWF  xB2
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
01C50:  MOVF   xB1,W
01C52:  MULWF  xAC
01C54:  MOVF   FF3,W
01C56:  ADDWF  xA9,W
01C58:  MOVWF  xC4
01C5A:  MOVLW  00
01C5C:  ADDWFC xAA,W
01C5E:  MOVWF  xC5
01C60:  MOVF   xB2,W
01C62:  MULWF  xAC
01C64:  MOVF   FF3,W
01C66:  ADDWF  xA9,W
01C68:  MOVWF  xC6
01C6A:  MOVLW  00
01C6C:  ADDWFC xAA,W
01C6E:  MOVWF  xC7
01C70:  MOVLW  06
01C72:  MOVWF  FEA
01C74:  MOVLW  AD
01C76:  MOVWF  FE9
01C78:  MOVFF  6C5,660
01C7C:  MOVFF  6C4,65F
01C80:  MOVFF  6C7,662
01C84:  MOVFF  6C6,661
01C88:  MOVLB  0
01C8A:  CALL   00BC
01C8E:  BTFSC  01.7
01C90:  BRA    1D3E
01C92:  MOVF   01,W
01C94:  SUBLW  00
01C96:  BC    1D3E
....................               memcpy(t, qdata+i*qsize, qsize);
01C98:  MOVLB  6
01C9A:  MOVF   xB1,W
01C9C:  MULWF  xAC
01C9E:  MOVF   FF3,W
01CA0:  ADDWF  xA9,W
01CA2:  MOVWF  xC4
01CA4:  MOVLW  00
01CA6:  ADDWFC xAA,W
01CA8:  MOVWF  xC5
01CAA:  MOVLW  06
01CAC:  MOVWF  FEA
01CAE:  MOVLW  B4
01CB0:  MOVWF  FE9
01CB2:  MOVFF  6C5,FE2
01CB6:  MOVFF  6C4,FE1
01CBA:  MOVF   xAC,W
01CBC:  MOVWF  01
01CBE:  BZ    1CC8
01CC0:  MOVFF  FE6,FEE
01CC4:  DECFSZ 01,F
01CC6:  BRA    1CC0
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
01CC8:  MOVF   xB1,W
01CCA:  MULWF  xAC
01CCC:  MOVF   FF3,W
01CCE:  ADDWF  xA9,W
01CD0:  MOVWF  xC4
01CD2:  MOVLW  00
01CD4:  ADDWFC xAA,W
01CD6:  MOVWF  xC5
01CD8:  MOVF   xB2,W
01CDA:  MULWF  xAC
01CDC:  MOVF   FF3,W
01CDE:  ADDWF  xA9,W
01CE0:  MOVWF  xC6
01CE2:  MOVLW  00
01CE4:  ADDWFC xAA,W
01CE6:  MOVWF  xC7
01CE8:  MOVFF  6C5,FEA
01CEC:  MOVFF  6C4,FE9
01CF0:  MOVWF  FE2
01CF2:  MOVFF  6C6,FE1
01CF6:  MOVF   xAC,W
01CF8:  MOVWF  01
01CFA:  BZ    1D04
01CFC:  MOVFF  FE6,FEE
01D00:  DECFSZ 01,F
01D02:  BRA    1CFC
....................               memcpy(qdata+l*qsize, t, qsize);
01D04:  MOVF   xB2,W
01D06:  MULWF  xAC
01D08:  MOVF   FF3,W
01D0A:  ADDWF  xA9,W
01D0C:  MOVWF  xC4
01D0E:  MOVLW  00
01D10:  ADDWFC xAA,W
01D12:  MOVWF  xC5
01D14:  MOVWF  FEA
01D16:  MOVFF  6C4,FE9
01D1A:  MOVLW  06
01D1C:  MOVWF  FE2
01D1E:  MOVLW  B4
01D20:  MOVWF  FE1
01D22:  MOVF   xAC,W
01D24:  MOVWF  01
01D26:  BZ    1D30
01D28:  MOVFF  FE6,FEE
01D2C:  DECFSZ 01,F
01D2E:  BRA    1D28
....................               if(m <= i)
01D30:  MOVF   xAF,W
01D32:  SUBWF  xB1,W
01D34:  BNC   1D3A
....................                 i -= m;
01D36:  MOVF   xAF,W
01D38:  SUBWF  xB1,F
....................                 done = 0;
01D3A:  BCF    xB3.0
01D3C:  MOVLB  0
....................            }
....................         } while(!done);
01D3E:  MOVLB  6
01D40:  BTFSS  xB3.0
01D42:  BRA    1C48
01D44:  INCF   xB0,F
01D46:  BRA    1C3A
....................      }
....................      m = m/2;
01D48:  BCF    FD8.0
01D4A:  RRCF   xAF,F
01D4C:  BRA    1C32
....................    }
01D4E:  MOVLB  0
01D50:  RETURN 0
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00462:  MOVLB  6
00464:  CLRF   x69
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00466:  CLRF   x69
00468:  MOVF   x68,W
0046A:  SUBWF  x69,W
0046C:  BC    04C4
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0046E:  MOVF   x69,W
00470:  ADDWF  x66,W
00472:  MOVWF  x6A
00474:  MOVLW  00
00476:  ADDWFC x67,W
00478:  MOVWF  x6B
0047A:  MOVF   x69,W
0047C:  ADDWF  x64,W
0047E:  MOVWF  01
00480:  MOVLW  00
00482:  ADDWFC x65,W
00484:  MOVWF  03
00486:  MOVF   01,W
00488:  MOVWF  FE9
0048A:  MOVFF  03,FEA
0048E:  MOVFF  FEF,66C
00492:  BSF    F7F.7
00494:  MOVF   FF2,W
00496:  MOVWF  00
00498:  BCF    FF2.7
0049A:  MOVFF  66B,F7A
0049E:  MOVFF  66A,F79
004A2:  MOVLW  31
004A4:  MOVWF  F7B
004A6:  MOVFF  66C,F7C
004AA:  MOVLB  F
004AC:  MOVLW  55
004AE:  MOVWF  F81
004B0:  MOVLW  AA
004B2:  MOVWF  F81
004B4:  BSF    F80.4
004B6:  BTFSC  F80.4
004B8:  BRA    04B6
004BA:  MOVF   00,W
004BC:  IORWF  FF2,F
004BE:  MOVLB  6
004C0:  INCF   x69,F
004C2:  BRA    0468
....................    }
004C4:  MOVLB  0
004C6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003E6:  MOVLB  6
003E8:  CLRF   x69
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003EA:  CLRF   x69
003EC:  MOVF   x68,W
003EE:  SUBWF  x69,W
003F0:  BC    0434
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003F2:  MOVF   x69,W
003F4:  ADDWF  x64,W
003F6:  MOVWF  01
003F8:  MOVLW  00
003FA:  ADDWFC x65,W
003FC:  MOVWF  03
003FE:  MOVF   01,W
00400:  MOVWF  FE9
00402:  MOVFF  03,FEA
00406:  MOVF   x69,W
00408:  ADDWF  x66,W
0040A:  MOVWF  x6C
0040C:  MOVLW  00
0040E:  ADDWFC x67,W
00410:  MOVWF  x6D
00412:  BSF    F7F.7
00414:  MOVFF  FF2,66E
00418:  BCF    FF2.7
0041A:  MOVFF  66D,F7A
0041E:  MOVFF  66C,F79
00422:  MOVLW  31
00424:  MOVWF  F7B
00426:  BSF    F80.0
00428:  MOVF   F7C,W
0042A:  BTFSC  x6E.7
0042C:  BSF    FF2.7
0042E:  MOVWF  FEF
00430:  INCF   x69,F
00432:  BRA    03EC
....................    }
00434:  MOVLB  0
00436:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004C8:  MOVLB  6
004CA:  CLRF   x65
004CC:  MOVLW  20
004CE:  MOVWF  x64
004D0:  CLRF   x67
004D2:  CLRF   x66
004D4:  MOVLW  80
004D6:  MOVWF  x68
004D8:  MOVLB  0
004DA:  RCALL  0462
....................    delay_ms(1);
004DC:  MOVLW  01
004DE:  MOVLB  6
004E0:  MOVWF  x6C
004E2:  MOVLB  0
004E4:  RCALL  0438
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E6:  MOVLB  6
004E8:  CLRF   x65
004EA:  MOVLW  60
004EC:  MOVWF  x64
004EE:  CLRF   x67
004F0:  MOVLW  80
004F2:  MOVWF  x66
004F4:  MOVLW  02
004F6:  MOVWF  x68
004F8:  MOVLB  0
004FA:  RCALL  0462
....................    delay_ms(1);
004FC:  MOVLW  01
004FE:  MOVLB  6
00500:  MOVWF  x6C
00502:  MOVLB  0
00504:  RCALL  0438
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00506:  MOVLB  6
00508:  CLRF   x65
0050A:  MOVLW  61
0050C:  MOVWF  x64
0050E:  CLRF   x67
00510:  MOVLW  90
00512:  MOVWF  x66
00514:  MOVLW  02
00516:  MOVWF  x68
00518:  MOVLB  0
0051A:  RCALL  0462
....................    delay_ms(1);
0051C:  MOVLW  01
0051E:  MOVLB  6
00520:  MOVWF  x6C
00522:  MOVLB  0
00524:  RCALL  0438
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00526:  MOVLB  6
00528:  CLRF   x65
0052A:  MOVLW  62
0052C:  MOVWF  x64
0052E:  CLRF   x67
00530:  MOVLW  A0
00532:  MOVWF  x66
00534:  MOVLW  20
00536:  MOVWF  x68
00538:  MOVLB  0
0053A:  RCALL  0462
....................    delay_ms(1);
0053C:  MOVLW  01
0053E:  MOVLB  6
00540:  MOVWF  x6C
00542:  MOVLB  0
00544:  RCALL  0438
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00546:  MOVLB  6
00548:  CLRF   x65
0054A:  MOVLW  82
0054C:  MOVWF  x64
0054E:  CLRF   x67
00550:  MOVLW  C0
00552:  MOVWF  x66
00554:  MOVLW  30
00556:  MOVWF  x68
00558:  MOVLB  0
0055A:  RCALL  0462
....................    delay_ms(1);
0055C:  MOVLW  01
0055E:  MOVLB  6
00560:  MOVWF  x6C
00562:  MOVLB  0
00564:  RCALL  0438
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00566:  MOVLB  6
00568:  CLRF   x65
0056A:  MOVLW  B2
0056C:  MOVWF  x64
0056E:  CLRF   x67
00570:  MOVLW  F0
00572:  MOVWF  x66
00574:  MOVLW  38
00576:  MOVWF  x68
00578:  MOVLB  0
0057A:  RCALL  0462
....................    delay_ms(1);
0057C:  MOVLW  01
0057E:  MOVLB  6
00580:  MOVWF  x6C
00582:  MOVLB  0
00584:  RCALL  0438
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00586:  MOVLB  6
00588:  CLRF   x65
0058A:  MOVLW  F2
0058C:  MOVWF  x64
0058E:  MOVLW  01
00590:  MOVWF  x67
00592:  MOVLW  40
00594:  MOVWF  x66
00596:  MOVLW  01
00598:  MOVWF  x68
0059A:  MOVLB  0
0059C:  RCALL  0462
....................    delay_ms(1);
0059E:  MOVLW  01
005A0:  MOVLB  6
005A2:  MOVWF  x6C
005A4:  MOVLB  0
005A6:  RCALL  0438
005A8:  GOTO   0678 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005AC:  MOVLB  6
005AE:  CLRF   x65
005B0:  MOVLW  20
005B2:  MOVWF  x64
005B4:  CLRF   x67
005B6:  CLRF   x66
005B8:  MOVLW  80
005BA:  MOVWF  x68
005BC:  MOVLB  0
005BE:  RCALL  03E6
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005C0:  MOVLB  6
005C2:  CLRF   x65
005C4:  MOVLW  60
005C6:  MOVWF  x64
005C8:  CLRF   x67
005CA:  MOVLW  80
005CC:  MOVWF  x66
005CE:  MOVLW  02
005D0:  MOVWF  x68
005D2:  MOVLB  0
005D4:  RCALL  03E6
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D6:  MOVLB  6
005D8:  CLRF   x65
005DA:  MOVLW  61
005DC:  MOVWF  x64
005DE:  CLRF   x67
005E0:  MOVLW  90
005E2:  MOVWF  x66
005E4:  MOVLW  02
005E6:  MOVWF  x68
005E8:  MOVLB  0
005EA:  RCALL  03E6
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005EC:  MOVLB  6
005EE:  CLRF   x65
005F0:  MOVLW  62
005F2:  MOVWF  x64
005F4:  CLRF   x67
005F6:  MOVLW  A0
005F8:  MOVWF  x66
005FA:  MOVLW  20
005FC:  MOVWF  x68
005FE:  MOVLB  0
00600:  RCALL  03E6
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00602:  MOVLB  6
00604:  CLRF   x65
00606:  MOVLW  82
00608:  MOVWF  x64
0060A:  CLRF   x67
0060C:  MOVLW  C0
0060E:  MOVWF  x66
00610:  MOVLW  30
00612:  MOVWF  x68
00614:  MOVLB  0
00616:  RCALL  03E6
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00618:  MOVLB  6
0061A:  CLRF   x65
0061C:  MOVLW  B2
0061E:  MOVWF  x64
00620:  CLRF   x67
00622:  MOVLW  F0
00624:  MOVWF  x66
00626:  MOVLW  38
00628:  MOVWF  x68
0062A:  MOVLB  0
0062C:  RCALL  03E6
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0062E:  MOVLB  6
00630:  CLRF   x65
00632:  MOVLW  F2
00634:  MOVWF  x64
00636:  MOVLW  01
00638:  MOVWF  x67
0063A:  MOVLW  40
0063C:  MOVWF  x66
0063E:  MOVLW  01
00640:  MOVWF  x68
00642:  MOVLB  0
00644:  RCALL  03E6
00646:  GOTO   067C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064A:  MOVLB  6
0064C:  CLRF   x65
0064E:  MOVLW  F2
00650:  MOVWF  x64
00652:  MOVLW  01
00654:  MOVWF  x67
00656:  MOVLW  40
00658:  MOVWF  x66
0065A:  MOVLW  01
0065C:  MOVWF  x68
0065E:  MOVLB  0
00660:  RCALL  03E6
....................    delay_ms(1);
00662:  MOVLW  01
00664:  MOVLB  6
00666:  MOVWF  x6C
00668:  MOVLB  0
0066A:  RCALL  0438
....................    if (paramsValid != isValid)
0066C:  MOVF   xF2,W
0066E:  SUBLW  AA
00670:  BZ    067A
....................    {
....................       paramsValid = isValid;
00672:  MOVLW  AA
00674:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00676:  BRA    04C8
....................    }
00678:  BRA    067C
....................    else
....................    {
....................       params_load_from_ee();
0067A:  BRA    05AC
....................    }
0067C:  GOTO   B066 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00680:  RCALL  0136
....................    switch(ch)
00682:  MOVLB  6
00684:  MOVF   x7D,W
00686:  ADDLW  FC
00688:  BC    06BC
0068A:  ADDLW  04
0068C:  MOVLB  0
0068E:  GOTO   06C8
....................    {
....................       case 0:
....................          output_low(_CS0);
00692:  MOVLW  1F
00694:  MOVWF  F8A
00696:  BCF    F85.5
....................       break; 
00698:  MOVLB  6
0069A:  BRA    06BC
....................       case 1:
....................          output_low(_CS1);
0069C:  MOVLW  1F
0069E:  MOVWF  F8A
006A0:  BCF    F85.6
....................       break;   
006A2:  MOVLB  6
006A4:  BRA    06BC
....................       case 2:
....................          output_low(_CS2);
006A6:  MOVLW  1F
006A8:  MOVWF  F8A
006AA:  BCF    F85.7
....................       break;
006AC:  MOVLB  6
006AE:  BRA    06BC
....................       case 3:
....................          output_low(_CS3);
006B0:  MOVLW  C4
006B2:  MOVWF  F88
006B4:  BCF    F83.0
....................       break;              
006B6:  MOVLB  6
006B8:  BRA    06BC
006BA:  MOVLB  6
....................    }
....................    delay_us(10);
006BC:  MOVLW  35
006BE:  MOVWF  00
006C0:  DECFSZ 00,F
006C2:  BRA    06C0
006C4:  MOVLB  0
006C6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   xD6,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007B6:  MOVLW  1F
007B8:  MOVWF  F8A
007BA:  BCF    F85.5
....................    output_low(_CS1);
007BC:  MOVWF  F8A
007BE:  BCF    F85.6
....................    output_low(_CS2);
007C0:  MOVWF  F8A
007C2:  BCF    F85.7
....................    output_low(_CS3);
007C4:  MOVLW  C4
007C6:  MOVWF  F88
007C8:  BCF    F83.0
....................    delay_us(10);
007CA:  MOVLW  35
007CC:  MOVWF  00
007CE:  DECFSZ 00,F
007D0:  BRA    07CE
007D2:  GOTO   07D8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006EA:  MOVFF  674,67D
006EE:  RCALL  0680
....................    spi_write2(command);
006F0:  MOVLB  E
006F2:  MOVF   x8D,W
006F4:  MOVFF  675,E8D
006F8:  RRCF   x90,W
006FA:  BNC   06F8
006FC:  MOVLB  0
006FE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  6D4,6D6
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  6D5,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007D6:  BRA    07B6
....................    spi_write2(command);
007D8:  MOVLB  E
007DA:  MOVF   x8D,W
007DC:  MOVFF  66B,E8D
007E0:  RRCF   x90,W
007E2:  BNC   07E0
007E4:  MOVLB  0
007E6:  GOTO   07F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00824:  MOVFF  67B,67D
00828:  RCALL  0680
....................    spi_read2(command);
0082A:  MOVLB  E
0082C:  MOVF   x8D,W
0082E:  MOVFF  67C,E8D
00832:  RRCF   x90,W
00834:  BNC   0832
00836:  MOVLB  0
00838:  GOTO   084A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00726:  MOVLB  6
00728:  MOVF   x71,W
0072A:  IORLW  40
0072C:  MOVWF  x73
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0072E:  MOVFF  670,674
00732:  MOVFF  673,675
00736:  MOVLB  0
00738:  RCALL  06EA
....................    spi_write2(data);
0073A:  MOVLB  E
0073C:  MOVF   x8D,W
0073E:  MOVFF  672,E8D
00742:  RRCF   x90,W
00744:  BNC   0742
....................    ads_deselect_all();
00746:  MOVLB  0
00748:  RCALL  0136
0074A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  6D3,6D4
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  xD5
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(10);
001B0:  MOVLW  35
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
....................    ads_deselect_all();
001B8:  RCALL  0136
001BA:  GOTO   0200 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007EA:  MOVLW  08
007EC:  MOVLB  6
007EE:  MOVWF  x6B
007F0:  MOVLB  0
007F2:  BRA    07D6
....................    delay_us(10);
007F4:  MOVLW  35
007F6:  MOVWF  00
007F8:  DECFSZ 00,F
007FA:  BRA    07F8
....................    ads_deselect_all();
007FC:  RCALL  0136
007FE:  GOTO   0994 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0083C:  MOVFF  676,67B
00840:  MOVLW  10
00842:  MOVLB  6
00844:  MOVWF  x7C
00846:  MOVLB  0
00848:  BRA    0824
....................    data.dBytes[0] = 0;
0084A:  MOVLB  6
0084C:  CLRF   x77
....................    data.dBytes[3] = spi_read2(0);
0084E:  MOVLB  E
00850:  MOVF   x8D,W
00852:  CLRF   x8D
00854:  RRCF   x90,W
00856:  BNC   0854
00858:  MOVFF  E8D,67A
....................    data.dBytes[2] = spi_read2(0);
0085C:  MOVF   x8D,W
0085E:  CLRF   x8D
00860:  RRCF   x90,W
00862:  BNC   0860
00864:  MOVFF  E8D,679
....................    data.dBytes[1] = spi_read2(0);
00868:  MOVF   x8D,W
0086A:  CLRF   x8D
0086C:  RRCF   x90,W
0086E:  BNC   086C
00870:  MOVFF  E8D,678
....................    
....................    ads_deselect_all();
00874:  MOVLB  0
00876:  RCALL  0136
....................    return data.dWord;
00878:  MOVFF  677,00
0087C:  MOVFF  678,01
00880:  MOVFF  679,02
00884:  MOVFF  67A,03
00888:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0074C:  MOVFF  66B,674
00750:  MOVLW  06
00752:  MOVLB  6
00754:  MOVWF  x75
00756:  MOVLB  0
00758:  RCALL  06EA
....................    delay_us(300);                    
0075A:  MOVLW  02
0075C:  MOVLB  6
0075E:  MOVWF  x70
00760:  MOVLW  96
00762:  MOVWF  x71
00764:  MOVLB  0
00766:  BRA    0700
00768:  MOVLB  6
0076A:  DECFSZ x70,F
0076C:  BRA    0760
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0076E:  MOVFF  66B,670
00772:  CLRF   x71
00774:  MOVFF  66C,672
00778:  MOVLB  0
0077A:  RCALL  0726
....................    ads_write_reg(ch, reg1, rc1);
0077C:  MOVFF  66B,670
00780:  MOVLW  04
00782:  MOVLB  6
00784:  MOVWF  x71
00786:  MOVFF  66D,672
0078A:  MOVLB  0
0078C:  RCALL  0726
....................    ads_write_reg(ch, reg2, rc2);
0078E:  MOVFF  66B,670
00792:  MOVLW  08
00794:  MOVLB  6
00796:  MOVWF  x71
00798:  MOVFF  66E,672
0079C:  MOVLB  0
0079E:  RCALL  0726
....................    ads_write_reg(ch, reg3, rc3);  
007A0:  MOVFF  66B,670
007A4:  MOVLW  0C
007A6:  MOVLB  6
007A8:  MOVWF  x71
007AA:  MOVFF  66F,672
007AE:  MOVLB  0
007B0:  RCALL  0726
007B2:  GOTO   08C2 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
03206:  MOVLB  6
03208:  BCF    xAE.0
....................    y = x;
0320A:  MOVFF  6A2,6A7
0320E:  MOVFF  6A1,6A6
03212:  MOVFF  6A0,6A5
03216:  MOVFF  69F,6A4
.................... 
....................    if (x < 0)
0321A:  MOVFF  6A2,6B2
0321E:  MOVFF  6A1,6B1
03222:  MOVFF  6A0,6B0
03226:  MOVFF  69F,6AF
0322A:  CLRF   xB6
0322C:  CLRF   xB5
0322E:  CLRF   xB4
03230:  CLRF   xB3
03232:  MOVLB  0
03234:  CALL   27D6
03238:  BNC   3246
....................    {
....................       s = 1;
0323A:  MOVLB  6
0323C:  BSF    xAE.0
....................       y = -y;
0323E:  MOVF   xA5,W
03240:  XORLW  80
03242:  MOVWF  xA5
03244:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
03246:  MOVFF  6A7,6B2
0324A:  MOVFF  6A6,6B1
0324E:  MOVFF  6A5,6B0
03252:  MOVFF  6A4,6AF
03256:  MOVLB  6
03258:  CLRF   xB6
0325A:  CLRF   xB5
0325C:  CLRF   xB4
0325E:  MOVLW  8E
03260:  MOVWF  xB3
03262:  MOVLB  0
03264:  CALL   27D6
03268:  BC    326C
0326A:  BNZ   329C
....................       res = (float32)(unsigned int16)y;
0326C:  MOVFF  6A7,6B2
03270:  MOVFF  6A6,6B1
03274:  MOVFF  6A5,6B0
03278:  MOVFF  6A4,6AF
0327C:  RCALL  31CA
0327E:  MOVFF  02,6B4
03282:  MOVFF  01,6B3
03286:  CALL   12D4
0328A:  MOVFF  03,6AB
0328E:  MOVFF  02,6AA
03292:  MOVFF  01,6A9
03296:  MOVFF  00,6A8
0329A:  BRA    343E
.................... 
....................  else if (y < 10000000.0)
0329C:  MOVFF  6A7,6B2
032A0:  MOVFF  6A6,6B1
032A4:  MOVFF  6A5,6B0
032A8:  MOVFF  6A4,6AF
032AC:  MOVLW  80
032AE:  MOVLB  6
032B0:  MOVWF  xB6
032B2:  MOVLW  96
032B4:  MOVWF  xB5
032B6:  MOVLW  18
032B8:  MOVWF  xB4
032BA:  MOVLW  96
032BC:  MOVWF  xB3
032BE:  MOVLB  0
032C0:  CALL   27D6
032C4:  BTFSS  FD8.0
032C6:  BRA    342E
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
032C8:  MOVFF  6A7,6B7
032CC:  MOVFF  6A6,6B6
032D0:  MOVFF  6A5,6B5
032D4:  MOVFF  6A4,6B4
032D8:  MOVLB  6
032DA:  CLRF   xBB
032DC:  CLRF   xBA
032DE:  CLRF   xB9
032E0:  MOVLW  70
032E2:  MOVWF  xB8
032E4:  MOVLB  0
032E6:  CALL   130A
032EA:  MOVFF  03,6B2
032EE:  MOVFF  02,6B1
032F2:  MOVFF  01,6B0
032F6:  MOVFF  00,6AF
032FA:  RCALL  31CA
032FC:  MOVFF  02,6AD
03300:  MOVFF  01,6AC
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
03304:  MOVFF  6A7,6B7
03308:  MOVFF  6A6,6B6
0330C:  MOVFF  6A5,6B5
03310:  MOVFF  6A4,6B4
03314:  MOVLB  6
03316:  CLRF   xBB
03318:  CLRF   xBA
0331A:  CLRF   xB9
0331C:  MOVLW  70
0331E:  MOVWF  xB8
03320:  MOVLB  0
03322:  CALL   130A
03326:  MOVFF  03,6B2
0332A:  MOVFF  02,6B1
0332E:  MOVFF  01,6B0
03332:  MOVFF  00,6AF
03336:  MOVFF  6AD,6B4
0333A:  MOVFF  6AC,6B3
0333E:  CALL   12D4
03342:  BSF    FD8.1
03344:  MOVFF  6B2,6B6
03348:  MOVFF  6B1,6B5
0334C:  MOVFF  6B0,6B4
03350:  MOVFF  6AF,6B3
03354:  MOVFF  03,6BA
03358:  MOVFF  02,6B9
0335C:  MOVFF  01,6B8
03360:  MOVFF  00,6B7
03364:  CALL   1400
03368:  MOVLB  6
0336A:  CLRF   xB7
0336C:  CLRF   xB6
0336E:  CLRF   xB5
03370:  MOVLW  8E
03372:  MOVWF  xB4
03374:  MOVFF  03,6BB
03378:  MOVFF  02,6BA
0337C:  MOVFF  01,6B9
03380:  MOVFF  00,6B8
03384:  MOVLB  0
03386:  CALL   130A
0338A:  MOVFF  03,6A7
0338E:  MOVFF  02,6A6
03392:  MOVFF  01,6A5
03396:  MOVFF  00,6A4
....................       res = 32768.0*(float32)l;
0339A:  MOVFF  6AD,6B4
0339E:  MOVFF  6AC,6B3
033A2:  CALL   12D4
033A6:  MOVLB  6
033A8:  CLRF   xB7
033AA:  CLRF   xB6
033AC:  CLRF   xB5
033AE:  MOVLW  8E
033B0:  MOVWF  xB4
033B2:  MOVFF  03,6BB
033B6:  MOVFF  02,6BA
033BA:  MOVFF  01,6B9
033BE:  MOVFF  00,6B8
033C2:  MOVLB  0
033C4:  CALL   130A
033C8:  MOVFF  03,6AB
033CC:  MOVFF  02,6AA
033D0:  MOVFF  01,6A9
033D4:  MOVFF  00,6A8
....................       res += (float32)(unsigned int16)y;
033D8:  MOVFF  6A7,6B2
033DC:  MOVFF  6A6,6B1
033E0:  MOVFF  6A5,6B0
033E4:  MOVFF  6A4,6AF
033E8:  RCALL  31CA
033EA:  MOVFF  02,6B4
033EE:  MOVFF  01,6B3
033F2:  CALL   12D4
033F6:  BCF    FD8.1
033F8:  MOVFF  6AB,6B6
033FC:  MOVFF  6AA,6B5
03400:  MOVFF  6A9,6B4
03404:  MOVFF  6A8,6B3
03408:  MOVFF  03,6BA
0340C:  MOVFF  02,6B9
03410:  MOVFF  01,6B8
03414:  MOVFF  00,6B7
03418:  CALL   1400
0341C:  MOVFF  03,6AB
03420:  MOVFF  02,6AA
03424:  MOVFF  01,6A9
03428:  MOVFF  00,6A8
....................    }
0342C:  BRA    343E
.................... 
....................  else
....................   res = y;
0342E:  MOVFF  6A7,6AB
03432:  MOVFF  6A6,6AA
03436:  MOVFF  6A5,6A9
0343A:  MOVFF  6A4,6A8
.................... 
....................  y = y - (float32)(unsigned int16)y;
0343E:  MOVFF  6A7,6B2
03442:  MOVFF  6A6,6B1
03446:  MOVFF  6A5,6B0
0344A:  MOVFF  6A4,6AF
0344E:  RCALL  31CA
03450:  MOVFF  02,6B4
03454:  MOVFF  01,6B3
03458:  CALL   12D4
0345C:  BSF    FD8.1
0345E:  MOVFF  6A7,6B6
03462:  MOVFF  6A6,6B5
03466:  MOVFF  6A5,6B4
0346A:  MOVFF  6A4,6B3
0346E:  MOVFF  03,6BA
03472:  MOVFF  02,6B9
03476:  MOVFF  01,6B8
0347A:  MOVFF  00,6B7
0347E:  CALL   1400
03482:  MOVFF  03,6A7
03486:  MOVFF  02,6A6
0348A:  MOVFF  01,6A5
0348E:  MOVFF  00,6A4
.................... 
....................  if (s)
03492:  MOVLB  6
03494:  BTFSS  xAE.0
03496:  BRA    349E
....................   res = -res;
03498:  MOVF   xA9,W
0349A:  XORLW  80
0349C:  MOVWF  xA9
.................... 
....................  if (y != 0)
0349E:  MOVFF  6A7,6B2
034A2:  MOVFF  6A6,6B1
034A6:  MOVFF  6A5,6B0
034AA:  MOVFF  6A4,6AF
034AE:  CLRF   xB6
034B0:  CLRF   xB5
034B2:  CLRF   xB4
034B4:  CLRF   xB3
034B6:  MOVLB  0
034B8:  CALL   27D6
034BC:  BZ    3536
....................  {
....................   if (s == 1 && n == 0)
034BE:  MOVLB  6
034C0:  BTFSS  xAE.0
034C2:  BRA    34FC
034C4:  MOVF   xA3,F
034C6:  BNZ   34FC
....................    res -= 1.0;
034C8:  BSF    FD8.1
034CA:  MOVFF  6AB,6B6
034CE:  MOVFF  6AA,6B5
034D2:  MOVFF  6A9,6B4
034D6:  MOVFF  6A8,6B3
034DA:  CLRF   xBA
034DC:  CLRF   xB9
034DE:  CLRF   xB8
034E0:  MOVLW  7F
034E2:  MOVWF  xB7
034E4:  MOVLB  0
034E6:  CALL   1400
034EA:  MOVFF  03,6AB
034EE:  MOVFF  02,6AA
034F2:  MOVFF  01,6A9
034F6:  MOVFF  00,6A8
034FA:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
034FC:  BTFSC  xAE.0
034FE:  BRA    3538
03500:  DECFSZ xA3,W
03502:  BRA    3538
....................    res += 1.0;
03504:  BCF    FD8.1
03506:  MOVFF  6AB,6B6
0350A:  MOVFF  6AA,6B5
0350E:  MOVFF  6A9,6B4
03512:  MOVFF  6A8,6B3
03516:  CLRF   xBA
03518:  CLRF   xB9
0351A:  CLRF   xB8
0351C:  MOVLW  7F
0351E:  MOVWF  xB7
03520:  MOVLB  0
03522:  CALL   1400
03526:  MOVFF  03,6AB
0352A:  MOVFF  02,6AA
0352E:  MOVFF  01,6A9
03532:  MOVFF  00,6A8
03536:  MOVLB  6
....................  }
....................  if (x == 0)
03538:  MOVFF  6A2,6B2
0353C:  MOVFF  6A1,6B1
03540:  MOVFF  6A0,6B0
03544:  MOVFF  69F,6AF
03548:  CLRF   xB6
0354A:  CLRF   xB5
0354C:  CLRF   xB4
0354E:  CLRF   xB3
03550:  MOVLB  0
03552:  CALL   27D6
03556:  BNZ   3564
....................     res = 0;
03558:  MOVLB  6
0355A:  CLRF   xAB
0355C:  CLRF   xAA
0355E:  CLRF   xA9
03560:  CLRF   xA8
03562:  MOVLB  0
.................... 
....................  return (res);
03564:  MOVFF  6A8,00
03568:  MOVFF  6A9,01
0356C:  MOVFF  6AA,02
03570:  MOVFF  6AB,03
03574:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
03594:  MOVFF  69E,6A2
03598:  MOVFF  69D,6A1
0359C:  MOVFF  69C,6A0
035A0:  MOVFF  69B,69F
035A4:  MOVLB  6
035A6:  CLRF   xA3
035A8:  MOVLB  0
035AA:  RCALL  3206
035AC:  GOTO   36B8 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
03576:  MOVFF  69E,6A2
0357A:  MOVFF  69D,6A1
0357E:  MOVFF  69C,6A0
03582:  MOVFF  69B,69F
03586:  MOVLW  01
03588:  MOVLB  6
0358A:  MOVWF  xA3
0358C:  MOVLB  0
0358E:  RCALL  3206
03590:  GOTO   3670 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
035B0:  MOVFF  692,6B2
035B4:  MOVFF  691,6B1
035B8:  MOVFF  690,6B0
035BC:  MOVFF  68F,6AF
035C0:  MOVLB  6
035C2:  CLRF   xB6
035C4:  CLRF   xB5
035C6:  CLRF   xB4
035C8:  CLRF   xB3
035CA:  MOVLB  0
035CC:  CALL   27D6
035D0:  BTFSC  FD8.2
035D2:  BRA    3714
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
035D4:  MOVFF  68E,6AB
035D8:  MOVFF  68D,6AA
035DC:  MOVFF  68C,6A9
035E0:  MOVFF  68B,6A8
035E4:  MOVFF  692,6AF
035E8:  MOVFF  691,6AE
035EC:  MOVFF  690,6AD
035F0:  MOVFF  68F,6AC
035F4:  CALL   2850
035F8:  MOVFF  03,69A
035FC:  MOVFF  02,699
03600:  MOVFF  01,698
03604:  MOVFF  00,697
03608:  MOVFF  03,6B2
0360C:  MOVFF  02,6B1
03610:  MOVFF  01,6B0
03614:  MOVFF  00,6AF
03618:  MOVLB  6
0361A:  CLRF   xB6
0361C:  CLRF   xB5
0361E:  CLRF   xB4
03620:  CLRF   xB3
03622:  MOVLB  0
03624:  CALL   27D6
03628:  BNC   3672
0362A:  MOVFF  68E,6AB
0362E:  MOVFF  68D,6AA
03632:  MOVFF  68C,6A9
03636:  MOVFF  68B,6A8
0363A:  MOVFF  692,6AF
0363E:  MOVFF  691,6AE
03642:  MOVFF  690,6AD
03646:  MOVFF  68F,6AC
0364A:  CALL   2850
0364E:  MOVFF  03,69A
03652:  MOVFF  02,699
03656:  MOVFF  01,698
0365A:  MOVFF  00,697
0365E:  MOVFF  03,69E
03662:  MOVFF  02,69D
03666:  MOVFF  01,69C
0366A:  MOVFF  00,69B
0366E:  BRA    3576
03670:  BRA    36B8
03672:  MOVFF  68E,6AB
03676:  MOVFF  68D,6AA
0367A:  MOVFF  68C,6A9
0367E:  MOVFF  68B,6A8
03682:  MOVFF  692,6AF
03686:  MOVFF  691,6AE
0368A:  MOVFF  690,6AD
0368E:  MOVFF  68F,6AC
03692:  CALL   2850
03696:  MOVFF  03,69A
0369A:  MOVFF  02,699
0369E:  MOVFF  01,698
036A2:  MOVFF  00,697
036A6:  MOVFF  03,69E
036AA:  MOVFF  02,69D
036AE:  MOVFF  01,69C
036B2:  MOVFF  00,69B
036B6:  BRA    3594
036B8:  MOVFF  03,696
036BC:  MOVFF  02,695
036C0:  MOVFF  01,694
036C4:  MOVFF  00,693
....................       return(x-(i*y));
036C8:  MOVFF  696,6B7
036CC:  MOVFF  695,6B6
036D0:  MOVFF  694,6B5
036D4:  MOVFF  693,6B4
036D8:  MOVFF  692,6BB
036DC:  MOVFF  691,6BA
036E0:  MOVFF  690,6B9
036E4:  MOVFF  68F,6B8
036E8:  CALL   130A
036EC:  BSF    FD8.1
036EE:  MOVFF  68E,6B6
036F2:  MOVFF  68D,6B5
036F6:  MOVFF  68C,6B4
036FA:  MOVFF  68B,6B3
036FE:  MOVFF  03,6BA
03702:  MOVFF  02,6B9
03706:  MOVFF  01,6B8
0370A:  MOVFF  00,6B7
0370E:  CALL   1400
03712:  BRA    3714
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
03714:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
03AAA:  MOVFF  692,6B7
03AAE:  MOVFF  691,6B6
03AB2:  MOVFF  690,6B5
03AB6:  MOVFF  68F,6B4
03ABA:  MOVLW  3B
03ABC:  MOVLB  6
03ABE:  MOVWF  xBB
03AC0:  MOVLW  AA
03AC2:  MOVWF  xBA
03AC4:  MOVLW  38
03AC6:  MOVWF  xB9
03AC8:  MOVLW  7F
03ACA:  MOVWF  xB8
03ACC:  MOVLB  0
03ACE:  CALL   130A
03AD2:  MOVFF  03,6B2
03AD6:  MOVFF  02,6B1
03ADA:  MOVFF  01,6B0
03ADE:  MOVFF  00,6AF
03AE2:  CALL   31CA
03AE6:  MOVFF  01,69F
....................    s = 0;
03AEA:  MOVLB  6
03AEC:  BCF    xA0.0
....................    y = x;
03AEE:  MOVFF  692,696
03AF2:  MOVFF  691,695
03AF6:  MOVFF  690,694
03AFA:  MOVFF  68F,693
.................... 
....................    if (x < 0)
03AFE:  MOVFF  692,6B2
03B02:  MOVFF  691,6B1
03B06:  MOVFF  690,6B0
03B0A:  MOVFF  68F,6AF
03B0E:  CLRF   xB6
03B10:  CLRF   xB5
03B12:  CLRF   xB4
03B14:  CLRF   xB3
03B16:  MOVLB  0
03B18:  CALL   27D6
03B1C:  BNC   3B2C
....................    {
....................       s = 1;
03B1E:  MOVLB  6
03B20:  BSF    xA0.0
....................       n = -n;
03B22:  NEGF   x9F
....................       y = -y;
03B24:  MOVF   x94,W
03B26:  XORLW  80
03B28:  MOVWF  x94
03B2A:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03B2C:  MOVLB  6
03B2E:  CLRF   x9A
03B30:  CLRF   x99
03B32:  CLRF   x98
03B34:  CLRF   x97
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03B36:  MOVLW  06
03B38:  MOVWF  xA2
03B3A:  MOVLW  97
03B3C:  MOVFF  6A2,FEA
03B40:  MOVWF  FE9
03B42:  MOVLW  7F
03B44:  ADDWF  x9F,W
03B46:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03B48:  MOVFF  696,6B7
03B4C:  MOVFF  695,6B6
03B50:  MOVFF  694,6B5
03B54:  MOVFF  693,6B4
03B58:  MOVLW  3B
03B5A:  MOVWF  xBB
03B5C:  MOVLW  AA
03B5E:  MOVWF  xBA
03B60:  MOVLW  38
03B62:  MOVWF  xB9
03B64:  MOVLW  7F
03B66:  MOVWF  xB8
03B68:  MOVLB  0
03B6A:  CALL   130A
03B6E:  MOVFF  03,6A4
03B72:  MOVFF  02,6A3
03B76:  MOVFF  01,6A2
03B7A:  MOVFF  00,6A1
03B7E:  MOVLB  6
03B80:  CLRF   xA6
03B82:  MOVFF  69F,6A5
03B86:  BTFSC  xA5.7
03B88:  DECF   xA6,F
03B8A:  MOVLB  0
03B8C:  CALL   317A
03B90:  BSF    FD8.1
03B92:  MOVFF  6A4,6B6
03B96:  MOVFF  6A3,6B5
03B9A:  MOVFF  6A2,6B4
03B9E:  MOVFF  6A1,6B3
03BA2:  MOVFF  03,6BA
03BA6:  MOVFF  02,6B9
03BAA:  MOVFF  01,6B8
03BAE:  MOVFF  00,6B7
03BB2:  CALL   1400
03BB6:  MOVFF  03,696
03BBA:  MOVFF  02,695
03BBE:  MOVFF  01,694
03BC2:  MOVFF  00,693
.................... 
....................    r = pe[0]*y + pe[1];
03BC6:  MOVLW  7C
03BC8:  MOVLB  6
03BCA:  MOVWF  xB7
03BCC:  MOVLW  88
03BCE:  MOVWF  xB6
03BD0:  MOVLW  59
03BD2:  MOVWF  xB5
03BD4:  MOVLW  72
03BD6:  MOVWF  xB4
03BD8:  MOVFF  696,6BB
03BDC:  MOVFF  695,6BA
03BE0:  MOVFF  694,6B9
03BE4:  MOVFF  693,6B8
03BE8:  MOVLB  0
03BEA:  CALL   130A
03BEE:  MOVFF  03,6A4
03BF2:  MOVFF  02,6A3
03BF6:  MOVFF  01,6A2
03BFA:  MOVFF  00,6A1
03BFE:  BCF    FD8.1
03C00:  MOVFF  03,6B6
03C04:  MOVFF  02,6B5
03C08:  MOVFF  01,6B4
03C0C:  MOVFF  00,6B3
03C10:  MOVLW  E0
03C12:  MOVLB  6
03C14:  MOVWF  xBA
03C16:  MOVLW  97
03C18:  MOVWF  xB9
03C1A:  MOVLW  26
03C1C:  MOVWF  xB8
03C1E:  MOVLW  75
03C20:  MOVWF  xB7
03C22:  MOVLB  0
03C24:  CALL   1400
03C28:  MOVFF  03,69E
03C2C:  MOVFF  02,69D
03C30:  MOVFF  01,69C
03C34:  MOVFF  00,69B
....................    r = r*y + pe[2];
03C38:  MOVFF  69E,6B7
03C3C:  MOVFF  69D,6B6
03C40:  MOVFF  69C,6B5
03C44:  MOVFF  69B,6B4
03C48:  MOVFF  696,6BB
03C4C:  MOVFF  695,6BA
03C50:  MOVFF  694,6B9
03C54:  MOVFF  693,6B8
03C58:  CALL   130A
03C5C:  MOVFF  03,6A4
03C60:  MOVFF  02,6A3
03C64:  MOVFF  01,6A2
03C68:  MOVFF  00,6A1
03C6C:  BCF    FD8.1
03C6E:  MOVFF  03,6B6
03C72:  MOVFF  02,6B5
03C76:  MOVFF  01,6B4
03C7A:  MOVFF  00,6B3
03C7E:  MOVLW  C4
03C80:  MOVLB  6
03C82:  MOVWF  xBA
03C84:  MOVLW  1D
03C86:  MOVWF  xB9
03C88:  MOVLW  1E
03C8A:  MOVWF  xB8
03C8C:  MOVLW  78
03C8E:  MOVWF  xB7
03C90:  MOVLB  0
03C92:  CALL   1400
03C96:  MOVFF  03,69E
03C9A:  MOVFF  02,69D
03C9E:  MOVFF  01,69C
03CA2:  MOVFF  00,69B
....................    r = r*y + pe[3];
03CA6:  MOVFF  69E,6B7
03CAA:  MOVFF  69D,6B6
03CAE:  MOVFF  69C,6B5
03CB2:  MOVFF  69B,6B4
03CB6:  MOVFF  696,6BB
03CBA:  MOVFF  695,6BA
03CBE:  MOVFF  694,6B9
03CC2:  MOVFF  693,6B8
03CC6:  CALL   130A
03CCA:  MOVFF  03,6A4
03CCE:  MOVFF  02,6A3
03CD2:  MOVFF  01,6A2
03CD6:  MOVFF  00,6A1
03CDA:  BCF    FD8.1
03CDC:  MOVFF  03,6B6
03CE0:  MOVFF  02,6B5
03CE4:  MOVFF  01,6B4
03CE8:  MOVFF  00,6B3
03CEC:  MOVLW  5E
03CEE:  MOVLB  6
03CF0:  MOVWF  xBA
03CF2:  MOVLW  50
03CF4:  MOVWF  xB9
03CF6:  MOVLW  63
03CF8:  MOVWF  xB8
03CFA:  MOVLW  7A
03CFC:  MOVWF  xB7
03CFE:  MOVLB  0
03D00:  CALL   1400
03D04:  MOVFF  03,69E
03D08:  MOVFF  02,69D
03D0C:  MOVFF  01,69C
03D10:  MOVFF  00,69B
....................    r = r*y + pe[4];
03D14:  MOVFF  69E,6B7
03D18:  MOVFF  69D,6B6
03D1C:  MOVFF  69C,6B5
03D20:  MOVFF  69B,6B4
03D24:  MOVFF  696,6BB
03D28:  MOVFF  695,6BA
03D2C:  MOVFF  694,6B9
03D30:  MOVFF  693,6B8
03D34:  CALL   130A
03D38:  MOVFF  03,6A4
03D3C:  MOVFF  02,6A3
03D40:  MOVFF  01,6A2
03D44:  MOVFF  00,6A1
03D48:  BCF    FD8.1
03D4A:  MOVFF  03,6B6
03D4E:  MOVFF  02,6B5
03D52:  MOVFF  01,6B4
03D56:  MOVFF  00,6B3
03D5A:  MOVLW  1A
03D5C:  MOVLB  6
03D5E:  MOVWF  xBA
03D60:  MOVLW  FE
03D62:  MOVWF  xB9
03D64:  MOVLW  75
03D66:  MOVWF  xB8
03D68:  MOVLW  7C
03D6A:  MOVWF  xB7
03D6C:  MOVLB  0
03D6E:  CALL   1400
03D72:  MOVFF  03,69E
03D76:  MOVFF  02,69D
03D7A:  MOVFF  01,69C
03D7E:  MOVFF  00,69B
....................    r = r*y + pe[5];
03D82:  MOVFF  69E,6B7
03D86:  MOVFF  69D,6B6
03D8A:  MOVFF  69C,6B5
03D8E:  MOVFF  69B,6B4
03D92:  MOVFF  696,6BB
03D96:  MOVFF  695,6BA
03D9A:  MOVFF  694,6B9
03D9E:  MOVFF  693,6B8
03DA2:  CALL   130A
03DA6:  MOVFF  03,6A4
03DAA:  MOVFF  02,6A3
03DAE:  MOVFF  01,6A2
03DB2:  MOVFF  00,6A1
03DB6:  BCF    FD8.1
03DB8:  MOVFF  03,6B6
03DBC:  MOVFF  02,6B5
03DC0:  MOVFF  01,6B4
03DC4:  MOVFF  00,6B3
03DC8:  MOVLW  18
03DCA:  MOVLB  6
03DCC:  MOVWF  xBA
03DCE:  MOVLW  72
03DD0:  MOVWF  xB9
03DD2:  MOVLW  31
03DD4:  MOVWF  xB8
03DD6:  MOVLW  7E
03DD8:  MOVWF  xB7
03DDA:  MOVLB  0
03DDC:  CALL   1400
03DE0:  MOVFF  03,69E
03DE4:  MOVFF  02,69D
03DE8:  MOVFF  01,69C
03DEC:  MOVFF  00,69B
.................... 
....................    res = res*(1.0 + y*r);
03DF0:  MOVFF  696,6B7
03DF4:  MOVFF  695,6B6
03DF8:  MOVFF  694,6B5
03DFC:  MOVFF  693,6B4
03E00:  MOVFF  69E,6BB
03E04:  MOVFF  69D,6BA
03E08:  MOVFF  69C,6B9
03E0C:  MOVFF  69B,6B8
03E10:  CALL   130A
03E14:  BCF    FD8.1
03E16:  MOVLB  6
03E18:  CLRF   xB6
03E1A:  CLRF   xB5
03E1C:  CLRF   xB4
03E1E:  MOVLW  7F
03E20:  MOVWF  xB3
03E22:  MOVFF  03,6BA
03E26:  MOVFF  02,6B9
03E2A:  MOVFF  01,6B8
03E2E:  MOVFF  00,6B7
03E32:  MOVLB  0
03E34:  CALL   1400
03E38:  MOVFF  69A,6B7
03E3C:  MOVFF  699,6B6
03E40:  MOVFF  698,6B5
03E44:  MOVFF  697,6B4
03E48:  MOVFF  03,6BB
03E4C:  MOVFF  02,6BA
03E50:  MOVFF  01,6B9
03E54:  MOVFF  00,6B8
03E58:  CALL   130A
03E5C:  MOVFF  03,69A
03E60:  MOVFF  02,699
03E64:  MOVFF  01,698
03E68:  MOVFF  00,697
.................... 
....................    if (s)
03E6C:  MOVLB  6
03E6E:  BTFSS  xA0.0
03E70:  BRA    3EA4
....................       res = 1.0/res;
03E72:  CLRF   xAB
03E74:  CLRF   xAA
03E76:  CLRF   xA9
03E78:  MOVLW  7F
03E7A:  MOVWF  xA8
03E7C:  MOVFF  69A,6AF
03E80:  MOVFF  699,6AE
03E84:  MOVFF  698,6AD
03E88:  MOVFF  697,6AC
03E8C:  MOVLB  0
03E8E:  CALL   2850
03E92:  MOVFF  03,69A
03E96:  MOVFF  02,699
03E9A:  MOVFF  01,698
03E9E:  MOVFF  00,697
03EA2:  MOVLB  6
....................    return(res);
03EA4:  MOVFF  697,00
03EA8:  MOVFF  698,01
03EAC:  MOVFF  699,02
03EB0:  MOVFF  69A,03
03EB4:  MOVLB  0
03EB6:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
03716:  MOVFF  692,696
0371A:  MOVFF  691,695
0371E:  MOVFF  690,694
03722:  MOVFF  68F,693
.................... 
....................    if (y != 1.0)
03726:  MOVFF  696,6B2
0372A:  MOVFF  695,6B1
0372E:  MOVFF  694,6B0
03732:  MOVFF  693,6AF
03736:  MOVLB  6
03738:  CLRF   xB6
0373A:  CLRF   xB5
0373C:  CLRF   xB4
0373E:  MOVLW  7F
03740:  MOVWF  xB3
03742:  MOVLB  0
03744:  CALL   27D6
03748:  BTFSC  FD8.2
0374A:  BRA    3A8C
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
0374C:  MOVLW  06
0374E:  MOVLB  6
03750:  MOVWF  xA5
03752:  MOVLW  93
03754:  MOVFF  6A5,FEA
03758:  MOVWF  FE9
0375A:  MOVLW  7E
0375C:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
0375E:  BSF    FD8.1
03760:  MOVFF  696,6B6
03764:  MOVFF  695,6B5
03768:  MOVFF  694,6B4
0376C:  MOVFF  693,6B3
03770:  CLRF   xBA
03772:  CLRF   xB9
03774:  CLRF   xB8
03776:  MOVLW  7F
03778:  MOVWF  xB7
0377A:  MOVLB  0
0377C:  CALL   1400
03780:  MOVFF  03,6A7
03784:  MOVFF  02,6A6
03788:  MOVFF  01,6A5
0378C:  MOVFF  00,6A4
03790:  BCF    FD8.1
03792:  MOVFF  696,6B6
03796:  MOVFF  695,6B5
0379A:  MOVFF  694,6B4
0379E:  MOVFF  693,6B3
037A2:  MOVLB  6
037A4:  CLRF   xBA
037A6:  CLRF   xB9
037A8:  CLRF   xB8
037AA:  MOVLW  7F
037AC:  MOVWF  xB7
037AE:  MOVLB  0
037B0:  CALL   1400
037B4:  MOVFF  6A7,6AB
037B8:  MOVFF  6A6,6AA
037BC:  MOVFF  6A5,6A9
037C0:  MOVFF  6A4,6A8
037C4:  MOVFF  03,6AF
037C8:  MOVFF  02,6AE
037CC:  MOVFF  01,6AD
037D0:  MOVFF  00,6AC
037D4:  CALL   2850
037D8:  MOVFF  03,696
037DC:  MOVFF  02,695
037E0:  MOVFF  01,694
037E4:  MOVFF  00,693
.................... 
....................       y2=y*y;
037E8:  MOVFF  696,6B7
037EC:  MOVFF  695,6B6
037F0:  MOVFF  694,6B5
037F4:  MOVFF  693,6B4
037F8:  MOVFF  696,6BB
037FC:  MOVFF  695,6BA
03800:  MOVFF  694,6B9
03804:  MOVFF  693,6B8
03808:  CALL   130A
0380C:  MOVFF  03,6A2
03810:  MOVFF  02,6A1
03814:  MOVFF  01,6A0
03818:  MOVFF  00,69F
.................... 
....................       res = pl[0]*y2 + pl[1];
0381C:  MOVLW  99
0381E:  MOVLB  6
03820:  MOVWF  xB7
03822:  MOVLW  47
03824:  MOVWF  xB6
03826:  MOVLW  8A
03828:  MOVWF  xB5
0382A:  MOVLW  7F
0382C:  MOVWF  xB4
0382E:  MOVFF  6A2,6BB
03832:  MOVFF  6A1,6BA
03836:  MOVFF  6A0,6B9
0383A:  MOVFF  69F,6B8
0383E:  MOVLB  0
03840:  CALL   130A
03844:  MOVFF  03,6A7
03848:  MOVFF  02,6A6
0384C:  MOVFF  01,6A5
03850:  MOVFF  00,6A4
03854:  BCF    FD8.1
03856:  MOVFF  03,6B6
0385A:  MOVFF  02,6B5
0385E:  MOVFF  01,6B4
03862:  MOVFF  00,6B3
03866:  MOVLB  6
03868:  CLRF   xBA
0386A:  CLRF   xB9
0386C:  CLRF   xB8
0386E:  MOVLW  80
03870:  MOVWF  xB7
03872:  MOVLB  0
03874:  CALL   1400
03878:  MOVFF  03,69A
0387C:  MOVFF  02,699
03880:  MOVFF  01,698
03884:  MOVFF  00,697
.................... 
....................       r = ql[0]*y2 + ql[1];
03888:  MOVLW  4C
0388A:  MOVLB  6
0388C:  MOVWF  xB7
0388E:  MOVLW  F3
03890:  MOVWF  xB6
03892:  MOVLW  3A
03894:  MOVWF  xB5
03896:  MOVLW  7B
03898:  MOVWF  xB4
0389A:  MOVFF  6A2,6BB
0389E:  MOVFF  6A1,6BA
038A2:  MOVFF  6A0,6B9
038A6:  MOVFF  69F,6B8
038AA:  MOVLB  0
038AC:  CALL   130A
038B0:  MOVFF  03,6A7
038B4:  MOVFF  02,6A6
038B8:  MOVFF  01,6A5
038BC:  MOVFF  00,6A4
038C0:  BCF    FD8.1
038C2:  MOVFF  03,6B6
038C6:  MOVFF  02,6B5
038CA:  MOVFF  01,6B4
038CE:  MOVFF  00,6B3
038D2:  MOVLW  2B
038D4:  MOVLB  6
038D6:  MOVWF  xBA
038D8:  MOVLW  9D
038DA:  MOVWF  xB9
038DC:  MOVLW  DF
038DE:  MOVWF  xB8
038E0:  MOVLW  7E
038E2:  MOVWF  xB7
038E4:  MOVLB  0
038E6:  CALL   1400
038EA:  MOVFF  03,69E
038EE:  MOVFF  02,69D
038F2:  MOVFF  01,69C
038F6:  MOVFF  00,69B
....................       r = r*y2 + 1.0;
038FA:  MOVFF  69E,6B7
038FE:  MOVFF  69D,6B6
03902:  MOVFF  69C,6B5
03906:  MOVFF  69B,6B4
0390A:  MOVFF  6A2,6BB
0390E:  MOVFF  6A1,6BA
03912:  MOVFF  6A0,6B9
03916:  MOVFF  69F,6B8
0391A:  CALL   130A
0391E:  MOVFF  03,6A7
03922:  MOVFF  02,6A6
03926:  MOVFF  01,6A5
0392A:  MOVFF  00,6A4
0392E:  BCF    FD8.1
03930:  MOVFF  03,6B6
03934:  MOVFF  02,6B5
03938:  MOVFF  01,6B4
0393C:  MOVFF  00,6B3
03940:  MOVLB  6
03942:  CLRF   xBA
03944:  CLRF   xB9
03946:  CLRF   xB8
03948:  MOVLW  7F
0394A:  MOVWF  xB7
0394C:  MOVLB  0
0394E:  CALL   1400
03952:  MOVFF  03,69E
03956:  MOVFF  02,69D
0395A:  MOVFF  01,69C
0395E:  MOVFF  00,69B
.................... 
....................       res = y*res/r;
03962:  MOVFF  696,6B7
03966:  MOVFF  695,6B6
0396A:  MOVFF  694,6B5
0396E:  MOVFF  693,6B4
03972:  MOVFF  69A,6BB
03976:  MOVFF  699,6BA
0397A:  MOVFF  698,6B9
0397E:  MOVFF  697,6B8
03982:  CALL   130A
03986:  MOVFF  03,6A7
0398A:  MOVFF  02,6A6
0398E:  MOVFF  01,6A5
03992:  MOVFF  00,6A4
03996:  MOVFF  03,6AB
0399A:  MOVFF  02,6AA
0399E:  MOVFF  01,6A9
039A2:  MOVFF  00,6A8
039A6:  MOVFF  69E,6AF
039AA:  MOVFF  69D,6AE
039AE:  MOVFF  69C,6AD
039B2:  MOVFF  69B,6AC
039B6:  CALL   2850
039BA:  MOVFF  03,69A
039BE:  MOVFF  02,699
039C2:  MOVFF  01,698
039C6:  MOVFF  00,697
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
039CA:  MOVLW  06
039CC:  MOVLB  6
039CE:  MOVWF  xA5
039D0:  MOVLW  8F
039D2:  MOVFF  6A5,FEA
039D6:  MOVWF  FE9
039D8:  MOVLW  7E
039DA:  SUBWF  FEF,W
039DC:  MOVWF  xA3
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
039DE:  BTFSS  xA3.7
039E0:  BRA    3A0C
....................          r = -(float32)-n;
039E2:  MOVLW  00
039E4:  BSF    FD8.0
039E6:  SUBFWB xA3,W
039E8:  CLRF   xA6
039EA:  MOVWF  xA5
039EC:  BTFSC  xA5.7
039EE:  DECF   xA6,F
039F0:  MOVLB  0
039F2:  CALL   317A
039F6:  MOVFF  00,69B
039FA:  MOVF   01,W
039FC:  XORLW  80
039FE:  MOVLB  6
03A00:  MOVWF  x9C
03A02:  MOVFF  02,69D
03A06:  MOVFF  03,69E
03A0A:  BRA    3A2E
....................       else
....................          r = (float32)n;
03A0C:  CLRF   xA6
03A0E:  MOVFF  6A3,6A5
03A12:  BTFSC  xA5.7
03A14:  DECF   xA6,F
03A16:  MOVLB  0
03A18:  CALL   317A
03A1C:  MOVFF  03,69E
03A20:  MOVFF  02,69D
03A24:  MOVFF  01,69C
03A28:  MOVFF  00,69B
03A2C:  MOVLB  6
.................... 
....................       res += r*LN2;
03A2E:  MOVFF  69E,6B7
03A32:  MOVFF  69D,6B6
03A36:  MOVFF  69C,6B5
03A3A:  MOVFF  69B,6B4
03A3E:  MOVLW  18
03A40:  MOVWF  xBB
03A42:  MOVLW  72
03A44:  MOVWF  xBA
03A46:  MOVLW  31
03A48:  MOVWF  xB9
03A4A:  MOVLW  7E
03A4C:  MOVWF  xB8
03A4E:  MOVLB  0
03A50:  CALL   130A
03A54:  BCF    FD8.1
03A56:  MOVFF  69A,6B6
03A5A:  MOVFF  699,6B5
03A5E:  MOVFF  698,6B4
03A62:  MOVFF  697,6B3
03A66:  MOVFF  03,6BA
03A6A:  MOVFF  02,6B9
03A6E:  MOVFF  01,6B8
03A72:  MOVFF  00,6B7
03A76:  CALL   1400
03A7A:  MOVFF  03,69A
03A7E:  MOVFF  02,699
03A82:  MOVFF  01,698
03A86:  MOVFF  00,697
....................    }
03A8A:  BRA    3A98
.................... 
....................    else
....................       res = 0.0;
03A8C:  MOVLB  6
03A8E:  CLRF   x9A
03A90:  CLRF   x99
03A92:  CLRF   x98
03A94:  CLRF   x97
03A96:  MOVLB  0
.................... 
....................    return(res);
03A98:  MOVFF  697,00
03A9C:  MOVFF  698,01
03AA0:  MOVFF  699,02
03AA4:  MOVFF  69A,03
03AA8:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03EB8:  MOVFF  686,6B2
03EBC:  MOVFF  685,6B1
03EC0:  MOVFF  684,6B0
03EC4:  MOVFF  683,6AF
03EC8:  MOVLB  6
03ECA:  CLRF   xB6
03ECC:  CLRF   xB5
03ECE:  CLRF   xB4
03ED0:  CLRF   xB3
03ED2:  MOVLB  0
03ED4:  CALL   27D6
03ED8:  BTFSS  FD8.0
03EDA:  BRA    4076
03EDC:  MOVFF  68A,68E
03EE0:  MOVFF  689,68D
03EE4:  MOVFF  688,68C
03EE8:  MOVFF  687,68B
03EEC:  MOVLB  6
03EEE:  CLRF   x92
03EF0:  CLRF   x91
03EF2:  CLRF   x90
03EF4:  MOVLW  7F
03EF6:  MOVWF  x8F
03EF8:  MOVLB  0
03EFA:  CALL   35B0
03EFE:  MOVFF  03,68E
03F02:  MOVFF  02,68D
03F06:  MOVFF  01,68C
03F0A:  MOVFF  00,68B
03F0E:  MOVFF  03,6B2
03F12:  MOVFF  02,6B1
03F16:  MOVFF  01,6B0
03F1A:  MOVFF  00,6AF
03F1E:  MOVLB  6
03F20:  CLRF   xB6
03F22:  CLRF   xB5
03F24:  CLRF   xB4
03F26:  CLRF   xB3
03F28:  MOVLB  0
03F2A:  CALL   27D6
03F2E:  BTFSS  FD8.2
03F30:  BRA    4076
....................       if(fmod(y, 2) == 0) {
03F32:  MOVFF  68A,68E
03F36:  MOVFF  689,68D
03F3A:  MOVFF  688,68C
03F3E:  MOVFF  687,68B
03F42:  MOVLB  6
03F44:  CLRF   x92
03F46:  CLRF   x91
03F48:  CLRF   x90
03F4A:  MOVLW  80
03F4C:  MOVWF  x8F
03F4E:  MOVLB  0
03F50:  CALL   35B0
03F54:  MOVFF  03,68E
03F58:  MOVFF  02,68D
03F5C:  MOVFF  01,68C
03F60:  MOVFF  00,68B
03F64:  MOVFF  03,6B2
03F68:  MOVFF  02,6B1
03F6C:  MOVFF  01,6B0
03F70:  MOVFF  00,6AF
03F74:  MOVLB  6
03F76:  CLRF   xB6
03F78:  CLRF   xB5
03F7A:  CLRF   xB4
03F7C:  CLRF   xB3
03F7E:  MOVLB  0
03F80:  CALL   27D6
03F84:  BNZ   3FFC
....................          return (exp(log(-x) * y));
03F86:  MOVLB  6
03F88:  MOVF   x84,W
03F8A:  XORLW  80
03F8C:  MOVWF  x8C
03F8E:  MOVFF  686,692
03F92:  MOVFF  685,691
03F96:  MOVWF  x90
03F98:  MOVFF  683,68F
03F9C:  MOVLB  0
03F9E:  CALL   3716
03FA2:  MOVFF  03,68E
03FA6:  MOVFF  02,68D
03FAA:  MOVFF  01,68C
03FAE:  MOVFF  00,68B
03FB2:  MOVFF  03,6B7
03FB6:  MOVFF  02,6B6
03FBA:  MOVFF  01,6B5
03FBE:  MOVFF  00,6B4
03FC2:  MOVFF  68A,6BB
03FC6:  MOVFF  689,6BA
03FCA:  MOVFF  688,6B9
03FCE:  MOVFF  687,6B8
03FD2:  CALL   130A
03FD6:  MOVFF  03,68E
03FDA:  MOVFF  02,68D
03FDE:  MOVFF  01,68C
03FE2:  MOVFF  00,68B
03FE6:  MOVFF  03,692
03FEA:  MOVFF  02,691
03FEE:  MOVFF  01,690
03FF2:  MOVFF  00,68F
03FF6:  RCALL  3AAA
03FF8:  BRA    41B4
....................       } else {
03FFA:  BRA    4074
....................          return (-exp(log(-x) * y));
03FFC:  MOVLB  6
03FFE:  MOVF   x84,W
04000:  XORLW  80
04002:  MOVWF  x8C
04004:  MOVFF  686,692
04008:  MOVFF  685,691
0400C:  MOVWF  x90
0400E:  MOVFF  683,68F
04012:  MOVLB  0
04014:  CALL   3716
04018:  MOVFF  03,68E
0401C:  MOVFF  02,68D
04020:  MOVFF  01,68C
04024:  MOVFF  00,68B
04028:  MOVFF  03,6B7
0402C:  MOVFF  02,6B6
04030:  MOVFF  01,6B5
04034:  MOVFF  00,6B4
04038:  MOVFF  68A,6BB
0403C:  MOVFF  689,6BA
04040:  MOVFF  688,6B9
04044:  MOVFF  687,6B8
04048:  CALL   130A
0404C:  MOVFF  03,68E
04050:  MOVFF  02,68D
04054:  MOVFF  01,68C
04058:  MOVFF  00,68B
0405C:  MOVFF  03,692
04060:  MOVFF  02,691
04064:  MOVFF  01,690
04068:  MOVFF  00,68F
0406C:  RCALL  3AAA
0406E:  MOVLW  80
04070:  XORWF  01,F
04072:  BRA    41B4
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
04074:  BRA    41B4
04076:  MOVFF  686,6B2
0407A:  MOVFF  685,6B1
0407E:  MOVFF  684,6B0
04082:  MOVFF  683,6AF
04086:  MOVLB  6
04088:  CLRF   xB6
0408A:  CLRF   xB5
0408C:  CLRF   xB4
0408E:  CLRF   xB3
04090:  MOVLB  0
04092:  CALL   27D6
04096:  BNC   40F8
04098:  MOVFF  68A,68E
0409C:  MOVFF  689,68D
040A0:  MOVFF  688,68C
040A4:  MOVFF  687,68B
040A8:  MOVLB  6
040AA:  CLRF   x92
040AC:  CLRF   x91
040AE:  CLRF   x90
040B0:  MOVLW  7F
040B2:  MOVWF  x8F
040B4:  MOVLB  0
040B6:  CALL   35B0
040BA:  MOVFF  03,68E
040BE:  MOVFF  02,68D
040C2:  MOVFF  01,68C
040C6:  MOVFF  00,68B
040CA:  MOVFF  03,6B2
040CE:  MOVFF  02,6B1
040D2:  MOVFF  01,6B0
040D6:  MOVFF  00,6AF
040DA:  MOVLB  6
040DC:  CLRF   xB6
040DE:  CLRF   xB5
040E0:  CLRF   xB4
040E2:  CLRF   xB3
040E4:  MOVLB  0
040E6:  CALL   27D6
040EA:  BZ    40F8
....................       return 0;
040EC:  CLRF   00
040EE:  CLRF   01
040F0:  CLRF   02
040F2:  CLRF   03
040F4:  BRA    41B4
....................    } else {
040F6:  BRA    41B4
....................       if(x != 0 || 0 >= y) {
040F8:  MOVFF  686,6B2
040FC:  MOVFF  685,6B1
04100:  MOVFF  684,6B0
04104:  MOVFF  683,6AF
04108:  MOVLB  6
0410A:  CLRF   xB6
0410C:  CLRF   xB5
0410E:  CLRF   xB4
04110:  CLRF   xB3
04112:  MOVLB  0
04114:  CALL   27D6
04118:  BNZ   413E
0411A:  MOVFF  68A,6B2
0411E:  MOVFF  689,6B1
04122:  MOVFF  688,6B0
04126:  MOVFF  687,6AF
0412A:  MOVLB  6
0412C:  CLRF   xB6
0412E:  CLRF   xB5
04130:  CLRF   xB4
04132:  CLRF   xB3
04134:  MOVLB  0
04136:  CALL   27D6
0413A:  BC    413E
0413C:  BNZ   41AC
....................          return (exp(log(x) * y));
0413E:  MOVFF  686,692
04142:  MOVFF  685,691
04146:  MOVFF  684,690
0414A:  MOVFF  683,68F
0414E:  CALL   3716
04152:  MOVFF  03,68E
04156:  MOVFF  02,68D
0415A:  MOVFF  01,68C
0415E:  MOVFF  00,68B
04162:  MOVFF  03,6B7
04166:  MOVFF  02,6B6
0416A:  MOVFF  01,6B5
0416E:  MOVFF  00,6B4
04172:  MOVFF  68A,6BB
04176:  MOVFF  689,6BA
0417A:  MOVFF  688,6B9
0417E:  MOVFF  687,6B8
04182:  CALL   130A
04186:  MOVFF  03,68E
0418A:  MOVFF  02,68D
0418E:  MOVFF  01,68C
04192:  MOVFF  00,68B
04196:  MOVFF  03,692
0419A:  MOVFF  02,691
0419E:  MOVFF  01,690
041A2:  MOVFF  00,68F
041A6:  RCALL  3AAA
041A8:  BRA    41B4
....................       } else return 0;
041AA:  BRA    41B4
041AC:  CLRF   00
041AE:  CLRF   01
041B0:  CLRF   02
041B2:  CLRF   03
....................    }
041B4:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
029AE:  MOVLB  6
029B0:  BCF    xA1.0
....................    flag = 0;
029B2:  BCF    xA1.1
....................    y = x;
029B4:  MOVFF  694,698
029B8:  MOVFF  693,697
029BC:  MOVFF  692,696
029C0:  MOVFF  691,695
.................... 
....................    if (x < 0)
029C4:  MOVFF  694,6B2
029C8:  MOVFF  693,6B1
029CC:  MOVFF  692,6B0
029D0:  MOVFF  691,6AF
029D4:  CLRF   xB6
029D6:  CLRF   xB5
029D8:  CLRF   xB4
029DA:  CLRF   xB3
029DC:  MOVLB  0
029DE:  RCALL  27D6
029E0:  BNC   29EE
....................    {
....................       s = 1;
029E2:  MOVLB  6
029E4:  BSF    xA1.0
....................       y = -y;
029E6:  MOVF   x96,W
029E8:  XORLW  80
029EA:  MOVWF  x96
029EC:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
029EE:  MOVLB  6
029F0:  CLRF   xB2
029F2:  CLRF   xB1
029F4:  CLRF   xB0
029F6:  MOVLW  7F
029F8:  MOVWF  xAF
029FA:  MOVFF  698,6B6
029FE:  MOVFF  697,6B5
02A02:  MOVFF  696,6B4
02A06:  MOVFF  695,6B3
02A0A:  MOVLB  0
02A0C:  RCALL  27D6
02A0E:  BNC   2A46
....................    {
....................       y = 1.0/y;
02A10:  MOVLB  6
02A12:  CLRF   xAB
02A14:  CLRF   xAA
02A16:  CLRF   xA9
02A18:  MOVLW  7F
02A1A:  MOVWF  xA8
02A1C:  MOVFF  698,6AF
02A20:  MOVFF  697,6AE
02A24:  MOVFF  696,6AD
02A28:  MOVFF  695,6AC
02A2C:  MOVLB  0
02A2E:  RCALL  2850
02A30:  MOVFF  03,698
02A34:  MOVFF  02,697
02A38:  MOVFF  01,696
02A3C:  MOVFF  00,695
....................       flag = 1;
02A40:  MOVLB  6
02A42:  BSF    xA1.1
02A44:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
02A46:  MOVLW  0A
02A48:  MOVLB  6
02A4A:  MOVWF  xB7
02A4C:  MOVLW  89
02A4E:  MOVWF  xB6
02A50:  MOVLW  34
02A52:  MOVWF  xB5
02A54:  MOVLW  7C
02A56:  MOVWF  xB4
02A58:  MOVFF  698,6BB
02A5C:  MOVFF  697,6BA
02A60:  MOVFF  696,6B9
02A64:  MOVFF  695,6B8
02A68:  MOVLB  0
02A6A:  CALL   130A
02A6E:  MOVFF  03,6A5
02A72:  MOVFF  02,6A4
02A76:  MOVFF  01,6A3
02A7A:  MOVFF  00,6A2
02A7E:  MOVFF  03,6B7
02A82:  MOVFF  02,6B6
02A86:  MOVFF  01,6B5
02A8A:  MOVFF  00,6B4
02A8E:  MOVFF  698,6BB
02A92:  MOVFF  697,6BA
02A96:  MOVFF  696,6B9
02A9A:  MOVFF  695,6B8
02A9E:  CALL   130A
02AA2:  MOVFF  03,6A5
02AA6:  MOVFF  02,6A4
02AAA:  MOVFF  01,6A3
02AAE:  MOVFF  00,6A2
02AB2:  BCF    FD8.1
02AB4:  MOVFF  03,6B6
02AB8:  MOVFF  02,6B5
02ABC:  MOVFF  01,6B4
02AC0:  MOVFF  00,6B3
02AC4:  MOVLW  7C
02AC6:  MOVLB  6
02AC8:  MOVWF  xBA
02ACA:  MOVLW  79
02ACC:  MOVWF  xB9
02ACE:  MOVLW  35
02AD0:  MOVWF  xB8
02AD2:  MOVLW  81
02AD4:  MOVWF  xB7
02AD6:  MOVLB  0
02AD8:  CALL   1400
02ADC:  MOVFF  03,69C
02AE0:  MOVFF  02,69B
02AE4:  MOVFF  01,69A
02AE8:  MOVFF  00,699
....................    res = res*y*y + pat[2];
02AEC:  MOVFF  69C,6B7
02AF0:  MOVFF  69B,6B6
02AF4:  MOVFF  69A,6B5
02AF8:  MOVFF  699,6B4
02AFC:  MOVFF  698,6BB
02B00:  MOVFF  697,6BA
02B04:  MOVFF  696,6B9
02B08:  MOVFF  695,6B8
02B0C:  CALL   130A
02B10:  MOVFF  03,6A5
02B14:  MOVFF  02,6A4
02B18:  MOVFF  01,6A3
02B1C:  MOVFF  00,6A2
02B20:  MOVFF  03,6B7
02B24:  MOVFF  02,6B6
02B28:  MOVFF  01,6B5
02B2C:  MOVFF  00,6B4
02B30:  MOVFF  698,6BB
02B34:  MOVFF  697,6BA
02B38:  MOVFF  696,6B9
02B3C:  MOVFF  695,6B8
02B40:  CALL   130A
02B44:  MOVFF  03,6A5
02B48:  MOVFF  02,6A4
02B4C:  MOVFF  01,6A3
02B50:  MOVFF  00,6A2
02B54:  BCF    FD8.1
02B56:  MOVFF  03,6B6
02B5A:  MOVFF  02,6B5
02B5E:  MOVFF  01,6B4
02B62:  MOVFF  00,6B3
02B66:  MOVLW  3F
02B68:  MOVLB  6
02B6A:  MOVWF  xBA
02B6C:  MOVLW  02
02B6E:  MOVWF  xB9
02B70:  MOVLW  33
02B72:  MOVWF  xB8
02B74:  MOVLW  83
02B76:  MOVWF  xB7
02B78:  MOVLB  0
02B7A:  CALL   1400
02B7E:  MOVFF  03,69C
02B82:  MOVFF  02,69B
02B86:  MOVFF  01,69A
02B8A:  MOVFF  00,699
....................    res = res*y*y + pat[3];
02B8E:  MOVFF  69C,6B7
02B92:  MOVFF  69B,6B6
02B96:  MOVFF  69A,6B5
02B9A:  MOVFF  699,6B4
02B9E:  MOVFF  698,6BB
02BA2:  MOVFF  697,6BA
02BA6:  MOVFF  696,6B9
02BAA:  MOVFF  695,6B8
02BAE:  CALL   130A
02BB2:  MOVFF  03,6A5
02BB6:  MOVFF  02,6A4
02BBA:  MOVFF  01,6A3
02BBE:  MOVFF  00,6A2
02BC2:  MOVFF  03,6B7
02BC6:  MOVFF  02,6B6
02BCA:  MOVFF  01,6B5
02BCE:  MOVFF  00,6B4
02BD2:  MOVFF  698,6BB
02BD6:  MOVFF  697,6BA
02BDA:  MOVFF  696,6B9
02BDE:  MOVFF  695,6B8
02BE2:  CALL   130A
02BE6:  MOVFF  03,6A5
02BEA:  MOVFF  02,6A4
02BEE:  MOVFF  01,6A3
02BF2:  MOVFF  00,6A2
02BF6:  BCF    FD8.1
02BF8:  MOVFF  03,6B6
02BFC:  MOVFF  02,6B5
02C00:  MOVFF  01,6B4
02C04:  MOVFF  00,6B3
02C08:  MOVLW  33
02C0A:  MOVLB  6
02C0C:  MOVWF  xBA
02C0E:  MOVLW  8C
02C10:  MOVWF  xB9
02C12:  MOVLW  1E
02C14:  MOVWF  xB8
02C16:  MOVLW  83
02C18:  MOVWF  xB7
02C1A:  MOVLB  0
02C1C:  CALL   1400
02C20:  MOVFF  03,69C
02C24:  MOVFF  02,69B
02C28:  MOVFF  01,69A
02C2C:  MOVFF  00,699
.................... 
....................    r = qat[0]*y*y + qat[1];
02C30:  MOVLB  6
02C32:  CLRF   xB7
02C34:  CLRF   xB6
02C36:  CLRF   xB5
02C38:  MOVLW  7F
02C3A:  MOVWF  xB4
02C3C:  MOVFF  698,6BB
02C40:  MOVFF  697,6BA
02C44:  MOVFF  696,6B9
02C48:  MOVFF  695,6B8
02C4C:  MOVLB  0
02C4E:  CALL   130A
02C52:  MOVFF  03,6A5
02C56:  MOVFF  02,6A4
02C5A:  MOVFF  01,6A3
02C5E:  MOVFF  00,6A2
02C62:  MOVFF  03,6B7
02C66:  MOVFF  02,6B6
02C6A:  MOVFF  01,6B5
02C6E:  MOVFF  00,6B4
02C72:  MOVFF  698,6BB
02C76:  MOVFF  697,6BA
02C7A:  MOVFF  696,6B9
02C7E:  MOVFF  695,6B8
02C82:  CALL   130A
02C86:  MOVFF  03,6A5
02C8A:  MOVFF  02,6A4
02C8E:  MOVFF  01,6A3
02C92:  MOVFF  00,6A2
02C96:  BCF    FD8.1
02C98:  MOVFF  03,6B6
02C9C:  MOVFF  02,6B5
02CA0:  MOVFF  01,6B4
02CA4:  MOVFF  00,6B3
02CA8:  MOVLW  1B
02CAA:  MOVLB  6
02CAC:  MOVWF  xBA
02CAE:  MOVLW  E4
02CB0:  MOVWF  xB9
02CB2:  MOVLW  35
02CB4:  MOVWF  xB8
02CB6:  MOVLW  82
02CB8:  MOVWF  xB7
02CBA:  MOVLB  0
02CBC:  CALL   1400
02CC0:  MOVFF  03,6A0
02CC4:  MOVFF  02,69F
02CC8:  MOVFF  01,69E
02CCC:  MOVFF  00,69D
....................    r = r*y*y + qat[2];
02CD0:  MOVFF  6A0,6B7
02CD4:  MOVFF  69F,6B6
02CD8:  MOVFF  69E,6B5
02CDC:  MOVFF  69D,6B4
02CE0:  MOVFF  698,6BB
02CE4:  MOVFF  697,6BA
02CE8:  MOVFF  696,6B9
02CEC:  MOVFF  695,6B8
02CF0:  CALL   130A
02CF4:  MOVFF  03,6A5
02CF8:  MOVFF  02,6A4
02CFC:  MOVFF  01,6A3
02D00:  MOVFF  00,6A2
02D04:  MOVFF  03,6B7
02D08:  MOVFF  02,6B6
02D0C:  MOVFF  01,6B5
02D10:  MOVFF  00,6B4
02D14:  MOVFF  698,6BB
02D18:  MOVFF  697,6BA
02D1C:  MOVFF  696,6B9
02D20:  MOVFF  695,6B8
02D24:  CALL   130A
02D28:  MOVFF  03,6A5
02D2C:  MOVFF  02,6A4
02D30:  MOVFF  01,6A3
02D34:  MOVFF  00,6A2
02D38:  BCF    FD8.1
02D3A:  MOVFF  03,6B6
02D3E:  MOVFF  02,6B5
02D42:  MOVFF  01,6B4
02D46:  MOVFF  00,6B3
02D4A:  MOVLW  A4
02D4C:  MOVLB  6
02D4E:  MOVWF  xBA
02D50:  MOVLW  DB
02D52:  MOVWF  xB9
02D54:  MOVLW  67
02D56:  MOVWF  xB8
02D58:  MOVLW  83
02D5A:  MOVWF  xB7
02D5C:  MOVLB  0
02D5E:  CALL   1400
02D62:  MOVFF  03,6A0
02D66:  MOVFF  02,69F
02D6A:  MOVFF  01,69E
02D6E:  MOVFF  00,69D
....................    r = r*y*y + qat[3];
02D72:  MOVFF  6A0,6B7
02D76:  MOVFF  69F,6B6
02D7A:  MOVFF  69E,6B5
02D7E:  MOVFF  69D,6B4
02D82:  MOVFF  698,6BB
02D86:  MOVFF  697,6BA
02D8A:  MOVFF  696,6B9
02D8E:  MOVFF  695,6B8
02D92:  CALL   130A
02D96:  MOVFF  03,6A5
02D9A:  MOVFF  02,6A4
02D9E:  MOVFF  01,6A3
02DA2:  MOVFF  00,6A2
02DA6:  MOVFF  03,6B7
02DAA:  MOVFF  02,6B6
02DAE:  MOVFF  01,6B5
02DB2:  MOVFF  00,6B4
02DB6:  MOVFF  698,6BB
02DBA:  MOVFF  697,6BA
02DBE:  MOVFF  696,6B9
02DC2:  MOVFF  695,6B8
02DC6:  CALL   130A
02DCA:  MOVFF  03,6A5
02DCE:  MOVFF  02,6A4
02DD2:  MOVFF  01,6A3
02DD6:  MOVFF  00,6A2
02DDA:  BCF    FD8.1
02DDC:  MOVFF  03,6B6
02DE0:  MOVFF  02,6B5
02DE4:  MOVFF  01,6B4
02DE8:  MOVFF  00,6B3
02DEC:  MOVLW  33
02DEE:  MOVLB  6
02DF0:  MOVWF  xBA
02DF2:  MOVLW  8C
02DF4:  MOVWF  xB9
02DF6:  MOVLW  1E
02DF8:  MOVWF  xB8
02DFA:  MOVLW  83
02DFC:  MOVWF  xB7
02DFE:  MOVLB  0
02E00:  CALL   1400
02E04:  MOVFF  03,6A0
02E08:  MOVFF  02,69F
02E0C:  MOVFF  01,69E
02E10:  MOVFF  00,69D
.................... 
....................    res = y*res/r;
02E14:  MOVFF  698,6B7
02E18:  MOVFF  697,6B6
02E1C:  MOVFF  696,6B5
02E20:  MOVFF  695,6B4
02E24:  MOVFF  69C,6BB
02E28:  MOVFF  69B,6BA
02E2C:  MOVFF  69A,6B9
02E30:  MOVFF  699,6B8
02E34:  CALL   130A
02E38:  MOVFF  03,6A5
02E3C:  MOVFF  02,6A4
02E40:  MOVFF  01,6A3
02E44:  MOVFF  00,6A2
02E48:  MOVFF  03,6AB
02E4C:  MOVFF  02,6AA
02E50:  MOVFF  01,6A9
02E54:  MOVFF  00,6A8
02E58:  MOVFF  6A0,6AF
02E5C:  MOVFF  69F,6AE
02E60:  MOVFF  69E,6AD
02E64:  MOVFF  69D,6AC
02E68:  RCALL  2850
02E6A:  MOVFF  03,69C
02E6E:  MOVFF  02,69B
02E72:  MOVFF  01,69A
02E76:  MOVFF  00,699
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02E7A:  MOVLB  6
02E7C:  BTFSS  xA1.1
02E7E:  BRA    2EBA
....................       res = PI_DIV_BY_TWO - res;
02E80:  BSF    FD8.1
02E82:  MOVLW  DB
02E84:  MOVWF  xB6
02E86:  MOVLW  0F
02E88:  MOVWF  xB5
02E8A:  MOVLW  49
02E8C:  MOVWF  xB4
02E8E:  MOVLW  7F
02E90:  MOVWF  xB3
02E92:  MOVFF  69C,6BA
02E96:  MOVFF  69B,6B9
02E9A:  MOVFF  69A,6B8
02E9E:  MOVFF  699,6B7
02EA2:  MOVLB  0
02EA4:  CALL   1400
02EA8:  MOVFF  03,69C
02EAC:  MOVFF  02,69B
02EB0:  MOVFF  01,69A
02EB4:  MOVFF  00,699
02EB8:  MOVLB  6
....................    if (s)
02EBA:  BTFSS  xA1.0
02EBC:  BRA    2EC4
....................       res = -res;
02EBE:  MOVF   x9A,W
02EC0:  XORLW  80
02EC2:  MOVWF  x9A
.................... 
....................    return(res);
02EC4:  MOVFF  699,00
02EC8:  MOVFF  69A,01
02ECC:  MOVFF  69B,02
02ED0:  MOVFF  69C,03
02ED4:  MOVLB  0
02ED6:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02ED8:  MOVLB  6
02EDA:  BCF    x8F.0
....................    quad=0; //quadrant
02EDC:  CLRF   x90
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02EDE:  MOVFF  686,6B2
02EE2:  MOVFF  685,6B1
02EE6:  MOVFF  684,6B0
02EEA:  MOVFF  683,6AF
02EEE:  CLRF   xB6
02EF0:  CLRF   xB5
02EF2:  CLRF   xB4
02EF4:  CLRF   xB3
02EF6:  MOVLB  0
02EF8:  RCALL  27D6
02EFA:  BC    2EFE
02EFC:  BNZ   2F28
02EFE:  MOVFF  68A,6B2
02F02:  MOVFF  689,6B1
02F06:  MOVFF  688,6B0
02F0A:  MOVFF  687,6AF
02F0E:  MOVLB  6
02F10:  CLRF   xB6
02F12:  CLRF   xB5
02F14:  CLRF   xB4
02F16:  CLRF   xB3
02F18:  MOVLB  0
02F1A:  RCALL  27D6
02F1C:  BC    2F20
02F1E:  BNZ   2F24
02F20:  MOVLW  03
02F22:  BRA    2F26
02F24:  MOVLW  04
02F26:  BRA    2F4E
02F28:  MOVFF  68A,6B2
02F2C:  MOVFF  689,6B1
02F30:  MOVFF  688,6B0
02F34:  MOVFF  687,6AF
02F38:  MOVLB  6
02F3A:  CLRF   xB6
02F3C:  CLRF   xB5
02F3E:  CLRF   xB4
02F40:  CLRF   xB3
02F42:  MOVLB  0
02F44:  RCALL  27D6
02F46:  BNC   2F4C
02F48:  MOVLW  02
02F4A:  BRA    2F4E
02F4C:  MOVLW  01
02F4E:  MOVLB  6
02F50:  MOVWF  x90
....................    if(y<0.0)
02F52:  MOVFF  686,6B2
02F56:  MOVFF  685,6B1
02F5A:  MOVFF  684,6B0
02F5E:  MOVFF  683,6AF
02F62:  CLRF   xB6
02F64:  CLRF   xB5
02F66:  CLRF   xB4
02F68:  CLRF   xB3
02F6A:  MOVLB  0
02F6C:  RCALL  27D6
02F6E:  BNC   2F7C
....................    {
....................       sign=1;
02F70:  MOVLB  6
02F72:  BSF    x8F.0
....................       y=-y;
02F74:  MOVF   x84,W
02F76:  XORLW  80
02F78:  MOVWF  x84
02F7A:  MOVLB  0
....................    }
....................    if(x<0.0)
02F7C:  MOVFF  68A,6B2
02F80:  MOVFF  689,6B1
02F84:  MOVFF  688,6B0
02F88:  MOVFF  687,6AF
02F8C:  MOVLB  6
02F8E:  CLRF   xB6
02F90:  CLRF   xB5
02F92:  CLRF   xB4
02F94:  CLRF   xB3
02F96:  MOVLB  0
02F98:  RCALL  27D6
02F9A:  BNC   2FA6
....................    {
....................       x=-x;
02F9C:  MOVLB  6
02F9E:  MOVF   x88,W
02FA0:  XORLW  80
02FA2:  MOVWF  x88
02FA4:  MOVLB  0
....................    }
....................    if (x==0.0)
02FA6:  MOVFF  68A,6B2
02FAA:  MOVFF  689,6B1
02FAE:  MOVFF  688,6B0
02FB2:  MOVFF  687,6AF
02FB6:  MOVLB  6
02FB8:  CLRF   xB6
02FBA:  CLRF   xB5
02FBC:  CLRF   xB4
02FBE:  CLRF   xB3
02FC0:  MOVLB  0
02FC2:  RCALL  27D6
02FC4:  BNZ   301A
....................    {
....................       if(y==0.0)
02FC6:  MOVFF  686,6B2
02FCA:  MOVFF  685,6B1
02FCE:  MOVFF  684,6B0
02FD2:  MOVFF  683,6AF
02FD6:  MOVLB  6
02FD8:  CLRF   xB6
02FDA:  CLRF   xB5
02FDC:  CLRF   xB4
02FDE:  CLRF   xB3
02FE0:  MOVLB  0
02FE2:  CALL   27D6
02FE6:  BNZ   2FEA
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02FE8:  BRA    3018
....................       else
....................       {
....................          if(sign)
02FEA:  MOVLB  6
02FEC:  BTFSS  x8F.0
02FEE:  BRA    3004
....................          {
....................          return (-(PI_DIV_BY_TWO));
02FF0:  MOVLW  7F
02FF2:  MOVWF  00
02FF4:  MOVLW  C9
02FF6:  MOVWF  01
02FF8:  MOVLW  0F
02FFA:  MOVWF  02
02FFC:  MOVLW  DB
02FFE:  MOVWF  03
03000:  BRA    3152
....................          }
03002:  BRA    3016
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
03004:  MOVLW  7F
03006:  MOVWF  00
03008:  MOVLW  49
0300A:  MOVWF  01
0300C:  MOVLW  0F
0300E:  MOVWF  02
03010:  MOVLW  DB
03012:  MOVWF  03
03014:  BRA    3152
03016:  MOVLB  0
....................          }
....................       }
....................    }
03018:  BRA    3150
....................    else
....................    {
....................       z=y/x;
0301A:  MOVFF  686,6AB
0301E:  MOVFF  685,6AA
03022:  MOVFF  684,6A9
03026:  MOVFF  683,6A8
0302A:  MOVFF  68A,6AF
0302E:  MOVFF  689,6AE
03032:  MOVFF  688,6AD
03036:  MOVFF  687,6AC
0303A:  RCALL  2850
0303C:  MOVFF  03,68E
03040:  MOVFF  02,68D
03044:  MOVFF  01,68C
03048:  MOVFF  00,68B
....................       switch(quad)
0304C:  MOVLW  01
0304E:  MOVLB  6
03050:  SUBWF  x90,W
03052:  ADDLW  FC
03054:  BTFSC  FD8.0
03056:  BRA    3152
03058:  ADDLW  04
0305A:  MOVLB  0
0305C:  GOTO   3158
....................       {
....................          case 1:
....................          {
....................             return atan(z);
03060:  MOVFF  68E,694
03064:  MOVFF  68D,693
03068:  MOVFF  68C,692
0306C:  MOVFF  68B,691
03070:  RCALL  29AE
03072:  MOVLB  6
03074:  BRA    3152
....................             break;
03076:  BRA    3152
03078:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
0307A:  MOVFF  68E,694
0307E:  MOVFF  68D,693
03082:  MOVFF  68C,692
03086:  MOVFF  68B,691
0308A:  RCALL  29AE
0308C:  MOVFF  FEA,692
03090:  MOVFF  FE9,691
03094:  BSF    FD8.1
03096:  MOVLW  DB
03098:  MOVLB  6
0309A:  MOVWF  xB6
0309C:  MOVLW  0F
0309E:  MOVWF  xB5
030A0:  MOVLW  49
030A2:  MOVWF  xB4
030A4:  MOVLW  80
030A6:  MOVWF  xB3
030A8:  MOVFF  03,6BA
030AC:  MOVFF  02,6B9
030B0:  MOVFF  01,6B8
030B4:  MOVFF  00,6B7
030B8:  MOVLB  0
030BA:  CALL   1400
030BE:  MOVFF  692,FEA
030C2:  MOVFF  691,FE9
030C6:  MOVLB  6
030C8:  BRA    3152
....................             break;
030CA:  BRA    3152
030CC:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
030CE:  MOVFF  68E,694
030D2:  MOVFF  68D,693
030D6:  MOVFF  68C,692
030DA:  MOVFF  68B,691
030DE:  RCALL  29AE
030E0:  MOVFF  03,694
030E4:  MOVFF  02,693
030E8:  MOVFF  01,692
030EC:  MOVFF  00,691
030F0:  MOVFF  FEA,696
030F4:  MOVFF  FE9,695
030F8:  BSF    FD8.1
030FA:  MOVFF  03,6B6
030FE:  MOVFF  02,6B5
03102:  MOVFF  01,6B4
03106:  MOVFF  00,6B3
0310A:  MOVLW  DB
0310C:  MOVLB  6
0310E:  MOVWF  xBA
03110:  MOVLW  0F
03112:  MOVWF  xB9
03114:  MOVLW  49
03116:  MOVWF  xB8
03118:  MOVLW  80
0311A:  MOVWF  xB7
0311C:  MOVLB  0
0311E:  CALL   1400
03122:  MOVFF  696,FEA
03126:  MOVFF  695,FE9
0312A:  MOVLB  6
0312C:  BRA    3152
....................             break;
0312E:  BRA    3152
03130:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
03132:  MOVFF  68E,694
03136:  MOVFF  68D,693
0313A:  MOVFF  68C,692
0313E:  MOVFF  68B,691
03142:  RCALL  29AE
03144:  MOVLW  80
03146:  XORWF  01,F
03148:  MOVLB  6
0314A:  BRA    3152
....................             break;
0314C:  BRA    3152
0314E:  MOVLB  0
03150:  MOVLB  6
....................          }
....................       }
....................    }
03152:  MOVLB  0
03154:  GOTO   485E (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... typedef struct {
....................    int8 in;
....................    int8 out;
....................    signed int32 buff[BUFFER_SIZE];
.................... } buffer;
.................... 
.................... buffer sinQ_x;
.................... buffer cosQ_x;
.................... buffer sinQ_y;
.................... buffer cosQ_y;
.................... 
.................... #define incin(buff) ((buff->in==(BUFFER_SIZE-1))?0:buff->in+1)
.................... #define incout(buff) ((buff->out==(BUFFER_SIZE-1))?0:buff->out+1)
.................... #define isempty(buff) (buff->in==buff->out)
.................... #define hasdata(buff) (buff->in!=buff->out)
.................... #define isfull(buff) (incin(buff)==buff->out)
.................... 
.................... #define tobuff(bname,c) { bname->buff[bname->in]=c;\
....................    bname->in=incin(bname);\
....................    if (bname->in==bname->out) bname->out=incout(bname);\
....................    }
.................... #define frombuff(bname) (btemp##bname=bname->buff[bname->out],\
....................    bname->out=incout(bname), \
....................    btemp##bname)
.................... #define clrbuff(buff) buff->in=buff->out=0
.................... 
.................... #define COMPARE(a,b) (((a) > (b)) - ((a) < (b)))
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    buffer* sinQ;
....................    buffer* cosQ;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, &sinQ_x, &cosQ_x, 0, 0},
....................    {false, false, &sinQ_y, &cosQ_y, 0, 0}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
01678:  MOVLB  F
0167A:  BTFSC  x5B.0
0167C:  BRA    1BC8
....................    {
....................       switch (state)
0167E:  MOVLB  1
01680:  MOVF   xD7,W
01682:  ADDLW  F9
01684:  BTFSC  FD8.0
01686:  BRA    1BC6
01688:  ADDLW  07
0168A:  MOVLB  0
0168C:  GOTO   1BCE
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
01690:  MOVLB  F
01692:  BTFSC  x5B.0
01694:  BRA    1692
01696:  MOVFF  F5F,02
0169A:  MOVFF  F5E,01
0169E:  MOVFF  02,665
016A2:  MOVFF  01,664
016A6:  MOVFF  02,6B4
016AA:  MOVFF  01,6B3
016AE:  MOVLB  0
016B0:  RCALL  12D4
016B2:  MOVFF  03,6B7
016B6:  MOVFF  02,6B6
016BA:  MOVFF  01,6B5
016BE:  MOVFF  00,6B4
016C2:  MOVFF  B9,6BB
016C6:  MOVFF  B8,6BA
016CA:  MOVFF  B7,6B9
016CE:  MOVFF  B6,6B8
016D2:  RCALL  130A
016D4:  MOVFF  03,667
016D8:  MOVFF  02,666
016DC:  MOVFF  01,665
016E0:  MOVFF  00,664
016E4:  BCF    FD8.1
016E6:  MOVFF  03,6B6
016EA:  MOVFF  02,6B5
016EE:  MOVFF  01,6B4
016F2:  MOVFF  00,6B3
016F6:  MOVFF  B5,6BA
016FA:  MOVFF  B4,6B9
016FE:  MOVFF  B3,6B8
01702:  MOVFF  B2,6B7
01706:  RCALL  1400
01708:  MOVFF  03,F6
0170C:  MOVFF  02,F5
01710:  MOVFF  01,F4
01714:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
01718:  MOVLB  F
0171A:  MOVF   x5A,W
0171C:  ANDLW  3F
0171E:  MOVWF  01
01720:  MOVLW  10
01722:  MOVWF  x5A
01724:  BTFSS  x5B.7
01726:  BRA    1736
01728:  MOVF   01,W
0172A:  SUBLW  10
0172C:  BZ    1736
0172E:  BSF    x5B.0
01730:  NOP   
01732:  BTFSC  x5B.0
01734:  BRA    1732
....................             delay_ms(10);
01736:  MOVLW  0A
01738:  MOVLB  6
0173A:  MOVWF  x6C
0173C:  MOVLB  0
0173E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01742:  MOVLB  F
01744:  BSF    x5B.0
01746:  NOP   
....................             state = 1;
01748:  MOVLW  01
0174A:  MOVLB  1
0174C:  MOVWF  xD7
....................          break;
0174E:  BRA    1BC6
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01750:  MOVLB  F
01752:  BTFSC  x5B.0
01754:  BRA    1752
01756:  MOVFF  F5F,02
0175A:  MOVFF  F5E,01
0175E:  MOVFF  02,665
01762:  MOVFF  01,664
01766:  MOVFF  02,6B4
0176A:  MOVFF  01,6B3
0176E:  MOVLB  0
01770:  RCALL  12D4
01772:  MOVFF  03,6B7
01776:  MOVFF  02,6B6
0177A:  MOVFF  01,6B5
0177E:  MOVFF  00,6B4
01782:  MOVFF  C1,6BB
01786:  MOVFF  C0,6BA
0178A:  MOVFF  BF,6B9
0178E:  MOVFF  BE,6B8
01792:  RCALL  130A
01794:  MOVFF  03,667
01798:  MOVFF  02,666
0179C:  MOVFF  01,665
017A0:  MOVFF  00,664
017A4:  BCF    FD8.1
017A6:  MOVFF  03,6B6
017AA:  MOVFF  02,6B5
017AE:  MOVFF  01,6B4
017B2:  MOVFF  00,6B3
017B6:  MOVFF  BD,6BA
017BA:  MOVFF  BC,6B9
017BE:  MOVFF  BB,6B8
017C2:  MOVFF  BA,6B7
017C6:  RCALL  1400
017C8:  MOVFF  03,FA
017CC:  MOVFF  02,F9
017D0:  MOVFF  01,F8
017D4:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
017D8:  MOVLB  F
017DA:  MOVF   x5A,W
017DC:  ANDLW  3F
017DE:  MOVWF  01
017E0:  MOVLW  18
017E2:  MOVWF  x5A
017E4:  BTFSS  x5B.7
017E6:  BRA    17F6
017E8:  MOVF   01,W
017EA:  SUBLW  18
017EC:  BZ    17F6
017EE:  BSF    x5B.0
017F0:  NOP   
017F2:  BTFSC  x5B.0
017F4:  BRA    17F2
....................             delay_ms(10);
017F6:  MOVLW  0A
017F8:  MOVLB  6
017FA:  MOVWF  x6C
017FC:  MOVLB  0
017FE:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01802:  MOVLB  F
01804:  BSF    x5B.0
01806:  NOP   
....................             state = 2;
01808:  MOVLW  02
0180A:  MOVLB  1
0180C:  MOVWF  xD7
....................          break;
0180E:  BRA    1BC6
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01810:  MOVLB  F
01812:  BTFSC  x5B.0
01814:  BRA    1812
01816:  MOVFF  F5F,02
0181A:  MOVFF  F5E,01
0181E:  MOVFF  02,665
01822:  MOVFF  01,664
01826:  MOVFF  02,6B4
0182A:  MOVFF  01,6B3
0182E:  MOVLB  0
01830:  RCALL  12D4
01832:  MOVFF  03,6B7
01836:  MOVFF  02,6B6
0183A:  MOVFF  01,6B5
0183E:  MOVFF  00,6B4
01842:  MOVFF  C9,6BB
01846:  MOVFF  C8,6BA
0184A:  MOVFF  C7,6B9
0184E:  MOVFF  C6,6B8
01852:  RCALL  130A
01854:  MOVFF  03,667
01858:  MOVFF  02,666
0185C:  MOVFF  01,665
01860:  MOVFF  00,664
01864:  BCF    FD8.1
01866:  MOVFF  03,6B6
0186A:  MOVFF  02,6B5
0186E:  MOVFF  01,6B4
01872:  MOVFF  00,6B3
01876:  MOVFF  C5,6BA
0187A:  MOVFF  C4,6B9
0187E:  MOVFF  C3,6B8
01882:  MOVFF  C2,6B7
01886:  RCALL  1400
01888:  MOVFF  03,FE
0188C:  MOVFF  02,FD
01890:  MOVFF  01,FC
01894:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
01898:  MOVLB  F
0189A:  MOVF   x5A,W
0189C:  ANDLW  3F
0189E:  MOVWF  01
018A0:  MOVLW  19
018A2:  MOVWF  x5A
018A4:  BTFSS  x5B.7
018A6:  BRA    18B6
018A8:  MOVF   01,W
018AA:  SUBLW  19
018AC:  BZ    18B6
018AE:  BSF    x5B.0
018B0:  NOP   
018B2:  BTFSC  x5B.0
018B4:  BRA    18B2
....................             delay_ms(10);
018B6:  MOVLW  0A
018B8:  MOVLB  6
018BA:  MOVWF  x6C
018BC:  MOVLB  0
018BE:  CALL   0438
....................             read_adc(ADC_START_ONLY);
018C2:  MOVLB  F
018C4:  BSF    x5B.0
018C6:  NOP   
....................             state = 3;
018C8:  MOVLW  03
018CA:  MOVLB  1
018CC:  MOVWF  xD7
....................          break;
018CE:  BRA    1BC6
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
018D0:  MOVLB  F
018D2:  BTFSC  x5B.0
018D4:  BRA    18D2
018D6:  MOVFF  F5F,02
018DA:  MOVFF  F5E,01
018DE:  MOVFF  02,665
018E2:  MOVFF  01,664
018E6:  MOVFF  02,6B4
018EA:  MOVFF  01,6B3
018EE:  MOVLB  0
018F0:  RCALL  12D4
018F2:  MOVFF  03,6B7
018F6:  MOVFF  02,6B6
018FA:  MOVFF  01,6B5
018FE:  MOVFF  00,6B4
01902:  MOVFF  D1,6BB
01906:  MOVFF  D0,6BA
0190A:  MOVFF  CF,6B9
0190E:  MOVFF  CE,6B8
01912:  RCALL  130A
01914:  MOVFF  03,667
01918:  MOVFF  02,666
0191C:  MOVFF  01,665
01920:  MOVFF  00,664
01924:  BCF    FD8.1
01926:  MOVFF  03,6B6
0192A:  MOVFF  02,6B5
0192E:  MOVFF  01,6B4
01932:  MOVFF  00,6B3
01936:  MOVFF  CD,6BA
0193A:  MOVFF  CC,6B9
0193E:  MOVFF  CB,6B8
01942:  MOVFF  CA,6B7
01946:  RCALL  1400
01948:  MOVFF  03,102
0194C:  MOVFF  02,101
01950:  MOVFF  01,100
01954:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01958:  MOVLB  F
0195A:  MOVF   x5A,W
0195C:  ANDLW  3F
0195E:  MOVWF  01
01960:  MOVLW  11
01962:  MOVWF  x5A
01964:  BTFSS  x5B.7
01966:  BRA    1976
01968:  MOVF   01,W
0196A:  SUBLW  11
0196C:  BZ    1976
0196E:  BSF    x5B.0
01970:  NOP   
01972:  BTFSC  x5B.0
01974:  BRA    1972
....................             delay_ms(10);
01976:  MOVLW  0A
01978:  MOVLB  6
0197A:  MOVWF  x6C
0197C:  MOVLB  0
0197E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01982:  MOVLB  F
01984:  BSF    x5B.0
01986:  NOP   
....................             state = 4;
01988:  MOVLW  04
0198A:  MOVLB  1
0198C:  MOVWF  xD7
....................          break;
0198E:  BRA    1BC6
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01990:  MOVLB  F
01992:  BTFSC  x5B.0
01994:  BRA    1992
01996:  MOVFF  F5F,02
0199A:  MOVFF  F5E,01
0199E:  MOVFF  02,665
019A2:  MOVFF  01,664
019A6:  MOVFF  02,6B4
019AA:  MOVFF  01,6B3
019AE:  MOVLB  0
019B0:  RCALL  12D4
019B2:  MOVFF  03,6B7
019B6:  MOVFF  02,6B6
019BA:  MOVFF  01,6B5
019BE:  MOVFF  00,6B4
019C2:  MOVFF  D9,6BB
019C6:  MOVFF  D8,6BA
019CA:  MOVFF  D7,6B9
019CE:  MOVFF  D6,6B8
019D2:  RCALL  130A
019D4:  MOVFF  03,667
019D8:  MOVFF  02,666
019DC:  MOVFF  01,665
019E0:  MOVFF  00,664
019E4:  BCF    FD8.1
019E6:  MOVFF  03,6B6
019EA:  MOVFF  02,6B5
019EE:  MOVFF  01,6B4
019F2:  MOVFF  00,6B3
019F6:  MOVFF  D5,6BA
019FA:  MOVFF  D4,6B9
019FE:  MOVFF  D3,6B8
01A02:  MOVFF  D2,6B7
01A06:  RCALL  1400
01A08:  MOVFF  03,106
01A0C:  MOVFF  02,105
01A10:  MOVFF  01,104
01A14:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01A18:  MOVLB  F
01A1A:  MOVF   x5A,W
01A1C:  ANDLW  3F
01A1E:  MOVWF  01
01A20:  MOVLW  1B
01A22:  MOVWF  x5A
01A24:  BTFSS  x5B.7
01A26:  BRA    1A36
01A28:  MOVF   01,W
01A2A:  SUBLW  1B
01A2C:  BZ    1A36
01A2E:  BSF    x5B.0
01A30:  NOP   
01A32:  BTFSC  x5B.0
01A34:  BRA    1A32
....................             delay_ms(10);
01A36:  MOVLW  0A
01A38:  MOVLB  6
01A3A:  MOVWF  x6C
01A3C:  MOVLB  0
01A3E:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01A42:  MOVLB  F
01A44:  BSF    x5B.0
01A46:  NOP   
....................             state = 5;
01A48:  MOVLW  05
01A4A:  MOVLB  1
01A4C:  MOVWF  xD7
....................          break;
01A4E:  BRA    1BC6
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01A50:  MOVLB  F
01A52:  BTFSC  x5B.0
01A54:  BRA    1A52
01A56:  MOVFF  F5F,02
01A5A:  MOVFF  F5E,01
01A5E:  MOVFF  02,665
01A62:  MOVFF  01,664
01A66:  MOVFF  02,6B4
01A6A:  MOVFF  01,6B3
01A6E:  MOVLB  0
01A70:  RCALL  12D4
01A72:  MOVFF  03,6B7
01A76:  MOVFF  02,6B6
01A7A:  MOVFF  01,6B5
01A7E:  MOVFF  00,6B4
01A82:  MOVFF  E1,6BB
01A86:  MOVFF  E0,6BA
01A8A:  MOVFF  DF,6B9
01A8E:  MOVFF  DE,6B8
01A92:  RCALL  130A
01A94:  MOVFF  03,667
01A98:  MOVFF  02,666
01A9C:  MOVFF  01,665
01AA0:  MOVFF  00,664
01AA4:  BCF    FD8.1
01AA6:  MOVFF  03,6B6
01AAA:  MOVFF  02,6B5
01AAE:  MOVFF  01,6B4
01AB2:  MOVFF  00,6B3
01AB6:  MOVFF  DD,6BA
01ABA:  MOVFF  DC,6B9
01ABE:  MOVFF  DB,6B8
01AC2:  MOVFF  DA,6B7
01AC6:  RCALL  1400
01AC8:  MOVFF  03,10A
01ACC:  MOVFF  02,109
01AD0:  MOVFF  01,108
01AD4:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01AD8:  MOVLB  F
01ADA:  MOVF   x5A,W
01ADC:  ANDLW  3F
01ADE:  MOVWF  01
01AE0:  MOVLW  1A
01AE2:  MOVWF  x5A
01AE4:  BTFSS  x5B.7
01AE6:  BRA    1AF6
01AE8:  MOVF   01,W
01AEA:  SUBLW  1A
01AEC:  BZ    1AF6
01AEE:  BSF    x5B.0
01AF0:  NOP   
01AF2:  BTFSC  x5B.0
01AF4:  BRA    1AF2
....................             delay_ms(10);
01AF6:  MOVLW  0A
01AF8:  MOVLB  6
01AFA:  MOVWF  x6C
01AFC:  MOVLB  0
01AFE:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01B02:  MOVLB  F
01B04:  BSF    x5B.0
01B06:  NOP   
....................             state = 6;
01B08:  MOVLW  06
01B0A:  MOVLB  1
01B0C:  MOVWF  xD7
....................          break;
01B0E:  BRA    1BC6
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01B10:  MOVLB  F
01B12:  BTFSC  x5B.0
01B14:  BRA    1B12
01B16:  MOVFF  F5F,02
01B1A:  MOVFF  F5E,01
01B1E:  MOVFF  02,665
01B22:  MOVFF  01,664
01B26:  MOVFF  02,6B4
01B2A:  MOVFF  01,6B3
01B2E:  MOVLB  0
01B30:  CALL   12D4
01B34:  MOVFF  03,6B7
01B38:  MOVFF  02,6B6
01B3C:  MOVFF  01,6B5
01B40:  MOVFF  00,6B4
01B44:  MOVFF  E9,6BB
01B48:  MOVFF  E8,6BA
01B4C:  MOVFF  E7,6B9
01B50:  MOVFF  E6,6B8
01B54:  CALL   130A
01B58:  MOVFF  03,667
01B5C:  MOVFF  02,666
01B60:  MOVFF  01,665
01B64:  MOVFF  00,664
01B68:  BCF    FD8.1
01B6A:  MOVFF  03,6B6
01B6E:  MOVFF  02,6B5
01B72:  MOVFF  01,6B4
01B76:  MOVFF  00,6B3
01B7A:  MOVFF  E5,6BA
01B7E:  MOVFF  E4,6B9
01B82:  MOVFF  E3,6B8
01B86:  MOVFF  E2,6B7
01B8A:  RCALL  1400
01B8C:  MOVFF  03,10E
01B90:  MOVFF  02,10D
01B94:  MOVFF  01,10C
01B98:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
01B9C:  MOVLB  F
01B9E:  MOVF   x5A,W
01BA0:  ANDLW  3F
01BA2:  MOVWF  01
01BA4:  MOVLW  06
01BA6:  MOVWF  x5A
01BA8:  BTFSS  x5B.7
01BAA:  BRA    1BBA
01BAC:  MOVF   01,W
01BAE:  SUBLW  06
01BB0:  BZ    1BBA
01BB2:  BSF    x5B.0
01BB4:  NOP   
01BB6:  BTFSC  x5B.0
01BB8:  BRA    1BB6
....................             read_adc(ADC_START_ONLY);
01BBA:  BSF    x5B.0
01BBC:  NOP   
....................             state = 0;
01BBE:  MOVLB  1
01BC0:  CLRF   xD7
....................          break;   
01BC2:  BRA    1BC6
01BC4:  MOVLB  1
01BC6:  MOVLB  F
....................       }
....................    }
01BC8:  MOVLB  0
01BCA:  GOTO   B07E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch)//, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
041B6:  MOVLB  6
041B8:  MOVF   x6C,W
041BA:  MULLW  21
041BC:  MOVF   FF3,W
041BE:  CLRF   x76
041C0:  MOVWF  x75
041C2:  MOVLW  10
041C4:  ADDWF  x75,W
041C6:  MOVWF  01
041C8:  MOVLW  00
041CA:  ADDWFC x76,W
041CC:  MOVWF  03
041CE:  MOVF   01,W
041D0:  ADDLW  0F
041D2:  MOVWF  01
041D4:  MOVLW  01
041D6:  ADDWFC 03,F
041D8:  MOVFF  01,675
041DC:  MOVFF  03,676
041E0:  MOVF   x6C,W
041E2:  MULLW  21
041E4:  MOVF   FF3,W
041E6:  CLRF   x78
041E8:  MOVWF  x77
041EA:  MOVLW  08
041EC:  ADDWF  x77,W
041EE:  MOVWF  01
041F0:  MOVLW  00
041F2:  ADDWFC x78,W
041F4:  MOVWF  03
041F6:  MOVF   01,W
041F8:  ADDLW  0F
041FA:  MOVWF  FE9
041FC:  MOVLW  01
041FE:  ADDWFC 03,W
04200:  MOVWF  FEA
04202:  MOVFF  FEF,00
04206:  MOVFF  FEC,01
0420A:  MOVFF  FEC,02
0420E:  MOVFF  FEC,03
04212:  MOVFF  676,FEA
04216:  MOVFF  675,FE9
0421A:  MOVFF  00,FEF
0421E:  MOVFF  01,FEC
04222:  MOVFF  02,FEC
04226:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
0422A:  MOVF   x6C,W
0422C:  MULLW  21
0422E:  MOVF   FF3,W
04230:  CLRF   x76
04232:  MOVWF  x75
04234:  MOVLW  14
04236:  ADDWF  x75,W
04238:  MOVWF  01
0423A:  MOVLW  00
0423C:  ADDWFC x76,W
0423E:  MOVWF  03
04240:  MOVF   01,W
04242:  ADDLW  0F
04244:  MOVWF  01
04246:  MOVLW  01
04248:  ADDWFC 03,F
0424A:  MOVFF  01,675
0424E:  MOVFF  03,676
04252:  MOVF   x6C,W
04254:  MULLW  21
04256:  MOVF   FF3,W
04258:  CLRF   x78
0425A:  MOVWF  x77
0425C:  MOVLW  0C
0425E:  ADDWF  x77,W
04260:  MOVWF  01
04262:  MOVLW  00
04264:  ADDWFC x78,W
04266:  MOVWF  03
04268:  MOVF   01,W
0426A:  ADDLW  0F
0426C:  MOVWF  FE9
0426E:  MOVLW  01
04270:  ADDWFC 03,W
04272:  MOVWF  FEA
04274:  MOVFF  FEF,00
04278:  MOVFF  FEC,01
0427C:  MOVFF  FEC,02
04280:  MOVFF  FEC,03
04284:  MOVFF  676,FEA
04288:  MOVFF  675,FE9
0428C:  MOVFF  00,FEF
04290:  MOVFF  01,FEC
04294:  MOVFF  02,FEC
04298:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
0429C:  MOVF   x6C,W
0429E:  MULLW  21
042A0:  MOVF   FF3,W
042A2:  CLRF   x76
042A4:  MOVWF  x75
042A6:  MOVLW  0F
042A8:  ADDWF  x75,W
042AA:  MOVWF  01
042AC:  MOVLW  01
042AE:  ADDWFC x76,W
042B0:  MOVWF  03
042B2:  MOVFF  01,677
042B6:  MOVWF  x78
042B8:  MOVF   x6C,W
042BA:  MULLW  0D
042BC:  MOVF   FF3,W
042BE:  CLRF   x7A
042C0:  MOVWF  x79
042C2:  MOVLW  05
042C4:  ADDWF  x79,W
042C6:  MOVWF  01
042C8:  MOVLW  00
042CA:  ADDWFC x7A,W
042CC:  MOVWF  03
042CE:  MOVF   01,W
042D0:  ADDLW  BD
042D2:  MOVWF  FE9
042D4:  MOVLW  01
042D6:  ADDWFC 03,W
042D8:  MOVWF  FEA
042DA:  MOVFF  FEF,679
042DE:  MOVFF  FEC,01
042E2:  MOVFF  FEC,02
042E6:  MOVFF  FEC,03
042EA:  MOVFF  03,67C
042EE:  MOVFF  02,67B
042F2:  MOVFF  01,67A
042F6:  MOVLB  0
042F8:  CALL   277C
042FC:  MOVFF  678,FEA
04300:  MOVFF  677,FE9
04304:  MOVFF  00,FEF
04308:  MOVFF  01,FEC
0430C:  MOVFF  02,FEC
04310:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
04314:  MOVLB  6
04316:  MOVF   x6C,W
04318:  MULLW  21
0431A:  MOVF   FF3,W
0431C:  CLRF   x76
0431E:  MOVWF  x75
04320:  MOVLW  04
04322:  ADDWF  x75,W
04324:  MOVWF  01
04326:  MOVLW  00
04328:  ADDWFC x76,W
0432A:  MOVWF  03
0432C:  MOVF   01,W
0432E:  ADDLW  0F
04330:  MOVWF  01
04332:  MOVLW  01
04334:  ADDWFC 03,F
04336:  MOVFF  01,675
0433A:  MOVFF  03,676
0433E:  MOVF   x6C,W
04340:  MULLW  0D
04342:  MOVF   FF3,W
04344:  CLRF   x78
04346:  MOVWF  x77
04348:  MOVLW  09
0434A:  ADDWF  x77,W
0434C:  MOVWF  01
0434E:  MOVLW  00
04350:  ADDWFC x78,W
04352:  MOVWF  03
04354:  MOVF   01,W
04356:  ADDLW  BD
04358:  MOVWF  FE9
0435A:  MOVLW  01
0435C:  ADDWFC 03,W
0435E:  MOVWF  FEA
04360:  MOVFF  FEF,679
04364:  MOVFF  FEC,01
04368:  MOVFF  FEC,02
0436C:  MOVFF  FEC,03
04370:  MOVFF  03,67C
04374:  MOVFF  02,67B
04378:  MOVFF  01,67A
0437C:  MOVLB  0
0437E:  CALL   277C
04382:  MOVFF  676,FEA
04386:  MOVFF  675,FE9
0438A:  MOVFF  00,FEF
0438E:  MOVFF  01,FEC
04392:  MOVFF  02,FEC
04396:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
0439A:  MOVLB  6
0439C:  MOVF   x6C,W
0439E:  MULLW  21
043A0:  MOVF   FF3,W
043A2:  CLRF   x76
043A4:  MOVWF  x75
043A6:  MOVLW  08
043A8:  ADDWF  x75,W
043AA:  MOVWF  01
043AC:  MOVLW  00
043AE:  ADDWFC x76,W
043B0:  MOVWF  03
043B2:  MOVF   01,W
043B4:  ADDLW  0F
043B6:  MOVWF  01
043B8:  MOVLW  01
043BA:  ADDWFC 03,F
043BC:  MOVFF  01,675
043C0:  MOVFF  03,676
043C4:  MOVF   x6C,W
043C6:  MULLW  21
043C8:  MOVF   FF3,W
043CA:  CLRF   x78
043CC:  MOVWF  x77
043CE:  MOVLW  0F
043D0:  ADDWF  x77,W
043D2:  MOVWF  FE9
043D4:  MOVLW  01
043D6:  ADDWFC x78,W
043D8:  MOVWF  FEA
043DA:  MOVFF  FEF,6B4
043DE:  MOVFF  FEC,6B5
043E2:  MOVFF  FEC,6B6
043E6:  MOVFF  FEC,6B7
043EA:  MOVF   x6C,W
043EC:  MULLW  10
043EE:  MOVF   FF3,W
043F0:  CLRF   x7E
043F2:  MOVWF  x7D
043F4:  MOVLW  08
043F6:  ADDWF  x7D,W
043F8:  MOVWF  01
043FA:  MOVLW  00
043FC:  ADDWFC x7E,W
043FE:  MOVWF  03
04400:  MOVF   01,W
04402:  ADDLW  62
04404:  MOVWF  FE9
04406:  MOVLW  00
04408:  ADDWFC 03,W
0440A:  MOVWF  FEA
0440C:  MOVFF  FEF,6B8
04410:  MOVFF  FEC,01
04414:  MOVFF  FEC,02
04418:  MOVFF  FEC,03
0441C:  MOVFF  03,6BB
04420:  MOVFF  02,6BA
04424:  MOVFF  01,6B9
04428:  MOVLB  0
0442A:  CALL   130A
0442E:  MOVFF  03,6B6
04432:  MOVFF  02,6B5
04436:  MOVFF  01,6B4
0443A:  MOVFF  00,6B3
0443E:  MOVLB  6
04440:  MOVF   x6C,W
04442:  MULLW  10
04444:  MOVF   FF3,W
04446:  CLRF   x7E
04448:  MOVWF  x7D
0444A:  MOVLW  62
0444C:  ADDWF  x7D,W
0444E:  MOVWF  FE9
04450:  MOVLW  00
04452:  ADDWFC x7E,W
04454:  MOVWF  FEA
04456:  MOVFF  FEF,6B7
0445A:  MOVFF  FEC,01
0445E:  MOVFF  FEC,02
04462:  MOVFF  FEC,03
04466:  BCF    FD8.1
04468:  MOVFF  03,6BA
0446C:  MOVFF  02,6B9
04470:  MOVFF  01,6B8
04474:  MOVLB  0
04476:  CALL   1400
0447A:  MOVFF  676,FEA
0447E:  MOVFF  675,FE9
04482:  MOVFF  00,FEF
04486:  MOVFF  01,FEC
0448A:  MOVFF  02,FEC
0448E:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
04492:  MOVLB  6
04494:  MOVF   x6C,W
04496:  MULLW  21
04498:  MOVF   FF3,W
0449A:  CLRF   x76
0449C:  MOVWF  x75
0449E:  MOVLW  0C
044A0:  ADDWF  x75,W
044A2:  MOVWF  01
044A4:  MOVLW  00
044A6:  ADDWFC x76,W
044A8:  MOVWF  03
044AA:  MOVF   01,W
044AC:  ADDLW  0F
044AE:  MOVWF  01
044B0:  MOVLW  01
044B2:  ADDWFC 03,F
044B4:  MOVFF  01,675
044B8:  MOVFF  03,676
044BC:  MOVF   x6C,W
044BE:  MULLW  21
044C0:  MOVF   FF3,W
044C2:  CLRF   x78
044C4:  MOVWF  x77
044C6:  MOVLW  04
044C8:  ADDWF  x77,W
044CA:  MOVWF  01
044CC:  MOVLW  00
044CE:  ADDWFC x78,W
044D0:  MOVWF  03
044D2:  MOVF   01,W
044D4:  ADDLW  0F
044D6:  MOVWF  FE9
044D8:  MOVLW  01
044DA:  ADDWFC 03,W
044DC:  MOVWF  FEA
044DE:  MOVFF  FEF,6B4
044E2:  MOVFF  FEC,6B5
044E6:  MOVFF  FEC,6B6
044EA:  MOVFF  FEC,6B7
044EE:  MOVF   x6C,W
044F0:  MULLW  10
044F2:  MOVF   FF3,W
044F4:  CLRF   x7C
044F6:  MOVWF  x7B
044F8:  MOVLW  0C
044FA:  ADDWF  x7B,W
044FC:  MOVWF  01
044FE:  MOVLW  00
04500:  ADDWFC x7C,W
04502:  MOVWF  03
04504:  MOVF   01,W
04506:  ADDLW  62
04508:  MOVWF  FE9
0450A:  MOVLW  00
0450C:  ADDWFC 03,W
0450E:  MOVWF  FEA
04510:  MOVFF  FEF,6B8
04514:  MOVFF  FEC,01
04518:  MOVFF  FEC,02
0451C:  MOVFF  FEC,03
04520:  MOVFF  03,6BB
04524:  MOVFF  02,6BA
04528:  MOVFF  01,6B9
0452C:  MOVLB  0
0452E:  CALL   130A
04532:  MOVFF  03,6B6
04536:  MOVFF  02,6B5
0453A:  MOVFF  01,6B4
0453E:  MOVFF  00,6B3
04542:  MOVLB  6
04544:  MOVF   x6C,W
04546:  MULLW  10
04548:  MOVF   FF3,W
0454A:  CLRF   x7C
0454C:  MOVWF  x7B
0454E:  MOVLW  04
04550:  ADDWF  x7B,W
04552:  MOVWF  01
04554:  MOVLW  00
04556:  ADDWFC x7C,W
04558:  MOVWF  03
0455A:  MOVF   01,W
0455C:  ADDLW  62
0455E:  MOVWF  FE9
04560:  MOVLW  00
04562:  ADDWFC 03,W
04564:  MOVWF  FEA
04566:  MOVFF  FEF,6B7
0456A:  MOVFF  FEC,01
0456E:  MOVFF  FEC,02
04572:  MOVFF  FEC,03
04576:  BCF    FD8.1
04578:  MOVFF  03,6BA
0457C:  MOVFF  02,6B9
04580:  MOVFF  01,6B8
04584:  MOVLB  0
04586:  CALL   1400
0458A:  MOVFF  676,FEA
0458E:  MOVFF  675,FE9
04592:  MOVFF  00,FEF
04596:  MOVFF  01,FEC
0459A:  MOVFF  02,FEC
0459E:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
045A2:  MOVLB  6
045A4:  CLRF   x70
045A6:  CLRF   x6F
045A8:  CLRF   x6E
045AA:  CLRF   x6D
045AC:  CLRF   x74
045AE:  CLRF   x73
045B0:  CLRF   x72
045B2:  MOVLW  7F
045B4:  MOVWF  x71
....................    
....................    if (adcVals[ch].cosCounts < 0){
045B6:  MOVF   x6C,W
045B8:  MULLW  21
045BA:  MOVF   FF3,W
045BC:  CLRF   x76
045BE:  MOVWF  x75
045C0:  MOVLW  0C
045C2:  ADDWF  x75,W
045C4:  MOVWF  01
045C6:  MOVLW  00
045C8:  ADDWFC x76,W
045CA:  MOVWF  03
045CC:  MOVF   01,W
045CE:  ADDLW  0F
045D0:  MOVWF  FE9
045D2:  MOVLW  01
045D4:  ADDWFC 03,W
045D6:  MOVWF  FEA
045D8:  MOVFF  FEF,6AF
045DC:  MOVFF  FEC,6B0
045E0:  MOVFF  FEC,6B1
045E4:  MOVFF  FEC,6B2
045E8:  CLRF   xB6
045EA:  CLRF   xB5
045EC:  CLRF   xB4
045EE:  CLRF   xB3
045F0:  MOVLB  0
045F2:  CALL   27D6
045F6:  BTFSS  FD8.0
045F8:  BRA    4762
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
045FA:  MOVLB  6
045FC:  MOVF   x6C,W
045FE:  MULLW  21
04600:  MOVF   FF3,W
04602:  CLRF   x76
04604:  MOVWF  x75
04606:  MOVLW  08
04608:  ADDWF  x75,W
0460A:  MOVWF  01
0460C:  MOVLW  00
0460E:  ADDWFC x76,W
04610:  MOVWF  03
04612:  MOVF   01,W
04614:  ADDLW  0F
04616:  MOVWF  FE9
04618:  MOVLW  01
0461A:  ADDWFC 03,W
0461C:  MOVWF  FEA
0461E:  MOVFF  FEF,6B3
04622:  MOVFF  FEC,676
04626:  MOVFF  FEC,6B5
0462A:  MOVFF  FEC,6B6
0462E:  CLRF   xB2
04630:  CLRF   xB1
04632:  CLRF   xB0
04634:  CLRF   xAF
04636:  MOVFF  676,6B4
0463A:  MOVLB  0
0463C:  CALL   27D6
04640:  BNC   46AE
04642:  MOVLB  6
04644:  MOVF   x6C,W
04646:  MULLW  21
04648:  MOVF   FF3,W
0464A:  CLRF   x76
0464C:  MOVWF  x75
0464E:  MOVLW  10
04650:  ADDWF  x75,W
04652:  MOVWF  01
04654:  MOVLW  00
04656:  ADDWFC x76,W
04658:  MOVWF  03
0465A:  MOVF   01,W
0465C:  ADDLW  0F
0465E:  MOVWF  FE9
04660:  MOVLW  01
04662:  ADDWFC 03,W
04664:  MOVWF  FEA
04666:  MOVFF  FEF,6AF
0466A:  MOVFF  FEC,6B0
0466E:  MOVFF  FEC,6B1
04672:  MOVFF  FEC,6B2
04676:  CLRF   xB6
04678:  CLRF   xB5
0467A:  CLRF   xB4
0467C:  CLRF   xB3
0467E:  MOVLB  0
04680:  CALL   27D6
04684:  BNC   46AE
....................          adcVals[ch].npoles--;
04686:  MOVLB  6
04688:  MOVF   x6C,W
0468A:  MULLW  21
0468C:  MOVF   FF3,W
0468E:  CLRF   x76
04690:  MOVWF  x75
04692:  MOVLW  1C
04694:  ADDWF  x75,W
04696:  MOVWF  01
04698:  MOVLW  00
0469A:  ADDWFC x76,W
0469C:  MOVWF  03
0469E:  MOVF   01,W
046A0:  ADDLW  0F
046A2:  MOVWF  FE9
046A4:  MOVLW  01
046A6:  ADDWFC 03,W
046A8:  MOVWF  FEA
046AA:  DECF   FEF,F
....................       }
046AC:  BRA    4760
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
046AE:  MOVLB  6
046B0:  MOVF   x6C,W
046B2:  MULLW  21
046B4:  MOVF   FF3,W
046B6:  CLRF   x76
046B8:  MOVWF  x75
046BA:  MOVLW  08
046BC:  ADDWF  x75,W
046BE:  MOVWF  01
046C0:  MOVLW  00
046C2:  ADDWFC x76,W
046C4:  MOVWF  03
046C6:  MOVF   01,W
046C8:  ADDLW  0F
046CA:  MOVWF  FE9
046CC:  MOVLW  01
046CE:  ADDWFC 03,W
046D0:  MOVWF  FEA
046D2:  MOVFF  FEF,6AF
046D6:  MOVFF  FEC,676
046DA:  MOVFF  FEC,6B1
046DE:  MOVFF  FEC,6B2
046E2:  MOVFF  676,6B0
046E6:  CLRF   xB6
046E8:  CLRF   xB5
046EA:  CLRF   xB4
046EC:  CLRF   xB3
046EE:  MOVLB  0
046F0:  CALL   27D6
046F4:  BNC   4762
046F6:  MOVLB  6
046F8:  MOVF   x6C,W
046FA:  MULLW  21
046FC:  MOVF   FF3,W
046FE:  CLRF   x76
04700:  MOVWF  x75
04702:  MOVLW  10
04704:  ADDWF  x75,W
04706:  MOVWF  01
04708:  MOVLW  00
0470A:  ADDWFC x76,W
0470C:  MOVWF  03
0470E:  MOVF   01,W
04710:  ADDLW  0F
04712:  MOVWF  FE9
04714:  MOVLW  01
04716:  ADDWFC 03,W
04718:  MOVWF  FEA
0471A:  MOVFF  FEF,6B3
0471E:  MOVFF  FEC,6B4
04722:  MOVFF  FEC,6B5
04726:  MOVFF  FEC,6B6
0472A:  CLRF   xB2
0472C:  CLRF   xB1
0472E:  CLRF   xB0
04730:  CLRF   xAF
04732:  MOVLB  0
04734:  CALL   27D6
04738:  BNC   4762
....................          adcVals[ch].npoles++;
0473A:  MOVLB  6
0473C:  MOVF   x6C,W
0473E:  MULLW  21
04740:  MOVF   FF3,W
04742:  CLRF   x76
04744:  MOVWF  x75
04746:  MOVLW  1C
04748:  ADDWF  x75,W
0474A:  MOVWF  01
0474C:  MOVLW  00
0474E:  ADDWFC x76,W
04750:  MOVWF  03
04752:  MOVF   01,W
04754:  ADDLW  0F
04756:  MOVWF  FE9
04758:  MOVLW  01
0475A:  ADDWFC 03,W
0475C:  MOVWF  FEA
0475E:  INCF   FEF,F
04760:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
04762:  MOVLB  6
04764:  MOVF   x6C,W
04766:  MULLW  21
04768:  MOVF   FF3,W
0476A:  CLRF   x76
0476C:  MOVWF  x75
0476E:  MOVLW  18
04770:  ADDWF  x75,W
04772:  MOVWF  01
04774:  MOVLW  00
04776:  ADDWFC x76,W
04778:  MOVWF  03
0477A:  MOVF   01,W
0477C:  ADDLW  0F
0477E:  MOVWF  01
04780:  MOVLW  01
04782:  ADDWFC 03,F
04784:  MOVFF  01,675
04788:  MOVFF  03,676
0478C:  MOVFF  674,6B7
04790:  MOVFF  673,6B6
04794:  MOVFF  672,6B5
04798:  MOVFF  671,6B4
0479C:  MOVLW  AA
0479E:  MOVWF  xBB
047A0:  MOVLW  27
047A2:  MOVWF  xBA
047A4:  MOVLW  1F
047A6:  MOVWF  xB9
047A8:  MOVLW  86
047AA:  MOVWF  xB8
047AC:  MOVLB  0
047AE:  CALL   130A
047B2:  MOVFF  03,67A
047B6:  MOVFF  02,679
047BA:  MOVFF  01,678
047BE:  MOVFF  00,677
047C2:  MOVLB  6
047C4:  MOVF   x6C,W
047C6:  MULLW  21
047C8:  MOVF   FF3,W
047CA:  CLRF   x7C
047CC:  MOVWF  x7B
047CE:  MOVLW  08
047D0:  ADDWF  x7B,W
047D2:  MOVWF  01
047D4:  MOVLW  00
047D6:  ADDWFC x7C,W
047D8:  MOVWF  03
047DA:  MOVF   01,W
047DC:  ADDLW  0F
047DE:  MOVWF  FE9
047E0:  MOVLW  01
047E2:  ADDWFC 03,W
047E4:  MOVWF  FEA
047E6:  MOVFF  FEF,67B
047EA:  MOVFF  FEC,67C
047EE:  MOVFF  FEC,67D
047F2:  MOVFF  FEC,67E
047F6:  MOVF   x6C,W
047F8:  MULLW  21
047FA:  MOVF   FF3,W
047FC:  CLRF   x80
047FE:  MOVWF  x7F
04800:  MOVLW  0C
04802:  ADDWF  x7F,W
04804:  MOVWF  01
04806:  MOVLW  00
04808:  ADDWFC x80,W
0480A:  MOVWF  03
0480C:  MOVF   01,W
0480E:  ADDLW  0F
04810:  MOVWF  FE9
04812:  MOVLW  01
04814:  ADDWFC 03,W
04816:  MOVWF  FEA
04818:  MOVFF  FEF,00
0481C:  MOVFF  FEC,01
04820:  MOVFF  FEC,02
04824:  MOVFF  FEC,03
04828:  MOVFF  03,682
0482C:  MOVFF  02,681
04830:  MOVFF  01,680
04834:  MOVFF  00,67F
04838:  MOVFF  67E,686
0483C:  MOVFF  67D,685
04840:  MOVFF  67C,684
04844:  MOVFF  67B,683
04848:  MOVFF  03,68A
0484C:  MOVFF  02,689
04850:  MOVFF  01,688
04854:  MOVFF  00,687
04858:  MOVLB  0
0485A:  GOTO   2ED8
0485E:  MOVFF  67A,6B7
04862:  MOVFF  679,6B6
04866:  MOVFF  678,6B5
0486A:  MOVFF  677,6B4
0486E:  MOVFF  03,6BB
04872:  MOVFF  02,6BA
04876:  MOVFF  01,6B9
0487A:  MOVFF  00,6B8
0487E:  CALL   130A
04882:  MOVFF  676,FEA
04886:  MOVFF  675,FE9
0488A:  MOVFF  00,FEF
0488E:  MOVFF  01,FEC
04892:  MOVFF  02,FEC
04896:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
0489A:  MOVLB  6
0489C:  MOVF   x6C,W
0489E:  MULLW  21
048A0:  MOVF   FF3,W
048A2:  CLRF   x76
048A4:  MOVWF  x75
048A6:  MOVLW  18
048A8:  ADDWF  x75,W
048AA:  MOVWF  01
048AC:  MOVLW  00
048AE:  ADDWFC x76,W
048B0:  MOVWF  03
048B2:  MOVF   01,W
048B4:  ADDLW  0F
048B6:  MOVWF  FE9
048B8:  MOVLW  01
048BA:  ADDWFC 03,W
048BC:  MOVWF  FEA
048BE:  MOVFF  FEF,675
048C2:  MOVFF  FEC,676
048C6:  MOVFF  FEC,677
048CA:  MOVFF  FEC,678
048CE:  CLRF   xB7
048D0:  CLRF   xB6
048D2:  MOVLW  7A
048D4:  MOVWF  xB5
048D6:  MOVLW  88
048D8:  MOVWF  xB4
048DA:  MOVFF  674,6BB
048DE:  MOVFF  673,6BA
048E2:  MOVFF  672,6B9
048E6:  MOVFF  671,6B8
048EA:  MOVLB  0
048EC:  CALL   130A
048F0:  MOVFF  03,67C
048F4:  MOVFF  02,67B
048F8:  MOVFF  01,67A
048FC:  MOVFF  00,679
04900:  MOVLB  6
04902:  MOVF   x6C,W
04904:  MULLW  21
04906:  MOVF   FF3,W
04908:  CLRF   x7E
0490A:  MOVWF  x7D
0490C:  MOVLW  1C
0490E:  ADDWF  x7D,W
04910:  MOVWF  01
04912:  MOVLW  00
04914:  ADDWFC x7E,W
04916:  MOVWF  03
04918:  MOVF   01,W
0491A:  ADDLW  0F
0491C:  MOVWF  FE9
0491E:  MOVLW  01
04920:  ADDWFC 03,W
04922:  MOVWF  FEA
04924:  MOVF   FEF,W
04926:  CLRF   xA6
04928:  MOVWF  xA5
0492A:  BTFSC  xA5.7
0492C:  DECF   xA6,F
0492E:  MOVLB  0
04930:  CALL   317A
04934:  MOVFF  67C,6B7
04938:  MOVFF  67B,6B6
0493C:  MOVFF  67A,6B5
04940:  MOVFF  679,6B4
04944:  MOVFF  03,6BB
04948:  MOVFF  02,6BA
0494C:  MOVFF  01,6B9
04950:  MOVFF  00,6B8
04954:  CALL   130A
04958:  MOVFF  FEA,67A
0495C:  MOVFF  FE9,679
04960:  BCF    FD8.1
04962:  MOVFF  678,6B6
04966:  MOVFF  677,6B5
0496A:  MOVFF  676,6B4
0496E:  MOVFF  675,6B3
04972:  MOVFF  03,6BA
04976:  MOVFF  02,6B9
0497A:  MOVFF  01,6B8
0497E:  MOVFF  00,6B7
04982:  CALL   1400
04986:  MOVFF  67A,FEA
0498A:  MOVFF  679,FE9
0498E:  MOVFF  03,670
04992:  MOVFF  02,66F
04996:  MOVFF  01,66E
0499A:  MOVFF  00,66D
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
0499E:  MOVLB  6
049A0:  MOVF   x6C,W
049A2:  MULLW  21
049A4:  MOVF   FF3,W
049A6:  CLRF   x76
049A8:  MOVWF  x75
049AA:  MOVLW  1D
049AC:  ADDWF  x75,W
049AE:  MOVWF  01
049B0:  MOVLW  00
049B2:  ADDWFC x76,W
049B4:  MOVWF  03
049B6:  MOVF   01,W
049B8:  ADDLW  0F
049BA:  MOVWF  01
049BC:  MOVLW  01
049BE:  ADDWFC 03,F
049C0:  MOVFF  01,675
049C4:  MOVFF  03,676
049C8:  MOVF   x6C,W
049CA:  MULLW  18
049CC:  MOVF   FF3,W
049CE:  CLRF   x78
049D0:  MOVWF  x77
049D2:  MOVLW  14
049D4:  ADDWF  x77,W
049D6:  MOVWF  01
049D8:  MOVLW  00
049DA:  ADDWFC x78,W
049DC:  MOVWF  03
049DE:  MOVF   01,W
049E0:  ADDLW  82
049E2:  MOVWF  FE9
049E4:  MOVLW  00
049E6:  ADDWFC 03,W
049E8:  MOVWF  FEA
049EA:  MOVFF  FEF,6B8
049EE:  MOVFF  FEC,01
049F2:  MOVFF  FEC,02
049F6:  MOVFF  FEC,03
049FA:  MOVFF  670,6B7
049FE:  MOVFF  66F,6B6
04A02:  MOVFF  66E,6B5
04A06:  MOVFF  66D,6B4
04A0A:  MOVFF  03,6BB
04A0E:  MOVFF  02,6BA
04A12:  MOVFF  01,6B9
04A16:  MOVLB  0
04A18:  CALL   130A
04A1C:  MOVFF  03,67A
04A20:  MOVFF  02,679
04A24:  MOVFF  01,678
04A28:  MOVFF  00,677
04A2C:  MOVFF  03,686
04A30:  MOVFF  02,685
04A34:  MOVFF  01,684
04A38:  MOVFF  00,683
04A3C:  MOVLB  6
04A3E:  CLRF   x8A
04A40:  CLRF   x89
04A42:  MOVLW  20
04A44:  MOVWF  x88
04A46:  MOVLW  81
04A48:  MOVWF  x87
04A4A:  MOVLB  0
04A4C:  CALL   3EB8
04A50:  MOVFF  03,67A
04A54:  MOVFF  02,679
04A58:  MOVFF  01,678
04A5C:  MOVFF  00,677
04A60:  MOVLB  6
04A62:  MOVF   x6C,W
04A64:  MULLW  18
04A66:  MOVF   FF3,W
04A68:  CLRF   x7C
04A6A:  MOVWF  x7B
04A6C:  MOVLW  10
04A6E:  ADDWF  x7B,W
04A70:  MOVWF  01
04A72:  MOVLW  00
04A74:  ADDWFC x7C,W
04A76:  MOVWF  03
04A78:  MOVF   01,W
04A7A:  ADDLW  82
04A7C:  MOVWF  FE9
04A7E:  MOVLW  00
04A80:  ADDWFC 03,W
04A82:  MOVWF  FEA
04A84:  MOVFF  FEF,6B8
04A88:  MOVFF  FEC,01
04A8C:  MOVFF  FEC,02
04A90:  MOVFF  FEC,03
04A94:  MOVFF  670,6B7
04A98:  MOVFF  66F,6B6
04A9C:  MOVFF  66E,6B5
04AA0:  MOVFF  66D,6B4
04AA4:  MOVFF  03,6BB
04AA8:  MOVFF  02,6BA
04AAC:  MOVFF  01,6B9
04AB0:  MOVLB  0
04AB2:  CALL   130A
04AB6:  MOVFF  03,67E
04ABA:  MOVFF  02,67D
04ABE:  MOVFF  01,67C
04AC2:  MOVFF  00,67B
04AC6:  MOVFF  03,686
04ACA:  MOVFF  02,685
04ACE:  MOVFF  01,684
04AD2:  MOVFF  00,683
04AD6:  MOVLB  6
04AD8:  CLRF   x8A
04ADA:  CLRF   x89
04ADC:  CLRF   x88
04ADE:  MOVLW  81
04AE0:  MOVWF  x87
04AE2:  MOVLB  0
04AE4:  CALL   3EB8
04AE8:  MOVFF  FEA,67C
04AEC:  MOVFF  FE9,67B
04AF0:  BCF    FD8.1
04AF2:  MOVFF  67A,6B6
04AF6:  MOVFF  679,6B5
04AFA:  MOVFF  678,6B4
04AFE:  MOVFF  677,6B3
04B02:  MOVFF  03,6BA
04B06:  MOVFF  02,6B9
04B0A:  MOVFF  01,6B8
04B0E:  MOVFF  00,6B7
04B12:  CALL   1400
04B16:  MOVFF  67C,FEA
04B1A:  MOVFF  67B,FE9
04B1E:  MOVFF  03,67A
04B22:  MOVFF  02,679
04B26:  MOVFF  01,678
04B2A:  MOVFF  00,677
04B2E:  MOVLB  6
04B30:  MOVF   x6C,W
04B32:  MULLW  18
04B34:  MOVF   FF3,W
04B36:  CLRF   x7E
04B38:  MOVWF  x7D
04B3A:  MOVLW  0C
04B3C:  ADDWF  x7D,W
04B3E:  MOVWF  01
04B40:  MOVLW  00
04B42:  ADDWFC x7E,W
04B44:  MOVWF  03
04B46:  MOVF   01,W
04B48:  ADDLW  82
04B4A:  MOVWF  FE9
04B4C:  MOVLW  00
04B4E:  ADDWFC 03,W
04B50:  MOVWF  FEA
04B52:  MOVFF  FEF,6B8
04B56:  MOVFF  FEC,01
04B5A:  MOVFF  FEC,02
04B5E:  MOVFF  FEC,03
04B62:  MOVFF  670,6B7
04B66:  MOVFF  66F,6B6
04B6A:  MOVFF  66E,6B5
04B6E:  MOVFF  66D,6B4
04B72:  MOVFF  03,6BB
04B76:  MOVFF  02,6BA
04B7A:  MOVFF  01,6B9
04B7E:  MOVLB  0
04B80:  CALL   130A
04B84:  MOVFF  03,680
04B88:  MOVFF  02,67F
04B8C:  MOVFF  01,67E
04B90:  MOVFF  00,67D
04B94:  MOVFF  03,686
04B98:  MOVFF  02,685
04B9C:  MOVFF  01,684
04BA0:  MOVFF  00,683
04BA4:  MOVLB  6
04BA6:  CLRF   x8A
04BA8:  CLRF   x89
04BAA:  MOVLW  40
04BAC:  MOVWF  x88
04BAE:  MOVLW  80
04BB0:  MOVWF  x87
04BB2:  MOVLB  0
04BB4:  CALL   3EB8
04BB8:  MOVFF  FEA,67E
04BBC:  MOVFF  FE9,67D
04BC0:  BCF    FD8.1
04BC2:  MOVFF  67A,6B6
04BC6:  MOVFF  679,6B5
04BCA:  MOVFF  678,6B4
04BCE:  MOVFF  677,6B3
04BD2:  MOVFF  03,6BA
04BD6:  MOVFF  02,6B9
04BDA:  MOVFF  01,6B8
04BDE:  MOVFF  00,6B7
04BE2:  CALL   1400
04BE6:  MOVFF  67E,FEA
04BEA:  MOVFF  67D,FE9
04BEE:  MOVFF  03,67A
04BF2:  MOVFF  02,679
04BF6:  MOVFF  01,678
04BFA:  MOVFF  00,677
04BFE:  MOVLB  6
04C00:  MOVF   x6C,W
04C02:  MULLW  18
04C04:  MOVF   FF3,W
04C06:  CLRF   x80
04C08:  MOVWF  x7F
04C0A:  MOVLW  08
04C0C:  ADDWF  x7F,W
04C0E:  MOVWF  01
04C10:  MOVLW  00
04C12:  ADDWFC x80,W
04C14:  MOVWF  03
04C16:  MOVF   01,W
04C18:  ADDLW  82
04C1A:  MOVWF  FE9
04C1C:  MOVLW  00
04C1E:  ADDWFC 03,W
04C20:  MOVWF  FEA
04C22:  MOVFF  FEF,6B8
04C26:  MOVFF  FEC,01
04C2A:  MOVFF  FEC,02
04C2E:  MOVFF  FEC,03
04C32:  MOVFF  670,6B7
04C36:  MOVFF  66F,6B6
04C3A:  MOVFF  66E,6B5
04C3E:  MOVFF  66D,6B4
04C42:  MOVFF  03,6BB
04C46:  MOVFF  02,6BA
04C4A:  MOVFF  01,6B9
04C4E:  MOVLB  0
04C50:  CALL   130A
04C54:  MOVFF  03,682
04C58:  MOVFF  02,681
04C5C:  MOVFF  01,680
04C60:  MOVFF  00,67F
04C64:  MOVFF  03,686
04C68:  MOVFF  02,685
04C6C:  MOVFF  01,684
04C70:  MOVFF  00,683
04C74:  MOVLB  6
04C76:  CLRF   x8A
04C78:  CLRF   x89
04C7A:  CLRF   x88
04C7C:  MOVLW  80
04C7E:  MOVWF  x87
04C80:  MOVLB  0
04C82:  CALL   3EB8
04C86:  MOVFF  FEA,680
04C8A:  MOVFF  FE9,67F
04C8E:  BCF    FD8.1
04C90:  MOVFF  67A,6B6
04C94:  MOVFF  679,6B5
04C98:  MOVFF  678,6B4
04C9C:  MOVFF  677,6B3
04CA0:  MOVFF  03,6BA
04CA4:  MOVFF  02,6B9
04CA8:  MOVFF  01,6B8
04CAC:  MOVFF  00,6B7
04CB0:  CALL   1400
04CB4:  MOVFF  680,FEA
04CB8:  MOVFF  67F,FE9
04CBC:  MOVFF  03,67A
04CC0:  MOVFF  02,679
04CC4:  MOVFF  01,678
04CC8:  MOVFF  00,677
04CCC:  MOVLB  6
04CCE:  MOVF   x6C,W
04CD0:  MULLW  18
04CD2:  MOVF   FF3,W
04CD4:  CLRF   x82
04CD6:  MOVWF  x81
04CD8:  MOVLW  04
04CDA:  ADDWF  x81,W
04CDC:  MOVWF  01
04CDE:  MOVLW  00
04CE0:  ADDWFC x82,W
04CE2:  MOVWF  03
04CE4:  MOVF   01,W
04CE6:  ADDLW  82
04CE8:  MOVWF  FE9
04CEA:  MOVLW  00
04CEC:  ADDWFC 03,W
04CEE:  MOVWF  FEA
04CF0:  MOVFF  FEF,6B8
04CF4:  MOVFF  FEC,01
04CF8:  MOVFF  FEC,02
04CFC:  MOVFF  FEC,03
04D00:  MOVFF  670,6B7
04D04:  MOVFF  66F,6B6
04D08:  MOVFF  66E,6B5
04D0C:  MOVFF  66D,6B4
04D10:  MOVFF  03,6BB
04D14:  MOVFF  02,6BA
04D18:  MOVFF  01,6B9
04D1C:  MOVLB  0
04D1E:  CALL   130A
04D22:  MOVFF  FEA,682
04D26:  MOVFF  FE9,681
04D2A:  BCF    FD8.1
04D2C:  MOVFF  67A,6B6
04D30:  MOVFF  679,6B5
04D34:  MOVFF  678,6B4
04D38:  MOVFF  677,6B3
04D3C:  MOVFF  03,6BA
04D40:  MOVFF  02,6B9
04D44:  MOVFF  01,6B8
04D48:  MOVFF  00,6B7
04D4C:  CALL   1400
04D50:  MOVFF  682,FEA
04D54:  MOVFF  681,FE9
04D58:  MOVFF  03,6B6
04D5C:  MOVFF  02,6B5
04D60:  MOVFF  01,6B4
04D64:  MOVFF  00,6B3
04D68:  MOVLB  6
04D6A:  MOVF   x6C,W
04D6C:  MULLW  18
04D6E:  MOVF   FF3,W
04D70:  CLRF   x84
04D72:  MOVWF  x83
04D74:  MOVLW  82
04D76:  ADDWF  x83,W
04D78:  MOVWF  FE9
04D7A:  MOVLW  00
04D7C:  ADDWFC x84,W
04D7E:  MOVWF  FEA
04D80:  MOVFF  FEF,6B7
04D84:  MOVFF  FEC,01
04D88:  MOVFF  FEC,02
04D8C:  MOVFF  FEC,03
04D90:  BCF    FD8.1
04D92:  MOVFF  03,6BA
04D96:  MOVFF  02,6B9
04D9A:  MOVFF  01,6B8
04D9E:  MOVLB  0
04DA0:  CALL   1400
04DA4:  MOVFF  676,FEA
04DA8:  MOVFF  675,FE9
04DAC:  MOVFF  00,FEF
04DB0:  MOVFF  01,FEC
04DB4:  MOVFF  02,FEC
04DB8:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04DBC:  MOVLB  6
04DBE:  MOVF   x6C,F
04DC0:  BNZ   4E1E
04DC2:  MOVF   x6C,W
04DC4:  MULLW  21
04DC6:  MOVF   FF3,W
04DC8:  CLRF   x76
04DCA:  MOVWF  x75
04DCC:  MOVLW  1D
04DCE:  ADDWF  x75,W
04DD0:  MOVWF  01
04DD2:  MOVLW  00
04DD4:  ADDWFC x76,W
04DD6:  MOVWF  03
04DD8:  MOVF   01,W
04DDA:  ADDLW  0F
04DDC:  MOVWF  FE9
04DDE:  MOVLW  01
04DE0:  ADDWFC 03,W
04DE2:  MOVWF  FEA
04DE4:  MOVFF  FEF,6B4
04DE8:  MOVFF  FEC,6B5
04DEC:  MOVFF  FEC,6B6
04DF0:  MOVFF  FEC,6B7
04DF4:  MOVF   FED,F
04DF6:  MOVF   FED,F
04DF8:  MOVF   FED,F
04DFA:  CLRF   xBB
04DFC:  CLRF   xBA
04DFE:  MOVLW  80
04E00:  MOVWF  xB9
04E02:  MOVLW  7F
04E04:  MOVWF  xB8
04E06:  MOVLB  0
04E08:  CALL   130A
04E0C:  MOVFF  00,FEF
04E10:  MOVFF  01,FEC
04E14:  MOVFF  02,FEC
04E18:  MOVFF  03,FEC
04E1C:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
04E1E:  MOVF   x6C,W
04E20:  MULLW  20
04E22:  MOVF   FF3,W
04E24:  CLRF   x76
04E26:  MOVWF  x75
04E28:  MOVLW  14
04E2A:  ADDWF  x75,W
04E2C:  MOVWF  01
04E2E:  MOVLW  00
04E30:  ADDWFC x76,W
04E32:  MOVWF  03
04E34:  MOVF   01,W
04E36:  ADDLW  20
04E38:  MOVWF  01
04E3A:  MOVLW  00
04E3C:  ADDWFC 03,F
04E3E:  MOVFF  01,675
04E42:  MOVFF  03,676
04E46:  MOVF   x6C,W
04E48:  MULLW  20
04E4A:  MOVF   FF3,W
04E4C:  CLRF   x78
04E4E:  MOVWF  x77
04E50:  MOVLW  10
04E52:  ADDWF  x77,W
04E54:  MOVWF  01
04E56:  MOVLW  00
04E58:  ADDWFC x78,W
04E5A:  MOVWF  03
04E5C:  MOVF   01,W
04E5E:  ADDLW  20
04E60:  MOVWF  FE9
04E62:  MOVLW  00
04E64:  ADDWFC 03,W
04E66:  MOVWF  FEA
04E68:  MOVFF  FEF,00
04E6C:  MOVFF  FEC,01
04E70:  MOVFF  FEC,02
04E74:  MOVFF  FEC,03
04E78:  MOVFF  676,FEA
04E7C:  MOVFF  675,FE9
04E80:  MOVFF  00,FEF
04E84:  MOVFF  01,FEC
04E88:  MOVFF  02,FEC
04E8C:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04E90:  MOVF   x6C,W
04E92:  MULLW  20
04E94:  MOVF   FF3,W
04E96:  CLRF   x76
04E98:  MOVWF  x75
04E9A:  MOVLW  10
04E9C:  ADDWF  x75,W
04E9E:  MOVWF  01
04EA0:  MOVLW  00
04EA2:  ADDWFC x76,W
04EA4:  MOVWF  03
04EA6:  MOVF   01,W
04EA8:  ADDLW  20
04EAA:  MOVWF  01
04EAC:  MOVLW  00
04EAE:  ADDWFC 03,F
04EB0:  MOVFF  01,675
04EB4:  MOVFF  03,676
04EB8:  MOVF   x6C,W
04EBA:  MULLW  21
04EBC:  MOVF   FF3,W
04EBE:  CLRF   x78
04EC0:  MOVWF  x77
04EC2:  MOVLW  1D
04EC4:  ADDWF  x77,W
04EC6:  MOVWF  01
04EC8:  MOVLW  00
04ECA:  ADDWFC x78,W
04ECC:  MOVWF  03
04ECE:  MOVF   01,W
04ED0:  ADDLW  0F
04ED2:  MOVWF  FE9
04ED4:  MOVLW  01
04ED6:  ADDWFC 03,W
04ED8:  MOVWF  FEA
04EDA:  MOVFF  FEF,00
04EDE:  MOVFF  FEC,01
04EE2:  MOVFF  FEC,02
04EE6:  MOVFF  FEC,03
04EEA:  MOVFF  676,FEA
04EEE:  MOVFF  675,FE9
04EF2:  MOVFF  00,FEF
04EF6:  MOVFF  01,FEC
04EFA:  MOVFF  02,FEC
04EFE:  MOVFF  03,FEC
04F02:  MOVLB  0
04F04:  GOTO   4FE8 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001BE:  MOVLB  1
001C0:  MOVF   xD8,W
001C2:  MULLW  0D
001C4:  MOVF   FF3,W
001C6:  MOVLB  6
001C8:  CLRF   xD4
001CA:  MOVWF  xD3
001CC:  MOVLW  BD
001CE:  ADDWF  xD3,W
001D0:  MOVWF  FE9
001D2:  MOVLW  01
001D4:  ADDWFC xD4,W
001D6:  MOVWF  FEA
001D8:  BTFSC  FEF.1
001DA:  BRA    0254
....................    {
....................       smData[ch].adcBusy = true;
001DC:  MOVLB  1
001DE:  MOVF   xD8,W
001E0:  MULLW  0D
001E2:  MOVF   FF3,W
001E4:  MOVLB  6
001E6:  CLRF   xD4
001E8:  MOVWF  xD3
001EA:  MOVLW  BD
001EC:  ADDWF  xD3,W
001EE:  MOVWF  FE9
001F0:  MOVLW  01
001F2:  ADDWFC xD4,W
001F4:  MOVWF  FEA
001F6:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001F8:  MOVFF  1D8,6D3
001FC:  MOVLB  0
001FE:  BRA    01A2
....................       ch = !ch;
00200:  MOVLB  1
00202:  MOVF   xD8,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVWF  xD8
....................       
....................       smData[!ch].dataReady = true;
0020E:  MOVF   xD8,F
00210:  BZ    0216
00212:  MOVLW  00
00214:  BRA    0218
00216:  MOVLW  01
00218:  MULLW  0D
0021A:  MOVF   FF3,W
0021C:  MOVLB  6
0021E:  CLRF   xD4
00220:  MOVWF  xD3
00222:  MOVLW  BD
00224:  ADDWF  xD3,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC xD4,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00230:  MOVLB  1
00232:  MOVF   xD8,F
00234:  BZ    023A
00236:  MOVLW  00
00238:  BRA    023C
0023A:  MOVLW  01
0023C:  MULLW  0D
0023E:  MOVF   FF3,W
00240:  MOVLB  6
00242:  CLRF   xD4
00244:  MOVWF  xD3
00246:  MOVLW  BD
00248:  ADDWF  xD3,W
0024A:  MOVWF  FE9
0024C:  MOVLW  01
0024E:  ADDWFC xD4,W
00250:  MOVWF  FEA
00252:  BCF    FEF.1
....................    }
00254:  MOVLB  0
00256:  GOTO   0318 (RETURN)
.................... }
.................... 
.................... signed int compar(void *a, void *b) {
....................    return COMPARE(a,b);
*
01BF6:  MOVLB  6
01BF8:  MOVF   x62,W
01BFA:  SUBWF  x60,W
01BFC:  BNC   1C06
01BFE:  BNZ   1C0A
01C00:  MOVF   x5F,W
01C02:  SUBWF  x61,W
01C04:  BNC   1C0A
01C06:  MOVLW  00
01C08:  BRA    1C0C
01C0A:  MOVLW  01
01C0C:  MOVWF  xC8
01C0E:  MOVF   x60,W
01C10:  SUBWF  x62,W
01C12:  BNC   1C1C
01C14:  BNZ   1C20
01C16:  MOVF   x61,W
01C18:  SUBWF  x5F,W
01C1A:  BNC   1C20
01C1C:  MOVLW  00
01C1E:  BRA    1C22
01C20:  MOVLW  01
01C22:  SUBWF  xC8,W
01C24:  MOVWF  01
01C26:  MOVLB  0
01C28:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts)
*
01E3C:  MOVLB  6
01E3E:  CLRF   xA0
01E40:  CLRF   x9F
01E42:  CLRF   x9E
01E44:  CLRF   x9D
01E46:  CLRF   xA4
01E48:  CLRF   xA3
01E4A:  CLRF   xA2
01E4C:  CLRF   xA1
.................... {
....................    signed int32 iqmBufSin[BUFFER_SIZE];
....................    signed int32 iqmBufCos[BUFFER_SIZE];
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    tobuff(smData[ch].sinQ, sinCnts); // push new data into queues
01E4E:  MOVF   x6C,W
01E50:  MULLW  0D
01E52:  MOVF   FF3,W
01E54:  CLRF   xA8
01E56:  MOVWF  xA7
01E58:  MOVLW  01
01E5A:  ADDWF  xA7,W
01E5C:  MOVWF  01
01E5E:  MOVLW  00
01E60:  ADDWFC xA8,W
01E62:  MOVWF  03
01E64:  MOVF   01,W
01E66:  ADDLW  BD
01E68:  MOVWF  01
01E6A:  MOVLW  01
01E6C:  ADDWFC 03,F
01E6E:  MOVFF  01,6A7
01E72:  MOVFF  03,6A8
01E76:  MOVFF  03,FEA
01E7A:  MOVFF  01,FE9
01E7E:  MOVFF  FEC,6AA
01E82:  MOVF   FED,F
01E84:  MOVFF  FEF,6A9
01E88:  MOVF   x6C,W
01E8A:  MULLW  0D
01E8C:  MOVF   FF3,W
01E8E:  CLRF   xAC
01E90:  MOVWF  xAB
01E92:  MOVLW  01
01E94:  ADDWF  xAB,W
01E96:  MOVWF  01
01E98:  MOVLW  00
01E9A:  ADDWFC xAC,W
01E9C:  MOVWF  03
01E9E:  MOVF   01,W
01EA0:  ADDLW  BD
01EA2:  MOVWF  01
01EA4:  MOVLW  01
01EA6:  ADDWFC 03,F
01EA8:  MOVFF  01,6AB
01EAC:  MOVFF  03,6AC
01EB0:  MOVFF  03,FEA
01EB4:  MOVFF  01,FE9
01EB8:  MOVFF  FEC,6AE
01EBC:  MOVF   FED,F
01EBE:  MOVFF  FEF,6AD
01EC2:  MOVFF  6AD,FE9
01EC6:  MOVFF  6AE,FEA
01ECA:  CLRF   xB1
01ECC:  MOVFF  FEF,6B0
01ED0:  CLRF   xB3
01ED2:  MOVLW  04
01ED4:  MOVWF  xB2
01ED6:  MOVLB  0
01ED8:  CALL   0802
01EDC:  MOVFF  02,03
01EE0:  MOVF   01,W
01EE2:  ADDLW  02
01EE4:  MOVWF  01
01EE6:  MOVLW  00
01EE8:  ADDWFC 03,F
01EEA:  MOVF   01,W
01EEC:  MOVLB  6
01EEE:  ADDWF  xA9,W
01EF0:  MOVWF  FE9
01EF2:  MOVF   xAA,W
01EF4:  ADDWFC 03,W
01EF6:  MOVWF  FEA
01EF8:  MOVFF  66D,FEF
01EFC:  MOVFF  66E,FEC
01F00:  MOVFF  66F,FEC
01F04:  MOVFF  670,FEC
01F08:  MOVF   x6C,W
01F0A:  MULLW  0D
01F0C:  MOVF   FF3,W
01F0E:  CLRF   xA8
01F10:  MOVWF  xA7
01F12:  MOVLW  01
01F14:  ADDWF  xA7,W
01F16:  MOVWF  01
01F18:  MOVLW  00
01F1A:  ADDWFC xA8,W
01F1C:  MOVWF  03
01F1E:  MOVF   01,W
01F20:  ADDLW  BD
01F22:  MOVWF  01
01F24:  MOVLW  01
01F26:  ADDWFC 03,F
01F28:  MOVFF  01,6A7
01F2C:  MOVFF  03,6A8
01F30:  MOVFF  03,FEA
01F34:  MOVFF  01,FE9
01F38:  MOVFF  FEC,03
01F3C:  MOVF   FED,F
01F3E:  MOVFF  FEF,01
01F42:  MOVFF  01,6AB
01F46:  MOVFF  03,6AC
01F4A:  MOVF   x6C,W
01F4C:  MULLW  0D
01F4E:  MOVF   FF3,W
01F50:  CLRF   xAE
01F52:  MOVWF  xAD
01F54:  MOVLW  01
01F56:  ADDWF  xAD,W
01F58:  MOVWF  01
01F5A:  MOVLW  00
01F5C:  ADDWFC xAE,W
01F5E:  MOVWF  03
01F60:  MOVF   01,W
01F62:  ADDLW  BD
01F64:  MOVWF  01
01F66:  MOVLW  01
01F68:  ADDWFC 03,F
01F6A:  MOVFF  01,6AD
01F6E:  MOVFF  03,6AE
01F72:  MOVFF  03,FEA
01F76:  MOVFF  01,FE9
01F7A:  MOVFF  FEC,6B0
01F7E:  MOVF   FED,F
01F80:  MOVFF  FEF,6AF
01F84:  MOVFF  6AF,FE9
01F88:  MOVFF  6B0,FEA
01F8C:  MOVF   FEF,W
01F8E:  SUBLW  04
01F90:  BNZ   1F96
01F92:  MOVLW  00
01F94:  BRA    1FDC
01F96:  MOVF   x6C,W
01F98:  MULLW  0D
01F9A:  MOVF   FF3,W
01F9C:  CLRF   xB2
01F9E:  MOVWF  xB1
01FA0:  MOVLW  01
01FA2:  ADDWF  xB1,W
01FA4:  MOVWF  01
01FA6:  MOVLW  00
01FA8:  ADDWFC xB2,W
01FAA:  MOVWF  03
01FAC:  MOVF   01,W
01FAE:  ADDLW  BD
01FB0:  MOVWF  01
01FB2:  MOVLW  01
01FB4:  ADDWFC 03,F
01FB6:  MOVFF  01,6B1
01FBA:  MOVFF  03,6B2
01FBE:  MOVFF  03,FEA
01FC2:  MOVFF  01,FE9
01FC6:  MOVFF  FEC,6B4
01FCA:  MOVF   FED,F
01FCC:  MOVFF  FEF,6B3
01FD0:  MOVFF  6B3,FE9
01FD4:  MOVFF  6B4,FEA
01FD8:  MOVLW  01
01FDA:  ADDWF  FEF,W
01FDC:  MOVWF  xB5
01FDE:  MOVFF  6AC,FEA
01FE2:  MOVFF  6AB,FE9
01FE6:  MOVWF  FEF
01FE8:  MOVF   x6C,W
01FEA:  MULLW  0D
01FEC:  MOVF   FF3,W
01FEE:  CLRF   xA8
01FF0:  MOVWF  xA7
01FF2:  MOVLW  01
01FF4:  ADDWF  xA7,W
01FF6:  MOVWF  01
01FF8:  MOVLW  00
01FFA:  ADDWFC xA8,W
01FFC:  MOVWF  03
01FFE:  MOVF   01,W
02000:  ADDLW  BD
02002:  MOVWF  01
02004:  MOVLW  01
02006:  ADDWFC 03,F
02008:  MOVFF  01,6A7
0200C:  MOVFF  03,6A8
02010:  MOVFF  03,FEA
02014:  MOVFF  01,FE9
02018:  MOVFF  FEC,6AA
0201C:  MOVF   FED,F
0201E:  MOVFF  FEF,6A9
02022:  MOVFF  6A9,FE9
02026:  MOVFF  6AA,FEA
0202A:  MOVFF  FEF,6AB
0202E:  MOVF   x6C,W
02030:  MULLW  0D
02032:  MOVF   FF3,W
02034:  CLRF   xAD
02036:  MOVWF  xAC
02038:  MOVLW  01
0203A:  ADDWF  xAC,W
0203C:  MOVWF  01
0203E:  MOVLW  00
02040:  ADDWFC xAD,W
02042:  MOVWF  03
02044:  MOVF   01,W
02046:  ADDLW  BD
02048:  MOVWF  01
0204A:  MOVLW  01
0204C:  ADDWFC 03,F
0204E:  MOVFF  01,6AC
02052:  MOVFF  03,6AD
02056:  MOVFF  03,FEA
0205A:  MOVFF  01,FE9
0205E:  MOVFF  FEC,6AF
02062:  MOVF   FED,F
02064:  MOVFF  FEF,6AE
02068:  MOVLW  01
0206A:  ADDWF  xAE,W
0206C:  MOVWF  FE9
0206E:  MOVLW  00
02070:  ADDWFC xAF,W
02072:  MOVWF  FEA
02074:  MOVF   FEF,W
02076:  SUBWF  xAB,W
02078:  BNZ   216A
0207A:  MOVF   x6C,W
0207C:  MULLW  0D
0207E:  MOVF   FF3,W
02080:  CLRF   xA8
02082:  MOVWF  xA7
02084:  MOVLW  01
02086:  ADDWF  xA7,W
02088:  MOVWF  01
0208A:  MOVLW  00
0208C:  ADDWFC xA8,W
0208E:  MOVWF  03
02090:  MOVF   01,W
02092:  ADDLW  BD
02094:  MOVWF  01
02096:  MOVLW  01
02098:  ADDWFC 03,F
0209A:  MOVFF  01,6A7
0209E:  MOVFF  03,6A8
020A2:  MOVFF  03,FEA
020A6:  MOVFF  01,FE9
020AA:  MOVFF  FEC,6AA
020AE:  MOVF   FED,F
020B0:  MOVFF  FEF,6A9
020B4:  MOVLW  01
020B6:  ADDWF  xA9,W
020B8:  MOVWF  01
020BA:  MOVLW  00
020BC:  ADDWFC xAA,W
020BE:  MOVWF  03
020C0:  MOVFF  01,6AB
020C4:  MOVWF  xAC
020C6:  MOVF   x6C,W
020C8:  MULLW  0D
020CA:  MOVF   FF3,W
020CC:  CLRF   xAE
020CE:  MOVWF  xAD
020D0:  MOVLW  01
020D2:  ADDWF  xAD,W
020D4:  MOVWF  01
020D6:  MOVLW  00
020D8:  ADDWFC xAE,W
020DA:  MOVWF  03
020DC:  MOVF   01,W
020DE:  ADDLW  BD
020E0:  MOVWF  01
020E2:  MOVLW  01
020E4:  ADDWFC 03,F
020E6:  MOVFF  01,6AD
020EA:  MOVFF  03,6AE
020EE:  MOVFF  03,FEA
020F2:  MOVFF  01,FE9
020F6:  MOVFF  FEC,6B0
020FA:  MOVF   FED,F
020FC:  MOVFF  FEF,6AF
02100:  MOVLW  01
02102:  ADDWF  xAF,W
02104:  MOVWF  FE9
02106:  MOVLW  00
02108:  ADDWFC xB0,W
0210A:  MOVWF  FEA
0210C:  MOVF   FEF,W
0210E:  SUBLW  04
02110:  BNZ   2116
02112:  MOVLW  00
02114:  BRA    2160
02116:  MOVF   x6C,W
02118:  MULLW  0D
0211A:  MOVF   FF3,W
0211C:  CLRF   xB2
0211E:  MOVWF  xB1
02120:  MOVLW  01
02122:  ADDWF  xB1,W
02124:  MOVWF  01
02126:  MOVLW  00
02128:  ADDWFC xB2,W
0212A:  MOVWF  03
0212C:  MOVF   01,W
0212E:  ADDLW  BD
02130:  MOVWF  01
02132:  MOVLW  01
02134:  ADDWFC 03,F
02136:  MOVFF  01,6B1
0213A:  MOVFF  03,6B2
0213E:  MOVFF  03,FEA
02142:  MOVFF  01,FE9
02146:  MOVFF  FEC,6B4
0214A:  MOVF   FED,F
0214C:  MOVFF  FEF,6B3
02150:  MOVLW  01
02152:  ADDWF  xB3,W
02154:  MOVWF  FE9
02156:  MOVLW  00
02158:  ADDWFC xB4,W
0215A:  MOVWF  FEA
0215C:  MOVLW  01
0215E:  ADDWF  FEF,W
02160:  MOVFF  6AC,FEA
02164:  MOVFF  6AB,FE9
02168:  MOVWF  FEF
....................    tobuff(smData[ch].cosQ, cosCnts);
0216A:  MOVF   x6C,W
0216C:  MULLW  0D
0216E:  MOVF   FF3,W
02170:  CLRF   xA8
02172:  MOVWF  xA7
02174:  MOVLW  03
02176:  ADDWF  xA7,W
02178:  MOVWF  01
0217A:  MOVLW  00
0217C:  ADDWFC xA8,W
0217E:  MOVWF  03
02180:  MOVF   01,W
02182:  ADDLW  BD
02184:  MOVWF  01
02186:  MOVLW  01
02188:  ADDWFC 03,F
0218A:  MOVFF  01,6A7
0218E:  MOVFF  03,6A8
02192:  MOVFF  03,FEA
02196:  MOVFF  01,FE9
0219A:  MOVFF  FEC,6AA
0219E:  MOVF   FED,F
021A0:  MOVFF  FEF,6A9
021A4:  MOVF   x6C,W
021A6:  MULLW  0D
021A8:  MOVF   FF3,W
021AA:  CLRF   xAC
021AC:  MOVWF  xAB
021AE:  MOVLW  03
021B0:  ADDWF  xAB,W
021B2:  MOVWF  01
021B4:  MOVLW  00
021B6:  ADDWFC xAC,W
021B8:  MOVWF  03
021BA:  MOVF   01,W
021BC:  ADDLW  BD
021BE:  MOVWF  01
021C0:  MOVLW  01
021C2:  ADDWFC 03,F
021C4:  MOVFF  01,6AB
021C8:  MOVFF  03,6AC
021CC:  MOVFF  03,FEA
021D0:  MOVFF  01,FE9
021D4:  MOVFF  FEC,6AE
021D8:  MOVF   FED,F
021DA:  MOVFF  FEF,6AD
021DE:  MOVFF  6AD,FE9
021E2:  MOVFF  6AE,FEA
021E6:  CLRF   xB1
021E8:  MOVFF  FEF,6B0
021EC:  CLRF   xB3
021EE:  MOVLW  04
021F0:  MOVWF  xB2
021F2:  MOVLB  0
021F4:  CALL   0802
021F8:  MOVFF  02,03
021FC:  MOVF   01,W
021FE:  ADDLW  02
02200:  MOVWF  01
02202:  MOVLW  00
02204:  ADDWFC 03,F
02206:  MOVF   01,W
02208:  MOVLB  6
0220A:  ADDWF  xA9,W
0220C:  MOVWF  FE9
0220E:  MOVF   xAA,W
02210:  ADDWFC 03,W
02212:  MOVWF  FEA
02214:  MOVFF  671,FEF
02218:  MOVFF  672,FEC
0221C:  MOVFF  673,FEC
02220:  MOVFF  674,FEC
02224:  MOVF   x6C,W
02226:  MULLW  0D
02228:  MOVF   FF3,W
0222A:  CLRF   xA8
0222C:  MOVWF  xA7
0222E:  MOVLW  03
02230:  ADDWF  xA7,W
02232:  MOVWF  01
02234:  MOVLW  00
02236:  ADDWFC xA8,W
02238:  MOVWF  03
0223A:  MOVF   01,W
0223C:  ADDLW  BD
0223E:  MOVWF  01
02240:  MOVLW  01
02242:  ADDWFC 03,F
02244:  MOVFF  01,6A7
02248:  MOVFF  03,6A8
0224C:  MOVFF  03,FEA
02250:  MOVFF  01,FE9
02254:  MOVFF  FEC,03
02258:  MOVF   FED,F
0225A:  MOVFF  FEF,01
0225E:  MOVFF  01,6AB
02262:  MOVFF  03,6AC
02266:  MOVF   x6C,W
02268:  MULLW  0D
0226A:  MOVF   FF3,W
0226C:  CLRF   xAE
0226E:  MOVWF  xAD
02270:  MOVLW  03
02272:  ADDWF  xAD,W
02274:  MOVWF  01
02276:  MOVLW  00
02278:  ADDWFC xAE,W
0227A:  MOVWF  03
0227C:  MOVF   01,W
0227E:  ADDLW  BD
02280:  MOVWF  01
02282:  MOVLW  01
02284:  ADDWFC 03,F
02286:  MOVFF  01,6AD
0228A:  MOVFF  03,6AE
0228E:  MOVFF  03,FEA
02292:  MOVFF  01,FE9
02296:  MOVFF  FEC,6B0
0229A:  MOVF   FED,F
0229C:  MOVFF  FEF,6AF
022A0:  MOVFF  6AF,FE9
022A4:  MOVFF  6B0,FEA
022A8:  MOVF   FEF,W
022AA:  SUBLW  04
022AC:  BNZ   22B2
022AE:  MOVLW  00
022B0:  BRA    22F8
022B2:  MOVF   x6C,W
022B4:  MULLW  0D
022B6:  MOVF   FF3,W
022B8:  CLRF   xB2
022BA:  MOVWF  xB1
022BC:  MOVLW  03
022BE:  ADDWF  xB1,W
022C0:  MOVWF  01
022C2:  MOVLW  00
022C4:  ADDWFC xB2,W
022C6:  MOVWF  03
022C8:  MOVF   01,W
022CA:  ADDLW  BD
022CC:  MOVWF  01
022CE:  MOVLW  01
022D0:  ADDWFC 03,F
022D2:  MOVFF  01,6B1
022D6:  MOVFF  03,6B2
022DA:  MOVFF  03,FEA
022DE:  MOVFF  01,FE9
022E2:  MOVFF  FEC,6B4
022E6:  MOVF   FED,F
022E8:  MOVFF  FEF,6B3
022EC:  MOVFF  6B3,FE9
022F0:  MOVFF  6B4,FEA
022F4:  MOVLW  01
022F6:  ADDWF  FEF,W
022F8:  MOVWF  xB5
022FA:  MOVFF  6AC,FEA
022FE:  MOVFF  6AB,FE9
02302:  MOVWF  FEF
02304:  MOVF   x6C,W
02306:  MULLW  0D
02308:  MOVF   FF3,W
0230A:  CLRF   xA8
0230C:  MOVWF  xA7
0230E:  MOVLW  03
02310:  ADDWF  xA7,W
02312:  MOVWF  01
02314:  MOVLW  00
02316:  ADDWFC xA8,W
02318:  MOVWF  03
0231A:  MOVF   01,W
0231C:  ADDLW  BD
0231E:  MOVWF  01
02320:  MOVLW  01
02322:  ADDWFC 03,F
02324:  MOVFF  01,6A7
02328:  MOVFF  03,6A8
0232C:  MOVFF  03,FEA
02330:  MOVFF  01,FE9
02334:  MOVFF  FEC,6AA
02338:  MOVF   FED,F
0233A:  MOVFF  FEF,6A9
0233E:  MOVFF  6A9,FE9
02342:  MOVFF  6AA,FEA
02346:  MOVFF  FEF,6AB
0234A:  MOVF   x6C,W
0234C:  MULLW  0D
0234E:  MOVF   FF3,W
02350:  CLRF   xAD
02352:  MOVWF  xAC
02354:  MOVLW  03
02356:  ADDWF  xAC,W
02358:  MOVWF  01
0235A:  MOVLW  00
0235C:  ADDWFC xAD,W
0235E:  MOVWF  03
02360:  MOVF   01,W
02362:  ADDLW  BD
02364:  MOVWF  01
02366:  MOVLW  01
02368:  ADDWFC 03,F
0236A:  MOVFF  01,6AC
0236E:  MOVFF  03,6AD
02372:  MOVFF  03,FEA
02376:  MOVFF  01,FE9
0237A:  MOVFF  FEC,6AF
0237E:  MOVF   FED,F
02380:  MOVFF  FEF,6AE
02384:  MOVLW  01
02386:  ADDWF  xAE,W
02388:  MOVWF  FE9
0238A:  MOVLW  00
0238C:  ADDWFC xAF,W
0238E:  MOVWF  FEA
02390:  MOVF   FEF,W
02392:  SUBWF  xAB,W
02394:  BNZ   2486
02396:  MOVF   x6C,W
02398:  MULLW  0D
0239A:  MOVF   FF3,W
0239C:  CLRF   xA8
0239E:  MOVWF  xA7
023A0:  MOVLW  03
023A2:  ADDWF  xA7,W
023A4:  MOVWF  01
023A6:  MOVLW  00
023A8:  ADDWFC xA8,W
023AA:  MOVWF  03
023AC:  MOVF   01,W
023AE:  ADDLW  BD
023B0:  MOVWF  01
023B2:  MOVLW  01
023B4:  ADDWFC 03,F
023B6:  MOVFF  01,6A7
023BA:  MOVFF  03,6A8
023BE:  MOVFF  03,FEA
023C2:  MOVFF  01,FE9
023C6:  MOVFF  FEC,6AA
023CA:  MOVF   FED,F
023CC:  MOVFF  FEF,6A9
023D0:  MOVLW  01
023D2:  ADDWF  xA9,W
023D4:  MOVWF  01
023D6:  MOVLW  00
023D8:  ADDWFC xAA,W
023DA:  MOVWF  03
023DC:  MOVFF  01,6AB
023E0:  MOVWF  xAC
023E2:  MOVF   x6C,W
023E4:  MULLW  0D
023E6:  MOVF   FF3,W
023E8:  CLRF   xAE
023EA:  MOVWF  xAD
023EC:  MOVLW  03
023EE:  ADDWF  xAD,W
023F0:  MOVWF  01
023F2:  MOVLW  00
023F4:  ADDWFC xAE,W
023F6:  MOVWF  03
023F8:  MOVF   01,W
023FA:  ADDLW  BD
023FC:  MOVWF  01
023FE:  MOVLW  01
02400:  ADDWFC 03,F
02402:  MOVFF  01,6AD
02406:  MOVFF  03,6AE
0240A:  MOVFF  03,FEA
0240E:  MOVFF  01,FE9
02412:  MOVFF  FEC,6B0
02416:  MOVF   FED,F
02418:  MOVFF  FEF,6AF
0241C:  MOVLW  01
0241E:  ADDWF  xAF,W
02420:  MOVWF  FE9
02422:  MOVLW  00
02424:  ADDWFC xB0,W
02426:  MOVWF  FEA
02428:  MOVF   FEF,W
0242A:  SUBLW  04
0242C:  BNZ   2432
0242E:  MOVLW  00
02430:  BRA    247C
02432:  MOVF   x6C,W
02434:  MULLW  0D
02436:  MOVF   FF3,W
02438:  CLRF   xB2
0243A:  MOVWF  xB1
0243C:  MOVLW  03
0243E:  ADDWF  xB1,W
02440:  MOVWF  01
02442:  MOVLW  00
02444:  ADDWFC xB2,W
02446:  MOVWF  03
02448:  MOVF   01,W
0244A:  ADDLW  BD
0244C:  MOVWF  01
0244E:  MOVLW  01
02450:  ADDWFC 03,F
02452:  MOVFF  01,6B1
02456:  MOVFF  03,6B2
0245A:  MOVFF  03,FEA
0245E:  MOVFF  01,FE9
02462:  MOVFF  FEC,6B4
02466:  MOVF   FED,F
02468:  MOVFF  FEF,6B3
0246C:  MOVLW  01
0246E:  ADDWF  xB3,W
02470:  MOVWF  FE9
02472:  MOVLW  00
02474:  ADDWFC xB4,W
02476:  MOVWF  FEA
02478:  MOVLW  01
0247A:  ADDWF  FEF,W
0247C:  MOVFF  6AC,FEA
02480:  MOVFF  6AB,FE9
02484:  MOVWF  FEF
....................    
....................    // copy queue contents out to buffer for qsorting
....................    for (int j=0; j<BUFFER_SIZE; j++){
02486:  CLRF   xA5
02488:  MOVF   xA5,W
0248A:  SUBLW  04
0248C:  BTFSS  FD8.0
0248E:  BRA    25E4
....................       iqmBufSin[j] = smData[ch].sinQ->buff[j];
02490:  MOVF   xA5,W
02492:  MULLW  04
02494:  MOVF   FF3,W
02496:  CLRF   03
02498:  ADDLW  75
0249A:  MOVWF  01
0249C:  MOVLW  06
0249E:  ADDWFC 03,F
024A0:  MOVFF  01,6A7
024A4:  MOVFF  03,6A8
024A8:  MOVF   x6C,W
024AA:  MULLW  0D
024AC:  MOVF   FF3,W
024AE:  CLRF   xAA
024B0:  MOVWF  xA9
024B2:  MOVLW  01
024B4:  ADDWF  xA9,W
024B6:  MOVWF  01
024B8:  MOVLW  00
024BA:  ADDWFC xAA,W
024BC:  MOVWF  03
024BE:  MOVF   01,W
024C0:  ADDLW  BD
024C2:  MOVWF  01
024C4:  MOVLW  01
024C6:  ADDWFC 03,F
024C8:  MOVFF  01,6A9
024CC:  MOVFF  03,6AA
024D0:  MOVFF  03,FEA
024D4:  MOVFF  01,FE9
024D8:  MOVFF  FEC,6AC
024DC:  MOVF   FED,F
024DE:  MOVFF  FEF,6AB
024E2:  CLRF   xB1
024E4:  MOVFF  6A5,6B0
024E8:  CLRF   xB3
024EA:  MOVLW  04
024EC:  MOVWF  xB2
024EE:  MOVLB  0
024F0:  CALL   0802
024F4:  MOVFF  02,03
024F8:  MOVF   01,W
024FA:  ADDLW  02
024FC:  MOVWF  01
024FE:  MOVLW  00
02500:  ADDWFC 03,F
02502:  MOVF   01,W
02504:  MOVLB  6
02506:  ADDWF  xAB,W
02508:  MOVWF  FE9
0250A:  MOVF   xAC,W
0250C:  ADDWFC 03,W
0250E:  MOVWF  FEA
02510:  MOVFF  FEF,00
02514:  MOVFF  FEC,01
02518:  MOVFF  FEC,02
0251C:  MOVFF  FEC,03
02520:  MOVFF  6A8,FEA
02524:  MOVFF  6A7,FE9
02528:  MOVFF  00,FEF
0252C:  MOVFF  01,FEC
02530:  MOVFF  02,FEC
02534:  MOVFF  03,FEC
....................       iqmBufCos[j] = smData[ch].cosQ->buff[j];
02538:  MOVF   xA5,W
0253A:  MULLW  04
0253C:  MOVF   FF3,W
0253E:  CLRF   03
02540:  ADDLW  89
02542:  MOVWF  01
02544:  MOVLW  06
02546:  ADDWFC 03,F
02548:  MOVFF  01,6A7
0254C:  MOVFF  03,6A8
02550:  MOVF   x6C,W
02552:  MULLW  0D
02554:  MOVF   FF3,W
02556:  CLRF   xAA
02558:  MOVWF  xA9
0255A:  MOVLW  03
0255C:  ADDWF  xA9,W
0255E:  MOVWF  01
02560:  MOVLW  00
02562:  ADDWFC xAA,W
02564:  MOVWF  03
02566:  MOVF   01,W
02568:  ADDLW  BD
0256A:  MOVWF  01
0256C:  MOVLW  01
0256E:  ADDWFC 03,F
02570:  MOVFF  01,6A9
02574:  MOVFF  03,6AA
02578:  MOVFF  03,FEA
0257C:  MOVFF  01,FE9
02580:  MOVFF  FEC,6AC
02584:  MOVF   FED,F
02586:  MOVFF  FEF,6AB
0258A:  CLRF   xB1
0258C:  MOVFF  6A5,6B0
02590:  CLRF   xB3
02592:  MOVLW  04
02594:  MOVWF  xB2
02596:  MOVLB  0
02598:  CALL   0802
0259C:  MOVFF  02,03
025A0:  MOVF   01,W
025A2:  ADDLW  02
025A4:  MOVWF  01
025A6:  MOVLW  00
025A8:  ADDWFC 03,F
025AA:  MOVF   01,W
025AC:  MOVLB  6
025AE:  ADDWF  xAB,W
025B0:  MOVWF  FE9
025B2:  MOVF   xAC,W
025B4:  ADDWFC 03,W
025B6:  MOVWF  FEA
025B8:  MOVFF  FEF,00
025BC:  MOVFF  FEC,01
025C0:  MOVFF  FEC,02
025C4:  MOVFF  FEC,03
025C8:  MOVFF  6A8,FEA
025CC:  MOVFF  6A7,FE9
025D0:  MOVFF  00,FEF
025D4:  MOVFF  01,FEC
025D8:  MOVFF  02,FEC
025DC:  MOVFF  03,FEC
025E0:  INCF   xA5,F
025E2:  BRA    2488
....................    }
....................    
....................    qsort(iqmBufSin, BUFFER_SIZE, sizeof(*iqmBufSin), compar);
025E4:  MOVLW  1B
025E6:  MOVWF  03
025E8:  MOVLW  F6
025EA:  MOVWF  xA7
025EC:  MOVFF  03,6A8
025F0:  MOVLW  06
025F2:  MOVWF  xAA
025F4:  MOVLW  75
025F6:  MOVWF  xA9
025F8:  MOVLW  05
025FA:  MOVWF  xAB
025FC:  MOVLW  01
025FE:  MOVWF  xAC
02600:  MOVFF  03,6AE
02604:  MOVFF  6A7,6AD
02608:  MOVLB  0
0260A:  CALL   1C2A
....................    qsort(iqmBufCos, BUFFER_SIZE, sizeof(*iqmBufCos), compar);
0260E:  MOVLW  1B
02610:  MOVWF  03
02612:  MOVLW  F6
02614:  MOVLB  6
02616:  MOVWF  xA7
02618:  MOVFF  03,6A8
0261C:  MOVLW  06
0261E:  MOVWF  xAA
02620:  MOVLW  89
02622:  MOVWF  xA9
02624:  MOVLW  05
02626:  MOVWF  xAB
02628:  MOVLW  01
0262A:  MOVWF  xAC
0262C:  MOVFF  03,6AE
02630:  MOVFF  6A7,6AD
02634:  MOVLB  0
02636:  CALL   1C2A
....................    
....................    for (int k=1; k<(BUFFER_SIZE-1); k++){
0263A:  MOVLW  01
0263C:  MOVLB  6
0263E:  MOVWF  xA6
02640:  MOVF   xA6,W
02642:  SUBLW  03
02644:  BNC   26AE
....................       sumSin+=iqmBufSin[k];
02646:  MOVF   xA6,W
02648:  MULLW  04
0264A:  MOVF   FF3,W
0264C:  CLRF   03
0264E:  ADDLW  75
02650:  MOVWF  FE9
02652:  MOVLW  06
02654:  ADDWFC 03,W
02656:  MOVWF  FEA
02658:  MOVFF  FEF,00
0265C:  MOVFF  FEC,01
02660:  MOVFF  FEC,02
02664:  MOVFF  FEC,03
02668:  MOVF   00,W
0266A:  ADDWF  x9D,F
0266C:  MOVF   01,W
0266E:  ADDWFC x9E,F
02670:  MOVF   02,W
02672:  ADDWFC x9F,F
02674:  MOVF   03,W
02676:  ADDWFC xA0,F
....................       sumCos+=iqmBufCos[k];
02678:  MOVF   xA6,W
0267A:  MULLW  04
0267C:  MOVF   FF3,W
0267E:  CLRF   03
02680:  ADDLW  89
02682:  MOVWF  FE9
02684:  MOVLW  06
02686:  ADDWFC 03,W
02688:  MOVWF  FEA
0268A:  MOVFF  FEF,00
0268E:  MOVFF  FEC,01
02692:  MOVFF  FEC,02
02696:  MOVFF  FEC,03
0269A:  MOVF   00,W
0269C:  ADDWF  xA1,F
0269E:  MOVF   01,W
026A0:  ADDWFC xA2,F
026A2:  MOVF   02,W
026A4:  ADDWFC xA3,F
026A6:  MOVF   03,W
026A8:  ADDWFC xA4,F
026AA:  INCF   xA6,F
026AC:  BRA    2640
....................    }
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
026AE:  MOVF   x6C,W
026B0:  MULLW  0D
026B2:  MOVF   FF3,W
026B4:  CLRF   xA8
026B6:  MOVWF  xA7
026B8:  MOVLW  05
026BA:  ADDWF  xA7,W
026BC:  MOVWF  01
026BE:  MOVLW  00
026C0:  ADDWFC xA8,W
026C2:  MOVWF  03
026C4:  MOVF   01,W
026C6:  ADDLW  BD
026C8:  MOVWF  FE9
026CA:  MOVLW  01
026CC:  ADDWFC 03,W
026CE:  MOVWF  FEA
026D0:  MOVFF  FEA,6AA
026D4:  MOVFF  FE9,6A9
026D8:  BCF    FD8.1
026DA:  MOVFF  6A0,6AE
026DE:  MOVFF  69F,6AD
026E2:  MOVFF  69E,6AC
026E6:  MOVFF  69D,6AB
026EA:  CLRF   xB2
026EC:  CLRF   xB1
026EE:  CLRF   xB0
026F0:  MOVLW  03
026F2:  MOVWF  xAF
026F4:  MOVLB  0
026F6:  CALL   1D52
026FA:  MOVFF  6AA,FEA
026FE:  MOVFF  6A9,FE9
02702:  MOVFF  00,FEF
02706:  MOVFF  01,FEC
0270A:  MOVFF  02,FEC
0270E:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
02712:  MOVLB  6
02714:  MOVF   x6C,W
02716:  MULLW  0D
02718:  MOVF   FF3,W
0271A:  CLRF   xA8
0271C:  MOVWF  xA7
0271E:  MOVLW  09
02720:  ADDWF  xA7,W
02722:  MOVWF  01
02724:  MOVLW  00
02726:  ADDWFC xA8,W
02728:  MOVWF  03
0272A:  MOVF   01,W
0272C:  ADDLW  BD
0272E:  MOVWF  FE9
02730:  MOVLW  01
02732:  ADDWFC 03,W
02734:  MOVWF  FEA
02736:  MOVFF  FEA,6AA
0273A:  MOVFF  FE9,6A9
0273E:  BCF    FD8.1
02740:  MOVFF  6A4,6AE
02744:  MOVFF  6A3,6AD
02748:  MOVFF  6A2,6AC
0274C:  MOVFF  6A1,6AB
02750:  CLRF   xB2
02752:  CLRF   xB1
02754:  CLRF   xB0
02756:  MOVLW  03
02758:  MOVWF  xAF
0275A:  MOVLB  0
0275C:  CALL   1D52
02760:  MOVFF  6AA,FEA
02764:  MOVFF  6A9,FE9
02768:  MOVFF  00,FEF
0276C:  MOVFF  01,FEC
02770:  MOVFF  02,FEC
02774:  MOVFF  03,FEC
02778:  GOTO   4FE0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
04F08:  MOVLB  6
04F0A:  CLRF   x67
04F0C:  CLRF   x66
04F0E:  CLRF   x65
04F10:  CLRF   x64
04F12:  CLRF   x6B
04F14:  CLRF   x6A
04F16:  CLRF   x69
04F18:  CLRF   x68
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04F1A:  MOVLB  1
04F1C:  MOVF   xD9,W
04F1E:  MULLW  0D
04F20:  MOVF   FF3,W
04F22:  MOVLB  6
04F24:  CLRF   x6D
04F26:  MOVWF  x6C
04F28:  MOVLW  BD
04F2A:  ADDWF  x6C,W
04F2C:  MOVWF  FE9
04F2E:  MOVLW  01
04F30:  ADDWFC x6D,W
04F32:  MOVWF  FEA
04F34:  BTFSC  FEF.1
04F36:  BRA    503C
04F38:  MOVLB  1
04F3A:  MOVF   xD9,W
04F3C:  MULLW  0D
04F3E:  MOVF   FF3,W
04F40:  MOVLB  6
04F42:  CLRF   x6F
04F44:  MOVWF  x6E
04F46:  MOVLW  BD
04F48:  ADDWF  x6E,W
04F4A:  MOVWF  FE9
04F4C:  MOVLW  01
04F4E:  ADDWFC x6F,W
04F50:  MOVWF  FEA
04F52:  BTFSS  FEF.0
04F54:  BRA    503C
....................       smData[ch].adcBusy = true;
04F56:  MOVLB  1
04F58:  MOVF   xD9,W
04F5A:  MULLW  0D
04F5C:  MOVF   FF3,W
04F5E:  MOVLB  6
04F60:  CLRF   x6D
04F62:  MOVWF  x6C
04F64:  MOVLW  BD
04F66:  ADDWF  x6C,W
04F68:  MOVWF  FE9
04F6A:  MOVLW  01
04F6C:  ADDWFC x6D,W
04F6E:  MOVWF  FEA
04F70:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04F72:  BCF    FD8.0
04F74:  MOVLB  1
04F76:  RLCF   xD9,W
04F78:  MOVLB  6
04F7A:  MOVWF  x6C
04F7C:  MOVWF  x76
04F7E:  MOVLB  0
04F80:  CALL   083C
04F84:  MOVFF  03,667
04F88:  MOVFF  02,666
04F8C:  MOVFF  01,665
04F90:  MOVFF  00,664
....................       cosNew = ads_read_data(ch*2+1);      
04F94:  BCF    FD8.0
04F96:  MOVLB  1
04F98:  RLCF   xD9,W
04F9A:  ADDLW  01
04F9C:  MOVLB  6
04F9E:  MOVWF  x6C
04FA0:  MOVWF  x76
04FA2:  MOVLB  0
04FA4:  CALL   083C
04FA8:  MOVFF  03,66B
04FAC:  MOVFF  02,66A
04FB0:  MOVFF  01,669
04FB4:  MOVFF  00,668
....................       
....................       iqm_ring_buffer(ch, sinNew, cosNew);
04FB8:  MOVFF  1D9,66C
04FBC:  MOVFF  667,670
04FC0:  MOVFF  666,66F
04FC4:  MOVFF  665,66E
04FC8:  MOVFF  664,66D
04FCC:  MOVFF  66B,674
04FD0:  MOVFF  66A,673
04FD4:  MOVFF  669,672
04FD8:  MOVFF  668,671
04FDC:  GOTO   1E3C
....................       
....................       sensor_process_data(ch);
04FE0:  MOVFF  1D9,66C
04FE4:  GOTO   41B6
....................       ch = !ch;
04FE8:  MOVLB  1
04FEA:  MOVF   xD9,F
04FEC:  BZ    4FF2
04FEE:  MOVLW  00
04FF0:  BRA    4FF4
04FF2:  MOVLW  01
04FF4:  MOVWF  xD9
....................       
....................       smData[!ch].dataReady = false;
04FF6:  MOVF   xD9,F
04FF8:  BZ    4FFE
04FFA:  MOVLW  00
04FFC:  BRA    5000
04FFE:  MOVLW  01
05000:  MULLW  0D
05002:  MOVF   FF3,W
05004:  MOVLB  6
05006:  CLRF   x6D
05008:  MOVWF  x6C
0500A:  MOVLW  BD
0500C:  ADDWF  x6C,W
0500E:  MOVWF  FE9
05010:  MOVLW  01
05012:  ADDWFC x6D,W
05014:  MOVWF  FEA
05016:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
05018:  MOVLB  1
0501A:  MOVF   xD9,F
0501C:  BZ    5022
0501E:  MOVLW  00
05020:  BRA    5024
05022:  MOVLW  01
05024:  MULLW  0D
05026:  MOVF   FF3,W
05028:  MOVLB  6
0502A:  CLRF   x6D
0502C:  MOVWF  x6C
0502E:  MOVLW  BD
05030:  ADDWF  x6C,W
05032:  MOVWF  FE9
05034:  MOVLW  01
05036:  ADDWFC x6D,W
05038:  MOVWF  FEA
0503A:  BCF    FEF.1
....................    }
0503C:  MOVLB  0
0503E:  GOTO   B082 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0088A:  MOVLB  6
0088C:  CLRF   x64
0088E:  CLRF   x65
00890:  CLRF   x66
00892:  CLRF   x67
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++)
00894:  CLRF   x68
00896:  MOVF   x68,W
00898:  SUBLW  03
0089A:  BNC   08D2
....................    {
....................       rc0=reg0config;
0089C:  MOVLW  30
0089E:  MOVWF  x64
....................       rc1=reg1config;
008A0:  MOVLW  10
008A2:  MOVWF  x65
....................       rc2=reg2config;
008A4:  MOVLW  30
008A6:  MOVWF  x66
....................       rc3=reg3config;
008A8:  CLRF   x67
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
008AA:  MOVFF  668,66B
008AE:  MOVFF  664,66C
008B2:  MOVFF  665,66D
008B6:  MOVFF  666,66E
008BA:  MOVFF  667,66F
008BE:  MOVLB  0
008C0:  BRA    074C
....................       delay_ms(100);
008C2:  MOVLW  64
008C4:  MOVLB  6
008C6:  MOVWF  x6C
008C8:  MOVLB  0
008CA:  RCALL  0438
008CC:  MOVLB  6
008CE:  INCF   x68,F
008D0:  BRA    0896
....................    }
....................    
.................... 
....................    clrbuff(smData[0].sinQ);
008D2:  MOVFF  1BE,01
008D6:  MOVFF  1BF,03
008DA:  MOVLW  01
008DC:  MOVLB  1
008DE:  ADDWF  xBE,W
008E0:  MOVWF  FE9
008E2:  MOVLW  00
008E4:  ADDWFC xBF,W
008E6:  MOVWF  FEA
008E8:  CLRF   FEF
008EA:  MOVLW  00
008EC:  MOVLB  6
008EE:  MOVFF  03,FEA
008F2:  MOVFF  01,FE9
008F6:  MOVWF  FEF
....................    clrbuff(smData[0].cosQ);
008F8:  MOVFF  1C0,01
008FC:  MOVFF  1C1,03
00900:  MOVLW  01
00902:  MOVLB  1
00904:  ADDWF  xC0,W
00906:  MOVWF  FE9
00908:  MOVLW  00
0090A:  ADDWFC xC1,W
0090C:  MOVWF  FEA
0090E:  CLRF   FEF
00910:  MOVLW  00
00912:  MOVLB  6
00914:  MOVFF  03,FEA
00918:  MOVFF  01,FE9
0091C:  MOVWF  FEF
....................    clrbuff(smData[1].sinQ);
0091E:  MOVFF  1CB,01
00922:  MOVFF  1CC,03
00926:  MOVLW  01
00928:  MOVLB  1
0092A:  ADDWF  xCB,W
0092C:  MOVWF  FE9
0092E:  MOVLW  00
00930:  ADDWFC xCC,W
00932:  MOVWF  FEA
00934:  CLRF   FEF
00936:  MOVLW  00
00938:  MOVLB  6
0093A:  MOVFF  03,FEA
0093E:  MOVFF  01,FE9
00942:  MOVWF  FEF
....................    clrbuff(smData[1].cosQ);
00944:  MOVFF  1CD,01
00948:  MOVFF  1CE,03
0094C:  MOVLW  01
0094E:  MOVLB  1
00950:  ADDWF  xCD,W
00952:  MOVWF  FE9
00954:  MOVLW  00
00956:  ADDWFC xCE,W
00958:  MOVWF  FEA
0095A:  CLRF   FEF
0095C:  MOVLW  00
0095E:  MOVLB  6
00960:  MOVFF  03,FEA
00964:  MOVFF  01,FE9
00968:  MOVWF  FEF
....................    smData[0].sinQ->in = 0;
0096A:  MOVLB  1
0096C:  MOVFF  1BE,FE9
00970:  MOVFF  1BF,FEA
00974:  CLRF   FEF
....................    smData[0].sinQ->out = 0;
00976:  MOVLW  01
00978:  ADDWF  xBE,W
0097A:  MOVWF  FE9
0097C:  MOVLW  00
0097E:  ADDWFC xBF,W
00980:  MOVWF  FEA
00982:  CLRF   FEF
....................    for (int i = 0; i < BUFFER_SIZE; i++){
00984:  MOVLB  6
00986:  CLRF   x69
00988:  MOVF   x69,W
0098A:  SUBLW  04
0098C:  BTFSS  FD8.0
0098E:  BRA    1028
....................       ads_start_conv_all();
00990:  MOVLB  0
00992:  BRA    07EA
....................       delay_ms(600);
00994:  MOVLW  03
00996:  MOVLB  6
00998:  MOVWF  x6B
0099A:  MOVLW  C8
0099C:  MOVWF  x6C
0099E:  MOVLB  0
009A0:  RCALL  0438
009A2:  MOVLB  6
009A4:  DECFSZ x6B,F
009A6:  BRA    099A
....................       for (int b = 0; b < 2; b++){
009A8:  CLRF   x6A
009AA:  MOVF   x6A,W
009AC:  SUBLW  01
009AE:  BTFSS  FD8.0
009B0:  BRA    1024
....................          tobuff(smData[b].sinQ, ads_read_data(b*2));
009B2:  MOVF   x6A,W
009B4:  MULLW  0D
009B6:  MOVF   FF3,W
009B8:  CLRF   x6C
009BA:  MOVWF  x6B
009BC:  MOVLW  01
009BE:  ADDWF  x6B,W
009C0:  MOVWF  01
009C2:  MOVLW  00
009C4:  ADDWFC x6C,W
009C6:  MOVWF  03
009C8:  MOVF   01,W
009CA:  ADDLW  BD
009CC:  MOVWF  01
009CE:  MOVLW  01
009D0:  ADDWFC 03,F
009D2:  MOVFF  01,66B
009D6:  MOVFF  03,66C
009DA:  MOVFF  03,FEA
009DE:  MOVFF  01,FE9
009E2:  MOVFF  FEC,66E
009E6:  MOVF   FED,F
009E8:  MOVFF  FEF,66D
009EC:  MOVF   x6A,W
009EE:  MULLW  0D
009F0:  MOVF   FF3,W
009F2:  CLRF   x70
009F4:  MOVWF  x6F
009F6:  MOVLW  01
009F8:  ADDWF  x6F,W
009FA:  MOVWF  01
009FC:  MOVLW  00
009FE:  ADDWFC x70,W
00A00:  MOVWF  03
00A02:  MOVF   01,W
00A04:  ADDLW  BD
00A06:  MOVWF  01
00A08:  MOVLW  01
00A0A:  ADDWFC 03,F
00A0C:  MOVFF  01,66F
00A10:  MOVFF  03,670
00A14:  MOVFF  03,FEA
00A18:  MOVFF  01,FE9
00A1C:  MOVFF  FEC,672
00A20:  MOVF   FED,F
00A22:  MOVFF  FEF,671
00A26:  MOVFF  671,FE9
00A2A:  MOVFF  672,FEA
00A2E:  CLRF   xB1
00A30:  MOVFF  FEF,6B0
00A34:  CLRF   xB3
00A36:  MOVLW  04
00A38:  MOVWF  xB2
00A3A:  MOVLB  0
00A3C:  RCALL  0802
00A3E:  MOVFF  02,03
00A42:  MOVF   01,W
00A44:  ADDLW  02
00A46:  MOVWF  01
00A48:  MOVLW  00
00A4A:  ADDWFC 03,F
00A4C:  MOVF   01,W
00A4E:  MOVLB  6
00A50:  ADDWF  x6D,W
00A52:  MOVWF  01
00A54:  MOVF   x6E,W
00A56:  ADDWFC 03,F
00A58:  MOVFF  01,673
00A5C:  MOVFF  03,674
00A60:  BCF    FD8.0
00A62:  RLCF   x6A,W
00A64:  MOVWF  x75
00A66:  MOVWF  x76
00A68:  MOVLB  0
00A6A:  RCALL  083C
00A6C:  MOVFF  674,FEA
00A70:  MOVFF  673,FE9
00A74:  MOVFF  00,FEF
00A78:  MOVFF  01,FEC
00A7C:  MOVFF  02,FEC
00A80:  MOVFF  03,FEC
00A84:  MOVLB  6
00A86:  MOVF   x6A,W
00A88:  MULLW  0D
00A8A:  MOVF   FF3,W
00A8C:  CLRF   x6C
00A8E:  MOVWF  x6B
00A90:  MOVLW  01
00A92:  ADDWF  x6B,W
00A94:  MOVWF  01
00A96:  MOVLW  00
00A98:  ADDWFC x6C,W
00A9A:  MOVWF  03
00A9C:  MOVF   01,W
00A9E:  ADDLW  BD
00AA0:  MOVWF  01
00AA2:  MOVLW  01
00AA4:  ADDWFC 03,F
00AA6:  MOVFF  01,66B
00AAA:  MOVFF  03,66C
00AAE:  MOVFF  03,FEA
00AB2:  MOVFF  01,FE9
00AB6:  MOVFF  FEC,03
00ABA:  MOVF   FED,F
00ABC:  MOVFF  FEF,01
00AC0:  MOVFF  01,66F
00AC4:  MOVFF  03,670
00AC8:  MOVF   x6A,W
00ACA:  MULLW  0D
00ACC:  MOVF   FF3,W
00ACE:  CLRF   x72
00AD0:  MOVWF  x71
00AD2:  MOVLW  01
00AD4:  ADDWF  x71,W
00AD6:  MOVWF  01
00AD8:  MOVLW  00
00ADA:  ADDWFC x72,W
00ADC:  MOVWF  03
00ADE:  MOVF   01,W
00AE0:  ADDLW  BD
00AE2:  MOVWF  01
00AE4:  MOVLW  01
00AE6:  ADDWFC 03,F
00AE8:  MOVFF  01,671
00AEC:  MOVFF  03,672
00AF0:  MOVFF  03,FEA
00AF4:  MOVFF  01,FE9
00AF8:  MOVFF  FEC,674
00AFC:  MOVF   FED,F
00AFE:  MOVFF  FEF,673
00B02:  MOVFF  673,FE9
00B06:  MOVFF  674,FEA
00B0A:  MOVF   FEF,W
00B0C:  SUBLW  04
00B0E:  BNZ   0B14
00B10:  MOVLW  00
00B12:  BRA    0B5A
00B14:  MOVF   x6A,W
00B16:  MULLW  0D
00B18:  MOVF   FF3,W
00B1A:  CLRF   x76
00B1C:  MOVWF  x75
00B1E:  MOVLW  01
00B20:  ADDWF  x75,W
00B22:  MOVWF  01
00B24:  MOVLW  00
00B26:  ADDWFC x76,W
00B28:  MOVWF  03
00B2A:  MOVF   01,W
00B2C:  ADDLW  BD
00B2E:  MOVWF  01
00B30:  MOVLW  01
00B32:  ADDWFC 03,F
00B34:  MOVFF  01,675
00B38:  MOVFF  03,676
00B3C:  MOVFF  03,FEA
00B40:  MOVFF  01,FE9
00B44:  MOVFF  FEC,678
00B48:  MOVF   FED,F
00B4A:  MOVFF  FEF,677
00B4E:  MOVFF  677,FE9
00B52:  MOVFF  678,FEA
00B56:  MOVLW  01
00B58:  ADDWF  FEF,W
00B5A:  MOVWF  x79
00B5C:  MOVFF  670,FEA
00B60:  MOVFF  66F,FE9
00B64:  MOVWF  FEF
00B66:  MOVF   x6A,W
00B68:  MULLW  0D
00B6A:  MOVF   FF3,W
00B6C:  CLRF   x6C
00B6E:  MOVWF  x6B
00B70:  MOVLW  01
00B72:  ADDWF  x6B,W
00B74:  MOVWF  01
00B76:  MOVLW  00
00B78:  ADDWFC x6C,W
00B7A:  MOVWF  03
00B7C:  MOVF   01,W
00B7E:  ADDLW  BD
00B80:  MOVWF  01
00B82:  MOVLW  01
00B84:  ADDWFC 03,F
00B86:  MOVFF  01,66B
00B8A:  MOVFF  03,66C
00B8E:  MOVFF  03,FEA
00B92:  MOVFF  01,FE9
00B96:  MOVFF  FEC,66E
00B9A:  MOVF   FED,F
00B9C:  MOVFF  FEF,66D
00BA0:  MOVFF  66D,FE9
00BA4:  MOVFF  66E,FEA
00BA8:  MOVFF  FEF,66F
00BAC:  MOVF   x6A,W
00BAE:  MULLW  0D
00BB0:  MOVF   FF3,W
00BB2:  CLRF   x71
00BB4:  MOVWF  x70
00BB6:  MOVLW  01
00BB8:  ADDWF  x70,W
00BBA:  MOVWF  01
00BBC:  MOVLW  00
00BBE:  ADDWFC x71,W
00BC0:  MOVWF  03
00BC2:  MOVF   01,W
00BC4:  ADDLW  BD
00BC6:  MOVWF  01
00BC8:  MOVLW  01
00BCA:  ADDWFC 03,F
00BCC:  MOVFF  01,670
00BD0:  MOVFF  03,671
00BD4:  MOVFF  03,FEA
00BD8:  MOVFF  01,FE9
00BDC:  MOVFF  FEC,673
00BE0:  MOVF   FED,F
00BE2:  MOVFF  FEF,672
00BE6:  MOVLW  01
00BE8:  ADDWF  x72,W
00BEA:  MOVWF  FE9
00BEC:  MOVLW  00
00BEE:  ADDWFC x73,W
00BF0:  MOVWF  FEA
00BF2:  MOVF   FEF,W
00BF4:  SUBWF  x6F,W
00BF6:  BNZ   0CE8
00BF8:  MOVF   x6A,W
00BFA:  MULLW  0D
00BFC:  MOVF   FF3,W
00BFE:  CLRF   x6C
00C00:  MOVWF  x6B
00C02:  MOVLW  01
00C04:  ADDWF  x6B,W
00C06:  MOVWF  01
00C08:  MOVLW  00
00C0A:  ADDWFC x6C,W
00C0C:  MOVWF  03
00C0E:  MOVF   01,W
00C10:  ADDLW  BD
00C12:  MOVWF  01
00C14:  MOVLW  01
00C16:  ADDWFC 03,F
00C18:  MOVFF  01,66B
00C1C:  MOVFF  03,66C
00C20:  MOVFF  03,FEA
00C24:  MOVFF  01,FE9
00C28:  MOVFF  FEC,66E
00C2C:  MOVF   FED,F
00C2E:  MOVFF  FEF,66D
00C32:  MOVLW  01
00C34:  ADDWF  x6D,W
00C36:  MOVWF  01
00C38:  MOVLW  00
00C3A:  ADDWFC x6E,W
00C3C:  MOVWF  03
00C3E:  MOVFF  01,66F
00C42:  MOVWF  x70
00C44:  MOVF   x6A,W
00C46:  MULLW  0D
00C48:  MOVF   FF3,W
00C4A:  CLRF   x72
00C4C:  MOVWF  x71
00C4E:  MOVLW  01
00C50:  ADDWF  x71,W
00C52:  MOVWF  01
00C54:  MOVLW  00
00C56:  ADDWFC x72,W
00C58:  MOVWF  03
00C5A:  MOVF   01,W
00C5C:  ADDLW  BD
00C5E:  MOVWF  01
00C60:  MOVLW  01
00C62:  ADDWFC 03,F
00C64:  MOVFF  01,671
00C68:  MOVFF  03,672
00C6C:  MOVFF  03,FEA
00C70:  MOVFF  01,FE9
00C74:  MOVFF  FEC,674
00C78:  MOVF   FED,F
00C7A:  MOVFF  FEF,673
00C7E:  MOVLW  01
00C80:  ADDWF  x73,W
00C82:  MOVWF  FE9
00C84:  MOVLW  00
00C86:  ADDWFC x74,W
00C88:  MOVWF  FEA
00C8A:  MOVF   FEF,W
00C8C:  SUBLW  04
00C8E:  BNZ   0C94
00C90:  MOVLW  00
00C92:  BRA    0CDE
00C94:  MOVF   x6A,W
00C96:  MULLW  0D
00C98:  MOVF   FF3,W
00C9A:  CLRF   x76
00C9C:  MOVWF  x75
00C9E:  MOVLW  01
00CA0:  ADDWF  x75,W
00CA2:  MOVWF  01
00CA4:  MOVLW  00
00CA6:  ADDWFC x76,W
00CA8:  MOVWF  03
00CAA:  MOVF   01,W
00CAC:  ADDLW  BD
00CAE:  MOVWF  01
00CB0:  MOVLW  01
00CB2:  ADDWFC 03,F
00CB4:  MOVFF  01,675
00CB8:  MOVFF  03,676
00CBC:  MOVFF  03,FEA
00CC0:  MOVFF  01,FE9
00CC4:  MOVFF  FEC,678
00CC8:  MOVF   FED,F
00CCA:  MOVFF  FEF,677
00CCE:  MOVLW  01
00CD0:  ADDWF  x77,W
00CD2:  MOVWF  FE9
00CD4:  MOVLW  00
00CD6:  ADDWFC x78,W
00CD8:  MOVWF  FEA
00CDA:  MOVLW  01
00CDC:  ADDWF  FEF,W
00CDE:  MOVFF  670,FEA
00CE2:  MOVFF  66F,FE9
00CE6:  MOVWF  FEF
....................          tobuff(smData[b].cosQ, ads_read_data(b*2+1));      
00CE8:  MOVF   x6A,W
00CEA:  MULLW  0D
00CEC:  MOVF   FF3,W
00CEE:  CLRF   x6C
00CF0:  MOVWF  x6B
00CF2:  MOVLW  03
00CF4:  ADDWF  x6B,W
00CF6:  MOVWF  01
00CF8:  MOVLW  00
00CFA:  ADDWFC x6C,W
00CFC:  MOVWF  03
00CFE:  MOVF   01,W
00D00:  ADDLW  BD
00D02:  MOVWF  01
00D04:  MOVLW  01
00D06:  ADDWFC 03,F
00D08:  MOVFF  01,66B
00D0C:  MOVFF  03,66C
00D10:  MOVFF  03,FEA
00D14:  MOVFF  01,FE9
00D18:  MOVFF  FEC,66E
00D1C:  MOVF   FED,F
00D1E:  MOVFF  FEF,66D
00D22:  MOVF   x6A,W
00D24:  MULLW  0D
00D26:  MOVF   FF3,W
00D28:  CLRF   x70
00D2A:  MOVWF  x6F
00D2C:  MOVLW  03
00D2E:  ADDWF  x6F,W
00D30:  MOVWF  01
00D32:  MOVLW  00
00D34:  ADDWFC x70,W
00D36:  MOVWF  03
00D38:  MOVF   01,W
00D3A:  ADDLW  BD
00D3C:  MOVWF  01
00D3E:  MOVLW  01
00D40:  ADDWFC 03,F
00D42:  MOVFF  01,66F
00D46:  MOVFF  03,670
00D4A:  MOVFF  03,FEA
00D4E:  MOVFF  01,FE9
00D52:  MOVFF  FEC,672
00D56:  MOVF   FED,F
00D58:  MOVFF  FEF,671
00D5C:  MOVFF  671,FE9
00D60:  MOVFF  672,FEA
00D64:  CLRF   xB1
00D66:  MOVFF  FEF,6B0
00D6A:  CLRF   xB3
00D6C:  MOVLW  04
00D6E:  MOVWF  xB2
00D70:  MOVLB  0
00D72:  RCALL  0802
00D74:  MOVFF  02,03
00D78:  MOVF   01,W
00D7A:  ADDLW  02
00D7C:  MOVWF  01
00D7E:  MOVLW  00
00D80:  ADDWFC 03,F
00D82:  MOVF   01,W
00D84:  MOVLB  6
00D86:  ADDWF  x6D,W
00D88:  MOVWF  01
00D8A:  MOVF   x6E,W
00D8C:  ADDWFC 03,F
00D8E:  MOVFF  01,673
00D92:  MOVFF  03,674
00D96:  BCF    FD8.0
00D98:  RLCF   x6A,W
00D9A:  ADDLW  01
00D9C:  MOVWF  x75
00D9E:  MOVWF  x76
00DA0:  MOVLB  0
00DA2:  RCALL  083C
00DA4:  MOVFF  674,FEA
00DA8:  MOVFF  673,FE9
00DAC:  MOVFF  00,FEF
00DB0:  MOVFF  01,FEC
00DB4:  MOVFF  02,FEC
00DB8:  MOVFF  03,FEC
00DBC:  MOVLB  6
00DBE:  MOVF   x6A,W
00DC0:  MULLW  0D
00DC2:  MOVF   FF3,W
00DC4:  CLRF   x6C
00DC6:  MOVWF  x6B
00DC8:  MOVLW  03
00DCA:  ADDWF  x6B,W
00DCC:  MOVWF  01
00DCE:  MOVLW  00
00DD0:  ADDWFC x6C,W
00DD2:  MOVWF  03
00DD4:  MOVF   01,W
00DD6:  ADDLW  BD
00DD8:  MOVWF  01
00DDA:  MOVLW  01
00DDC:  ADDWFC 03,F
00DDE:  MOVFF  01,66B
00DE2:  MOVFF  03,66C
00DE6:  MOVFF  03,FEA
00DEA:  MOVFF  01,FE9
00DEE:  MOVFF  FEC,03
00DF2:  MOVF   FED,F
00DF4:  MOVFF  FEF,01
00DF8:  MOVFF  01,66F
00DFC:  MOVFF  03,670
00E00:  MOVF   x6A,W
00E02:  MULLW  0D
00E04:  MOVF   FF3,W
00E06:  CLRF   x72
00E08:  MOVWF  x71
00E0A:  MOVLW  03
00E0C:  ADDWF  x71,W
00E0E:  MOVWF  01
00E10:  MOVLW  00
00E12:  ADDWFC x72,W
00E14:  MOVWF  03
00E16:  MOVF   01,W
00E18:  ADDLW  BD
00E1A:  MOVWF  01
00E1C:  MOVLW  01
00E1E:  ADDWFC 03,F
00E20:  MOVFF  01,671
00E24:  MOVFF  03,672
00E28:  MOVFF  03,FEA
00E2C:  MOVFF  01,FE9
00E30:  MOVFF  FEC,674
00E34:  MOVF   FED,F
00E36:  MOVFF  FEF,673
00E3A:  MOVFF  673,FE9
00E3E:  MOVFF  674,FEA
00E42:  MOVF   FEF,W
00E44:  SUBLW  04
00E46:  BNZ   0E4C
00E48:  MOVLW  00
00E4A:  BRA    0E92
00E4C:  MOVF   x6A,W
00E4E:  MULLW  0D
00E50:  MOVF   FF3,W
00E52:  CLRF   x76
00E54:  MOVWF  x75
00E56:  MOVLW  03
00E58:  ADDWF  x75,W
00E5A:  MOVWF  01
00E5C:  MOVLW  00
00E5E:  ADDWFC x76,W
00E60:  MOVWF  03
00E62:  MOVF   01,W
00E64:  ADDLW  BD
00E66:  MOVWF  01
00E68:  MOVLW  01
00E6A:  ADDWFC 03,F
00E6C:  MOVFF  01,675
00E70:  MOVFF  03,676
00E74:  MOVFF  03,FEA
00E78:  MOVFF  01,FE9
00E7C:  MOVFF  FEC,678
00E80:  MOVF   FED,F
00E82:  MOVFF  FEF,677
00E86:  MOVFF  677,FE9
00E8A:  MOVFF  678,FEA
00E8E:  MOVLW  01
00E90:  ADDWF  FEF,W
00E92:  MOVWF  x79
00E94:  MOVFF  670,FEA
00E98:  MOVFF  66F,FE9
00E9C:  MOVWF  FEF
00E9E:  MOVF   x6A,W
00EA0:  MULLW  0D
00EA2:  MOVF   FF3,W
00EA4:  CLRF   x6C
00EA6:  MOVWF  x6B
00EA8:  MOVLW  03
00EAA:  ADDWF  x6B,W
00EAC:  MOVWF  01
00EAE:  MOVLW  00
00EB0:  ADDWFC x6C,W
00EB2:  MOVWF  03
00EB4:  MOVF   01,W
00EB6:  ADDLW  BD
00EB8:  MOVWF  01
00EBA:  MOVLW  01
00EBC:  ADDWFC 03,F
00EBE:  MOVFF  01,66B
00EC2:  MOVFF  03,66C
00EC6:  MOVFF  03,FEA
00ECA:  MOVFF  01,FE9
00ECE:  MOVFF  FEC,66E
00ED2:  MOVF   FED,F
00ED4:  MOVFF  FEF,66D
00ED8:  MOVFF  66D,FE9
00EDC:  MOVFF  66E,FEA
00EE0:  MOVFF  FEF,66F
00EE4:  MOVF   x6A,W
00EE6:  MULLW  0D
00EE8:  MOVF   FF3,W
00EEA:  CLRF   x71
00EEC:  MOVWF  x70
00EEE:  MOVLW  03
00EF0:  ADDWF  x70,W
00EF2:  MOVWF  01
00EF4:  MOVLW  00
00EF6:  ADDWFC x71,W
00EF8:  MOVWF  03
00EFA:  MOVF   01,W
00EFC:  ADDLW  BD
00EFE:  MOVWF  01
00F00:  MOVLW  01
00F02:  ADDWFC 03,F
00F04:  MOVFF  01,670
00F08:  MOVFF  03,671
00F0C:  MOVFF  03,FEA
00F10:  MOVFF  01,FE9
00F14:  MOVFF  FEC,673
00F18:  MOVF   FED,F
00F1A:  MOVFF  FEF,672
00F1E:  MOVLW  01
00F20:  ADDWF  x72,W
00F22:  MOVWF  FE9
00F24:  MOVLW  00
00F26:  ADDWFC x73,W
00F28:  MOVWF  FEA
00F2A:  MOVF   FEF,W
00F2C:  SUBWF  x6F,W
00F2E:  BNZ   1020
00F30:  MOVF   x6A,W
00F32:  MULLW  0D
00F34:  MOVF   FF3,W
00F36:  CLRF   x6C
00F38:  MOVWF  x6B
00F3A:  MOVLW  03
00F3C:  ADDWF  x6B,W
00F3E:  MOVWF  01
00F40:  MOVLW  00
00F42:  ADDWFC x6C,W
00F44:  MOVWF  03
00F46:  MOVF   01,W
00F48:  ADDLW  BD
00F4A:  MOVWF  01
00F4C:  MOVLW  01
00F4E:  ADDWFC 03,F
00F50:  MOVFF  01,66B
00F54:  MOVFF  03,66C
00F58:  MOVFF  03,FEA
00F5C:  MOVFF  01,FE9
00F60:  MOVFF  FEC,66E
00F64:  MOVF   FED,F
00F66:  MOVFF  FEF,66D
00F6A:  MOVLW  01
00F6C:  ADDWF  x6D,W
00F6E:  MOVWF  01
00F70:  MOVLW  00
00F72:  ADDWFC x6E,W
00F74:  MOVWF  03
00F76:  MOVFF  01,66F
00F7A:  MOVWF  x70
00F7C:  MOVF   x6A,W
00F7E:  MULLW  0D
00F80:  MOVF   FF3,W
00F82:  CLRF   x72
00F84:  MOVWF  x71
00F86:  MOVLW  03
00F88:  ADDWF  x71,W
00F8A:  MOVWF  01
00F8C:  MOVLW  00
00F8E:  ADDWFC x72,W
00F90:  MOVWF  03
00F92:  MOVF   01,W
00F94:  ADDLW  BD
00F96:  MOVWF  01
00F98:  MOVLW  01
00F9A:  ADDWFC 03,F
00F9C:  MOVFF  01,671
00FA0:  MOVFF  03,672
00FA4:  MOVFF  03,FEA
00FA8:  MOVFF  01,FE9
00FAC:  MOVFF  FEC,674
00FB0:  MOVF   FED,F
00FB2:  MOVFF  FEF,673
00FB6:  MOVLW  01
00FB8:  ADDWF  x73,W
00FBA:  MOVWF  FE9
00FBC:  MOVLW  00
00FBE:  ADDWFC x74,W
00FC0:  MOVWF  FEA
00FC2:  MOVF   FEF,W
00FC4:  SUBLW  04
00FC6:  BNZ   0FCC
00FC8:  MOVLW  00
00FCA:  BRA    1016
00FCC:  MOVF   x6A,W
00FCE:  MULLW  0D
00FD0:  MOVF   FF3,W
00FD2:  CLRF   x76
00FD4:  MOVWF  x75
00FD6:  MOVLW  03
00FD8:  ADDWF  x75,W
00FDA:  MOVWF  01
00FDC:  MOVLW  00
00FDE:  ADDWFC x76,W
00FE0:  MOVWF  03
00FE2:  MOVF   01,W
00FE4:  ADDLW  BD
00FE6:  MOVWF  01
00FE8:  MOVLW  01
00FEA:  ADDWFC 03,F
00FEC:  MOVFF  01,675
00FF0:  MOVFF  03,676
00FF4:  MOVFF  03,FEA
00FF8:  MOVFF  01,FE9
00FFC:  MOVFF  FEC,678
01000:  MOVF   FED,F
01002:  MOVFF  FEF,677
01006:  MOVLW  01
01008:  ADDWF  x77,W
0100A:  MOVWF  FE9
0100C:  MOVLW  00
0100E:  ADDWFC x78,W
01010:  MOVWF  FEA
01012:  MOVLW  01
01014:  ADDWF  FEF,W
01016:  MOVFF  670,FEA
0101A:  MOVFF  66F,FE9
0101E:  MOVWF  FEF
01020:  INCF   x6A,F
01022:  BRA    09AA
....................       }
01024:  INCF   x69,F
01026:  BRA    0988
....................    }
01028:  MOVLB  0
0102A:  GOTO   1092 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0102E:  MOVLW  00
01030:  MOVLB  F
01032:  MOVWF  x53
01034:  MOVLW  40
01036:  MOVWF  x0C
01038:  MOVLW  00
0103A:  MOVWF  x14
0103C:  MOVLW  03
0103E:  MOVWF  x1C
01040:  MOVLW  0F
01042:  MOVWF  x21
01044:  MOVLW  00
01046:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
01048:  MOVLW  08
0104A:  MOVWF  x55
0104C:  CLRF   x56
0104E:  CLRF   x52
01050:  SETF   x57
01052:  CLRF   F61
01054:  MOVLW  94
01056:  MOVWF  x5B
....................    output_high(EN_EXC);
01058:  MOVLW  E8
0105A:  MOVWF  F8B
0105C:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
0105E:  MOVF   x5A,W
01060:  ANDLW  3F
01062:  MOVWF  01
01064:  MOVLW  06
01066:  MOVWF  x5A
01068:  BTFSS  x5B.7
0106A:  BRA    107A
0106C:  MOVF   01,W
0106E:  SUBLW  06
01070:  BZ    107A
01072:  BSF    x5B.0
01074:  NOP   
01076:  BTFSC  x5B.0
01078:  BRA    1076
....................    delay_ms(10);
0107A:  MOVLW  0A
0107C:  MOVLB  6
0107E:  MOVWF  x6C
01080:  MOVLB  0
01082:  CALL   0438
....................    read_adc(ADC_START_ONLY);
01086:  MOVLB  F
01088:  BSF    x5B.0
0108A:  NOP   
....................    setup_external_ADCs();
0108C:  MOVLB  0
0108E:  GOTO   088A
....................    intTimeoutReg = sensorSampleRate;
01092:  MOVLB  1
01094:  CLRF   x64
01096:  MOVLW  32
01098:  MOVWF  x63
0109A:  MOVLB  0
0109C:  GOTO   B06A (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
0511C:  MOVLB  6
0511E:  MOVF   x68,W
05120:  MULLW  20
05122:  MOVF   FF3,W
05124:  CLRF   x76
05126:  MOVWF  x75
05128:  MOVLW  0C
0512A:  ADDWF  x75,W
0512C:  MOVWF  01
0512E:  MOVLW  00
05130:  ADDWFC x76,W
05132:  MOVWF  03
05134:  MOVF   01,W
05136:  ADDLW  20
05138:  MOVWF  FE9
0513A:  MOVLW  00
0513C:  ADDWFC 03,W
0513E:  MOVWF  FEA
05140:  MOVFF  FEF,6B3
05144:  MOVFF  FEC,6B4
05148:  MOVFF  FEC,6B5
0514C:  MOVFF  FEC,6B6
05150:  MOVF   x68,W
05152:  MULLW  20
05154:  MOVF   FF3,W
05156:  CLRF   x7A
05158:  MOVWF  x79
0515A:  MOVLW  10
0515C:  ADDWF  x79,W
0515E:  MOVWF  01
05160:  MOVLW  00
05162:  ADDWFC x7A,W
05164:  MOVWF  03
05166:  MOVF   01,W
05168:  ADDLW  20
0516A:  MOVWF  FE9
0516C:  MOVLW  00
0516E:  ADDWFC 03,W
05170:  MOVWF  FEA
05172:  MOVFF  FEF,6B7
05176:  MOVFF  FEC,01
0517A:  MOVFF  FEC,02
0517E:  MOVFF  FEC,03
05182:  MOVFF  FEA,67A
05186:  MOVFF  FE9,679
0518A:  BSF    FD8.1
0518C:  MOVFF  03,6BA
05190:  MOVFF  02,6B9
05194:  MOVFF  01,6B8
05198:  MOVLB  0
0519A:  CALL   1400
0519E:  MOVFF  67A,FEA
051A2:  MOVFF  679,FE9
051A6:  MOVFF  03,66C
051AA:  MOVFF  02,66B
051AE:  MOVFF  01,66A
051B2:  MOVFF  00,669
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
051B6:  MOVLB  6
051B8:  MOVF   x68,W
051BA:  MULLW  20
051BC:  MOVF   FF3,W
051BE:  CLRF   x76
051C0:  MOVWF  x75
051C2:  MOVLW  1C
051C4:  ADDWF  x75,W
051C6:  MOVWF  01
051C8:  MOVLW  00
051CA:  ADDWFC x76,W
051CC:  MOVWF  03
051CE:  MOVF   01,W
051D0:  ADDLW  20
051D2:  MOVWF  01
051D4:  MOVLW  00
051D6:  ADDWFC 03,F
051D8:  MOVFF  01,675
051DC:  MOVFF  03,676
051E0:  MOVFF  03,FEA
051E4:  MOVFF  01,FE9
051E8:  MOVFF  FEF,677
051EC:  MOVFF  FEC,678
051F0:  MOVFF  FEC,679
051F4:  MOVFF  FEC,67A
051F8:  MOVF   x68,W
051FA:  MULLW  20
051FC:  MOVF   FF3,W
051FE:  CLRF   x7C
05200:  MOVWF  x7B
05202:  MOVLW  04
05204:  ADDWF  x7B,W
05206:  MOVWF  01
05208:  MOVLW  00
0520A:  ADDWFC x7C,W
0520C:  MOVWF  03
0520E:  MOVF   01,W
05210:  ADDLW  20
05212:  MOVWF  FE9
05214:  MOVLW  00
05216:  ADDWFC 03,W
05218:  MOVWF  FEA
0521A:  MOVFF  FEF,6B8
0521E:  MOVFF  FEC,01
05222:  MOVFF  FEC,02
05226:  MOVFF  FEC,03
0522A:  MOVFF  66C,6B7
0522E:  MOVFF  66B,6B6
05232:  MOVFF  66A,6B5
05236:  MOVFF  669,6B4
0523A:  MOVFF  03,6BB
0523E:  MOVFF  02,6BA
05242:  MOVFF  01,6B9
05246:  MOVLB  0
05248:  CALL   130A
0524C:  BCF    FD8.1
0524E:  MOVFF  67A,6B6
05252:  MOVFF  679,6B5
05256:  MOVFF  678,6B4
0525A:  MOVFF  677,6B3
0525E:  MOVFF  03,6BA
05262:  MOVFF  02,6B9
05266:  MOVFF  01,6B8
0526A:  MOVFF  00,6B7
0526E:  CALL   1400
05272:  MOVFF  676,FEA
05276:  MOVFF  675,FE9
0527A:  MOVFF  00,FEF
0527E:  MOVFF  01,FEC
05282:  MOVFF  02,FEC
05286:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
0528A:  MOVLB  6
0528C:  MOVF   x68,W
0528E:  MULLW  20
05290:  MOVF   FF3,W
05292:  CLRF   x76
05294:  MOVWF  x75
05296:  MOVLW  1C
05298:  ADDWF  x75,W
0529A:  MOVWF  01
0529C:  MOVLW  00
0529E:  ADDWFC x76,W
052A0:  MOVWF  03
052A2:  MOVF   01,W
052A4:  ADDLW  20
052A6:  MOVWF  FE9
052A8:  MOVLW  00
052AA:  ADDWFC 03,W
052AC:  MOVWF  FEA
052AE:  MOVFF  FEF,6B3
052B2:  MOVFF  FEC,676
052B6:  MOVFF  FEC,6B5
052BA:  MOVFF  FEC,6B6
052BE:  CLRF   xB2
052C0:  CLRF   xB1
052C2:  MOVLW  7C
052C4:  MOVWF  xB0
052C6:  MOVLW  84
052C8:  MOVWF  xAF
052CA:  MOVFF  676,6B4
052CE:  MOVLB  0
052D0:  CALL   27D6
052D4:  BNC   5308
052D6:  MOVLB  6
052D8:  MOVF   x68,W
052DA:  MULLW  20
052DC:  MOVF   FF3,W
052DE:  CLRF   x76
052E0:  MOVWF  x75
052E2:  MOVLW  1C
052E4:  ADDWF  x75,W
052E6:  MOVWF  01
052E8:  MOVLW  00
052EA:  ADDWFC x76,W
052EC:  MOVWF  03
052EE:  MOVF   01,W
052F0:  ADDLW  20
052F2:  MOVWF  FE9
052F4:  MOVLW  00
052F6:  ADDWFC 03,W
052F8:  MOVWF  FEA
052FA:  MOVLW  84
052FC:  MOVWF  FEF
052FE:  MOVLW  7C
05300:  MOVWF  FEC
05302:  CLRF   FEC
05304:  CLRF   FEC
05306:  BRA    5384
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
05308:  MOVLB  6
0530A:  MOVF   x68,W
0530C:  MULLW  20
0530E:  MOVF   FF3,W
05310:  CLRF   x76
05312:  MOVWF  x75
05314:  MOVLW  1C
05316:  ADDWF  x75,W
05318:  MOVWF  01
0531A:  MOVLW  00
0531C:  ADDWFC x76,W
0531E:  MOVWF  03
05320:  MOVF   01,W
05322:  ADDLW  20
05324:  MOVWF  FE9
05326:  MOVLW  00
05328:  ADDWFC 03,W
0532A:  MOVWF  FEA
0532C:  MOVFF  FEF,6AF
05330:  MOVFF  FEC,676
05334:  MOVFF  FEC,6B1
05338:  MOVFF  FEC,6B2
0533C:  MOVFF  676,6B0
05340:  CLRF   xB6
05342:  CLRF   xB5
05344:  MOVLW  FC
05346:  MOVWF  xB4
05348:  MOVLW  84
0534A:  MOVWF  xB3
0534C:  MOVLB  0
0534E:  CALL   27D6
05352:  BNC   5386
05354:  MOVLB  6
05356:  MOVF   x68,W
05358:  MULLW  20
0535A:  MOVF   FF3,W
0535C:  CLRF   x76
0535E:  MOVWF  x75
05360:  MOVLW  1C
05362:  ADDWF  x75,W
05364:  MOVWF  01
05366:  MOVLW  00
05368:  ADDWFC x76,W
0536A:  MOVWF  03
0536C:  MOVF   01,W
0536E:  ADDLW  20
05370:  MOVWF  FE9
05372:  MOVLW  00
05374:  ADDWFC 03,W
05376:  MOVWF  FEA
05378:  MOVLW  84
0537A:  MOVWF  FEF
0537C:  MOVLW  FC
0537E:  MOVWF  FEC
05380:  CLRF   FEC
05382:  CLRF   FEC
05384:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
05386:  MOVLB  6
05388:  MOVF   x68,W
0538A:  MULLW  20
0538C:  MOVF   FF3,W
0538E:  CLRF   x76
05390:  MOVWF  x75
05392:  MOVLW  20
05394:  ADDWF  x75,W
05396:  MOVWF  FE9
05398:  MOVLW  00
0539A:  ADDWFC x76,W
0539C:  MOVWF  FEA
0539E:  MOVFF  FEF,6B8
053A2:  MOVFF  FEC,01
053A6:  MOVFF  FEC,02
053AA:  MOVFF  FEC,03
053AE:  MOVFF  66C,6B7
053B2:  MOVFF  66B,6B6
053B6:  MOVFF  66A,6B5
053BA:  MOVFF  669,6B4
053BE:  MOVFF  03,6BB
053C2:  MOVFF  02,6BA
053C6:  MOVFF  01,6B9
053CA:  MOVLB  0
053CC:  CALL   130A
053D0:  MOVFF  03,670
053D4:  MOVFF  02,66F
053D8:  MOVFF  01,66E
053DC:  MOVFF  00,66D
053E0:  MOVLB  6
053E2:  MOVF   x68,W
053E4:  MULLW  20
053E6:  MOVF   FF3,W
053E8:  CLRF   x78
053EA:  MOVWF  x77
053EC:  MOVLW  08
053EE:  ADDWF  x77,W
053F0:  MOVWF  01
053F2:  MOVLW  00
053F4:  ADDWFC x78,W
053F6:  MOVWF  03
053F8:  MOVF   01,W
053FA:  ADDLW  20
053FC:  MOVWF  FE9
053FE:  MOVLW  00
05400:  ADDWFC 03,W
05402:  MOVWF  FEA
05404:  MOVFF  FEF,677
05408:  MOVFF  FEC,678
0540C:  MOVFF  FEC,679
05410:  MOVFF  FEC,67A
05414:  MOVF   x68,W
05416:  MULLW  20
05418:  MOVF   FF3,W
0541A:  CLRF   x7C
0541C:  MOVWF  x7B
0541E:  MOVLW  10
05420:  ADDWF  x7B,W
05422:  MOVWF  01
05424:  MOVLW  00
05426:  ADDWFC x7C,W
05428:  MOVWF  03
0542A:  MOVF   01,W
0542C:  ADDLW  20
0542E:  MOVWF  FE9
05430:  MOVLW  00
05432:  ADDWFC 03,W
05434:  MOVWF  FEA
05436:  MOVFF  FEF,6B3
0543A:  MOVFF  FEC,6B4
0543E:  MOVFF  FEC,6B5
05442:  MOVFF  FEC,6B6
05446:  MOVF   x68,W
05448:  MULLW  20
0544A:  MOVF   FF3,W
0544C:  CLRF   x80
0544E:  MOVWF  x7F
05450:  MOVLW  14
05452:  ADDWF  x7F,W
05454:  MOVWF  01
05456:  MOVLW  00
05458:  ADDWFC x80,W
0545A:  MOVWF  03
0545C:  MOVF   01,W
0545E:  ADDLW  20
05460:  MOVWF  FE9
05462:  MOVLW  00
05464:  ADDWFC 03,W
05466:  MOVWF  FEA
05468:  MOVFF  FEF,6B7
0546C:  MOVFF  FEC,01
05470:  MOVFF  FEC,02
05474:  MOVFF  FEC,03
05478:  MOVFF  FEA,680
0547C:  MOVFF  FE9,67F
05480:  BSF    FD8.1
05482:  MOVFF  03,6BA
05486:  MOVFF  02,6B9
0548A:  MOVFF  01,6B8
0548E:  MOVLB  0
05490:  CALL   1400
05494:  MOVFF  680,FEA
05498:  MOVFF  67F,FE9
0549C:  MOVFF  67A,6B7
054A0:  MOVFF  679,6B6
054A4:  MOVFF  678,6B5
054A8:  MOVFF  677,6B4
054AC:  MOVFF  03,6BB
054B0:  MOVFF  02,6BA
054B4:  MOVFF  01,6B9
054B8:  MOVFF  00,6B8
054BC:  CALL   130A
054C0:  MOVFF  03,674
054C4:  MOVFF  02,673
054C8:  MOVFF  01,672
054CC:  MOVFF  00,671
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
054D0:  MOVLB  6
054D2:  MOVF   x68,W
054D4:  MULLW  20
054D6:  MOVF   FF3,W
054D8:  CLRF   x76
054DA:  MOVWF  x75
054DC:  MOVLW  18
054DE:  ADDWF  x75,W
054E0:  MOVWF  01
054E2:  MOVLW  00
054E4:  ADDWFC x76,W
054E6:  MOVWF  03
054E8:  MOVF   01,W
054EA:  ADDLW  20
054EC:  MOVWF  01
054EE:  MOVLW  00
054F0:  ADDWFC 03,F
054F2:  MOVFF  01,675
054F6:  MOVFF  03,676
054FA:  MOVF   x68,W
054FC:  MULLW  20
054FE:  MOVF   FF3,W
05500:  CLRF   x78
05502:  MOVWF  x77
05504:  MOVLW  1C
05506:  ADDWF  x77,W
05508:  MOVWF  01
0550A:  MOVLW  00
0550C:  ADDWFC x78,W
0550E:  MOVWF  03
05510:  MOVF   01,W
05512:  ADDLW  20
05514:  MOVWF  FE9
05516:  MOVLW  00
05518:  ADDWFC 03,W
0551A:  MOVWF  FEA
0551C:  MOVFF  FEF,6B7
05520:  MOVFF  FEC,01
05524:  MOVFF  FEC,02
05528:  MOVFF  FEC,03
0552C:  MOVFF  FEA,678
05530:  MOVFF  FE9,677
05534:  BCF    FD8.1
05536:  MOVFF  670,6B6
0553A:  MOVFF  66F,6B5
0553E:  MOVFF  66E,6B4
05542:  MOVFF  66D,6B3
05546:  MOVFF  03,6BA
0554A:  MOVFF  02,6B9
0554E:  MOVFF  01,6B8
05552:  MOVLB  0
05554:  CALL   1400
05558:  MOVFF  678,FEA
0555C:  MOVFF  677,FE9
05560:  MOVFF  03,67C
05564:  MOVFF  02,67B
05568:  MOVFF  01,67A
0556C:  MOVFF  00,679
05570:  BCF    FD8.1
05572:  MOVFF  03,6B6
05576:  MOVFF  02,6B5
0557A:  MOVFF  01,6B4
0557E:  MOVFF  00,6B3
05582:  MOVFF  674,6BA
05586:  MOVFF  673,6B9
0558A:  MOVFF  672,6B8
0558E:  MOVFF  671,6B7
05592:  CALL   1400
05596:  MOVFF  676,FEA
0559A:  MOVFF  675,FE9
0559E:  MOVFF  00,FEF
055A2:  MOVFF  01,FEC
055A6:  MOVFF  02,FEC
055AA:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
055AE:  MOVLB  6
055B0:  MOVF   x68,W
055B2:  MULLW  20
055B4:  MOVF   FF3,W
055B6:  CLRF   x76
055B8:  MOVWF  x75
055BA:  MOVLW  18
055BC:  ADDWF  x75,W
055BE:  MOVWF  01
055C0:  MOVLW  00
055C2:  ADDWFC x76,W
055C4:  MOVWF  03
055C6:  MOVF   01,W
055C8:  ADDLW  20
055CA:  MOVWF  FE9
055CC:  MOVLW  00
055CE:  ADDWFC 03,W
055D0:  MOVWF  FEA
055D2:  MOVFF  FEF,6B3
055D6:  MOVFF  FEC,676
055DA:  MOVFF  FEC,6B5
055DE:  MOVFF  FEC,6B6
055E2:  CLRF   xB2
055E4:  CLRF   xB1
055E6:  MOVLW  7C
055E8:  MOVWF  xB0
055EA:  MOVLW  84
055EC:  MOVWF  xAF
055EE:  MOVFF  676,6B4
055F2:  MOVLB  0
055F4:  CALL   27D6
055F8:  BNC   562C
055FA:  MOVLB  6
055FC:  MOVF   x68,W
055FE:  MULLW  20
05600:  MOVF   FF3,W
05602:  CLRF   x76
05604:  MOVWF  x75
05606:  MOVLW  18
05608:  ADDWF  x75,W
0560A:  MOVWF  01
0560C:  MOVLW  00
0560E:  ADDWFC x76,W
05610:  MOVWF  03
05612:  MOVF   01,W
05614:  ADDLW  20
05616:  MOVWF  FE9
05618:  MOVLW  00
0561A:  ADDWFC 03,W
0561C:  MOVWF  FEA
0561E:  MOVLW  84
05620:  MOVWF  FEF
05622:  MOVLW  7C
05624:  MOVWF  FEC
05626:  CLRF   FEC
05628:  CLRF   FEC
0562A:  BRA    56A8
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
0562C:  MOVLB  6
0562E:  MOVF   x68,W
05630:  MULLW  20
05632:  MOVF   FF3,W
05634:  CLRF   x76
05636:  MOVWF  x75
05638:  MOVLW  18
0563A:  ADDWF  x75,W
0563C:  MOVWF  01
0563E:  MOVLW  00
05640:  ADDWFC x76,W
05642:  MOVWF  03
05644:  MOVF   01,W
05646:  ADDLW  20
05648:  MOVWF  FE9
0564A:  MOVLW  00
0564C:  ADDWFC 03,W
0564E:  MOVWF  FEA
05650:  MOVFF  FEF,6AF
05654:  MOVFF  FEC,676
05658:  MOVFF  FEC,6B1
0565C:  MOVFF  FEC,6B2
05660:  MOVFF  676,6B0
05664:  CLRF   xB6
05666:  CLRF   xB5
05668:  MOVLW  FC
0566A:  MOVWF  xB4
0566C:  MOVLW  84
0566E:  MOVWF  xB3
05670:  MOVLB  0
05672:  CALL   27D6
05676:  BNC   56A8
05678:  MOVLB  6
0567A:  MOVF   x68,W
0567C:  MULLW  20
0567E:  MOVF   FF3,W
05680:  CLRF   x76
05682:  MOVWF  x75
05684:  MOVLW  18
05686:  ADDWF  x75,W
05688:  MOVWF  01
0568A:  MOVLW  00
0568C:  ADDWFC x76,W
0568E:  MOVWF  03
05690:  MOVF   01,W
05692:  ADDLW  20
05694:  MOVWF  FE9
05696:  MOVLW  00
05698:  ADDWFC 03,W
0569A:  MOVWF  FEA
0569C:  MOVLW  84
0569E:  MOVWF  FEF
056A0:  MOVLW  FC
056A2:  MOVWF  FEC
056A4:  CLRF   FEC
056A6:  CLRF   FEC
056A8:  MOVLB  0
056AA:  GOTO   5722 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
056AE:  MOVLB  6
056B0:  MOVF   x67,W
056B2:  MULLW  20
056B4:  MOVF   FF3,W
056B6:  CLRF   x69
056B8:  MOVWF  x68
056BA:  MOVLW  0C
056BC:  ADDWF  x68,W
056BE:  MOVWF  01
056C0:  MOVLW  00
056C2:  ADDWFC x69,W
056C4:  MOVWF  03
056C6:  MOVF   01,W
056C8:  ADDLW  20
056CA:  MOVWF  FE9
056CC:  MOVLW  00
056CE:  ADDWFC 03,W
056D0:  MOVWF  FEA
056D2:  MOVFF  FEF,6AF
056D6:  MOVFF  FEC,6B0
056DA:  MOVFF  FEC,6B1
056DE:  MOVFF  FEC,6B2
056E2:  MOVF   x67,W
056E4:  MULLW  20
056E6:  MOVF   FF3,W
056E8:  CLRF   x6D
056EA:  MOVWF  x6C
056EC:  MOVLW  10
056EE:  ADDWF  x6C,W
056F0:  MOVWF  01
056F2:  MOVLW  00
056F4:  ADDWFC x6D,W
056F6:  MOVWF  03
056F8:  MOVF   01,W
056FA:  ADDLW  20
056FC:  MOVWF  FE9
056FE:  MOVLW  00
05700:  ADDWFC 03,W
05702:  MOVWF  FEA
05704:  MOVFF  FEF,6B3
05708:  MOVFF  FEC,6B4
0570C:  MOVFF  FEC,6B5
05710:  MOVFF  FEC,6B6
05714:  MOVLB  0
05716:  CALL   27D6
0571A:  BZ    5722
0571C:  MOVFF  667,668
05720:  BRA    511C
....................    if ((index++) >= numChannels) index = 0;
05722:  MOVLB  1
05724:  MOVF   xDA,W
05726:  INCF   xDA,F
05728:  SUBLW  01
0572A:  BC    572E
0572C:  CLRF   xDA
0572E:  MOVLB  0
05730:  GOTO   581C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
010A0:  CLRF   03
010A2:  MOVF   F91,W
010A4:  MOVFF  669,F91
010A8:  RRCF   F94,W
010AA:  BNC   10A8
010AC:  MOVF   F91,W
010AE:  MOVWF  02
010B0:  MOVFF  668,F91
010B4:  RRCF   F94,W
010B6:  BNC   10B4
010B8:  MOVF   F91,W
010BA:  MOVWF  01
010BC:  MOVFF  667,F91
010C0:  RRCF   F94,W
010C2:  BNC   10C0
010C4:  MOVFF  F91,00
010C8:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
05078:  MOVLB  6
0507A:  MOVF   x68,F
0507C:  BZ    50CC
....................       if (chMap[0] == ch) output_low(INV_HVX);
0507E:  MOVLW  00
05080:  MOVLB  0
05082:  BTFSC  x60.0
05084:  MOVLW  01
05086:  MOVLB  6
05088:  SUBWF  x67,W
0508A:  BNZ   5092
0508C:  MOVLW  C4
0508E:  MOVWF  F88
05090:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
05092:  MOVLW  00
05094:  MOVLB  0
05096:  BTFSC  x60.1
05098:  MOVLW  01
0509A:  MOVLB  6
0509C:  SUBWF  x67,W
0509E:  BNZ   50A6
050A0:  MOVLW  C4
050A2:  MOVWF  F88
050A4:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
050A6:  MOVF   x67,W
050A8:  MULLW  03
050AA:  MOVF   FF3,W
050AC:  CLRF   x6A
050AE:  MOVWF  x69
050B0:  MOVLW  02
050B2:  ADDWF  x69,W
050B4:  MOVWF  01
050B6:  MOVLW  00
050B8:  ADDWFC x6A,W
050BA:  MOVWF  03
050BC:  MOVF   01,W
050BE:  ADDLW  51
050C0:  MOVWF  FE9
050C2:  MOVLW  01
050C4:  ADDWFC 03,W
050C6:  MOVWF  FEA
050C8:  BSF    FEF.0
....................    }
050CA:  BRA    5118
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
050CC:  MOVLW  00
050CE:  MOVLB  0
050D0:  BTFSC  x60.0
050D2:  MOVLW  01
050D4:  MOVLB  6
050D6:  SUBWF  x67,W
050D8:  BNZ   50E0
050DA:  MOVLW  C4
050DC:  MOVWF  F88
050DE:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
050E0:  MOVLW  00
050E2:  MOVLB  0
050E4:  BTFSC  x60.1
050E6:  MOVLW  01
050E8:  MOVLB  6
050EA:  SUBWF  x67,W
050EC:  BNZ   50F4
050EE:  MOVLW  C4
050F0:  MOVWF  F88
050F2:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
050F4:  MOVF   x67,W
050F6:  MULLW  03
050F8:  MOVF   FF3,W
050FA:  CLRF   x6A
050FC:  MOVWF  x69
050FE:  MOVLW  02
05100:  ADDWF  x69,W
05102:  MOVWF  01
05104:  MOVLW  00
05106:  ADDWFC x6A,W
05108:  MOVWF  03
0510A:  MOVF   01,W
0510C:  ADDLW  51
0510E:  MOVWF  FE9
05110:  MOVLW  01
05112:  ADDWFC 03,W
05114:  MOVWF  FEA
05116:  BCF    FEF.0
....................    }
05118:  MOVLB  0
0511A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
05734:  MOVLB  6
05736:  CLRF   x66
05738:  CLRF   x65
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
0573A:  MOVFF  664,671
0573E:  CLRF   x73
05740:  MOVLW  61
05742:  MOVWF  x72
05744:  MOVLB  0
05746:  RCALL  5042
05748:  MOVF   01,F
0574A:  BNZ   5816
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
0574C:  MOVLB  6
0574E:  MOVF   x64,W
05750:  MULLW  04
05752:  MOVF   FF3,W
05754:  CLRF   03
05756:  ADDLW  EA
05758:  MOVWF  FE9
0575A:  MOVLW  00
0575C:  ADDWFC 03,W
0575E:  MOVWF  FEA
05760:  MOVFF  FEF,6AF
05764:  MOVFF  FEC,6B0
05768:  MOVFF  FEC,6B1
0576C:  MOVFF  FEC,6B2
05770:  CLRF   xB6
05772:  CLRF   xB5
05774:  CLRF   xB4
05776:  CLRF   xB3
05778:  MOVLB  0
0577A:  CALL   27D6
0577E:  BNC   5790
05780:  MOVFF  664,667
05784:  MOVLW  01
05786:  MOVLB  6
05788:  MOVWF  x68
0578A:  MOVLB  0
0578C:  RCALL  5078
0578E:  BRA    579C
....................       else                             invert_voltage(ch, FALSE);
05790:  MOVFF  664,667
05794:  MOVLB  6
05796:  CLRF   x68
05798:  MOVLB  0
0579A:  RCALL  5078
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
0579C:  MOVLB  6
0579E:  MOVF   x64,W
057A0:  MULLW  04
057A2:  MOVF   FF3,W
057A4:  CLRF   03
057A6:  ADDLW  EA
057A8:  MOVWF  FE9
057AA:  MOVLW  00
057AC:  ADDWFC 03,W
057AE:  MOVWF  FEA
057B0:  MOVFF  FEF,00
057B4:  MOVFF  FEC,01
057B8:  MOVFF  FEC,02
057BC:  MOVFF  FEC,03
057C0:  BCF    01.7
057C2:  MOVFF  03,66A
057C6:  MOVFF  02,669
057CA:  MOVFF  01,668
057CE:  MOVFF  00,667
057D2:  MOVFF  03,6B7
057D6:  MOVFF  02,6B6
057DA:  MOVFF  01,6B5
057DE:  MOVFF  00,6B4
057E2:  MOVLW  66
057E4:  MOVWF  xBB
057E6:  MOVLW  D6
057E8:  MOVWF  xBA
057EA:  MOVLW  23
057EC:  MOVWF  xB9
057EE:  MOVLW  88
057F0:  MOVWF  xB8
057F2:  MOVLB  0
057F4:  CALL   130A
057F8:  MOVFF  03,6B2
057FC:  MOVFF  02,6B1
05800:  MOVFF  01,6B0
05804:  MOVFF  00,6AF
05808:  CALL   31CA
0580C:  MOVFF  02,666
05810:  MOVFF  01,665
....................    }
05814:  BRA    5906
....................    else {
....................       pid_task(ch);
05816:  MOVFF  664,667
0581A:  BRA    56AE
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
0581C:  MOVLB  6
0581E:  MOVF   x64,W
05820:  MULLW  20
05822:  MOVF   FF3,W
05824:  CLRF   x68
05826:  MOVWF  x67
05828:  MOVLW  18
0582A:  ADDWF  x67,W
0582C:  MOVWF  01
0582E:  MOVLW  00
05830:  ADDWFC x68,W
05832:  MOVWF  03
05834:  MOVF   01,W
05836:  ADDLW  20
05838:  MOVWF  FE9
0583A:  MOVLW  00
0583C:  ADDWFC 03,W
0583E:  MOVWF  FEA
05840:  MOVFF  FEF,6AF
05844:  MOVFF  FEC,6B0
05848:  MOVFF  FEC,6B1
0584C:  MOVFF  FEC,6B2
05850:  CLRF   xB6
05852:  CLRF   xB5
05854:  CLRF   xB4
05856:  CLRF   xB3
05858:  MOVLB  0
0585A:  CALL   27D6
0585E:  BNC   5870
05860:  MOVFF  664,667
05864:  MOVLW  01
05866:  MOVLB  6
05868:  MOVWF  x68
0586A:  MOVLB  0
0586C:  RCALL  5078
0586E:  BRA    587E
....................       else                       invert_voltage(ch, FALSE);
05870:  MOVFF  664,667
05874:  MOVLB  6
05876:  CLRF   x68
05878:  MOVLB  0
0587A:  CALL   5078
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
0587E:  MOVLB  6
05880:  MOVF   x64,W
05882:  MULLW  20
05884:  MOVF   FF3,W
05886:  CLRF   x68
05888:  MOVWF  x67
0588A:  MOVLW  18
0588C:  ADDWF  x67,W
0588E:  MOVWF  01
05890:  MOVLW  00
05892:  ADDWFC x68,W
05894:  MOVWF  03
05896:  MOVF   01,W
05898:  ADDLW  20
0589A:  MOVWF  FE9
0589C:  MOVLW  00
0589E:  ADDWFC 03,W
058A0:  MOVWF  FEA
058A2:  MOVFF  FEF,00
058A6:  MOVFF  FEC,01
058AA:  MOVFF  FEC,02
058AE:  MOVFF  FEC,03
058B2:  BCF    01.7
058B4:  MOVFF  03,66A
058B8:  MOVFF  02,669
058BC:  MOVFF  01,668
058C0:  MOVFF  00,667
058C4:  MOVFF  03,6B7
058C8:  MOVFF  02,6B6
058CC:  MOVFF  01,6B5
058D0:  MOVFF  00,6B4
058D4:  MOVLW  66
058D6:  MOVWF  xBB
058D8:  MOVLW  D6
058DA:  MOVWF  xBA
058DC:  MOVLW  23
058DE:  MOVWF  xB9
058E0:  MOVLW  88
058E2:  MOVWF  xB8
058E4:  MOVLB  0
058E6:  CALL   130A
058EA:  MOVFF  03,6B2
058EE:  MOVFF  02,6B1
058F2:  MOVFF  01,6B0
058F6:  MOVFF  00,6AF
058FA:  CALL   31CA
058FE:  MOVFF  02,666
05902:  MOVFF  01,665
....................    }
....................    
....................    dacVals[ch].val = txData;
05906:  MOVLB  6
05908:  MOVF   x64,W
0590A:  MULLW  03
0590C:  MOVF   FF3,W
0590E:  CLRF   x68
05910:  MOVWF  x67
05912:  MOVLW  51
05914:  ADDWF  x67,W
05916:  MOVWF  FE9
05918:  MOVLW  01
0591A:  ADDWFC x68,W
0591C:  MOVWF  FEA
0591E:  MOVFF  666,FEC
05922:  MOVF   FED,F
05924:  MOVFF  665,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
05928:  MOVLW  00
0592A:  MOVLB  0
0592C:  BTFSC  x60.0
0592E:  MOVLW  01
05930:  MOVLB  6
05932:  SUBWF  x64,W
05934:  BNZ   593C
05936:  MOVLW  E8
05938:  MOVWF  F8B
0593A:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
0593C:  MOVLW  00
0593E:  MOVLB  0
05940:  BTFSC  x60.1
05942:  MOVLW  01
05944:  MOVLB  6
05946:  SUBWF  x64,W
05948:  BNZ   5950
0594A:  MOVLW  E8
0594C:  MOVWF  F8B
0594E:  BSF    F86.1
....................    
....................    delay_ms(1);
05950:  MOVLW  01
05952:  MOVWF  x6C
05954:  MOVLB  0
05956:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
0595A:  MOVLW  00
0595C:  BTFSC  x60.0
0595E:  MOVLW  01
05960:  MOVLB  6
05962:  SUBWF  x64,W
05964:  BNZ   596C
05966:  MOVLW  E8
05968:  MOVWF  F8B
0596A:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
0596C:  MOVLW  00
0596E:  MOVLB  0
05970:  BTFSC  x60.1
05972:  MOVLW  01
05974:  MOVLB  6
05976:  SUBWF  x64,W
05978:  BNZ   5980
0597A:  MOVLW  E8
0597C:  MOVWF  F8B
0597E:  BCF    F86.1
....................    delay_ms(1);
05980:  MOVLW  01
05982:  MOVWF  x6C
05984:  MOVLB  0
05986:  CALL   0438
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
0598A:  MOVLB  6
0598C:  CLRF   x6A
0598E:  CLRF   x69
05990:  MOVFF  666,668
05994:  MOVFF  665,667
05998:  MOVLB  0
0599A:  CALL   10A0
....................    delay_ms(1);
0599E:  MOVLW  01
059A0:  MOVLB  6
059A2:  MOVWF  x6C
059A4:  MOVLB  0
059A6:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
059AA:  MOVLW  00
059AC:  BTFSC  x60.0
059AE:  MOVLW  01
059B0:  MOVLB  6
059B2:  SUBWF  x64,W
059B4:  BNZ   59BC
059B6:  MOVLW  E8
059B8:  MOVWF  F8B
059BA:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
059BC:  MOVLW  00
059BE:  MOVLB  0
059C0:  BTFSC  x60.1
059C2:  MOVLW  01
059C4:  MOVLB  6
059C6:  SUBWF  x64,W
059C8:  BNZ   59D0
059CA:  MOVLW  E8
059CC:  MOVWF  F8B
059CE:  BSF    F86.1
059D0:  MOVLB  0
059D2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
059D4:  MOVLB  1
059D6:  MOVF   xDB,W
059D8:  XORLW  00
059DA:  MOVLB  0
059DC:  BZ    59E4
059DE:  XORLW  01
059E0:  BZ    59F6
059E2:  BRA    5A06
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
059E4:  MOVLB  6
059E6:  CLRF   x64
059E8:  MOVLB  0
059EA:  RCALL  5734
....................          state = 1;
059EC:  MOVLW  01
059EE:  MOVLB  1
059F0:  MOVWF  xDB
....................       break;
059F2:  MOVLB  0
059F4:  BRA    5A06
....................       case 1:
....................          set_nanoDAC_outputs(chY);
059F6:  MOVLW  01
059F8:  MOVLB  6
059FA:  MOVWF  x64
059FC:  MOVLB  0
059FE:  RCALL  5734
....................          state = 0;
05A00:  MOVLB  1
05A02:  CLRF   xDB
....................       break;
05A04:  MOVLB  0
....................    }
05A06:  GOTO   B086 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
010CA:  MOVLB  6
010CC:  CLRF   x6A
010CE:  CLRF   x69
010D0:  CLRF   x68
010D2:  CLRF   x67
010D4:  MOVLB  0
010D6:  RCALL  10A0
....................    output_low(_SYNC_X);
010D8:  MOVLW  E8
010DA:  MOVWF  F8B
010DC:  BCF    F86.2
....................    output_low(_SYNC_Y);
010DE:  MOVWF  F8B
010E0:  BCF    F86.1
....................    output_high(_SYNC_X);
010E2:  MOVWF  F8B
010E4:  BSF    F86.2
....................    output_high(_SYNC_Y);
010E6:  MOVWF  F8B
010E8:  BSF    F86.1
010EA:  GOTO   B06E (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
010EE:  MOVLB  6
010F0:  MOVF   x65,W
010F2:  SUBLW  03
010F4:  BTFSS  FD8.0
010F6:  BRA    1274
....................    {
....................       for (int i = 0; i <numParam; i ++)
010F8:  CLRF   x66
010FA:  MOVF   x66,W
010FC:  SUBLW  06
010FE:  BNC   1152
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
01100:  CLRF   xB1
01102:  MOVFF  665,6B0
01106:  CLRF   xB3
01108:  MOVLW  B5
0110A:  MOVWF  xB2
0110C:  MOVLB  0
0110E:  CALL   0802
01112:  MOVFF  02,668
01116:  MOVFF  01,667
0111A:  MOVLW  06
0111C:  MOVLB  6
0111E:  ADDWF  x67,F
01120:  MOVLW  00
01122:  ADDWFC x68,F
01124:  CLRF   xB1
01126:  MOVFF  666,6B0
0112A:  CLRF   xB3
0112C:  MOVLW  19
0112E:  MOVWF  xB2
01130:  MOVLB  0
01132:  CALL   0802
01136:  MOVF   01,W
01138:  MOVLB  6
0113A:  ADDWF  x67,F
0113C:  MOVF   02,W
0113E:  ADDWFC x68,F
01140:  MOVLW  DC
01142:  ADDWF  x67,W
01144:  MOVWF  FE9
01146:  MOVLW  01
01148:  ADDWFC x68,W
0114A:  MOVWF  FEA
0114C:  CLRF   FEF
0114E:  INCF   x66,F
01150:  BRA    10FA
....................       }
....................       SERcmd[recNum].t = 0;
01152:  CLRF   xB1
01154:  MOVFF  665,6B0
01158:  CLRF   xB3
0115A:  MOVLW  B5
0115C:  MOVWF  xB2
0115E:  MOVLB  0
01160:  CALL   0802
01164:  MOVFF  01,667
01168:  MOVLW  05
0116A:  MOVLB  6
0116C:  ADDWF  01,W
0116E:  MOVWF  01
01170:  MOVLW  00
01172:  ADDWFC 02,W
01174:  MOVWF  03
01176:  MOVF   01,W
01178:  ADDLW  DC
0117A:  MOVWF  FE9
0117C:  MOVLW  01
0117E:  ADDWFC 03,W
01180:  MOVWF  FEA
01182:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
01184:  CLRF   xB1
01186:  MOVFF  665,6B0
0118A:  CLRF   xB3
0118C:  MOVLW  B5
0118E:  MOVWF  xB2
01190:  MOVLB  0
01192:  CALL   0802
01196:  MOVFF  01,667
0119A:  MOVLW  01
0119C:  MOVLB  6
0119E:  ADDWF  01,W
011A0:  MOVWF  01
011A2:  MOVLW  00
011A4:  ADDWFC 02,W
011A6:  MOVWF  03
011A8:  MOVF   01,W
011AA:  ADDLW  DC
011AC:  MOVWF  FE9
011AE:  MOVLW  01
011B0:  ADDWFC 03,W
011B2:  MOVWF  FEA
011B4:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
011B6:  CLRF   xB1
011B8:  MOVFF  665,6B0
011BC:  CLRF   xB3
011BE:  MOVLW  B5
011C0:  MOVWF  xB2
011C2:  MOVLB  0
011C4:  CALL   0802
011C8:  MOVFF  01,667
011CC:  MOVLW  02
011CE:  MOVLB  6
011D0:  ADDWF  01,W
011D2:  MOVWF  01
011D4:  MOVLW  00
011D6:  ADDWFC 02,W
011D8:  MOVWF  03
011DA:  MOVF   01,W
011DC:  ADDLW  DC
011DE:  MOVWF  FE9
011E0:  MOVLW  01
011E2:  ADDWFC 03,W
011E4:  MOVWF  FEA
011E6:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
011E8:  CLRF   xB1
011EA:  MOVFF  665,6B0
011EE:  CLRF   xB3
011F0:  MOVLW  B5
011F2:  MOVWF  xB2
011F4:  MOVLB  0
011F6:  CALL   0802
011FA:  MOVFF  01,667
011FE:  MOVLW  03
01200:  MOVLB  6
01202:  ADDWF  01,W
01204:  MOVWF  01
01206:  MOVLW  00
01208:  ADDWFC 02,W
0120A:  MOVWF  03
0120C:  MOVF   01,W
0120E:  ADDLW  DC
01210:  MOVWF  FE9
01212:  MOVLW  01
01214:  ADDWFC 03,W
01216:  MOVWF  FEA
01218:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
0121A:  CLRF   xB1
0121C:  MOVFF  665,6B0
01220:  CLRF   xB3
01222:  MOVLW  B5
01224:  MOVWF  xB2
01226:  MOVLB  0
01228:  CALL   0802
0122C:  MOVFF  01,667
01230:  MOVLW  04
01232:  MOVLB  6
01234:  ADDWF  01,W
01236:  MOVWF  01
01238:  MOVLW  00
0123A:  ADDWFC 02,W
0123C:  MOVWF  03
0123E:  MOVF   01,W
01240:  ADDLW  DC
01242:  MOVWF  FE9
01244:  MOVLW  01
01246:  ADDWFC 03,W
01248:  MOVWF  FEA
0124A:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
0124C:  CLRF   xB1
0124E:  MOVFF  665,6B0
01252:  CLRF   xB3
01254:  MOVLW  B5
01256:  MOVWF  xB2
01258:  MOVLB  0
0125A:  CALL   0802
0125E:  MOVLW  DC
01260:  MOVLB  6
01262:  ADDWF  01,W
01264:  MOVWF  FE9
01266:  MOVLW  01
01268:  ADDWFC 02,W
0126A:  MOVWF  FEA
0126C:  BCF    FEF.0
....................       retData[0] = '\0';
0126E:  MOVLB  4
01270:  CLRF   xB2
01272:  MOVLB  6
....................    }
01274:  MOVLB  0
01276:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
063B2:  MOVLB  6
063B4:  CLRF   xB1
063B6:  MOVFF  4B0,6B0
063BA:  CLRF   xB3
063BC:  MOVLW  B5
063BE:  MOVWF  xB2
063C0:  MOVLB  0
063C2:  CALL   0802
063C6:  MOVFF  02,666
063CA:  MOVFF  01,665
063CE:  MOVLW  DC
063D0:  MOVLB  6
063D2:  ADDWF  01,W
063D4:  MOVWF  FE9
063D6:  MOVLW  01
063D8:  ADDWFC 02,W
063DA:  MOVWF  FEA
063DC:  BTFSC  FEF.0
063DE:  BRA    6400
....................    {
....................       if (SRI == SWI) return FALSE;
063E0:  MOVLB  4
063E2:  MOVF   xB1,W
063E4:  SUBWF  xB0,W
063E6:  BNZ   63EE
063E8:  MOVLW  00
063EA:  MOVWF  01
063EC:  BRA    6406
....................       SRI +=1;
063EE:  MOVLW  01
063F0:  ADDWF  xB0,F
....................       if (SRI >= numRecords) SRI=0;
063F2:  MOVF   xB0,W
063F4:  SUBLW  03
063F6:  BC    63FA
063F8:  CLRF   xB0
063FA:  MOVLB  0
063FC:  BRA    63B2
063FE:  MOVLB  6
....................    }
....................    return TRUE;
06400:  MOVLW  01
06402:  MOVWF  01
06404:  MOVLB  4
06406:  MOVLB  0
06408:  GOTO   ABC8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05A3E:  MOVLW  01
05A40:  MOVLB  4
05A42:  ADDWF  xB1,F
....................    if (SWI >= numRecords) SWI=0;
05A44:  MOVF   xB1,W
05A46:  SUBLW  03
05A48:  BC    5A4C
05A4A:  CLRF   xB1
05A4C:  MOVLB  0
05A4E:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,555
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x55.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
05A50:  MOVLW  93
05A52:  MOVWF  F89
05A54:  BSF    F84.5
05A56:  MOVLB  E
05A58:  BTFSS  xC8.4
05A5A:  BRA    5A58
05A5C:  MOVLW  93
05A5E:  MOVWF  F89
05A60:  BSF    F84.5
05A62:  MOVLB  6
05A64:  MOVFF  67A,F99
05A68:  NOP   
05A6A:  BTFSS  F9D.1
05A6C:  BRA    5A6A
05A6E:  MOVLW  93
05A70:  MOVWF  F89
05A72:  BCF    F84.5
05A74:  MOVLB  0
05A76:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x52,W
000F6:  ADDLW  16
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,6D6
00104:  MOVFF  FE9,6D5
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  6D6,FEA
00110:  MOVFF  6D5,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x52,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x52,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x52
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    x54.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05A0A:  CLRF   03
05A0C:  MOVLB  5
05A0E:  MOVF   x53,W
05A10:  ADDLW  16
05A12:  MOVWF  FE9
05A14:  MOVLW  05
05A16:  ADDWFC 03,W
05A18:  MOVWF  FEA
05A1A:  MOVFF  FEF,665
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05A1E:  MOVLW  01
05A20:  ADDWF  x53,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05A22:  MOVF   x53,W
05A24:  SUBLW  3B
05A26:  BC    5A2A
05A28:  CLRF   x53
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05A2A:  MOVF   x52,W
05A2C:  SUBWF  x53,W
05A2E:  BNZ   5A32
05A30:  BCF    x54.0
....................    return data;
05A32:  MOVLB  6
05A34:  MOVFF  665,01
05A38:  MOVLB  0
05A3A:  GOTO   5ADE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05A9C:  MOVLB  5
05A9E:  BTFSS  x54.0
05AA0:  BRA    5F8E
05AA2:  MOVLB  6
05AA4:  CLRF   xB1
05AA6:  MOVFF  4B1,6B0
05AAA:  CLRF   xB3
05AAC:  MOVLW  B5
05AAE:  MOVWF  xB2
05AB0:  MOVLB  0
05AB2:  CALL   0802
05AB6:  MOVFF  02,666
05ABA:  MOVFF  01,665
05ABE:  MOVLW  DC
05AC0:  MOVLB  6
05AC2:  ADDWF  01,W
05AC4:  MOVWF  01
05AC6:  MOVLW  01
05AC8:  ADDWFC 02,W
05ACA:  MOVWF  03
05ACC:  MOVFF  01,FE9
05AD0:  MOVWF  FEA
05AD2:  BTFSS  FEF.0
05AD4:  BRA    5ADA
05AD6:  MOVLB  5
05AD8:  BRA    5F8E
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
05ADA:  MOVLB  0
05ADC:  BRA    5A0A
05ADE:  MOVFF  01,664
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05AE2:  MOVLB  6
05AE4:  MOVF   x64,W
05AE6:  SUBLW  0D
05AE8:  BZ    5AF0
05AEA:  MOVF   x64,W
05AEC:  SUBLW  20
05AEE:  BNZ   5AF2
....................       {
....................       }
05AF0:  BRA    5F88
....................       else if (rxChar == UART_SOT_CHAR)
05AF2:  MOVF   x64,W
05AF4:  SUBLW  7E
05AF6:  BNZ   5B3A
....................       {
....................          resetSERcmd(SWI);
05AF8:  MOVFF  4B1,665
05AFC:  MOVLB  0
05AFE:  CALL   10EE
....................          SERcmd[SWI].t = rxChar;
05B02:  MOVLB  6
05B04:  CLRF   xB1
05B06:  MOVFF  4B1,6B0
05B0A:  CLRF   xB3
05B0C:  MOVLW  B5
05B0E:  MOVWF  xB2
05B10:  MOVLB  0
05B12:  CALL   0802
05B16:  MOVFF  01,665
05B1A:  MOVLW  05
05B1C:  MOVLB  6
05B1E:  ADDWF  01,W
05B20:  MOVWF  01
05B22:  MOVLW  00
05B24:  ADDWFC 02,W
05B26:  MOVWF  03
05B28:  MOVF   01,W
05B2A:  ADDLW  DC
05B2C:  MOVWF  FE9
05B2E:  MOVLW  01
05B30:  ADDWFC 03,W
05B32:  MOVWF  FEA
05B34:  MOVFF  664,FEF
....................       }
05B38:  BRA    5F88
....................       else if (rxChar >= oneByteCmdTestValue)
05B3A:  MOVF   x64,W
05B3C:  SUBLW  7F
05B3E:  BC    5BAA
....................       {
....................          resetSERcmd(SWI);
05B40:  MOVFF  4B1,665
05B44:  MOVLB  0
05B46:  CALL   10EE
....................          SERcmd[SWI].t = rxChar;
05B4A:  MOVLB  6
05B4C:  CLRF   xB1
05B4E:  MOVFF  4B1,6B0
05B52:  CLRF   xB3
05B54:  MOVLW  B5
05B56:  MOVWF  xB2
05B58:  MOVLB  0
05B5A:  CALL   0802
05B5E:  MOVFF  01,665
05B62:  MOVLW  05
05B64:  MOVLB  6
05B66:  ADDWF  01,W
05B68:  MOVWF  01
05B6A:  MOVLW  00
05B6C:  ADDWFC 02,W
05B6E:  MOVWF  03
05B70:  MOVF   01,W
05B72:  ADDLW  DC
05B74:  MOVWF  FE9
05B76:  MOVLW  01
05B78:  ADDWFC 03,W
05B7A:  MOVWF  FEA
05B7C:  MOVFF  664,FEF
....................          SERcmd[SWI].full = TRUE;
05B80:  CLRF   xB1
05B82:  MOVFF  4B1,6B0
05B86:  CLRF   xB3
05B88:  MOVLW  B5
05B8A:  MOVWF  xB2
05B8C:  MOVLB  0
05B8E:  CALL   0802
05B92:  MOVLW  DC
05B94:  MOVLB  6
05B96:  ADDWF  01,W
05B98:  MOVWF  FE9
05B9A:  MOVLW  01
05B9C:  ADDWFC 02,W
05B9E:  MOVWF  FEA
05BA0:  BSF    FEF.0
....................          setNextSERWriteIndex();
05BA2:  MOVLB  0
05BA4:  RCALL  5A3E
....................       }
05BA6:  BRA    5F86
05BA8:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05BAA:  MOVF   x64,W
05BAC:  SUBLW  0A
05BAE:  BTFSS  FD8.2
05BB0:  BRA    5CB6
....................       {
....................          SERcmd[SWI].full = TRUE;
05BB2:  CLRF   xB1
05BB4:  MOVFF  4B1,6B0
05BB8:  CLRF   xB3
05BBA:  MOVLW  B5
05BBC:  MOVWF  xB2
05BBE:  MOVLB  0
05BC0:  CALL   0802
05BC4:  MOVLW  DC
05BC6:  MOVLB  6
05BC8:  ADDWF  01,W
05BCA:  MOVWF  FE9
05BCC:  MOVLW  01
05BCE:  ADDWFC 02,W
05BD0:  MOVWF  FEA
05BD2:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05BD4:  CLRF   xB1
05BD6:  MOVFF  4B1,6B0
05BDA:  CLRF   xB3
05BDC:  MOVLW  B5
05BDE:  MOVWF  xB2
05BE0:  MOVLB  0
05BE2:  CALL   0802
05BE6:  MOVFF  01,665
05BEA:  MOVLW  04
05BEC:  MOVLB  6
05BEE:  ADDWF  01,W
05BF0:  MOVWF  01
05BF2:  MOVLW  00
05BF4:  ADDWFC 02,W
05BF6:  MOVWF  03
05BF8:  MOVF   01,W
05BFA:  ADDLW  DC
05BFC:  MOVWF  01
05BFE:  MOVLW  01
05C00:  ADDWFC 03,F
05C02:  MOVFF  01,665
05C06:  MOVFF  03,666
05C0A:  CLRF   xB1
05C0C:  MOVFF  4B1,6B0
05C10:  CLRF   xB3
05C12:  MOVLW  B5
05C14:  MOVWF  xB2
05C16:  MOVLB  0
05C18:  CALL   0802
05C1C:  MOVFF  01,667
05C20:  MOVLW  02
05C22:  MOVLB  6
05C24:  ADDWF  01,W
05C26:  MOVWF  01
05C28:  MOVLW  00
05C2A:  ADDWFC 02,W
05C2C:  MOVWF  03
05C2E:  MOVF   01,W
05C30:  ADDLW  DC
05C32:  MOVWF  FE9
05C34:  MOVLW  01
05C36:  ADDWFC 03,W
05C38:  MOVWF  FEA
05C3A:  MOVFF  FEF,667
05C3E:  MOVFF  666,FEA
05C42:  MOVFF  665,FE9
05C46:  MOVFF  667,FEF
....................          SERcmd[SWI].chrIndex = 0;
05C4A:  CLRF   xB1
05C4C:  MOVFF  4B1,6B0
05C50:  CLRF   xB3
05C52:  MOVLW  B5
05C54:  MOVWF  xB2
05C56:  MOVLB  0
05C58:  CALL   0802
05C5C:  MOVFF  01,665
05C60:  MOVLW  01
05C62:  MOVLB  6
05C64:  ADDWF  01,W
05C66:  MOVWF  01
05C68:  MOVLW  00
05C6A:  ADDWFC 02,W
05C6C:  MOVWF  03
05C6E:  MOVF   01,W
05C70:  ADDLW  DC
05C72:  MOVWF  FE9
05C74:  MOVLW  01
05C76:  ADDWFC 03,W
05C78:  MOVWF  FEA
05C7A:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05C7C:  CLRF   xB1
05C7E:  MOVFF  4B1,6B0
05C82:  CLRF   xB3
05C84:  MOVLW  B5
05C86:  MOVWF  xB2
05C88:  MOVLB  0
05C8A:  CALL   0802
05C8E:  MOVFF  01,665
05C92:  MOVLW  02
05C94:  MOVLB  6
05C96:  ADDWF  01,W
05C98:  MOVWF  01
05C9A:  MOVLW  00
05C9C:  ADDWFC 02,W
05C9E:  MOVWF  03
05CA0:  MOVF   01,W
05CA2:  ADDLW  DC
05CA4:  MOVWF  FE9
05CA6:  MOVLW  01
05CA8:  ADDWFC 03,W
05CAA:  MOVWF  FEA
05CAC:  CLRF   FEF
....................          setNextSERWriteIndex();
05CAE:  MOVLB  0
05CB0:  RCALL  5A3E
....................       }
05CB2:  BRA    5F86
05CB4:  MOVLB  6
....................       else if (rxChar == delimiter)
05CB6:  MOVF   x64,W
05CB8:  SUBLW  2C
05CBA:  BNZ   5D78
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
05CBC:  CLRF   xB1
05CBE:  MOVFF  4B1,6B0
05CC2:  CLRF   xB3
05CC4:  MOVLW  B5
05CC6:  MOVWF  xB2
05CC8:  MOVLB  0
05CCA:  CALL   0802
05CCE:  MOVFF  02,666
05CD2:  MOVFF  01,665
05CD6:  MOVLW  02
05CD8:  MOVLB  6
05CDA:  ADDWF  01,W
05CDC:  MOVWF  01
05CDE:  MOVLW  00
05CE0:  ADDWFC 02,W
05CE2:  MOVWF  03
05CE4:  MOVF   01,W
05CE6:  ADDLW  DC
05CE8:  MOVWF  FE9
05CEA:  MOVLW  01
05CEC:  ADDWFC 03,W
05CEE:  MOVWF  FEA
05CF0:  MOVF   FEF,W
05CF2:  SUBLW  05
05CF4:  BNC   5D60
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05CF6:  CLRF   xB1
05CF8:  MOVFF  4B1,6B0
05CFC:  CLRF   xB3
05CFE:  MOVLW  B5
05D00:  MOVWF  xB2
05D02:  MOVLB  0
05D04:  CALL   0802
05D08:  MOVFF  01,665
05D0C:  MOVLW  02
05D0E:  MOVLB  6
05D10:  ADDWF  01,W
05D12:  MOVWF  01
05D14:  MOVLW  00
05D16:  ADDWFC 02,W
05D18:  MOVWF  03
05D1A:  MOVF   01,W
05D1C:  ADDLW  DC
05D1E:  MOVWF  FE9
05D20:  MOVLW  01
05D22:  ADDWFC 03,W
05D24:  MOVWF  FEA
05D26:  MOVLW  01
05D28:  ADDWF  FEF,W
05D2A:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05D2C:  CLRF   xB1
05D2E:  MOVFF  4B1,6B0
05D32:  CLRF   xB3
05D34:  MOVLW  B5
05D36:  MOVWF  xB2
05D38:  MOVLB  0
05D3A:  CALL   0802
05D3E:  MOVFF  01,665
05D42:  MOVLW  01
05D44:  MOVLB  6
05D46:  ADDWF  01,W
05D48:  MOVWF  01
05D4A:  MOVLW  00
05D4C:  ADDWFC 02,W
05D4E:  MOVWF  03
05D50:  MOVF   01,W
05D52:  ADDLW  DC
05D54:  MOVWF  FE9
05D56:  MOVLW  01
05D58:  ADDWFC 03,W
05D5A:  MOVWF  FEA
05D5C:  CLRF   FEF
....................          }
05D5E:  BRA    5D76
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05D60:  MOVFF  4B1,665
05D64:  MOVLB  0
05D66:  CALL   10EE
....................             fprintf(SERIAL, retData);
05D6A:  MOVLW  04
05D6C:  MOVWF  FEA
05D6E:  MOVLW  B2
05D70:  MOVWF  FE9
05D72:  RCALL  5A78
05D74:  MOVLB  6
....................          }
....................       }
05D76:  BRA    5F88
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05D78:  CLRF   xB1
05D7A:  MOVFF  4B1,6B0
05D7E:  CLRF   xB3
05D80:  MOVLW  B5
05D82:  MOVWF  xB2
05D84:  MOVLB  0
05D86:  CALL   0802
05D8A:  MOVFF  02,666
05D8E:  MOVFF  01,665
05D92:  MOVLW  01
05D94:  MOVLB  6
05D96:  ADDWF  01,W
05D98:  MOVWF  01
05D9A:  MOVLW  00
05D9C:  ADDWFC 02,W
05D9E:  MOVWF  03
05DA0:  MOVF   01,W
05DA2:  ADDLW  DC
05DA4:  MOVWF  FE9
05DA6:  MOVLW  01
05DA8:  ADDWFC 03,W
05DAA:  MOVWF  FEA
05DAC:  MOVF   FEF,W
05DAE:  SUBLW  18
05DB0:  BTFSS  FD8.0
05DB2:  BRA    5F72
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
05DB4:  CLRF   xB1
05DB6:  MOVFF  4B1,6B0
05DBA:  CLRF   xB3
05DBC:  MOVLW  B5
05DBE:  MOVWF  xB2
05DC0:  MOVLB  0
05DC2:  CALL   0802
05DC6:  MOVFF  02,666
05DCA:  MOVFF  01,665
05DCE:  MOVLW  06
05DD0:  MOVLB  6
05DD2:  ADDWF  x65,F
05DD4:  MOVLW  00
05DD6:  ADDWFC x66,F
05DD8:  CLRF   xB1
05DDA:  MOVFF  4B1,6B0
05DDE:  CLRF   xB3
05DE0:  MOVLW  B5
05DE2:  MOVWF  xB2
05DE4:  MOVLB  0
05DE6:  CALL   0802
05DEA:  MOVFF  02,668
05DEE:  MOVFF  01,667
05DF2:  MOVLW  02
05DF4:  MOVLB  6
05DF6:  ADDWF  01,W
05DF8:  MOVWF  01
05DFA:  MOVLW  00
05DFC:  ADDWFC 02,W
05DFE:  MOVWF  03
05E00:  MOVF   01,W
05E02:  ADDLW  DC
05E04:  MOVWF  FE9
05E06:  MOVLW  01
05E08:  ADDWFC 03,W
05E0A:  MOVWF  FEA
05E0C:  CLRF   xB1
05E0E:  MOVFF  FEF,6B0
05E12:  CLRF   xB3
05E14:  MOVLW  19
05E16:  MOVWF  xB2
05E18:  MOVLB  0
05E1A:  CALL   0802
05E1E:  MOVFF  02,03
05E22:  MOVF   01,W
05E24:  MOVLB  6
05E26:  ADDWF  x65,F
05E28:  MOVF   02,W
05E2A:  ADDWFC x66,F
05E2C:  CLRF   xB1
05E2E:  MOVFF  4B1,6B0
05E32:  CLRF   xB3
05E34:  MOVLW  B5
05E36:  MOVWF  xB2
05E38:  MOVLB  0
05E3A:  CALL   0802
05E3E:  MOVFF  01,667
05E42:  MOVLW  01
05E44:  MOVLB  6
05E46:  ADDWF  01,W
05E48:  MOVWF  01
05E4A:  MOVLW  00
05E4C:  ADDWFC 02,W
05E4E:  MOVWF  03
05E50:  MOVF   01,W
05E52:  ADDLW  DC
05E54:  MOVWF  FE9
05E56:  MOVLW  01
05E58:  ADDWFC 03,W
05E5A:  MOVWF  FEA
05E5C:  MOVF   FEF,W
05E5E:  ADDWF  x65,W
05E60:  MOVWF  01
05E62:  MOVLW  00
05E64:  ADDWFC x66,W
05E66:  MOVWF  03
05E68:  MOVF   01,W
05E6A:  ADDLW  DC
05E6C:  MOVWF  FE9
05E6E:  MOVLW  01
05E70:  ADDWFC 03,W
05E72:  MOVWF  FEA
05E74:  MOVFF  664,FEF
....................             SERcmd[SWI].chrIndex += 1;
05E78:  CLRF   xB1
05E7A:  MOVFF  4B1,6B0
05E7E:  CLRF   xB3
05E80:  MOVLW  B5
05E82:  MOVWF  xB2
05E84:  MOVLB  0
05E86:  CALL   0802
05E8A:  MOVFF  01,665
05E8E:  MOVLW  01
05E90:  MOVLB  6
05E92:  ADDWF  01,W
05E94:  MOVWF  01
05E96:  MOVLW  00
05E98:  ADDWFC 02,W
05E9A:  MOVWF  03
05E9C:  MOVF   01,W
05E9E:  ADDLW  DC
05EA0:  MOVWF  FE9
05EA2:  MOVLW  01
05EA4:  ADDWFC 03,W
05EA6:  MOVWF  FEA
05EA8:  MOVLW  01
05EAA:  ADDWF  FEF,W
05EAC:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05EAE:  CLRF   xB1
05EB0:  MOVFF  4B1,6B0
05EB4:  CLRF   xB3
05EB6:  MOVLW  B5
05EB8:  MOVWF  xB2
05EBA:  MOVLB  0
05EBC:  CALL   0802
05EC0:  MOVFF  02,666
05EC4:  MOVFF  01,665
05EC8:  MOVLW  06
05ECA:  MOVLB  6
05ECC:  ADDWF  x65,F
05ECE:  MOVLW  00
05ED0:  ADDWFC x66,F
05ED2:  CLRF   xB1
05ED4:  MOVFF  4B1,6B0
05ED8:  CLRF   xB3
05EDA:  MOVLW  B5
05EDC:  MOVWF  xB2
05EDE:  MOVLB  0
05EE0:  CALL   0802
05EE4:  MOVFF  02,668
05EE8:  MOVFF  01,667
05EEC:  MOVLW  02
05EEE:  MOVLB  6
05EF0:  ADDWF  01,W
05EF2:  MOVWF  01
05EF4:  MOVLW  00
05EF6:  ADDWFC 02,W
05EF8:  MOVWF  03
05EFA:  MOVF   01,W
05EFC:  ADDLW  DC
05EFE:  MOVWF  FE9
05F00:  MOVLW  01
05F02:  ADDWFC 03,W
05F04:  MOVWF  FEA
05F06:  CLRF   xB1
05F08:  MOVFF  FEF,6B0
05F0C:  CLRF   xB3
05F0E:  MOVLW  19
05F10:  MOVWF  xB2
05F12:  MOVLB  0
05F14:  CALL   0802
05F18:  MOVFF  02,03
05F1C:  MOVF   01,W
05F1E:  MOVLB  6
05F20:  ADDWF  x65,F
05F22:  MOVF   02,W
05F24:  ADDWFC x66,F
05F26:  CLRF   xB1
05F28:  MOVFF  4B1,6B0
05F2C:  CLRF   xB3
05F2E:  MOVLW  B5
05F30:  MOVWF  xB2
05F32:  MOVLB  0
05F34:  CALL   0802
05F38:  MOVFF  01,667
05F3C:  MOVLW  01
05F3E:  MOVLB  6
05F40:  ADDWF  01,W
05F42:  MOVWF  01
05F44:  MOVLW  00
05F46:  ADDWFC 02,W
05F48:  MOVWF  03
05F4A:  MOVF   01,W
05F4C:  ADDLW  DC
05F4E:  MOVWF  FE9
05F50:  MOVLW  01
05F52:  ADDWFC 03,W
05F54:  MOVWF  FEA
05F56:  MOVF   FEF,W
05F58:  ADDWF  x65,W
05F5A:  MOVWF  01
05F5C:  MOVLW  00
05F5E:  ADDWFC x66,W
05F60:  MOVWF  03
05F62:  MOVF   01,W
05F64:  ADDLW  DC
05F66:  MOVWF  FE9
05F68:  MOVLW  01
05F6A:  ADDWFC 03,W
05F6C:  MOVWF  FEA
05F6E:  CLRF   FEF
....................          }
05F70:  BRA    5F88
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05F72:  MOVFF  4B1,665
05F76:  MOVLB  0
05F78:  CALL   10EE
....................             fprintf(SERIAL, retData);
05F7C:  MOVLW  04
05F7E:  MOVWF  FEA
05F80:  MOVLW  B2
05F82:  MOVWF  FE9
05F84:  RCALL  5A78
05F86:  MOVLB  6
....................          }
....................       }
05F88:  MOVLB  0
05F8A:  BRA    5A9C
05F8C:  MOVLB  5
....................    }          
05F8E:  MOVLB  0
05F90:  GOTO   B08A (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
01278:  MOVLB  6
0127A:  CLRF   x64
0127C:  MOVF   x64,W
0127E:  SUBLW  03
01280:  BNC   1290
....................    {
....................       resetSERcmd(i);
01282:  MOVFF  664,665
01286:  MOVLB  0
01288:  RCALL  10EE
0128A:  MOVLB  6
0128C:  INCF   x64,F
0128E:  BRA    127C
....................    }
....................    enable_interrupts(INT_RDA);
01290:  MOVLB  E
01292:  BSF    xC0.5
01294:  MOVLB  0
01296:  GOTO   B072 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
0129A:  MOVLB  E
0129C:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
0129E:  MOVLW  01
012A0:  MOVWF  FD1
012A2:  MOVLW  07
012A4:  MOVWF  FCE
012A6:  CLRF   FCF
012A8:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
012AA:  MOVLB  1
012AC:  CLRF   x5A
012AE:  CLRF   x59
012B0:  CLRF   x58
012B2:  CLRF   x57
....................    timeoutReg1 = 0;
012B4:  CLRF   x5E
012B6:  CLRF   x5D
012B8:  CLRF   x5C
012BA:  CLRF   x5B
....................    timeoutReg2 = 0;
012BC:  CLRF   x62
012BE:  CLRF   x61
012C0:  CLRF   x60
012C2:  CLRF   x5F
....................    intTimeoutReg = 50;
012C4:  CLRF   x64
012C6:  MOVLW  32
012C8:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
012CA:  MOVLB  E
012CC:  BSF    xC1.0
012CE:  MOVLB  0
012D0:  GOTO   B076 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025A:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025C:  MOVLW  0B
0025E:  MOVWF  FCD
00260:  MOVLW  DB
00262:  MOVWF  FCC
00264:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00266:  MOVLB  1
00268:  MOVF   x5A,F
0026A:  BNZ   027A
0026C:  MOVF   x59,F
0026E:  BNZ   027A
00270:  MOVF   x58,F
00272:  BNZ   027A
00274:  MOVF   x57,W
00276:  SUBLW  0A
00278:  BC    0288
0027A:  MOVLW  0A
0027C:  SUBWF  x57,F
0027E:  MOVLW  00
00280:  SUBWFB x58,F
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  BRA    0290
00288:  CLRF   x5A
0028A:  CLRF   x59
0028C:  CLRF   x58
0028E:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00290:  MOVF   x5E,F
00292:  BNZ   02A2
00294:  MOVF   x5D,F
00296:  BNZ   02A2
00298:  MOVF   x5C,F
0029A:  BNZ   02A2
0029C:  MOVF   x5B,W
0029E:  SUBLW  0A
002A0:  BC    02B0
002A2:  MOVLW  0A
002A4:  SUBWF  x5B,F
002A6:  MOVLW  00
002A8:  SUBWFB x5C,F
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  BRA    02B8
002B0:  CLRF   x5E
002B2:  CLRF   x5D
002B4:  CLRF   x5C
002B6:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002B8:  MOVF   x62,F
002BA:  BNZ   02CA
002BC:  MOVF   x61,F
002BE:  BNZ   02CA
002C0:  MOVF   x60,F
002C2:  BNZ   02CA
002C4:  MOVF   x5F,W
002C6:  SUBLW  0A
002C8:  BC    02D8
002CA:  MOVLW  0A
002CC:  SUBWF  x5F,F
002CE:  MOVLW  00
002D0:  SUBWFB x60,F
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  BRA    02E0
002D8:  CLRF   x62
002DA:  CLRF   x61
002DC:  CLRF   x60
002DE:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E0:  MOVF   x63,F
002E2:  BNZ   02E8
002E4:  MOVF   x64,F
002E6:  BZ    0324
....................    {
....................       timeCounter+=10;
002E8:  MOVLW  0A
002EA:  MOVLB  5
002EC:  ADDWF  x58,F
002EE:  MOVLW  00
002F0:  ADDWFC x59,F
002F2:  ADDWFC x5A,F
002F4:  ADDWFC x5B,F
....................       if (timeCounter >= intTimeoutReg)
002F6:  MOVF   x5B,F
002F8:  BNZ   0314
002FA:  MOVF   x5A,F
002FC:  BNZ   0314
002FE:  MOVLB  1
00300:  MOVF   x64,W
00302:  MOVLB  5
00304:  SUBWF  x59,W
00306:  BNC   0322
00308:  BNZ   0314
0030A:  MOVLB  1
0030C:  MOVF   x63,W
0030E:  MOVLB  5
00310:  SUBWF  x58,W
00312:  BNC   0322
....................       {
....................          sensor_monitor_interrupt_task();
00314:  MOVLB  0
00316:  BRA    01BE
....................          timeCounter = 0;
00318:  MOVLB  5
0031A:  CLRF   x5B
0031C:  CLRF   x5A
0031E:  CLRF   x59
00320:  CLRF   x58
00322:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00324:  MOVLB  E
00326:  BCF    xC9.0
00328:  MOVLB  0
0032A:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
06536:  MOVLW  04
06538:  MOVLB  6
0653A:  MOVWF  xA6
0653C:  MOVLW  B2
0653E:  MOVWF  xA5
06540:  MOVLB  0
06542:  RCALL  6446
06544:  MOVFF  02,03
06548:  MOVF   01,W
0654A:  ADDLW  B2
0654C:  MOVLB  6
0654E:  MOVWF  x6F
06550:  MOVLW  04
06552:  ADDWFC 02,W
06554:  MOVWF  x70
06556:  MOVFF  FE8,557
0655A:  MOVFF  66F,556
0655E:  MOVLW  2E
06560:  MOVWF  FF6
06562:  MOVLW  03
06564:  MOVWF  FF7
06566:  MOVLB  0
06568:  RCALL  6516
0656A:  MOVLW  2C
0656C:  MOVLB  6
0656E:  MOVWF  xB4
06570:  MOVLB  0
06572:  RCALL  64F6
....................    return SUCCESS;
06574:  MOVLW  00
06576:  MOVWF  01
06578:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
0657A:  MOVLW  04
0657C:  MOVLB  6
0657E:  MOVWF  xA6
06580:  MOVLW  B2
06582:  MOVWF  xA5
06584:  MOVLB  0
06586:  RCALL  6446
06588:  MOVFF  02,03
0658C:  MOVF   01,W
0658E:  ADDLW  B2
06590:  MOVLB  6
06592:  MOVWF  x6F
06594:  MOVLW  04
06596:  ADDWFC 02,W
06598:  MOVWF  x70
0659A:  MOVFF  FE8,557
0659E:  MOVFF  66F,556
065A2:  MOVLW  38
065A4:  MOVWF  FF6
065A6:  MOVLW  03
065A8:  MOVWF  FF7
065AA:  MOVLB  0
065AC:  RCALL  6516
065AE:  MOVLW  2C
065B0:  MOVLB  6
065B2:  MOVWF  xB4
065B4:  MOVLB  0
065B6:  RCALL  64F6
....................    return SUCCESS;
065B8:  MOVLW  00
065BA:  MOVWF  01
065BC:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06AC2:  MOVLB  6
06AC4:  CLRF   xB1
06AC6:  MOVFF  663,6B0
06ACA:  CLRF   xB3
06ACC:  MOVLW  B5
06ACE:  MOVWF  xB2
06AD0:  MOVLB  0
06AD2:  CALL   0802
06AD6:  MOVFF  02,671
06ADA:  MOVFF  01,670
06ADE:  MOVLW  06
06AE0:  MOVLB  6
06AE2:  ADDWF  x70,F
06AE4:  MOVLW  00
06AE6:  ADDWFC x71,F
06AE8:  MOVLW  32
06AEA:  ADDWF  x70,W
06AEC:  MOVWF  01
06AEE:  MOVLW  00
06AF0:  ADDWFC x71,W
06AF2:  MOVWF  03
06AF4:  MOVF   01,W
06AF6:  ADDLW  DC
06AF8:  MOVWF  01
06AFA:  MOVLW  01
06AFC:  ADDWFC 03,F
06AFE:  MOVFF  01,670
06B02:  MOVFF  03,671
06B06:  MOVFF  03,698
06B0A:  MOVFF  01,697
06B0E:  MOVLB  0
06B10:  RCALL  65BE
06B12:  MOVF   01,F
06B14:  BNZ   6B1E
06B16:  MOVLW  02
06B18:  MOVWF  01
06B1A:  BRA    6C5C
06B1C:  BRA    6B7A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06B1E:  MOVLB  6
06B20:  CLRF   xB1
06B22:  MOVFF  663,6B0
06B26:  CLRF   xB3
06B28:  MOVLW  B5
06B2A:  MOVWF  xB2
06B2C:  MOVLB  0
06B2E:  CALL   0802
06B32:  MOVFF  02,671
06B36:  MOVFF  01,670
06B3A:  MOVLW  06
06B3C:  MOVLB  6
06B3E:  ADDWF  x70,F
06B40:  MOVLW  00
06B42:  ADDWFC x71,F
06B44:  MOVLW  32
06B46:  ADDWF  x70,W
06B48:  MOVWF  01
06B4A:  MOVLW  00
06B4C:  ADDWFC x71,W
06B4E:  MOVWF  03
06B50:  MOVF   01,W
06B52:  ADDLW  DC
06B54:  MOVWF  01
06B56:  MOVLW  01
06B58:  ADDWFC 03,F
06B5A:  MOVFF  01,670
06B5E:  MOVFF  03,671
06B62:  MOVFF  03,698
06B66:  MOVFF  01,697
06B6A:  CLRF   x9A
06B6C:  CLRF   x99
06B6E:  MOVLW  0A
06B70:  MOVWF  x9B
06B72:  MOVLB  0
06B74:  RCALL  66AE
06B76:  MOVFF  01,66F
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
06B7A:  MOVLW  01
06B7C:  MOVLB  6
06B7E:  SUBWF  x6F,W
06B80:  MOVWF  x71
06B82:  CLRF   x73
06B84:  MOVLW  60
06B86:  MOVWF  x72
06B88:  MOVLB  0
06B8A:  CALL   5042
06B8E:  BTFSC  01.0
06B90:  BRA    6BE6
06B92:  MOVLW  04
06B94:  MOVLB  6
06B96:  MOVWF  xA6
06B98:  MOVLW  B2
06B9A:  MOVWF  xA5
06B9C:  MOVLB  0
06B9E:  RCALL  6446
06BA0:  MOVFF  02,03
06BA4:  MOVF   01,W
06BA6:  ADDLW  B2
06BA8:  MOVLB  6
06BAA:  MOVWF  x70
06BAC:  MOVLW  04
06BAE:  ADDWFC 02,W
06BB0:  MOVWF  x71
06BB2:  MOVFF  FE8,557
06BB6:  MOVFF  670,556
06BBA:  MOVFF  66F,698
06BBE:  MOVLW  18
06BC0:  MOVWF  x99
06BC2:  MOVLB  0
06BC4:  RCALL  6A02
06BC6:  MOVLW  2C
06BC8:  MOVLB  6
06BCA:  MOVWF  xB4
06BCC:  MOVLB  0
06BCE:  RCALL  64F6
06BD0:  MOVLW  58
06BD2:  MOVLB  6
06BD4:  MOVWF  xB4
06BD6:  MOVLB  0
06BD8:  RCALL  64F6
06BDA:  MOVLW  2C
06BDC:  MOVLB  6
06BDE:  MOVWF  xB4
06BE0:  MOVLB  0
06BE2:  RCALL  64F6
06BE4:  BRA    6C58
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
06BE6:  MOVLW  01
06BE8:  MOVLB  6
06BEA:  SUBWF  x6F,W
06BEC:  MOVWF  x71
06BEE:  CLRF   x73
06BF0:  MOVLW  60
06BF2:  MOVWF  x72
06BF4:  MOVLB  0
06BF6:  CALL   5042
06BFA:  BTFSS  01.0
06BFC:  BRA    6C52
06BFE:  MOVLW  04
06C00:  MOVLB  6
06C02:  MOVWF  xA6
06C04:  MOVLW  B2
06C06:  MOVWF  xA5
06C08:  MOVLB  0
06C0A:  RCALL  6446
06C0C:  MOVFF  02,03
06C10:  MOVF   01,W
06C12:  ADDLW  B2
06C14:  MOVLB  6
06C16:  MOVWF  x70
06C18:  MOVLW  04
06C1A:  ADDWFC 02,W
06C1C:  MOVWF  x71
06C1E:  MOVFF  FE8,557
06C22:  MOVFF  670,556
06C26:  MOVFF  66F,698
06C2A:  MOVLW  18
06C2C:  MOVWF  x99
06C2E:  MOVLB  0
06C30:  RCALL  6A02
06C32:  MOVLW  2C
06C34:  MOVLB  6
06C36:  MOVWF  xB4
06C38:  MOVLB  0
06C3A:  RCALL  64F6
06C3C:  MOVLW  59
06C3E:  MOVLB  6
06C40:  MOVWF  xB4
06C42:  MOVLB  0
06C44:  RCALL  64F6
06C46:  MOVLW  2C
06C48:  MOVLB  6
06C4A:  MOVWF  xB4
06C4C:  MOVLB  0
06C4E:  RCALL  64F6
06C50:  BRA    6C58
....................    else return INV_PARAM;
06C52:  MOVLW  02
06C54:  MOVWF  01
06C56:  BRA    6C5C
....................    
....................    return SUCCESS;
06C58:  MOVLW  00
06C5A:  MOVWF  01
06C5C:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06CA0:  MOVLB  6
06CA2:  CLRF   xB1
06CA4:  MOVFF  663,6B0
06CA8:  CLRF   xB3
06CAA:  MOVLW  B5
06CAC:  MOVWF  xB2
06CAE:  MOVLB  0
06CB0:  CALL   0802
06CB4:  MOVFF  02,672
06CB8:  MOVFF  01,671
06CBC:  MOVLW  06
06CBE:  MOVLB  6
06CC0:  ADDWF  x71,F
06CC2:  MOVLW  00
06CC4:  ADDWFC x72,F
06CC6:  MOVLW  32
06CC8:  ADDWF  x71,W
06CCA:  MOVWF  01
06CCC:  MOVLW  00
06CCE:  ADDWFC x72,W
06CD0:  MOVWF  03
06CD2:  MOVF   01,W
06CD4:  ADDLW  DC
06CD6:  MOVWF  01
06CD8:  MOVLW  01
06CDA:  ADDWFC 03,F
06CDC:  MOVFF  01,671
06CE0:  MOVFF  03,672
06CE4:  MOVFF  03,698
06CE8:  MOVFF  01,697
06CEC:  MOVLB  0
06CEE:  RCALL  65BE
06CF0:  MOVF   01,F
06CF2:  BNZ   6CFC
06CF4:  MOVLW  02
06CF6:  MOVWF  01
06CF8:  BRA    6E4C
06CFA:  BRA    6D58
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06CFC:  MOVLB  6
06CFE:  CLRF   xB1
06D00:  MOVFF  663,6B0
06D04:  CLRF   xB3
06D06:  MOVLW  B5
06D08:  MOVWF  xB2
06D0A:  MOVLB  0
06D0C:  CALL   0802
06D10:  MOVFF  02,672
06D14:  MOVFF  01,671
06D18:  MOVLW  06
06D1A:  MOVLB  6
06D1C:  ADDWF  x71,F
06D1E:  MOVLW  00
06D20:  ADDWFC x72,F
06D22:  MOVLW  32
06D24:  ADDWF  x71,W
06D26:  MOVWF  01
06D28:  MOVLW  00
06D2A:  ADDWFC x72,W
06D2C:  MOVWF  03
06D2E:  MOVF   01,W
06D30:  ADDLW  DC
06D32:  MOVWF  01
06D34:  MOVLW  01
06D36:  ADDWFC 03,F
06D38:  MOVFF  01,671
06D3C:  MOVFF  03,672
06D40:  MOVFF  03,698
06D44:  MOVFF  01,697
06D48:  CLRF   x9A
06D4A:  CLRF   x99
06D4C:  MOVLW  0A
06D4E:  MOVWF  x9B
06D50:  MOVLB  0
06D52:  RCALL  66AE
06D54:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06D58:  MOVLB  6
06D5A:  CLRF   xB1
06D5C:  MOVFF  663,6B0
06D60:  CLRF   xB3
06D62:  MOVLW  B5
06D64:  MOVWF  xB2
06D66:  MOVLB  0
06D68:  CALL   0802
06D6C:  MOVFF  02,672
06D70:  MOVFF  01,671
06D74:  MOVLW  06
06D76:  MOVLB  6
06D78:  ADDWF  x71,F
06D7A:  MOVLW  00
06D7C:  ADDWFC x72,F
06D7E:  MOVLW  4B
06D80:  ADDWF  x71,W
06D82:  MOVWF  01
06D84:  MOVLW  00
06D86:  ADDWFC x72,W
06D88:  MOVWF  03
06D8A:  MOVF   01,W
06D8C:  ADDLW  DC
06D8E:  MOVWF  01
06D90:  MOVLW  01
06D92:  ADDWFC 03,F
06D94:  MOVFF  01,671
06D98:  MOVFF  03,672
06D9C:  MOVFF  03,6A6
06DA0:  MOVFF  01,6A5
06DA4:  MOVLB  0
06DA6:  CALL   6446
06DAA:  MOVFF  02,03
06DAE:  MOVF   01,W
06DB0:  SUBLW  01
06DB2:  BNZ   6DB8
06DB4:  MOVF   03,F
06DB6:  BZ    6DC0
06DB8:  MOVLW  02
06DBA:  MOVWF  01
06DBC:  BRA    6E4C
06DBE:  BRA    6E00
....................    else arg2 = SERcmd[rec].p[3][0];
06DC0:  MOVLB  6
06DC2:  CLRF   xB1
06DC4:  MOVFF  663,6B0
06DC8:  CLRF   xB3
06DCA:  MOVLW  B5
06DCC:  MOVWF  xB2
06DCE:  MOVLB  0
06DD0:  CALL   0802
06DD4:  MOVFF  02,672
06DD8:  MOVFF  01,671
06DDC:  MOVLW  06
06DDE:  MOVLB  6
06DE0:  ADDWF  x71,F
06DE2:  MOVLW  00
06DE4:  ADDWFC x72,F
06DE6:  MOVLW  4B
06DE8:  ADDWF  x71,F
06DEA:  MOVLW  00
06DEC:  ADDWFC x72,F
06DEE:  MOVLW  DC
06DF0:  ADDWF  x71,W
06DF2:  MOVWF  FE9
06DF4:  MOVLW  01
06DF6:  ADDWFC x72,W
06DF8:  MOVWF  FEA
06DFA:  MOVFF  FEF,670
06DFE:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06E00:  MOVLB  6
06E02:  MOVF   x70,W
06E04:  SUBLW  58
06E06:  BNZ   6E20
06E08:  MOVLW  01
06E0A:  SUBWF  x6F,W
06E0C:  MOVWF  x71
06E0E:  MOVWF  x86
06E10:  CLRF   x87
06E12:  CLRF   x89
06E14:  MOVLW  60
06E16:  MOVWF  x88
06E18:  MOVLB  0
06E1A:  RCALL  6C5E
06E1C:  BRA    6E48
06E1E:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06E20:  MOVF   x70,W
06E22:  SUBLW  59
06E24:  BNZ   6E40
06E26:  MOVLW  01
06E28:  SUBWF  x6F,W
06E2A:  MOVWF  x71
06E2C:  MOVWF  x86
06E2E:  MOVLW  01
06E30:  MOVWF  x87
06E32:  CLRF   x89
06E34:  MOVLW  60
06E36:  MOVWF  x88
06E38:  MOVLB  0
06E3A:  RCALL  6C5E
06E3C:  BRA    6E48
06E3E:  MOVLB  6
....................    else return INV_PARAM;
06E40:  MOVLW  02
06E42:  MOVWF  01
06E44:  MOVLB  0
06E46:  BRA    6E4C
....................    
....................    return SUCCESS;
06E48:  MOVLW  00
06E4A:  MOVWF  01
06E4C:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06E78:  MOVLB  6
06E7A:  CLRF   xB1
06E7C:  MOVFF  663,6B0
06E80:  CLRF   xB3
06E82:  MOVLW  B5
06E84:  MOVWF  xB2
06E86:  MOVLB  0
06E88:  CALL   0802
06E8C:  MOVFF  02,671
06E90:  MOVFF  01,670
06E94:  MOVLW  06
06E96:  MOVLB  6
06E98:  ADDWF  x70,F
06E9A:  MOVLW  00
06E9C:  ADDWFC x71,F
06E9E:  MOVLW  32
06EA0:  ADDWF  x70,W
06EA2:  MOVWF  01
06EA4:  MOVLW  00
06EA6:  ADDWFC x71,W
06EA8:  MOVWF  03
06EAA:  MOVF   01,W
06EAC:  ADDLW  DC
06EAE:  MOVWF  01
06EB0:  MOVLW  01
06EB2:  ADDWFC 03,F
06EB4:  MOVFF  01,670
06EB8:  MOVFF  03,671
06EBC:  MOVFF  03,698
06EC0:  MOVFF  01,697
06EC4:  MOVLB  0
06EC6:  CALL   65BE
06ECA:  MOVF   01,F
06ECC:  BNZ   6ED6
06ECE:  MOVLW  02
06ED0:  MOVWF  01
06ED2:  BRA    7002
06ED4:  BRA    6F34
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06ED6:  MOVLB  6
06ED8:  CLRF   xB1
06EDA:  MOVFF  663,6B0
06EDE:  CLRF   xB3
06EE0:  MOVLW  B5
06EE2:  MOVWF  xB2
06EE4:  MOVLB  0
06EE6:  CALL   0802
06EEA:  MOVFF  02,671
06EEE:  MOVFF  01,670
06EF2:  MOVLW  06
06EF4:  MOVLB  6
06EF6:  ADDWF  x70,F
06EF8:  MOVLW  00
06EFA:  ADDWFC x71,F
06EFC:  MOVLW  32
06EFE:  ADDWF  x70,W
06F00:  MOVWF  01
06F02:  MOVLW  00
06F04:  ADDWFC x71,W
06F06:  MOVWF  03
06F08:  MOVF   01,W
06F0A:  ADDLW  DC
06F0C:  MOVWF  01
06F0E:  MOVLW  01
06F10:  ADDWFC 03,F
06F12:  MOVFF  01,670
06F16:  MOVFF  03,671
06F1A:  MOVFF  03,698
06F1E:  MOVFF  01,697
06F22:  CLRF   x9A
06F24:  CLRF   x99
06F26:  MOVLW  0A
06F28:  MOVWF  x9B
06F2A:  MOVLB  0
06F2C:  CALL   66AE
06F30:  MOVFF  01,66F
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06F34:  MOVLW  01
06F36:  MOVLB  6
06F38:  SUBWF  x6F,W
06F3A:  MOVWF  x71
06F3C:  CLRF   x73
06F3E:  MOVLW  61
06F40:  MOVWF  x72
06F42:  MOVLB  0
06F44:  CALL   5042
06F48:  BTFSC  01.0
06F4A:  BRA    6F96
06F4C:  MOVLW  04
06F4E:  MOVLB  6
06F50:  MOVWF  xA6
06F52:  MOVLW  B2
06F54:  MOVWF  xA5
06F56:  MOVLB  0
06F58:  CALL   6446
06F5C:  MOVFF  02,03
06F60:  MOVF   01,W
06F62:  ADDLW  B2
06F64:  MOVLB  6
06F66:  MOVWF  x70
06F68:  MOVLW  04
06F6A:  ADDWFC 02,W
06F6C:  MOVWF  x71
06F6E:  MOVFF  FE8,557
06F72:  MOVFF  670,556
06F76:  MOVFF  66F,698
06F7A:  MOVLW  18
06F7C:  MOVWF  x99
06F7E:  MOVLB  0
06F80:  RCALL  6A02
06F82:  MOVLW  40
06F84:  MOVWF  FF6
06F86:  MOVLW  03
06F88:  MOVWF  FF7
06F8A:  MOVLW  08
06F8C:  MOVLB  6
06F8E:  MOVWF  x73
06F90:  MOVLB  0
06F92:  RCALL  6E4E
06F94:  BRA    6FFE
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06F96:  MOVLW  01
06F98:  MOVLB  6
06F9A:  SUBWF  x6F,W
06F9C:  MOVWF  x71
06F9E:  CLRF   x73
06FA0:  MOVLW  61
06FA2:  MOVWF  x72
06FA4:  MOVLB  0
06FA6:  CALL   5042
06FAA:  BTFSS  01.0
06FAC:  BRA    6FF8
06FAE:  MOVLW  04
06FB0:  MOVLB  6
06FB2:  MOVWF  xA6
06FB4:  MOVLW  B2
06FB6:  MOVWF  xA5
06FB8:  MOVLB  0
06FBA:  CALL   6446
06FBE:  MOVFF  02,03
06FC2:  MOVF   01,W
06FC4:  ADDLW  B2
06FC6:  MOVLB  6
06FC8:  MOVWF  x70
06FCA:  MOVLW  04
06FCC:  ADDWFC 02,W
06FCE:  MOVWF  x71
06FD0:  MOVFF  FE8,557
06FD4:  MOVFF  670,556
06FD8:  MOVFF  66F,698
06FDC:  MOVLW  18
06FDE:  MOVWF  x99
06FE0:  MOVLB  0
06FE2:  RCALL  6A02
06FE4:  MOVLW  4C
06FE6:  MOVWF  FF6
06FE8:  MOVLW  03
06FEA:  MOVWF  FF7
06FEC:  MOVLW  08
06FEE:  MOVLB  6
06FF0:  MOVWF  x73
06FF2:  MOVLB  0
06FF4:  RCALL  6E4E
06FF6:  BRA    6FFE
....................    else return INV_PARAM;
06FF8:  MOVLW  02
06FFA:  MOVWF  01
06FFC:  BRA    7002
....................    
....................    return SUCCESS;
06FFE:  MOVLW  00
07000:  MOVWF  01
07002:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
07004:  MOVLW  4D
07006:  MOVLB  6
07008:  MOVWF  x74
0700A:  MOVLW  41
0700C:  MOVWF  x75
0700E:  MOVLW  4E
07010:  MOVWF  x76
07012:  MOVLW  55
07014:  MOVWF  x77
07016:  MOVLW  41
07018:  MOVWF  x78
0701A:  MOVLW  4C
0701C:  MOVWF  x79
0701E:  CLRF   x7A
07020:  MOVLW  06
07022:  MOVWF  x73
07024:  MOVLW  74
07026:  MOVWF  x72
....................    char *s_magsns = "MAGSNS";
07028:  MOVLW  4D
0702A:  MOVWF  x7D
0702C:  MOVLW  41
0702E:  MOVWF  x7E
07030:  MOVLW  47
07032:  MOVWF  x7F
07034:  MOVLW  53
07036:  MOVWF  x80
07038:  MOVLW  4E
0703A:  MOVWF  x81
0703C:  MOVLW  53
0703E:  MOVWF  x82
07040:  CLRF   x83
07042:  MOVLW  06
07044:  MOVWF  x7C
07046:  MOVLW  7D
07048:  MOVWF  x7B
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0704A:  CLRF   xB1
0704C:  MOVFF  663,6B0
07050:  CLRF   xB3
07052:  MOVLW  B5
07054:  MOVWF  xB2
07056:  MOVLB  0
07058:  CALL   0802
0705C:  MOVFF  02,685
07060:  MOVFF  01,684
07064:  MOVLW  06
07066:  MOVLB  6
07068:  ADDWF  x84,F
0706A:  MOVLW  00
0706C:  ADDWFC x85,F
0706E:  MOVLW  32
07070:  ADDWF  x84,W
07072:  MOVWF  01
07074:  MOVLW  00
07076:  ADDWFC x85,W
07078:  MOVWF  03
0707A:  MOVF   01,W
0707C:  ADDLW  DC
0707E:  MOVWF  01
07080:  MOVLW  01
07082:  ADDWFC 03,F
07084:  MOVFF  01,684
07088:  MOVFF  03,685
0708C:  MOVFF  03,698
07090:  MOVFF  01,697
07094:  MOVLB  0
07096:  CALL   65BE
0709A:  MOVF   01,F
0709C:  BNZ   70A6
0709E:  MOVLW  02
070A0:  MOVWF  01
070A2:  BRA    721C
070A4:  BRA    7104
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
070A6:  MOVLB  6
070A8:  CLRF   xB1
070AA:  MOVFF  663,6B0
070AE:  CLRF   xB3
070B0:  MOVLW  B5
070B2:  MOVWF  xB2
070B4:  MOVLB  0
070B6:  CALL   0802
070BA:  MOVFF  02,685
070BE:  MOVFF  01,684
070C2:  MOVLW  06
070C4:  MOVLB  6
070C6:  ADDWF  x84,F
070C8:  MOVLW  00
070CA:  ADDWFC x85,F
070CC:  MOVLW  32
070CE:  ADDWF  x84,W
070D0:  MOVWF  01
070D2:  MOVLW  00
070D4:  ADDWFC x85,W
070D6:  MOVWF  03
070D8:  MOVF   01,W
070DA:  ADDLW  DC
070DC:  MOVWF  01
070DE:  MOVLW  01
070E0:  ADDWFC 03,F
070E2:  MOVFF  01,684
070E6:  MOVFF  03,685
070EA:  MOVFF  03,698
070EE:  MOVFF  01,697
070F2:  CLRF   x9A
070F4:  CLRF   x99
070F6:  MOVLW  0A
070F8:  MOVWF  x9B
070FA:  MOVLB  0
070FC:  CALL   66AE
07100:  MOVFF  01,66F
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
07104:  MOVLB  6
07106:  CLRF   xB1
07108:  MOVFF  663,6B0
0710C:  CLRF   xB3
0710E:  MOVLW  B5
07110:  MOVWF  xB2
07112:  MOVLB  0
07114:  CALL   0802
07118:  MOVFF  02,685
0711C:  MOVFF  01,684
07120:  MOVLW  06
07122:  MOVLB  6
07124:  ADDWF  x84,F
07126:  MOVLW  00
07128:  ADDWFC x85,F
0712A:  MOVLW  4B
0712C:  ADDWF  x84,W
0712E:  MOVWF  01
07130:  MOVLW  00
07132:  ADDWFC x85,W
07134:  MOVWF  03
07136:  MOVF   01,W
07138:  ADDLW  DC
0713A:  MOVWF  01
0713C:  MOVLW  01
0713E:  ADDWFC 03,F
07140:  MOVFF  01,684
07144:  MOVFF  03,685
07148:  MOVFF  03,6A6
0714C:  MOVFF  01,6A5
07150:  MOVLB  0
07152:  CALL   6446
07156:  MOVFF  02,03
0715A:  MOVF   01,W
0715C:  BNZ   716A
0715E:  MOVF   03,F
07160:  BNZ   716A
07162:  MOVLW  02
07164:  MOVWF  01
07166:  BRA    721C
07168:  BRA    71B0
....................    else arg2 = SERcmd[rec].p[3];
0716A:  MOVLB  6
0716C:  CLRF   xB1
0716E:  MOVFF  663,6B0
07172:  CLRF   xB3
07174:  MOVLW  B5
07176:  MOVWF  xB2
07178:  MOVLB  0
0717A:  CALL   0802
0717E:  MOVFF  02,685
07182:  MOVFF  01,684
07186:  MOVLW  06
07188:  MOVLB  6
0718A:  ADDWF  x84,F
0718C:  MOVLW  00
0718E:  ADDWFC x85,F
07190:  MOVLW  4B
07192:  ADDWF  x84,W
07194:  MOVWF  01
07196:  MOVLW  00
07198:  ADDWFC x85,W
0719A:  MOVWF  03
0719C:  MOVF   01,W
0719E:  ADDLW  DC
071A0:  MOVWF  01
071A2:  MOVLW  01
071A4:  ADDWFC 03,F
071A6:  MOVFF  01,670
071AA:  MOVFF  03,671
071AE:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
071B0:  MOVFF  673,6A6
071B4:  MOVFF  672,6A5
071B8:  MOVFF  671,6A8
071BC:  MOVFF  670,6A7
071C0:  CALL   647E
071C4:  MOVF   01,F
071C6:  BNZ   71E0
071C8:  MOVLW  01
071CA:  MOVLB  6
071CC:  SUBWF  x6F,W
071CE:  MOVWF  x84
071D0:  MOVWF  x86
071D2:  CLRF   x87
071D4:  CLRF   x89
071D6:  MOVLW  61
071D8:  MOVWF  x88
071DA:  MOVLB  0
071DC:  RCALL  6C5E
071DE:  BRA    7218
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
071E0:  MOVFF  67C,6A6
071E4:  MOVFF  67B,6A5
071E8:  MOVFF  671,6A8
071EC:  MOVFF  670,6A7
071F0:  CALL   647E
071F4:  MOVF   01,F
071F6:  BNZ   7212
071F8:  MOVLW  01
071FA:  MOVLB  6
071FC:  SUBWF  x6F,W
071FE:  MOVWF  x84
07200:  MOVWF  x86
07202:  MOVLW  01
07204:  MOVWF  x87
07206:  CLRF   x89
07208:  MOVLW  61
0720A:  MOVWF  x88
0720C:  MOVLB  0
0720E:  RCALL  6C5E
07210:  BRA    7218
....................    else return INV_PARAM;
07212:  MOVLW  02
07214:  MOVWF  01
07216:  BRA    721C
....................    
....................    return SUCCESS;
07218:  MOVLW  00
0721A:  MOVWF  01
0721C:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
073D4:  MOVLB  6
073D6:  CLRF   xB1
073D8:  MOVFF  663,6B0
073DC:  CLRF   xB3
073DE:  MOVLW  B5
073E0:  MOVWF  xB2
073E2:  MOVLB  0
073E4:  CALL   0802
073E8:  MOVFF  02,672
073EC:  MOVFF  01,671
073F0:  MOVLW  06
073F2:  MOVLB  6
073F4:  ADDWF  x71,F
073F6:  MOVLW  00
073F8:  ADDWFC x72,F
073FA:  MOVLW  32
073FC:  ADDWF  x71,W
073FE:  MOVWF  01
07400:  MOVLW  00
07402:  ADDWFC x72,W
07404:  MOVWF  03
07406:  MOVF   01,W
07408:  ADDLW  DC
0740A:  MOVWF  01
0740C:  MOVLW  01
0740E:  ADDWFC 03,F
07410:  MOVFF  01,671
07414:  MOVFF  03,672
07418:  MOVFF  03,698
0741C:  MOVFF  01,697
07420:  MOVLB  0
07422:  CALL   65BE
07426:  MOVF   01,F
07428:  BNZ   7432
0742A:  MOVLW  02
0742C:  MOVWF  01
0742E:  BRA    7888
07430:  BRA    7490
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07432:  MOVLB  6
07434:  CLRF   xB1
07436:  MOVFF  663,6B0
0743A:  CLRF   xB3
0743C:  MOVLW  B5
0743E:  MOVWF  xB2
07440:  MOVLB  0
07442:  CALL   0802
07446:  MOVFF  02,672
0744A:  MOVFF  01,671
0744E:  MOVLW  06
07450:  MOVLB  6
07452:  ADDWF  x71,F
07454:  MOVLW  00
07456:  ADDWFC x72,F
07458:  MOVLW  32
0745A:  ADDWF  x71,W
0745C:  MOVWF  01
0745E:  MOVLW  00
07460:  ADDWFC x72,W
07462:  MOVWF  03
07464:  MOVF   01,W
07466:  ADDLW  DC
07468:  MOVWF  01
0746A:  MOVLW  01
0746C:  ADDWFC 03,F
0746E:  MOVFF  01,671
07472:  MOVFF  03,672
07476:  MOVFF  03,698
0747A:  MOVFF  01,697
0747E:  CLRF   x9A
07480:  CLRF   x99
07482:  MOVLW  0A
07484:  MOVWF  x9B
07486:  MOVLB  0
07488:  CALL   66AE
0748C:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07490:  MOVLB  6
07492:  CLRF   xB1
07494:  MOVFF  663,6B0
07498:  CLRF   xB3
0749A:  MOVLW  B5
0749C:  MOVWF  xB2
0749E:  MOVLB  0
074A0:  CALL   0802
074A4:  MOVFF  02,672
074A8:  MOVFF  01,671
074AC:  MOVLW  06
074AE:  MOVLB  6
074B0:  ADDWF  x71,F
074B2:  MOVLW  00
074B4:  ADDWFC x72,F
074B6:  MOVLW  4B
074B8:  ADDWF  x71,W
074BA:  MOVWF  01
074BC:  MOVLW  00
074BE:  ADDWFC x72,W
074C0:  MOVWF  03
074C2:  MOVF   01,W
074C4:  ADDLW  DC
074C6:  MOVWF  01
074C8:  MOVLW  01
074CA:  ADDWFC 03,F
074CC:  MOVFF  01,671
074D0:  MOVFF  03,672
074D4:  MOVFF  03,6A6
074D8:  MOVFF  01,6A5
074DC:  MOVLB  0
074DE:  CALL   6446
074E2:  MOVFF  02,03
074E6:  MOVF   01,W
074E8:  SUBLW  01
074EA:  BNZ   74F0
074EC:  MOVF   03,F
074EE:  BZ    74F8
074F0:  MOVLW  02
074F2:  MOVWF  01
074F4:  BRA    7888
074F6:  BRA    7538
....................    else arg2 = SERcmd[rec].p[3][0];
074F8:  MOVLB  6
074FA:  CLRF   xB1
074FC:  MOVFF  663,6B0
07500:  CLRF   xB3
07502:  MOVLW  B5
07504:  MOVWF  xB2
07506:  MOVLB  0
07508:  CALL   0802
0750C:  MOVFF  02,672
07510:  MOVFF  01,671
07514:  MOVLW  06
07516:  MOVLB  6
07518:  ADDWF  x71,F
0751A:  MOVLW  00
0751C:  ADDWFC x72,F
0751E:  MOVLW  4B
07520:  ADDWF  x71,F
07522:  MOVLW  00
07524:  ADDWFC x72,F
07526:  MOVLW  DC
07528:  ADDWF  x71,W
0752A:  MOVWF  FE9
0752C:  MOVLW  01
0752E:  ADDWFC x72,W
07530:  MOVWF  FEA
07532:  MOVFF  FEF,670
07536:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
07538:  MOVLB  6
0753A:  MOVF   x70,W
0753C:  SUBLW  50
0753E:  BNZ   75D8
07540:  MOVLW  04
07542:  MOVWF  xA6
07544:  MOVLW  B2
07546:  MOVWF  xA5
07548:  MOVLB  0
0754A:  CALL   6446
0754E:  MOVFF  02,03
07552:  MOVF   01,W
07554:  ADDLW  B2
07556:  MOVLB  6
07558:  MOVWF  x71
0755A:  MOVLW  04
0755C:  ADDWFC 02,W
0755E:  MOVWF  x72
07560:  MOVLW  01
07562:  SUBWF  x6F,W
07564:  MULLW  20
07566:  MOVF   FF3,W
07568:  CLRF   x74
0756A:  MOVWF  x73
0756C:  MOVLW  20
0756E:  ADDWF  x73,W
07570:  MOVWF  FE9
07572:  MOVLW  00
07574:  ADDWFC x74,W
07576:  MOVWF  FEA
07578:  MOVFF  FEF,675
0757C:  MOVFF  FEC,676
07580:  MOVFF  FEC,677
07584:  MOVFF  FEC,678
07588:  MOVFF  672,557
0758C:  MOVFF  671,556
07590:  MOVFF  66F,698
07594:  MOVLW  18
07596:  MOVWF  x99
07598:  MOVLB  0
0759A:  CALL   6A02
0759E:  MOVLW  2C
075A0:  MOVLB  6
075A2:  MOVWF  xB4
075A4:  MOVLB  0
075A6:  CALL   64F6
075AA:  MOVLW  89
075AC:  MOVWF  FE9
075AE:  MOVFF  678,6AA
075B2:  MOVFF  677,6A9
075B6:  MOVFF  676,6A8
075BA:  MOVFF  675,6A7
075BE:  MOVLW  02
075C0:  MOVLB  6
075C2:  MOVWF  xAB
075C4:  MOVLB  0
075C6:  RCALL  721E
075C8:  MOVLW  2C
075CA:  MOVLB  6
075CC:  MOVWF  xB4
075CE:  MOVLB  0
075D0:  CALL   64F6
075D4:  BRA    7884
075D6:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
075D8:  MOVF   x70,W
075DA:  SUBLW  49
075DC:  BNZ   767E
075DE:  MOVLW  04
075E0:  MOVWF  xA6
075E2:  MOVLW  B2
075E4:  MOVWF  xA5
075E6:  MOVLB  0
075E8:  CALL   6446
075EC:  MOVF   01,W
075EE:  ADDLW  B2
075F0:  MOVLB  6
075F2:  MOVWF  x71
075F4:  MOVLW  04
075F6:  ADDWFC 02,W
075F8:  MOVWF  x72
075FA:  MOVLW  01
075FC:  SUBWF  x6F,W
075FE:  MULLW  20
07600:  MOVF   FF3,W
07602:  CLRF   x74
07604:  MOVWF  x73
07606:  MOVLW  04
07608:  ADDWF  x73,W
0760A:  MOVWF  01
0760C:  MOVLW  00
0760E:  ADDWFC x74,W
07610:  MOVWF  03
07612:  MOVF   01,W
07614:  ADDLW  20
07616:  MOVWF  FE9
07618:  MOVLW  00
0761A:  ADDWFC 03,W
0761C:  MOVWF  FEA
0761E:  MOVFF  FEF,673
07622:  MOVFF  FEC,674
07626:  MOVFF  FEC,675
0762A:  MOVFF  FEC,676
0762E:  MOVFF  672,557
07632:  MOVFF  671,556
07636:  MOVFF  66F,698
0763A:  MOVLW  18
0763C:  MOVWF  x99
0763E:  MOVLB  0
07640:  CALL   6A02
07644:  MOVLW  2C
07646:  MOVLB  6
07648:  MOVWF  xB4
0764A:  MOVLB  0
0764C:  CALL   64F6
07650:  MOVLW  89
07652:  MOVWF  FE9
07654:  MOVFF  676,6AA
07658:  MOVFF  675,6A9
0765C:  MOVFF  674,6A8
07660:  MOVFF  673,6A7
07664:  MOVLW  02
07666:  MOVLB  6
07668:  MOVWF  xAB
0766A:  MOVLB  0
0766C:  RCALL  721E
0766E:  MOVLW  2C
07670:  MOVLB  6
07672:  MOVWF  xB4
07674:  MOVLB  0
07676:  CALL   64F6
0767A:  BRA    7884
0767C:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
0767E:  MOVF   x70,W
07680:  SUBLW  44
07682:  BNZ   7724
07684:  MOVLW  04
07686:  MOVWF  xA6
07688:  MOVLW  B2
0768A:  MOVWF  xA5
0768C:  MOVLB  0
0768E:  CALL   6446
07692:  MOVF   01,W
07694:  ADDLW  B2
07696:  MOVLB  6
07698:  MOVWF  x71
0769A:  MOVLW  04
0769C:  ADDWFC 02,W
0769E:  MOVWF  x72
076A0:  MOVLW  01
076A2:  SUBWF  x6F,W
076A4:  MULLW  20
076A6:  MOVF   FF3,W
076A8:  CLRF   x74
076AA:  MOVWF  x73
076AC:  MOVLW  08
076AE:  ADDWF  x73,W
076B0:  MOVWF  01
076B2:  MOVLW  00
076B4:  ADDWFC x74,W
076B6:  MOVWF  03
076B8:  MOVF   01,W
076BA:  ADDLW  20
076BC:  MOVWF  FE9
076BE:  MOVLW  00
076C0:  ADDWFC 03,W
076C2:  MOVWF  FEA
076C4:  MOVFF  FEF,673
076C8:  MOVFF  FEC,674
076CC:  MOVFF  FEC,675
076D0:  MOVFF  FEC,676
076D4:  MOVFF  672,557
076D8:  MOVFF  671,556
076DC:  MOVFF  66F,698
076E0:  MOVLW  18
076E2:  MOVWF  x99
076E4:  MOVLB  0
076E6:  CALL   6A02
076EA:  MOVLW  2C
076EC:  MOVLB  6
076EE:  MOVWF  xB4
076F0:  MOVLB  0
076F2:  CALL   64F6
076F6:  MOVLW  89
076F8:  MOVWF  FE9
076FA:  MOVFF  676,6AA
076FE:  MOVFF  675,6A9
07702:  MOVFF  674,6A8
07706:  MOVFF  673,6A7
0770A:  MOVLW  02
0770C:  MOVLB  6
0770E:  MOVWF  xAB
07710:  MOVLB  0
07712:  RCALL  721E
07714:  MOVLW  2C
07716:  MOVLB  6
07718:  MOVWF  xB4
0771A:  MOVLB  0
0771C:  CALL   64F6
07720:  BRA    7884
07722:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
07724:  MOVF   x70,W
07726:  SUBLW  41
07728:  BTFSS  FD8.2
0772A:  BRA    787C
0772C:  MOVLW  04
0772E:  MOVWF  xA6
07730:  MOVLW  B2
07732:  MOVWF  xA5
07734:  MOVLB  0
07736:  CALL   6446
0773A:  MOVF   01,W
0773C:  ADDLW  B2
0773E:  MOVLB  6
07740:  MOVWF  x71
07742:  MOVLW  04
07744:  ADDWFC 02,W
07746:  MOVWF  x72
07748:  MOVLW  01
0774A:  SUBWF  x6F,W
0774C:  MULLW  20
0774E:  MOVF   FF3,W
07750:  CLRF   x74
07752:  MOVWF  x73
07754:  MOVLW  20
07756:  ADDWF  x73,W
07758:  MOVWF  FE9
0775A:  MOVLW  00
0775C:  ADDWFC x74,W
0775E:  MOVWF  FEA
07760:  MOVFF  FEF,675
07764:  MOVFF  FEC,676
07768:  MOVFF  FEC,677
0776C:  MOVFF  FEC,678
07770:  MOVLW  01
07772:  SUBWF  x6F,W
07774:  MULLW  20
07776:  MOVF   FF3,W
07778:  CLRF   x7A
0777A:  MOVWF  x79
0777C:  MOVLW  04
0777E:  ADDWF  x79,W
07780:  MOVWF  01
07782:  MOVLW  00
07784:  ADDWFC x7A,W
07786:  MOVWF  03
07788:  MOVF   01,W
0778A:  ADDLW  20
0778C:  MOVWF  FE9
0778E:  MOVLW  00
07790:  ADDWFC 03,W
07792:  MOVWF  FEA
07794:  MOVFF  FEF,679
07798:  MOVFF  FEC,67A
0779C:  MOVFF  FEC,67B
077A0:  MOVFF  FEC,67C
077A4:  MOVLW  01
077A6:  SUBWF  x6F,W
077A8:  MULLW  20
077AA:  MOVF   FF3,W
077AC:  CLRF   x7E
077AE:  MOVWF  x7D
077B0:  MOVLW  08
077B2:  ADDWF  x7D,W
077B4:  MOVWF  01
077B6:  MOVLW  00
077B8:  ADDWFC x7E,W
077BA:  MOVWF  03
077BC:  MOVF   01,W
077BE:  ADDLW  20
077C0:  MOVWF  FE9
077C2:  MOVLW  00
077C4:  ADDWFC 03,W
077C6:  MOVWF  FEA
077C8:  MOVFF  FEF,67D
077CC:  MOVFF  FEC,67E
077D0:  MOVFF  FEC,67F
077D4:  MOVFF  FEC,680
077D8:  MOVFF  672,557
077DC:  MOVFF  671,556
077E0:  MOVFF  66F,698
077E4:  MOVLW  18
077E6:  MOVWF  x99
077E8:  MOVLB  0
077EA:  CALL   6A02
077EE:  MOVLW  2C
077F0:  MOVLB  6
077F2:  MOVWF  xB4
077F4:  MOVLB  0
077F6:  CALL   64F6
077FA:  MOVLW  89
077FC:  MOVWF  FE9
077FE:  MOVFF  678,6AA
07802:  MOVFF  677,6A9
07806:  MOVFF  676,6A8
0780A:  MOVFF  675,6A7
0780E:  MOVLW  02
07810:  MOVLB  6
07812:  MOVWF  xAB
07814:  MOVLB  0
07816:  RCALL  721E
07818:  MOVLW  2C
0781A:  MOVLB  6
0781C:  MOVWF  xB4
0781E:  MOVLB  0
07820:  CALL   64F6
07824:  MOVLW  89
07826:  MOVWF  FE9
07828:  MOVFF  67C,6AA
0782C:  MOVFF  67B,6A9
07830:  MOVFF  67A,6A8
07834:  MOVFF  679,6A7
07838:  MOVLW  02
0783A:  MOVLB  6
0783C:  MOVWF  xAB
0783E:  MOVLB  0
07840:  RCALL  721E
07842:  MOVLW  2C
07844:  MOVLB  6
07846:  MOVWF  xB4
07848:  MOVLB  0
0784A:  CALL   64F6
0784E:  MOVLW  89
07850:  MOVWF  FE9
07852:  MOVFF  680,6AA
07856:  MOVFF  67F,6A9
0785A:  MOVFF  67E,6A8
0785E:  MOVFF  67D,6A7
07862:  MOVLW  02
07864:  MOVLB  6
07866:  MOVWF  xAB
07868:  MOVLB  0
0786A:  RCALL  721E
0786C:  MOVLW  2C
0786E:  MOVLB  6
07870:  MOVWF  xB4
07872:  MOVLB  0
07874:  CALL   64F6
07878:  BRA    7884
0787A:  MOVLB  6
....................    else return INV_PARAM;
0787C:  MOVLW  02
0787E:  MOVWF  01
07880:  MOVLB  0
07882:  BRA    7888
....................    
....................    return SUCCESS;
07884:  MOVLW  00
07886:  MOVWF  01
07888:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
07BA6:  MOVLB  6
07BA8:  CLRF   xB1
07BAA:  MOVFF  663,6B0
07BAE:  CLRF   xB3
07BB0:  MOVLW  B5
07BB2:  MOVWF  xB2
07BB4:  MOVLB  0
07BB6:  CALL   0802
07BBA:  MOVFF  02,676
07BBE:  MOVFF  01,675
07BC2:  MOVLW  06
07BC4:  MOVLB  6
07BC6:  ADDWF  x75,F
07BC8:  MOVLW  00
07BCA:  ADDWFC x76,F
07BCC:  MOVLW  32
07BCE:  ADDWF  x75,W
07BD0:  MOVWF  01
07BD2:  MOVLW  00
07BD4:  ADDWFC x76,W
07BD6:  MOVWF  03
07BD8:  MOVF   01,W
07BDA:  ADDLW  DC
07BDC:  MOVWF  01
07BDE:  MOVLW  01
07BE0:  ADDWFC 03,F
07BE2:  MOVFF  01,675
07BE6:  MOVFF  03,676
07BEA:  MOVFF  03,698
07BEE:  MOVFF  01,697
07BF2:  MOVLB  0
07BF4:  CALL   65BE
07BF8:  MOVF   01,F
07BFA:  BNZ   7C04
07BFC:  MOVLW  02
07BFE:  MOVWF  01
07C00:  BRA    7E84
07C02:  BRA    7C62
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07C04:  MOVLB  6
07C06:  CLRF   xB1
07C08:  MOVFF  663,6B0
07C0C:  CLRF   xB3
07C0E:  MOVLW  B5
07C10:  MOVWF  xB2
07C12:  MOVLB  0
07C14:  CALL   0802
07C18:  MOVFF  02,676
07C1C:  MOVFF  01,675
07C20:  MOVLW  06
07C22:  MOVLB  6
07C24:  ADDWF  x75,F
07C26:  MOVLW  00
07C28:  ADDWFC x76,F
07C2A:  MOVLW  32
07C2C:  ADDWF  x75,W
07C2E:  MOVWF  01
07C30:  MOVLW  00
07C32:  ADDWFC x76,W
07C34:  MOVWF  03
07C36:  MOVF   01,W
07C38:  ADDLW  DC
07C3A:  MOVWF  01
07C3C:  MOVLW  01
07C3E:  ADDWFC 03,F
07C40:  MOVFF  01,675
07C44:  MOVFF  03,676
07C48:  MOVFF  03,698
07C4C:  MOVFF  01,697
07C50:  CLRF   x9A
07C52:  CLRF   x99
07C54:  MOVLW  0A
07C56:  MOVWF  x9B
07C58:  MOVLB  0
07C5A:  CALL   66AE
07C5E:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07C62:  MOVLB  6
07C64:  CLRF   xB1
07C66:  MOVFF  663,6B0
07C6A:  CLRF   xB3
07C6C:  MOVLW  B5
07C6E:  MOVWF  xB2
07C70:  MOVLB  0
07C72:  CALL   0802
07C76:  MOVFF  02,676
07C7A:  MOVFF  01,675
07C7E:  MOVLW  06
07C80:  MOVLB  6
07C82:  ADDWF  x75,F
07C84:  MOVLW  00
07C86:  ADDWFC x76,F
07C88:  MOVLW  4B
07C8A:  ADDWF  x75,W
07C8C:  MOVWF  01
07C8E:  MOVLW  00
07C90:  ADDWFC x76,W
07C92:  MOVWF  03
07C94:  MOVF   01,W
07C96:  ADDLW  DC
07C98:  MOVWF  01
07C9A:  MOVLW  01
07C9C:  ADDWFC 03,F
07C9E:  MOVFF  01,675
07CA2:  MOVFF  03,676
07CA6:  MOVFF  03,6A6
07CAA:  MOVFF  01,6A5
07CAE:  MOVLB  0
07CB0:  CALL   6446
07CB4:  MOVFF  02,03
07CB8:  MOVF   01,W
07CBA:  SUBLW  01
07CBC:  BNZ   7CC2
07CBE:  MOVF   03,F
07CC0:  BZ    7CCA
07CC2:  MOVLW  02
07CC4:  MOVWF  01
07CC6:  BRA    7E84
07CC8:  BRA    7D0A
....................    else arg2 = SERcmd[rec].p[3][0];
07CCA:  MOVLB  6
07CCC:  CLRF   xB1
07CCE:  MOVFF  663,6B0
07CD2:  CLRF   xB3
07CD4:  MOVLW  B5
07CD6:  MOVWF  xB2
07CD8:  MOVLB  0
07CDA:  CALL   0802
07CDE:  MOVFF  02,676
07CE2:  MOVFF  01,675
07CE6:  MOVLW  06
07CE8:  MOVLB  6
07CEA:  ADDWF  x75,F
07CEC:  MOVLW  00
07CEE:  ADDWFC x76,F
07CF0:  MOVLW  4B
07CF2:  ADDWF  x75,F
07CF4:  MOVLW  00
07CF6:  ADDWFC x76,F
07CF8:  MOVLW  DC
07CFA:  ADDWF  x75,W
07CFC:  MOVWF  FE9
07CFE:  MOVLW  01
07D00:  ADDWFC x76,W
07D02:  MOVWF  FEA
07D04:  MOVFF  FEF,670
07D08:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07D0A:  MOVLB  6
07D0C:  CLRF   xB1
07D0E:  MOVFF  663,6B0
07D12:  CLRF   xB3
07D14:  MOVLW  B5
07D16:  MOVWF  xB2
07D18:  MOVLB  0
07D1A:  CALL   0802
07D1E:  MOVFF  02,676
07D22:  MOVFF  01,675
07D26:  MOVLW  06
07D28:  MOVLB  6
07D2A:  ADDWF  x75,F
07D2C:  MOVLW  00
07D2E:  ADDWFC x76,F
07D30:  MOVLW  64
07D32:  ADDWF  x75,W
07D34:  MOVWF  01
07D36:  MOVLW  00
07D38:  ADDWFC x76,W
07D3A:  MOVWF  03
07D3C:  MOVF   01,W
07D3E:  ADDLW  DC
07D40:  MOVWF  01
07D42:  MOVLW  01
07D44:  ADDWFC 03,F
07D46:  MOVFF  01,675
07D4A:  MOVFF  03,676
07D4E:  MOVFF  03,679
07D52:  MOVFF  01,678
07D56:  MOVLB  0
07D58:  RCALL  788A
07D5A:  MOVF   01,F
07D5C:  BNZ   7D66
07D5E:  MOVLW  02
07D60:  MOVWF  01
07D62:  BRA    7E84
07D64:  BRA    7DCA
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07D66:  MOVLB  6
07D68:  CLRF   xB1
07D6A:  MOVFF  663,6B0
07D6E:  CLRF   xB3
07D70:  MOVLW  B5
07D72:  MOVWF  xB2
07D74:  MOVLB  0
07D76:  CALL   0802
07D7A:  MOVFF  02,676
07D7E:  MOVFF  01,675
07D82:  MOVLW  06
07D84:  MOVLB  6
07D86:  ADDWF  x75,F
07D88:  MOVLW  00
07D8A:  ADDWFC x76,F
07D8C:  MOVLW  64
07D8E:  ADDWF  x75,W
07D90:  MOVWF  01
07D92:  MOVLW  00
07D94:  ADDWFC x76,W
07D96:  MOVWF  03
07D98:  MOVF   01,W
07D9A:  ADDLW  DC
07D9C:  MOVWF  01
07D9E:  MOVLW  01
07DA0:  ADDWFC 03,F
07DA2:  MOVFF  01,675
07DA6:  MOVFF  03,676
07DAA:  MOVFF  03,679
07DAE:  MOVFF  01,678
07DB2:  CLRF   x7B
07DB4:  CLRF   x7A
07DB6:  MOVLB  0
07DB8:  RCALL  794C
07DBA:  MOVFF  03,674
07DBE:  MOVFF  02,673
07DC2:  MOVFF  01,672
07DC6:  MOVFF  00,671
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07DCA:  MOVLB  6
07DCC:  MOVF   x70,W
07DCE:  SUBLW  50
07DD0:  BNZ   7DFC
07DD2:  MOVLW  01
07DD4:  SUBWF  x6F,W
07DD6:  MULLW  20
07DD8:  MOVF   FF3,W
07DDA:  CLRF   x76
07DDC:  MOVWF  x75
07DDE:  MOVLW  20
07DE0:  ADDWF  x75,W
07DE2:  MOVWF  FE9
07DE4:  MOVLW  00
07DE6:  ADDWFC x76,W
07DE8:  MOVWF  FEA
07DEA:  MOVFF  671,FEF
07DEE:  MOVFF  672,FEC
07DF2:  MOVFF  673,FEC
07DF6:  MOVFF  674,FEC
07DFA:  BRA    7E7E
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07DFC:  MOVF   x70,W
07DFE:  SUBLW  49
07E00:  BNZ   7E38
07E02:  MOVLW  01
07E04:  SUBWF  x6F,W
07E06:  MULLW  20
07E08:  MOVF   FF3,W
07E0A:  CLRF   x76
07E0C:  MOVWF  x75
07E0E:  MOVLW  04
07E10:  ADDWF  x75,W
07E12:  MOVWF  01
07E14:  MOVLW  00
07E16:  ADDWFC x76,W
07E18:  MOVWF  03
07E1A:  MOVF   01,W
07E1C:  ADDLW  20
07E1E:  MOVWF  FE9
07E20:  MOVLW  00
07E22:  ADDWFC 03,W
07E24:  MOVWF  FEA
07E26:  MOVFF  671,FEF
07E2A:  MOVFF  672,FEC
07E2E:  MOVFF  673,FEC
07E32:  MOVFF  674,FEC
07E36:  BRA    7E7E
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07E38:  MOVF   x70,W
07E3A:  SUBLW  44
07E3C:  BNZ   7E74
07E3E:  MOVLW  01
07E40:  SUBWF  x6F,W
07E42:  MULLW  20
07E44:  MOVF   FF3,W
07E46:  CLRF   x76
07E48:  MOVWF  x75
07E4A:  MOVLW  08
07E4C:  ADDWF  x75,W
07E4E:  MOVWF  01
07E50:  MOVLW  00
07E52:  ADDWFC x76,W
07E54:  MOVWF  03
07E56:  MOVF   01,W
07E58:  ADDLW  20
07E5A:  MOVWF  FE9
07E5C:  MOVLW  00
07E5E:  ADDWFC 03,W
07E60:  MOVWF  FEA
07E62:  MOVFF  671,FEF
07E66:  MOVFF  672,FEC
07E6A:  MOVFF  673,FEC
07E6E:  MOVFF  674,FEC
07E72:  BRA    7E7E
....................    else return INV_PARAM;
07E74:  MOVLW  02
07E76:  MOVWF  01
07E78:  MOVLB  0
07E7A:  BRA    7E84
07E7C:  MOVLB  6
....................    
....................    return SUCCESS;
07E7E:  MOVLW  00
07E80:  MOVWF  01
07E82:  MOVLB  0
07E84:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07E86:  MOVLB  6
07E88:  CLRF   xB1
07E8A:  MOVFF  663,6B0
07E8E:  CLRF   xB3
07E90:  MOVLW  B5
07E92:  MOVWF  xB2
07E94:  MOVLB  0
07E96:  CALL   0802
07E9A:  MOVFF  02,671
07E9E:  MOVFF  01,670
07EA2:  MOVLW  06
07EA4:  MOVLB  6
07EA6:  ADDWF  x70,F
07EA8:  MOVLW  00
07EAA:  ADDWFC x71,F
07EAC:  MOVLW  32
07EAE:  ADDWF  x70,W
07EB0:  MOVWF  01
07EB2:  MOVLW  00
07EB4:  ADDWFC x71,W
07EB6:  MOVWF  03
07EB8:  MOVF   01,W
07EBA:  ADDLW  DC
07EBC:  MOVWF  01
07EBE:  MOVLW  01
07EC0:  ADDWFC 03,F
07EC2:  MOVFF  01,670
07EC6:  MOVFF  03,671
07ECA:  MOVFF  03,698
07ECE:  MOVFF  01,697
07ED2:  MOVLB  0
07ED4:  CALL   65BE
07ED8:  MOVF   01,F
07EDA:  BNZ   7EE4
07EDC:  MOVLW  02
07EDE:  MOVWF  01
07EE0:  BRA    7FE6
07EE2:  BRA    7F42
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07EE4:  MOVLB  6
07EE6:  CLRF   xB1
07EE8:  MOVFF  663,6B0
07EEC:  CLRF   xB3
07EEE:  MOVLW  B5
07EF0:  MOVWF  xB2
07EF2:  MOVLB  0
07EF4:  CALL   0802
07EF8:  MOVFF  02,671
07EFC:  MOVFF  01,670
07F00:  MOVLW  06
07F02:  MOVLB  6
07F04:  ADDWF  x70,F
07F06:  MOVLW  00
07F08:  ADDWFC x71,F
07F0A:  MOVLW  32
07F0C:  ADDWF  x70,W
07F0E:  MOVWF  01
07F10:  MOVLW  00
07F12:  ADDWFC x71,W
07F14:  MOVWF  03
07F16:  MOVF   01,W
07F18:  ADDLW  DC
07F1A:  MOVWF  01
07F1C:  MOVLW  01
07F1E:  ADDWFC 03,F
07F20:  MOVFF  01,670
07F24:  MOVFF  03,671
07F28:  MOVFF  03,698
07F2C:  MOVFF  01,697
07F30:  CLRF   x9A
07F32:  CLRF   x99
07F34:  MOVLW  0A
07F36:  MOVWF  x9B
07F38:  MOVLB  0
07F3A:  CALL   66AE
07F3E:  MOVFF  01,66F
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07F42:  MOVLW  04
07F44:  MOVLB  6
07F46:  MOVWF  xA6
07F48:  MOVLW  B2
07F4A:  MOVWF  xA5
07F4C:  MOVLB  0
07F4E:  CALL   6446
07F52:  MOVF   01,W
07F54:  ADDLW  B2
07F56:  MOVLB  6
07F58:  MOVWF  x70
07F5A:  MOVLW  04
07F5C:  ADDWFC 02,W
07F5E:  MOVWF  x71
07F60:  MOVLW  01
07F62:  SUBWF  x6F,W
07F64:  MULLW  20
07F66:  MOVF   FF3,W
07F68:  CLRF   x73
07F6A:  MOVWF  x72
07F6C:  MOVLW  0C
07F6E:  ADDWF  x72,W
07F70:  MOVWF  01
07F72:  MOVLW  00
07F74:  ADDWFC x73,W
07F76:  MOVWF  03
07F78:  MOVF   01,W
07F7A:  ADDLW  20
07F7C:  MOVWF  FE9
07F7E:  MOVLW  00
07F80:  ADDWFC 03,W
07F82:  MOVWF  FEA
07F84:  MOVFF  FEF,672
07F88:  MOVFF  FEC,673
07F8C:  MOVFF  FEC,674
07F90:  MOVFF  FEC,675
07F94:  MOVFF  671,557
07F98:  MOVFF  670,556
07F9C:  MOVFF  66F,698
07FA0:  MOVLW  18
07FA2:  MOVWF  x99
07FA4:  MOVLB  0
07FA6:  CALL   6A02
07FAA:  MOVLW  2C
07FAC:  MOVLB  6
07FAE:  MOVWF  xB4
07FB0:  MOVLB  0
07FB2:  CALL   64F6
07FB6:  MOVLW  89
07FB8:  MOVWF  FE9
07FBA:  MOVFF  675,6AA
07FBE:  MOVFF  674,6A9
07FC2:  MOVFF  673,6A8
07FC6:  MOVFF  672,6A7
07FCA:  MOVLW  02
07FCC:  MOVLB  6
07FCE:  MOVWF  xAB
07FD0:  MOVLB  0
07FD2:  CALL   721E
07FD6:  MOVLW  2C
07FD8:  MOVLB  6
07FDA:  MOVWF  xB4
07FDC:  MOVLB  0
07FDE:  CALL   64F6
....................    return SUCCESS;
07FE2:  MOVLW  00
07FE4:  MOVWF  01
07FE6:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07FE8:  MOVLB  6
07FEA:  CLRF   xB1
07FEC:  MOVFF  663,6B0
07FF0:  CLRF   xB3
07FF2:  MOVLW  B5
07FF4:  MOVWF  xB2
07FF6:  MOVLB  0
07FF8:  CALL   0802
07FFC:  MOVFF  02,675
08000:  MOVFF  01,674
08004:  MOVLW  06
08006:  MOVLB  6
08008:  ADDWF  x74,F
0800A:  MOVLW  00
0800C:  ADDWFC x75,F
0800E:  MOVLW  32
08010:  ADDWF  x74,W
08012:  MOVWF  01
08014:  MOVLW  00
08016:  ADDWFC x75,W
08018:  MOVWF  03
0801A:  MOVF   01,W
0801C:  ADDLW  DC
0801E:  MOVWF  01
08020:  MOVLW  01
08022:  ADDWFC 03,F
08024:  MOVFF  01,674
08028:  MOVFF  03,675
0802C:  MOVFF  03,698
08030:  MOVFF  01,697
08034:  MOVLB  0
08036:  CALL   65BE
0803A:  MOVF   01,F
0803C:  BNZ   8046
0803E:  MOVLW  02
08040:  MOVWF  01
08042:  BRA    81A4
08044:  BRA    80A4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08046:  MOVLB  6
08048:  CLRF   xB1
0804A:  MOVFF  663,6B0
0804E:  CLRF   xB3
08050:  MOVLW  B5
08052:  MOVWF  xB2
08054:  MOVLB  0
08056:  CALL   0802
0805A:  MOVFF  02,675
0805E:  MOVFF  01,674
08062:  MOVLW  06
08064:  MOVLB  6
08066:  ADDWF  x74,F
08068:  MOVLW  00
0806A:  ADDWFC x75,F
0806C:  MOVLW  32
0806E:  ADDWF  x74,W
08070:  MOVWF  01
08072:  MOVLW  00
08074:  ADDWFC x75,W
08076:  MOVWF  03
08078:  MOVF   01,W
0807A:  ADDLW  DC
0807C:  MOVWF  01
0807E:  MOVLW  01
08080:  ADDWFC 03,F
08082:  MOVFF  01,674
08086:  MOVFF  03,675
0808A:  MOVFF  03,698
0808E:  MOVFF  01,697
08092:  CLRF   x9A
08094:  CLRF   x99
08096:  MOVLW  0A
08098:  MOVWF  x9B
0809A:  MOVLB  0
0809C:  CALL   66AE
080A0:  MOVFF  01,66F
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
080A4:  MOVLB  6
080A6:  CLRF   xB1
080A8:  MOVFF  663,6B0
080AC:  CLRF   xB3
080AE:  MOVLW  B5
080B0:  MOVWF  xB2
080B2:  MOVLB  0
080B4:  CALL   0802
080B8:  MOVFF  02,675
080BC:  MOVFF  01,674
080C0:  MOVLW  06
080C2:  MOVLB  6
080C4:  ADDWF  x74,F
080C6:  MOVLW  00
080C8:  ADDWFC x75,F
080CA:  MOVLW  4B
080CC:  ADDWF  x74,W
080CE:  MOVWF  01
080D0:  MOVLW  00
080D2:  ADDWFC x75,W
080D4:  MOVWF  03
080D6:  MOVF   01,W
080D8:  ADDLW  DC
080DA:  MOVWF  01
080DC:  MOVLW  01
080DE:  ADDWFC 03,F
080E0:  MOVFF  01,674
080E4:  MOVFF  03,675
080E8:  MOVFF  03,679
080EC:  MOVFF  01,678
080F0:  MOVLB  0
080F2:  CALL   788A
080F6:  MOVF   01,F
080F8:  BNZ   8102
080FA:  MOVLW  02
080FC:  MOVWF  01
080FE:  BRA    81A4
08100:  BRA    8168
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
08102:  MOVLB  6
08104:  CLRF   xB1
08106:  MOVFF  663,6B0
0810A:  CLRF   xB3
0810C:  MOVLW  B5
0810E:  MOVWF  xB2
08110:  MOVLB  0
08112:  CALL   0802
08116:  MOVFF  02,675
0811A:  MOVFF  01,674
0811E:  MOVLW  06
08120:  MOVLB  6
08122:  ADDWF  x74,F
08124:  MOVLW  00
08126:  ADDWFC x75,F
08128:  MOVLW  4B
0812A:  ADDWF  x74,W
0812C:  MOVWF  01
0812E:  MOVLW  00
08130:  ADDWFC x75,W
08132:  MOVWF  03
08134:  MOVF   01,W
08136:  ADDLW  DC
08138:  MOVWF  01
0813A:  MOVLW  01
0813C:  ADDWFC 03,F
0813E:  MOVFF  01,674
08142:  MOVFF  03,675
08146:  MOVFF  03,679
0814A:  MOVFF  01,678
0814E:  CLRF   x7B
08150:  CLRF   x7A
08152:  MOVLB  0
08154:  CALL   794C
08158:  MOVFF  03,673
0815C:  MOVFF  02,672
08160:  MOVFF  01,671
08164:  MOVFF  00,670
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
08168:  MOVLW  01
0816A:  MOVLB  6
0816C:  SUBWF  x6F,W
0816E:  MULLW  20
08170:  MOVF   FF3,W
08172:  CLRF   x75
08174:  MOVWF  x74
08176:  MOVLW  0C
08178:  ADDWF  x74,W
0817A:  MOVWF  01
0817C:  MOVLW  00
0817E:  ADDWFC x75,W
08180:  MOVWF  03
08182:  MOVF   01,W
08184:  ADDLW  20
08186:  MOVWF  FE9
08188:  MOVLW  00
0818A:  ADDWFC 03,W
0818C:  MOVWF  FEA
0818E:  MOVFF  670,FEF
08192:  MOVFF  671,FEC
08196:  MOVFF  672,FEC
0819A:  MOVFF  673,FEC
....................    
....................    return SUCCESS;
0819E:  MOVLW  00
081A0:  MOVWF  01
081A2:  MOVLB  0
081A4:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
081A6:  MOVLB  6
081A8:  CLRF   xB1
081AA:  MOVFF  663,6B0
081AE:  CLRF   xB3
081B0:  MOVLW  B5
081B2:  MOVWF  xB2
081B4:  MOVLB  0
081B6:  CALL   0802
081BA:  MOVFF  02,671
081BE:  MOVFF  01,670
081C2:  MOVLW  06
081C4:  MOVLB  6
081C6:  ADDWF  x70,F
081C8:  MOVLW  00
081CA:  ADDWFC x71,F
081CC:  MOVLW  32
081CE:  ADDWF  x70,W
081D0:  MOVWF  01
081D2:  MOVLW  00
081D4:  ADDWFC x71,W
081D6:  MOVWF  03
081D8:  MOVF   01,W
081DA:  ADDLW  DC
081DC:  MOVWF  01
081DE:  MOVLW  01
081E0:  ADDWFC 03,F
081E2:  MOVFF  01,670
081E6:  MOVFF  03,671
081EA:  MOVFF  03,698
081EE:  MOVFF  01,697
081F2:  MOVLB  0
081F4:  CALL   65BE
081F8:  MOVF   01,F
081FA:  BNZ   8204
081FC:  MOVLW  02
081FE:  MOVWF  01
08200:  BRA    855A
08202:  BRA    8262
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08204:  MOVLB  6
08206:  CLRF   xB1
08208:  MOVFF  663,6B0
0820C:  CLRF   xB3
0820E:  MOVLW  B5
08210:  MOVWF  xB2
08212:  MOVLB  0
08214:  CALL   0802
08218:  MOVFF  02,671
0821C:  MOVFF  01,670
08220:  MOVLW  06
08222:  MOVLB  6
08224:  ADDWF  x70,F
08226:  MOVLW  00
08228:  ADDWFC x71,F
0822A:  MOVLW  32
0822C:  ADDWF  x70,W
0822E:  MOVWF  01
08230:  MOVLW  00
08232:  ADDWFC x71,W
08234:  MOVWF  03
08236:  MOVF   01,W
08238:  ADDLW  DC
0823A:  MOVWF  01
0823C:  MOVLW  01
0823E:  ADDWFC 03,F
08240:  MOVFF  01,670
08244:  MOVFF  03,671
08248:  MOVFF  03,698
0824C:  MOVFF  01,697
08250:  CLRF   x9A
08252:  CLRF   x99
08254:  MOVLW  0A
08256:  MOVWF  x9B
08258:  MOVLB  0
0825A:  CALL   66AE
0825E:  MOVFF  01,66F
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
08262:  MOVLW  04
08264:  MOVLB  6
08266:  MOVWF  xA6
08268:  MOVLW  B2
0826A:  MOVWF  xA5
0826C:  MOVLB  0
0826E:  CALL   6446
08272:  MOVFF  02,03
08276:  MOVF   01,W
08278:  ADDLW  B2
0827A:  MOVLB  6
0827C:  MOVWF  x70
0827E:  MOVLW  04
08280:  ADDWFC 02,W
08282:  MOVWF  x71
08284:  MOVFF  FE8,557
08288:  MOVFF  670,556
0828C:  MOVFF  66F,698
08290:  MOVLW  18
08292:  MOVWF  x99
08294:  MOVLB  0
08296:  CALL   6A02
0829A:  MOVLW  2C
0829C:  MOVLB  6
0829E:  MOVWF  xB4
082A0:  MOVLB  0
082A2:  CALL   64F6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
082A6:  MOVLW  04
082A8:  MOVLB  6
082AA:  MOVWF  xA6
082AC:  MOVLW  B2
082AE:  MOVWF  xA5
082B0:  MOVLB  0
082B2:  CALL   6446
082B6:  MOVFF  02,03
082BA:  MOVF   01,W
082BC:  ADDLW  B2
082BE:  MOVLB  6
082C0:  MOVWF  x70
082C2:  MOVLW  04
082C4:  ADDWFC 02,W
082C6:  MOVWF  x71
082C8:  MOVLW  01
082CA:  SUBWF  x6F,W
082CC:  MULLW  18
082CE:  MOVF   FF3,W
082D0:  CLRF   x73
082D2:  MOVWF  x72
082D4:  MOVLW  82
082D6:  ADDWF  x72,W
082D8:  MOVWF  FE9
082DA:  MOVLW  00
082DC:  ADDWFC x73,W
082DE:  MOVWF  FEA
082E0:  MOVFF  FEF,6A7
082E4:  MOVFF  FEC,6A8
082E8:  MOVFF  FEC,6A9
082EC:  MOVFF  FEC,6AA
082F0:  MOVFF  671,557
082F4:  MOVFF  670,556
082F8:  MOVLW  89
082FA:  MOVWF  FE9
082FC:  MOVLW  02
082FE:  MOVWF  xAB
08300:  MOVLB  0
08302:  CALL   721E
08306:  MOVLW  2C
08308:  MOVLB  6
0830A:  MOVWF  xB4
0830C:  MOVLB  0
0830E:  CALL   64F6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
08312:  MOVLW  04
08314:  MOVLB  6
08316:  MOVWF  xA6
08318:  MOVLW  B2
0831A:  MOVWF  xA5
0831C:  MOVLB  0
0831E:  CALL   6446
08322:  MOVF   01,W
08324:  ADDLW  B2
08326:  MOVLB  6
08328:  MOVWF  x70
0832A:  MOVLW  04
0832C:  ADDWFC 02,W
0832E:  MOVWF  x71
08330:  MOVLW  01
08332:  SUBWF  x6F,W
08334:  MULLW  18
08336:  MOVF   FF3,W
08338:  CLRF   x73
0833A:  MOVWF  x72
0833C:  MOVLW  04
0833E:  ADDWF  x72,W
08340:  MOVWF  01
08342:  MOVLW  00
08344:  ADDWFC x73,W
08346:  MOVWF  03
08348:  MOVF   01,W
0834A:  ADDLW  82
0834C:  MOVWF  FE9
0834E:  MOVLW  00
08350:  ADDWFC 03,W
08352:  MOVWF  FEA
08354:  MOVFF  FEF,6A7
08358:  MOVFF  FEC,6A8
0835C:  MOVFF  FEC,6A9
08360:  MOVFF  FEC,6AA
08364:  MOVFF  671,557
08368:  MOVFF  670,556
0836C:  MOVLW  89
0836E:  MOVWF  FE9
08370:  MOVLW  02
08372:  MOVWF  xAB
08374:  MOVLB  0
08376:  CALL   721E
0837A:  MOVLW  2C
0837C:  MOVLB  6
0837E:  MOVWF  xB4
08380:  MOVLB  0
08382:  CALL   64F6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
08386:  MOVLW  04
08388:  MOVLB  6
0838A:  MOVWF  xA6
0838C:  MOVLW  B2
0838E:  MOVWF  xA5
08390:  MOVLB  0
08392:  CALL   6446
08396:  MOVF   01,W
08398:  ADDLW  B2
0839A:  MOVLB  6
0839C:  MOVWF  x70
0839E:  MOVLW  04
083A0:  ADDWFC 02,W
083A2:  MOVWF  x71
083A4:  MOVLW  01
083A6:  SUBWF  x6F,W
083A8:  MULLW  18
083AA:  MOVF   FF3,W
083AC:  CLRF   x73
083AE:  MOVWF  x72
083B0:  MOVLW  08
083B2:  ADDWF  x72,W
083B4:  MOVWF  01
083B6:  MOVLW  00
083B8:  ADDWFC x73,W
083BA:  MOVWF  03
083BC:  MOVF   01,W
083BE:  ADDLW  82
083C0:  MOVWF  FE9
083C2:  MOVLW  00
083C4:  ADDWFC 03,W
083C6:  MOVWF  FEA
083C8:  MOVFF  FEF,6A7
083CC:  MOVFF  FEC,6A8
083D0:  MOVFF  FEC,6A9
083D4:  MOVFF  FEC,6AA
083D8:  MOVFF  671,557
083DC:  MOVFF  670,556
083E0:  MOVLW  89
083E2:  MOVWF  FE9
083E4:  MOVLW  02
083E6:  MOVWF  xAB
083E8:  MOVLB  0
083EA:  CALL   721E
083EE:  MOVLW  2C
083F0:  MOVLB  6
083F2:  MOVWF  xB4
083F4:  MOVLB  0
083F6:  CALL   64F6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
083FA:  MOVLW  04
083FC:  MOVLB  6
083FE:  MOVWF  xA6
08400:  MOVLW  B2
08402:  MOVWF  xA5
08404:  MOVLB  0
08406:  CALL   6446
0840A:  MOVF   01,W
0840C:  ADDLW  B2
0840E:  MOVLB  6
08410:  MOVWF  x70
08412:  MOVLW  04
08414:  ADDWFC 02,W
08416:  MOVWF  x71
08418:  MOVLW  01
0841A:  SUBWF  x6F,W
0841C:  MULLW  18
0841E:  MOVF   FF3,W
08420:  CLRF   x73
08422:  MOVWF  x72
08424:  MOVLW  0C
08426:  ADDWF  x72,W
08428:  MOVWF  01
0842A:  MOVLW  00
0842C:  ADDWFC x73,W
0842E:  MOVWF  03
08430:  MOVF   01,W
08432:  ADDLW  82
08434:  MOVWF  FE9
08436:  MOVLW  00
08438:  ADDWFC 03,W
0843A:  MOVWF  FEA
0843C:  MOVFF  FEF,6A7
08440:  MOVFF  FEC,6A8
08444:  MOVFF  FEC,6A9
08448:  MOVFF  FEC,6AA
0844C:  MOVFF  671,557
08450:  MOVFF  670,556
08454:  MOVLW  89
08456:  MOVWF  FE9
08458:  MOVLW  02
0845A:  MOVWF  xAB
0845C:  MOVLB  0
0845E:  CALL   721E
08462:  MOVLW  2C
08464:  MOVLB  6
08466:  MOVWF  xB4
08468:  MOVLB  0
0846A:  CALL   64F6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
0846E:  MOVLW  04
08470:  MOVLB  6
08472:  MOVWF  xA6
08474:  MOVLW  B2
08476:  MOVWF  xA5
08478:  MOVLB  0
0847A:  CALL   6446
0847E:  MOVF   01,W
08480:  ADDLW  B2
08482:  MOVLB  6
08484:  MOVWF  x70
08486:  MOVLW  04
08488:  ADDWFC 02,W
0848A:  MOVWF  x71
0848C:  MOVLW  01
0848E:  SUBWF  x6F,W
08490:  MULLW  18
08492:  MOVF   FF3,W
08494:  CLRF   x73
08496:  MOVWF  x72
08498:  MOVLW  10
0849A:  ADDWF  x72,W
0849C:  MOVWF  01
0849E:  MOVLW  00
084A0:  ADDWFC x73,W
084A2:  MOVWF  03
084A4:  MOVF   01,W
084A6:  ADDLW  82
084A8:  MOVWF  FE9
084AA:  MOVLW  00
084AC:  ADDWFC 03,W
084AE:  MOVWF  FEA
084B0:  MOVFF  FEF,6A7
084B4:  MOVFF  FEC,6A8
084B8:  MOVFF  FEC,6A9
084BC:  MOVFF  FEC,6AA
084C0:  MOVFF  671,557
084C4:  MOVFF  670,556
084C8:  MOVLW  89
084CA:  MOVWF  FE9
084CC:  MOVLW  02
084CE:  MOVWF  xAB
084D0:  MOVLB  0
084D2:  CALL   721E
084D6:  MOVLW  2C
084D8:  MOVLB  6
084DA:  MOVWF  xB4
084DC:  MOVLB  0
084DE:  CALL   64F6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
084E2:  MOVLW  04
084E4:  MOVLB  6
084E6:  MOVWF  xA6
084E8:  MOVLW  B2
084EA:  MOVWF  xA5
084EC:  MOVLB  0
084EE:  CALL   6446
084F2:  MOVF   01,W
084F4:  ADDLW  B2
084F6:  MOVLB  6
084F8:  MOVWF  x70
084FA:  MOVLW  04
084FC:  ADDWFC 02,W
084FE:  MOVWF  x71
08500:  MOVLW  01
08502:  SUBWF  x6F,W
08504:  MULLW  18
08506:  MOVF   FF3,W
08508:  CLRF   x73
0850A:  MOVWF  x72
0850C:  MOVLW  14
0850E:  ADDWF  x72,W
08510:  MOVWF  01
08512:  MOVLW  00
08514:  ADDWFC x73,W
08516:  MOVWF  03
08518:  MOVF   01,W
0851A:  ADDLW  82
0851C:  MOVWF  FE9
0851E:  MOVLW  00
08520:  ADDWFC 03,W
08522:  MOVWF  FEA
08524:  MOVFF  FEF,6A7
08528:  MOVFF  FEC,6A8
0852C:  MOVFF  FEC,6A9
08530:  MOVFF  FEC,6AA
08534:  MOVFF  671,557
08538:  MOVFF  670,556
0853C:  MOVLW  89
0853E:  MOVWF  FE9
08540:  MOVLW  02
08542:  MOVWF  xAB
08544:  MOVLB  0
08546:  CALL   721E
0854A:  MOVLW  2C
0854C:  MOVLB  6
0854E:  MOVWF  xB4
08550:  MOVLB  0
08552:  CALL   64F6
....................    
....................    return SUCCESS;
08556:  MOVLW  00
08558:  MOVWF  01
0855A:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0855C:  MOVLB  6
0855E:  CLRF   xB1
08560:  MOVFF  663,6B0
08564:  CLRF   xB3
08566:  MOVLW  B5
08568:  MOVWF  xB2
0856A:  MOVLB  0
0856C:  CALL   0802
08570:  MOVFF  02,672
08574:  MOVFF  01,671
08578:  MOVLW  06
0857A:  MOVLB  6
0857C:  ADDWF  x71,F
0857E:  MOVLW  00
08580:  ADDWFC x72,F
08582:  MOVLW  32
08584:  ADDWF  x71,W
08586:  MOVWF  01
08588:  MOVLW  00
0858A:  ADDWFC x72,W
0858C:  MOVWF  03
0858E:  MOVF   01,W
08590:  ADDLW  DC
08592:  MOVWF  01
08594:  MOVLW  01
08596:  ADDWFC 03,F
08598:  MOVFF  01,671
0859C:  MOVFF  03,672
085A0:  MOVFF  03,698
085A4:  MOVFF  01,697
085A8:  MOVLB  0
085AA:  CALL   65BE
085AE:  MOVF   01,F
085B0:  BNZ   85BA
085B2:  MOVLW  02
085B4:  MOVWF  01
085B6:  BRA    8AB6
085B8:  BRA    8618
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
085BA:  MOVLB  6
085BC:  CLRF   xB1
085BE:  MOVFF  663,6B0
085C2:  CLRF   xB3
085C4:  MOVLW  B5
085C6:  MOVWF  xB2
085C8:  MOVLB  0
085CA:  CALL   0802
085CE:  MOVFF  02,672
085D2:  MOVFF  01,671
085D6:  MOVLW  06
085D8:  MOVLB  6
085DA:  ADDWF  x71,F
085DC:  MOVLW  00
085DE:  ADDWFC x72,F
085E0:  MOVLW  32
085E2:  ADDWF  x71,W
085E4:  MOVWF  01
085E6:  MOVLW  00
085E8:  ADDWFC x72,W
085EA:  MOVWF  03
085EC:  MOVF   01,W
085EE:  ADDLW  DC
085F0:  MOVWF  01
085F2:  MOVLW  01
085F4:  ADDWFC 03,F
085F6:  MOVFF  01,671
085FA:  MOVFF  03,672
085FE:  MOVFF  03,698
08602:  MOVFF  01,697
08606:  CLRF   x9A
08608:  CLRF   x99
0860A:  MOVLW  0A
0860C:  MOVWF  x9B
0860E:  MOVLB  0
08610:  CALL   66AE
08614:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08618:  MOVLB  6
0861A:  CLRF   xB1
0861C:  MOVFF  663,6B0
08620:  CLRF   xB3
08622:  MOVLW  B5
08624:  MOVWF  xB2
08626:  MOVLB  0
08628:  CALL   0802
0862C:  MOVFF  02,672
08630:  MOVFF  01,671
08634:  MOVLW  06
08636:  MOVLB  6
08638:  ADDWF  x71,F
0863A:  MOVLW  00
0863C:  ADDWFC x72,F
0863E:  MOVLW  4B
08640:  ADDWF  x71,W
08642:  MOVWF  01
08644:  MOVLW  00
08646:  ADDWFC x72,W
08648:  MOVWF  03
0864A:  MOVF   01,W
0864C:  ADDLW  DC
0864E:  MOVWF  01
08650:  MOVLW  01
08652:  ADDWFC 03,F
08654:  MOVFF  01,671
08658:  MOVFF  03,672
0865C:  MOVFF  03,6A6
08660:  MOVFF  01,6A5
08664:  MOVLB  0
08666:  CALL   6446
0866A:  MOVFF  02,03
0866E:  MOVF   01,W
08670:  SUBLW  01
08672:  BNZ   8678
08674:  MOVF   03,F
08676:  BZ    8680
08678:  MOVLW  02
0867A:  MOVWF  01
0867C:  BRA    8AB6
0867E:  BRA    86C0
....................    else arg2 = SERcmd[rec].p[3][0];
08680:  MOVLB  6
08682:  CLRF   xB1
08684:  MOVFF  663,6B0
08688:  CLRF   xB3
0868A:  MOVLW  B5
0868C:  MOVWF  xB2
0868E:  MOVLB  0
08690:  CALL   0802
08694:  MOVFF  02,672
08698:  MOVFF  01,671
0869C:  MOVLW  06
0869E:  MOVLB  6
086A0:  ADDWF  x71,F
086A2:  MOVLW  00
086A4:  ADDWFC x72,F
086A6:  MOVLW  4B
086A8:  ADDWF  x71,F
086AA:  MOVLW  00
086AC:  ADDWFC x72,F
086AE:  MOVLW  DC
086B0:  ADDWF  x71,W
086B2:  MOVWF  FE9
086B4:  MOVLW  01
086B6:  ADDWFC x72,W
086B8:  MOVWF  FEA
086BA:  MOVFF  FEF,670
086BE:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
086C0:  MOVLB  6
086C2:  MOVF   x70,W
086C4:  SUBLW  30
086C6:  BNZ   8762
086C8:  MOVLW  04
086CA:  MOVWF  xA6
086CC:  MOVLW  B2
086CE:  MOVWF  xA5
086D0:  MOVLB  0
086D2:  CALL   6446
086D6:  MOVFF  02,03
086DA:  MOVF   01,W
086DC:  ADDLW  B2
086DE:  MOVLB  6
086E0:  MOVWF  x71
086E2:  MOVLW  04
086E4:  ADDWFC 02,W
086E6:  MOVWF  x72
086E8:  MOVLW  01
086EA:  SUBWF  x6F,W
086EC:  MULLW  18
086EE:  MOVF   FF3,W
086F0:  CLRF   x74
086F2:  MOVWF  x73
086F4:  MOVLW  82
086F6:  ADDWF  x73,W
086F8:  MOVWF  FE9
086FA:  MOVLW  00
086FC:  ADDWFC x74,W
086FE:  MOVWF  FEA
08700:  MOVFF  FEF,675
08704:  MOVFF  FEC,676
08708:  MOVFF  FEC,677
0870C:  MOVFF  FEC,678
08710:  MOVFF  672,557
08714:  MOVFF  671,556
08718:  MOVFF  66F,698
0871C:  MOVLW  18
0871E:  MOVWF  x99
08720:  MOVLB  0
08722:  CALL   6A02
08726:  MOVLW  2C
08728:  MOVLB  6
0872A:  MOVWF  xB4
0872C:  MOVLB  0
0872E:  CALL   64F6
08732:  MOVLW  89
08734:  MOVWF  FE9
08736:  MOVFF  678,6AA
0873A:  MOVFF  677,6A9
0873E:  MOVFF  676,6A8
08742:  MOVFF  675,6A7
08746:  MOVLW  02
08748:  MOVLB  6
0874A:  MOVWF  xAB
0874C:  MOVLB  0
0874E:  CALL   721E
08752:  MOVLW  2C
08754:  MOVLB  6
08756:  MOVWF  xB4
08758:  MOVLB  0
0875A:  CALL   64F6
0875E:  BRA    8AB2
08760:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
08762:  MOVF   x70,W
08764:  SUBLW  31
08766:  BNZ   880A
08768:  MOVLW  04
0876A:  MOVWF  xA6
0876C:  MOVLW  B2
0876E:  MOVWF  xA5
08770:  MOVLB  0
08772:  CALL   6446
08776:  MOVF   01,W
08778:  ADDLW  B2
0877A:  MOVLB  6
0877C:  MOVWF  x71
0877E:  MOVLW  04
08780:  ADDWFC 02,W
08782:  MOVWF  x72
08784:  MOVLW  01
08786:  SUBWF  x6F,W
08788:  MULLW  18
0878A:  MOVF   FF3,W
0878C:  CLRF   x74
0878E:  MOVWF  x73
08790:  MOVLW  04
08792:  ADDWF  x73,W
08794:  MOVWF  01
08796:  MOVLW  00
08798:  ADDWFC x74,W
0879A:  MOVWF  03
0879C:  MOVF   01,W
0879E:  ADDLW  82
087A0:  MOVWF  FE9
087A2:  MOVLW  00
087A4:  ADDWFC 03,W
087A6:  MOVWF  FEA
087A8:  MOVFF  FEF,673
087AC:  MOVFF  FEC,674
087B0:  MOVFF  FEC,675
087B4:  MOVFF  FEC,676
087B8:  MOVFF  672,557
087BC:  MOVFF  671,556
087C0:  MOVFF  66F,698
087C4:  MOVLW  18
087C6:  MOVWF  x99
087C8:  MOVLB  0
087CA:  CALL   6A02
087CE:  MOVLW  2C
087D0:  MOVLB  6
087D2:  MOVWF  xB4
087D4:  MOVLB  0
087D6:  CALL   64F6
087DA:  MOVLW  89
087DC:  MOVWF  FE9
087DE:  MOVFF  676,6AA
087E2:  MOVFF  675,6A9
087E6:  MOVFF  674,6A8
087EA:  MOVFF  673,6A7
087EE:  MOVLW  02
087F0:  MOVLB  6
087F2:  MOVWF  xAB
087F4:  MOVLB  0
087F6:  CALL   721E
087FA:  MOVLW  2C
087FC:  MOVLB  6
087FE:  MOVWF  xB4
08800:  MOVLB  0
08802:  CALL   64F6
08806:  BRA    8AB2
08808:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
0880A:  MOVF   x70,W
0880C:  SUBLW  32
0880E:  BNZ   88B2
08810:  MOVLW  04
08812:  MOVWF  xA6
08814:  MOVLW  B2
08816:  MOVWF  xA5
08818:  MOVLB  0
0881A:  CALL   6446
0881E:  MOVF   01,W
08820:  ADDLW  B2
08822:  MOVLB  6
08824:  MOVWF  x71
08826:  MOVLW  04
08828:  ADDWFC 02,W
0882A:  MOVWF  x72
0882C:  MOVLW  01
0882E:  SUBWF  x6F,W
08830:  MULLW  18
08832:  MOVF   FF3,W
08834:  CLRF   x74
08836:  MOVWF  x73
08838:  MOVLW  08
0883A:  ADDWF  x73,W
0883C:  MOVWF  01
0883E:  MOVLW  00
08840:  ADDWFC x74,W
08842:  MOVWF  03
08844:  MOVF   01,W
08846:  ADDLW  82
08848:  MOVWF  FE9
0884A:  MOVLW  00
0884C:  ADDWFC 03,W
0884E:  MOVWF  FEA
08850:  MOVFF  FEF,673
08854:  MOVFF  FEC,674
08858:  MOVFF  FEC,675
0885C:  MOVFF  FEC,676
08860:  MOVFF  672,557
08864:  MOVFF  671,556
08868:  MOVFF  66F,698
0886C:  MOVLW  18
0886E:  MOVWF  x99
08870:  MOVLB  0
08872:  CALL   6A02
08876:  MOVLW  2C
08878:  MOVLB  6
0887A:  MOVWF  xB4
0887C:  MOVLB  0
0887E:  CALL   64F6
08882:  MOVLW  89
08884:  MOVWF  FE9
08886:  MOVFF  676,6AA
0888A:  MOVFF  675,6A9
0888E:  MOVFF  674,6A8
08892:  MOVFF  673,6A7
08896:  MOVLW  02
08898:  MOVLB  6
0889A:  MOVWF  xAB
0889C:  MOVLB  0
0889E:  CALL   721E
088A2:  MOVLW  2C
088A4:  MOVLB  6
088A6:  MOVWF  xB4
088A8:  MOVLB  0
088AA:  CALL   64F6
088AE:  BRA    8AB2
088B0:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
088B2:  MOVF   x70,W
088B4:  SUBLW  33
088B6:  BNZ   895A
088B8:  MOVLW  04
088BA:  MOVWF  xA6
088BC:  MOVLW  B2
088BE:  MOVWF  xA5
088C0:  MOVLB  0
088C2:  CALL   6446
088C6:  MOVF   01,W
088C8:  ADDLW  B2
088CA:  MOVLB  6
088CC:  MOVWF  x71
088CE:  MOVLW  04
088D0:  ADDWFC 02,W
088D2:  MOVWF  x72
088D4:  MOVLW  01
088D6:  SUBWF  x6F,W
088D8:  MULLW  18
088DA:  MOVF   FF3,W
088DC:  CLRF   x74
088DE:  MOVWF  x73
088E0:  MOVLW  0C
088E2:  ADDWF  x73,W
088E4:  MOVWF  01
088E6:  MOVLW  00
088E8:  ADDWFC x74,W
088EA:  MOVWF  03
088EC:  MOVF   01,W
088EE:  ADDLW  82
088F0:  MOVWF  FE9
088F2:  MOVLW  00
088F4:  ADDWFC 03,W
088F6:  MOVWF  FEA
088F8:  MOVFF  FEF,673
088FC:  MOVFF  FEC,674
08900:  MOVFF  FEC,675
08904:  MOVFF  FEC,676
08908:  MOVFF  672,557
0890C:  MOVFF  671,556
08910:  MOVFF  66F,698
08914:  MOVLW  18
08916:  MOVWF  x99
08918:  MOVLB  0
0891A:  CALL   6A02
0891E:  MOVLW  2C
08920:  MOVLB  6
08922:  MOVWF  xB4
08924:  MOVLB  0
08926:  CALL   64F6
0892A:  MOVLW  89
0892C:  MOVWF  FE9
0892E:  MOVFF  676,6AA
08932:  MOVFF  675,6A9
08936:  MOVFF  674,6A8
0893A:  MOVFF  673,6A7
0893E:  MOVLW  02
08940:  MOVLB  6
08942:  MOVWF  xAB
08944:  MOVLB  0
08946:  CALL   721E
0894A:  MOVLW  2C
0894C:  MOVLB  6
0894E:  MOVWF  xB4
08950:  MOVLB  0
08952:  CALL   64F6
08956:  BRA    8AB2
08958:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
0895A:  MOVF   x70,W
0895C:  SUBLW  34
0895E:  BNZ   8A02
08960:  MOVLW  04
08962:  MOVWF  xA6
08964:  MOVLW  B2
08966:  MOVWF  xA5
08968:  MOVLB  0
0896A:  CALL   6446
0896E:  MOVF   01,W
08970:  ADDLW  B2
08972:  MOVLB  6
08974:  MOVWF  x71
08976:  MOVLW  04
08978:  ADDWFC 02,W
0897A:  MOVWF  x72
0897C:  MOVLW  01
0897E:  SUBWF  x6F,W
08980:  MULLW  18
08982:  MOVF   FF3,W
08984:  CLRF   x74
08986:  MOVWF  x73
08988:  MOVLW  10
0898A:  ADDWF  x73,W
0898C:  MOVWF  01
0898E:  MOVLW  00
08990:  ADDWFC x74,W
08992:  MOVWF  03
08994:  MOVF   01,W
08996:  ADDLW  82
08998:  MOVWF  FE9
0899A:  MOVLW  00
0899C:  ADDWFC 03,W
0899E:  MOVWF  FEA
089A0:  MOVFF  FEF,673
089A4:  MOVFF  FEC,674
089A8:  MOVFF  FEC,675
089AC:  MOVFF  FEC,676
089B0:  MOVFF  672,557
089B4:  MOVFF  671,556
089B8:  MOVFF  66F,698
089BC:  MOVLW  18
089BE:  MOVWF  x99
089C0:  MOVLB  0
089C2:  CALL   6A02
089C6:  MOVLW  2C
089C8:  MOVLB  6
089CA:  MOVWF  xB4
089CC:  MOVLB  0
089CE:  CALL   64F6
089D2:  MOVLW  89
089D4:  MOVWF  FE9
089D6:  MOVFF  676,6AA
089DA:  MOVFF  675,6A9
089DE:  MOVFF  674,6A8
089E2:  MOVFF  673,6A7
089E6:  MOVLW  02
089E8:  MOVLB  6
089EA:  MOVWF  xAB
089EC:  MOVLB  0
089EE:  CALL   721E
089F2:  MOVLW  2C
089F4:  MOVLB  6
089F6:  MOVWF  xB4
089F8:  MOVLB  0
089FA:  CALL   64F6
089FE:  BRA    8AB2
08A00:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
08A02:  MOVF   x70,W
08A04:  SUBLW  35
08A06:  BNZ   8AAA
08A08:  MOVLW  04
08A0A:  MOVWF  xA6
08A0C:  MOVLW  B2
08A0E:  MOVWF  xA5
08A10:  MOVLB  0
08A12:  CALL   6446
08A16:  MOVF   01,W
08A18:  ADDLW  B2
08A1A:  MOVLB  6
08A1C:  MOVWF  x71
08A1E:  MOVLW  04
08A20:  ADDWFC 02,W
08A22:  MOVWF  x72
08A24:  MOVLW  01
08A26:  SUBWF  x6F,W
08A28:  MULLW  18
08A2A:  MOVF   FF3,W
08A2C:  CLRF   x74
08A2E:  MOVWF  x73
08A30:  MOVLW  14
08A32:  ADDWF  x73,W
08A34:  MOVWF  01
08A36:  MOVLW  00
08A38:  ADDWFC x74,W
08A3A:  MOVWF  03
08A3C:  MOVF   01,W
08A3E:  ADDLW  82
08A40:  MOVWF  FE9
08A42:  MOVLW  00
08A44:  ADDWFC 03,W
08A46:  MOVWF  FEA
08A48:  MOVFF  FEF,673
08A4C:  MOVFF  FEC,674
08A50:  MOVFF  FEC,675
08A54:  MOVFF  FEC,676
08A58:  MOVFF  672,557
08A5C:  MOVFF  671,556
08A60:  MOVFF  66F,698
08A64:  MOVLW  18
08A66:  MOVWF  x99
08A68:  MOVLB  0
08A6A:  CALL   6A02
08A6E:  MOVLW  2C
08A70:  MOVLB  6
08A72:  MOVWF  xB4
08A74:  MOVLB  0
08A76:  CALL   64F6
08A7A:  MOVLW  89
08A7C:  MOVWF  FE9
08A7E:  MOVFF  676,6AA
08A82:  MOVFF  675,6A9
08A86:  MOVFF  674,6A8
08A8A:  MOVFF  673,6A7
08A8E:  MOVLW  02
08A90:  MOVLB  6
08A92:  MOVWF  xAB
08A94:  MOVLB  0
08A96:  CALL   721E
08A9A:  MOVLW  2C
08A9C:  MOVLB  6
08A9E:  MOVWF  xB4
08AA0:  MOVLB  0
08AA2:  CALL   64F6
08AA6:  BRA    8AB2
08AA8:  MOVLB  6
....................    else return INV_PARAM;
08AAA:  MOVLW  02
08AAC:  MOVWF  01
08AAE:  MOVLB  0
08AB0:  BRA    8AB6
....................    
....................    return SUCCESS;
08AB2:  MOVLW  00
08AB4:  MOVWF  01
08AB6:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08AB8:  MOVLB  6
08ABA:  CLRF   xB1
08ABC:  MOVFF  663,6B0
08AC0:  CLRF   xB3
08AC2:  MOVLW  B5
08AC4:  MOVWF  xB2
08AC6:  MOVLB  0
08AC8:  CALL   0802
08ACC:  MOVFF  02,676
08AD0:  MOVFF  01,675
08AD4:  MOVLW  06
08AD6:  MOVLB  6
08AD8:  ADDWF  x75,F
08ADA:  MOVLW  00
08ADC:  ADDWFC x76,F
08ADE:  MOVLW  32
08AE0:  ADDWF  x75,W
08AE2:  MOVWF  01
08AE4:  MOVLW  00
08AE6:  ADDWFC x76,W
08AE8:  MOVWF  03
08AEA:  MOVF   01,W
08AEC:  ADDLW  DC
08AEE:  MOVWF  01
08AF0:  MOVLW  01
08AF2:  ADDWFC 03,F
08AF4:  MOVFF  01,675
08AF8:  MOVFF  03,676
08AFC:  MOVFF  03,698
08B00:  MOVFF  01,697
08B04:  MOVLB  0
08B06:  CALL   65BE
08B0A:  MOVF   01,F
08B0C:  BNZ   8B16
08B0E:  MOVLW  02
08B10:  MOVWF  01
08B12:  BRA    8E4E
08B14:  BRA    8B74
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08B16:  MOVLB  6
08B18:  CLRF   xB1
08B1A:  MOVFF  663,6B0
08B1E:  CLRF   xB3
08B20:  MOVLW  B5
08B22:  MOVWF  xB2
08B24:  MOVLB  0
08B26:  CALL   0802
08B2A:  MOVFF  02,676
08B2E:  MOVFF  01,675
08B32:  MOVLW  06
08B34:  MOVLB  6
08B36:  ADDWF  x75,F
08B38:  MOVLW  00
08B3A:  ADDWFC x76,F
08B3C:  MOVLW  32
08B3E:  ADDWF  x75,W
08B40:  MOVWF  01
08B42:  MOVLW  00
08B44:  ADDWFC x76,W
08B46:  MOVWF  03
08B48:  MOVF   01,W
08B4A:  ADDLW  DC
08B4C:  MOVWF  01
08B4E:  MOVLW  01
08B50:  ADDWFC 03,F
08B52:  MOVFF  01,675
08B56:  MOVFF  03,676
08B5A:  MOVFF  03,698
08B5E:  MOVFF  01,697
08B62:  CLRF   x9A
08B64:  CLRF   x99
08B66:  MOVLW  0A
08B68:  MOVWF  x9B
08B6A:  MOVLB  0
08B6C:  CALL   66AE
08B70:  MOVFF  01,66F
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08B74:  MOVLB  6
08B76:  CLRF   xB1
08B78:  MOVFF  663,6B0
08B7C:  CLRF   xB3
08B7E:  MOVLW  B5
08B80:  MOVWF  xB2
08B82:  MOVLB  0
08B84:  CALL   0802
08B88:  MOVFF  02,676
08B8C:  MOVFF  01,675
08B90:  MOVLW  06
08B92:  MOVLB  6
08B94:  ADDWF  x75,F
08B96:  MOVLW  00
08B98:  ADDWFC x76,F
08B9A:  MOVLW  4B
08B9C:  ADDWF  x75,W
08B9E:  MOVWF  01
08BA0:  MOVLW  00
08BA2:  ADDWFC x76,W
08BA4:  MOVWF  03
08BA6:  MOVF   01,W
08BA8:  ADDLW  DC
08BAA:  MOVWF  01
08BAC:  MOVLW  01
08BAE:  ADDWFC 03,F
08BB0:  MOVFF  01,675
08BB4:  MOVFF  03,676
08BB8:  MOVFF  03,6A6
08BBC:  MOVFF  01,6A5
08BC0:  MOVLB  0
08BC2:  CALL   6446
08BC6:  MOVFF  02,03
08BCA:  MOVF   01,W
08BCC:  SUBLW  01
08BCE:  BNZ   8BD4
08BD0:  MOVF   03,F
08BD2:  BZ    8BDC
08BD4:  MOVLW  02
08BD6:  MOVWF  01
08BD8:  BRA    8E4E
08BDA:  BRA    8C1C
....................    else arg2 = SERcmd[rec].p[3][0];
08BDC:  MOVLB  6
08BDE:  CLRF   xB1
08BE0:  MOVFF  663,6B0
08BE4:  CLRF   xB3
08BE6:  MOVLW  B5
08BE8:  MOVWF  xB2
08BEA:  MOVLB  0
08BEC:  CALL   0802
08BF0:  MOVFF  02,676
08BF4:  MOVFF  01,675
08BF8:  MOVLW  06
08BFA:  MOVLB  6
08BFC:  ADDWF  x75,F
08BFE:  MOVLW  00
08C00:  ADDWFC x76,F
08C02:  MOVLW  4B
08C04:  ADDWF  x75,F
08C06:  MOVLW  00
08C08:  ADDWFC x76,F
08C0A:  MOVLW  DC
08C0C:  ADDWF  x75,W
08C0E:  MOVWF  FE9
08C10:  MOVLW  01
08C12:  ADDWFC x76,W
08C14:  MOVWF  FEA
08C16:  MOVFF  FEF,670
08C1A:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
08C1C:  MOVLB  6
08C1E:  CLRF   xB1
08C20:  MOVFF  663,6B0
08C24:  CLRF   xB3
08C26:  MOVLW  B5
08C28:  MOVWF  xB2
08C2A:  MOVLB  0
08C2C:  CALL   0802
08C30:  MOVFF  02,676
08C34:  MOVFF  01,675
08C38:  MOVLW  06
08C3A:  MOVLB  6
08C3C:  ADDWF  x75,F
08C3E:  MOVLW  00
08C40:  ADDWFC x76,F
08C42:  MOVLW  64
08C44:  ADDWF  x75,W
08C46:  MOVWF  01
08C48:  MOVLW  00
08C4A:  ADDWFC x76,W
08C4C:  MOVWF  03
08C4E:  MOVF   01,W
08C50:  ADDLW  DC
08C52:  MOVWF  01
08C54:  MOVLW  01
08C56:  ADDWFC 03,F
08C58:  MOVFF  01,675
08C5C:  MOVFF  03,676
08C60:  MOVFF  03,679
08C64:  MOVFF  01,678
08C68:  MOVLB  0
08C6A:  CALL   788A
08C6E:  MOVF   01,F
08C70:  BNZ   8C7A
08C72:  MOVLW  02
08C74:  MOVWF  01
08C76:  BRA    8E4E
08C78:  BRA    8CE0
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08C7A:  MOVLB  6
08C7C:  CLRF   xB1
08C7E:  MOVFF  663,6B0
08C82:  CLRF   xB3
08C84:  MOVLW  B5
08C86:  MOVWF  xB2
08C88:  MOVLB  0
08C8A:  CALL   0802
08C8E:  MOVFF  02,676
08C92:  MOVFF  01,675
08C96:  MOVLW  06
08C98:  MOVLB  6
08C9A:  ADDWF  x75,F
08C9C:  MOVLW  00
08C9E:  ADDWFC x76,F
08CA0:  MOVLW  64
08CA2:  ADDWF  x75,W
08CA4:  MOVWF  01
08CA6:  MOVLW  00
08CA8:  ADDWFC x76,W
08CAA:  MOVWF  03
08CAC:  MOVF   01,W
08CAE:  ADDLW  DC
08CB0:  MOVWF  01
08CB2:  MOVLW  01
08CB4:  ADDWFC 03,F
08CB6:  MOVFF  01,675
08CBA:  MOVFF  03,676
08CBE:  MOVFF  03,679
08CC2:  MOVFF  01,678
08CC6:  CLRF   x7B
08CC8:  CLRF   x7A
08CCA:  MOVLB  0
08CCC:  CALL   794C
08CD0:  MOVFF  03,674
08CD4:  MOVFF  02,673
08CD8:  MOVFF  01,672
08CDC:  MOVFF  00,671
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08CE0:  MOVLB  6
08CE2:  MOVF   x70,W
08CE4:  SUBLW  30
08CE6:  BNZ   8D12
08CE8:  MOVLW  01
08CEA:  SUBWF  x6F,W
08CEC:  MULLW  18
08CEE:  MOVF   FF3,W
08CF0:  CLRF   x76
08CF2:  MOVWF  x75
08CF4:  MOVLW  82
08CF6:  ADDWF  x75,W
08CF8:  MOVWF  FE9
08CFA:  MOVLW  00
08CFC:  ADDWFC x76,W
08CFE:  MOVWF  FEA
08D00:  MOVFF  671,FEF
08D04:  MOVFF  672,FEC
08D08:  MOVFF  673,FEC
08D0C:  MOVFF  674,FEC
08D10:  BRA    8E48
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08D12:  MOVF   x70,W
08D14:  SUBLW  31
08D16:  BNZ   8D4E
08D18:  MOVLW  01
08D1A:  SUBWF  x6F,W
08D1C:  MULLW  18
08D1E:  MOVF   FF3,W
08D20:  CLRF   x76
08D22:  MOVWF  x75
08D24:  MOVLW  04
08D26:  ADDWF  x75,W
08D28:  MOVWF  01
08D2A:  MOVLW  00
08D2C:  ADDWFC x76,W
08D2E:  MOVWF  03
08D30:  MOVF   01,W
08D32:  ADDLW  82
08D34:  MOVWF  FE9
08D36:  MOVLW  00
08D38:  ADDWFC 03,W
08D3A:  MOVWF  FEA
08D3C:  MOVFF  671,FEF
08D40:  MOVFF  672,FEC
08D44:  MOVFF  673,FEC
08D48:  MOVFF  674,FEC
08D4C:  BRA    8E48
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08D4E:  MOVF   x70,W
08D50:  SUBLW  32
08D52:  BNZ   8D8A
08D54:  MOVLW  01
08D56:  SUBWF  x6F,W
08D58:  MULLW  18
08D5A:  MOVF   FF3,W
08D5C:  CLRF   x76
08D5E:  MOVWF  x75
08D60:  MOVLW  08
08D62:  ADDWF  x75,W
08D64:  MOVWF  01
08D66:  MOVLW  00
08D68:  ADDWFC x76,W
08D6A:  MOVWF  03
08D6C:  MOVF   01,W
08D6E:  ADDLW  82
08D70:  MOVWF  FE9
08D72:  MOVLW  00
08D74:  ADDWFC 03,W
08D76:  MOVWF  FEA
08D78:  MOVFF  671,FEF
08D7C:  MOVFF  672,FEC
08D80:  MOVFF  673,FEC
08D84:  MOVFF  674,FEC
08D88:  BRA    8E48
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08D8A:  MOVF   x70,W
08D8C:  SUBLW  33
08D8E:  BNZ   8DC6
08D90:  MOVLW  01
08D92:  SUBWF  x6F,W
08D94:  MULLW  18
08D96:  MOVF   FF3,W
08D98:  CLRF   x76
08D9A:  MOVWF  x75
08D9C:  MOVLW  0C
08D9E:  ADDWF  x75,W
08DA0:  MOVWF  01
08DA2:  MOVLW  00
08DA4:  ADDWFC x76,W
08DA6:  MOVWF  03
08DA8:  MOVF   01,W
08DAA:  ADDLW  82
08DAC:  MOVWF  FE9
08DAE:  MOVLW  00
08DB0:  ADDWFC 03,W
08DB2:  MOVWF  FEA
08DB4:  MOVFF  671,FEF
08DB8:  MOVFF  672,FEC
08DBC:  MOVFF  673,FEC
08DC0:  MOVFF  674,FEC
08DC4:  BRA    8E48
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08DC6:  MOVF   x70,W
08DC8:  SUBLW  34
08DCA:  BNZ   8E02
08DCC:  MOVLW  01
08DCE:  SUBWF  x6F,W
08DD0:  MULLW  18
08DD2:  MOVF   FF3,W
08DD4:  CLRF   x76
08DD6:  MOVWF  x75
08DD8:  MOVLW  10
08DDA:  ADDWF  x75,W
08DDC:  MOVWF  01
08DDE:  MOVLW  00
08DE0:  ADDWFC x76,W
08DE2:  MOVWF  03
08DE4:  MOVF   01,W
08DE6:  ADDLW  82
08DE8:  MOVWF  FE9
08DEA:  MOVLW  00
08DEC:  ADDWFC 03,W
08DEE:  MOVWF  FEA
08DF0:  MOVFF  671,FEF
08DF4:  MOVFF  672,FEC
08DF8:  MOVFF  673,FEC
08DFC:  MOVFF  674,FEC
08E00:  BRA    8E48
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08E02:  MOVF   x70,W
08E04:  SUBLW  35
08E06:  BNZ   8E3E
08E08:  MOVLW  01
08E0A:  SUBWF  x6F,W
08E0C:  MULLW  18
08E0E:  MOVF   FF3,W
08E10:  CLRF   x76
08E12:  MOVWF  x75
08E14:  MOVLW  14
08E16:  ADDWF  x75,W
08E18:  MOVWF  01
08E1A:  MOVLW  00
08E1C:  ADDWFC x76,W
08E1E:  MOVWF  03
08E20:  MOVF   01,W
08E22:  ADDLW  82
08E24:  MOVWF  FE9
08E26:  MOVLW  00
08E28:  ADDWFC 03,W
08E2A:  MOVWF  FEA
08E2C:  MOVFF  671,FEF
08E30:  MOVFF  672,FEC
08E34:  MOVFF  673,FEC
08E38:  MOVFF  674,FEC
08E3C:  BRA    8E48
....................    else return INV_PARAM;
08E3E:  MOVLW  02
08E40:  MOVWF  01
08E42:  MOVLB  0
08E44:  BRA    8E4E
08E46:  MOVLB  6
....................    
....................    return SUCCESS;
08E48:  MOVLW  00
08E4A:  MOVWF  01
08E4C:  MOVLB  0
08E4E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08E50:  MOVLW  4E
08E52:  MOVLB  6
08E54:  MOVWF  x73
08E56:  MOVLW  31
08E58:  MOVWF  x74
08E5A:  MOVLW  35
08E5C:  MOVWF  x75
08E5E:  CLRF   x76
08E60:  MOVLW  06
08E62:  MOVWF  x72
08E64:  MOVLW  73
08E66:  MOVWF  x71
....................    char *s_200 = "200";
08E68:  MOVLW  32
08E6A:  MOVWF  x79
08E6C:  MOVLW  30
08E6E:  MOVWF  x7A
08E70:  MOVWF  x7B
08E72:  CLRF   x7C
08E74:  MOVLW  06
08E76:  MOVWF  x78
08E78:  MOVLW  79
08E7A:  MOVWF  x77
....................    char *s_5V6 = "5V6";
08E7C:  MOVLW  35
08E7E:  MOVWF  x7F
08E80:  MOVLW  56
08E82:  MOVWF  x80
08E84:  MOVLW  36
08E86:  MOVWF  x81
08E88:  CLRF   x82
08E8A:  MOVLW  06
08E8C:  MOVWF  x7E
08E8E:  MOVLW  7F
08E90:  MOVWF  x7D
....................    char *s_5VA = "5VA";
08E92:  MOVLW  35
08E94:  MOVWF  x85
08E96:  MOVLW  56
08E98:  MOVWF  x86
08E9A:  MOVLW  41
08E9C:  MOVWF  x87
08E9E:  CLRF   x88
08EA0:  MOVLW  06
08EA2:  MOVWF  x84
08EA4:  MOVLW  85
08EA6:  MOVWF  x83
....................    char *s_3V6X = "3V6X";
08EA8:  MOVLW  33
08EAA:  MOVWF  x8B
08EAC:  MOVLW  56
08EAE:  MOVWF  x8C
08EB0:  MOVLW  36
08EB2:  MOVWF  x8D
08EB4:  MOVLW  58
08EB6:  MOVWF  x8E
08EB8:  CLRF   x8F
08EBA:  MOVLW  06
08EBC:  MOVWF  x8A
08EBE:  MOVLW  8B
08EC0:  MOVWF  x89
....................    char *s_3V3A = "3V3A";
08EC2:  MOVLW  33
08EC4:  MOVWF  x92
08EC6:  MOVLW  56
08EC8:  MOVWF  x93
08ECA:  MOVLW  33
08ECC:  MOVWF  x94
08ECE:  MOVLW  41
08ED0:  MOVWF  x95
08ED2:  CLRF   x96
08ED4:  MOVLW  06
08ED6:  MOVWF  x91
08ED8:  MOVLW  92
08EDA:  MOVWF  x90
....................    char *s_3V3D = "3V3D";
08EDC:  MOVLW  33
08EDE:  MOVWF  x99
08EE0:  MOVLW  56
08EE2:  MOVWF  x9A
08EE4:  MOVLW  33
08EE6:  MOVWF  x9B
08EE8:  MOVLW  44
08EEA:  MOVWF  x9C
08EEC:  CLRF   x9D
08EEE:  MOVLW  06
08EF0:  MOVWF  x98
08EF2:  MOVLW  99
08EF4:  MOVWF  x97
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08EF6:  CLRF   xB1
08EF8:  MOVFF  663,6B0
08EFC:  CLRF   xB3
08EFE:  MOVLW  B5
08F00:  MOVWF  xB2
08F02:  MOVLB  0
08F04:  CALL   0802
08F08:  MOVFF  02,69F
08F0C:  MOVFF  01,69E
08F10:  MOVLW  06
08F12:  MOVLB  6
08F14:  ADDWF  x9E,F
08F16:  MOVLW  00
08F18:  ADDWFC x9F,F
08F1A:  MOVLW  32
08F1C:  ADDWF  x9E,W
08F1E:  MOVWF  01
08F20:  MOVLW  00
08F22:  ADDWFC x9F,W
08F24:  MOVWF  03
08F26:  MOVF   01,W
08F28:  ADDLW  DC
08F2A:  MOVWF  01
08F2C:  MOVLW  01
08F2E:  ADDWFC 03,F
08F30:  MOVFF  01,66F
08F34:  MOVFF  03,670
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08F38:  MOVFF  672,6A6
08F3C:  MOVFF  671,6A5
08F40:  MOVFF  670,6A8
08F44:  MOVFF  66F,6A7
08F48:  MOVLB  0
08F4A:  CALL   647E
08F4E:  MOVF   01,F
08F50:  BNZ   8FD4
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08F52:  MOVLW  04
08F54:  MOVLB  6
08F56:  MOVWF  xA6
08F58:  MOVLW  B2
08F5A:  MOVWF  xA5
08F5C:  MOVLB  0
08F5E:  CALL   6446
08F62:  MOVFF  02,03
08F66:  MOVF   01,W
08F68:  ADDLW  B2
08F6A:  MOVLB  6
08F6C:  MOVWF  x9E
08F6E:  MOVLW  04
08F70:  ADDWFC 02,W
08F72:  MOVWF  x9F
08F74:  MOVFF  FE8,557
08F78:  MOVFF  69E,556
08F7C:  MOVLW  89
08F7E:  MOVWF  FE9
08F80:  MOVFF  B5,6AA
08F84:  MOVFF  B4,6A9
08F88:  MOVFF  B3,6A8
08F8C:  MOVFF  B2,6A7
08F90:  MOVLW  02
08F92:  MOVWF  xAB
08F94:  MOVLB  0
08F96:  CALL   721E
08F9A:  MOVLW  2C
08F9C:  MOVLB  6
08F9E:  MOVWF  xB4
08FA0:  MOVLB  0
08FA2:  CALL   64F6
08FA6:  MOVLW  89
08FA8:  MOVWF  FE9
08FAA:  MOVFF  B9,6AA
08FAE:  MOVFF  B8,6A9
08FB2:  MOVFF  B7,6A8
08FB6:  MOVFF  B6,6A7
08FBA:  MOVLW  02
08FBC:  MOVLB  6
08FBE:  MOVWF  xAB
08FC0:  MOVLB  0
08FC2:  CALL   721E
08FC6:  MOVLW  2C
08FC8:  MOVLB  6
08FCA:  MOVWF  xB4
08FCC:  MOVLB  0
08FCE:  CALL   64F6
....................    }
08FD2:  BRA    9376
....................    else if (0 == strcmp(s_200, arg1)) {
08FD4:  MOVFF  678,6A6
08FD8:  MOVFF  677,6A5
08FDC:  MOVFF  670,6A8
08FE0:  MOVFF  66F,6A7
08FE4:  CALL   647E
08FE8:  MOVF   01,F
08FEA:  BNZ   906E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08FEC:  MOVLW  04
08FEE:  MOVLB  6
08FF0:  MOVWF  xA6
08FF2:  MOVLW  B2
08FF4:  MOVWF  xA5
08FF6:  MOVLB  0
08FF8:  CALL   6446
08FFC:  MOVFF  02,03
09000:  MOVF   01,W
09002:  ADDLW  B2
09004:  MOVLB  6
09006:  MOVWF  x9E
09008:  MOVLW  04
0900A:  ADDWFC 02,W
0900C:  MOVWF  x9F
0900E:  MOVFF  FE8,557
09012:  MOVFF  69E,556
09016:  MOVLW  89
09018:  MOVWF  FE9
0901A:  MOVFF  BD,6AA
0901E:  MOVFF  BC,6A9
09022:  MOVFF  BB,6A8
09026:  MOVFF  BA,6A7
0902A:  MOVLW  02
0902C:  MOVWF  xAB
0902E:  MOVLB  0
09030:  CALL   721E
09034:  MOVLW  2C
09036:  MOVLB  6
09038:  MOVWF  xB4
0903A:  MOVLB  0
0903C:  CALL   64F6
09040:  MOVLW  89
09042:  MOVWF  FE9
09044:  MOVFF  C1,6AA
09048:  MOVFF  C0,6A9
0904C:  MOVFF  BF,6A8
09050:  MOVFF  BE,6A7
09054:  MOVLW  02
09056:  MOVLB  6
09058:  MOVWF  xAB
0905A:  MOVLB  0
0905C:  CALL   721E
09060:  MOVLW  2C
09062:  MOVLB  6
09064:  MOVWF  xB4
09066:  MOVLB  0
09068:  CALL   64F6
....................    }
0906C:  BRA    9376
....................    else if (0 == strcmp(s_5V6, arg1)) {
0906E:  MOVFF  67E,6A6
09072:  MOVFF  67D,6A5
09076:  MOVFF  670,6A8
0907A:  MOVFF  66F,6A7
0907E:  CALL   647E
09082:  MOVF   01,F
09084:  BNZ   9108
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
09086:  MOVLW  04
09088:  MOVLB  6
0908A:  MOVWF  xA6
0908C:  MOVLW  B2
0908E:  MOVWF  xA5
09090:  MOVLB  0
09092:  CALL   6446
09096:  MOVFF  02,03
0909A:  MOVF   01,W
0909C:  ADDLW  B2
0909E:  MOVLB  6
090A0:  MOVWF  x9E
090A2:  MOVLW  04
090A4:  ADDWFC 02,W
090A6:  MOVWF  x9F
090A8:  MOVFF  FE8,557
090AC:  MOVFF  69E,556
090B0:  MOVLW  89
090B2:  MOVWF  FE9
090B4:  MOVFF  C5,6AA
090B8:  MOVFF  C4,6A9
090BC:  MOVFF  C3,6A8
090C0:  MOVFF  C2,6A7
090C4:  MOVLW  02
090C6:  MOVWF  xAB
090C8:  MOVLB  0
090CA:  CALL   721E
090CE:  MOVLW  2C
090D0:  MOVLB  6
090D2:  MOVWF  xB4
090D4:  MOVLB  0
090D6:  CALL   64F6
090DA:  MOVLW  89
090DC:  MOVWF  FE9
090DE:  MOVFF  C9,6AA
090E2:  MOVFF  C8,6A9
090E6:  MOVFF  C7,6A8
090EA:  MOVFF  C6,6A7
090EE:  MOVLW  02
090F0:  MOVLB  6
090F2:  MOVWF  xAB
090F4:  MOVLB  0
090F6:  CALL   721E
090FA:  MOVLW  2C
090FC:  MOVLB  6
090FE:  MOVWF  xB4
09100:  MOVLB  0
09102:  CALL   64F6
....................    }
09106:  BRA    9376
....................    else if (0 == strcmp(s_5VA, arg1)) {
09108:  MOVFF  684,6A6
0910C:  MOVFF  683,6A5
09110:  MOVFF  670,6A8
09114:  MOVFF  66F,6A7
09118:  CALL   647E
0911C:  MOVF   01,F
0911E:  BNZ   91A2
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
09120:  MOVLW  04
09122:  MOVLB  6
09124:  MOVWF  xA6
09126:  MOVLW  B2
09128:  MOVWF  xA5
0912A:  MOVLB  0
0912C:  CALL   6446
09130:  MOVFF  02,03
09134:  MOVF   01,W
09136:  ADDLW  B2
09138:  MOVLB  6
0913A:  MOVWF  x9E
0913C:  MOVLW  04
0913E:  ADDWFC 02,W
09140:  MOVWF  x9F
09142:  MOVFF  FE8,557
09146:  MOVFF  69E,556
0914A:  MOVLW  89
0914C:  MOVWF  FE9
0914E:  MOVFF  CD,6AA
09152:  MOVFF  CC,6A9
09156:  MOVFF  CB,6A8
0915A:  MOVFF  CA,6A7
0915E:  MOVLW  02
09160:  MOVWF  xAB
09162:  MOVLB  0
09164:  CALL   721E
09168:  MOVLW  2C
0916A:  MOVLB  6
0916C:  MOVWF  xB4
0916E:  MOVLB  0
09170:  CALL   64F6
09174:  MOVLW  89
09176:  MOVWF  FE9
09178:  MOVFF  D1,6AA
0917C:  MOVFF  D0,6A9
09180:  MOVFF  CF,6A8
09184:  MOVFF  CE,6A7
09188:  MOVLW  02
0918A:  MOVLB  6
0918C:  MOVWF  xAB
0918E:  MOVLB  0
09190:  CALL   721E
09194:  MOVLW  2C
09196:  MOVLB  6
09198:  MOVWF  xB4
0919A:  MOVLB  0
0919C:  CALL   64F6
....................    }
091A0:  BRA    9376
....................    else if (0 == strcmp(s_3V6X, arg1)) {
091A2:  MOVFF  68A,6A6
091A6:  MOVFF  689,6A5
091AA:  MOVFF  670,6A8
091AE:  MOVFF  66F,6A7
091B2:  CALL   647E
091B6:  MOVF   01,F
091B8:  BNZ   923C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
091BA:  MOVLW  04
091BC:  MOVLB  6
091BE:  MOVWF  xA6
091C0:  MOVLW  B2
091C2:  MOVWF  xA5
091C4:  MOVLB  0
091C6:  CALL   6446
091CA:  MOVFF  02,03
091CE:  MOVF   01,W
091D0:  ADDLW  B2
091D2:  MOVLB  6
091D4:  MOVWF  x9E
091D6:  MOVLW  04
091D8:  ADDWFC 02,W
091DA:  MOVWF  x9F
091DC:  MOVFF  FE8,557
091E0:  MOVFF  69E,556
091E4:  MOVLW  89
091E6:  MOVWF  FE9
091E8:  MOVFF  D5,6AA
091EC:  MOVFF  D4,6A9
091F0:  MOVFF  D3,6A8
091F4:  MOVFF  D2,6A7
091F8:  MOVLW  02
091FA:  MOVWF  xAB
091FC:  MOVLB  0
091FE:  CALL   721E
09202:  MOVLW  2C
09204:  MOVLB  6
09206:  MOVWF  xB4
09208:  MOVLB  0
0920A:  CALL   64F6
0920E:  MOVLW  89
09210:  MOVWF  FE9
09212:  MOVFF  D9,6AA
09216:  MOVFF  D8,6A9
0921A:  MOVFF  D7,6A8
0921E:  MOVFF  D6,6A7
09222:  MOVLW  02
09224:  MOVLB  6
09226:  MOVWF  xAB
09228:  MOVLB  0
0922A:  CALL   721E
0922E:  MOVLW  2C
09230:  MOVLB  6
09232:  MOVWF  xB4
09234:  MOVLB  0
09236:  CALL   64F6
....................    }
0923A:  BRA    9376
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0923C:  MOVFF  691,6A6
09240:  MOVFF  690,6A5
09244:  MOVFF  670,6A8
09248:  MOVFF  66F,6A7
0924C:  CALL   647E
09250:  MOVF   01,F
09252:  BNZ   92D6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
09254:  MOVLW  04
09256:  MOVLB  6
09258:  MOVWF  xA6
0925A:  MOVLW  B2
0925C:  MOVWF  xA5
0925E:  MOVLB  0
09260:  CALL   6446
09264:  MOVFF  02,03
09268:  MOVF   01,W
0926A:  ADDLW  B2
0926C:  MOVLB  6
0926E:  MOVWF  x9E
09270:  MOVLW  04
09272:  ADDWFC 02,W
09274:  MOVWF  x9F
09276:  MOVFF  FE8,557
0927A:  MOVFF  69E,556
0927E:  MOVLW  89
09280:  MOVWF  FE9
09282:  MOVFF  DD,6AA
09286:  MOVFF  DC,6A9
0928A:  MOVFF  DB,6A8
0928E:  MOVFF  DA,6A7
09292:  MOVLW  02
09294:  MOVWF  xAB
09296:  MOVLB  0
09298:  CALL   721E
0929C:  MOVLW  2C
0929E:  MOVLB  6
092A0:  MOVWF  xB4
092A2:  MOVLB  0
092A4:  CALL   64F6
092A8:  MOVLW  89
092AA:  MOVWF  FE9
092AC:  MOVFF  E1,6AA
092B0:  MOVFF  E0,6A9
092B4:  MOVFF  DF,6A8
092B8:  MOVFF  DE,6A7
092BC:  MOVLW  02
092BE:  MOVLB  6
092C0:  MOVWF  xAB
092C2:  MOVLB  0
092C4:  CALL   721E
092C8:  MOVLW  2C
092CA:  MOVLB  6
092CC:  MOVWF  xB4
092CE:  MOVLB  0
092D0:  CALL   64F6
....................    }
092D4:  BRA    9376
....................    else if (0 == strcmp(s_3V3D, arg1)) {
092D6:  MOVFF  698,6A6
092DA:  MOVFF  697,6A5
092DE:  MOVFF  670,6A8
092E2:  MOVFF  66F,6A7
092E6:  CALL   647E
092EA:  MOVF   01,F
092EC:  BNZ   9370
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
092EE:  MOVLW  04
092F0:  MOVLB  6
092F2:  MOVWF  xA6
092F4:  MOVLW  B2
092F6:  MOVWF  xA5
092F8:  MOVLB  0
092FA:  CALL   6446
092FE:  MOVFF  02,03
09302:  MOVF   01,W
09304:  ADDLW  B2
09306:  MOVLB  6
09308:  MOVWF  x9E
0930A:  MOVLW  04
0930C:  ADDWFC 02,W
0930E:  MOVWF  x9F
09310:  MOVFF  FE8,557
09314:  MOVFF  69E,556
09318:  MOVLW  89
0931A:  MOVWF  FE9
0931C:  MOVFF  E5,6AA
09320:  MOVFF  E4,6A9
09324:  MOVFF  E3,6A8
09328:  MOVFF  E2,6A7
0932C:  MOVLW  02
0932E:  MOVWF  xAB
09330:  MOVLB  0
09332:  CALL   721E
09336:  MOVLW  2C
09338:  MOVLB  6
0933A:  MOVWF  xB4
0933C:  MOVLB  0
0933E:  CALL   64F6
09342:  MOVLW  89
09344:  MOVWF  FE9
09346:  MOVFF  E9,6AA
0934A:  MOVFF  E8,6A9
0934E:  MOVFF  E7,6A8
09352:  MOVFF  E6,6A7
09356:  MOVLW  02
09358:  MOVLB  6
0935A:  MOVWF  xAB
0935C:  MOVLB  0
0935E:  CALL   721E
09362:  MOVLW  2C
09364:  MOVLB  6
09366:  MOVWF  xB4
09368:  MOVLB  0
0936A:  CALL   64F6
....................    }
0936E:  BRA    9376
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
09370:  MOVLW  02
09372:  MOVWF  01
09374:  BRA    937A
....................    
....................    return SUCCESS;
09376:  MOVLW  00
09378:  MOVWF  01
0937A:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
0937C:  MOVLW  00
0937E:  MOVWF  01
09380:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
09382:  MOVLW  4E
09384:  MOVLB  6
09386:  MOVWF  x73
09388:  MOVLW  31
0938A:  MOVWF  x74
0938C:  MOVLW  35
0938E:  MOVWF  x75
09390:  CLRF   x76
09392:  MOVLW  06
09394:  MOVWF  x72
09396:  MOVLW  73
09398:  MOVWF  x71
....................    char *s_200 = "200";
0939A:  MOVLW  32
0939C:  MOVWF  x79
0939E:  MOVLW  30
093A0:  MOVWF  x7A
093A2:  MOVWF  x7B
093A4:  CLRF   x7C
093A6:  MOVLW  06
093A8:  MOVWF  x78
093AA:  MOVLW  79
093AC:  MOVWF  x77
....................    char *s_5V6 = "5V6";
093AE:  MOVLW  35
093B0:  MOVWF  x7F
093B2:  MOVLW  56
093B4:  MOVWF  x80
093B6:  MOVLW  36
093B8:  MOVWF  x81
093BA:  CLRF   x82
093BC:  MOVLW  06
093BE:  MOVWF  x7E
093C0:  MOVLW  7F
093C2:  MOVWF  x7D
....................    char *s_5VA = "5VA";
093C4:  MOVLW  35
093C6:  MOVWF  x85
093C8:  MOVLW  56
093CA:  MOVWF  x86
093CC:  MOVLW  41
093CE:  MOVWF  x87
093D0:  CLRF   x88
093D2:  MOVLW  06
093D4:  MOVWF  x84
093D6:  MOVLW  85
093D8:  MOVWF  x83
....................    char *s_3V6X = "3V6X";
093DA:  MOVLW  33
093DC:  MOVWF  x8B
093DE:  MOVLW  56
093E0:  MOVWF  x8C
093E2:  MOVLW  36
093E4:  MOVWF  x8D
093E6:  MOVLW  58
093E8:  MOVWF  x8E
093EA:  CLRF   x8F
093EC:  MOVLW  06
093EE:  MOVWF  x8A
093F0:  MOVLW  8B
093F2:  MOVWF  x89
....................    char *s_3V3A = "3V3A";
093F4:  MOVLW  33
093F6:  MOVWF  x92
093F8:  MOVLW  56
093FA:  MOVWF  x93
093FC:  MOVLW  33
093FE:  MOVWF  x94
09400:  MOVLW  41
09402:  MOVWF  x95
09404:  CLRF   x96
09406:  MOVLW  06
09408:  MOVWF  x91
0940A:  MOVLW  92
0940C:  MOVWF  x90
....................    char *s_3V3D = "3V3D";
0940E:  MOVLW  33
09410:  MOVWF  x99
09412:  MOVLW  56
09414:  MOVWF  x9A
09416:  MOVLW  33
09418:  MOVWF  x9B
0941A:  MOVLW  44
0941C:  MOVWF  x9C
0941E:  CLRF   x9D
09420:  MOVLW  06
09422:  MOVWF  x98
09424:  MOVLW  99
09426:  MOVWF  x97
....................    char *s_all = "all";
09428:  MOVLW  61
0942A:  MOVWF  xA0
0942C:  MOVLW  6C
0942E:  MOVWF  xA1
09430:  MOVWF  xA2
09432:  CLRF   xA3
09434:  MOVLW  06
09436:  MOVWF  x9F
09438:  MOVLW  A0
0943A:  MOVWF  x9E
....................    
....................    arg1 = SERcmd[rec].p[2];
0943C:  CLRF   xB1
0943E:  MOVFF  663,6B0
09442:  CLRF   xB3
09444:  MOVLW  B5
09446:  MOVWF  xB2
09448:  MOVLB  0
0944A:  CALL   0802
0944E:  MOVFF  02,6A5
09452:  MOVFF  01,6A4
09456:  MOVLW  06
09458:  MOVLB  6
0945A:  ADDWF  xA4,F
0945C:  MOVLW  00
0945E:  ADDWFC xA5,F
09460:  MOVLW  32
09462:  ADDWF  xA4,W
09464:  MOVWF  01
09466:  MOVLW  00
09468:  ADDWFC xA5,W
0946A:  MOVWF  03
0946C:  MOVF   01,W
0946E:  ADDLW  DC
09470:  MOVWF  01
09472:  MOVLW  01
09474:  ADDWFC 03,F
09476:  MOVFF  01,66F
0947A:  MOVFF  03,670
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0947E:  MOVFF  672,6A6
09482:  MOVFF  671,6A5
09486:  MOVFF  670,6A8
0948A:  MOVFF  66F,6A7
0948E:  MOVLB  0
09490:  CALL   647E
09494:  MOVF   01,F
09496:  BNZ   94EE
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
09498:  MOVLW  04
0949A:  MOVLB  6
0949C:  MOVWF  xA6
0949E:  MOVLW  B2
094A0:  MOVWF  xA5
094A2:  MOVLB  0
094A4:  CALL   6446
094A8:  MOVFF  02,03
094AC:  MOVF   01,W
094AE:  ADDLW  B2
094B0:  MOVLB  6
094B2:  MOVWF  xA4
094B4:  MOVLW  04
094B6:  ADDWFC 02,W
094B8:  MOVWF  xA5
094BA:  MOVFF  FE8,557
094BE:  MOVFF  6A4,556
094C2:  MOVLW  89
094C4:  MOVWF  FE9
094C6:  MOVFF  F6,6AA
094CA:  MOVFF  F5,6A9
094CE:  MOVFF  F4,6A8
094D2:  MOVFF  F3,6A7
094D6:  MOVLW  02
094D8:  MOVWF  xAB
094DA:  MOVLB  0
094DC:  CALL   721E
094E0:  MOVLW  2C
094E2:  MOVLB  6
094E4:  MOVWF  xB4
094E6:  MOVLB  0
094E8:  CALL   64F6
....................    }
094EC:  BRA    99F0
....................    else if (0 == strcmp(s_200, arg1)) {
094EE:  MOVFF  678,6A6
094F2:  MOVFF  677,6A5
094F6:  MOVFF  670,6A8
094FA:  MOVFF  66F,6A7
094FE:  CALL   647E
09502:  MOVF   01,F
09504:  BNZ   955C
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
09506:  MOVLW  04
09508:  MOVLB  6
0950A:  MOVWF  xA6
0950C:  MOVLW  B2
0950E:  MOVWF  xA5
09510:  MOVLB  0
09512:  CALL   6446
09516:  MOVFF  02,03
0951A:  MOVF   01,W
0951C:  ADDLW  B2
0951E:  MOVLB  6
09520:  MOVWF  xA4
09522:  MOVLW  04
09524:  ADDWFC 02,W
09526:  MOVWF  xA5
09528:  MOVFF  FE8,557
0952C:  MOVFF  6A4,556
09530:  MOVLW  89
09532:  MOVWF  FE9
09534:  MOVFF  FA,6AA
09538:  MOVFF  F9,6A9
0953C:  MOVFF  F8,6A8
09540:  MOVFF  F7,6A7
09544:  MOVLW  01
09546:  MOVWF  xAB
09548:  MOVLB  0
0954A:  CALL   721E
0954E:  MOVLW  2C
09550:  MOVLB  6
09552:  MOVWF  xB4
09554:  MOVLB  0
09556:  CALL   64F6
....................    }
0955A:  BRA    99F0
....................    else if (0 == strcmp(s_5V6, arg1)) {
0955C:  MOVFF  67E,6A6
09560:  MOVFF  67D,6A5
09564:  MOVFF  670,6A8
09568:  MOVFF  66F,6A7
0956C:  CALL   647E
09570:  MOVF   01,F
09572:  BNZ   95CA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
09574:  MOVLW  04
09576:  MOVLB  6
09578:  MOVWF  xA6
0957A:  MOVLW  B2
0957C:  MOVWF  xA5
0957E:  MOVLB  0
09580:  CALL   6446
09584:  MOVFF  02,03
09588:  MOVF   01,W
0958A:  ADDLW  B2
0958C:  MOVLB  6
0958E:  MOVWF  xA4
09590:  MOVLW  04
09592:  ADDWFC 02,W
09594:  MOVWF  xA5
09596:  MOVFF  FE8,557
0959A:  MOVFF  6A4,556
0959E:  MOVLW  89
095A0:  MOVWF  FE9
095A2:  MOVFF  FE,6AA
095A6:  MOVFF  FD,6A9
095AA:  MOVFF  FC,6A8
095AE:  MOVFF  FB,6A7
095B2:  MOVLW  03
095B4:  MOVWF  xAB
095B6:  MOVLB  0
095B8:  CALL   721E
095BC:  MOVLW  2C
095BE:  MOVLB  6
095C0:  MOVWF  xB4
095C2:  MOVLB  0
095C4:  CALL   64F6
....................    }
095C8:  BRA    99F0
....................    else if (0 == strcmp(s_5VA, arg1)) {
095CA:  MOVFF  684,6A6
095CE:  MOVFF  683,6A5
095D2:  MOVFF  670,6A8
095D6:  MOVFF  66F,6A7
095DA:  CALL   647E
095DE:  MOVF   01,F
095E0:  BNZ   9638
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
095E2:  MOVLW  04
095E4:  MOVLB  6
095E6:  MOVWF  xA6
095E8:  MOVLW  B2
095EA:  MOVWF  xA5
095EC:  MOVLB  0
095EE:  CALL   6446
095F2:  MOVFF  02,03
095F6:  MOVF   01,W
095F8:  ADDLW  B2
095FA:  MOVLB  6
095FC:  MOVWF  xA4
095FE:  MOVLW  04
09600:  ADDWFC 02,W
09602:  MOVWF  xA5
09604:  MOVFF  FE8,557
09608:  MOVFF  6A4,556
0960C:  MOVLW  89
0960E:  MOVWF  FE9
09610:  MOVFF  102,6AA
09614:  MOVFF  101,6A9
09618:  MOVFF  100,6A8
0961C:  MOVFF  FF,6A7
09620:  MOVLW  03
09622:  MOVWF  xAB
09624:  MOVLB  0
09626:  CALL   721E
0962A:  MOVLW  2C
0962C:  MOVLB  6
0962E:  MOVWF  xB4
09630:  MOVLB  0
09632:  CALL   64F6
....................    }
09636:  BRA    99F0
....................    else if (0 == strcmp(s_3V6X, arg1)) {
09638:  MOVFF  68A,6A6
0963C:  MOVFF  689,6A5
09640:  MOVFF  670,6A8
09644:  MOVFF  66F,6A7
09648:  CALL   647E
0964C:  MOVF   01,F
0964E:  BNZ   96A6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
09650:  MOVLW  04
09652:  MOVLB  6
09654:  MOVWF  xA6
09656:  MOVLW  B2
09658:  MOVWF  xA5
0965A:  MOVLB  0
0965C:  CALL   6446
09660:  MOVFF  02,03
09664:  MOVF   01,W
09666:  ADDLW  B2
09668:  MOVLB  6
0966A:  MOVWF  xA4
0966C:  MOVLW  04
0966E:  ADDWFC 02,W
09670:  MOVWF  xA5
09672:  MOVFF  FE8,557
09676:  MOVFF  6A4,556
0967A:  MOVLW  89
0967C:  MOVWF  FE9
0967E:  MOVFF  106,6AA
09682:  MOVFF  105,6A9
09686:  MOVFF  104,6A8
0968A:  MOVFF  103,6A7
0968E:  MOVLW  03
09690:  MOVWF  xAB
09692:  MOVLB  0
09694:  CALL   721E
09698:  MOVLW  2C
0969A:  MOVLB  6
0969C:  MOVWF  xB4
0969E:  MOVLB  0
096A0:  CALL   64F6
....................    }
096A4:  BRA    99F0
....................    else if (0 == strcmp(s_3V3A, arg1)) {
096A6:  MOVFF  691,6A6
096AA:  MOVFF  690,6A5
096AE:  MOVFF  670,6A8
096B2:  MOVFF  66F,6A7
096B6:  CALL   647E
096BA:  MOVF   01,F
096BC:  BNZ   9714
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
096BE:  MOVLW  04
096C0:  MOVLB  6
096C2:  MOVWF  xA6
096C4:  MOVLW  B2
096C6:  MOVWF  xA5
096C8:  MOVLB  0
096CA:  CALL   6446
096CE:  MOVFF  02,03
096D2:  MOVF   01,W
096D4:  ADDLW  B2
096D6:  MOVLB  6
096D8:  MOVWF  xA4
096DA:  MOVLW  04
096DC:  ADDWFC 02,W
096DE:  MOVWF  xA5
096E0:  MOVFF  FE8,557
096E4:  MOVFF  6A4,556
096E8:  MOVLW  89
096EA:  MOVWF  FE9
096EC:  MOVFF  10A,6AA
096F0:  MOVFF  109,6A9
096F4:  MOVFF  108,6A8
096F8:  MOVFF  107,6A7
096FC:  MOVLW  03
096FE:  MOVWF  xAB
09700:  MOVLB  0
09702:  CALL   721E
09706:  MOVLW  2C
09708:  MOVLB  6
0970A:  MOVWF  xB4
0970C:  MOVLB  0
0970E:  CALL   64F6
....................    }
09712:  BRA    99F0
....................    else if (0 == strcmp(s_3V3D, arg1)) {
09714:  MOVFF  698,6A6
09718:  MOVFF  697,6A5
0971C:  MOVFF  670,6A8
09720:  MOVFF  66F,6A7
09724:  CALL   647E
09728:  MOVF   01,F
0972A:  BNZ   9782
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
0972C:  MOVLW  04
0972E:  MOVLB  6
09730:  MOVWF  xA6
09732:  MOVLW  B2
09734:  MOVWF  xA5
09736:  MOVLB  0
09738:  CALL   6446
0973C:  MOVFF  02,03
09740:  MOVF   01,W
09742:  ADDLW  B2
09744:  MOVLB  6
09746:  MOVWF  xA4
09748:  MOVLW  04
0974A:  ADDWFC 02,W
0974C:  MOVWF  xA5
0974E:  MOVFF  FE8,557
09752:  MOVFF  6A4,556
09756:  MOVLW  89
09758:  MOVWF  FE9
0975A:  MOVFF  10E,6AA
0975E:  MOVFF  10D,6A9
09762:  MOVFF  10C,6A8
09766:  MOVFF  10B,6A7
0976A:  MOVLW  03
0976C:  MOVWF  xAB
0976E:  MOVLB  0
09770:  CALL   721E
09774:  MOVLW  2C
09776:  MOVLB  6
09778:  MOVWF  xB4
0977A:  MOVLB  0
0977C:  CALL   64F6
....................    }
09780:  BRA    99F0
....................    else if (0 == strcmp(s_all, arg1)) {
09782:  MOVFF  69F,6A6
09786:  MOVFF  69E,6A5
0978A:  MOVFF  670,6A8
0978E:  MOVFF  66F,6A7
09792:  CALL   647E
09796:  MOVF   01,F
09798:  BTFSS  FD8.2
0979A:  BRA    99EA
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0979C:  MOVLW  04
0979E:  MOVLB  6
097A0:  MOVWF  xA6
097A2:  MOVLW  B2
097A4:  MOVWF  xA5
097A6:  MOVLB  0
097A8:  CALL   6446
097AC:  MOVFF  02,03
097B0:  MOVF   01,W
097B2:  ADDLW  B2
097B4:  MOVLB  6
097B6:  MOVWF  xA4
097B8:  MOVLW  04
097BA:  ADDWFC 02,W
097BC:  MOVWF  xA5
097BE:  MOVFF  FE8,557
097C2:  MOVFF  6A4,556
097C6:  MOVLW  89
097C8:  MOVWF  FE9
097CA:  MOVFF  F6,6AA
097CE:  MOVFF  F5,6A9
097D2:  MOVFF  F4,6A8
097D6:  MOVFF  F3,6A7
097DA:  MOVLW  02
097DC:  MOVWF  xAB
097DE:  MOVLB  0
097E0:  CALL   721E
097E4:  MOVLW  2C
097E6:  MOVLB  6
097E8:  MOVWF  xB4
097EA:  MOVLB  0
097EC:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
097F0:  MOVLW  04
097F2:  MOVLB  6
097F4:  MOVWF  xA6
097F6:  MOVLW  B2
097F8:  MOVWF  xA5
097FA:  MOVLB  0
097FC:  CALL   6446
09800:  MOVFF  02,03
09804:  MOVF   01,W
09806:  ADDLW  B2
09808:  MOVLB  6
0980A:  MOVWF  xA4
0980C:  MOVLW  04
0980E:  ADDWFC 02,W
09810:  MOVWF  xA5
09812:  MOVFF  FE8,557
09816:  MOVFF  6A4,556
0981A:  MOVLW  89
0981C:  MOVWF  FE9
0981E:  MOVFF  FA,6AA
09822:  MOVFF  F9,6A9
09826:  MOVFF  F8,6A8
0982A:  MOVFF  F7,6A7
0982E:  MOVLW  01
09830:  MOVWF  xAB
09832:  MOVLB  0
09834:  CALL   721E
09838:  MOVLW  2C
0983A:  MOVLB  6
0983C:  MOVWF  xB4
0983E:  MOVLB  0
09840:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
09844:  MOVLW  04
09846:  MOVLB  6
09848:  MOVWF  xA6
0984A:  MOVLW  B2
0984C:  MOVWF  xA5
0984E:  MOVLB  0
09850:  CALL   6446
09854:  MOVFF  02,03
09858:  MOVF   01,W
0985A:  ADDLW  B2
0985C:  MOVLB  6
0985E:  MOVWF  xA4
09860:  MOVLW  04
09862:  ADDWFC 02,W
09864:  MOVWF  xA5
09866:  MOVFF  FE8,557
0986A:  MOVFF  6A4,556
0986E:  MOVLW  89
09870:  MOVWF  FE9
09872:  MOVFF  FE,6AA
09876:  MOVFF  FD,6A9
0987A:  MOVFF  FC,6A8
0987E:  MOVFF  FB,6A7
09882:  MOVLW  03
09884:  MOVWF  xAB
09886:  MOVLB  0
09888:  CALL   721E
0988C:  MOVLW  2C
0988E:  MOVLB  6
09890:  MOVWF  xB4
09892:  MOVLB  0
09894:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
09898:  MOVLW  04
0989A:  MOVLB  6
0989C:  MOVWF  xA6
0989E:  MOVLW  B2
098A0:  MOVWF  xA5
098A2:  MOVLB  0
098A4:  CALL   6446
098A8:  MOVFF  02,03
098AC:  MOVF   01,W
098AE:  ADDLW  B2
098B0:  MOVLB  6
098B2:  MOVWF  xA4
098B4:  MOVLW  04
098B6:  ADDWFC 02,W
098B8:  MOVWF  xA5
098BA:  MOVFF  FE8,557
098BE:  MOVFF  6A4,556
098C2:  MOVLW  89
098C4:  MOVWF  FE9
098C6:  MOVFF  102,6AA
098CA:  MOVFF  101,6A9
098CE:  MOVFF  100,6A8
098D2:  MOVFF  FF,6A7
098D6:  MOVLW  03
098D8:  MOVWF  xAB
098DA:  MOVLB  0
098DC:  CALL   721E
098E0:  MOVLW  2C
098E2:  MOVLB  6
098E4:  MOVWF  xB4
098E6:  MOVLB  0
098E8:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
098EC:  MOVLW  04
098EE:  MOVLB  6
098F0:  MOVWF  xA6
098F2:  MOVLW  B2
098F4:  MOVWF  xA5
098F6:  MOVLB  0
098F8:  CALL   6446
098FC:  MOVFF  02,03
09900:  MOVF   01,W
09902:  ADDLW  B2
09904:  MOVLB  6
09906:  MOVWF  xA4
09908:  MOVLW  04
0990A:  ADDWFC 02,W
0990C:  MOVWF  xA5
0990E:  MOVFF  FE8,557
09912:  MOVFF  6A4,556
09916:  MOVLW  89
09918:  MOVWF  FE9
0991A:  MOVFF  106,6AA
0991E:  MOVFF  105,6A9
09922:  MOVFF  104,6A8
09926:  MOVFF  103,6A7
0992A:  MOVLW  03
0992C:  MOVWF  xAB
0992E:  MOVLB  0
09930:  CALL   721E
09934:  MOVLW  2C
09936:  MOVLB  6
09938:  MOVWF  xB4
0993A:  MOVLB  0
0993C:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
09940:  MOVLW  04
09942:  MOVLB  6
09944:  MOVWF  xA6
09946:  MOVLW  B2
09948:  MOVWF  xA5
0994A:  MOVLB  0
0994C:  CALL   6446
09950:  MOVFF  02,03
09954:  MOVF   01,W
09956:  ADDLW  B2
09958:  MOVLB  6
0995A:  MOVWF  xA4
0995C:  MOVLW  04
0995E:  ADDWFC 02,W
09960:  MOVWF  xA5
09962:  MOVFF  FE8,557
09966:  MOVFF  6A4,556
0996A:  MOVLW  89
0996C:  MOVWF  FE9
0996E:  MOVFF  10A,6AA
09972:  MOVFF  109,6A9
09976:  MOVFF  108,6A8
0997A:  MOVFF  107,6A7
0997E:  MOVLW  03
09980:  MOVWF  xAB
09982:  MOVLB  0
09984:  CALL   721E
09988:  MOVLW  2C
0998A:  MOVLB  6
0998C:  MOVWF  xB4
0998E:  MOVLB  0
09990:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
09994:  MOVLW  04
09996:  MOVLB  6
09998:  MOVWF  xA6
0999A:  MOVLW  B2
0999C:  MOVWF  xA5
0999E:  MOVLB  0
099A0:  CALL   6446
099A4:  MOVFF  02,03
099A8:  MOVF   01,W
099AA:  ADDLW  B2
099AC:  MOVLB  6
099AE:  MOVWF  xA4
099B0:  MOVLW  04
099B2:  ADDWFC 02,W
099B4:  MOVWF  xA5
099B6:  MOVFF  FE8,557
099BA:  MOVFF  6A4,556
099BE:  MOVLW  89
099C0:  MOVWF  FE9
099C2:  MOVFF  10E,6AA
099C6:  MOVFF  10D,6A9
099CA:  MOVFF  10C,6A8
099CE:  MOVFF  10B,6A7
099D2:  MOVLW  03
099D4:  MOVWF  xAB
099D6:  MOVLB  0
099D8:  CALL   721E
099DC:  MOVLW  2C
099DE:  MOVLB  6
099E0:  MOVWF  xB4
099E2:  MOVLB  0
099E4:  CALL   64F6
....................    }
099E8:  BRA    99F0
....................    else return INV_PARAM;
099EA:  MOVLW  02
099EC:  MOVWF  01
099EE:  BRA    99F4
....................    
....................    return SUCCESS;
099F0:  MOVLW  00
099F2:  MOVWF  01
099F4:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
099F6:  MOVLW  50
099F8:  MOVLB  6
099FA:  MOVWF  x74
099FC:  MOVLW  56
099FE:  MOVWF  x75
09A00:  CLRF   x76
09A02:  MOVLW  06
09A04:  MOVWF  x73
09A06:  MOVLW  74
09A08:  MOVWF  x72
....................    char *s_CV = "CV";
09A0A:  MOVLW  43
09A0C:  MOVWF  x79
09A0E:  MOVLW  56
09A10:  MOVWF  x7A
09A12:  CLRF   x7B
09A14:  MOVLW  06
09A16:  MOVWF  x78
09A18:  MOVLW  79
09A1A:  MOVWF  x77
....................    char *s_PVold = "PVold";
09A1C:  MOVLW  50
09A1E:  MOVWF  x7E
09A20:  MOVLW  56
09A22:  MOVWF  x7F
09A24:  MOVLW  6F
09A26:  MOVWF  x80
09A28:  MOVLW  6C
09A2A:  MOVWF  x81
09A2C:  MOVLW  64
09A2E:  MOVWF  x82
09A30:  CLRF   x83
09A32:  MOVLW  06
09A34:  MOVWF  x7D
09A36:  MOVLW  7E
09A38:  MOVWF  x7C
....................    char *s_I = "I";
09A3A:  MOVLW  49
09A3C:  MOVWF  x86
09A3E:  CLRF   x87
09A40:  MOVLW  06
09A42:  MOVWF  x85
09A44:  MOVLW  86
09A46:  MOVWF  x84
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09A48:  CLRF   xB1
09A4A:  MOVFF  663,6B0
09A4E:  CLRF   xB3
09A50:  MOVLW  B5
09A52:  MOVWF  xB2
09A54:  MOVLB  0
09A56:  CALL   0802
09A5A:  MOVFF  02,689
09A5E:  MOVFF  01,688
09A62:  MOVLW  06
09A64:  MOVLB  6
09A66:  ADDWF  x88,F
09A68:  MOVLW  00
09A6A:  ADDWFC x89,F
09A6C:  MOVLW  32
09A6E:  ADDWF  x88,W
09A70:  MOVWF  01
09A72:  MOVLW  00
09A74:  ADDWFC x89,W
09A76:  MOVWF  03
09A78:  MOVF   01,W
09A7A:  ADDLW  DC
09A7C:  MOVWF  01
09A7E:  MOVLW  01
09A80:  ADDWFC 03,F
09A82:  MOVFF  01,688
09A86:  MOVFF  03,689
09A8A:  MOVFF  03,698
09A8E:  MOVFF  01,697
09A92:  MOVLB  0
09A94:  CALL   65BE
09A98:  MOVF   01,F
09A9A:  BNZ   9AA4
09A9C:  MOVLW  02
09A9E:  MOVWF  01
09AA0:  BRA    9E3A
09AA2:  BRA    9B02
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09AA4:  MOVLB  6
09AA6:  CLRF   xB1
09AA8:  MOVFF  663,6B0
09AAC:  CLRF   xB3
09AAE:  MOVLW  B5
09AB0:  MOVWF  xB2
09AB2:  MOVLB  0
09AB4:  CALL   0802
09AB8:  MOVFF  02,689
09ABC:  MOVFF  01,688
09AC0:  MOVLW  06
09AC2:  MOVLB  6
09AC4:  ADDWF  x88,F
09AC6:  MOVLW  00
09AC8:  ADDWFC x89,F
09ACA:  MOVLW  32
09ACC:  ADDWF  x88,W
09ACE:  MOVWF  01
09AD0:  MOVLW  00
09AD2:  ADDWFC x89,W
09AD4:  MOVWF  03
09AD6:  MOVF   01,W
09AD8:  ADDLW  DC
09ADA:  MOVWF  01
09ADC:  MOVLW  01
09ADE:  ADDWFC 03,F
09AE0:  MOVFF  01,688
09AE4:  MOVFF  03,689
09AE8:  MOVFF  03,698
09AEC:  MOVFF  01,697
09AF0:  CLRF   x9A
09AF2:  CLRF   x99
09AF4:  MOVLW  0A
09AF6:  MOVWF  x9B
09AF8:  MOVLB  0
09AFA:  CALL   66AE
09AFE:  MOVFF  01,66F
....................    
....................    arg2 = SERcmd[rec].p[3];
09B02:  MOVLB  6
09B04:  CLRF   xB1
09B06:  MOVFF  663,6B0
09B0A:  CLRF   xB3
09B0C:  MOVLW  B5
09B0E:  MOVWF  xB2
09B10:  MOVLB  0
09B12:  CALL   0802
09B16:  MOVFF  02,689
09B1A:  MOVFF  01,688
09B1E:  MOVLW  06
09B20:  MOVLB  6
09B22:  ADDWF  x88,F
09B24:  MOVLW  00
09B26:  ADDWFC x89,F
09B28:  MOVLW  4B
09B2A:  ADDWF  x88,W
09B2C:  MOVWF  01
09B2E:  MOVLW  00
09B30:  ADDWFC x89,W
09B32:  MOVWF  03
09B34:  MOVF   01,W
09B36:  ADDLW  DC
09B38:  MOVWF  01
09B3A:  MOVLW  01
09B3C:  ADDWFC 03,F
09B3E:  MOVFF  01,670
09B42:  MOVFF  03,671
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09B46:  MOVFF  673,6A6
09B4A:  MOVFF  672,6A5
09B4E:  MOVFF  671,6A8
09B52:  MOVFF  670,6A7
09B56:  MOVLB  0
09B58:  CALL   647E
09B5C:  MOVF   01,F
09B5E:  BNZ   9C02
09B60:  MOVLW  04
09B62:  MOVLB  6
09B64:  MOVWF  xA6
09B66:  MOVLW  B2
09B68:  MOVWF  xA5
09B6A:  MOVLB  0
09B6C:  CALL   6446
09B70:  MOVF   01,W
09B72:  ADDLW  B2
09B74:  MOVLB  6
09B76:  MOVWF  x88
09B78:  MOVLW  04
09B7A:  ADDWFC 02,W
09B7C:  MOVWF  x89
09B7E:  MOVLW  01
09B80:  SUBWF  x6F,W
09B82:  MULLW  20
09B84:  MOVF   FF3,W
09B86:  CLRF   x8B
09B88:  MOVWF  x8A
09B8A:  MOVLW  10
09B8C:  ADDWF  x8A,W
09B8E:  MOVWF  01
09B90:  MOVLW  00
09B92:  ADDWFC x8B,W
09B94:  MOVWF  03
09B96:  MOVF   01,W
09B98:  ADDLW  20
09B9A:  MOVWF  FE9
09B9C:  MOVLW  00
09B9E:  ADDWFC 03,W
09BA0:  MOVWF  FEA
09BA2:  MOVFF  FEF,68A
09BA6:  MOVFF  FEC,68B
09BAA:  MOVFF  FEC,68C
09BAE:  MOVFF  FEC,68D
09BB2:  MOVFF  689,557
09BB6:  MOVFF  688,556
09BBA:  MOVFF  66F,698
09BBE:  MOVLW  18
09BC0:  MOVWF  x99
09BC2:  MOVLB  0
09BC4:  CALL   6A02
09BC8:  MOVLW  2C
09BCA:  MOVLB  6
09BCC:  MOVWF  xB4
09BCE:  MOVLB  0
09BD0:  CALL   64F6
09BD4:  MOVLW  89
09BD6:  MOVWF  FE9
09BD8:  MOVFF  68D,6AA
09BDC:  MOVFF  68C,6A9
09BE0:  MOVFF  68B,6A8
09BE4:  MOVFF  68A,6A7
09BE8:  MOVLW  02
09BEA:  MOVLB  6
09BEC:  MOVWF  xAB
09BEE:  MOVLB  0
09BF0:  CALL   721E
09BF4:  MOVLW  2C
09BF6:  MOVLB  6
09BF8:  MOVWF  xB4
09BFA:  MOVLB  0
09BFC:  CALL   64F6
09C00:  BRA    9E36
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
09C02:  MOVFF  678,6A6
09C06:  MOVFF  677,6A5
09C0A:  MOVFF  671,6A8
09C0E:  MOVFF  670,6A7
09C12:  CALL   647E
09C16:  MOVF   01,F
09C18:  BNZ   9CBC
09C1A:  MOVLW  04
09C1C:  MOVLB  6
09C1E:  MOVWF  xA6
09C20:  MOVLW  B2
09C22:  MOVWF  xA5
09C24:  MOVLB  0
09C26:  CALL   6446
09C2A:  MOVF   01,W
09C2C:  ADDLW  B2
09C2E:  MOVLB  6
09C30:  MOVWF  x88
09C32:  MOVLW  04
09C34:  ADDWFC 02,W
09C36:  MOVWF  x89
09C38:  MOVLW  01
09C3A:  SUBWF  x6F,W
09C3C:  MULLW  20
09C3E:  MOVF   FF3,W
09C40:  CLRF   x8B
09C42:  MOVWF  x8A
09C44:  MOVLW  18
09C46:  ADDWF  x8A,W
09C48:  MOVWF  01
09C4A:  MOVLW  00
09C4C:  ADDWFC x8B,W
09C4E:  MOVWF  03
09C50:  MOVF   01,W
09C52:  ADDLW  20
09C54:  MOVWF  FE9
09C56:  MOVLW  00
09C58:  ADDWFC 03,W
09C5A:  MOVWF  FEA
09C5C:  MOVFF  FEF,68A
09C60:  MOVFF  FEC,68B
09C64:  MOVFF  FEC,68C
09C68:  MOVFF  FEC,68D
09C6C:  MOVFF  689,557
09C70:  MOVFF  688,556
09C74:  MOVFF  66F,698
09C78:  MOVLW  18
09C7A:  MOVWF  x99
09C7C:  MOVLB  0
09C7E:  CALL   6A02
09C82:  MOVLW  2C
09C84:  MOVLB  6
09C86:  MOVWF  xB4
09C88:  MOVLB  0
09C8A:  CALL   64F6
09C8E:  MOVLW  89
09C90:  MOVWF  FE9
09C92:  MOVFF  68D,6AA
09C96:  MOVFF  68C,6A9
09C9A:  MOVFF  68B,6A8
09C9E:  MOVFF  68A,6A7
09CA2:  MOVLW  02
09CA4:  MOVLB  6
09CA6:  MOVWF  xAB
09CA8:  MOVLB  0
09CAA:  CALL   721E
09CAE:  MOVLW  2C
09CB0:  MOVLB  6
09CB2:  MOVWF  xB4
09CB4:  MOVLB  0
09CB6:  CALL   64F6
09CBA:  BRA    9E36
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09CBC:  MOVFF  67D,6A6
09CC0:  MOVFF  67C,6A5
09CC4:  MOVFF  671,6A8
09CC8:  MOVFF  670,6A7
09CCC:  CALL   647E
09CD0:  MOVF   01,F
09CD2:  BNZ   9D76
09CD4:  MOVLW  04
09CD6:  MOVLB  6
09CD8:  MOVWF  xA6
09CDA:  MOVLW  B2
09CDC:  MOVWF  xA5
09CDE:  MOVLB  0
09CE0:  CALL   6446
09CE4:  MOVF   01,W
09CE6:  ADDLW  B2
09CE8:  MOVLB  6
09CEA:  MOVWF  x88
09CEC:  MOVLW  04
09CEE:  ADDWFC 02,W
09CF0:  MOVWF  x89
09CF2:  MOVLW  01
09CF4:  SUBWF  x6F,W
09CF6:  MULLW  20
09CF8:  MOVF   FF3,W
09CFA:  CLRF   x8B
09CFC:  MOVWF  x8A
09CFE:  MOVLW  14
09D00:  ADDWF  x8A,W
09D02:  MOVWF  01
09D04:  MOVLW  00
09D06:  ADDWFC x8B,W
09D08:  MOVWF  03
09D0A:  MOVF   01,W
09D0C:  ADDLW  20
09D0E:  MOVWF  FE9
09D10:  MOVLW  00
09D12:  ADDWFC 03,W
09D14:  MOVWF  FEA
09D16:  MOVFF  FEF,68A
09D1A:  MOVFF  FEC,68B
09D1E:  MOVFF  FEC,68C
09D22:  MOVFF  FEC,68D
09D26:  MOVFF  689,557
09D2A:  MOVFF  688,556
09D2E:  MOVFF  66F,698
09D32:  MOVLW  18
09D34:  MOVWF  x99
09D36:  MOVLB  0
09D38:  CALL   6A02
09D3C:  MOVLW  2C
09D3E:  MOVLB  6
09D40:  MOVWF  xB4
09D42:  MOVLB  0
09D44:  CALL   64F6
09D48:  MOVLW  89
09D4A:  MOVWF  FE9
09D4C:  MOVFF  68D,6AA
09D50:  MOVFF  68C,6A9
09D54:  MOVFF  68B,6A8
09D58:  MOVFF  68A,6A7
09D5C:  MOVLW  02
09D5E:  MOVLB  6
09D60:  MOVWF  xAB
09D62:  MOVLB  0
09D64:  CALL   721E
09D68:  MOVLW  2C
09D6A:  MOVLB  6
09D6C:  MOVWF  xB4
09D6E:  MOVLB  0
09D70:  CALL   64F6
09D74:  BRA    9E36
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09D76:  MOVFF  685,6A6
09D7A:  MOVFF  684,6A5
09D7E:  MOVFF  671,6A8
09D82:  MOVFF  670,6A7
09D86:  CALL   647E
09D8A:  MOVF   01,F
09D8C:  BNZ   9E30
09D8E:  MOVLW  04
09D90:  MOVLB  6
09D92:  MOVWF  xA6
09D94:  MOVLW  B2
09D96:  MOVWF  xA5
09D98:  MOVLB  0
09D9A:  CALL   6446
09D9E:  MOVF   01,W
09DA0:  ADDLW  B2
09DA2:  MOVLB  6
09DA4:  MOVWF  x88
09DA6:  MOVLW  04
09DA8:  ADDWFC 02,W
09DAA:  MOVWF  x89
09DAC:  MOVLW  01
09DAE:  SUBWF  x6F,W
09DB0:  MULLW  20
09DB2:  MOVF   FF3,W
09DB4:  CLRF   x8B
09DB6:  MOVWF  x8A
09DB8:  MOVLW  1C
09DBA:  ADDWF  x8A,W
09DBC:  MOVWF  01
09DBE:  MOVLW  00
09DC0:  ADDWFC x8B,W
09DC2:  MOVWF  03
09DC4:  MOVF   01,W
09DC6:  ADDLW  20
09DC8:  MOVWF  FE9
09DCA:  MOVLW  00
09DCC:  ADDWFC 03,W
09DCE:  MOVWF  FEA
09DD0:  MOVFF  FEF,68A
09DD4:  MOVFF  FEC,68B
09DD8:  MOVFF  FEC,68C
09DDC:  MOVFF  FEC,68D
09DE0:  MOVFF  689,557
09DE4:  MOVFF  688,556
09DE8:  MOVFF  66F,698
09DEC:  MOVLW  18
09DEE:  MOVWF  x99
09DF0:  MOVLB  0
09DF2:  CALL   6A02
09DF6:  MOVLW  2C
09DF8:  MOVLB  6
09DFA:  MOVWF  xB4
09DFC:  MOVLB  0
09DFE:  CALL   64F6
09E02:  MOVLW  89
09E04:  MOVWF  FE9
09E06:  MOVFF  68D,6AA
09E0A:  MOVFF  68C,6A9
09E0E:  MOVFF  68B,6A8
09E12:  MOVFF  68A,6A7
09E16:  MOVLW  02
09E18:  MOVLB  6
09E1A:  MOVWF  xAB
09E1C:  MOVLB  0
09E1E:  CALL   721E
09E22:  MOVLW  2C
09E24:  MOVLB  6
09E26:  MOVWF  xB4
09E28:  MOVLB  0
09E2A:  CALL   64F6
09E2E:  BRA    9E36
....................    else return INV_PARAM;
09E30:  MOVLW  02
09E32:  MOVWF  01
09E34:  BRA    9E3A
....................    
....................    return SUCCESS;
09E36:  MOVLW  00
09E38:  MOVWF  01
09E3A:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09F5A:  MOVLW  72
09F5C:  MOVLB  6
09F5E:  MOVWF  x74
09F60:  MOVLW  61
09F62:  MOVWF  x75
09F64:  MOVLW  77
09F66:  MOVWF  x76
09F68:  CLRF   x77
09F6A:  MOVLW  06
09F6C:  MOVWF  x73
09F6E:  MOVLW  74
09F70:  MOVWF  x72
....................    char *s_calibrated = "calib";
09F72:  MOVLW  63
09F74:  MOVWF  x7A
09F76:  MOVLW  61
09F78:  MOVWF  x7B
09F7A:  MOVLW  6C
09F7C:  MOVWF  x7C
09F7E:  MOVLW  69
09F80:  MOVWF  x7D
09F82:  MOVLW  62
09F84:  MOVWF  x7E
09F86:  CLRF   x7F
09F88:  MOVLW  06
09F8A:  MOVWF  x79
09F8C:  MOVLW  7A
09F8E:  MOVWF  x78
....................    char *s_p0 = "p0";
09F90:  MOVLW  70
09F92:  MOVWF  x82
09F94:  MOVLW  30
09F96:  MOVWF  x83
09F98:  CLRF   x84
09F9A:  MOVLW  06
09F9C:  MOVWF  x81
09F9E:  MOVLW  82
09FA0:  MOVWF  x80
....................    char *s_poles = "poles";
09FA2:  MOVLW  70
09FA4:  MOVWF  x87
09FA6:  MOVLW  6F
09FA8:  MOVWF  x88
09FAA:  MOVLW  6C
09FAC:  MOVWF  x89
09FAE:  MOVLW  65
09FB0:  MOVWF  x8A
09FB2:  MOVLW  73
09FB4:  MOVWF  x8B
09FB6:  CLRF   x8C
09FB8:  MOVLW  06
09FBA:  MOVWF  x86
09FBC:  MOVLW  87
09FBE:  MOVWF  x85
....................    char *s_real = "real";
09FC0:  MOVLW  72
09FC2:  MOVWF  x8F
09FC4:  MOVLW  65
09FC6:  MOVWF  x90
09FC8:  MOVLW  61
09FCA:  MOVWF  x91
09FCC:  MOVLW  6C
09FCE:  MOVWF  x92
09FD0:  CLRF   x93
09FD2:  MOVLW  06
09FD4:  MOVWF  x8E
09FD6:  MOVLW  8F
09FD8:  MOVWF  x8D
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09FDA:  CLRF   xB1
09FDC:  MOVFF  663,6B0
09FE0:  CLRF   xB3
09FE2:  MOVLW  B5
09FE4:  MOVWF  xB2
09FE6:  MOVLB  0
09FE8:  CALL   0802
09FEC:  MOVFF  02,695
09FF0:  MOVFF  01,694
09FF4:  MOVLW  06
09FF6:  MOVLB  6
09FF8:  ADDWF  x94,F
09FFA:  MOVLW  00
09FFC:  ADDWFC x95,F
09FFE:  MOVLW  32
0A000:  ADDWF  x94,W
0A002:  MOVWF  01
0A004:  MOVLW  00
0A006:  ADDWFC x95,W
0A008:  MOVWF  03
0A00A:  MOVF   01,W
0A00C:  ADDLW  DC
0A00E:  MOVWF  01
0A010:  MOVLW  01
0A012:  ADDWFC 03,F
0A014:  MOVFF  01,694
0A018:  MOVFF  03,695
0A01C:  MOVFF  03,698
0A020:  MOVFF  01,697
0A024:  MOVLB  0
0A026:  CALL   65BE
0A02A:  MOVF   01,F
0A02C:  BNZ   A036
0A02E:  MOVLW  02
0A030:  MOVWF  01
0A032:  BRA    A67A
0A034:  BRA    A094
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A036:  MOVLB  6
0A038:  CLRF   xB1
0A03A:  MOVFF  663,6B0
0A03E:  CLRF   xB3
0A040:  MOVLW  B5
0A042:  MOVWF  xB2
0A044:  MOVLB  0
0A046:  CALL   0802
0A04A:  MOVFF  02,695
0A04E:  MOVFF  01,694
0A052:  MOVLW  06
0A054:  MOVLB  6
0A056:  ADDWF  x94,F
0A058:  MOVLW  00
0A05A:  ADDWFC x95,F
0A05C:  MOVLW  32
0A05E:  ADDWF  x94,W
0A060:  MOVWF  01
0A062:  MOVLW  00
0A064:  ADDWFC x95,W
0A066:  MOVWF  03
0A068:  MOVF   01,W
0A06A:  ADDLW  DC
0A06C:  MOVWF  01
0A06E:  MOVLW  01
0A070:  ADDWFC 03,F
0A072:  MOVFF  01,694
0A076:  MOVFF  03,695
0A07A:  MOVFF  03,698
0A07E:  MOVFF  01,697
0A082:  CLRF   x9A
0A084:  CLRF   x99
0A086:  MOVLW  0A
0A088:  MOVWF  x9B
0A08A:  MOVLB  0
0A08C:  CALL   66AE
0A090:  MOVFF  01,66F
....................    
....................    arg2 = SERcmd[rec].p[3];
0A094:  MOVLB  6
0A096:  CLRF   xB1
0A098:  MOVFF  663,6B0
0A09C:  CLRF   xB3
0A09E:  MOVLW  B5
0A0A0:  MOVWF  xB2
0A0A2:  MOVLB  0
0A0A4:  CALL   0802
0A0A8:  MOVFF  02,695
0A0AC:  MOVFF  01,694
0A0B0:  MOVLW  06
0A0B2:  MOVLB  6
0A0B4:  ADDWF  x94,F
0A0B6:  MOVLW  00
0A0B8:  ADDWFC x95,F
0A0BA:  MOVLW  4B
0A0BC:  ADDWF  x94,W
0A0BE:  MOVWF  01
0A0C0:  MOVLW  00
0A0C2:  ADDWFC x95,W
0A0C4:  MOVWF  03
0A0C6:  MOVF   01,W
0A0C8:  ADDLW  DC
0A0CA:  MOVWF  01
0A0CC:  MOVLW  01
0A0CE:  ADDWFC 03,F
0A0D0:  MOVFF  01,670
0A0D4:  MOVFF  03,671
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0A0D8:  MOVFF  673,6A6
0A0DC:  MOVFF  672,6A5
0A0E0:  MOVFF  671,6A8
0A0E4:  MOVFF  670,6A7
0A0E8:  MOVLB  0
0A0EA:  CALL   647E
0A0EE:  MOVF   01,F
0A0F0:  BTFSS  FD8.2
0A0F2:  BRA    A26E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A0F4:  MOVLW  04
0A0F6:  MOVLB  6
0A0F8:  MOVWF  xA6
0A0FA:  MOVLW  B2
0A0FC:  MOVWF  xA5
0A0FE:  MOVLB  0
0A100:  CALL   6446
0A104:  MOVFF  02,03
0A108:  MOVF   01,W
0A10A:  ADDLW  B2
0A10C:  MOVLB  6
0A10E:  MOVWF  x94
0A110:  MOVLW  04
0A112:  ADDWFC 02,W
0A114:  MOVWF  x95
0A116:  MOVFF  FE8,557
0A11A:  MOVFF  694,556
0A11E:  MOVFF  66F,698
0A122:  MOVLW  18
0A124:  MOVWF  x99
0A126:  MOVLB  0
0A128:  CALL   6A02
0A12C:  MOVLW  2C
0A12E:  MOVLB  6
0A130:  MOVWF  xB4
0A132:  MOVLB  0
0A134:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0A138:  MOVLW  04
0A13A:  MOVLB  6
0A13C:  MOVWF  xA6
0A13E:  MOVLW  B2
0A140:  MOVWF  xA5
0A142:  MOVLB  0
0A144:  CALL   6446
0A148:  MOVFF  02,03
0A14C:  MOVF   01,W
0A14E:  ADDLW  B2
0A150:  MOVLB  6
0A152:  MOVWF  x94
0A154:  MOVLW  04
0A156:  ADDWFC 02,W
0A158:  MOVWF  x95
0A15A:  MOVLW  01
0A15C:  SUBWF  x6F,W
0A15E:  MULLW  21
0A160:  MOVF   FF3,W
0A162:  CLRF   x97
0A164:  MOVWF  x96
0A166:  MOVLW  0F
0A168:  ADDWF  x96,W
0A16A:  MOVWF  FE9
0A16C:  MOVLW  01
0A16E:  ADDWFC x97,W
0A170:  MOVWF  FEA
0A172:  MOVFF  FEF,6B4
0A176:  MOVFF  FEC,01
0A17A:  MOVFF  FEC,02
0A17E:  MOVFF  FEC,03
0A182:  MOVFF  03,6B7
0A186:  MOVFF  02,6B6
0A18A:  MOVFF  01,6B5
0A18E:  MOVLB  0
0A190:  CALL   6064
0A194:  MOVFF  03,69B
0A198:  MOVFF  02,69A
0A19C:  MOVFF  01,699
0A1A0:  MOVFF  00,698
0A1A4:  MOVFF  695,557
0A1A8:  MOVFF  694,556
0A1AC:  MOVLW  41
0A1AE:  MOVWF  FE9
0A1B0:  MOVFF  03,6A0
0A1B4:  MOVFF  02,69F
0A1B8:  MOVFF  01,69E
0A1BC:  MOVFF  00,69D
0A1C0:  RCALL  9E3C
0A1C2:  MOVLW  2C
0A1C4:  MOVLB  6
0A1C6:  MOVWF  xB4
0A1C8:  MOVLB  0
0A1CA:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0A1CE:  MOVLW  04
0A1D0:  MOVLB  6
0A1D2:  MOVWF  xA6
0A1D4:  MOVLW  B2
0A1D6:  MOVWF  xA5
0A1D8:  MOVLB  0
0A1DA:  CALL   6446
0A1DE:  MOVF   01,W
0A1E0:  ADDLW  B2
0A1E2:  MOVLB  6
0A1E4:  MOVWF  x94
0A1E6:  MOVLW  04
0A1E8:  ADDWFC 02,W
0A1EA:  MOVWF  x95
0A1EC:  MOVLW  01
0A1EE:  SUBWF  x6F,W
0A1F0:  MULLW  21
0A1F2:  MOVF   FF3,W
0A1F4:  CLRF   x97
0A1F6:  MOVWF  x96
0A1F8:  MOVLW  04
0A1FA:  ADDWF  x96,W
0A1FC:  MOVWF  01
0A1FE:  MOVLW  00
0A200:  ADDWFC x97,W
0A202:  MOVWF  03
0A204:  MOVF   01,W
0A206:  ADDLW  0F
0A208:  MOVWF  FE9
0A20A:  MOVLW  01
0A20C:  ADDWFC 03,W
0A20E:  MOVWF  FEA
0A210:  MOVFF  FEF,6B4
0A214:  MOVFF  FEC,01
0A218:  MOVFF  FEC,02
0A21C:  MOVFF  FEC,03
0A220:  MOVFF  03,6B7
0A224:  MOVFF  02,6B6
0A228:  MOVFF  01,6B5
0A22C:  MOVLB  0
0A22E:  CALL   6064
0A232:  MOVFF  03,699
0A236:  MOVFF  02,698
0A23A:  MOVFF  01,697
0A23E:  MOVFF  00,696
0A242:  MOVFF  695,557
0A246:  MOVFF  694,556
0A24A:  MOVLW  41
0A24C:  MOVWF  FE9
0A24E:  MOVFF  03,6A0
0A252:  MOVFF  02,69F
0A256:  MOVFF  01,69E
0A25A:  MOVFF  00,69D
0A25E:  RCALL  9E3C
0A260:  MOVLW  2C
0A262:  MOVLB  6
0A264:  MOVWF  xB4
0A266:  MOVLB  0
0A268:  CALL   64F6
....................    }
0A26C:  BRA    A676
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0A26E:  MOVFF  679,6A6
0A272:  MOVFF  678,6A5
0A276:  MOVFF  671,6A8
0A27A:  MOVFF  670,6A7
0A27E:  CALL   647E
0A282:  MOVF   01,F
0A284:  BTFSS  FD8.2
0A286:  BRA    A40A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A288:  MOVLW  04
0A28A:  MOVLB  6
0A28C:  MOVWF  xA6
0A28E:  MOVLW  B2
0A290:  MOVWF  xA5
0A292:  MOVLB  0
0A294:  CALL   6446
0A298:  MOVFF  02,03
0A29C:  MOVF   01,W
0A29E:  ADDLW  B2
0A2A0:  MOVLB  6
0A2A2:  MOVWF  x94
0A2A4:  MOVLW  04
0A2A6:  ADDWFC 02,W
0A2A8:  MOVWF  x95
0A2AA:  MOVFF  FE8,557
0A2AE:  MOVFF  694,556
0A2B2:  MOVFF  66F,698
0A2B6:  MOVLW  18
0A2B8:  MOVWF  x99
0A2BA:  MOVLB  0
0A2BC:  CALL   6A02
0A2C0:  MOVLW  2C
0A2C2:  MOVLB  6
0A2C4:  MOVWF  xB4
0A2C6:  MOVLB  0
0A2C8:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0A2CC:  MOVLW  04
0A2CE:  MOVLB  6
0A2D0:  MOVWF  xA6
0A2D2:  MOVLW  B2
0A2D4:  MOVWF  xA5
0A2D6:  MOVLB  0
0A2D8:  CALL   6446
0A2DC:  MOVF   01,W
0A2DE:  ADDLW  B2
0A2E0:  MOVLB  6
0A2E2:  MOVWF  x94
0A2E4:  MOVLW  04
0A2E6:  ADDWFC 02,W
0A2E8:  MOVWF  x95
0A2EA:  MOVLW  01
0A2EC:  SUBWF  x6F,W
0A2EE:  MULLW  21
0A2F0:  MOVF   FF3,W
0A2F2:  CLRF   x97
0A2F4:  MOVWF  x96
0A2F6:  MOVLW  08
0A2F8:  ADDWF  x96,W
0A2FA:  MOVWF  01
0A2FC:  MOVLW  00
0A2FE:  ADDWFC x97,W
0A300:  MOVWF  03
0A302:  MOVF   01,W
0A304:  ADDLW  0F
0A306:  MOVWF  FE9
0A308:  MOVLW  01
0A30A:  ADDWFC 03,W
0A30C:  MOVWF  FEA
0A30E:  MOVFF  FEF,6B4
0A312:  MOVFF  FEC,01
0A316:  MOVFF  FEC,02
0A31A:  MOVFF  FEC,03
0A31E:  MOVFF  03,6B7
0A322:  MOVFF  02,6B6
0A326:  MOVFF  01,6B5
0A32A:  MOVLB  0
0A32C:  CALL   6064
0A330:  MOVFF  03,699
0A334:  MOVFF  02,698
0A338:  MOVFF  01,697
0A33C:  MOVFF  00,696
0A340:  MOVFF  695,557
0A344:  MOVFF  694,556
0A348:  MOVLW  41
0A34A:  MOVWF  FE9
0A34C:  MOVFF  03,6A0
0A350:  MOVFF  02,69F
0A354:  MOVFF  01,69E
0A358:  MOVFF  00,69D
0A35C:  RCALL  9E3C
0A35E:  MOVLW  2C
0A360:  MOVLB  6
0A362:  MOVWF  xB4
0A364:  MOVLB  0
0A366:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
0A36A:  MOVLW  04
0A36C:  MOVLB  6
0A36E:  MOVWF  xA6
0A370:  MOVLW  B2
0A372:  MOVWF  xA5
0A374:  MOVLB  0
0A376:  CALL   6446
0A37A:  MOVF   01,W
0A37C:  ADDLW  B2
0A37E:  MOVLB  6
0A380:  MOVWF  x94
0A382:  MOVLW  04
0A384:  ADDWFC 02,W
0A386:  MOVWF  x95
0A388:  MOVLW  01
0A38A:  SUBWF  x6F,W
0A38C:  MULLW  21
0A38E:  MOVF   FF3,W
0A390:  CLRF   x97
0A392:  MOVWF  x96
0A394:  MOVLW  0C
0A396:  ADDWF  x96,W
0A398:  MOVWF  01
0A39A:  MOVLW  00
0A39C:  ADDWFC x97,W
0A39E:  MOVWF  03
0A3A0:  MOVF   01,W
0A3A2:  ADDLW  0F
0A3A4:  MOVWF  FE9
0A3A6:  MOVLW  01
0A3A8:  ADDWFC 03,W
0A3AA:  MOVWF  FEA
0A3AC:  MOVFF  FEF,6B4
0A3B0:  MOVFF  FEC,01
0A3B4:  MOVFF  FEC,02
0A3B8:  MOVFF  FEC,03
0A3BC:  MOVFF  03,6B7
0A3C0:  MOVFF  02,6B6
0A3C4:  MOVFF  01,6B5
0A3C8:  MOVLB  0
0A3CA:  CALL   6064
0A3CE:  MOVFF  03,699
0A3D2:  MOVFF  02,698
0A3D6:  MOVFF  01,697
0A3DA:  MOVFF  00,696
0A3DE:  MOVFF  695,557
0A3E2:  MOVFF  694,556
0A3E6:  MOVLW  41
0A3E8:  MOVWF  FE9
0A3EA:  MOVFF  03,6A0
0A3EE:  MOVFF  02,69F
0A3F2:  MOVFF  01,69E
0A3F6:  MOVFF  00,69D
0A3FA:  RCALL  9E3C
0A3FC:  MOVLW  2C
0A3FE:  MOVLB  6
0A400:  MOVWF  xB4
0A402:  MOVLB  0
0A404:  CALL   64F6
....................    }
0A408:  BRA    A676
....................    else if (0 == strcmp(s_p0, arg2)) {
0A40A:  MOVFF  681,6A6
0A40E:  MOVFF  680,6A5
0A412:  MOVFF  671,6A8
0A416:  MOVFF  670,6A7
0A41A:  CALL   647E
0A41E:  MOVF   01,F
0A420:  BNZ   A4DC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A422:  MOVLW  04
0A424:  MOVLB  6
0A426:  MOVWF  xA6
0A428:  MOVLW  B2
0A42A:  MOVWF  xA5
0A42C:  MOVLB  0
0A42E:  CALL   6446
0A432:  MOVFF  02,03
0A436:  MOVF   01,W
0A438:  ADDLW  B2
0A43A:  MOVLB  6
0A43C:  MOVWF  x94
0A43E:  MOVLW  04
0A440:  ADDWFC 02,W
0A442:  MOVWF  x95
0A444:  MOVFF  FE8,557
0A448:  MOVFF  694,556
0A44C:  MOVFF  66F,698
0A450:  MOVLW  18
0A452:  MOVWF  x99
0A454:  MOVLB  0
0A456:  CALL   6A02
0A45A:  MOVLW  2C
0A45C:  MOVLB  6
0A45E:  MOVWF  xB4
0A460:  MOVLB  0
0A462:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
0A466:  MOVLW  04
0A468:  MOVLB  6
0A46A:  MOVWF  xA6
0A46C:  MOVLW  B2
0A46E:  MOVWF  xA5
0A470:  MOVLB  0
0A472:  CALL   6446
0A476:  MOVF   01,W
0A478:  ADDLW  B2
0A47A:  MOVLB  6
0A47C:  MOVWF  x94
0A47E:  MOVLW  04
0A480:  ADDWFC 02,W
0A482:  MOVWF  x95
0A484:  MOVLW  01
0A486:  SUBWF  x6F,W
0A488:  MULLW  21
0A48A:  MOVF   FF3,W
0A48C:  CLRF   x97
0A48E:  MOVWF  x96
0A490:  MOVLW  18
0A492:  ADDWF  x96,W
0A494:  MOVWF  01
0A496:  MOVLW  00
0A498:  ADDWFC x97,W
0A49A:  MOVWF  03
0A49C:  MOVF   01,W
0A49E:  ADDLW  0F
0A4A0:  MOVWF  FE9
0A4A2:  MOVLW  01
0A4A4:  ADDWFC 03,W
0A4A6:  MOVWF  FEA
0A4A8:  MOVFF  FEF,6A7
0A4AC:  MOVFF  FEC,6A8
0A4B0:  MOVFF  FEC,6A9
0A4B4:  MOVFF  FEC,6AA
0A4B8:  MOVFF  695,557
0A4BC:  MOVFF  694,556
0A4C0:  MOVLW  89
0A4C2:  MOVWF  FE9
0A4C4:  MOVLW  02
0A4C6:  MOVWF  xAB
0A4C8:  MOVLB  0
0A4CA:  CALL   721E
0A4CE:  MOVLW  2C
0A4D0:  MOVLB  6
0A4D2:  MOVWF  xB4
0A4D4:  MOVLB  0
0A4D6:  CALL   64F6
....................    }
0A4DA:  BRA    A676
....................    else if (0 == strcmp(s_poles, arg2)) {
0A4DC:  MOVFF  686,6A6
0A4E0:  MOVFF  685,6A5
0A4E4:  MOVFF  671,6A8
0A4E8:  MOVFF  670,6A7
0A4EC:  CALL   647E
0A4F0:  MOVF   01,F
0A4F2:  BNZ   A59E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A4F4:  MOVLW  04
0A4F6:  MOVLB  6
0A4F8:  MOVWF  xA6
0A4FA:  MOVLW  B2
0A4FC:  MOVWF  xA5
0A4FE:  MOVLB  0
0A500:  CALL   6446
0A504:  MOVFF  02,03
0A508:  MOVF   01,W
0A50A:  ADDLW  B2
0A50C:  MOVLB  6
0A50E:  MOVWF  x94
0A510:  MOVLW  04
0A512:  ADDWFC 02,W
0A514:  MOVWF  x95
0A516:  MOVFF  FE8,557
0A51A:  MOVFF  694,556
0A51E:  MOVFF  66F,698
0A522:  MOVLW  18
0A524:  MOVWF  x99
0A526:  MOVLB  0
0A528:  CALL   6A02
0A52C:  MOVLW  2C
0A52E:  MOVLB  6
0A530:  MOVWF  xB4
0A532:  MOVLB  0
0A534:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
0A538:  MOVLW  04
0A53A:  MOVLB  6
0A53C:  MOVWF  xA6
0A53E:  MOVLW  B2
0A540:  MOVWF  xA5
0A542:  MOVLB  0
0A544:  CALL   6446
0A548:  MOVF   01,W
0A54A:  ADDLW  B2
0A54C:  MOVLB  6
0A54E:  MOVWF  x94
0A550:  MOVLW  04
0A552:  ADDWFC 02,W
0A554:  MOVWF  x95
0A556:  MOVLW  01
0A558:  SUBWF  x6F,W
0A55A:  MULLW  21
0A55C:  MOVF   FF3,W
0A55E:  CLRF   x97
0A560:  MOVWF  x96
0A562:  MOVLW  1C
0A564:  ADDWF  x96,W
0A566:  MOVWF  01
0A568:  MOVLW  00
0A56A:  ADDWFC x97,W
0A56C:  MOVWF  03
0A56E:  MOVF   01,W
0A570:  ADDLW  0F
0A572:  MOVWF  FE9
0A574:  MOVLW  01
0A576:  ADDWFC 03,W
0A578:  MOVWF  FEA
0A57A:  MOVFF  FEF,698
0A57E:  MOVFF  695,557
0A582:  MOVFF  694,556
0A586:  MOVLW  18
0A588:  MOVWF  x99
0A58A:  MOVLB  0
0A58C:  CALL   6A02
0A590:  MOVLW  2C
0A592:  MOVLB  6
0A594:  MOVWF  xB4
0A596:  MOVLB  0
0A598:  CALL   64F6
....................    }
0A59C:  BRA    A676
....................    else if (0 == strcmp(s_real, arg2)) {
0A59E:  MOVFF  68E,6A6
0A5A2:  MOVFF  68D,6A5
0A5A6:  MOVFF  671,6A8
0A5AA:  MOVFF  670,6A7
0A5AE:  CALL   647E
0A5B2:  MOVF   01,F
0A5B4:  BNZ   A670
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0A5B6:  MOVLW  04
0A5B8:  MOVLB  6
0A5BA:  MOVWF  xA6
0A5BC:  MOVLW  B2
0A5BE:  MOVWF  xA5
0A5C0:  MOVLB  0
0A5C2:  CALL   6446
0A5C6:  MOVFF  02,03
0A5CA:  MOVF   01,W
0A5CC:  ADDLW  B2
0A5CE:  MOVLB  6
0A5D0:  MOVWF  x94
0A5D2:  MOVLW  04
0A5D4:  ADDWFC 02,W
0A5D6:  MOVWF  x95
0A5D8:  MOVFF  FE8,557
0A5DC:  MOVFF  694,556
0A5E0:  MOVFF  66F,698
0A5E4:  MOVLW  18
0A5E6:  MOVWF  x99
0A5E8:  MOVLB  0
0A5EA:  CALL   6A02
0A5EE:  MOVLW  2C
0A5F0:  MOVLB  6
0A5F2:  MOVWF  xB4
0A5F4:  MOVLB  0
0A5F6:  CALL   64F6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
0A5FA:  MOVLW  04
0A5FC:  MOVLB  6
0A5FE:  MOVWF  xA6
0A600:  MOVLW  B2
0A602:  MOVWF  xA5
0A604:  MOVLB  0
0A606:  CALL   6446
0A60A:  MOVF   01,W
0A60C:  ADDLW  B2
0A60E:  MOVLB  6
0A610:  MOVWF  x94
0A612:  MOVLW  04
0A614:  ADDWFC 02,W
0A616:  MOVWF  x95
0A618:  MOVLW  01
0A61A:  SUBWF  x6F,W
0A61C:  MULLW  21
0A61E:  MOVF   FF3,W
0A620:  CLRF   x97
0A622:  MOVWF  x96
0A624:  MOVLW  1D
0A626:  ADDWF  x96,W
0A628:  MOVWF  01
0A62A:  MOVLW  00
0A62C:  ADDWFC x97,W
0A62E:  MOVWF  03
0A630:  MOVF   01,W
0A632:  ADDLW  0F
0A634:  MOVWF  FE9
0A636:  MOVLW  01
0A638:  ADDWFC 03,W
0A63A:  MOVWF  FEA
0A63C:  MOVFF  FEF,6A7
0A640:  MOVFF  FEC,6A8
0A644:  MOVFF  FEC,6A9
0A648:  MOVFF  FEC,6AA
0A64C:  MOVFF  695,557
0A650:  MOVFF  694,556
0A654:  MOVLW  89
0A656:  MOVWF  FE9
0A658:  MOVLW  02
0A65A:  MOVWF  xAB
0A65C:  MOVLB  0
0A65E:  CALL   721E
0A662:  MOVLW  2C
0A664:  MOVLB  6
0A666:  MOVWF  xB4
0A668:  MOVLB  0
0A66A:  CALL   64F6
....................    }
0A66E:  BRA    A676
....................    else return INV_PARAM;
0A670:  MOVLW  02
0A672:  MOVWF  01
0A674:  BRA    A67A
....................    
....................    return SUCCESS;
0A676:  MOVLW  00
0A678:  MOVWF  01
0A67A:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A67C:  MOVLB  6
0A67E:  CLRF   xB1
0A680:  MOVFF  663,6B0
0A684:  CLRF   xB3
0A686:  MOVLW  B5
0A688:  MOVWF  xB2
0A68A:  MOVLB  0
0A68C:  CALL   0802
0A690:  MOVFF  02,671
0A694:  MOVFF  01,670
0A698:  MOVLW  06
0A69A:  MOVLB  6
0A69C:  ADDWF  x70,F
0A69E:  MOVLW  00
0A6A0:  ADDWFC x71,F
0A6A2:  MOVLW  32
0A6A4:  ADDWF  x70,W
0A6A6:  MOVWF  01
0A6A8:  MOVLW  00
0A6AA:  ADDWFC x71,W
0A6AC:  MOVWF  03
0A6AE:  MOVF   01,W
0A6B0:  ADDLW  DC
0A6B2:  MOVWF  01
0A6B4:  MOVLW  01
0A6B6:  ADDWFC 03,F
0A6B8:  MOVFF  01,670
0A6BC:  MOVFF  03,671
0A6C0:  MOVFF  03,698
0A6C4:  MOVFF  01,697
0A6C8:  MOVLB  0
0A6CA:  CALL   65BE
0A6CE:  MOVF   01,F
0A6D0:  BNZ   A6DA
0A6D2:  MOVLW  02
0A6D4:  MOVWF  01
0A6D6:  BRA    A7CC
0A6D8:  BRA    A738
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A6DA:  MOVLB  6
0A6DC:  CLRF   xB1
0A6DE:  MOVFF  663,6B0
0A6E2:  CLRF   xB3
0A6E4:  MOVLW  B5
0A6E6:  MOVWF  xB2
0A6E8:  MOVLB  0
0A6EA:  CALL   0802
0A6EE:  MOVFF  02,671
0A6F2:  MOVFF  01,670
0A6F6:  MOVLW  06
0A6F8:  MOVLB  6
0A6FA:  ADDWF  x70,F
0A6FC:  MOVLW  00
0A6FE:  ADDWFC x71,F
0A700:  MOVLW  32
0A702:  ADDWF  x70,W
0A704:  MOVWF  01
0A706:  MOVLW  00
0A708:  ADDWFC x71,W
0A70A:  MOVWF  03
0A70C:  MOVF   01,W
0A70E:  ADDLW  DC
0A710:  MOVWF  01
0A712:  MOVLW  01
0A714:  ADDWFC 03,F
0A716:  MOVFF  01,670
0A71A:  MOVFF  03,671
0A71E:  MOVFF  03,698
0A722:  MOVFF  01,697
0A726:  CLRF   x9A
0A728:  CLRF   x99
0A72A:  MOVLW  0A
0A72C:  MOVWF  x9B
0A72E:  MOVLB  0
0A730:  CALL   66AE
0A734:  MOVFF  01,66F
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
0A738:  MOVLW  04
0A73A:  MOVLB  6
0A73C:  MOVWF  xA6
0A73E:  MOVLW  B2
0A740:  MOVWF  xA5
0A742:  MOVLB  0
0A744:  CALL   6446
0A748:  MOVF   01,W
0A74A:  ADDLW  B2
0A74C:  MOVLB  6
0A74E:  MOVWF  x70
0A750:  MOVLW  04
0A752:  ADDWFC 02,W
0A754:  MOVWF  x71
0A756:  MOVLW  01
0A758:  SUBWF  x6F,W
0A75A:  MULLW  04
0A75C:  MOVF   FF3,W
0A75E:  CLRF   03
0A760:  ADDLW  EA
0A762:  MOVWF  FE9
0A764:  MOVLW  00
0A766:  ADDWFC 03,W
0A768:  MOVWF  FEA
0A76A:  MOVFF  FEF,672
0A76E:  MOVFF  FEC,673
0A772:  MOVFF  FEC,674
0A776:  MOVFF  FEC,675
0A77A:  MOVFF  671,557
0A77E:  MOVFF  670,556
0A782:  MOVFF  66F,698
0A786:  MOVLW  18
0A788:  MOVWF  x99
0A78A:  MOVLB  0
0A78C:  CALL   6A02
0A790:  MOVLW  2C
0A792:  MOVLB  6
0A794:  MOVWF  xB4
0A796:  MOVLB  0
0A798:  CALL   64F6
0A79C:  MOVLW  89
0A79E:  MOVWF  FE9
0A7A0:  MOVFF  675,6AA
0A7A4:  MOVFF  674,6A9
0A7A8:  MOVFF  673,6A8
0A7AC:  MOVFF  672,6A7
0A7B0:  MOVLW  02
0A7B2:  MOVLB  6
0A7B4:  MOVWF  xAB
0A7B6:  MOVLB  0
0A7B8:  CALL   721E
0A7BC:  MOVLW  2C
0A7BE:  MOVLB  6
0A7C0:  MOVWF  xB4
0A7C2:  MOVLB  0
0A7C4:  CALL   64F6
....................    
....................    return SUCCESS;
0A7C8:  MOVLW  00
0A7CA:  MOVWF  01
0A7CC:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0A7CE:  MOVLB  6
0A7D0:  CLRF   xB1
0A7D2:  MOVFF  663,6B0
0A7D6:  CLRF   xB3
0A7D8:  MOVLW  B5
0A7DA:  MOVWF  xB2
0A7DC:  MOVLB  0
0A7DE:  CALL   0802
0A7E2:  MOVFF  02,675
0A7E6:  MOVFF  01,674
0A7EA:  MOVLW  06
0A7EC:  MOVLB  6
0A7EE:  ADDWF  x74,F
0A7F0:  MOVLW  00
0A7F2:  ADDWFC x75,F
0A7F4:  MOVLW  32
0A7F6:  ADDWF  x74,W
0A7F8:  MOVWF  01
0A7FA:  MOVLW  00
0A7FC:  ADDWFC x75,W
0A7FE:  MOVWF  03
0A800:  MOVF   01,W
0A802:  ADDLW  DC
0A804:  MOVWF  01
0A806:  MOVLW  01
0A808:  ADDWFC 03,F
0A80A:  MOVFF  01,674
0A80E:  MOVFF  03,675
0A812:  MOVFF  03,698
0A816:  MOVFF  01,697
0A81A:  MOVLB  0
0A81C:  CALL   65BE
0A820:  MOVF   01,F
0A822:  BNZ   A82C
0A824:  MOVLW  02
0A826:  MOVWF  01
0A828:  BRA    AA0E
0A82A:  BRA    A88A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0A82C:  MOVLB  6
0A82E:  CLRF   xB1
0A830:  MOVFF  663,6B0
0A834:  CLRF   xB3
0A836:  MOVLW  B5
0A838:  MOVWF  xB2
0A83A:  MOVLB  0
0A83C:  CALL   0802
0A840:  MOVFF  02,675
0A844:  MOVFF  01,674
0A848:  MOVLW  06
0A84A:  MOVLB  6
0A84C:  ADDWF  x74,F
0A84E:  MOVLW  00
0A850:  ADDWFC x75,F
0A852:  MOVLW  32
0A854:  ADDWF  x74,W
0A856:  MOVWF  01
0A858:  MOVLW  00
0A85A:  ADDWFC x75,W
0A85C:  MOVWF  03
0A85E:  MOVF   01,W
0A860:  ADDLW  DC
0A862:  MOVWF  01
0A864:  MOVLW  01
0A866:  ADDWFC 03,F
0A868:  MOVFF  01,674
0A86C:  MOVFF  03,675
0A870:  MOVFF  03,698
0A874:  MOVFF  01,697
0A878:  CLRF   x9A
0A87A:  CLRF   x99
0A87C:  MOVLW  0A
0A87E:  MOVWF  x9B
0A880:  MOVLB  0
0A882:  CALL   66AE
0A886:  MOVFF  01,66F
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0A88A:  MOVLB  6
0A88C:  CLRF   xB1
0A88E:  MOVFF  663,6B0
0A892:  CLRF   xB3
0A894:  MOVLW  B5
0A896:  MOVWF  xB2
0A898:  MOVLB  0
0A89A:  CALL   0802
0A89E:  MOVFF  02,675
0A8A2:  MOVFF  01,674
0A8A6:  MOVLW  06
0A8A8:  MOVLB  6
0A8AA:  ADDWF  x74,F
0A8AC:  MOVLW  00
0A8AE:  ADDWFC x75,F
0A8B0:  MOVLW  4B
0A8B2:  ADDWF  x74,W
0A8B4:  MOVWF  01
0A8B6:  MOVLW  00
0A8B8:  ADDWFC x75,W
0A8BA:  MOVWF  03
0A8BC:  MOVF   01,W
0A8BE:  ADDLW  DC
0A8C0:  MOVWF  01
0A8C2:  MOVLW  01
0A8C4:  ADDWFC 03,F
0A8C6:  MOVFF  01,674
0A8CA:  MOVFF  03,675
0A8CE:  MOVFF  03,679
0A8D2:  MOVFF  01,678
0A8D6:  MOVLB  0
0A8D8:  CALL   788A
0A8DC:  MOVF   01,F
0A8DE:  BNZ   A8E8
0A8E0:  MOVLW  02
0A8E2:  MOVWF  01
0A8E4:  BRA    AA0E
0A8E6:  BRA    A94E
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0A8E8:  MOVLB  6
0A8EA:  CLRF   xB1
0A8EC:  MOVFF  663,6B0
0A8F0:  CLRF   xB3
0A8F2:  MOVLW  B5
0A8F4:  MOVWF  xB2
0A8F6:  MOVLB  0
0A8F8:  CALL   0802
0A8FC:  MOVFF  02,675
0A900:  MOVFF  01,674
0A904:  MOVLW  06
0A906:  MOVLB  6
0A908:  ADDWF  x74,F
0A90A:  MOVLW  00
0A90C:  ADDWFC x75,F
0A90E:  MOVLW  4B
0A910:  ADDWF  x74,W
0A912:  MOVWF  01
0A914:  MOVLW  00
0A916:  ADDWFC x75,W
0A918:  MOVWF  03
0A91A:  MOVF   01,W
0A91C:  ADDLW  DC
0A91E:  MOVWF  01
0A920:  MOVLW  01
0A922:  ADDWFC 03,F
0A924:  MOVFF  01,674
0A928:  MOVFF  03,675
0A92C:  MOVFF  03,679
0A930:  MOVFF  01,678
0A934:  CLRF   x7B
0A936:  CLRF   x7A
0A938:  MOVLB  0
0A93A:  CALL   794C
0A93E:  MOVFF  03,673
0A942:  MOVFF  02,672
0A946:  MOVFF  01,671
0A94A:  MOVFF  00,670
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
0A94E:  MOVLB  6
0A950:  CLRF   xB2
0A952:  CLRF   xB1
0A954:  MOVLW  7C
0A956:  MOVWF  xB0
0A958:  MOVLW  84
0A95A:  MOVWF  xAF
0A95C:  MOVFF  673,6B6
0A960:  MOVFF  672,6B5
0A964:  MOVFF  671,6B4
0A968:  MOVFF  670,6B3
0A96C:  MOVLB  0
0A96E:  CALL   27D6
0A972:  BNC   A998
0A974:  MOVLW  01
0A976:  MOVLB  6
0A978:  SUBWF  x6F,W
0A97A:  MULLW  04
0A97C:  MOVF   FF3,W
0A97E:  CLRF   03
0A980:  ADDLW  EA
0A982:  MOVWF  FE9
0A984:  MOVLW  00
0A986:  ADDWFC 03,W
0A988:  MOVWF  FEA
0A98A:  MOVLW  84
0A98C:  MOVWF  FEF
0A98E:  MOVLW  7C
0A990:  MOVWF  FEC
0A992:  CLRF   FEC
0A994:  CLRF   FEC
0A996:  BRA    AA08
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
0A998:  MOVFF  673,6B2
0A99C:  MOVFF  672,6B1
0A9A0:  MOVFF  671,6B0
0A9A4:  MOVFF  670,6AF
0A9A8:  MOVLB  6
0A9AA:  CLRF   xB6
0A9AC:  CLRF   xB5
0A9AE:  MOVLW  FC
0A9B0:  MOVWF  xB4
0A9B2:  MOVLW  84
0A9B4:  MOVWF  xB3
0A9B6:  MOVLB  0
0A9B8:  CALL   27D6
0A9BC:  BNC   A9E2
0A9BE:  MOVLW  01
0A9C0:  MOVLB  6
0A9C2:  SUBWF  x6F,W
0A9C4:  MULLW  04
0A9C6:  MOVF   FF3,W
0A9C8:  CLRF   03
0A9CA:  ADDLW  EA
0A9CC:  MOVWF  FE9
0A9CE:  MOVLW  00
0A9D0:  ADDWFC 03,W
0A9D2:  MOVWF  FEA
0A9D4:  MOVLW  84
0A9D6:  MOVWF  FEF
0A9D8:  MOVLW  FC
0A9DA:  MOVWF  FEC
0A9DC:  CLRF   FEC
0A9DE:  CLRF   FEC
0A9E0:  BRA    AA08
....................    else manualOutputValues[arg1-1] = arg2;
0A9E2:  MOVLW  01
0A9E4:  MOVLB  6
0A9E6:  SUBWF  x6F,W
0A9E8:  MULLW  04
0A9EA:  MOVF   FF3,W
0A9EC:  CLRF   03
0A9EE:  ADDLW  EA
0A9F0:  MOVWF  FE9
0A9F2:  MOVLW  00
0A9F4:  ADDWFC 03,W
0A9F6:  MOVWF  FEA
0A9F8:  MOVFF  670,FEF
0A9FC:  MOVFF  671,FEC
0AA00:  MOVFF  672,FEC
0AA04:  MOVFF  673,FEC
....................    
....................    return SUCCESS;
0AA08:  MOVLW  00
0AA0A:  MOVWF  01
0AA0C:  MOVLB  0
0AA0E:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0AA10:  MOVLW  01
0AA12:  MOVWF  01
0AA14:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
0788A:  MOVLB  6
0788C:  BCF    x7A.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
0788E:  CLRF   x7B
07890:  MOVFF  679,6A6
07894:  MOVFF  678,6A5
07898:  MOVLB  0
0789A:  CALL   6446
0789E:  MOVFF  02,03
078A2:  MOVF   01,W
078A4:  MOVF   03,F
078A6:  BNZ   78B2
078A8:  MOVF   01,W
078AA:  MOVLB  6
078AC:  SUBWF  x7B,W
078AE:  BC    7944
078B0:  MOVLB  0
....................       if (!isdigit(arg[i])){
078B2:  MOVLB  6
078B4:  MOVF   x7B,W
078B6:  ADDWF  x78,W
078B8:  MOVWF  FE9
078BA:  MOVLW  00
078BC:  ADDWFC x79,W
078BE:  MOVWF  FEA
078C0:  MOVFF  FEF,67C
078C4:  MOVF   x7C,W
078C6:  SUBLW  2F
078C8:  BC    78D0
078CA:  MOVF   x7C,W
078CC:  SUBLW  39
078CE:  BC    793C
....................          // Check for negative sign
....................          if ('-' != arg[i]){
078D0:  MOVF   x7B,W
078D2:  ADDWF  x78,W
078D4:  MOVWF  FE9
078D6:  MOVLW  00
078D8:  ADDWFC x79,W
078DA:  MOVWF  FEA
078DC:  MOVF   FEF,W
078DE:  SUBLW  2D
078E0:  BZ    790C
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
078E2:  MOVF   x7B,W
078E4:  ADDWF  x78,W
078E6:  MOVWF  FE9
078E8:  MOVLW  00
078EA:  ADDWFC x79,W
078EC:  MOVWF  FEA
078EE:  MOVF   FEF,W
078F0:  SUBLW  2E
078F2:  BZ    78FC
078F4:  MOVLW  00
078F6:  MOVWF  01
078F8:  BRA    7948
078FA:  BRA    790A
....................             else if  (decimal) return FALSE;
078FC:  BTFSS  x7A.0
078FE:  BRA    7908
07900:  MOVLW  00
07902:  MOVWF  01
07904:  BRA    7948
07906:  BRA    790A
....................             else decimal = TRUE;
07908:  BSF    x7A.0
....................          }
0790A:  BRA    793C
....................          else if (0 != i) return FALSE;
0790C:  MOVF   x7B,F
0790E:  BZ    7918
07910:  MOVLW  00
07912:  MOVWF  01
07914:  BRA    7948
07916:  BRA    793C
....................          else if (1 == strlen(arg)) return FALSE;
07918:  MOVFF  679,6A6
0791C:  MOVFF  678,6A5
07920:  MOVLB  0
07922:  CALL   6446
07926:  MOVFF  02,03
0792A:  MOVF   01,W
0792C:  SUBLW  01
0792E:  BNZ   793E
07930:  MOVF   03,F
07932:  BNZ   793E
07934:  MOVLW  00
07936:  MOVWF  01
07938:  MOVLB  6
0793A:  BRA    7948
0793C:  MOVLB  0
....................       }
0793E:  MOVLB  6
07940:  INCF   x7B,F
07942:  BRA    7890
....................    }
....................    return TRUE;
07944:  MOVLW  01
07946:  MOVWF  01
07948:  MOVLB  0
0794A:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
065BE:  MOVFF  698,6A6
065C2:  MOVFF  697,6A5
065C6:  RCALL  6446
065C8:  MOVFF  02,03
065CC:  MOVF   01,W
065CE:  SUBLW  01
065D0:  BNZ   65D6
065D2:  MOVF   03,F
065D4:  BZ    65DE
065D6:  MOVLW  00
065D8:  MOVWF  01
065DA:  BRA    660C
065DC:  BRA    6604
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
065DE:  MOVLB  6
065E0:  MOVFF  697,FE9
065E4:  MOVFF  698,FEA
065E8:  MOVF   FEF,W
065EA:  SUBLW  31
065EC:  BZ    6606
065EE:  MOVFF  697,FE9
065F2:  MOVFF  698,FEA
065F6:  MOVF   FEF,W
065F8:  SUBLW  32
065FA:  BZ    6606
065FC:  MOVLW  00
065FE:  MOVWF  01
06600:  MOVLB  0
06602:  BRA    660C
06604:  MOVLB  6
....................     return TRUE;
06606:  MOVLW  01
06608:  MOVWF  01
0660A:  MOVLB  0
0660C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
0640C:  MOVLB  6
0640E:  MOVF   x6E,W
06410:  SUBLW  2F
06412:  BC    6424
06414:  MOVF   x6E,W
06416:  SUBLW  39
06418:  BNC   6424
0641A:  MOVLW  30
0641C:  SUBWF  x6E,W
0641E:  MOVWF  01
06420:  BRA    6440
06422:  BRA    6440
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
06424:  MOVF   x6E,W
06426:  SUBLW  40
06428:  BC    643C
0642A:  MOVF   x6E,W
0642C:  SUBLW  46
0642E:  BNC   643C
06430:  MOVLW  41
06432:  SUBWF  x6E,W
06434:  ADDLW  0A
06436:  MOVWF  01
06438:  BRA    6440
0643A:  BRA    6440
....................    else return 0xFF;
0643C:  MOVLW  FF
0643E:  MOVWF  01
06440:  MOVLB  0
06442:  GOTO   AABA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0AA16:  MOVLB  6
0AA18:  CLRF   xB1
0AA1A:  MOVFF  665,6B0
0AA1E:  CLRF   xB3
0AA20:  MOVLW  B5
0AA22:  MOVWF  xB2
0AA24:  MOVLB  0
0AA26:  CALL   0802
0AA2A:  MOVFF  02,66E
0AA2E:  MOVFF  01,66D
0AA32:  MOVLW  06
0AA34:  MOVLB  6
0AA36:  ADDWF  x6D,F
0AA38:  MOVLW  00
0AA3A:  ADDWFC x6E,F
0AA3C:  MOVLW  DC
0AA3E:  ADDWF  x6D,W
0AA40:  MOVWF  01
0AA42:  MOVLW  01
0AA44:  ADDWFC x6E,W
0AA46:  MOVWF  03
0AA48:  MOVFF  01,666
0AA4C:  MOVWF  x67
0AA4E:  CLRF   xB1
0AA50:  MOVFF  665,6B0
0AA54:  CLRF   xB3
0AA56:  MOVLW  B5
0AA58:  MOVWF  xB2
0AA5A:  MOVLB  0
0AA5C:  CALL   0802
0AA60:  MOVFF  02,670
0AA64:  MOVFF  01,66F
0AA68:  MOVLW  06
0AA6A:  MOVLB  6
0AA6C:  ADDWF  x6F,F
0AA6E:  MOVLW  00
0AA70:  ADDWFC x70,F
0AA72:  MOVLW  19
0AA74:  ADDWF  x6F,W
0AA76:  MOVWF  01
0AA78:  MOVLW  00
0AA7A:  ADDWFC x70,W
0AA7C:  MOVWF  03
0AA7E:  MOVF   01,W
0AA80:  ADDLW  DC
0AA82:  MOVWF  01
0AA84:  MOVLW  01
0AA86:  ADDWFC 03,F
0AA88:  MOVFF  01,668
0AA8C:  MOVFF  03,669
0AA90:  CLRF   x6A
0AA92:  CLRF   x6B
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0AA94:  MOVFF  666,FE9
0AA98:  MOVFF  667,FEA
0AA9C:  MOVF   FEF,W
0AA9E:  SUBLW  44
0AAA0:  BTFSS  FD8.2
0AAA2:  BRA    AB92
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0AAA4:  MOVLW  01
0AAA6:  ADDWF  x66,W
0AAA8:  MOVWF  FE9
0AAAA:  MOVLW  00
0AAAC:  ADDWFC x67,W
0AAAE:  MOVWF  FEA
0AAB0:  MOVFF  FEF,66E
0AAB4:  MOVLB  0
0AAB6:  GOTO   640C
0AABA:  MOVFF  01,66D
0AABE:  MOVLB  6
0AAC0:  MOVF   x6A,W
0AAC2:  ANDLW  0F
0AAC4:  SUBWF  01,W
0AAC6:  BNZ   AB8A
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0AAC8:  MOVF   x6B,W
0AACA:  MULLW  04
0AACC:  MOVF   FF3,W
0AACE:  CLRF   x6E
0AAD0:  MOVWF  x6D
0AAD2:  MOVLW  5C
0AAD4:  ADDWF  x6D,W
0AAD6:  MOVWF  FE9
0AAD8:  MOVLW  05
0AADA:  ADDWFC x6E,W
0AADC:  MOVWF  FEA
0AADE:  MOVFF  FEC,6A6
0AAE2:  MOVF   FED,F
0AAE4:  MOVFF  FEF,6A5
0AAE8:  MOVLB  0
0AAEA:  CALL   6446
0AAEE:  MOVFF  02,03
0AAF2:  MOVF   01,W
0AAF4:  BNZ   AAFA
0AAF6:  MOVF   03,F
0AAF8:  BZ    AB80
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0AAFA:  MOVLB  6
0AAFC:  MOVF   x6B,W
0AAFE:  MULLW  04
0AB00:  MOVF   FF3,W
0AB02:  CLRF   x6E
0AB04:  MOVWF  x6D
0AB06:  MOVLW  5C
0AB08:  ADDWF  x6D,W
0AB0A:  MOVWF  FE9
0AB0C:  MOVLW  05
0AB0E:  ADDWFC x6E,W
0AB10:  MOVWF  FEA
0AB12:  MOVFF  FEC,6A8
0AB16:  MOVF   FED,F
0AB18:  MOVFF  FEF,6A7
0AB1C:  MOVFF  669,6A6
0AB20:  MOVFF  668,6A5
0AB24:  MOVLB  0
0AB26:  CALL   647E
0AB2A:  MOVF   01,F
0AB2C:  BNZ   AB78
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0AB2E:  MOVLB  6
0AB30:  MOVF   x6B,W
0AB32:  MULLW  04
0AB34:  MOVF   FF3,W
0AB36:  CLRF   x6E
0AB38:  MOVWF  x6D
0AB3A:  MOVLW  02
0AB3C:  ADDWF  x6D,W
0AB3E:  MOVWF  01
0AB40:  MOVLW  00
0AB42:  ADDWFC x6E,W
0AB44:  MOVWF  03
0AB46:  MOVF   01,W
0AB48:  ADDLW  5C
0AB4A:  MOVWF  01
0AB4C:  MOVLW  05
0AB4E:  ADDWFC 03,F
0AB50:  MOVFF  01,66D
0AB54:  MOVFF  03,66E
0AB58:  MOVFF  03,FEA
0AB5C:  MOVFF  01,FE9
0AB60:  MOVFF  665,663
0AB64:  MOVLB  0
0AB66:  CALL   00BC
0AB6A:  MOVFF  01,66C
....................                return return_code;
0AB6E:  MOVLB  6
0AB70:  MOVFF  66C,01
0AB74:  BRA    AB96
0AB76:  MOVLB  0
....................             }
....................             i++;
0AB78:  MOVLB  6
0AB7A:  INCF   x6B,F
0AB7C:  BRA    AAC8
0AB7E:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0AB80:  MOVLW  01
0AB82:  MOVWF  01
0AB84:  MOVLB  6
0AB86:  BRA    AB96
....................       } else return 254; // NOT THIS ADDRESS
0AB88:  BRA    AB90
0AB8A:  MOVLW  FE
0AB8C:  MOVWF  01
0AB8E:  BRA    AB96
....................    } else return 255; // NOT THIS DEVICE TYPE
0AB90:  BRA    AB96
0AB92:  MOVLW  FF
0AB94:  MOVWF  01
0AB96:  MOVLB  0
0AB98:  GOTO   ABD2 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0ABC4:  GOTO   63B2
0ABC8:  MOVF   01,F
0ABCA:  BZ    ACBA
....................    {
....................       int8 return_code = command_parser(SRI);
0ABCC:  MOVFF  4B0,665
0ABD0:  BRA    AA16
0ABD2:  MOVFF  01,664
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0ABD6:  MOVLW  04
0ABD8:  MOVLB  6
0ABDA:  MOVWF  xA6
0ABDC:  MOVLW  B2
0ABDE:  MOVWF  xA5
0ABE0:  MOVLB  0
0ABE2:  CALL   6446
0ABE6:  MOVF   01,W
0ABE8:  ADDLW  B2
0ABEA:  MOVLB  6
0ABEC:  MOVWF  x65
0ABEE:  MOVLW  04
0ABF0:  ADDWFC 02,W
0ABF2:  MOVWF  x66
0ABF4:  MOVF   x64,W
0ABF6:  MULLW  03
0ABF8:  MOVF   FF3,W
0ABFA:  CLRF   x68
0ABFC:  MOVWF  x67
0ABFE:  MOVLW  01
0AC00:  ADDWF  x67,W
0AC02:  MOVWF  01
0AC04:  MOVLW  00
0AC06:  ADDWFC x68,W
0AC08:  MOVWF  03
0AC0A:  MOVF   01,W
0AC0C:  ADDLW  2B
0AC0E:  MOVWF  FE9
0AC10:  MOVLW  06
0AC12:  ADDWFC 03,W
0AC14:  MOVWF  FEA
0AC16:  MOVFF  FEC,668
0AC1A:  MOVF   FED,F
0AC1C:  MOVFF  FEF,667
0AC20:  MOVFF  666,557
0AC24:  MOVFF  665,556
0AC28:  MOVFF  557,FEA
0AC2C:  MOVFF  556,FE9
0AC30:  CLRF   FEF
0AC32:  MOVFF  668,FEA
0AC36:  MOVFF  667,FE9
0AC3A:  MOVLB  0
0AC3C:  BRA    AB9C
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
0AC3E:  MOVLB  6
0AC40:  CLRF   xB1
0AC42:  MOVFF  4B0,6B0
0AC46:  CLRF   xB3
0AC48:  MOVLW  B5
0AC4A:  MOVWF  xB2
0AC4C:  MOVLB  0
0AC4E:  CALL   0802
0AC52:  MOVFF  02,666
0AC56:  MOVFF  01,665
0AC5A:  MOVLW  06
0AC5C:  MOVLB  6
0AC5E:  ADDWF  x65,F
0AC60:  MOVLW  00
0AC62:  ADDWFC x66,F
0AC64:  MOVLW  DC
0AC66:  ADDWF  x65,W
0AC68:  MOVWF  01
0AC6A:  MOVLW  01
0AC6C:  ADDWFC x66,W
0AC6E:  MOVWF  03
0AC70:  MOVFF  01,667
0AC74:  MOVWF  x68
0AC76:  MOVLW  24
0AC78:  MOVWF  x7A
0AC7A:  MOVLB  0
0AC7C:  CALL   5A50
0AC80:  MOVFF  668,FEA
0AC84:  MOVFF  667,FE9
0AC88:  CALL   5A78
0AC8C:  MOVLW  2C
0AC8E:  MOVLB  6
0AC90:  MOVWF  x7A
0AC92:  MOVLB  0
0AC94:  CALL   5A50
0AC98:  MOVLW  04
0AC9A:  MOVWF  FEA
0AC9C:  MOVLW  B2
0AC9E:  MOVWF  FE9
0ACA0:  CALL   5A78
0ACA4:  MOVLW  0A
0ACA6:  MOVLB  6
0ACA8:  MOVWF  x7A
0ACAA:  MOVLB  0
0ACAC:  CALL   5A50
....................       
....................       resetSERcmd(SRI);
0ACB0:  MOVFF  4B0,665
0ACB4:  CALL   10EE
0ACB8:  BRA    ABC4
....................    }
0ACBA:  GOTO   B33A (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0ACBE:  CLRF   FF8
0ACC0:  BCF    FF2.5
0ACC2:  BSF    07.7
0ACC4:  MOVLB  E
0ACC6:  MOVLW  55
0ACC8:  MOVWF  x9B
0ACCA:  MOVLW  AA
0ACCC:  MOVWF  x9B
0ACCE:  BCF    x9B.0
0ACD0:  MOVLW  17
0ACD2:  MOVWF  xB0
0ACD4:  MOVLW  13
0ACD6:  MOVWF  xB2
0ACD8:  MOVLW  09
0ACDA:  MOVWF  x8A
0ACDC:  MOVLW  0A
0ACDE:  MOVWF  x8B
0ACE0:  MOVLW  11
0ACE2:  MOVWF  xEB
0ACE4:  MOVLW  12
0ACE6:  MOVWF  xED
0ACE8:  MOVLW  10
0ACEA:  MOVWF  xF4
0ACEC:  MOVLW  0F
0ACEE:  MOVWF  xF5
0ACF0:  MOVLW  09
0ACF2:  MOVWF  xF8
0ACF4:  MOVLW  55
0ACF6:  MOVWF  x9B
0ACF8:  MOVLW  AA
0ACFA:  MOVWF  x9B
0ACFC:  BSF    x9B.0
0ACFE:  CLRF   xD8
0AD00:  CLRF   xD5
0AD02:  CLRF   xD7
0AD04:  MOVLW  08
0AD06:  MOVWF  xD9
0AD08:  MOVLW  60
0AD0A:  MOVWF  xD3
0AD0C:  MOVLW  AA
0AD0E:  MOVLB  0
0AD10:  MOVWF  xF2
0AD12:  MOVLB  1
0AD14:  CLRF   x5A
0AD16:  CLRF   x59
0AD18:  CLRF   x58
0AD1A:  CLRF   x57
0AD1C:  CLRF   x5E
0AD1E:  CLRF   x5D
0AD20:  CLRF   x5C
0AD22:  CLRF   x5B
0AD24:  CLRF   x62
0AD26:  CLRF   x61
0AD28:  CLRF   x60
0AD2A:  CLRF   x5F
0AD2C:  CLRF   x64
0AD2E:  CLRF   x63
0AD30:  MOVLB  E
0AD32:  BCF    x91.5
0AD34:  MOVLW  00
0AD36:  MOVWF  x90
0AD38:  MOVLW  0F
0AD3A:  MOVWF  x8E
0AD3C:  MOVLW  2A
0AD3E:  MOVWF  x91
0AD40:  MOVLW  C4
0AD42:  MOVWF  F88
0AD44:  MOVWF  F88
0AD46:  MOVWF  F88
0AD48:  BCF    F95.5
0AD4A:  MOVLW  40
0AD4C:  MOVWF  F94
0AD4E:  MOVLW  9F
0AD50:  MOVWF  F92
0AD52:  MOVLW  3A
0AD54:  MOVWF  F95
0AD56:  MOVLW  93
0AD58:  MOVWF  F89
0AD5A:  MOVWF  F89
0AD5C:  MOVLB  4
0AD5E:  CLRF   xB0
0AD60:  CLRF   xB1
0AD62:  MOVLB  5
0AD64:  CLRF   x52
0AD66:  CLRF   x53
0AD68:  BCF    x54.0
0AD6A:  CLRF   x55
0AD6C:  BSF    F9E.3
0AD6E:  MOVLW  7C
0AD70:  MOVWF  F9A
0AD72:  MOVLW  00
0AD74:  MOVWF  F9B
0AD76:  MOVLW  A6
0AD78:  MOVWF  F9D
0AD7A:  MOVLW  90
0AD7C:  MOVWF  F9C
0AD7E:  MOVLW  93
0AD80:  MOVWF  F89
0AD82:  BCF    F84.5
0AD84:  CLRF   x57
0AD86:  CLRF   x56
0AD88:  CLRF   x5B
0AD8A:  CLRF   x5A
0AD8C:  CLRF   x59
0AD8E:  CLRF   x58
0AD90:  MOVLB  F
0AD92:  CLRF   x0C
0AD94:  CLRF   x14
0AD96:  CLRF   x1C
0AD98:  CLRF   x21
0AD9A:  CLRF   x29
0AD9C:  CLRF   x35
0AD9E:  CLRF   x36
0ADA0:  CLRF   x37
0ADA2:  CLRF   x34
0ADA4:  CLRF   x31
0ADA6:  CLRF   x32
0ADA8:  CLRF   x33
0ADAA:  CLRF   x30
0ADAC:  MOVLW  65
0ADAE:  MOVLB  5
0ADB0:  MOVWF  x5F
0ADB2:  MOVLW  36
0ADB4:  MOVWF  x5E
0ADB6:  MOVLW  65
0ADB8:  MOVWF  x63
0ADBA:  MOVLW  7A
0ADBC:  MOVWF  x62
0ADBE:  MOVLW  6A
0ADC0:  MOVWF  x67
0ADC2:  MOVLW  C2
0ADC4:  MOVWF  x66
0ADC6:  MOVLW  6C
0ADC8:  MOVWF  x6B
0ADCA:  MOVLW  A0
0ADCC:  MOVWF  x6A
0ADCE:  MOVLW  6E
0ADD0:  MOVWF  x6F
0ADD2:  MOVLW  78
0ADD4:  MOVWF  x6E
0ADD6:  MOVLW  70
0ADD8:  MOVWF  x73
0ADDA:  MOVLW  04
0ADDC:  MOVWF  x72
0ADDE:  MOVLW  73
0ADE0:  MOVWF  x77
0ADE2:  MOVLW  D4
0ADE4:  MOVWF  x76
0ADE6:  MOVLW  7B
0ADE8:  MOVWF  x7B
0ADEA:  MOVLW  A6
0ADEC:  MOVWF  x7A
0ADEE:  MOVLW  7E
0ADF0:  MOVWF  x7F
0ADF2:  MOVLW  86
0ADF4:  MOVWF  x7E
0ADF6:  MOVLW  7F
0ADF8:  MOVWF  x83
0ADFA:  MOVLW  E8
0ADFC:  MOVWF  x82
0ADFE:  MOVLW  81
0AE00:  MOVWF  x87
0AE02:  MOVLW  A6
0AE04:  MOVWF  x86
0AE06:  MOVLW  85
0AE08:  MOVWF  x8B
0AE0A:  MOVLW  5C
0AE0C:  MOVWF  x8A
0AE0E:  MOVLW  8A
0AE10:  MOVWF  x8F
0AE12:  MOVLW  B8
0AE14:  MOVWF  x8E
0AE16:  MOVLW  8E
0AE18:  MOVWF  x93
0AE1A:  MOVLW  50
0AE1C:  MOVWF  x92
0AE1E:  MOVLW  93
0AE20:  MOVWF  x97
0AE22:  MOVLW  7C
0AE24:  MOVWF  x96
0AE26:  MOVLW  93
0AE28:  MOVWF  x9B
0AE2A:  MOVLW  82
0AE2C:  MOVWF  x9A
0AE2E:  MOVLW  99
0AE30:  MOVWF  x9F
0AE32:  MOVLW  F6
0AE34:  MOVWF  x9E
0AE36:  MOVLW  9F
0AE38:  MOVWF  xA3
0AE3A:  MOVLW  5A
0AE3C:  MOVWF  xA2
0AE3E:  MOVLW  A6
0AE40:  MOVWF  xA7
0AE42:  MOVLW  7C
0AE44:  MOVWF  xA6
0AE46:  MOVLW  A7
0AE48:  MOVWF  xAB
0AE4A:  MOVLW  CE
0AE4C:  MOVWF  xAA
0AE4E:  MOVLW  AA
0AE50:  MOVWF  xAF
0AE52:  MOVLW  10
0AE54:  MOVWF  xAE
0AE56:  BRA    B01E
0AE58:  DATA 02,00
0AE5A:  DATA 1A,00
0AE5C:  DATA 00,0C
0AE5E:  DATA 00,20
0AE60:  DATA 78,23
0AE62:  DATA D7,0A
0AE64:  DATA 7D,19
0AE66:  DATA 99,9A
0AE68:  DATA 7B,4C
0AE6A:  DATA CC,CD
0AE6C:  DATA 14,C0
0AE6E:  DATA 00,0C
0AE70:  DATA 80,78
0AE72:  DATA 23,D7
0AE74:  DATA 0A,7D
0AE76:  DATA 19,99
0AE78:  DATA 9A,7B
0AE7A:  DATA 4C,CC
0AE7C:  DATA CD,14
0AE7E:  DATA C0,00
0AE80:  DATA 01,80
0AE82:  DATA 02,09
0AE84:  DATA C0,00
0AE86:  DATA 05,80
0AE88:  DATA 7F,00
0AE8A:  DATA 00,00
0AE8C:  DATA 7F,0B
0AE8E:  DATA C0,00
0AE90:  DATA 05,80
0AE92:  DATA 7F,00
0AE94:  DATA 00,00
0AE96:  DATA 7F,07
0AE98:  DATA C0,00
0AE9A:  DATA 01,80
0AE9C:  DATA 7F,17
0AE9E:  DATA C0,00
0AEA0:  DATA 01,80
0AEA2:  DATA 7F,17
0AEA4:  DATA C0,00
0AEA6:  DATA 04,80
0AEA8:  DATA 79,B7
0AEAA:  DATA F3,BD
0AEAC:  DATA 04,C0
0AEAE:  DATA 00,04
0AEB0:  DATA 80,7C
0AEB2:  DATA 59,DF
0AEB4:  DATA 4E,04
0AEB6:  DATA C0,00
0AEB8:  DATA 04,80
0AEBA:  DATA 78,0A
0AEBC:  DATA 28,88
0AEBE:  DATA 04,C0
0AEC0:  DATA 00,04
0AEC2:  DATA 80,78
0AEC4:  DATA 05,EA
0AEC6:  DATA 16,04
0AEC8:  DATA C0,00
0AECA:  DATA 04,80
0AECC:  DATA 78,1E
0AECE:  DATA 33,D7
0AED0:  DATA 04,C0
0AED2:  DATA 00,04
0AED4:  DATA 80,77
0AED6:  DATA 68,7B
0AED8:  DATA BB,04
0AEDA:  DATA C0,00
0AEDC:  DATA 04,80
0AEDE:  DATA 77,68
0AEE0:  DATA 0D,C6
0AEE2:  DATA 08,C0
0AEE4:  DATA 00,64
0AEE6:  DATA 40,F3
0AEE8:  DATA 00,05
0AEEA:  DATA 01,BD
0AEEC:  DATA 00,65
0AEEE:  DATA 01,7B
0AEF0:  DATA 01,09
0AEF2:  DATA C0,00
0AEF4:  DATA 04,80
0AEF6:  DATA 91,01
0AEF8:  DATA A7,01
0AEFA:  DATA 0D,C0
0AEFC:  DATA 00,3C
0AEFE:  DATA 45,16
0AF00:  DATA 00,02
0AF02:  DATA 05,5C
0AF04:  DATA B0,05
0AF06:  DATA 02,05
0AF08:  DATA 60,B3
0AF0A:  DATA 05,02
0AF0C:  DATA 05,64
0AF0E:  DATA B6,05
0AF10:  DATA 02,05
0AF12:  DATA 68,BD
0AF14:  DATA 05,02
0AF16:  DATA 05,6C
0AF18:  DATA C4,05
0AF1A:  DATA 02,05
0AF1C:  DATA 70,CC
0AF1E:  DATA 05,02
0AF20:  DATA 05,74
0AF22:  DATA D4,05
0AF24:  DATA 02,05
0AF26:  DATA 78,D9
0AF28:  DATA 05,02
0AF2A:  DATA 05,7C
0AF2C:  DATA DE,05
0AF2E:  DATA 02,05
0AF30:  DATA 80,E2
0AF32:  DATA 05,02
0AF34:  DATA 05,84
0AF36:  DATA E6,05
0AF38:  DATA 02,05
0AF3A:  DATA 88,ED
0AF3C:  DATA 05,02
0AF3E:  DATA 05,8C
0AF40:  DATA F3,05
0AF42:  DATA 02,05
0AF44:  DATA 90,F9
0AF46:  DATA 05,02
0AF48:  DATA 05,94
0AF4A:  DATA FF,05
0AF4C:  DATA 02,05
0AF4E:  DATA 98,05
0AF50:  DATA 06,02
0AF52:  DATA 05,9C
0AF54:  DATA 0A,06
0AF56:  DATA 02,05
0AF58:  DATA A0,13
0AF5A:  DATA 06,02
0AF5C:  DATA 05,A4
0AF5E:  DATA 1B,06
0AF60:  DATA 02,05
0AF62:  DATA A8,22
0AF64:  DATA 06,02
0AF66:  DATA 05,AC
0AF68:  DATA 29,06
0AF6A:  DATA 78,05
0AF6C:  DATA B0,67
0AF6E:  DATA 72,00
0AF70:  DATA 67,73
0AF72:  DATA 00,67
0AF74:  DATA 43,68
0AF76:  DATA 4D,61
0AF78:  DATA 70,00
0AF7A:  DATA 73,43
0AF7C:  DATA 68,4D
0AF7E:  DATA 61,70
0AF80:  DATA 00,67
0AF82:  DATA 43,68
0AF84:  DATA 4D,6F
0AF86:  DATA 64,65
0AF88:  DATA 00,73
0AF8A:  DATA 43,68
0AF8C:  DATA 4D,6F
0AF8E:  DATA 64,65
0AF90:  DATA 00,67
0AF92:  DATA 50,49
0AF94:  DATA 44,00
0AF96:  DATA 73,50
0AF98:  DATA 49,44
0AF9A:  DATA 00,67
0AF9C:  DATA 53,50
0AF9E:  DATA 00,73
0AFA0:  DATA 53,50
0AFA2:  DATA 00,67
0AFA4:  DATA 53,43
0AFA6:  DATA 61,6C
0AFA8:  DATA 73,00
0AFAA:  DATA 67,53
0AFAC:  DATA 43,61
0AFAE:  DATA 6C,00
0AFB0:  DATA 73,53
0AFB2:  DATA 43,61
0AFB4:  DATA 6C,00
0AFB6:  DATA 67,4D
0AFB8:  DATA 43,61
0AFBA:  DATA 6C,00
0AFBC:  DATA 73,4D
0AFBE:  DATA 43,61
0AFC0:  DATA 6C,00
0AFC2:  DATA 67,4D
0AFC4:  DATA 6F,6E
0AFC6:  DATA 00,67
0AFC8:  DATA 50,49
0AFCA:  DATA 44,64
0AFCC:  DATA 61,74
0AFCE:  DATA 61,00
0AFD0:  DATA 67,49
0AFD2:  DATA 50,64
0AFD4:  DATA 61,74
0AFD6:  DATA 61,00
0AFD8:  DATA 67,4D
0AFDA:  DATA 61,6E
0AFDC:  DATA 4F,50
0AFDE:  DATA 00,73
0AFE0:  DATA 4D,61
0AFE2:  DATA 6E,4F
0AFE4:  DATA 50,04
0AFE6:  DATA C0,00
0AFE8:  DATA 33,80
0AFEA:  DATA 34,06
0AFEC:  DATA 01,3C
0AFEE:  DATA 06,02
0AFF0:  DATA 4C,06
0AFF2:  DATA 53,55
0AFF4:  DATA 43,43
0AFF6:  DATA 45,53
0AFF8:  DATA 53,00
0AFFA:  DATA 49,4E
0AFFC:  DATA 56,41
0AFFE:  DATA 4C,49
0B000:  DATA 44,20
0B002:  DATA 43,4F
0B004:  DATA 4D,4D
0B006:  DATA 41,4E
0B008:  DATA 44,00
0B00A:  DATA 49,4E
0B00C:  DATA 56,41
0B00E:  DATA 4C,49
0B010:  DATA 44,20
0B012:  DATA 50,41
0B014:  DATA 52,41
0B016:  DATA 4D,45
0B018:  DATA 54,45
0B01A:  DATA 52,00
0B01C:  DATA 00,00
0B01E:  MOVLW  00
0B020:  MOVWF  FF8
0B022:  MOVLW  AE
0B024:  MOVWF  FF7
0B026:  MOVLW  58
0B028:  MOVWF  FF6
0B02A:  TBLRD*+
0B02C:  MOVF   FF5,W
0B02E:  MOVWF  00
0B030:  XORLW  00
0B032:  BZ    B05A
0B034:  TBLRD*+
0B036:  MOVF   FF5,W
0B038:  MOVWF  01
0B03A:  BTFSC  FE8.7
0B03C:  BRA    B048
0B03E:  ANDLW  3F
0B040:  MOVWF  FEA
0B042:  TBLRD*+
0B044:  MOVFF  FF5,FE9
0B048:  BTFSC  01.6
0B04A:  TBLRD*+
0B04C:  BTFSS  01.6
0B04E:  TBLRD*+
0B050:  MOVFF  FF5,FEE
0B054:  DCFSNZ 00,F
0B056:  BRA    B02A
0B058:  BRA    B04C
0B05A:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
0B05C:  MOVLB  0
0B05E:  GOTO   03A2
....................    params_init();                // load parameters
0B062:  GOTO   064A
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0B066:  GOTO   102E
....................    control_init();               // initialize the output control DACs
0B06A:  GOTO   10CA
....................    serial_init();                // setup the serial port
0B06E:  GOTO   1278
....................    event_timer_init();
0B072:  GOTO   129A
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0B076:  MOVLW  C0
0B078:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0B07A:  GOTO   1678
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0B07E:  GOTO   4F08
....................       control_task();            //output control
0B082:  GOTO   59D4
....................       serial_task();             //serial port 
0B086:  GOTO   5A9C
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0B08A:  MOVLW  01
0B08C:  MOVLB  6
0B08E:  ADDWF  x5E,W
0B090:  MOVWF  x64
0B092:  MOVF   x5E,W
0B094:  MULLW  21
0B096:  MOVF   FF3,W
0B098:  CLRF   x66
0B09A:  MOVWF  x65
0B09C:  MOVLW  08
0B09E:  ADDWF  x65,W
0B0A0:  MOVWF  01
0B0A2:  MOVLW  00
0B0A4:  ADDWFC x66,W
0B0A6:  MOVWF  03
0B0A8:  MOVF   01,W
0B0AA:  ADDLW  0F
0B0AC:  MOVWF  FE9
0B0AE:  MOVLW  01
0B0B0:  ADDWFC 03,W
0B0B2:  MOVWF  FEA
0B0B4:  MOVFF  FEF,665
0B0B8:  MOVFF  FEC,666
0B0BC:  MOVFF  FEC,667
0B0C0:  MOVFF  FEC,668
0B0C4:  MOVF   x5E,W
0B0C6:  MULLW  21
0B0C8:  MOVF   FF3,W
0B0CA:  CLRF   x6A
0B0CC:  MOVWF  x69
0B0CE:  MOVLW  0C
0B0D0:  ADDWF  x69,W
0B0D2:  MOVWF  01
0B0D4:  MOVLW  00
0B0D6:  ADDWFC x6A,W
0B0D8:  MOVWF  03
0B0DA:  MOVF   01,W
0B0DC:  ADDLW  0F
0B0DE:  MOVWF  FE9
0B0E0:  MOVLW  01
0B0E2:  ADDWFC 03,W
0B0E4:  MOVWF  FEA
0B0E6:  MOVFF  FEF,669
0B0EA:  MOVFF  FEC,66A
0B0EE:  MOVFF  FEC,66B
0B0F2:  MOVFF  FEC,66C
0B0F6:  MOVLW  56
0B0F8:  MOVWF  FF6
0B0FA:  MOVLW  03
0B0FC:  MOVWF  FF7
0B0FE:  MOVLW  08
0B100:  MOVWF  x6D
0B102:  MOVLB  0
0B104:  CALL   5F94
0B108:  MOVFF  664,66D
0B10C:  MOVLW  1B
0B10E:  MOVLB  6
0B110:  MOVWF  x6E
0B112:  MOVLB  0
0B114:  CALL   5FE8
0B118:  MOVLW  2C
0B11A:  MOVLB  6
0B11C:  MOVWF  x7A
0B11E:  MOVLB  0
0B120:  CALL   5A50
0B124:  MOVLW  89
0B126:  MOVWF  FE9
0B128:  MOVFF  668,670
0B12C:  MOVFF  667,66F
0B130:  MOVFF  666,66E
0B134:  MOVFF  665,66D
0B138:  MOVLB  6
0B13A:  CLRF   x71
0B13C:  MOVLB  0
0B13E:  CALL   613A
0B142:  MOVLW  2C
0B144:  MOVLB  6
0B146:  MOVWF  x7A
0B148:  MOVLB  0
0B14A:  CALL   5A50
0B14E:  MOVLW  89
0B150:  MOVWF  FE9
0B152:  MOVFF  66C,670
0B156:  MOVFF  66B,66F
0B15A:  MOVFF  66A,66E
0B15E:  MOVFF  669,66D
0B162:  MOVLB  6
0B164:  CLRF   x71
0B166:  MOVLB  0
0B168:  CALL   613A
0B16C:  MOVLW  0A
0B16E:  MOVLB  6
0B170:  MOVWF  x7A
0B172:  MOVLB  0
0B174:  CALL   5A50
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0B178:  MOVLW  01
0B17A:  MOVLB  6
0B17C:  ADDWF  x5E,W
0B17E:  MOVWF  x64
0B180:  MOVF   x5E,W
0B182:  MULLW  21
0B184:  MOVF   FF3,W
0B186:  CLRF   x66
0B188:  MOVWF  x65
0B18A:  MOVLW  1D
0B18C:  ADDWF  x65,W
0B18E:  MOVWF  01
0B190:  MOVLW  00
0B192:  ADDWFC x66,W
0B194:  MOVWF  03
0B196:  MOVF   01,W
0B198:  ADDLW  0F
0B19A:  MOVWF  FE9
0B19C:  MOVLW  01
0B19E:  ADDWFC 03,W
0B1A0:  MOVWF  FEA
0B1A2:  MOVFF  FEF,665
0B1A6:  MOVFF  FEC,666
0B1AA:  MOVFF  FEC,667
0B1AE:  MOVFF  FEC,668
0B1B2:  MOVLW  6C
0B1B4:  MOVWF  FF6
0B1B6:  MOVLW  03
0B1B8:  MOVWF  FF7
0B1BA:  MOVLW  08
0B1BC:  MOVWF  x6D
0B1BE:  MOVLB  0
0B1C0:  CALL   5F94
0B1C4:  MOVFF  664,66D
0B1C8:  MOVLW  1B
0B1CA:  MOVLB  6
0B1CC:  MOVWF  x6E
0B1CE:  MOVLB  0
0B1D0:  CALL   5FE8
0B1D4:  MOVLW  2C
0B1D6:  MOVLB  6
0B1D8:  MOVWF  x7A
0B1DA:  MOVLB  0
0B1DC:  CALL   5A50
0B1E0:  MOVLW  89
0B1E2:  MOVWF  FE9
0B1E4:  MOVFF  668,670
0B1E8:  MOVFF  667,66F
0B1EC:  MOVFF  666,66E
0B1F0:  MOVFF  665,66D
0B1F4:  MOVLW  03
0B1F6:  MOVLB  6
0B1F8:  MOVWF  x71
0B1FA:  MOVLB  0
0B1FC:  CALL   613A
0B200:  MOVLW  0A
0B202:  MOVLB  6
0B204:  MOVWF  x7A
0B206:  MOVLB  0
0B208:  CALL   5A50
....................       if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0B20C:  MOVLB  6
0B20E:  MOVF   x5E,W
0B210:  MULLW  03
0B212:  MOVF   FF3,W
0B214:  CLRF   x65
0B216:  MOVWF  x64
0B218:  MOVLW  02
0B21A:  ADDWF  x64,W
0B21C:  MOVWF  01
0B21E:  MOVLW  00
0B220:  ADDWFC x65,W
0B222:  MOVWF  03
0B224:  MOVF   01,W
0B226:  ADDLW  51
0B228:  MOVWF  FE9
0B22A:  MOVLW  01
0B22C:  ADDWFC 03,W
0B22E:  MOVWF  FEA
0B230:  BTFSS  FEF.0
0B232:  BRA    B2B0
0B234:  MOVLW  01
0B236:  ADDWF  x5E,W
0B238:  MOVWF  x64
0B23A:  MOVF   x5E,W
0B23C:  MULLW  03
0B23E:  MOVF   FF3,W
0B240:  CLRF   x66
0B242:  MOVWF  x65
0B244:  MOVLW  51
0B246:  ADDWF  x65,W
0B248:  MOVWF  FE9
0B24A:  MOVLW  01
0B24C:  ADDWFC x66,W
0B24E:  MOVWF  FEA
0B250:  MOVFF  FEC,668
0B254:  MOVF   FED,F
0B256:  MOVFF  FEF,667
0B25A:  MOVLW  7E
0B25C:  MOVWF  FF6
0B25E:  MOVLW  03
0B260:  MOVWF  FF7
0B262:  MOVLW  08
0B264:  MOVWF  x6D
0B266:  MOVLB  0
0B268:  CALL   5F94
0B26C:  MOVFF  664,66D
0B270:  MOVLW  1B
0B272:  MOVLB  6
0B274:  MOVWF  x6E
0B276:  MOVLB  0
0B278:  CALL   5FE8
0B27C:  MOVLW  88
0B27E:  MOVWF  FF6
0B280:  MOVLW  03
0B282:  MOVWF  FF7
0B284:  MOVLW  03
0B286:  MOVLB  6
0B288:  MOVWF  x6D
0B28A:  MOVLB  0
0B28C:  CALL   5F94
0B290:  MOVLW  10
0B292:  MOVWF  FE9
0B294:  MOVFF  668,66A
0B298:  MOVFF  667,669
0B29C:  CALL   62EA
0B2A0:  MOVLW  0A
0B2A2:  MOVLB  6
0B2A4:  MOVWF  x7A
0B2A6:  MOVLB  0
0B2A8:  CALL   5A50
0B2AC:  BRA    B328
0B2AE:  MOVLB  6
....................       else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0B2B0:  MOVLW  01
0B2B2:  ADDWF  x5E,W
0B2B4:  MOVWF  x64
0B2B6:  MOVF   x5E,W
0B2B8:  MULLW  03
0B2BA:  MOVF   FF3,W
0B2BC:  CLRF   x66
0B2BE:  MOVWF  x65
0B2C0:  MOVLW  51
0B2C2:  ADDWF  x65,W
0B2C4:  MOVWF  FE9
0B2C6:  MOVLW  01
0B2C8:  ADDWFC x66,W
0B2CA:  MOVWF  FEA
0B2CC:  MOVFF  FEC,668
0B2D0:  MOVF   FED,F
0B2D2:  MOVFF  FEF,667
0B2D6:  MOVLW  90
0B2D8:  MOVWF  FF6
0B2DA:  MOVLW  03
0B2DC:  MOVWF  FF7
0B2DE:  MOVLW  08
0B2E0:  MOVWF  x6D
0B2E2:  MOVLB  0
0B2E4:  CALL   5F94
0B2E8:  MOVFF  664,66D
0B2EC:  MOVLW  1B
0B2EE:  MOVLB  6
0B2F0:  MOVWF  x6E
0B2F2:  MOVLB  0
0B2F4:  CALL   5FE8
0B2F8:  MOVLW  9A
0B2FA:  MOVWF  FF6
0B2FC:  MOVLW  03
0B2FE:  MOVWF  FF7
0B300:  MOVLW  03
0B302:  MOVLB  6
0B304:  MOVWF  x6D
0B306:  MOVLB  0
0B308:  CALL   5F94
0B30C:  MOVLW  10
0B30E:  MOVWF  FE9
0B310:  MOVFF  668,66A
0B314:  MOVFF  667,669
0B318:  CALL   62EA
0B31C:  MOVLW  0A
0B31E:  MOVLB  6
0B320:  MOVWF  x7A
0B322:  MOVLB  0
0B324:  CALL   5A50
....................       ch = !ch;
0B328:  MOVLB  6
0B32A:  MOVF   x5E,F
0B32C:  BZ    B332
0B32E:  MOVLW  00
0B330:  BRA    B334
0B332:  MOVLW  01
0B334:  MOVWF  x5E
.................... //!      fprintf(SERIAL, "---------------\n");
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0B336:  MOVLB  0
0B338:  BRA    ABC4
....................       
....................       delay_ms(250);
0B33A:  MOVLW  FA
0B33C:  MOVLB  6
0B33E:  MOVWF  x6C
0B340:  MOVLB  0
0B342:  CALL   0438
0B346:  BRA    B07A
....................    }
.................... }
0B348:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
