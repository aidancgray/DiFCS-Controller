CCS PCH C Compiler, Version 5.109, 62303               26-Sep-25 18:40

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   37950 bytes (58%)
                           Largest free fragment is 27584
               RAM used:   1513 (42%) at main() level
                           1635 (45%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   9082
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0246
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0031A:  DATA 32,30
0031C:  DATA 32,35
0031E:  DATA 30,38
00320:  DATA 31,32
00322:  DATA 00,00
00324:  DATA 30,30
00326:  DATA 30,30
00328:  DATA 00,00
0032A:  DATA 4D,41
0032C:  DATA 4E,55
0032E:  DATA 41,4C
00330:  DATA 2C,00
00332:  DATA 4D,41
00334:  DATA 47,53
00336:  DATA 4E,53
00338:  DATA 2C,00
*
00660:  ADDWF  FE8,W
00662:  CLRF   FF7
00664:  RLCF   FF7,F
00666:  ADDLW  7B
00668:  MOVWF  FF6
0066A:  MOVLW  06
0066C:  ADDWFC FF7,F
0066E:  TBLRD*-
00670:  MOVF   FF5,W
00672:  MOVWF  FFA
00674:  TBLRD*
00676:  MOVF   FF5,W
00678:  MOVWF  FF9
0067A:  DATA 2A,06
0067C:  DATA 34,06
0067E:  DATA 3E,06
00680:  DATA 48,06
*
00858:  MOVLB  6
0085A:  MOVF   x2A,W
0085C:  MULWF  x2C
0085E:  MOVFF  FF3,01
00862:  MOVFF  FF4,00
00866:  MULWF  x2D
00868:  MOVF   FF3,W
0086A:  ADDWF  00,F
0086C:  MOVF   x2B,W
0086E:  MULWF  x2C
00870:  MOVF   FF3,W
00872:  ADDWFC 00,W
00874:  MOVWF  02
00876:  MOVLB  0
00878:  RETURN 0
*
00A60:  MOVLW  8E
00A62:  MOVWF  00
00A64:  MOVFF  650,01
00A68:  MOVFF  64F,02
00A6C:  CLRF   03
00A6E:  MOVF   01,F
00A70:  BNZ   0A84
00A72:  MOVFF  02,01
00A76:  CLRF   02
00A78:  MOVLW  08
00A7A:  SUBWF  00,F
00A7C:  MOVF   01,F
00A7E:  BNZ   0A84
00A80:  CLRF   00
00A82:  BRA    0A94
00A84:  BCF    FD8.0
00A86:  BTFSC  01.7
00A88:  BRA    0A92
00A8A:  RLCF   02,F
00A8C:  RLCF   01,F
00A8E:  DECF   00,F
00A90:  BRA    0A84
00A92:  BCF    01.7
00A94:  RETURN 0
00A96:  MOVLB  6
00A98:  MOVF   x4B,W
00A9A:  BTFSC  FD8.2
00A9C:  BRA    0B80
00A9E:  MOVWF  00
00AA0:  MOVF   x4F,W
00AA2:  BTFSC  FD8.2
00AA4:  BRA    0B80
00AA6:  ADDWF  00,F
00AA8:  BNC   0AB2
00AAA:  MOVLW  81
00AAC:  ADDWF  00,F
00AAE:  BC    0B80
00AB0:  BRA    0ABA
00AB2:  MOVLW  7F
00AB4:  SUBWF  00,F
00AB6:  BNC   0B80
00AB8:  BZ    0B80
00ABA:  MOVFF  64C,653
00ABE:  MOVF   x50,W
00AC0:  XORWF  x53,F
00AC2:  BSF    x4C.7
00AC4:  BSF    x50.7
00AC6:  MOVF   x4E,W
00AC8:  MULWF  x52
00ACA:  MOVFF  FF4,655
00ACE:  MOVF   x4D,W
00AD0:  MULWF  x51
00AD2:  MOVFF  FF4,03
00AD6:  MOVFF  FF3,654
00ADA:  MULWF  x52
00ADC:  MOVF   FF3,W
00ADE:  ADDWF  x55,F
00AE0:  MOVF   FF4,W
00AE2:  ADDWFC x54,F
00AE4:  MOVLW  00
00AE6:  ADDWFC 03,F
00AE8:  MOVF   x4E,W
00AEA:  MULWF  x51
00AEC:  MOVF   FF3,W
00AEE:  ADDWF  x55,F
00AF0:  MOVF   FF4,W
00AF2:  ADDWFC x54,F
00AF4:  MOVLW  00
00AF6:  CLRF   02
00AF8:  ADDWFC 03,F
00AFA:  ADDWFC 02,F
00AFC:  MOVF   x4C,W
00AFE:  MULWF  x52
00B00:  MOVF   FF3,W
00B02:  ADDWF  x54,F
00B04:  MOVF   FF4,W
00B06:  ADDWFC 03,F
00B08:  MOVLW  00
00B0A:  ADDWFC 02,F
00B0C:  MOVF   x4C,W
00B0E:  MULWF  x51
00B10:  MOVF   FF3,W
00B12:  ADDWF  03,F
00B14:  MOVF   FF4,W
00B16:  ADDWFC 02,F
00B18:  MOVLW  00
00B1A:  CLRF   01
00B1C:  ADDWFC 01,F
00B1E:  MOVF   x4E,W
00B20:  MULWF  x50
00B22:  MOVF   FF3,W
00B24:  ADDWF  x54,F
00B26:  MOVF   FF4,W
00B28:  ADDWFC 03,F
00B2A:  MOVLW  00
00B2C:  ADDWFC 02,F
00B2E:  ADDWFC 01,F
00B30:  MOVF   x4D,W
00B32:  MULWF  x50
00B34:  MOVF   FF3,W
00B36:  ADDWF  03,F
00B38:  MOVF   FF4,W
00B3A:  ADDWFC 02,F
00B3C:  MOVLW  00
00B3E:  ADDWFC 01,F
00B40:  MOVF   x4C,W
00B42:  MULWF  x50
00B44:  MOVF   FF3,W
00B46:  ADDWF  02,F
00B48:  MOVF   FF4,W
00B4A:  ADDWFC 01,F
00B4C:  INCF   00,F
00B4E:  BTFSC  01.7
00B50:  BRA    0B5C
00B52:  RLCF   x54,F
00B54:  RLCF   03,F
00B56:  RLCF   02,F
00B58:  RLCF   01,F
00B5A:  DECF   00,F
00B5C:  MOVLW  00
00B5E:  BTFSS  x54.7
00B60:  BRA    0B76
00B62:  INCF   03,F
00B64:  ADDWFC 02,F
00B66:  ADDWFC 01,F
00B68:  MOVF   01,W
00B6A:  BNZ   0B76
00B6C:  MOVF   02,W
00B6E:  BNZ   0B76
00B70:  MOVF   03,W
00B72:  BNZ   0B76
00B74:  INCF   00,F
00B76:  BTFSC  x53.7
00B78:  BSF    01.7
00B7A:  BTFSS  x53.7
00B7C:  BCF    01.7
00B7E:  BRA    0B88
00B80:  CLRF   00
00B82:  CLRF   01
00B84:  CLRF   02
00B86:  CLRF   03
00B88:  MOVLB  0
00B8A:  RETURN 0
00B8C:  MOVLW  80
00B8E:  BTFSS  FD8.1
00B90:  BRA    0B96
00B92:  MOVLB  6
00B94:  XORWF  x54,F
00B96:  MOVLB  6
00B98:  CLRF   x59
00B9A:  CLRF   x5A
00B9C:  MOVFF  650,658
00BA0:  MOVF   x54,W
00BA2:  XORWF  x58,F
00BA4:  MOVF   x4F,W
00BA6:  BTFSC  FD8.2
00BA8:  BRA    0D68
00BAA:  MOVWF  x57
00BAC:  MOVWF  00
00BAE:  MOVF   x53,W
00BB0:  BTFSC  FD8.2
00BB2:  BRA    0D7A
00BB4:  SUBWF  x57,F
00BB6:  BTFSC  FD8.2
00BB8:  BRA    0CC0
00BBA:  BNC   0C38
00BBC:  MOVFF  654,65D
00BC0:  BSF    x5D.7
00BC2:  MOVFF  655,65C
00BC6:  MOVFF  656,65B
00BCA:  CLRF   x5A
00BCC:  BCF    FD8.0
00BCE:  RRCF   x5D,F
00BD0:  RRCF   x5C,F
00BD2:  RRCF   x5B,F
00BD4:  RRCF   x5A,F
00BD6:  DECFSZ x57,F
00BD8:  BRA    0BCA
00BDA:  BTFSS  x58.7
00BDC:  BRA    0BE4
00BDE:  BSF    x59.0
00BE0:  BRA    0DA2
00BE2:  BCF    x59.0
00BE4:  BCF    x57.0
00BE6:  BSF    x59.4
00BE8:  MOVLW  06
00BEA:  MOVWF  FEA
00BEC:  MOVLW  52
00BEE:  MOVWF  FE9
00BF0:  BRA    0DC8
00BF2:  BCF    x59.4
00BF4:  BTFSC  x58.7
00BF6:  BRA    0C0C
00BF8:  BTFSS  x57.0
00BFA:  BRA    0C22
00BFC:  RRCF   x5D,F
00BFE:  RRCF   x5C,F
00C00:  RRCF   x5B,F
00C02:  RRCF   x5A,F
00C04:  INCF   00,F
00C06:  BTFSC  FD8.2
00C08:  BRA    0D98
00C0A:  BRA    0C22
00C0C:  BTFSC  x5D.7
00C0E:  BRA    0C28
00C10:  BCF    FD8.0
00C12:  RLCF   x5A,F
00C14:  RLCF   x5B,F
00C16:  RLCF   x5C,F
00C18:  RLCF   x5D,F
00C1A:  DECF   00,F
00C1C:  BTFSC  FD8.2
00C1E:  BRA    0D98
00C20:  BRA    0C0C
00C22:  BSF    x59.6
00C24:  BRA    0D00
00C26:  BCF    x59.6
00C28:  MOVFF  650,658
00C2C:  BTFSS  x50.7
00C2E:  BRA    0C34
00C30:  BSF    x5D.7
00C32:  BRA    0D8A
00C34:  BCF    x5D.7
00C36:  BRA    0D8A
00C38:  MOVFF  653,657
00C3C:  MOVFF  653,00
00C40:  MOVF   x4F,W
00C42:  SUBWF  x57,F
00C44:  MOVFF  650,65D
00C48:  BSF    x5D.7
00C4A:  MOVFF  651,65C
00C4E:  MOVFF  652,65B
00C52:  CLRF   x5A
00C54:  BCF    FD8.0
00C56:  RRCF   x5D,F
00C58:  RRCF   x5C,F
00C5A:  RRCF   x5B,F
00C5C:  RRCF   x5A,F
00C5E:  DECFSZ x57,F
00C60:  BRA    0C52
00C62:  BTFSS  x58.7
00C64:  BRA    0C6C
00C66:  BSF    x59.1
00C68:  BRA    0DA2
00C6A:  BCF    x59.1
00C6C:  BCF    x57.0
00C6E:  BSF    x59.5
00C70:  MOVLW  06
00C72:  MOVWF  FEA
00C74:  MOVLW  56
00C76:  MOVWF  FE9
00C78:  BRA    0DC8
00C7A:  BCF    x59.5
00C7C:  BTFSC  x58.7
00C7E:  BRA    0C94
00C80:  BTFSS  x57.0
00C82:  BRA    0CAA
00C84:  RRCF   x5D,F
00C86:  RRCF   x5C,F
00C88:  RRCF   x5B,F
00C8A:  RRCF   x5A,F
00C8C:  INCF   00,F
00C8E:  BTFSC  FD8.2
00C90:  BRA    0D98
00C92:  BRA    0CAA
00C94:  BTFSC  x5D.7
00C96:  BRA    0CB0
00C98:  BCF    FD8.0
00C9A:  RLCF   x5A,F
00C9C:  RLCF   x5B,F
00C9E:  RLCF   x5C,F
00CA0:  RLCF   x5D,F
00CA2:  DECF   00,F
00CA4:  BTFSC  FD8.2
00CA6:  BRA    0D98
00CA8:  BRA    0C94
00CAA:  BSF    x59.7
00CAC:  BRA    0D00
00CAE:  BCF    x59.7
00CB0:  MOVFF  654,658
00CB4:  BTFSS  x54.7
00CB6:  BRA    0CBC
00CB8:  BSF    x5D.7
00CBA:  BRA    0D8A
00CBC:  BCF    x5D.7
00CBE:  BRA    0D8A
00CC0:  MOVFF  654,65D
00CC4:  BSF    x5D.7
00CC6:  MOVFF  655,65C
00CCA:  MOVFF  656,65B
00CCE:  BTFSS  x58.7
00CD0:  BRA    0CDA
00CD2:  BCF    x5D.7
00CD4:  BSF    x59.2
00CD6:  BRA    0DA2
00CD8:  BCF    x59.2
00CDA:  CLRF   x5A
00CDC:  BCF    x57.0
00CDE:  MOVLW  06
00CE0:  MOVWF  FEA
00CE2:  MOVLW  52
00CE4:  MOVWF  FE9
00CE6:  BRA    0DC8
00CE8:  BTFSC  x58.7
00CEA:  BRA    0D24
00CEC:  MOVFF  650,658
00CF0:  BTFSS  x57.0
00CF2:  BRA    0D00
00CF4:  RRCF   x5D,F
00CF6:  RRCF   x5C,F
00CF8:  RRCF   x5B,F
00CFA:  RRCF   x5A,F
00CFC:  INCF   00,F
00CFE:  BZ    0D98
00D00:  BTFSS  x5A.7
00D02:  BRA    0D1A
00D04:  INCF   x5B,F
00D06:  BNZ   0D1A
00D08:  INCF   x5C,F
00D0A:  BNZ   0D1A
00D0C:  INCF   x5D,F
00D0E:  BNZ   0D1A
00D10:  RRCF   x5D,F
00D12:  RRCF   x5C,F
00D14:  RRCF   x5B,F
00D16:  INCF   00,F
00D18:  BZ    0D98
00D1A:  BTFSC  x59.6
00D1C:  BRA    0C26
00D1E:  BTFSC  x59.7
00D20:  BRA    0CAE
00D22:  BRA    0D5C
00D24:  MOVLW  80
00D26:  XORWF  x5D,F
00D28:  BTFSS  x5D.7
00D2A:  BRA    0D34
00D2C:  BRA    0DA2
00D2E:  MOVFF  654,658
00D32:  BRA    0D48
00D34:  MOVFF  650,658
00D38:  MOVF   x5D,F
00D3A:  BNZ   0D48
00D3C:  MOVF   x5C,F
00D3E:  BNZ   0D48
00D40:  MOVF   x5B,F
00D42:  BNZ   0D48
00D44:  CLRF   00
00D46:  BRA    0D8A
00D48:  BTFSC  x5D.7
00D4A:  BRA    0D5C
00D4C:  BCF    FD8.0
00D4E:  RLCF   x5A,F
00D50:  RLCF   x5B,F
00D52:  RLCF   x5C,F
00D54:  RLCF   x5D,F
00D56:  DECFSZ 00,F
00D58:  BRA    0D48
00D5A:  BRA    0D98
00D5C:  BTFSS  x58.7
00D5E:  BRA    0D64
00D60:  BSF    x5D.7
00D62:  BRA    0D8A
00D64:  BCF    x5D.7
00D66:  BRA    0D8A
00D68:  MOVFF  653,00
00D6C:  MOVFF  654,65D
00D70:  MOVFF  655,65C
00D74:  MOVFF  656,65B
00D78:  BRA    0D8A
00D7A:  MOVFF  64F,00
00D7E:  MOVFF  650,65D
00D82:  MOVFF  651,65C
00D86:  MOVFF  652,65B
00D8A:  MOVFF  65D,01
00D8E:  MOVFF  65C,02
00D92:  MOVFF  65B,03
00D96:  BRA    0E00
00D98:  CLRF   00
00D9A:  CLRF   01
00D9C:  CLRF   02
00D9E:  CLRF   03
00DA0:  BRA    0E00
00DA2:  CLRF   x5A
00DA4:  COMF   x5B,F
00DA6:  COMF   x5C,F
00DA8:  COMF   x5D,F
00DAA:  COMF   x5A,F
00DAC:  INCF   x5A,F
00DAE:  BNZ   0DBA
00DB0:  INCF   x5B,F
00DB2:  BNZ   0DBA
00DB4:  INCF   x5C,F
00DB6:  BNZ   0DBA
00DB8:  INCF   x5D,F
00DBA:  BTFSC  x59.0
00DBC:  BRA    0BE2
00DBE:  BTFSC  x59.1
00DC0:  BRA    0C6A
00DC2:  BTFSC  x59.2
00DC4:  BRA    0CD8
00DC6:  BRA    0D2E
00DC8:  MOVF   FEF,W
00DCA:  ADDWF  x5B,F
00DCC:  BNC   0DD8
00DCE:  INCF   x5C,F
00DD0:  BNZ   0DD8
00DD2:  INCF   x5D,F
00DD4:  BTFSC  FD8.2
00DD6:  BSF    x57.0
00DD8:  MOVF   FED,F
00DDA:  MOVF   FEF,W
00DDC:  ADDWF  x5C,F
00DDE:  BNC   0DE6
00DE0:  INCF   x5D,F
00DE2:  BTFSC  FD8.2
00DE4:  BSF    x57.0
00DE6:  MOVF   FED,F
00DE8:  MOVF   FEF,W
00DEA:  BTFSC  FEF.7
00DEC:  BRA    0DF0
00DEE:  XORLW  80
00DF0:  ADDWF  x5D,F
00DF2:  BTFSC  FD8.0
00DF4:  BSF    x57.0
00DF6:  BTFSC  x59.4
00DF8:  BRA    0BF2
00DFA:  BTFSC  x59.5
00DFC:  BRA    0C7A
00DFE:  BRA    0CE8
00E00:  MOVLB  0
00E02:  RETURN 0
*
0135A:  ADDWF  FE8,W
0135C:  CLRF   FF7
0135E:  RLCF   FF7,F
01360:  ADDLW  75
01362:  MOVWF  FF6
01364:  MOVLW  13
01366:  ADDWFC FF7,F
01368:  TBLRD*-
0136A:  MOVF   FF5,W
0136C:  MOVWF  FFA
0136E:  TBLRD*
01370:  MOVF   FF5,W
01372:  MOVWF  FF9
01374:  DATA 1C,0E
01376:  DATA DC,0E
01378:  DATA 9C,0F
0137A:  DATA 5C,10
0137C:  DATA 1C,11
0137E:  DATA DC,11
01380:  DATA 9C,12
*
013EC:  MOVLW  B6
013EE:  MOVWF  00
013F0:  CLRF   03
013F2:  CLRF   02
013F4:  CLRF   01
013F6:  MOVLB  6
013F8:  BCF    x19.0
013FA:  BTFSS  x18.7
013FC:  BRA    1416
013FE:  BSF    x19.0
01400:  COMF   x15,F
01402:  COMF   x16,F
01404:  COMF   x17,F
01406:  COMF   x18,F
01408:  INCF   x15,F
0140A:  BNZ   1416
0140C:  INCF   x16,F
0140E:  BNZ   1416
01410:  INCF   x17,F
01412:  BTFSC  FD8.2
01414:  INCF   x18,F
01416:  MOVF   x15,W
01418:  IORWF  x16,W
0141A:  IORWF  x17,W
0141C:  IORWF  x18,W
0141E:  BNZ   1424
01420:  CLRF   00
01422:  BRA    1442
01424:  BCF    FD8.0
01426:  BTFSC  01.7
01428:  BRA    143C
0142A:  RLCF   x15,F
0142C:  RLCF   x16,F
0142E:  RLCF   x17,F
01430:  RLCF   x18,F
01432:  RLCF   03,F
01434:  RLCF   02,F
01436:  RLCF   01,F
01438:  DECFSZ 00,F
0143A:  BRA    1424
0143C:  BCF    01.7
0143E:  BTFSC  x19.0
01440:  BSF    01.7
01442:  MOVLB  0
01444:  RETURN 0
01446:  MOVFF  64C,653
0144A:  MOVLB  6
0144C:  MOVF   x50,W
0144E:  XORWF  x53,F
01450:  BTFSS  x53.7
01452:  BRA    145E
01454:  BCF    FD8.2
01456:  BCF    FD8.0
01458:  BTFSC  x4C.7
0145A:  BSF    FD8.0
0145C:  BRA    14BC
0145E:  MOVFF  64C,653
01462:  MOVFF  64F,654
01466:  MOVF   x4B,W
01468:  SUBWF  x54,F
0146A:  BZ    1478
0146C:  BTFSS  x53.7
0146E:  BRA    14BC
01470:  MOVF   FD8,W
01472:  XORLW  01
01474:  MOVWF  FD8
01476:  BRA    14BC
01478:  MOVFF  650,654
0147C:  MOVF   x4C,W
0147E:  SUBWF  x54,F
01480:  BZ    148E
01482:  BTFSS  x53.7
01484:  BRA    14BC
01486:  MOVF   FD8,W
01488:  XORLW  01
0148A:  MOVWF  FD8
0148C:  BRA    14BC
0148E:  MOVFF  651,654
01492:  MOVF   x4D,W
01494:  SUBWF  x54,F
01496:  BZ    14A4
01498:  BTFSS  x53.7
0149A:  BRA    14BC
0149C:  MOVF   FD8,W
0149E:  XORLW  01
014A0:  MOVWF  FD8
014A2:  BRA    14BC
014A4:  MOVFF  652,654
014A8:  MOVF   x4E,W
014AA:  SUBWF  x54,F
014AC:  BZ    14BA
014AE:  BTFSS  x53.7
014B0:  BRA    14BC
014B2:  MOVF   FD8,W
014B4:  XORLW  01
014B6:  MOVWF  FD8
014B8:  BRA    14BC
014BA:  BCF    FD8.0
014BC:  MOVLB  0
014BE:  RETURN 0
014C0:  MOVLB  6
014C2:  MOVF   x44,W
014C4:  BTFSC  FD8.2
014C6:  BRA    1612
014C8:  MOVWF  x50
014CA:  MOVF   x48,W
014CC:  BTFSC  FD8.2
014CE:  BRA    1612
014D0:  SUBWF  x50,F
014D2:  BNC   14DE
014D4:  MOVLW  7F
014D6:  ADDWF  x50,F
014D8:  BTFSC  FD8.0
014DA:  BRA    1612
014DC:  BRA    14EA
014DE:  MOVLW  81
014E0:  SUBWF  x50,F
014E2:  BTFSS  FD8.0
014E4:  BRA    1612
014E6:  BTFSC  FD8.2
014E8:  BRA    1612
014EA:  MOVFF  650,00
014EE:  CLRF   01
014F0:  CLRF   02
014F2:  CLRF   03
014F4:  CLRF   x4F
014F6:  MOVFF  645,64E
014FA:  BSF    x4E.7
014FC:  MOVFF  646,64D
01500:  MOVFF  647,64C
01504:  MOVLW  19
01506:  MOVWF  x50
01508:  MOVF   x4B,W
0150A:  SUBWF  x4C,F
0150C:  BC    1528
0150E:  MOVLW  01
01510:  SUBWF  x4D,F
01512:  BC    1528
01514:  SUBWF  x4E,F
01516:  BC    1528
01518:  SUBWF  x4F,F
0151A:  BC    1528
0151C:  INCF   x4F,F
0151E:  INCF   x4E,F
01520:  INCF   x4D,F
01522:  MOVF   x4B,W
01524:  ADDWF  x4C,F
01526:  BRA    1578
01528:  MOVF   x4A,W
0152A:  SUBWF  x4D,F
0152C:  BC    1552
0152E:  MOVLW  01
01530:  SUBWF  x4E,F
01532:  BC    1552
01534:  SUBWF  x4F,F
01536:  BC    1552
01538:  INCF   x4F,F
0153A:  INCF   x4E,F
0153C:  MOVF   x4A,W
0153E:  ADDWF  x4D,F
01540:  MOVF   x4B,W
01542:  ADDWF  x4C,F
01544:  BNC   1578
01546:  INCF   x4D,F
01548:  BNZ   1578
0154A:  INCF   x4E,F
0154C:  BNZ   1578
0154E:  INCF   x4F,F
01550:  BRA    1578
01552:  MOVF   x49,W
01554:  IORLW  80
01556:  SUBWF  x4E,F
01558:  BC    1576
0155A:  MOVLW  01
0155C:  SUBWF  x4F,F
0155E:  BC    1576
01560:  INCF   x4F,F
01562:  MOVF   x49,W
01564:  IORLW  80
01566:  ADDWF  x4E,F
01568:  MOVF   x4A,W
0156A:  ADDWF  x4D,F
0156C:  BNC   1540
0156E:  INCF   x4E,F
01570:  BNZ   1540
01572:  INCF   x4F,F
01574:  BRA    1540
01576:  BSF    03.0
01578:  DECFSZ x50,F
0157A:  BRA    157E
0157C:  BRA    1594
0157E:  BCF    FD8.0
01580:  RLCF   x4C,F
01582:  RLCF   x4D,F
01584:  RLCF   x4E,F
01586:  RLCF   x4F,F
01588:  BCF    FD8.0
0158A:  RLCF   03,F
0158C:  RLCF   02,F
0158E:  RLCF   01,F
01590:  RLCF   x51,F
01592:  BRA    1508
01594:  BTFSS  x51.0
01596:  BRA    15A4
01598:  BCF    FD8.0
0159A:  RRCF   01,F
0159C:  RRCF   02,F
0159E:  RRCF   03,F
015A0:  RRCF   x51,F
015A2:  BRA    15A8
015A4:  DECF   00,F
015A6:  BZ    1612
015A8:  BTFSC  x51.7
015AA:  BRA    15E8
015AC:  BCF    FD8.0
015AE:  RLCF   x4C,F
015B0:  RLCF   x4D,F
015B2:  RLCF   x4E,F
015B4:  RLCF   x4F,F
015B6:  MOVF   x4B,W
015B8:  SUBWF  x4C,F
015BA:  BC    15CA
015BC:  MOVLW  01
015BE:  SUBWF  x4D,F
015C0:  BC    15CA
015C2:  SUBWF  x4E,F
015C4:  BC    15CA
015C6:  SUBWF  x4F,F
015C8:  BNC   15FE
015CA:  MOVF   x4A,W
015CC:  SUBWF  x4D,F
015CE:  BC    15DA
015D0:  MOVLW  01
015D2:  SUBWF  x4E,F
015D4:  BC    15DA
015D6:  SUBWF  x4F,F
015D8:  BNC   15FE
015DA:  MOVF   x49,W
015DC:  IORLW  80
015DE:  SUBWF  x4E,F
015E0:  BC    15E8
015E2:  MOVLW  01
015E4:  SUBWF  x4F,F
015E6:  BNC   15FE
015E8:  INCF   03,F
015EA:  BNZ   15FE
015EC:  INCF   02,F
015EE:  BNZ   15FE
015F0:  INCF   01,F
015F2:  BNZ   15FE
015F4:  INCF   00,F
015F6:  BZ    1612
015F8:  RRCF   01,F
015FA:  RRCF   02,F
015FC:  RRCF   03,F
015FE:  MOVFF  645,650
01602:  MOVF   x49,W
01604:  XORWF  x50,F
01606:  BTFSS  x50.7
01608:  BRA    160E
0160A:  BSF    01.7
0160C:  BRA    161A
0160E:  BCF    01.7
01610:  BRA    161A
01612:  CLRF   00
01614:  CLRF   01
01616:  CLRF   02
01618:  CLRF   03
0161A:  MOVLB  0
0161C:  RETURN 0
*
01DC8:  ADDWF  FE8,W
01DCA:  CLRF   FF7
01DCC:  RLCF   FF7,F
01DCE:  ADDLW  E3
01DD0:  MOVWF  FF6
01DD2:  MOVLW  1D
01DD4:  ADDWFC FF7,F
01DD6:  TBLRD*-
01DD8:  MOVF   FF5,W
01DDA:  MOVWF  FFA
01DDC:  TBLRD*
01DDE:  MOVF   FF5,W
01DE0:  MOVWF  FF9
01DE2:  DATA D0,1C
01DE4:  DATA EA,1C
01DE6:  DATA 3E,1D
01DE8:  DATA A2,1D
01DEA:  MOVLW  8E
01DEC:  MOVWF  00
01DEE:  MOVFF  642,01
01DF2:  MOVFF  641,02
01DF6:  CLRF   03
01DF8:  BTFSS  01.7
01DFA:  BRA    1E06
01DFC:  COMF   01,F
01DFE:  COMF   02,F
01E00:  INCF   02,F
01E02:  BNZ   1E06
01E04:  INCF   01,F
01E06:  MOVF   01,F
01E08:  BNZ   1E1C
01E0A:  MOVFF  02,01
01E0E:  CLRF   02
01E10:  MOVLW  08
01E12:  SUBWF  00,F
01E14:  MOVF   01,F
01E16:  BNZ   1E1C
01E18:  CLRF   00
01E1A:  BRA    1E38
01E1C:  BCF    FD8.0
01E1E:  BTFSC  01.7
01E20:  BRA    1E2A
01E22:  RLCF   02,F
01E24:  RLCF   01,F
01E26:  DECF   00,F
01E28:  BRA    1E1C
01E2A:  MOVLB  6
01E2C:  BTFSS  x42.7
01E2E:  BRA    1E34
01E30:  MOVLB  0
01E32:  BRA    1E38
01E34:  BCF    01.7
01E36:  MOVLB  0
01E38:  RETURN 0
01E3A:  MOVLW  8E
01E3C:  MOVWF  00
01E3E:  MOVLB  6
01E40:  MOVF   x4B,W
01E42:  SUBWF  00,F
01E44:  MOVFF  64C,02
01E48:  MOVFF  64D,01
01E4C:  BSF    02.7
01E4E:  MOVF   00,F
01E50:  BZ    1E64
01E52:  BCF    FD8.0
01E54:  MOVF   02,F
01E56:  BNZ   1E5C
01E58:  MOVF   01,F
01E5A:  BZ    1E64
01E5C:  RRCF   02,F
01E5E:  RRCF   01,F
01E60:  DECFSZ 00,F
01E62:  BRA    1E52
01E64:  BTFSS  x4C.7
01E66:  BRA    1E72
01E68:  COMF   01,F
01E6A:  COMF   02,F
01E6C:  INCF   01,F
01E6E:  BTFSC  FD8.2
01E70:  INCF   02,F
01E72:  MOVLB  0
01E74:  RETURN 0
*
03C1A:  MOVLB  5
03C1C:  MOVF   xF6,W
03C1E:  ANDLW  07
03C20:  MOVWF  00
03C22:  RRCF   xF6,W
03C24:  MOVWF  01
03C26:  RRCF   01,F
03C28:  RRCF   01,F
03C2A:  MOVLW  1F
03C2C:  ANDWF  01,F
03C2E:  MOVF   01,W
03C30:  ADDWF  xF7,W
03C32:  MOVWF  FE9
03C34:  MOVLW  00
03C36:  ADDWFC xF8,W
03C38:  MOVWF  FEA
03C3A:  MOVFF  FEF,01
03C3E:  INCF   00,F
03C40:  BRA    3C44
03C42:  RRCF   01,F
03C44:  DECFSZ 00,F
03C46:  BRA    3C42
03C48:  MOVLW  01
03C4A:  ANDWF  01,F
03C4C:  MOVLB  0
03C4E:  RETURN 0
*
0446A:  MOVF   FEF,F
0446C:  BZ    448C
0446E:  MOVFF  FEA,5EF
04472:  MOVFF  FE9,5EE
04476:  MOVFF  FEF,5F0
0447A:  RCALL  4442
0447C:  MOVFF  5EF,FEA
04480:  MOVFF  5EE,FE9
04484:  INCF   FE9,F
04486:  BTFSC  FD8.2
04488:  INCF   FEA,F
0448A:  BRA    446A
0448C:  RETURN 0
*
04AEA:  MOVFF  4E1,FEA
04AEE:  MOVFF  4E0,FE9
04AF2:  MOVFF  639,FEF
04AF6:  INCF   FE9,F
04AF8:  BTFSC  FD8.2
04AFA:  INCF   FEA,F
04AFC:  CLRF   FEF
04AFE:  MOVLB  4
04B00:  INCF   xE0,F
04B02:  BTFSC  FD8.2
04B04:  INCF   xE1,F
04B06:  MOVLB  0
04B08:  RETURN 0
04B0A:  TBLRD*+
04B0C:  MOVF   FF5,F
04B0E:  BZ    4B28
04B10:  MOVFF  FF6,5F8
04B14:  MOVFF  FF7,5F9
04B18:  MOVFF  FF5,639
04B1C:  RCALL  4AEA
04B1E:  MOVFF  5F8,FF6
04B22:  MOVFF  5F9,FF7
04B26:  BRA    4B0A
04B28:  RETURN 0
*
04C4C:  MOVLB  6
04C4E:  MOVF   x51,W
04C50:  XORWF  x53,W
04C52:  ANDLW  80
04C54:  MOVWF  x55
04C56:  BTFSS  x51.7
04C58:  BRA    4C64
04C5A:  COMF   x50,F
04C5C:  COMF   x51,F
04C5E:  INCF   x50,F
04C60:  BTFSC  FD8.2
04C62:  INCF   x51,F
04C64:  BTFSS  x53.7
04C66:  BRA    4C72
04C68:  COMF   x52,F
04C6A:  COMF   x53,F
04C6C:  INCF   x52,F
04C6E:  BTFSC  FD8.2
04C70:  INCF   x53,F
04C72:  MOVF   x50,W
04C74:  MULWF  x52
04C76:  MOVFF  FF3,01
04C7A:  MOVFF  FF4,00
04C7E:  MULWF  x53
04C80:  MOVF   FF3,W
04C82:  ADDWF  00,F
04C84:  MOVF   x51,W
04C86:  MULWF  x52
04C88:  MOVF   FF3,W
04C8A:  ADDWFC 00,W
04C8C:  MOVWF  02
04C8E:  BTFSS  x55.7
04C90:  BRA    4C9C
04C92:  COMF   01,F
04C94:  COMF   02,F
04C96:  INCF   01,F
04C98:  BTFSC  FD8.2
04C9A:  INCF   02,F
04C9C:  MOVLB  0
04C9E:  GOTO   4F32 (RETURN)
*
05168:  MOVLB  6
0516A:  MOVF   x0B,W
0516C:  ANDLW  07
0516E:  MOVWF  00
05170:  RRCF   x0B,W
05172:  MOVWF  01
05174:  RRCF   01,F
05176:  RRCF   01,F
05178:  MOVLW  1F
0517A:  ANDWF  01,F
0517C:  MOVF   01,W
0517E:  ADDWF  x0D,W
05180:  MOVWF  FE9
05182:  MOVLW  00
05184:  ADDWFC x0E,W
05186:  MOVWF  FEA
05188:  CLRF   01
0518A:  INCF   01,F
0518C:  INCF   00,F
0518E:  BRA    5192
05190:  RLCF   01,F
05192:  DECFSZ 00,F
05194:  BRA    5190
05196:  MOVF   x0C,F
05198:  BZ    51A0
0519A:  MOVF   01,W
0519C:  IORWF  FEF,F
0519E:  BRA    51A6
051A0:  COMF   01,F
051A2:  MOVF   01,W
051A4:  ANDWF  FEF,F
051A6:  MOVLB  0
051A8:  RETURN 0
*
056EC:  MOVLB  6
056EE:  MOVF   x39,W
056F0:  SUBLW  B6
056F2:  MOVWF  x39
056F4:  CLRF   03
056F6:  MOVFF  63A,63D
056FA:  BSF    x3A.7
056FC:  BCF    FD8.0
056FE:  RRCF   x3A,F
05700:  RRCF   x3B,F
05702:  RRCF   x3C,F
05704:  RRCF   03,F
05706:  RRCF   02,F
05708:  RRCF   01,F
0570A:  RRCF   00,F
0570C:  DECFSZ x39,F
0570E:  BRA    56FC
05710:  BTFSS  x3D.7
05712:  BRA    572A
05714:  COMF   00,F
05716:  COMF   01,F
05718:  COMF   02,F
0571A:  COMF   03,F
0571C:  INCF   00,F
0571E:  BTFSC  FD8.2
05720:  INCF   01,F
05722:  BTFSC  FD8.2
05724:  INCF   02,F
05726:  BTFSC  FD8.2
05728:  INCF   03,F
0572A:  MOVLB  0
0572C:  RETURN 0
0572E:  BTFSC  FD8.1
05730:  BRA    573A
05732:  MOVLW  06
05734:  MOVWF  FEA
05736:  MOVLW  41
05738:  MOVWF  FE9
0573A:  CLRF   00
0573C:  CLRF   01
0573E:  CLRF   02
05740:  CLRF   03
05742:  MOVLB  6
05744:  CLRF   x41
05746:  CLRF   x42
05748:  CLRF   x43
0574A:  CLRF   x44
0574C:  MOVF   x40,W
0574E:  IORWF  x3F,W
05750:  IORWF  x3E,W
05752:  IORWF  x3D,W
05754:  BZ    57AE
05756:  MOVLW  20
05758:  MOVWF  x45
0575A:  BCF    FD8.0
0575C:  RLCF   x39,F
0575E:  RLCF   x3A,F
05760:  RLCF   x3B,F
05762:  RLCF   x3C,F
05764:  RLCF   x41,F
05766:  RLCF   x42,F
05768:  RLCF   x43,F
0576A:  RLCF   x44,F
0576C:  MOVF   x40,W
0576E:  SUBWF  x44,W
05770:  BNZ   5782
05772:  MOVF   x3F,W
05774:  SUBWF  x43,W
05776:  BNZ   5782
05778:  MOVF   x3E,W
0577A:  SUBWF  x42,W
0577C:  BNZ   5782
0577E:  MOVF   x3D,W
05780:  SUBWF  x41,W
05782:  BNC   57A2
05784:  MOVF   x3D,W
05786:  SUBWF  x41,F
05788:  MOVF   x3E,W
0578A:  BTFSS  FD8.0
0578C:  INCFSZ x3E,W
0578E:  SUBWF  x42,F
05790:  MOVF   x3F,W
05792:  BTFSS  FD8.0
05794:  INCFSZ x3F,W
05796:  SUBWF  x43,F
05798:  MOVF   x40,W
0579A:  BTFSS  FD8.0
0579C:  INCFSZ x40,W
0579E:  SUBWF  x44,F
057A0:  BSF    FD8.0
057A2:  RLCF   00,F
057A4:  RLCF   01,F
057A6:  RLCF   02,F
057A8:  RLCF   03,F
057AA:  DECFSZ x45,F
057AC:  BRA    575A
057AE:  MOVFF  641,FEF
057B2:  MOVFF  642,FEC
057B6:  MOVFF  643,FEC
057BA:  MOVFF  644,FEC
057BE:  MOVLB  0
057C0:  RETURN 0
057C2:  MOVF   FE9,W
057C4:  MOVLB  6
057C6:  MOVWF  x31
057C8:  MOVF   x30,W
057CA:  MOVWF  x33
057CC:  BZ    5806
057CE:  MOVFF  62F,64E
057D2:  MOVFF  62E,64D
057D6:  MOVFF  62D,64C
057DA:  MOVFF  62C,64B
057DE:  CLRF   x52
057E0:  CLRF   x51
057E2:  MOVLW  20
057E4:  MOVWF  x50
057E6:  MOVLW  82
057E8:  MOVWF  x4F
057EA:  MOVLB  0
057EC:  CALL   0A96
057F0:  MOVFF  03,62F
057F4:  MOVFF  02,62E
057F8:  MOVFF  01,62D
057FC:  MOVFF  00,62C
05800:  MOVLB  6
05802:  DECFSZ x33,F
05804:  BRA    57CE
05806:  MOVFF  62F,63C
0580A:  MOVFF  62E,63B
0580E:  MOVFF  62D,63A
05812:  MOVFF  62C,639
05816:  MOVLB  0
05818:  RCALL  56EC
0581A:  MOVFF  03,62F
0581E:  MOVFF  02,62E
05822:  MOVFF  01,62D
05826:  MOVFF  00,62C
0582A:  MOVLB  6
0582C:  BTFSS  x2F.7
0582E:  BRA    584A
05830:  DECF   x31,F
05832:  BSF    x31.5
05834:  COMF   x2C,F
05836:  COMF   x2D,F
05838:  COMF   x2E,F
0583A:  COMF   x2F,F
0583C:  INCF   x2C,F
0583E:  BTFSC  FD8.2
05840:  INCF   x2D,F
05842:  BTFSC  FD8.2
05844:  INCF   x2E,F
05846:  BTFSC  FD8.2
05848:  INCF   x2F,F
0584A:  MOVLW  3B
0584C:  MOVWF  x38
0584E:  MOVLW  9A
05850:  MOVWF  x37
05852:  MOVLW  CA
05854:  MOVWF  x36
05856:  CLRF   x35
05858:  MOVLW  0A
0585A:  MOVWF  x33
0585C:  MOVF   x30,W
0585E:  BTFSC  FD8.2
05860:  INCF   x31,F
05862:  BSF    FD8.1
05864:  MOVLW  06
05866:  MOVWF  FEA
05868:  MOVLW  2C
0586A:  MOVWF  FE9
0586C:  MOVFF  62F,63C
05870:  MOVFF  62E,63B
05874:  MOVFF  62D,63A
05878:  MOVFF  62C,639
0587C:  MOVFF  638,640
05880:  MOVFF  637,63F
05884:  MOVFF  636,63E
05888:  MOVFF  635,63D
0588C:  MOVLB  0
0588E:  RCALL  572E
05890:  MOVF   01,W
05892:  MOVF   00,F
05894:  BNZ   58BC
05896:  MOVLB  6
05898:  INCF   x30,W
0589A:  SUBWF  x33,W
0589C:  BTFSS  FD8.2
0589E:  BRA    58A4
058A0:  MOVLB  0
058A2:  BRA    58BC
058A4:  MOVF   x31,W
058A6:  BZ    58C2
058A8:  ANDLW  0F
058AA:  SUBWF  x33,W
058AC:  BZ    58B0
058AE:  BC    5938
058B0:  BTFSC  x31.7
058B2:  BRA    5938
058B4:  BTFSC  x31.6
058B6:  BRA    58C2
058B8:  MOVLW  20
058BA:  BRA    592A
058BC:  MOVLW  20
058BE:  MOVLB  6
058C0:  ANDWF  x31,F
058C2:  BTFSS  x31.5
058C4:  BRA    58E4
058C6:  BCF    x31.5
058C8:  MOVF   x30,W
058CA:  BTFSS  FD8.2
058CC:  DECF   x31,F
058CE:  MOVF   00,W
058D0:  MOVWF  x31
058D2:  MOVLW  2D
058D4:  MOVWF  x39
058D6:  MOVLB  0
058D8:  CALL   4AEA
058DC:  MOVLB  6
058DE:  MOVF   x31,W
058E0:  MOVWF  00
058E2:  CLRF   x31
058E4:  MOVF   x30,W
058E6:  SUBWF  x33,W
058E8:  BNZ   5904
058EA:  MOVF   00,W
058EC:  MOVWF  x31
058EE:  MOVLW  2E
058F0:  MOVWF  x39
058F2:  MOVLB  0
058F4:  CALL   4AEA
058F8:  MOVLB  6
058FA:  MOVF   x31,W
058FC:  MOVWF  00
058FE:  MOVLW  20
05900:  ANDWF  x31,F
05902:  MOVLW  00
05904:  MOVLW  30
05906:  BTFSS  x31.5
05908:  BRA    592A
0590A:  BCF    x31.5
0590C:  MOVF   x30,W
0590E:  BTFSS  FD8.2
05910:  DECF   x31,F
05912:  MOVF   00,W
05914:  MOVWF  x31
05916:  MOVLW  2D
05918:  MOVWF  x39
0591A:  MOVLB  0
0591C:  CALL   4AEA
05920:  MOVLB  6
05922:  MOVF   x31,W
05924:  MOVWF  00
05926:  CLRF   x31
05928:  MOVLW  30
0592A:  ADDWF  00,F
0592C:  MOVFF  00,639
05930:  MOVLB  0
05932:  CALL   4AEA
05936:  MOVLB  6
05938:  BCF    FD8.1
0593A:  MOVFF  638,63C
0593E:  MOVFF  637,63B
05942:  MOVFF  636,63A
05946:  MOVFF  635,639
0594A:  CLRF   x40
0594C:  CLRF   x3F
0594E:  CLRF   x3E
05950:  MOVLW  0A
05952:  MOVWF  x3D
05954:  MOVLB  0
05956:  RCALL  572E
05958:  MOVFF  03,638
0595C:  MOVFF  02,637
05960:  MOVFF  01,636
05964:  MOVFF  00,635
05968:  MOVLB  6
0596A:  DECFSZ x33,F
0596C:  BRA    5862
0596E:  MOVLB  0
05970:  RETURN 0
*
081AA:  MOVLB  6
081AC:  MOVF   x24,W
081AE:  CLRF   01
081B0:  SUBWF  x23,W
081B2:  BC    81BA
081B4:  MOVFF  623,00
081B8:  BRA    81D2
081BA:  CLRF   00
081BC:  MOVLW  08
081BE:  MOVWF  x25
081C0:  RLCF   x23,F
081C2:  RLCF   00,F
081C4:  MOVF   x24,W
081C6:  SUBWF  00,W
081C8:  BTFSC  FD8.0
081CA:  MOVWF  00
081CC:  RLCF   01,F
081CE:  DECFSZ x25,F
081D0:  BRA    81C0
081D2:  MOVLB  0
081D4:  RETURN 0
081D6:  MOVLW  20
081D8:  MOVLB  6
081DA:  BTFSS  x1E.4
081DC:  MOVLW  30
081DE:  MOVWF  x1F
081E0:  MOVFF  61D,00
081E4:  BTFSS  00.7
081E6:  BRA    81F8
081E8:  COMF   00,F
081EA:  INCF   00,F
081EC:  MOVFF  00,61D
081F0:  MOVLW  2D
081F2:  MOVWF  x1F
081F4:  BSF    x1E.7
081F6:  BSF    x1E.0
081F8:  MOVF   01,W
081FA:  MOVFF  61D,623
081FE:  MOVLW  64
08200:  MOVWF  x24
08202:  MOVLB  0
08204:  RCALL  81AA
08206:  MOVFF  00,61D
0820A:  MOVLW  30
0820C:  ADDWF  01,W
0820E:  MOVLB  6
08210:  MOVWF  x20
08212:  MOVFF  61D,623
08216:  MOVLW  0A
08218:  MOVWF  x24
0821A:  MOVLB  0
0821C:  RCALL  81AA
0821E:  MOVLW  30
08220:  ADDWF  00,W
08222:  MOVLB  6
08224:  MOVWF  x22
08226:  MOVLW  30
08228:  ADDWF  01,W
0822A:  MOVWF  x21
0822C:  MOVFF  61F,00
08230:  MOVLW  30
08232:  SUBWF  x20,W
08234:  BZ    823E
08236:  BSF    x1E.1
08238:  BTFSC  x1E.7
0823A:  BSF    x1E.2
0823C:  BRA    8262
0823E:  MOVFF  61F,620
08242:  MOVLW  20
08244:  MOVWF  x1F
08246:  MOVLW  30
08248:  SUBWF  x21,W
0824A:  BZ    8254
0824C:  BSF    x1E.0
0824E:  BTFSC  x1E.7
08250:  BSF    x1E.1
08252:  BRA    8262
08254:  BTFSS  FD8.2
08256:  BSF    x1E.0
08258:  BNZ   8262
0825A:  MOVFF  620,621
0825E:  MOVLW  20
08260:  MOVWF  x20
08262:  BTFSC  x1E.2
08264:  BRA    8270
08266:  BTFSC  x1E.1
08268:  BRA    827A
0826A:  BTFSC  x1E.0
0826C:  BRA    8284
0826E:  BRA    828E
08270:  MOVFF  61F,639
08274:  MOVLB  0
08276:  CALL   4AEA
0827A:  MOVFF  620,639
0827E:  MOVLB  0
08280:  CALL   4AEA
08284:  MOVFF  621,639
08288:  MOVLB  0
0828A:  CALL   4AEA
0828E:  MOVFF  622,639
08292:  MOVLB  0
08294:  CALL   4AEA
08298:  RETURN 0
0829A:  MOVF   FE9,W
0829C:  MOVLB  6
0829E:  MOVWF  x26
082A0:  BTFSS  x25.7
082A2:  BRA    82BE
082A4:  DECF   x26,F
082A6:  BSF    x26.5
082A8:  COMF   x22,F
082AA:  COMF   x23,F
082AC:  COMF   x24,F
082AE:  COMF   x25,F
082B0:  INCF   x22,F
082B2:  BTFSC  FD8.2
082B4:  INCF   x23,F
082B6:  BTFSC  FD8.2
082B8:  INCF   x24,F
082BA:  BTFSC  FD8.2
082BC:  INCF   x25,F
082BE:  MOVLW  3B
082C0:  MOVWF  x2D
082C2:  MOVLW  9A
082C4:  MOVWF  x2C
082C6:  MOVLW  CA
082C8:  MOVWF  x2B
082CA:  CLRF   x2A
082CC:  MOVLW  0A
082CE:  MOVWF  x28
082D0:  BSF    FD8.1
082D2:  MOVLW  06
082D4:  MOVWF  FEA
082D6:  MOVLW  22
082D8:  MOVWF  FE9
082DA:  MOVFF  625,63C
082DE:  MOVFF  624,63B
082E2:  MOVFF  623,63A
082E6:  MOVFF  622,639
082EA:  MOVFF  62D,640
082EE:  MOVFF  62C,63F
082F2:  MOVFF  62B,63E
082F6:  MOVFF  62A,63D
082FA:  MOVLB  0
082FC:  CALL   572E
08300:  MOVF   01,W
08302:  MOVF   00,F
08304:  BNZ   832C
08306:  MOVLB  6
08308:  MOVF   x28,W
0830A:  XORLW  01
0830C:  BTFSS  FD8.2
0830E:  BRA    8314
08310:  MOVLB  0
08312:  BRA    832C
08314:  MOVF   x26,W
08316:  BZ    8332
08318:  ANDLW  0F
0831A:  SUBWF  x28,W
0831C:  BZ    8320
0831E:  BC    837C
08320:  BTFSC  x26.7
08322:  BRA    837C
08324:  BTFSC  x26.6
08326:  BRA    8332
08328:  MOVLW  20
0832A:  BRA    836E
0832C:  MOVLW  20
0832E:  MOVLB  6
08330:  ANDWF  x26,F
08332:  BTFSS  x26.5
08334:  BRA    834E
08336:  BCF    x26.5
08338:  MOVFF  00,626
0833C:  MOVLW  2D
0833E:  MOVWF  x39
08340:  MOVLB  0
08342:  CALL   4AEA
08346:  MOVLB  6
08348:  MOVFF  626,00
0834C:  CLRF   x26
0834E:  MOVLW  30
08350:  BTFSS  x26.5
08352:  BRA    836E
08354:  BCF    x26.5
08356:  MOVFF  00,626
0835A:  MOVLW  2D
0835C:  MOVWF  x39
0835E:  MOVLB  0
08360:  CALL   4AEA
08364:  MOVLB  6
08366:  MOVFF  626,00
0836A:  CLRF   x26
0836C:  MOVLW  30
0836E:  ADDWF  00,F
08370:  MOVFF  00,639
08374:  MOVLB  0
08376:  CALL   4AEA
0837A:  MOVLB  6
0837C:  BCF    FD8.1
0837E:  MOVFF  62D,63C
08382:  MOVFF  62C,63B
08386:  MOVFF  62B,63A
0838A:  MOVFF  62A,639
0838E:  CLRF   x40
08390:  CLRF   x3F
08392:  CLRF   x3E
08394:  MOVLW  0A
08396:  MOVWF  x3D
08398:  MOVLB  0
0839A:  CALL   572E
0839E:  MOVFF  03,62D
083A2:  MOVFF  02,62C
083A6:  MOVFF  01,62B
083AA:  MOVFF  00,62A
083AE:  MOVLB  6
083B0:  DECFSZ x28,F
083B2:  BRA    82D0
083B4:  MOVLB  0
083B6:  RETURN 0
*
08F60:  MOVF   FEF,F
08F62:  BZ    8F84
08F64:  MOVFF  FEA,5EF
08F68:  MOVFF  FE9,5EE
08F6C:  MOVFF  FEF,639
08F70:  CALL   4AEA
08F74:  MOVFF  5EF,FEA
08F78:  MOVFF  5EE,FE9
08F7C:  INCF   FE9,F
08F7E:  BTFSC  FD8.2
08F80:  INCF   FEA,F
08F82:  BRA    8F60
08F84:  GOTO   9002 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003D0:  MOVLW  05
003D2:  MOVWF  FEA
003D4:  MOVLW  EE
003D6:  MOVWF  FE9
003D8:  MOVF   FEF,W
003DA:  BZ    03F8
003DC:  MOVLW  14
003DE:  MOVWF  01
003E0:  CLRF   00
003E2:  DECFSZ 00,F
003E4:  BRA    03E2
003E6:  DECFSZ 01,F
003E8:  BRA    03E0
003EA:  MOVLW  BF
003EC:  MOVWF  00
003EE:  DECFSZ 00,F
003F0:  BRA    03EE
003F2:  BRA    03F4
003F4:  DECFSZ FEF,F
003F6:  BRA    03DC
003F8:  RETURN 0
*
00698:  MOVLW  01
0069A:  MOVLB  5
0069C:  SUBWF  xF4,F
0069E:  BNC   06B8
006A0:  MOVLW  05
006A2:  MOVWF  FEA
006A4:  MOVLW  F4
006A6:  MOVWF  FE9
006A8:  MOVF   FEF,W
006AA:  BZ    06B8
006AC:  MOVLW  04
006AE:  MOVWF  00
006B0:  DECFSZ 00,F
006B2:  BRA    06B0
006B4:  DECFSZ FEF,F
006B6:  BRA    06AC
006B8:  MOVLB  0
006BA:  GOTO   0700 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20250812" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
0033A:  MOVLW  CF
0033C:  MOVWF  F87
0033E:  CLRF   F82
....................    output_b(portB_reset);
00340:  MOVLW  C4
00342:  MOVWF  F88
00344:  CLRF   F83
....................    output_c(portC_reset);
00346:  MOVLW  93
00348:  MOVWF  F89
0034A:  CLRF   F84
....................    output_d(portD_reset);
0034C:  MOVLW  1F
0034E:  MOVWF  F8A
00350:  CLRF   F85
....................    output_e(portE_reset);
00352:  BCF    F8B.0
00354:  BCF    F8B.1
00356:  BCF    F8B.2
00358:  BCF    F8B.3
0035A:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
0035C:  MOVLB  F
0035E:  SETF   x0B
....................    port_b_pullups(portB_pullups);
00360:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00362:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00364:  SETF   x20
....................    port_e_pullups(portE_pullups);
00366:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00368:  MOVLW  40
0036A:  MOVWF  x0C
0036C:  CLRF   x14
0036E:  MOVLW  03
00370:  MOVWF  x1C
00372:  MOVLW  0F
00374:  MOVWF  x21
00376:  CLRF   x29
00378:  MOVLB  0
0037A:  GOTO   9406 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
04A72:  MOVFF  62B,FEA
04A76:  MOVLB  6
04A78:  MOVFF  62A,FE9
04A7C:  MOVFF  FEF,62E
04A80:  MOVFF  62D,FEA
04A84:  MOVFF  62C,FE9
04A88:  MOVF   FEF,W
04A8A:  SUBWF  x2E,W
04A8C:  BNZ   4ABC
....................       if (*s1 == '\0')
04A8E:  MOVFF  62B,03
04A92:  MOVFF  62A,FE9
04A96:  MOVFF  03,FEA
04A9A:  MOVF   FEF,F
04A9C:  BNZ   4AA4
....................          return(0);
04A9E:  MOVLW  00
04AA0:  MOVWF  01
04AA2:  BRA    4AE6
04AA4:  MOVFF  62B,03
04AA8:  MOVF   x2A,W
04AAA:  INCF   x2A,F
04AAC:  BTFSC  FD8.2
04AAE:  INCF   x2B,F
04AB0:  INCF   x2C,F
04AB2:  BTFSC  FD8.2
04AB4:  INCF   x2D,F
04AB6:  MOVLB  0
04AB8:  BRA    4A72
04ABA:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
04ABC:  MOVFF  62B,03
04AC0:  MOVFF  62A,FE9
04AC4:  MOVFF  03,FEA
04AC8:  MOVFF  FEF,62E
04ACC:  MOVFF  62D,03
04AD0:  MOVFF  62C,FE9
04AD4:  MOVFF  03,FEA
04AD8:  MOVF   FEF,W
04ADA:  SUBWF  x2E,W
04ADC:  BC    4AE2
04ADE:  MOVLW  FF
04AE0:  BRA    4AE4
04AE2:  MOVLW  01
04AE4:  MOVWF  01
04AE6:  MOVLB  0
04AE8:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
04C02:  MOVFF  651,654
....................    for(su=s;0<n;++su,--n)
04C06:  MOVFF  650,656
04C0A:  MOVFF  64F,655
04C0E:  MOVLB  6
04C10:  MOVF   x53,F
04C12:  BNZ   4C1A
04C14:  MOVF   x52,W
04C16:  SUBLW  00
04C18:  BC    4C42
....................       if(*su==uc)
04C1A:  MOVFF  656,FEA
04C1E:  MOVFF  655,FE9
04C22:  MOVF   x54,W
04C24:  SUBWF  FEF,W
04C26:  BNZ   4C32
....................       return su;
04C28:  MOVFF  655,01
04C2C:  MOVFF  656,02
04C30:  BRA    4C48
04C32:  INCF   x55,F
04C34:  BTFSC  FD8.2
04C36:  INCF   x56,F
04C38:  MOVF   x52,W
04C3A:  BTFSC  FD8.2
04C3C:  DECF   x53,F
04C3E:  DECF   x52,F
04C40:  BRA    4C10
....................    return NULL;
04C42:  MOVLW  00
04C44:  MOVWF  01
04C46:  MOVWF  02
04C48:  MOVLB  0
04C4A:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
04A3A:  MOVFF  62B,62D
04A3E:  MOVFF  62A,62C
04A42:  MOVFF  62D,FEA
04A46:  MOVLB  6
04A48:  MOVFF  62C,FE9
04A4C:  MOVF   FEF,F
04A4E:  BZ    4A5C
04A50:  INCF   x2C,F
04A52:  BTFSC  FD8.2
04A54:  INCF   x2D,F
04A56:  MOVLB  0
04A58:  BRA    4A42
04A5A:  MOVLB  6
....................    return(sc - s);
04A5C:  MOVF   x2A,W
04A5E:  SUBWF  x2C,W
04A60:  MOVWF  00
04A62:  MOVF   x2B,W
04A64:  SUBWFB x2D,W
04A66:  MOVWF  03
04A68:  MOVFF  00,01
04A6C:  MOVWF  02
04A6E:  MOVLB  0
04A70:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
05E60:  MOVLB  6
05E62:  CLRF   x04
05E64:  CLRF   x03
05E66:  CLRF   x02
05E68:  MOVLW  7F
05E6A:  MOVWF  x01
05E6C:  CLRF   x08
05E6E:  CLRF   x07
05E70:  CLRF   x06
05E72:  CLRF   x05
05E74:  BSF    x09.0
05E76:  BCF    x09.1
05E78:  BCF    x09.2
05E7A:  CLRF   x0B
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
05E7C:  MOVLB  5
05E7E:  MOVF   xFD,W
05E80:  IORWF  xFE,W
05E82:  BNZ   5E8E
....................       return 0;
05E84:  CLRF   00
05E86:  CLRF   01
05E88:  CLRF   02
05E8A:  CLRF   03
05E8C:  BRA    60D2
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
05E8E:  MOVLB  6
05E90:  MOVF   x0B,W
05E92:  INCF   x0B,F
05E94:  MOVLB  5
05E96:  ADDWF  xFD,W
05E98:  MOVWF  FE9
05E9A:  MOVLW  00
05E9C:  ADDWFC xFE,W
05E9E:  MOVWF  FEA
05EA0:  MOVFF  FEF,60A
05EA4:  MOVLB  6
05EA6:  MOVF   x0A,F
05EA8:  BTFSC  FD8.2
05EAA:  BRA    6046
....................    {
....................       if (skip && !isspace(c))
05EAC:  BTFSS  x09.0
05EAE:  BRA    5ECE
05EB0:  MOVF   x0A,W
05EB2:  SUBLW  20
05EB4:  BZ    5ECE
....................       {
....................          skip = 0;
05EB6:  BCF    x09.0
....................          if (c == '+')
05EB8:  MOVF   x0A,W
05EBA:  SUBLW  2B
05EBC:  BNZ   5EC4
....................          {
....................             sign = 0;
05EBE:  BCF    x09.1
....................             continue;
05EC0:  BRA    602A
....................          }            
05EC2:  BRA    5ECE
....................          else if (c == '-')
05EC4:  MOVF   x0A,W
05EC6:  SUBLW  2D
05EC8:  BNZ   5ECE
....................          {
....................             sign = 1;
05ECA:  BSF    x09.1
....................             continue;
05ECC:  BRA    602A
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
05ECE:  BTFSC  x09.0
05ED0:  BRA    5EE0
05ED2:  MOVF   x0A,W
05ED4:  SUBLW  2E
05ED6:  BNZ   5EE0
05ED8:  BTFSC  x09.2
05EDA:  BRA    5EE0
....................          point = 1;
05EDC:  BSF    x09.2
05EDE:  BRA    602A
....................       else if (!skip && isdigit(c))
05EE0:  BTFSC  x09.0
05EE2:  BRA    6024
05EE4:  MOVF   x0A,W
05EE6:  SUBLW  2F
05EE8:  BTFSC  FD8.0
05EEA:  BRA    6024
05EEC:  MOVF   x0A,W
05EEE:  SUBLW  39
05EF0:  BTFSS  FD8.0
05EF2:  BRA    6024
....................       {
....................          c -= '0';
05EF4:  MOVLW  30
05EF6:  SUBWF  x0A,F
....................          if (point)
05EF8:  BTFSS  x09.2
05EFA:  BRA    5FAA
....................          {
....................             pow10 = pow10 * 10.0;
05EFC:  MOVFF  604,64E
05F00:  MOVFF  603,64D
05F04:  MOVFF  602,64C
05F08:  MOVFF  601,64B
05F0C:  CLRF   x52
05F0E:  CLRF   x51
05F10:  MOVLW  20
05F12:  MOVWF  x50
05F14:  MOVLW  82
05F16:  MOVWF  x4F
05F18:  MOVLB  0
05F1A:  CALL   0A96
05F1E:  MOVFF  03,604
05F22:  MOVFF  02,603
05F26:  MOVFF  01,602
05F2A:  MOVFF  00,601
....................             result += (float)c / pow10;   
05F2E:  MOVLB  6
05F30:  CLRF   x50
05F32:  MOVFF  60A,64F
05F36:  MOVLB  0
05F38:  CALL   0A60
05F3C:  MOVFF  03,60F
05F40:  MOVFF  02,60E
05F44:  MOVFF  01,60D
05F48:  MOVFF  00,60C
05F4C:  MOVFF  03,647
05F50:  MOVFF  02,646
05F54:  MOVFF  01,645
05F58:  MOVFF  00,644
05F5C:  MOVFF  604,64B
05F60:  MOVFF  603,64A
05F64:  MOVFF  602,649
05F68:  MOVFF  601,648
05F6C:  CALL   14C0
05F70:  BCF    FD8.1
05F72:  MOVFF  608,652
05F76:  MOVFF  607,651
05F7A:  MOVFF  606,650
05F7E:  MOVFF  605,64F
05F82:  MOVFF  03,656
05F86:  MOVFF  02,655
05F8A:  MOVFF  01,654
05F8E:  MOVFF  00,653
05F92:  CALL   0B8C
05F96:  MOVFF  03,608
05F9A:  MOVFF  02,607
05F9E:  MOVFF  01,606
05FA2:  MOVFF  00,605
....................          }
05FA6:  BRA    6020
05FA8:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
05FAA:  CLRF   x4E
05FAC:  CLRF   x4D
05FAE:  MOVLW  20
05FB0:  MOVWF  x4C
05FB2:  MOVLW  82
05FB4:  MOVWF  x4B
05FB6:  MOVFF  608,652
05FBA:  MOVFF  607,651
05FBE:  MOVFF  606,650
05FC2:  MOVFF  605,64F
05FC6:  MOVLB  0
05FC8:  CALL   0A96
05FCC:  MOVFF  03,60F
05FD0:  MOVFF  02,60E
05FD4:  MOVFF  01,60D
05FD8:  MOVFF  00,60C
05FDC:  MOVLB  6
05FDE:  CLRF   x50
05FE0:  MOVFF  60A,64F
05FE4:  MOVLB  0
05FE6:  CALL   0A60
05FEA:  BCF    FD8.1
05FEC:  MOVFF  60F,652
05FF0:  MOVFF  60E,651
05FF4:  MOVFF  60D,650
05FF8:  MOVFF  60C,64F
05FFC:  MOVFF  03,656
06000:  MOVFF  02,655
06004:  MOVFF  01,654
06008:  MOVFF  00,653
0600C:  CALL   0B8C
06010:  MOVFF  03,608
06014:  MOVFF  02,607
06018:  MOVFF  01,606
0601C:  MOVFF  00,605
....................          }
....................       }
06020:  BRA    602C
06022:  MOVLB  6
....................       else if (!skip)
06024:  BTFSC  x09.0
06026:  BRA    602A
....................          break;
06028:  BRA    6046
0602A:  MOVLB  0
0602C:  MOVLB  6
0602E:  MOVF   x0B,W
06030:  INCF   x0B,F
06032:  MOVLB  5
06034:  ADDWF  xFD,W
06036:  MOVWF  FE9
06038:  MOVLW  00
0603A:  ADDWFC xFE,W
0603C:  MOVWF  FEA
0603E:  MOVFF  FEF,60A
06042:  BRA    5EA4
06044:  MOVLB  6
....................    }
.................... 
....................    if (sign)
06046:  BTFSS  x09.1
06048:  BRA    607E
....................       result = -1*result;
0604A:  CLRF   x4E
0604C:  CLRF   x4D
0604E:  MOVLW  80
06050:  MOVWF  x4C
06052:  MOVLW  7F
06054:  MOVWF  x4B
06056:  MOVFF  608,652
0605A:  MOVFF  607,651
0605E:  MOVFF  606,650
06062:  MOVFF  605,64F
06066:  MOVLB  0
06068:  CALL   0A96
0606C:  MOVFF  03,608
06070:  MOVFF  02,607
06074:  MOVFF  01,606
06078:  MOVFF  00,605
0607C:  MOVLB  6
....................       
....................    if(endptr)
0607E:  MOVLB  5
06080:  MOVF   xFF,W
06082:  MOVLB  6
06084:  IORWF  x00,W
06086:  BZ    60C0
....................    {
....................       if (ptr) {
06088:  MOVF   x0B,F
0608A:  BZ    60AA
....................          ptr--;
0608C:  DECF   x0B,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
0608E:  MOVFF  600,FEA
06092:  MOVFF  5FF,FE9
06096:  MOVLB  6
06098:  MOVF   x0B,W
0609A:  MOVLB  5
0609C:  ADDWF  xFD,W
0609E:  MOVWF  FEF
060A0:  MOVLW  00
060A2:  ADDWFC xFE,W
060A4:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
060A6:  BRA    60BE
060A8:  MOVLB  6
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
060AA:  MOVFF  600,FEA
060AE:  MOVLB  5
060B0:  MOVFF  5FF,FE9
060B4:  MOVFF  5FE,FEC
060B8:  MOVF   FED,F
060BA:  MOVFF  5FD,FEF
060BE:  MOVLB  6
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
060C0:  MOVFF  605,00
060C4:  MOVFF  606,01
060C8:  MOVFF  607,02
060CC:  MOVFF  608,03
060D0:  MOVLB  5
060D2:  MOVLB  0
060D4:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
04CA2:  MOVLB  6
04CA4:  CLRF   x28
04CA6:  CLRF   x27
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
04CA8:  MOVLW  30
04CAA:  MOVWF  x2A
04CAC:  MOVLW  31
04CAE:  MOVWF  x2B
04CB0:  MOVLW  32
04CB2:  MOVWF  x2C
04CB4:  MOVLW  33
04CB6:  MOVWF  x2D
04CB8:  MOVLW  34
04CBA:  MOVWF  x2E
04CBC:  MOVLW  35
04CBE:  MOVWF  x2F
04CC0:  MOVLW  36
04CC2:  MOVWF  x30
04CC4:  MOVLW  37
04CC6:  MOVWF  x31
04CC8:  MOVLW  38
04CCA:  MOVWF  x32
04CCC:  MOVLW  39
04CCE:  MOVWF  x33
04CD0:  MOVLW  61
04CD2:  MOVWF  x34
04CD4:  MOVLW  62
04CD6:  MOVWF  x35
04CD8:  MOVLW  63
04CDA:  MOVWF  x36
04CDC:  MOVLW  64
04CDE:  MOVWF  x37
04CE0:  MOVLW  65
04CE2:  MOVWF  x38
04CE4:  MOVLW  66
04CE6:  MOVWF  x39
04CE8:  MOVLW  67
04CEA:  MOVWF  x3A
04CEC:  MOVLW  68
04CEE:  MOVWF  x3B
04CF0:  MOVLW  69
04CF2:  MOVWF  x3C
04CF4:  MOVLW  6A
04CF6:  MOVWF  x3D
04CF8:  MOVLW  6B
04CFA:  MOVWF  x3E
04CFC:  MOVLW  6C
04CFE:  MOVWF  x3F
04D00:  MOVLW  6D
04D02:  MOVWF  x40
04D04:  MOVLW  6E
04D06:  MOVWF  x41
04D08:  MOVLW  6F
04D0A:  MOVWF  x42
04D0C:  MOVLW  70
04D0E:  MOVWF  x43
04D10:  MOVLW  71
04D12:  MOVWF  x44
04D14:  MOVLW  73
04D16:  MOVWF  x45
04D18:  MOVLW  74
04D1A:  MOVWF  x46
04D1C:  MOVLW  75
04D1E:  MOVWF  x47
04D20:  MOVLW  76
04D22:  MOVWF  x48
04D24:  MOVLW  77
04D26:  MOVWF  x49
04D28:  MOVLW  78
04D2A:  MOVWF  x4A
04D2C:  MOVLW  79
04D2E:  MOVWF  x4B
04D30:  MOVLW  7A
04D32:  MOVWF  x4C
04D34:  CLRF   x4D
....................    for(sc=s;isspace(*sc);++sc);
04D36:  MOVFF  61D,622
04D3A:  MOVFF  61C,621
04D3E:  MOVFF  622,FEA
04D42:  MOVFF  621,FE9
04D46:  MOVF   FEF,W
04D48:  SUBLW  20
04D4A:  BNZ   4D54
04D4C:  INCF   x21,F
04D4E:  BTFSC  FD8.2
04D50:  INCF   x22,F
04D52:  BRA    4D3E
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
04D54:  MOVFF  622,03
04D58:  MOVFF  621,FE9
04D5C:  MOVFF  03,FEA
04D60:  MOVF   FEF,W
04D62:  SUBLW  2D
04D64:  BZ    4D74
04D66:  MOVFF  622,FEA
04D6A:  MOVFF  621,FE9
04D6E:  MOVF   FEF,W
04D70:  SUBLW  2B
04D72:  BNZ   4D86
04D74:  MOVFF  622,FEA
04D78:  MOVF   x21,W
04D7A:  INCF   x21,F
04D7C:  BTFSC  FD8.2
04D7E:  INCF   x22,F
04D80:  MOVWF  FE9
04D82:  MOVF   FEF,W
04D84:  BRA    4D88
04D86:  MOVLW  2B
04D88:  MOVWF  x29
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
04D8A:  MOVF   x29,W
04D8C:  SUBLW  2D
04D8E:  BZ    4DA4
04D90:  BTFSC  x20.7
04D92:  BRA    4DA4
04D94:  DECFSZ x20,W
04D96:  BRA    4D9A
04D98:  BRA    4DA4
04D9A:  BTFSC  x20.7
04D9C:  BRA    4DA8
04D9E:  MOVF   x20,W
04DA0:  SUBLW  24
04DA2:  BC    4DA8
....................    goto StrtoulGO;
04DA4:  BRA    4FB0
04DA6:  BRA    4EA0
.................... 
....................    else if (base)
04DA8:  MOVF   x20,F
04DAA:  BZ    4E38
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
04DAC:  MOVF   x20,W
04DAE:  SUBLW  10
04DB0:  BNZ   4DEC
04DB2:  MOVFF  622,FEA
04DB6:  MOVFF  621,FE9
04DBA:  MOVF   FEF,W
04DBC:  SUBLW  30
04DBE:  BNZ   4DEC
04DC0:  MOVLW  01
04DC2:  ADDWF  x21,W
04DC4:  MOVWF  FE9
04DC6:  MOVLW  00
04DC8:  ADDWFC x22,W
04DCA:  MOVWF  FEA
04DCC:  MOVF   FEF,W
04DCE:  SUBLW  78
04DD0:  BZ    4DE4
04DD2:  MOVLW  01
04DD4:  ADDWF  x21,W
04DD6:  MOVWF  FE9
04DD8:  MOVLW  00
04DDA:  ADDWFC x22,W
04DDC:  MOVWF  FEA
04DDE:  MOVF   FEF,W
04DE0:  SUBLW  58
04DE2:  BNZ   4DEC
....................          sc+=2;
04DE4:  MOVLW  02
04DE6:  ADDWF  x21,F
04DE8:  MOVLW  00
04DEA:  ADDWFC x22,F
....................       if(base==8 && *sc =='0')
04DEC:  MOVF   x20,W
04DEE:  SUBLW  08
04DF0:  BNZ   4E08
04DF2:  MOVFF  622,FEA
04DF6:  MOVFF  621,FE9
04DFA:  MOVF   FEF,W
04DFC:  SUBLW  30
04DFE:  BNZ   4E08
....................          sc+=1;
04E00:  MOVLW  01
04E02:  ADDWF  x21,F
04E04:  MOVLW  00
04E06:  ADDWFC x22,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
04E08:  MOVF   x20,W
04E0A:  SUBLW  02
04E0C:  BNZ   4E36
04E0E:  MOVFF  622,FEA
04E12:  MOVFF  621,FE9
04E16:  MOVF   FEF,W
04E18:  SUBLW  30
04E1A:  BNZ   4E36
04E1C:  MOVLW  01
04E1E:  ADDWF  x21,W
04E20:  MOVWF  FE9
04E22:  MOVLW  00
04E24:  ADDWFC x22,W
04E26:  MOVWF  FEA
04E28:  MOVF   FEF,W
04E2A:  SUBLW  62
04E2C:  BNZ   4E36
....................          sc+=2;
04E2E:  MOVLW  02
04E30:  ADDWF  x21,F
04E32:  MOVLW  00
04E34:  ADDWFC x22,F
.................... 
....................    }
04E36:  BRA    4EA0
....................    else if(*sc!='0') // base is 0, find base
04E38:  MOVFF  622,FEA
04E3C:  MOVFF  621,FE9
04E40:  MOVF   FEF,W
04E42:  SUBLW  30
04E44:  BZ    4E4C
....................       base=10;
04E46:  MOVLW  0A
04E48:  MOVWF  x20
04E4A:  BRA    4EA0
....................    else if (sc[1]=='x' || sc[1]=='X')
04E4C:  MOVLW  01
04E4E:  ADDWF  x21,W
04E50:  MOVWF  FE9
04E52:  MOVLW  00
04E54:  ADDWFC x22,W
04E56:  MOVWF  FEA
04E58:  MOVF   FEF,W
04E5A:  SUBLW  78
04E5C:  BZ    4E70
04E5E:  MOVLW  01
04E60:  ADDWF  x21,W
04E62:  MOVWF  FE9
04E64:  MOVLW  00
04E66:  ADDWFC x22,W
04E68:  MOVWF  FEA
04E6A:  MOVF   FEF,W
04E6C:  SUBLW  58
04E6E:  BNZ   4E7E
....................       base =16,sc+=2;
04E70:  MOVLW  10
04E72:  MOVWF  x20
04E74:  MOVLW  02
04E76:  ADDWF  x21,F
04E78:  MOVLW  00
04E7A:  ADDWFC x22,F
04E7C:  BRA    4EA0
....................    else if(sc[1]=='b')
04E7E:  MOVLW  01
04E80:  ADDWF  x21,W
04E82:  MOVWF  FE9
04E84:  MOVLW  00
04E86:  ADDWFC x22,W
04E88:  MOVWF  FEA
04E8A:  MOVF   FEF,W
04E8C:  SUBLW  62
04E8E:  BNZ   4E9C
....................       base=2,sc+=2;
04E90:  MOVLW  02
04E92:  MOVWF  x20
04E94:  ADDWF  x21,F
04E96:  MOVLW  00
04E98:  ADDWFC x22,F
04E9A:  BRA    4EA0
....................    else
....................       base=8;
04E9C:  MOVLW  08
04E9E:  MOVWF  x20
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
04EA0:  MOVFF  622,624
04EA4:  MOVFF  621,623
04EA8:  MOVFF  622,FEA
04EAC:  MOVFF  621,FE9
04EB0:  MOVF   FEF,W
04EB2:  SUBLW  30
04EB4:  BNZ   4EBE
04EB6:  INCF   x21,F
04EB8:  BTFSC  FD8.2
04EBA:  INCF   x22,F
04EBC:  BRA    4EA8
....................    sd=memchr(digits,tolower(*sc),base);
04EBE:  MOVFF  622,03
04EC2:  MOVFF  621,FE9
04EC6:  MOVFF  03,FEA
04ECA:  MOVFF  FEF,64E
04ECE:  MOVF   x4E,W
04ED0:  SUBLW  40
04ED2:  BC    4EE0
04ED4:  MOVF   x4E,W
04ED6:  SUBLW  5A
04ED8:  BNC   4EE0
04EDA:  MOVF   x4E,W
04EDC:  IORLW  20
04EDE:  BRA    4EE2
04EE0:  MOVF   x4E,W
04EE2:  MOVWF  x4E
04EE4:  MOVLW  06
04EE6:  MOVWF  x50
04EE8:  MOVLW  2A
04EEA:  MOVWF  x4F
04EEC:  MOVFF  64E,651
04EF0:  CLRF   x53
04EF2:  MOVFF  620,652
04EF6:  BTFSC  x52.7
04EF8:  DECF   x53,F
04EFA:  MOVLB  0
04EFC:  RCALL  4C02
04EFE:  MOVFF  02,626
04F02:  MOVFF  01,625
....................    for(; sd!=0; )
04F06:  MOVLB  6
04F08:  MOVF   x25,F
04F0A:  BNZ   4F10
04F0C:  MOVF   x26,F
04F0E:  BZ    4FA4
....................    {
....................       x=x*base+(int16)(sd-digits);
04F10:  CLRF   03
04F12:  MOVF   x20,W
04F14:  MOVWF  00
04F16:  BTFSC  FE8.7
04F18:  DECF   03,F
04F1A:  MOVWF  x4E
04F1C:  MOVFF  03,64F
04F20:  MOVFF  628,651
04F24:  MOVFF  627,650
04F28:  MOVFF  03,653
04F2C:  MOVWF  x52
04F2E:  MOVLB  0
04F30:  BRA    4C4C
04F32:  MOVFF  01,64E
04F36:  MOVLW  2A
04F38:  MOVLB  6
04F3A:  SUBWF  x25,W
04F3C:  MOVWF  00
04F3E:  MOVLW  06
04F40:  SUBWFB x26,W
04F42:  MOVWF  03
04F44:  MOVF   00,W
04F46:  ADDWF  01,W
04F48:  MOVWF  01
04F4A:  MOVF   02,W
04F4C:  ADDWFC 03,F
04F4E:  MOVFF  01,627
04F52:  MOVFF  03,628
....................       ++sc;
04F56:  INCF   x21,F
04F58:  BTFSC  FD8.2
04F5A:  INCF   x22,F
....................       sd=memchr(digits,tolower(*sc),base);
04F5C:  MOVFF  622,FEA
04F60:  MOVFF  621,FE9
04F64:  MOVFF  FEF,64E
04F68:  MOVF   x4E,W
04F6A:  SUBLW  40
04F6C:  BC    4F7A
04F6E:  MOVF   x4E,W
04F70:  SUBLW  5A
04F72:  BNC   4F7A
04F74:  MOVF   x4E,W
04F76:  IORLW  20
04F78:  BRA    4F7C
04F7A:  MOVF   x4E,W
04F7C:  MOVWF  x4E
04F7E:  MOVLW  06
04F80:  MOVWF  x50
04F82:  MOVLW  2A
04F84:  MOVWF  x4F
04F86:  MOVFF  64E,651
04F8A:  CLRF   x53
04F8C:  MOVFF  620,652
04F90:  BTFSC  x52.7
04F92:  DECF   x53,F
04F94:  MOVLB  0
04F96:  RCALL  4C02
04F98:  MOVFF  02,626
04F9C:  MOVFF  01,625
04FA0:  BRA    4F06
04FA2:  MOVLB  6
....................    }
....................    if(s1==sc)
04FA4:  MOVF   x21,W
04FA6:  SUBWF  x23,W
04FA8:  BNZ   4FD2
04FAA:  MOVF   x22,W
04FAC:  SUBWF  x24,W
04FAE:  BNZ   4FD2
....................    {
....................    StrtoulGO:
....................       if (endptr)
04FB0:  MOVLB  6
04FB2:  MOVF   x1E,W
04FB4:  IORWF  x1F,W
04FB6:  BZ    4FCA
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
04FB8:  MOVFF  61F,FEA
04FBC:  MOVFF  61E,FE9
04FC0:  MOVFF  61D,FEC
04FC4:  MOVF   FED,F
04FC6:  MOVFF  61C,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
04FCA:  MOVLW  00
04FCC:  MOVWF  01
04FCE:  MOVWF  02
04FD0:  BRA    4FF2
....................    }
....................    if (endptr)
04FD2:  MOVF   x1E,W
04FD4:  IORWF  x1F,W
04FD6:  BZ    4FEA
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
04FD8:  MOVFF  61F,FEA
04FDC:  MOVFF  61E,FE9
04FE0:  MOVFF  622,FEC
04FE4:  MOVF   FED,F
04FE6:  MOVFF  621,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
04FEA:  MOVFF  627,01
04FEE:  MOVFF  628,02
04FF2:  MOVLB  0
04FF4:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0,0,0,0,0,0,0},
....................    {0.01,0,0,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003FA:  MOVLB  5
003FC:  CLRF   xEE
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003FE:  CLRF   xEE
00400:  MOVF   xED,W
00402:  SUBWF  xEE,W
00404:  BC    045C
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00406:  MOVF   xEE,W
00408:  ADDWF  xEB,W
0040A:  MOVWF  xEF
0040C:  MOVLW  00
0040E:  ADDWFC xEC,W
00410:  MOVWF  xF0
00412:  MOVF   xEE,W
00414:  ADDWF  xE9,W
00416:  MOVWF  01
00418:  MOVLW  00
0041A:  ADDWFC xEA,W
0041C:  MOVWF  03
0041E:  MOVF   01,W
00420:  MOVWF  FE9
00422:  MOVFF  03,FEA
00426:  MOVFF  FEF,5F1
0042A:  BSF    F7F.7
0042C:  MOVF   FF2,W
0042E:  MOVWF  00
00430:  BCF    FF2.7
00432:  MOVFF  5F0,F7A
00436:  MOVFF  5EF,F79
0043A:  MOVLW  31
0043C:  MOVWF  F7B
0043E:  MOVFF  5F1,F7C
00442:  MOVLB  F
00444:  MOVLW  55
00446:  MOVWF  F81
00448:  MOVLW  AA
0044A:  MOVWF  F81
0044C:  BSF    F80.4
0044E:  BTFSC  F80.4
00450:  BRA    044E
00452:  MOVF   00,W
00454:  IORWF  FF2,F
00456:  MOVLB  5
00458:  INCF   xEE,F
0045A:  BRA    0400
....................    }
0045C:  MOVLB  0
0045E:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0037E:  MOVLB  5
00380:  CLRF   xEE
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00382:  CLRF   xEE
00384:  MOVF   xED,W
00386:  SUBWF  xEE,W
00388:  BC    03CC
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
0038A:  MOVF   xEE,W
0038C:  ADDWF  xE9,W
0038E:  MOVWF  01
00390:  MOVLW  00
00392:  ADDWFC xEA,W
00394:  MOVWF  03
00396:  MOVF   01,W
00398:  MOVWF  FE9
0039A:  MOVFF  03,FEA
0039E:  MOVF   xEE,W
003A0:  ADDWF  xEB,W
003A2:  MOVWF  xF1
003A4:  MOVLW  00
003A6:  ADDWFC xEC,W
003A8:  MOVWF  xF2
003AA:  BSF    F7F.7
003AC:  MOVFF  FF2,5F3
003B0:  BCF    FF2.7
003B2:  MOVFF  5F2,F7A
003B6:  MOVFF  5F1,F79
003BA:  MOVLW  31
003BC:  MOVWF  F7B
003BE:  BSF    F80.0
003C0:  MOVF   F7C,W
003C2:  BTFSC  xF3.7
003C4:  BSF    FF2.7
003C6:  MOVWF  FEF
003C8:  INCF   xEE,F
003CA:  BRA    0384
....................    }
003CC:  MOVLB  0
003CE:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
00460:  MOVLB  5
00462:  CLRF   xEA
00464:  MOVLW  20
00466:  MOVWF  xE9
00468:  CLRF   xEC
0046A:  CLRF   xEB
0046C:  MOVLW  80
0046E:  MOVWF  xED
00470:  MOVLB  0
00472:  RCALL  03FA
....................    delay_ms(1);
00474:  MOVLW  01
00476:  MOVLB  5
00478:  MOVWF  xEE
0047A:  MOVLB  0
0047C:  RCALL  03D0
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0047E:  MOVLB  5
00480:  CLRF   xEA
00482:  MOVLW  60
00484:  MOVWF  xE9
00486:  CLRF   xEC
00488:  MOVLW  80
0048A:  MOVWF  xEB
0048C:  MOVLW  02
0048E:  MOVWF  xED
00490:  MOVLB  0
00492:  RCALL  03FA
....................    delay_ms(1);
00494:  MOVLW  01
00496:  MOVLB  5
00498:  MOVWF  xEE
0049A:  MOVLB  0
0049C:  RCALL  03D0
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0049E:  MOVLB  5
004A0:  CLRF   xEA
004A2:  MOVLW  61
004A4:  MOVWF  xE9
004A6:  CLRF   xEC
004A8:  MOVLW  90
004AA:  MOVWF  xEB
004AC:  MOVLW  02
004AE:  MOVWF  xED
004B0:  MOVLB  0
004B2:  RCALL  03FA
....................    delay_ms(1);
004B4:  MOVLW  01
004B6:  MOVLB  5
004B8:  MOVWF  xEE
004BA:  MOVLB  0
004BC:  RCALL  03D0
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
004BE:  MOVLB  5
004C0:  CLRF   xEA
004C2:  MOVLW  62
004C4:  MOVWF  xE9
004C6:  CLRF   xEC
004C8:  MOVLW  A0
004CA:  MOVWF  xEB
004CC:  MOVLW  20
004CE:  MOVWF  xED
004D0:  MOVLB  0
004D2:  RCALL  03FA
....................    delay_ms(1);
004D4:  MOVLW  01
004D6:  MOVLB  5
004D8:  MOVWF  xEE
004DA:  MOVLB  0
004DC:  RCALL  03D0
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004DE:  MOVLB  5
004E0:  CLRF   xEA
004E2:  MOVLW  82
004E4:  MOVWF  xE9
004E6:  CLRF   xEC
004E8:  MOVLW  C0
004EA:  MOVWF  xEB
004EC:  MOVLW  30
004EE:  MOVWF  xED
004F0:  MOVLB  0
004F2:  RCALL  03FA
....................    delay_ms(1);
004F4:  MOVLW  01
004F6:  MOVLB  5
004F8:  MOVWF  xEE
004FA:  MOVLB  0
004FC:  RCALL  03D0
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
004FE:  MOVLB  5
00500:  CLRF   xEA
00502:  MOVLW  B2
00504:  MOVWF  xE9
00506:  CLRF   xEC
00508:  MOVLW  F0
0050A:  MOVWF  xEB
0050C:  MOVLW  38
0050E:  MOVWF  xED
00510:  MOVLB  0
00512:  RCALL  03FA
....................    delay_ms(1);
00514:  MOVLW  01
00516:  MOVLB  5
00518:  MOVWF  xEE
0051A:  MOVLB  0
0051C:  RCALL  03D0
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0051E:  MOVLB  5
00520:  CLRF   xEA
00522:  MOVLW  F2
00524:  MOVWF  xE9
00526:  MOVLW  01
00528:  MOVWF  xEC
0052A:  MOVLW  40
0052C:  MOVWF  xEB
0052E:  MOVLW  01
00530:  MOVWF  xED
00532:  MOVLB  0
00534:  RCALL  03FA
....................    delay_ms(1);
00536:  MOVLW  01
00538:  MOVLB  5
0053A:  MOVWF  xEE
0053C:  MOVLB  0
0053E:  RCALL  03D0
00540:  GOTO   0610 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00544:  MOVLB  5
00546:  CLRF   xEA
00548:  MOVLW  20
0054A:  MOVWF  xE9
0054C:  CLRF   xEC
0054E:  CLRF   xEB
00550:  MOVLW  80
00552:  MOVWF  xED
00554:  MOVLB  0
00556:  RCALL  037E
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00558:  MOVLB  5
0055A:  CLRF   xEA
0055C:  MOVLW  60
0055E:  MOVWF  xE9
00560:  CLRF   xEC
00562:  MOVLW  80
00564:  MOVWF  xEB
00566:  MOVLW  02
00568:  MOVWF  xED
0056A:  MOVLB  0
0056C:  RCALL  037E
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0056E:  MOVLB  5
00570:  CLRF   xEA
00572:  MOVLW  61
00574:  MOVWF  xE9
00576:  CLRF   xEC
00578:  MOVLW  90
0057A:  MOVWF  xEB
0057C:  MOVLW  02
0057E:  MOVWF  xED
00580:  MOVLB  0
00582:  RCALL  037E
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00584:  MOVLB  5
00586:  CLRF   xEA
00588:  MOVLW  62
0058A:  MOVWF  xE9
0058C:  CLRF   xEC
0058E:  MOVLW  A0
00590:  MOVWF  xEB
00592:  MOVLW  20
00594:  MOVWF  xED
00596:  MOVLB  0
00598:  RCALL  037E
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
0059A:  MOVLB  5
0059C:  CLRF   xEA
0059E:  MOVLW  82
005A0:  MOVWF  xE9
005A2:  CLRF   xEC
005A4:  MOVLW  C0
005A6:  MOVWF  xEB
005A8:  MOVLW  30
005AA:  MOVWF  xED
005AC:  MOVLB  0
005AE:  RCALL  037E
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005B0:  MOVLB  5
005B2:  CLRF   xEA
005B4:  MOVLW  B2
005B6:  MOVWF  xE9
005B8:  CLRF   xEC
005BA:  MOVLW  F0
005BC:  MOVWF  xEB
005BE:  MOVLW  38
005C0:  MOVWF  xED
005C2:  MOVLB  0
005C4:  RCALL  037E
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005C6:  MOVLB  5
005C8:  CLRF   xEA
005CA:  MOVLW  F2
005CC:  MOVWF  xE9
005CE:  MOVLW  01
005D0:  MOVWF  xEC
005D2:  MOVLW  40
005D4:  MOVWF  xEB
005D6:  MOVLW  01
005D8:  MOVWF  xED
005DA:  MOVLB  0
005DC:  RCALL  037E
005DE:  GOTO   0614 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005E2:  MOVLB  5
005E4:  CLRF   xEA
005E6:  MOVLW  F2
005E8:  MOVWF  xE9
005EA:  MOVLW  01
005EC:  MOVWF  xEC
005EE:  MOVLW  40
005F0:  MOVWF  xEB
005F2:  MOVLW  01
005F4:  MOVWF  xED
005F6:  MOVLB  0
005F8:  RCALL  037E
....................    delay_ms(1);
005FA:  MOVLW  01
005FC:  MOVLB  5
005FE:  MOVWF  xEE
00600:  MOVLB  0
00602:  RCALL  03D0
....................    if (paramsValid != isValid)
00604:  MOVF   xF2,W
00606:  SUBLW  AA
00608:  BZ    0612
....................    {
....................       paramsValid = isValid;
0060A:  MOVLW  AA
0060C:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
0060E:  BRA    0460
....................    }
00610:  BRA    0614
....................    else
....................    {
....................       params_load_from_ee();
00612:  BRA    0544
....................    }
00614:  GOTO   940A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0,0,0,0,0,0,0},
....................    {0.01,0,0,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00618:  RCALL  0136
....................    switch(ch)
0061A:  MOVLB  5
0061C:  MOVF   xF9,W
0061E:  ADDLW  FC
00620:  BC    0654
00622:  ADDLW  04
00624:  MOVLB  0
00626:  GOTO   0660
....................    {
....................       case 0:
....................          output_low(_CS0);
0062A:  MOVLW  1F
0062C:  MOVWF  F8A
0062E:  BCF    F85.5
....................       break; 
00630:  MOVLB  5
00632:  BRA    0654
....................       case 1:
....................          output_low(_CS1);
00634:  MOVLW  1F
00636:  MOVWF  F8A
00638:  BCF    F85.6
....................       break;   
0063A:  MOVLB  5
0063C:  BRA    0654
....................       case 2:
....................          output_low(_CS2);
0063E:  MOVLW  1F
00640:  MOVWF  F8A
00642:  BCF    F85.7
....................       break;
00644:  MOVLB  5
00646:  BRA    0654
....................       case 3:
....................          output_low(_CS3);
00648:  MOVLW  C4
0064A:  MOVWF  F88
0064C:  BCF    F83.0
....................       break;              
0064E:  MOVLB  5
00650:  BRA    0654
00652:  MOVLB  5
....................    }
....................    delay_us(10);
00654:  MOVLW  35
00656:  MOVWF  00
00658:  DECFSZ 00,F
0065A:  BRA    0658
0065C:  MOVLB  0
0065E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   x62,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00682:  MOVFF  5F7,5F9
00686:  RCALL  0618
....................    spi_write2(command);
00688:  MOVLB  E
0068A:  MOVF   x8D,W
0068C:  MOVFF  5F8,E8D
00690:  RRCF   x90,W
00692:  BNC   0690
00694:  MOVLB  0
00696:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  660,662
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  661,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
01382:  MOVFF  5F7,5F9
01386:  CALL   0618
....................    spi_read2(command);
0138A:  MOVLB  E
0138C:  MOVF   x8D,W
0138E:  MOVFF  5F8,E8D
01392:  RRCF   x90,W
01394:  BNC   1392
01396:  MOVLB  0
01398:  GOTO   13AA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
006BE:  MOVLB  5
006C0:  MOVF   xF4,W
006C2:  IORLW  40
006C4:  MOVWF  xF6
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
006C6:  MOVFF  5F3,5F7
006CA:  MOVFF  5F6,5F8
006CE:  MOVLB  0
006D0:  RCALL  0682
....................    spi_write2(data);
006D2:  MOVLB  E
006D4:  MOVF   x8D,W
006D6:  MOVFF  5F5,E8D
006DA:  RRCF   x90,W
006DC:  BNC   06DA
....................    ads_deselect_all();
006DE:  MOVLB  0
006E0:  RCALL  0136
006E2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  65F,660
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  x61
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(20);
001B0:  MOVLW  6A
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
001B8:  NOP   
....................    ads_deselect_all();
001BA:  RCALL  0136
001BC:  GOTO   01F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0139C:  MOVFF  5F2,5F7
013A0:  MOVLW  10
013A2:  MOVLB  5
013A4:  MOVWF  xF8
013A6:  MOVLB  0
013A8:  BRA    1382
....................    data.dBytes[0] = 0;
013AA:  MOVLB  5
013AC:  CLRF   xF3
....................    data.dBytes[3] = spi_read2(0);
013AE:  MOVLB  E
013B0:  MOVF   x8D,W
013B2:  CLRF   x8D
013B4:  RRCF   x90,W
013B6:  BNC   13B4
013B8:  MOVFF  E8D,5F6
....................    data.dBytes[2] = spi_read2(0);
013BC:  MOVF   x8D,W
013BE:  CLRF   x8D
013C0:  RRCF   x90,W
013C2:  BNC   13C0
013C4:  MOVFF  E8D,5F5
....................    data.dBytes[1] = spi_read2(0);
013C8:  MOVF   x8D,W
013CA:  CLRF   x8D
013CC:  RRCF   x90,W
013CE:  BNC   13CC
013D0:  MOVFF  E8D,5F4
....................    
....................    ads_deselect_all();
013D4:  MOVLB  0
013D6:  CALL   0136
....................    return data.dWord;
013DA:  MOVFF  5F3,00
013DE:  MOVFF  5F4,01
013E2:  MOVFF  5F5,02
013E6:  MOVFF  5F6,03
013EA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
006E4:  MOVFF  5EE,5F7
006E8:  MOVLW  06
006EA:  MOVLB  5
006EC:  MOVWF  xF8
006EE:  MOVLB  0
006F0:  RCALL  0682
....................    delay_us(300);                    
006F2:  MOVLW  02
006F4:  MOVLB  5
006F6:  MOVWF  xF3
006F8:  MOVLW  96
006FA:  MOVWF  xF4
006FC:  MOVLB  0
006FE:  BRA    0698
00700:  MOVLB  5
00702:  DECFSZ xF3,F
00704:  BRA    06F8
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00706:  MOVFF  5EE,5F3
0070A:  CLRF   xF4
0070C:  MOVFF  5EF,5F5
00710:  MOVLB  0
00712:  RCALL  06BE
....................    ads_write_reg(ch, reg1, rc1);
00714:  MOVFF  5EE,5F3
00718:  MOVLW  04
0071A:  MOVLB  5
0071C:  MOVWF  xF4
0071E:  MOVFF  5F0,5F5
00722:  MOVLB  0
00724:  RCALL  06BE
....................    ads_write_reg(ch, reg2, rc2);
00726:  MOVFF  5EE,5F3
0072A:  MOVLW  08
0072C:  MOVLB  5
0072E:  MOVWF  xF4
00730:  MOVFF  5F1,5F5
00734:  MOVLB  0
00736:  RCALL  06BE
....................    ads_write_reg(ch, reg3, rc3);  
00738:  MOVFF  5EE,5F3
0073C:  MOVLW  0C
0073E:  MOVLB  5
00740:  MOVWF  xF4
00742:  MOVFF  5F2,5F5
00746:  MOVLB  0
00748:  RCALL  06BE
0074A:  GOTO   0786 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01E76:  MOVLB  6
01E78:  BCF    x4A.0
....................    y = x;
01E7A:  MOVFF  63E,643
01E7E:  MOVFF  63D,642
01E82:  MOVFF  63C,641
01E86:  MOVFF  63B,640
.................... 
....................    if (x < 0)
01E8A:  MOVFF  63E,64E
01E8E:  MOVFF  63D,64D
01E92:  MOVFF  63C,64C
01E96:  MOVFF  63B,64B
01E9A:  CLRF   x52
01E9C:  CLRF   x51
01E9E:  CLRF   x50
01EA0:  CLRF   x4F
01EA2:  MOVLB  0
01EA4:  CALL   1446
01EA8:  BNC   1EB6
....................    {
....................       s = 1;
01EAA:  MOVLB  6
01EAC:  BSF    x4A.0
....................       y = -y;
01EAE:  MOVF   x41,W
01EB0:  XORLW  80
01EB2:  MOVWF  x41
01EB4:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01EB6:  MOVFF  643,64E
01EBA:  MOVFF  642,64D
01EBE:  MOVFF  641,64C
01EC2:  MOVFF  640,64B
01EC6:  MOVLB  6
01EC8:  CLRF   x52
01ECA:  CLRF   x51
01ECC:  CLRF   x50
01ECE:  MOVLW  8E
01ED0:  MOVWF  x4F
01ED2:  MOVLB  0
01ED4:  CALL   1446
01ED8:  BC    1EDC
01EDA:  BNZ   1F0C
....................       res = (float32)(unsigned int16)y;
01EDC:  MOVFF  643,64E
01EE0:  MOVFF  642,64D
01EE4:  MOVFF  641,64C
01EE8:  MOVFF  640,64B
01EEC:  RCALL  1E3A
01EEE:  MOVFF  02,650
01EF2:  MOVFF  01,64F
01EF6:  CALL   0A60
01EFA:  MOVFF  03,647
01EFE:  MOVFF  02,646
01F02:  MOVFF  01,645
01F06:  MOVFF  00,644
01F0A:  BRA    20AE
.................... 
....................  else if (y < 10000000.0)
01F0C:  MOVFF  643,64E
01F10:  MOVFF  642,64D
01F14:  MOVFF  641,64C
01F18:  MOVFF  640,64B
01F1C:  MOVLW  80
01F1E:  MOVLB  6
01F20:  MOVWF  x52
01F22:  MOVLW  96
01F24:  MOVWF  x51
01F26:  MOVLW  18
01F28:  MOVWF  x50
01F2A:  MOVLW  96
01F2C:  MOVWF  x4F
01F2E:  MOVLB  0
01F30:  CALL   1446
01F34:  BTFSS  FD8.0
01F36:  BRA    209E
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01F38:  MOVFF  643,64E
01F3C:  MOVFF  642,64D
01F40:  MOVFF  641,64C
01F44:  MOVFF  640,64B
01F48:  MOVLB  6
01F4A:  CLRF   x52
01F4C:  CLRF   x51
01F4E:  CLRF   x50
01F50:  MOVLW  70
01F52:  MOVWF  x4F
01F54:  MOVLB  0
01F56:  CALL   0A96
01F5A:  MOVFF  03,64E
01F5E:  MOVFF  02,64D
01F62:  MOVFF  01,64C
01F66:  MOVFF  00,64B
01F6A:  RCALL  1E3A
01F6C:  MOVFF  02,649
01F70:  MOVFF  01,648
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01F74:  MOVFF  643,64E
01F78:  MOVFF  642,64D
01F7C:  MOVFF  641,64C
01F80:  MOVFF  640,64B
01F84:  MOVLB  6
01F86:  CLRF   x52
01F88:  CLRF   x51
01F8A:  CLRF   x50
01F8C:  MOVLW  70
01F8E:  MOVWF  x4F
01F90:  MOVLB  0
01F92:  CALL   0A96
01F96:  MOVFF  03,64E
01F9A:  MOVFF  02,64D
01F9E:  MOVFF  01,64C
01FA2:  MOVFF  00,64B
01FA6:  MOVFF  649,650
01FAA:  MOVFF  648,64F
01FAE:  CALL   0A60
01FB2:  BSF    FD8.1
01FB4:  MOVFF  64E,652
01FB8:  MOVFF  64D,651
01FBC:  MOVFF  64C,650
01FC0:  MOVFF  64B,64F
01FC4:  MOVFF  03,656
01FC8:  MOVFF  02,655
01FCC:  MOVFF  01,654
01FD0:  MOVFF  00,653
01FD4:  CALL   0B8C
01FD8:  MOVLB  6
01FDA:  CLRF   x4E
01FDC:  CLRF   x4D
01FDE:  CLRF   x4C
01FE0:  MOVLW  8E
01FE2:  MOVWF  x4B
01FE4:  MOVFF  03,652
01FE8:  MOVFF  02,651
01FEC:  MOVFF  01,650
01FF0:  MOVFF  00,64F
01FF4:  MOVLB  0
01FF6:  CALL   0A96
01FFA:  MOVFF  03,643
01FFE:  MOVFF  02,642
02002:  MOVFF  01,641
02006:  MOVFF  00,640
....................       res = 32768.0*(float32)l;
0200A:  MOVFF  649,650
0200E:  MOVFF  648,64F
02012:  CALL   0A60
02016:  MOVLB  6
02018:  CLRF   x4E
0201A:  CLRF   x4D
0201C:  CLRF   x4C
0201E:  MOVLW  8E
02020:  MOVWF  x4B
02022:  MOVFF  03,652
02026:  MOVFF  02,651
0202A:  MOVFF  01,650
0202E:  MOVFF  00,64F
02032:  MOVLB  0
02034:  CALL   0A96
02038:  MOVFF  03,647
0203C:  MOVFF  02,646
02040:  MOVFF  01,645
02044:  MOVFF  00,644
....................       res += (float32)(unsigned int16)y;
02048:  MOVFF  643,64E
0204C:  MOVFF  642,64D
02050:  MOVFF  641,64C
02054:  MOVFF  640,64B
02058:  RCALL  1E3A
0205A:  MOVFF  02,650
0205E:  MOVFF  01,64F
02062:  CALL   0A60
02066:  BCF    FD8.1
02068:  MOVFF  647,652
0206C:  MOVFF  646,651
02070:  MOVFF  645,650
02074:  MOVFF  644,64F
02078:  MOVFF  03,656
0207C:  MOVFF  02,655
02080:  MOVFF  01,654
02084:  MOVFF  00,653
02088:  CALL   0B8C
0208C:  MOVFF  03,647
02090:  MOVFF  02,646
02094:  MOVFF  01,645
02098:  MOVFF  00,644
....................    }
0209C:  BRA    20AE
.................... 
....................  else
....................   res = y;
0209E:  MOVFF  643,647
020A2:  MOVFF  642,646
020A6:  MOVFF  641,645
020AA:  MOVFF  640,644
.................... 
....................  y = y - (float32)(unsigned int16)y;
020AE:  MOVFF  643,64E
020B2:  MOVFF  642,64D
020B6:  MOVFF  641,64C
020BA:  MOVFF  640,64B
020BE:  RCALL  1E3A
020C0:  MOVFF  02,650
020C4:  MOVFF  01,64F
020C8:  CALL   0A60
020CC:  BSF    FD8.1
020CE:  MOVFF  643,652
020D2:  MOVFF  642,651
020D6:  MOVFF  641,650
020DA:  MOVFF  640,64F
020DE:  MOVFF  03,656
020E2:  MOVFF  02,655
020E6:  MOVFF  01,654
020EA:  MOVFF  00,653
020EE:  CALL   0B8C
020F2:  MOVFF  03,643
020F6:  MOVFF  02,642
020FA:  MOVFF  01,641
020FE:  MOVFF  00,640
.................... 
....................  if (s)
02102:  MOVLB  6
02104:  BTFSS  x4A.0
02106:  BRA    210E
....................   res = -res;
02108:  MOVF   x45,W
0210A:  XORLW  80
0210C:  MOVWF  x45
.................... 
....................  if (y != 0)
0210E:  MOVFF  643,64E
02112:  MOVFF  642,64D
02116:  MOVFF  641,64C
0211A:  MOVFF  640,64B
0211E:  CLRF   x52
02120:  CLRF   x51
02122:  CLRF   x50
02124:  CLRF   x4F
02126:  MOVLB  0
02128:  CALL   1446
0212C:  BZ    21A6
....................  {
....................   if (s == 1 && n == 0)
0212E:  MOVLB  6
02130:  BTFSS  x4A.0
02132:  BRA    216C
02134:  MOVF   x3F,F
02136:  BNZ   216C
....................    res -= 1.0;
02138:  BSF    FD8.1
0213A:  MOVFF  647,652
0213E:  MOVFF  646,651
02142:  MOVFF  645,650
02146:  MOVFF  644,64F
0214A:  CLRF   x56
0214C:  CLRF   x55
0214E:  CLRF   x54
02150:  MOVLW  7F
02152:  MOVWF  x53
02154:  MOVLB  0
02156:  CALL   0B8C
0215A:  MOVFF  03,647
0215E:  MOVFF  02,646
02162:  MOVFF  01,645
02166:  MOVFF  00,644
0216A:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
0216C:  BTFSC  x4A.0
0216E:  BRA    21A8
02170:  DECFSZ x3F,W
02172:  BRA    21A8
....................    res += 1.0;
02174:  BCF    FD8.1
02176:  MOVFF  647,652
0217A:  MOVFF  646,651
0217E:  MOVFF  645,650
02182:  MOVFF  644,64F
02186:  CLRF   x56
02188:  CLRF   x55
0218A:  CLRF   x54
0218C:  MOVLW  7F
0218E:  MOVWF  x53
02190:  MOVLB  0
02192:  CALL   0B8C
02196:  MOVFF  03,647
0219A:  MOVFF  02,646
0219E:  MOVFF  01,645
021A2:  MOVFF  00,644
021A6:  MOVLB  6
....................  }
....................  if (x == 0)
021A8:  MOVFF  63E,64E
021AC:  MOVFF  63D,64D
021B0:  MOVFF  63C,64C
021B4:  MOVFF  63B,64B
021B8:  CLRF   x52
021BA:  CLRF   x51
021BC:  CLRF   x50
021BE:  CLRF   x4F
021C0:  MOVLB  0
021C2:  CALL   1446
021C6:  BNZ   21D4
....................     res = 0;
021C8:  MOVLB  6
021CA:  CLRF   x47
021CC:  CLRF   x46
021CE:  CLRF   x45
021D0:  CLRF   x44
021D2:  MOVLB  0
.................... 
....................  return (res);
021D4:  MOVFF  644,00
021D8:  MOVFF  645,01
021DC:  MOVFF  646,02
021E0:  MOVFF  647,03
021E4:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02204:  MOVFF  63A,63E
02208:  MOVFF  639,63D
0220C:  MOVFF  638,63C
02210:  MOVFF  637,63B
02214:  MOVLB  6
02216:  CLRF   x3F
02218:  MOVLB  0
0221A:  RCALL  1E76
0221C:  GOTO   2328 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
021E6:  MOVFF  63A,63E
021EA:  MOVFF  639,63D
021EE:  MOVFF  638,63C
021F2:  MOVFF  637,63B
021F6:  MOVLW  01
021F8:  MOVLB  6
021FA:  MOVWF  x3F
021FC:  MOVLB  0
021FE:  RCALL  1E76
02200:  GOTO   22E0 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02220:  MOVFF  62E,64E
02224:  MOVFF  62D,64D
02228:  MOVFF  62C,64C
0222C:  MOVFF  62B,64B
02230:  MOVLB  6
02232:  CLRF   x52
02234:  CLRF   x51
02236:  CLRF   x50
02238:  CLRF   x4F
0223A:  MOVLB  0
0223C:  CALL   1446
02240:  BTFSC  FD8.2
02242:  BRA    2384
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02244:  MOVFF  62A,647
02248:  MOVFF  629,646
0224C:  MOVFF  628,645
02250:  MOVFF  627,644
02254:  MOVFF  62E,64B
02258:  MOVFF  62D,64A
0225C:  MOVFF  62C,649
02260:  MOVFF  62B,648
02264:  CALL   14C0
02268:  MOVFF  03,636
0226C:  MOVFF  02,635
02270:  MOVFF  01,634
02274:  MOVFF  00,633
02278:  MOVFF  03,64E
0227C:  MOVFF  02,64D
02280:  MOVFF  01,64C
02284:  MOVFF  00,64B
02288:  MOVLB  6
0228A:  CLRF   x52
0228C:  CLRF   x51
0228E:  CLRF   x50
02290:  CLRF   x4F
02292:  MOVLB  0
02294:  CALL   1446
02298:  BNC   22E2
0229A:  MOVFF  62A,647
0229E:  MOVFF  629,646
022A2:  MOVFF  628,645
022A6:  MOVFF  627,644
022AA:  MOVFF  62E,64B
022AE:  MOVFF  62D,64A
022B2:  MOVFF  62C,649
022B6:  MOVFF  62B,648
022BA:  CALL   14C0
022BE:  MOVFF  03,636
022C2:  MOVFF  02,635
022C6:  MOVFF  01,634
022CA:  MOVFF  00,633
022CE:  MOVFF  03,63A
022D2:  MOVFF  02,639
022D6:  MOVFF  01,638
022DA:  MOVFF  00,637
022DE:  BRA    21E6
022E0:  BRA    2328
022E2:  MOVFF  62A,647
022E6:  MOVFF  629,646
022EA:  MOVFF  628,645
022EE:  MOVFF  627,644
022F2:  MOVFF  62E,64B
022F6:  MOVFF  62D,64A
022FA:  MOVFF  62C,649
022FE:  MOVFF  62B,648
02302:  CALL   14C0
02306:  MOVFF  03,636
0230A:  MOVFF  02,635
0230E:  MOVFF  01,634
02312:  MOVFF  00,633
02316:  MOVFF  03,63A
0231A:  MOVFF  02,639
0231E:  MOVFF  01,638
02322:  MOVFF  00,637
02326:  BRA    2204
02328:  MOVFF  03,632
0232C:  MOVFF  02,631
02330:  MOVFF  01,630
02334:  MOVFF  00,62F
....................       return(x-(i*y));
02338:  MOVFF  632,64E
0233C:  MOVFF  631,64D
02340:  MOVFF  630,64C
02344:  MOVFF  62F,64B
02348:  MOVFF  62E,652
0234C:  MOVFF  62D,651
02350:  MOVFF  62C,650
02354:  MOVFF  62B,64F
02358:  CALL   0A96
0235C:  BSF    FD8.1
0235E:  MOVFF  62A,652
02362:  MOVFF  629,651
02366:  MOVFF  628,650
0236A:  MOVFF  627,64F
0236E:  MOVFF  03,656
02372:  MOVFF  02,655
02376:  MOVFF  01,654
0237A:  MOVFF  00,653
0237E:  CALL   0B8C
02382:  BRA    2384
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02384:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
0271A:  MOVFF  62E,64E
0271E:  MOVFF  62D,64D
02722:  MOVFF  62C,64C
02726:  MOVFF  62B,64B
0272A:  MOVLW  3B
0272C:  MOVLB  6
0272E:  MOVWF  x52
02730:  MOVLW  AA
02732:  MOVWF  x51
02734:  MOVLW  38
02736:  MOVWF  x50
02738:  MOVLW  7F
0273A:  MOVWF  x4F
0273C:  MOVLB  0
0273E:  CALL   0A96
02742:  MOVFF  03,64E
02746:  MOVFF  02,64D
0274A:  MOVFF  01,64C
0274E:  MOVFF  00,64B
02752:  CALL   1E3A
02756:  MOVFF  01,63B
....................    s = 0;
0275A:  MOVLB  6
0275C:  BCF    x3C.0
....................    y = x;
0275E:  MOVFF  62E,632
02762:  MOVFF  62D,631
02766:  MOVFF  62C,630
0276A:  MOVFF  62B,62F
.................... 
....................    if (x < 0)
0276E:  MOVFF  62E,64E
02772:  MOVFF  62D,64D
02776:  MOVFF  62C,64C
0277A:  MOVFF  62B,64B
0277E:  CLRF   x52
02780:  CLRF   x51
02782:  CLRF   x50
02784:  CLRF   x4F
02786:  MOVLB  0
02788:  CALL   1446
0278C:  BNC   279C
....................    {
....................       s = 1;
0278E:  MOVLB  6
02790:  BSF    x3C.0
....................       n = -n;
02792:  NEGF   x3B
....................       y = -y;
02794:  MOVF   x30,W
02796:  XORLW  80
02798:  MOVWF  x30
0279A:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0279C:  MOVLB  6
0279E:  CLRF   x36
027A0:  CLRF   x35
027A2:  CLRF   x34
027A4:  CLRF   x33
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
027A6:  MOVLW  06
027A8:  MOVWF  x3E
027AA:  MOVLW  33
027AC:  MOVFF  63E,FEA
027B0:  MOVWF  FE9
027B2:  MOVLW  7F
027B4:  ADDWF  x3B,W
027B6:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
027B8:  MOVFF  632,64E
027BC:  MOVFF  631,64D
027C0:  MOVFF  630,64C
027C4:  MOVFF  62F,64B
027C8:  MOVLW  3B
027CA:  MOVWF  x52
027CC:  MOVLW  AA
027CE:  MOVWF  x51
027D0:  MOVLW  38
027D2:  MOVWF  x50
027D4:  MOVLW  7F
027D6:  MOVWF  x4F
027D8:  MOVLB  0
027DA:  CALL   0A96
027DE:  MOVFF  03,640
027E2:  MOVFF  02,63F
027E6:  MOVFF  01,63E
027EA:  MOVFF  00,63D
027EE:  MOVLB  6
027F0:  CLRF   x42
027F2:  MOVFF  63B,641
027F6:  BTFSC  x41.7
027F8:  DECF   x42,F
027FA:  MOVLB  0
027FC:  CALL   1DEA
02800:  BSF    FD8.1
02802:  MOVFF  640,652
02806:  MOVFF  63F,651
0280A:  MOVFF  63E,650
0280E:  MOVFF  63D,64F
02812:  MOVFF  03,656
02816:  MOVFF  02,655
0281A:  MOVFF  01,654
0281E:  MOVFF  00,653
02822:  CALL   0B8C
02826:  MOVFF  03,632
0282A:  MOVFF  02,631
0282E:  MOVFF  01,630
02832:  MOVFF  00,62F
.................... 
....................    r = pe[0]*y + pe[1];
02836:  MOVLW  7C
02838:  MOVLB  6
0283A:  MOVWF  x4E
0283C:  MOVLW  88
0283E:  MOVWF  x4D
02840:  MOVLW  59
02842:  MOVWF  x4C
02844:  MOVLW  72
02846:  MOVWF  x4B
02848:  MOVFF  632,652
0284C:  MOVFF  631,651
02850:  MOVFF  630,650
02854:  MOVFF  62F,64F
02858:  MOVLB  0
0285A:  CALL   0A96
0285E:  MOVFF  03,640
02862:  MOVFF  02,63F
02866:  MOVFF  01,63E
0286A:  MOVFF  00,63D
0286E:  BCF    FD8.1
02870:  MOVFF  03,652
02874:  MOVFF  02,651
02878:  MOVFF  01,650
0287C:  MOVFF  00,64F
02880:  MOVLW  E0
02882:  MOVLB  6
02884:  MOVWF  x56
02886:  MOVLW  97
02888:  MOVWF  x55
0288A:  MOVLW  26
0288C:  MOVWF  x54
0288E:  MOVLW  75
02890:  MOVWF  x53
02892:  MOVLB  0
02894:  CALL   0B8C
02898:  MOVFF  03,63A
0289C:  MOVFF  02,639
028A0:  MOVFF  01,638
028A4:  MOVFF  00,637
....................    r = r*y + pe[2];
028A8:  MOVFF  63A,64E
028AC:  MOVFF  639,64D
028B0:  MOVFF  638,64C
028B4:  MOVFF  637,64B
028B8:  MOVFF  632,652
028BC:  MOVFF  631,651
028C0:  MOVFF  630,650
028C4:  MOVFF  62F,64F
028C8:  CALL   0A96
028CC:  MOVFF  03,640
028D0:  MOVFF  02,63F
028D4:  MOVFF  01,63E
028D8:  MOVFF  00,63D
028DC:  BCF    FD8.1
028DE:  MOVFF  03,652
028E2:  MOVFF  02,651
028E6:  MOVFF  01,650
028EA:  MOVFF  00,64F
028EE:  MOVLW  C4
028F0:  MOVLB  6
028F2:  MOVWF  x56
028F4:  MOVLW  1D
028F6:  MOVWF  x55
028F8:  MOVLW  1E
028FA:  MOVWF  x54
028FC:  MOVLW  78
028FE:  MOVWF  x53
02900:  MOVLB  0
02902:  CALL   0B8C
02906:  MOVFF  03,63A
0290A:  MOVFF  02,639
0290E:  MOVFF  01,638
02912:  MOVFF  00,637
....................    r = r*y + pe[3];
02916:  MOVFF  63A,64E
0291A:  MOVFF  639,64D
0291E:  MOVFF  638,64C
02922:  MOVFF  637,64B
02926:  MOVFF  632,652
0292A:  MOVFF  631,651
0292E:  MOVFF  630,650
02932:  MOVFF  62F,64F
02936:  CALL   0A96
0293A:  MOVFF  03,640
0293E:  MOVFF  02,63F
02942:  MOVFF  01,63E
02946:  MOVFF  00,63D
0294A:  BCF    FD8.1
0294C:  MOVFF  03,652
02950:  MOVFF  02,651
02954:  MOVFF  01,650
02958:  MOVFF  00,64F
0295C:  MOVLW  5E
0295E:  MOVLB  6
02960:  MOVWF  x56
02962:  MOVLW  50
02964:  MOVWF  x55
02966:  MOVLW  63
02968:  MOVWF  x54
0296A:  MOVLW  7A
0296C:  MOVWF  x53
0296E:  MOVLB  0
02970:  CALL   0B8C
02974:  MOVFF  03,63A
02978:  MOVFF  02,639
0297C:  MOVFF  01,638
02980:  MOVFF  00,637
....................    r = r*y + pe[4];
02984:  MOVFF  63A,64E
02988:  MOVFF  639,64D
0298C:  MOVFF  638,64C
02990:  MOVFF  637,64B
02994:  MOVFF  632,652
02998:  MOVFF  631,651
0299C:  MOVFF  630,650
029A0:  MOVFF  62F,64F
029A4:  CALL   0A96
029A8:  MOVFF  03,640
029AC:  MOVFF  02,63F
029B0:  MOVFF  01,63E
029B4:  MOVFF  00,63D
029B8:  BCF    FD8.1
029BA:  MOVFF  03,652
029BE:  MOVFF  02,651
029C2:  MOVFF  01,650
029C6:  MOVFF  00,64F
029CA:  MOVLW  1A
029CC:  MOVLB  6
029CE:  MOVWF  x56
029D0:  MOVLW  FE
029D2:  MOVWF  x55
029D4:  MOVLW  75
029D6:  MOVWF  x54
029D8:  MOVLW  7C
029DA:  MOVWF  x53
029DC:  MOVLB  0
029DE:  CALL   0B8C
029E2:  MOVFF  03,63A
029E6:  MOVFF  02,639
029EA:  MOVFF  01,638
029EE:  MOVFF  00,637
....................    r = r*y + pe[5];
029F2:  MOVFF  63A,64E
029F6:  MOVFF  639,64D
029FA:  MOVFF  638,64C
029FE:  MOVFF  637,64B
02A02:  MOVFF  632,652
02A06:  MOVFF  631,651
02A0A:  MOVFF  630,650
02A0E:  MOVFF  62F,64F
02A12:  CALL   0A96
02A16:  MOVFF  03,640
02A1A:  MOVFF  02,63F
02A1E:  MOVFF  01,63E
02A22:  MOVFF  00,63D
02A26:  BCF    FD8.1
02A28:  MOVFF  03,652
02A2C:  MOVFF  02,651
02A30:  MOVFF  01,650
02A34:  MOVFF  00,64F
02A38:  MOVLW  18
02A3A:  MOVLB  6
02A3C:  MOVWF  x56
02A3E:  MOVLW  72
02A40:  MOVWF  x55
02A42:  MOVLW  31
02A44:  MOVWF  x54
02A46:  MOVLW  7E
02A48:  MOVWF  x53
02A4A:  MOVLB  0
02A4C:  CALL   0B8C
02A50:  MOVFF  03,63A
02A54:  MOVFF  02,639
02A58:  MOVFF  01,638
02A5C:  MOVFF  00,637
.................... 
....................    res = res*(1.0 + y*r);
02A60:  MOVFF  632,64E
02A64:  MOVFF  631,64D
02A68:  MOVFF  630,64C
02A6C:  MOVFF  62F,64B
02A70:  MOVFF  63A,652
02A74:  MOVFF  639,651
02A78:  MOVFF  638,650
02A7C:  MOVFF  637,64F
02A80:  CALL   0A96
02A84:  BCF    FD8.1
02A86:  MOVLB  6
02A88:  CLRF   x52
02A8A:  CLRF   x51
02A8C:  CLRF   x50
02A8E:  MOVLW  7F
02A90:  MOVWF  x4F
02A92:  MOVFF  03,656
02A96:  MOVFF  02,655
02A9A:  MOVFF  01,654
02A9E:  MOVFF  00,653
02AA2:  MOVLB  0
02AA4:  CALL   0B8C
02AA8:  MOVFF  636,64E
02AAC:  MOVFF  635,64D
02AB0:  MOVFF  634,64C
02AB4:  MOVFF  633,64B
02AB8:  MOVFF  03,652
02ABC:  MOVFF  02,651
02AC0:  MOVFF  01,650
02AC4:  MOVFF  00,64F
02AC8:  CALL   0A96
02ACC:  MOVFF  03,636
02AD0:  MOVFF  02,635
02AD4:  MOVFF  01,634
02AD8:  MOVFF  00,633
.................... 
....................    if (s)
02ADC:  MOVLB  6
02ADE:  BTFSS  x3C.0
02AE0:  BRA    2B14
....................       res = 1.0/res;
02AE2:  CLRF   x47
02AE4:  CLRF   x46
02AE6:  CLRF   x45
02AE8:  MOVLW  7F
02AEA:  MOVWF  x44
02AEC:  MOVFF  636,64B
02AF0:  MOVFF  635,64A
02AF4:  MOVFF  634,649
02AF8:  MOVFF  633,648
02AFC:  MOVLB  0
02AFE:  CALL   14C0
02B02:  MOVFF  03,636
02B06:  MOVFF  02,635
02B0A:  MOVFF  01,634
02B0E:  MOVFF  00,633
02B12:  MOVLB  6
....................    return(res);
02B14:  MOVFF  633,00
02B18:  MOVFF  634,01
02B1C:  MOVFF  635,02
02B20:  MOVFF  636,03
02B24:  MOVLB  0
02B26:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02386:  MOVFF  62E,632
0238A:  MOVFF  62D,631
0238E:  MOVFF  62C,630
02392:  MOVFF  62B,62F
.................... 
....................    if (y != 1.0)
02396:  MOVFF  632,64E
0239A:  MOVFF  631,64D
0239E:  MOVFF  630,64C
023A2:  MOVFF  62F,64B
023A6:  MOVLB  6
023A8:  CLRF   x52
023AA:  CLRF   x51
023AC:  CLRF   x50
023AE:  MOVLW  7F
023B0:  MOVWF  x4F
023B2:  MOVLB  0
023B4:  CALL   1446
023B8:  BTFSC  FD8.2
023BA:  BRA    26FC
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
023BC:  MOVLW  06
023BE:  MOVLB  6
023C0:  MOVWF  x41
023C2:  MOVLW  2F
023C4:  MOVFF  641,FEA
023C8:  MOVWF  FE9
023CA:  MOVLW  7E
023CC:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
023CE:  BSF    FD8.1
023D0:  MOVFF  632,652
023D4:  MOVFF  631,651
023D8:  MOVFF  630,650
023DC:  MOVFF  62F,64F
023E0:  CLRF   x56
023E2:  CLRF   x55
023E4:  CLRF   x54
023E6:  MOVLW  7F
023E8:  MOVWF  x53
023EA:  MOVLB  0
023EC:  CALL   0B8C
023F0:  MOVFF  03,643
023F4:  MOVFF  02,642
023F8:  MOVFF  01,641
023FC:  MOVFF  00,640
02400:  BCF    FD8.1
02402:  MOVFF  632,652
02406:  MOVFF  631,651
0240A:  MOVFF  630,650
0240E:  MOVFF  62F,64F
02412:  MOVLB  6
02414:  CLRF   x56
02416:  CLRF   x55
02418:  CLRF   x54
0241A:  MOVLW  7F
0241C:  MOVWF  x53
0241E:  MOVLB  0
02420:  CALL   0B8C
02424:  MOVFF  643,647
02428:  MOVFF  642,646
0242C:  MOVFF  641,645
02430:  MOVFF  640,644
02434:  MOVFF  03,64B
02438:  MOVFF  02,64A
0243C:  MOVFF  01,649
02440:  MOVFF  00,648
02444:  CALL   14C0
02448:  MOVFF  03,632
0244C:  MOVFF  02,631
02450:  MOVFF  01,630
02454:  MOVFF  00,62F
.................... 
....................       y2=y*y;
02458:  MOVFF  632,64E
0245C:  MOVFF  631,64D
02460:  MOVFF  630,64C
02464:  MOVFF  62F,64B
02468:  MOVFF  632,652
0246C:  MOVFF  631,651
02470:  MOVFF  630,650
02474:  MOVFF  62F,64F
02478:  CALL   0A96
0247C:  MOVFF  03,63E
02480:  MOVFF  02,63D
02484:  MOVFF  01,63C
02488:  MOVFF  00,63B
.................... 
....................       res = pl[0]*y2 + pl[1];
0248C:  MOVLW  99
0248E:  MOVLB  6
02490:  MOVWF  x4E
02492:  MOVLW  47
02494:  MOVWF  x4D
02496:  MOVLW  8A
02498:  MOVWF  x4C
0249A:  MOVLW  7F
0249C:  MOVWF  x4B
0249E:  MOVFF  63E,652
024A2:  MOVFF  63D,651
024A6:  MOVFF  63C,650
024AA:  MOVFF  63B,64F
024AE:  MOVLB  0
024B0:  CALL   0A96
024B4:  MOVFF  03,643
024B8:  MOVFF  02,642
024BC:  MOVFF  01,641
024C0:  MOVFF  00,640
024C4:  BCF    FD8.1
024C6:  MOVFF  03,652
024CA:  MOVFF  02,651
024CE:  MOVFF  01,650
024D2:  MOVFF  00,64F
024D6:  MOVLB  6
024D8:  CLRF   x56
024DA:  CLRF   x55
024DC:  CLRF   x54
024DE:  MOVLW  80
024E0:  MOVWF  x53
024E2:  MOVLB  0
024E4:  CALL   0B8C
024E8:  MOVFF  03,636
024EC:  MOVFF  02,635
024F0:  MOVFF  01,634
024F4:  MOVFF  00,633
.................... 
....................       r = ql[0]*y2 + ql[1];
024F8:  MOVLW  4C
024FA:  MOVLB  6
024FC:  MOVWF  x4E
024FE:  MOVLW  F3
02500:  MOVWF  x4D
02502:  MOVLW  3A
02504:  MOVWF  x4C
02506:  MOVLW  7B
02508:  MOVWF  x4B
0250A:  MOVFF  63E,652
0250E:  MOVFF  63D,651
02512:  MOVFF  63C,650
02516:  MOVFF  63B,64F
0251A:  MOVLB  0
0251C:  CALL   0A96
02520:  MOVFF  03,643
02524:  MOVFF  02,642
02528:  MOVFF  01,641
0252C:  MOVFF  00,640
02530:  BCF    FD8.1
02532:  MOVFF  03,652
02536:  MOVFF  02,651
0253A:  MOVFF  01,650
0253E:  MOVFF  00,64F
02542:  MOVLW  2B
02544:  MOVLB  6
02546:  MOVWF  x56
02548:  MOVLW  9D
0254A:  MOVWF  x55
0254C:  MOVLW  DF
0254E:  MOVWF  x54
02550:  MOVLW  7E
02552:  MOVWF  x53
02554:  MOVLB  0
02556:  CALL   0B8C
0255A:  MOVFF  03,63A
0255E:  MOVFF  02,639
02562:  MOVFF  01,638
02566:  MOVFF  00,637
....................       r = r*y2 + 1.0;
0256A:  MOVFF  63A,64E
0256E:  MOVFF  639,64D
02572:  MOVFF  638,64C
02576:  MOVFF  637,64B
0257A:  MOVFF  63E,652
0257E:  MOVFF  63D,651
02582:  MOVFF  63C,650
02586:  MOVFF  63B,64F
0258A:  CALL   0A96
0258E:  MOVFF  03,643
02592:  MOVFF  02,642
02596:  MOVFF  01,641
0259A:  MOVFF  00,640
0259E:  BCF    FD8.1
025A0:  MOVFF  03,652
025A4:  MOVFF  02,651
025A8:  MOVFF  01,650
025AC:  MOVFF  00,64F
025B0:  MOVLB  6
025B2:  CLRF   x56
025B4:  CLRF   x55
025B6:  CLRF   x54
025B8:  MOVLW  7F
025BA:  MOVWF  x53
025BC:  MOVLB  0
025BE:  CALL   0B8C
025C2:  MOVFF  03,63A
025C6:  MOVFF  02,639
025CA:  MOVFF  01,638
025CE:  MOVFF  00,637
.................... 
....................       res = y*res/r;
025D2:  MOVFF  632,64E
025D6:  MOVFF  631,64D
025DA:  MOVFF  630,64C
025DE:  MOVFF  62F,64B
025E2:  MOVFF  636,652
025E6:  MOVFF  635,651
025EA:  MOVFF  634,650
025EE:  MOVFF  633,64F
025F2:  CALL   0A96
025F6:  MOVFF  03,643
025FA:  MOVFF  02,642
025FE:  MOVFF  01,641
02602:  MOVFF  00,640
02606:  MOVFF  03,647
0260A:  MOVFF  02,646
0260E:  MOVFF  01,645
02612:  MOVFF  00,644
02616:  MOVFF  63A,64B
0261A:  MOVFF  639,64A
0261E:  MOVFF  638,649
02622:  MOVFF  637,648
02626:  CALL   14C0
0262A:  MOVFF  03,636
0262E:  MOVFF  02,635
02632:  MOVFF  01,634
02636:  MOVFF  00,633
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0263A:  MOVLW  06
0263C:  MOVLB  6
0263E:  MOVWF  x41
02640:  MOVLW  2B
02642:  MOVFF  641,FEA
02646:  MOVWF  FE9
02648:  MOVLW  7E
0264A:  SUBWF  FEF,W
0264C:  MOVWF  x3F
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
0264E:  BTFSS  x3F.7
02650:  BRA    267C
....................          r = -(float32)-n;
02652:  MOVLW  00
02654:  BSF    FD8.0
02656:  SUBFWB x3F,W
02658:  CLRF   x42
0265A:  MOVWF  x41
0265C:  BTFSC  x41.7
0265E:  DECF   x42,F
02660:  MOVLB  0
02662:  CALL   1DEA
02666:  MOVFF  00,637
0266A:  MOVF   01,W
0266C:  XORLW  80
0266E:  MOVLB  6
02670:  MOVWF  x38
02672:  MOVFF  02,639
02676:  MOVFF  03,63A
0267A:  BRA    269E
....................       else
....................          r = (float32)n;
0267C:  CLRF   x42
0267E:  MOVFF  63F,641
02682:  BTFSC  x41.7
02684:  DECF   x42,F
02686:  MOVLB  0
02688:  CALL   1DEA
0268C:  MOVFF  03,63A
02690:  MOVFF  02,639
02694:  MOVFF  01,638
02698:  MOVFF  00,637
0269C:  MOVLB  6
.................... 
....................       res += r*LN2;
0269E:  MOVFF  63A,64E
026A2:  MOVFF  639,64D
026A6:  MOVFF  638,64C
026AA:  MOVFF  637,64B
026AE:  MOVLW  18
026B0:  MOVWF  x52
026B2:  MOVLW  72
026B4:  MOVWF  x51
026B6:  MOVLW  31
026B8:  MOVWF  x50
026BA:  MOVLW  7E
026BC:  MOVWF  x4F
026BE:  MOVLB  0
026C0:  CALL   0A96
026C4:  BCF    FD8.1
026C6:  MOVFF  636,652
026CA:  MOVFF  635,651
026CE:  MOVFF  634,650
026D2:  MOVFF  633,64F
026D6:  MOVFF  03,656
026DA:  MOVFF  02,655
026DE:  MOVFF  01,654
026E2:  MOVFF  00,653
026E6:  CALL   0B8C
026EA:  MOVFF  03,636
026EE:  MOVFF  02,635
026F2:  MOVFF  01,634
026F6:  MOVFF  00,633
....................    }
026FA:  BRA    2708
.................... 
....................    else
....................       res = 0.0;
026FC:  MOVLB  6
026FE:  CLRF   x36
02700:  CLRF   x35
02702:  CLRF   x34
02704:  CLRF   x33
02706:  MOVLB  0
.................... 
....................    return(res);
02708:  MOVFF  633,00
0270C:  MOVFF  634,01
02710:  MOVFF  635,02
02714:  MOVFF  636,03
02718:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02B28:  MOVFF  622,64E
02B2C:  MOVFF  621,64D
02B30:  MOVFF  620,64C
02B34:  MOVFF  61F,64B
02B38:  MOVLB  6
02B3A:  CLRF   x52
02B3C:  CLRF   x51
02B3E:  CLRF   x50
02B40:  CLRF   x4F
02B42:  MOVLB  0
02B44:  CALL   1446
02B48:  BTFSS  FD8.0
02B4A:  BRA    2CE6
02B4C:  MOVFF  626,62A
02B50:  MOVFF  625,629
02B54:  MOVFF  624,628
02B58:  MOVFF  623,627
02B5C:  MOVLB  6
02B5E:  CLRF   x2E
02B60:  CLRF   x2D
02B62:  CLRF   x2C
02B64:  MOVLW  7F
02B66:  MOVWF  x2B
02B68:  MOVLB  0
02B6A:  CALL   2220
02B6E:  MOVFF  03,62A
02B72:  MOVFF  02,629
02B76:  MOVFF  01,628
02B7A:  MOVFF  00,627
02B7E:  MOVFF  03,64E
02B82:  MOVFF  02,64D
02B86:  MOVFF  01,64C
02B8A:  MOVFF  00,64B
02B8E:  MOVLB  6
02B90:  CLRF   x52
02B92:  CLRF   x51
02B94:  CLRF   x50
02B96:  CLRF   x4F
02B98:  MOVLB  0
02B9A:  CALL   1446
02B9E:  BTFSS  FD8.2
02BA0:  BRA    2CE6
....................       if(fmod(y, 2) == 0) {
02BA2:  MOVFF  626,62A
02BA6:  MOVFF  625,629
02BAA:  MOVFF  624,628
02BAE:  MOVFF  623,627
02BB2:  MOVLB  6
02BB4:  CLRF   x2E
02BB6:  CLRF   x2D
02BB8:  CLRF   x2C
02BBA:  MOVLW  80
02BBC:  MOVWF  x2B
02BBE:  MOVLB  0
02BC0:  CALL   2220
02BC4:  MOVFF  03,62A
02BC8:  MOVFF  02,629
02BCC:  MOVFF  01,628
02BD0:  MOVFF  00,627
02BD4:  MOVFF  03,64E
02BD8:  MOVFF  02,64D
02BDC:  MOVFF  01,64C
02BE0:  MOVFF  00,64B
02BE4:  MOVLB  6
02BE6:  CLRF   x52
02BE8:  CLRF   x51
02BEA:  CLRF   x50
02BEC:  CLRF   x4F
02BEE:  MOVLB  0
02BF0:  CALL   1446
02BF4:  BNZ   2C6C
....................          return (exp(log(-x) * y));
02BF6:  MOVLB  6
02BF8:  MOVF   x20,W
02BFA:  XORLW  80
02BFC:  MOVWF  x28
02BFE:  MOVFF  622,62E
02C02:  MOVFF  621,62D
02C06:  MOVWF  x2C
02C08:  MOVFF  61F,62B
02C0C:  MOVLB  0
02C0E:  CALL   2386
02C12:  MOVFF  03,62A
02C16:  MOVFF  02,629
02C1A:  MOVFF  01,628
02C1E:  MOVFF  00,627
02C22:  MOVFF  03,64E
02C26:  MOVFF  02,64D
02C2A:  MOVFF  01,64C
02C2E:  MOVFF  00,64B
02C32:  MOVFF  626,652
02C36:  MOVFF  625,651
02C3A:  MOVFF  624,650
02C3E:  MOVFF  623,64F
02C42:  CALL   0A96
02C46:  MOVFF  03,62A
02C4A:  MOVFF  02,629
02C4E:  MOVFF  01,628
02C52:  MOVFF  00,627
02C56:  MOVFF  03,62E
02C5A:  MOVFF  02,62D
02C5E:  MOVFF  01,62C
02C62:  MOVFF  00,62B
02C66:  RCALL  271A
02C68:  BRA    2E24
....................       } else {
02C6A:  BRA    2CE4
....................          return (-exp(log(-x) * y));
02C6C:  MOVLB  6
02C6E:  MOVF   x20,W
02C70:  XORLW  80
02C72:  MOVWF  x28
02C74:  MOVFF  622,62E
02C78:  MOVFF  621,62D
02C7C:  MOVWF  x2C
02C7E:  MOVFF  61F,62B
02C82:  MOVLB  0
02C84:  CALL   2386
02C88:  MOVFF  03,62A
02C8C:  MOVFF  02,629
02C90:  MOVFF  01,628
02C94:  MOVFF  00,627
02C98:  MOVFF  03,64E
02C9C:  MOVFF  02,64D
02CA0:  MOVFF  01,64C
02CA4:  MOVFF  00,64B
02CA8:  MOVFF  626,652
02CAC:  MOVFF  625,651
02CB0:  MOVFF  624,650
02CB4:  MOVFF  623,64F
02CB8:  CALL   0A96
02CBC:  MOVFF  03,62A
02CC0:  MOVFF  02,629
02CC4:  MOVFF  01,628
02CC8:  MOVFF  00,627
02CCC:  MOVFF  03,62E
02CD0:  MOVFF  02,62D
02CD4:  MOVFF  01,62C
02CD8:  MOVFF  00,62B
02CDC:  RCALL  271A
02CDE:  MOVLW  80
02CE0:  XORWF  01,F
02CE2:  BRA    2E24
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02CE4:  BRA    2E24
02CE6:  MOVFF  622,64E
02CEA:  MOVFF  621,64D
02CEE:  MOVFF  620,64C
02CF2:  MOVFF  61F,64B
02CF6:  MOVLB  6
02CF8:  CLRF   x52
02CFA:  CLRF   x51
02CFC:  CLRF   x50
02CFE:  CLRF   x4F
02D00:  MOVLB  0
02D02:  CALL   1446
02D06:  BNC   2D68
02D08:  MOVFF  626,62A
02D0C:  MOVFF  625,629
02D10:  MOVFF  624,628
02D14:  MOVFF  623,627
02D18:  MOVLB  6
02D1A:  CLRF   x2E
02D1C:  CLRF   x2D
02D1E:  CLRF   x2C
02D20:  MOVLW  7F
02D22:  MOVWF  x2B
02D24:  MOVLB  0
02D26:  CALL   2220
02D2A:  MOVFF  03,62A
02D2E:  MOVFF  02,629
02D32:  MOVFF  01,628
02D36:  MOVFF  00,627
02D3A:  MOVFF  03,64E
02D3E:  MOVFF  02,64D
02D42:  MOVFF  01,64C
02D46:  MOVFF  00,64B
02D4A:  MOVLB  6
02D4C:  CLRF   x52
02D4E:  CLRF   x51
02D50:  CLRF   x50
02D52:  CLRF   x4F
02D54:  MOVLB  0
02D56:  CALL   1446
02D5A:  BZ    2D68
....................       return 0;
02D5C:  CLRF   00
02D5E:  CLRF   01
02D60:  CLRF   02
02D62:  CLRF   03
02D64:  BRA    2E24
....................    } else {
02D66:  BRA    2E24
....................       if(x != 0 || 0 >= y) {
02D68:  MOVFF  622,64E
02D6C:  MOVFF  621,64D
02D70:  MOVFF  620,64C
02D74:  MOVFF  61F,64B
02D78:  MOVLB  6
02D7A:  CLRF   x52
02D7C:  CLRF   x51
02D7E:  CLRF   x50
02D80:  CLRF   x4F
02D82:  MOVLB  0
02D84:  CALL   1446
02D88:  BNZ   2DAE
02D8A:  MOVFF  626,64E
02D8E:  MOVFF  625,64D
02D92:  MOVFF  624,64C
02D96:  MOVFF  623,64B
02D9A:  MOVLB  6
02D9C:  CLRF   x52
02D9E:  CLRF   x51
02DA0:  CLRF   x50
02DA2:  CLRF   x4F
02DA4:  MOVLB  0
02DA6:  CALL   1446
02DAA:  BC    2DAE
02DAC:  BNZ   2E1C
....................          return (exp(log(x) * y));
02DAE:  MOVFF  622,62E
02DB2:  MOVFF  621,62D
02DB6:  MOVFF  620,62C
02DBA:  MOVFF  61F,62B
02DBE:  CALL   2386
02DC2:  MOVFF  03,62A
02DC6:  MOVFF  02,629
02DCA:  MOVFF  01,628
02DCE:  MOVFF  00,627
02DD2:  MOVFF  03,64E
02DD6:  MOVFF  02,64D
02DDA:  MOVFF  01,64C
02DDE:  MOVFF  00,64B
02DE2:  MOVFF  626,652
02DE6:  MOVFF  625,651
02DEA:  MOVFF  624,650
02DEE:  MOVFF  623,64F
02DF2:  CALL   0A96
02DF6:  MOVFF  03,62A
02DFA:  MOVFF  02,629
02DFE:  MOVFF  01,628
02E02:  MOVFF  00,627
02E06:  MOVFF  03,62E
02E0A:  MOVFF  02,62D
02E0E:  MOVFF  01,62C
02E12:  MOVFF  00,62B
02E16:  RCALL  271A
02E18:  BRA    2E24
....................       } else return 0;
02E1A:  BRA    2E24
02E1C:  CLRF   00
02E1E:  CLRF   01
02E20:  CLRF   02
02E22:  CLRF   03
....................    }
02E24:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
0161E:  MOVLB  6
01620:  BCF    x3D.0
....................    flag = 0;
01622:  BCF    x3D.1
....................    y = x;
01624:  MOVFF  630,634
01628:  MOVFF  62F,633
0162C:  MOVFF  62E,632
01630:  MOVFF  62D,631
.................... 
....................    if (x < 0)
01634:  MOVFF  630,64E
01638:  MOVFF  62F,64D
0163C:  MOVFF  62E,64C
01640:  MOVFF  62D,64B
01644:  CLRF   x52
01646:  CLRF   x51
01648:  CLRF   x50
0164A:  CLRF   x4F
0164C:  MOVLB  0
0164E:  RCALL  1446
01650:  BNC   165E
....................    {
....................       s = 1;
01652:  MOVLB  6
01654:  BSF    x3D.0
....................       y = -y;
01656:  MOVF   x32,W
01658:  XORLW  80
0165A:  MOVWF  x32
0165C:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
0165E:  MOVLB  6
01660:  CLRF   x4E
01662:  CLRF   x4D
01664:  CLRF   x4C
01666:  MOVLW  7F
01668:  MOVWF  x4B
0166A:  MOVFF  634,652
0166E:  MOVFF  633,651
01672:  MOVFF  632,650
01676:  MOVFF  631,64F
0167A:  MOVLB  0
0167C:  RCALL  1446
0167E:  BNC   16B6
....................    {
....................       y = 1.0/y;
01680:  MOVLB  6
01682:  CLRF   x47
01684:  CLRF   x46
01686:  CLRF   x45
01688:  MOVLW  7F
0168A:  MOVWF  x44
0168C:  MOVFF  634,64B
01690:  MOVFF  633,64A
01694:  MOVFF  632,649
01698:  MOVFF  631,648
0169C:  MOVLB  0
0169E:  RCALL  14C0
016A0:  MOVFF  03,634
016A4:  MOVFF  02,633
016A8:  MOVFF  01,632
016AC:  MOVFF  00,631
....................       flag = 1;
016B0:  MOVLB  6
016B2:  BSF    x3D.1
016B4:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
016B6:  MOVLW  0A
016B8:  MOVLB  6
016BA:  MOVWF  x4E
016BC:  MOVLW  89
016BE:  MOVWF  x4D
016C0:  MOVLW  34
016C2:  MOVWF  x4C
016C4:  MOVLW  7C
016C6:  MOVWF  x4B
016C8:  MOVFF  634,652
016CC:  MOVFF  633,651
016D0:  MOVFF  632,650
016D4:  MOVFF  631,64F
016D8:  MOVLB  0
016DA:  CALL   0A96
016DE:  MOVFF  03,641
016E2:  MOVFF  02,640
016E6:  MOVFF  01,63F
016EA:  MOVFF  00,63E
016EE:  MOVFF  03,64E
016F2:  MOVFF  02,64D
016F6:  MOVFF  01,64C
016FA:  MOVFF  00,64B
016FE:  MOVFF  634,652
01702:  MOVFF  633,651
01706:  MOVFF  632,650
0170A:  MOVFF  631,64F
0170E:  CALL   0A96
01712:  MOVFF  03,641
01716:  MOVFF  02,640
0171A:  MOVFF  01,63F
0171E:  MOVFF  00,63E
01722:  BCF    FD8.1
01724:  MOVFF  03,652
01728:  MOVFF  02,651
0172C:  MOVFF  01,650
01730:  MOVFF  00,64F
01734:  MOVLW  7C
01736:  MOVLB  6
01738:  MOVWF  x56
0173A:  MOVLW  79
0173C:  MOVWF  x55
0173E:  MOVLW  35
01740:  MOVWF  x54
01742:  MOVLW  81
01744:  MOVWF  x53
01746:  MOVLB  0
01748:  CALL   0B8C
0174C:  MOVFF  03,638
01750:  MOVFF  02,637
01754:  MOVFF  01,636
01758:  MOVFF  00,635
....................    res = res*y*y + pat[2];
0175C:  MOVFF  638,64E
01760:  MOVFF  637,64D
01764:  MOVFF  636,64C
01768:  MOVFF  635,64B
0176C:  MOVFF  634,652
01770:  MOVFF  633,651
01774:  MOVFF  632,650
01778:  MOVFF  631,64F
0177C:  CALL   0A96
01780:  MOVFF  03,641
01784:  MOVFF  02,640
01788:  MOVFF  01,63F
0178C:  MOVFF  00,63E
01790:  MOVFF  03,64E
01794:  MOVFF  02,64D
01798:  MOVFF  01,64C
0179C:  MOVFF  00,64B
017A0:  MOVFF  634,652
017A4:  MOVFF  633,651
017A8:  MOVFF  632,650
017AC:  MOVFF  631,64F
017B0:  CALL   0A96
017B4:  MOVFF  03,641
017B8:  MOVFF  02,640
017BC:  MOVFF  01,63F
017C0:  MOVFF  00,63E
017C4:  BCF    FD8.1
017C6:  MOVFF  03,652
017CA:  MOVFF  02,651
017CE:  MOVFF  01,650
017D2:  MOVFF  00,64F
017D6:  MOVLW  3F
017D8:  MOVLB  6
017DA:  MOVWF  x56
017DC:  MOVLW  02
017DE:  MOVWF  x55
017E0:  MOVLW  33
017E2:  MOVWF  x54
017E4:  MOVLW  83
017E6:  MOVWF  x53
017E8:  MOVLB  0
017EA:  CALL   0B8C
017EE:  MOVFF  03,638
017F2:  MOVFF  02,637
017F6:  MOVFF  01,636
017FA:  MOVFF  00,635
....................    res = res*y*y + pat[3];
017FE:  MOVFF  638,64E
01802:  MOVFF  637,64D
01806:  MOVFF  636,64C
0180A:  MOVFF  635,64B
0180E:  MOVFF  634,652
01812:  MOVFF  633,651
01816:  MOVFF  632,650
0181A:  MOVFF  631,64F
0181E:  CALL   0A96
01822:  MOVFF  03,641
01826:  MOVFF  02,640
0182A:  MOVFF  01,63F
0182E:  MOVFF  00,63E
01832:  MOVFF  03,64E
01836:  MOVFF  02,64D
0183A:  MOVFF  01,64C
0183E:  MOVFF  00,64B
01842:  MOVFF  634,652
01846:  MOVFF  633,651
0184A:  MOVFF  632,650
0184E:  MOVFF  631,64F
01852:  CALL   0A96
01856:  MOVFF  03,641
0185A:  MOVFF  02,640
0185E:  MOVFF  01,63F
01862:  MOVFF  00,63E
01866:  BCF    FD8.1
01868:  MOVFF  03,652
0186C:  MOVFF  02,651
01870:  MOVFF  01,650
01874:  MOVFF  00,64F
01878:  MOVLW  33
0187A:  MOVLB  6
0187C:  MOVWF  x56
0187E:  MOVLW  8C
01880:  MOVWF  x55
01882:  MOVLW  1E
01884:  MOVWF  x54
01886:  MOVLW  83
01888:  MOVWF  x53
0188A:  MOVLB  0
0188C:  CALL   0B8C
01890:  MOVFF  03,638
01894:  MOVFF  02,637
01898:  MOVFF  01,636
0189C:  MOVFF  00,635
.................... 
....................    r = qat[0]*y*y + qat[1];
018A0:  MOVLB  6
018A2:  CLRF   x4E
018A4:  CLRF   x4D
018A6:  CLRF   x4C
018A8:  MOVLW  7F
018AA:  MOVWF  x4B
018AC:  MOVFF  634,652
018B0:  MOVFF  633,651
018B4:  MOVFF  632,650
018B8:  MOVFF  631,64F
018BC:  MOVLB  0
018BE:  CALL   0A96
018C2:  MOVFF  03,641
018C6:  MOVFF  02,640
018CA:  MOVFF  01,63F
018CE:  MOVFF  00,63E
018D2:  MOVFF  03,64E
018D6:  MOVFF  02,64D
018DA:  MOVFF  01,64C
018DE:  MOVFF  00,64B
018E2:  MOVFF  634,652
018E6:  MOVFF  633,651
018EA:  MOVFF  632,650
018EE:  MOVFF  631,64F
018F2:  CALL   0A96
018F6:  MOVFF  03,641
018FA:  MOVFF  02,640
018FE:  MOVFF  01,63F
01902:  MOVFF  00,63E
01906:  BCF    FD8.1
01908:  MOVFF  03,652
0190C:  MOVFF  02,651
01910:  MOVFF  01,650
01914:  MOVFF  00,64F
01918:  MOVLW  1B
0191A:  MOVLB  6
0191C:  MOVWF  x56
0191E:  MOVLW  E4
01920:  MOVWF  x55
01922:  MOVLW  35
01924:  MOVWF  x54
01926:  MOVLW  82
01928:  MOVWF  x53
0192A:  MOVLB  0
0192C:  CALL   0B8C
01930:  MOVFF  03,63C
01934:  MOVFF  02,63B
01938:  MOVFF  01,63A
0193C:  MOVFF  00,639
....................    r = r*y*y + qat[2];
01940:  MOVFF  63C,64E
01944:  MOVFF  63B,64D
01948:  MOVFF  63A,64C
0194C:  MOVFF  639,64B
01950:  MOVFF  634,652
01954:  MOVFF  633,651
01958:  MOVFF  632,650
0195C:  MOVFF  631,64F
01960:  CALL   0A96
01964:  MOVFF  03,641
01968:  MOVFF  02,640
0196C:  MOVFF  01,63F
01970:  MOVFF  00,63E
01974:  MOVFF  03,64E
01978:  MOVFF  02,64D
0197C:  MOVFF  01,64C
01980:  MOVFF  00,64B
01984:  MOVFF  634,652
01988:  MOVFF  633,651
0198C:  MOVFF  632,650
01990:  MOVFF  631,64F
01994:  CALL   0A96
01998:  MOVFF  03,641
0199C:  MOVFF  02,640
019A0:  MOVFF  01,63F
019A4:  MOVFF  00,63E
019A8:  BCF    FD8.1
019AA:  MOVFF  03,652
019AE:  MOVFF  02,651
019B2:  MOVFF  01,650
019B6:  MOVFF  00,64F
019BA:  MOVLW  A4
019BC:  MOVLB  6
019BE:  MOVWF  x56
019C0:  MOVLW  DB
019C2:  MOVWF  x55
019C4:  MOVLW  67
019C6:  MOVWF  x54
019C8:  MOVLW  83
019CA:  MOVWF  x53
019CC:  MOVLB  0
019CE:  CALL   0B8C
019D2:  MOVFF  03,63C
019D6:  MOVFF  02,63B
019DA:  MOVFF  01,63A
019DE:  MOVFF  00,639
....................    r = r*y*y + qat[3];
019E2:  MOVFF  63C,64E
019E6:  MOVFF  63B,64D
019EA:  MOVFF  63A,64C
019EE:  MOVFF  639,64B
019F2:  MOVFF  634,652
019F6:  MOVFF  633,651
019FA:  MOVFF  632,650
019FE:  MOVFF  631,64F
01A02:  CALL   0A96
01A06:  MOVFF  03,641
01A0A:  MOVFF  02,640
01A0E:  MOVFF  01,63F
01A12:  MOVFF  00,63E
01A16:  MOVFF  03,64E
01A1A:  MOVFF  02,64D
01A1E:  MOVFF  01,64C
01A22:  MOVFF  00,64B
01A26:  MOVFF  634,652
01A2A:  MOVFF  633,651
01A2E:  MOVFF  632,650
01A32:  MOVFF  631,64F
01A36:  CALL   0A96
01A3A:  MOVFF  03,641
01A3E:  MOVFF  02,640
01A42:  MOVFF  01,63F
01A46:  MOVFF  00,63E
01A4A:  BCF    FD8.1
01A4C:  MOVFF  03,652
01A50:  MOVFF  02,651
01A54:  MOVFF  01,650
01A58:  MOVFF  00,64F
01A5C:  MOVLW  33
01A5E:  MOVLB  6
01A60:  MOVWF  x56
01A62:  MOVLW  8C
01A64:  MOVWF  x55
01A66:  MOVLW  1E
01A68:  MOVWF  x54
01A6A:  MOVLW  83
01A6C:  MOVWF  x53
01A6E:  MOVLB  0
01A70:  CALL   0B8C
01A74:  MOVFF  03,63C
01A78:  MOVFF  02,63B
01A7C:  MOVFF  01,63A
01A80:  MOVFF  00,639
.................... 
....................    res = y*res/r;
01A84:  MOVFF  634,64E
01A88:  MOVFF  633,64D
01A8C:  MOVFF  632,64C
01A90:  MOVFF  631,64B
01A94:  MOVFF  638,652
01A98:  MOVFF  637,651
01A9C:  MOVFF  636,650
01AA0:  MOVFF  635,64F
01AA4:  CALL   0A96
01AA8:  MOVFF  03,641
01AAC:  MOVFF  02,640
01AB0:  MOVFF  01,63F
01AB4:  MOVFF  00,63E
01AB8:  MOVFF  03,647
01ABC:  MOVFF  02,646
01AC0:  MOVFF  01,645
01AC4:  MOVFF  00,644
01AC8:  MOVFF  63C,64B
01ACC:  MOVFF  63B,64A
01AD0:  MOVFF  63A,649
01AD4:  MOVFF  639,648
01AD8:  RCALL  14C0
01ADA:  MOVFF  03,638
01ADE:  MOVFF  02,637
01AE2:  MOVFF  01,636
01AE6:  MOVFF  00,635
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
01AEA:  MOVLB  6
01AEC:  BTFSS  x3D.1
01AEE:  BRA    1B2A
....................       res = PI_DIV_BY_TWO - res;
01AF0:  BSF    FD8.1
01AF2:  MOVLW  DB
01AF4:  MOVWF  x52
01AF6:  MOVLW  0F
01AF8:  MOVWF  x51
01AFA:  MOVLW  49
01AFC:  MOVWF  x50
01AFE:  MOVLW  7F
01B00:  MOVWF  x4F
01B02:  MOVFF  638,656
01B06:  MOVFF  637,655
01B0A:  MOVFF  636,654
01B0E:  MOVFF  635,653
01B12:  MOVLB  0
01B14:  CALL   0B8C
01B18:  MOVFF  03,638
01B1C:  MOVFF  02,637
01B20:  MOVFF  01,636
01B24:  MOVFF  00,635
01B28:  MOVLB  6
....................    if (s)
01B2A:  BTFSS  x3D.0
01B2C:  BRA    1B34
....................       res = -res;
01B2E:  MOVF   x36,W
01B30:  XORLW  80
01B32:  MOVWF  x36
.................... 
....................    return(res);
01B34:  MOVFF  635,00
01B38:  MOVFF  636,01
01B3C:  MOVFF  637,02
01B40:  MOVFF  638,03
01B44:  MOVLB  0
01B46:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01B48:  MOVLB  6
01B4A:  BCF    x2B.0
....................    quad=0; //quadrant
01B4C:  CLRF   x2C
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01B4E:  MOVFF  622,64E
01B52:  MOVFF  621,64D
01B56:  MOVFF  620,64C
01B5A:  MOVFF  61F,64B
01B5E:  CLRF   x52
01B60:  CLRF   x51
01B62:  CLRF   x50
01B64:  CLRF   x4F
01B66:  MOVLB  0
01B68:  RCALL  1446
01B6A:  BC    1B6E
01B6C:  BNZ   1B98
01B6E:  MOVFF  626,64E
01B72:  MOVFF  625,64D
01B76:  MOVFF  624,64C
01B7A:  MOVFF  623,64B
01B7E:  MOVLB  6
01B80:  CLRF   x52
01B82:  CLRF   x51
01B84:  CLRF   x50
01B86:  CLRF   x4F
01B88:  MOVLB  0
01B8A:  RCALL  1446
01B8C:  BC    1B90
01B8E:  BNZ   1B94
01B90:  MOVLW  03
01B92:  BRA    1B96
01B94:  MOVLW  04
01B96:  BRA    1BBE
01B98:  MOVFF  626,64E
01B9C:  MOVFF  625,64D
01BA0:  MOVFF  624,64C
01BA4:  MOVFF  623,64B
01BA8:  MOVLB  6
01BAA:  CLRF   x52
01BAC:  CLRF   x51
01BAE:  CLRF   x50
01BB0:  CLRF   x4F
01BB2:  MOVLB  0
01BB4:  RCALL  1446
01BB6:  BNC   1BBC
01BB8:  MOVLW  02
01BBA:  BRA    1BBE
01BBC:  MOVLW  01
01BBE:  MOVLB  6
01BC0:  MOVWF  x2C
....................    if(y<0.0)
01BC2:  MOVFF  622,64E
01BC6:  MOVFF  621,64D
01BCA:  MOVFF  620,64C
01BCE:  MOVFF  61F,64B
01BD2:  CLRF   x52
01BD4:  CLRF   x51
01BD6:  CLRF   x50
01BD8:  CLRF   x4F
01BDA:  MOVLB  0
01BDC:  RCALL  1446
01BDE:  BNC   1BEC
....................    {
....................       sign=1;
01BE0:  MOVLB  6
01BE2:  BSF    x2B.0
....................       y=-y;
01BE4:  MOVF   x20,W
01BE6:  XORLW  80
01BE8:  MOVWF  x20
01BEA:  MOVLB  0
....................    }
....................    if(x<0.0)
01BEC:  MOVFF  626,64E
01BF0:  MOVFF  625,64D
01BF4:  MOVFF  624,64C
01BF8:  MOVFF  623,64B
01BFC:  MOVLB  6
01BFE:  CLRF   x52
01C00:  CLRF   x51
01C02:  CLRF   x50
01C04:  CLRF   x4F
01C06:  MOVLB  0
01C08:  RCALL  1446
01C0A:  BNC   1C16
....................    {
....................       x=-x;
01C0C:  MOVLB  6
01C0E:  MOVF   x24,W
01C10:  XORLW  80
01C12:  MOVWF  x24
01C14:  MOVLB  0
....................    }
....................    if (x==0.0)
01C16:  MOVFF  626,64E
01C1A:  MOVFF  625,64D
01C1E:  MOVFF  624,64C
01C22:  MOVFF  623,64B
01C26:  MOVLB  6
01C28:  CLRF   x52
01C2A:  CLRF   x51
01C2C:  CLRF   x50
01C2E:  CLRF   x4F
01C30:  MOVLB  0
01C32:  RCALL  1446
01C34:  BNZ   1C8A
....................    {
....................       if(y==0.0)
01C36:  MOVFF  622,64E
01C3A:  MOVFF  621,64D
01C3E:  MOVFF  620,64C
01C42:  MOVFF  61F,64B
01C46:  MOVLB  6
01C48:  CLRF   x52
01C4A:  CLRF   x51
01C4C:  CLRF   x50
01C4E:  CLRF   x4F
01C50:  MOVLB  0
01C52:  CALL   1446
01C56:  BNZ   1C5A
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01C58:  BRA    1C88
....................       else
....................       {
....................          if(sign)
01C5A:  MOVLB  6
01C5C:  BTFSS  x2B.0
01C5E:  BRA    1C74
....................          {
....................          return (-(PI_DIV_BY_TWO));
01C60:  MOVLW  7F
01C62:  MOVWF  00
01C64:  MOVLW  C9
01C66:  MOVWF  01
01C68:  MOVLW  0F
01C6A:  MOVWF  02
01C6C:  MOVLW  DB
01C6E:  MOVWF  03
01C70:  BRA    1DC2
....................          }
01C72:  BRA    1C86
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01C74:  MOVLW  7F
01C76:  MOVWF  00
01C78:  MOVLW  49
01C7A:  MOVWF  01
01C7C:  MOVLW  0F
01C7E:  MOVWF  02
01C80:  MOVLW  DB
01C82:  MOVWF  03
01C84:  BRA    1DC2
01C86:  MOVLB  0
....................          }
....................       }
....................    }
01C88:  BRA    1DC0
....................    else
....................    {
....................       z=y/x;
01C8A:  MOVFF  622,647
01C8E:  MOVFF  621,646
01C92:  MOVFF  620,645
01C96:  MOVFF  61F,644
01C9A:  MOVFF  626,64B
01C9E:  MOVFF  625,64A
01CA2:  MOVFF  624,649
01CA6:  MOVFF  623,648
01CAA:  RCALL  14C0
01CAC:  MOVFF  03,62A
01CB0:  MOVFF  02,629
01CB4:  MOVFF  01,628
01CB8:  MOVFF  00,627
....................       switch(quad)
01CBC:  MOVLW  01
01CBE:  MOVLB  6
01CC0:  SUBWF  x2C,W
01CC2:  ADDLW  FC
01CC4:  BTFSC  FD8.0
01CC6:  BRA    1DC2
01CC8:  ADDLW  04
01CCA:  MOVLB  0
01CCC:  GOTO   1DC8
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01CD0:  MOVFF  62A,630
01CD4:  MOVFF  629,62F
01CD8:  MOVFF  628,62E
01CDC:  MOVFF  627,62D
01CE0:  RCALL  161E
01CE2:  MOVLB  6
01CE4:  BRA    1DC2
....................             break;
01CE6:  BRA    1DC2
01CE8:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01CEA:  MOVFF  62A,630
01CEE:  MOVFF  629,62F
01CF2:  MOVFF  628,62E
01CF6:  MOVFF  627,62D
01CFA:  RCALL  161E
01CFC:  MOVFF  FEA,62E
01D00:  MOVFF  FE9,62D
01D04:  BSF    FD8.1
01D06:  MOVLW  DB
01D08:  MOVLB  6
01D0A:  MOVWF  x52
01D0C:  MOVLW  0F
01D0E:  MOVWF  x51
01D10:  MOVLW  49
01D12:  MOVWF  x50
01D14:  MOVLW  80
01D16:  MOVWF  x4F
01D18:  MOVFF  03,656
01D1C:  MOVFF  02,655
01D20:  MOVFF  01,654
01D24:  MOVFF  00,653
01D28:  MOVLB  0
01D2A:  CALL   0B8C
01D2E:  MOVFF  62E,FEA
01D32:  MOVFF  62D,FE9
01D36:  MOVLB  6
01D38:  BRA    1DC2
....................             break;
01D3A:  BRA    1DC2
01D3C:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01D3E:  MOVFF  62A,630
01D42:  MOVFF  629,62F
01D46:  MOVFF  628,62E
01D4A:  MOVFF  627,62D
01D4E:  RCALL  161E
01D50:  MOVFF  03,630
01D54:  MOVFF  02,62F
01D58:  MOVFF  01,62E
01D5C:  MOVFF  00,62D
01D60:  MOVFF  FEA,632
01D64:  MOVFF  FE9,631
01D68:  BSF    FD8.1
01D6A:  MOVFF  03,652
01D6E:  MOVFF  02,651
01D72:  MOVFF  01,650
01D76:  MOVFF  00,64F
01D7A:  MOVLW  DB
01D7C:  MOVLB  6
01D7E:  MOVWF  x56
01D80:  MOVLW  0F
01D82:  MOVWF  x55
01D84:  MOVLW  49
01D86:  MOVWF  x54
01D88:  MOVLW  80
01D8A:  MOVWF  x53
01D8C:  MOVLB  0
01D8E:  CALL   0B8C
01D92:  MOVFF  632,FEA
01D96:  MOVFF  631,FE9
01D9A:  MOVLB  6
01D9C:  BRA    1DC2
....................             break;
01D9E:  BRA    1DC2
01DA0:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01DA2:  MOVFF  62A,630
01DA6:  MOVFF  629,62F
01DAA:  MOVFF  628,62E
01DAE:  MOVFF  627,62D
01DB2:  RCALL  161E
01DB4:  MOVLW  80
01DB6:  XORWF  01,F
01DB8:  MOVLB  6
01DBA:  BRA    1DC2
....................             break;
01DBC:  BRA    1DC2
01DBE:  MOVLB  0
01DC0:  MOVLB  6
....................          }
....................       }
....................    }
01DC2:  MOVLB  0
01DC4:  GOTO   349C (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
.................... } smData[2] = 
.................... {
....................    {false, false},
....................    {false, false}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00E04:  MOVLB  F
00E06:  BTFSC  x5B.0
00E08:  BRA    1354
....................    {
....................       switch (state)
00E0A:  MOVLB  1
00E0C:  MOVF   x61,W
00E0E:  ADDLW  F9
00E10:  BTFSC  FD8.0
00E12:  BRA    1352
00E14:  ADDLW  07
00E16:  MOVLB  0
00E18:  GOTO   135A
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00E1C:  MOVLB  F
00E1E:  BTFSC  x5B.0
00E20:  BRA    0E1E
00E22:  MOVFF  F5F,02
00E26:  MOVFF  F5E,01
00E2A:  MOVFF  02,5EA
00E2E:  MOVFF  01,5E9
00E32:  MOVFF  02,650
00E36:  MOVFF  01,64F
00E3A:  MOVLB  0
00E3C:  RCALL  0A60
00E3E:  MOVFF  03,64E
00E42:  MOVFF  02,64D
00E46:  MOVFF  01,64C
00E4A:  MOVFF  00,64B
00E4E:  MOVFF  B9,652
00E52:  MOVFF  B8,651
00E56:  MOVFF  B7,650
00E5A:  MOVFF  B6,64F
00E5E:  RCALL  0A96
00E60:  MOVFF  03,5EC
00E64:  MOVFF  02,5EB
00E68:  MOVFF  01,5EA
00E6C:  MOVFF  00,5E9
00E70:  BCF    FD8.1
00E72:  MOVFF  03,652
00E76:  MOVFF  02,651
00E7A:  MOVFF  01,650
00E7E:  MOVFF  00,64F
00E82:  MOVFF  B5,656
00E86:  MOVFF  B4,655
00E8A:  MOVFF  B3,654
00E8E:  MOVFF  B2,653
00E92:  RCALL  0B8C
00E94:  MOVFF  03,F6
00E98:  MOVFF  02,F5
00E9C:  MOVFF  01,F4
00EA0:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00EA4:  MOVLB  F
00EA6:  MOVF   x5A,W
00EA8:  ANDLW  3F
00EAA:  MOVWF  01
00EAC:  MOVLW  10
00EAE:  MOVWF  x5A
00EB0:  BTFSS  x5B.7
00EB2:  BRA    0EC2
00EB4:  MOVF   01,W
00EB6:  SUBLW  10
00EB8:  BZ    0EC2
00EBA:  BSF    x5B.0
00EBC:  NOP   
00EBE:  BTFSC  x5B.0
00EC0:  BRA    0EBE
....................             delay_ms(10);
00EC2:  MOVLW  0A
00EC4:  MOVLB  5
00EC6:  MOVWF  xEE
00EC8:  MOVLB  0
00ECA:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
00ECE:  MOVLB  F
00ED0:  BSF    x5B.0
00ED2:  NOP   
....................             state = 1;
00ED4:  MOVLW  01
00ED6:  MOVLB  1
00ED8:  MOVWF  x61
....................          break;
00EDA:  BRA    1352
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00EDC:  MOVLB  F
00EDE:  BTFSC  x5B.0
00EE0:  BRA    0EDE
00EE2:  MOVFF  F5F,02
00EE6:  MOVFF  F5E,01
00EEA:  MOVFF  02,5EA
00EEE:  MOVFF  01,5E9
00EF2:  MOVFF  02,650
00EF6:  MOVFF  01,64F
00EFA:  MOVLB  0
00EFC:  RCALL  0A60
00EFE:  MOVFF  03,64E
00F02:  MOVFF  02,64D
00F06:  MOVFF  01,64C
00F0A:  MOVFF  00,64B
00F0E:  MOVFF  C1,652
00F12:  MOVFF  C0,651
00F16:  MOVFF  BF,650
00F1A:  MOVFF  BE,64F
00F1E:  RCALL  0A96
00F20:  MOVFF  03,5EC
00F24:  MOVFF  02,5EB
00F28:  MOVFF  01,5EA
00F2C:  MOVFF  00,5E9
00F30:  BCF    FD8.1
00F32:  MOVFF  03,652
00F36:  MOVFF  02,651
00F3A:  MOVFF  01,650
00F3E:  MOVFF  00,64F
00F42:  MOVFF  BD,656
00F46:  MOVFF  BC,655
00F4A:  MOVFF  BB,654
00F4E:  MOVFF  BA,653
00F52:  RCALL  0B8C
00F54:  MOVFF  03,FA
00F58:  MOVFF  02,F9
00F5C:  MOVFF  01,F8
00F60:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00F64:  MOVLB  F
00F66:  MOVF   x5A,W
00F68:  ANDLW  3F
00F6A:  MOVWF  01
00F6C:  MOVLW  18
00F6E:  MOVWF  x5A
00F70:  BTFSS  x5B.7
00F72:  BRA    0F82
00F74:  MOVF   01,W
00F76:  SUBLW  18
00F78:  BZ    0F82
00F7A:  BSF    x5B.0
00F7C:  NOP   
00F7E:  BTFSC  x5B.0
00F80:  BRA    0F7E
....................             delay_ms(10);
00F82:  MOVLW  0A
00F84:  MOVLB  5
00F86:  MOVWF  xEE
00F88:  MOVLB  0
00F8A:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
00F8E:  MOVLB  F
00F90:  BSF    x5B.0
00F92:  NOP   
....................             state = 2;
00F94:  MOVLW  02
00F96:  MOVLB  1
00F98:  MOVWF  x61
....................          break;
00F9A:  BRA    1352
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00F9C:  MOVLB  F
00F9E:  BTFSC  x5B.0
00FA0:  BRA    0F9E
00FA2:  MOVFF  F5F,02
00FA6:  MOVFF  F5E,01
00FAA:  MOVFF  02,5EA
00FAE:  MOVFF  01,5E9
00FB2:  MOVFF  02,650
00FB6:  MOVFF  01,64F
00FBA:  MOVLB  0
00FBC:  RCALL  0A60
00FBE:  MOVFF  03,64E
00FC2:  MOVFF  02,64D
00FC6:  MOVFF  01,64C
00FCA:  MOVFF  00,64B
00FCE:  MOVFF  C9,652
00FD2:  MOVFF  C8,651
00FD6:  MOVFF  C7,650
00FDA:  MOVFF  C6,64F
00FDE:  RCALL  0A96
00FE0:  MOVFF  03,5EC
00FE4:  MOVFF  02,5EB
00FE8:  MOVFF  01,5EA
00FEC:  MOVFF  00,5E9
00FF0:  BCF    FD8.1
00FF2:  MOVFF  03,652
00FF6:  MOVFF  02,651
00FFA:  MOVFF  01,650
00FFE:  MOVFF  00,64F
01002:  MOVFF  C5,656
01006:  MOVFF  C4,655
0100A:  MOVFF  C3,654
0100E:  MOVFF  C2,653
01012:  RCALL  0B8C
01014:  MOVFF  03,FE
01018:  MOVFF  02,FD
0101C:  MOVFF  01,FC
01020:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
01024:  MOVLB  F
01026:  MOVF   x5A,W
01028:  ANDLW  3F
0102A:  MOVWF  01
0102C:  MOVLW  19
0102E:  MOVWF  x5A
01030:  BTFSS  x5B.7
01032:  BRA    1042
01034:  MOVF   01,W
01036:  SUBLW  19
01038:  BZ    1042
0103A:  BSF    x5B.0
0103C:  NOP   
0103E:  BTFSC  x5B.0
01040:  BRA    103E
....................             delay_ms(10);
01042:  MOVLW  0A
01044:  MOVLB  5
01046:  MOVWF  xEE
01048:  MOVLB  0
0104A:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
0104E:  MOVLB  F
01050:  BSF    x5B.0
01052:  NOP   
....................             state = 3;
01054:  MOVLW  03
01056:  MOVLB  1
01058:  MOVWF  x61
....................          break;
0105A:  BRA    1352
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
0105C:  MOVLB  F
0105E:  BTFSC  x5B.0
01060:  BRA    105E
01062:  MOVFF  F5F,02
01066:  MOVFF  F5E,01
0106A:  MOVFF  02,5EA
0106E:  MOVFF  01,5E9
01072:  MOVFF  02,650
01076:  MOVFF  01,64F
0107A:  MOVLB  0
0107C:  RCALL  0A60
0107E:  MOVFF  03,64E
01082:  MOVFF  02,64D
01086:  MOVFF  01,64C
0108A:  MOVFF  00,64B
0108E:  MOVFF  D1,652
01092:  MOVFF  D0,651
01096:  MOVFF  CF,650
0109A:  MOVFF  CE,64F
0109E:  RCALL  0A96
010A0:  MOVFF  03,5EC
010A4:  MOVFF  02,5EB
010A8:  MOVFF  01,5EA
010AC:  MOVFF  00,5E9
010B0:  BCF    FD8.1
010B2:  MOVFF  03,652
010B6:  MOVFF  02,651
010BA:  MOVFF  01,650
010BE:  MOVFF  00,64F
010C2:  MOVFF  CD,656
010C6:  MOVFF  CC,655
010CA:  MOVFF  CB,654
010CE:  MOVFF  CA,653
010D2:  RCALL  0B8C
010D4:  MOVFF  03,102
010D8:  MOVFF  02,101
010DC:  MOVFF  01,100
010E0:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
010E4:  MOVLB  F
010E6:  MOVF   x5A,W
010E8:  ANDLW  3F
010EA:  MOVWF  01
010EC:  MOVLW  11
010EE:  MOVWF  x5A
010F0:  BTFSS  x5B.7
010F2:  BRA    1102
010F4:  MOVF   01,W
010F6:  SUBLW  11
010F8:  BZ    1102
010FA:  BSF    x5B.0
010FC:  NOP   
010FE:  BTFSC  x5B.0
01100:  BRA    10FE
....................             delay_ms(10);
01102:  MOVLW  0A
01104:  MOVLB  5
01106:  MOVWF  xEE
01108:  MOVLB  0
0110A:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
0110E:  MOVLB  F
01110:  BSF    x5B.0
01112:  NOP   
....................             state = 4;
01114:  MOVLW  04
01116:  MOVLB  1
01118:  MOVWF  x61
....................          break;
0111A:  BRA    1352
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0111C:  MOVLB  F
0111E:  BTFSC  x5B.0
01120:  BRA    111E
01122:  MOVFF  F5F,02
01126:  MOVFF  F5E,01
0112A:  MOVFF  02,5EA
0112E:  MOVFF  01,5E9
01132:  MOVFF  02,650
01136:  MOVFF  01,64F
0113A:  MOVLB  0
0113C:  RCALL  0A60
0113E:  MOVFF  03,64E
01142:  MOVFF  02,64D
01146:  MOVFF  01,64C
0114A:  MOVFF  00,64B
0114E:  MOVFF  D9,652
01152:  MOVFF  D8,651
01156:  MOVFF  D7,650
0115A:  MOVFF  D6,64F
0115E:  RCALL  0A96
01160:  MOVFF  03,5EC
01164:  MOVFF  02,5EB
01168:  MOVFF  01,5EA
0116C:  MOVFF  00,5E9
01170:  BCF    FD8.1
01172:  MOVFF  03,652
01176:  MOVFF  02,651
0117A:  MOVFF  01,650
0117E:  MOVFF  00,64F
01182:  MOVFF  D5,656
01186:  MOVFF  D4,655
0118A:  MOVFF  D3,654
0118E:  MOVFF  D2,653
01192:  RCALL  0B8C
01194:  MOVFF  03,106
01198:  MOVFF  02,105
0119C:  MOVFF  01,104
011A0:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
011A4:  MOVLB  F
011A6:  MOVF   x5A,W
011A8:  ANDLW  3F
011AA:  MOVWF  01
011AC:  MOVLW  1B
011AE:  MOVWF  x5A
011B0:  BTFSS  x5B.7
011B2:  BRA    11C2
011B4:  MOVF   01,W
011B6:  SUBLW  1B
011B8:  BZ    11C2
011BA:  BSF    x5B.0
011BC:  NOP   
011BE:  BTFSC  x5B.0
011C0:  BRA    11BE
....................             delay_ms(10);
011C2:  MOVLW  0A
011C4:  MOVLB  5
011C6:  MOVWF  xEE
011C8:  MOVLB  0
011CA:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
011CE:  MOVLB  F
011D0:  BSF    x5B.0
011D2:  NOP   
....................             state = 5;
011D4:  MOVLW  05
011D6:  MOVLB  1
011D8:  MOVWF  x61
....................          break;
011DA:  BRA    1352
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
011DC:  MOVLB  F
011DE:  BTFSC  x5B.0
011E0:  BRA    11DE
011E2:  MOVFF  F5F,02
011E6:  MOVFF  F5E,01
011EA:  MOVFF  02,5EA
011EE:  MOVFF  01,5E9
011F2:  MOVFF  02,650
011F6:  MOVFF  01,64F
011FA:  MOVLB  0
011FC:  RCALL  0A60
011FE:  MOVFF  03,64E
01202:  MOVFF  02,64D
01206:  MOVFF  01,64C
0120A:  MOVFF  00,64B
0120E:  MOVFF  E1,652
01212:  MOVFF  E0,651
01216:  MOVFF  DF,650
0121A:  MOVFF  DE,64F
0121E:  RCALL  0A96
01220:  MOVFF  03,5EC
01224:  MOVFF  02,5EB
01228:  MOVFF  01,5EA
0122C:  MOVFF  00,5E9
01230:  BCF    FD8.1
01232:  MOVFF  03,652
01236:  MOVFF  02,651
0123A:  MOVFF  01,650
0123E:  MOVFF  00,64F
01242:  MOVFF  DD,656
01246:  MOVFF  DC,655
0124A:  MOVFF  DB,654
0124E:  MOVFF  DA,653
01252:  RCALL  0B8C
01254:  MOVFF  03,10A
01258:  MOVFF  02,109
0125C:  MOVFF  01,108
01260:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01264:  MOVLB  F
01266:  MOVF   x5A,W
01268:  ANDLW  3F
0126A:  MOVWF  01
0126C:  MOVLW  1A
0126E:  MOVWF  x5A
01270:  BTFSS  x5B.7
01272:  BRA    1282
01274:  MOVF   01,W
01276:  SUBLW  1A
01278:  BZ    1282
0127A:  BSF    x5B.0
0127C:  NOP   
0127E:  BTFSC  x5B.0
01280:  BRA    127E
....................             delay_ms(10);
01282:  MOVLW  0A
01284:  MOVLB  5
01286:  MOVWF  xEE
01288:  MOVLB  0
0128A:  CALL   03D0
....................             read_adc(ADC_START_ONLY);
0128E:  MOVLB  F
01290:  BSF    x5B.0
01292:  NOP   
....................             state = 6;
01294:  MOVLW  06
01296:  MOVLB  1
01298:  MOVWF  x61
....................          break;
0129A:  BRA    1352
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
0129C:  MOVLB  F
0129E:  BTFSC  x5B.0
012A0:  BRA    129E
012A2:  MOVFF  F5F,02
012A6:  MOVFF  F5E,01
012AA:  MOVFF  02,5EA
012AE:  MOVFF  01,5E9
012B2:  MOVFF  02,650
012B6:  MOVFF  01,64F
012BA:  MOVLB  0
012BC:  CALL   0A60
012C0:  MOVFF  03,64E
012C4:  MOVFF  02,64D
012C8:  MOVFF  01,64C
012CC:  MOVFF  00,64B
012D0:  MOVFF  E9,652
012D4:  MOVFF  E8,651
012D8:  MOVFF  E7,650
012DC:  MOVFF  E6,64F
012E0:  CALL   0A96
012E4:  MOVFF  03,5EC
012E8:  MOVFF  02,5EB
012EC:  MOVFF  01,5EA
012F0:  MOVFF  00,5E9
012F4:  BCF    FD8.1
012F6:  MOVFF  03,652
012FA:  MOVFF  02,651
012FE:  MOVFF  01,650
01302:  MOVFF  00,64F
01306:  MOVFF  E5,656
0130A:  MOVFF  E4,655
0130E:  MOVFF  E3,654
01312:  MOVFF  E2,653
01316:  RCALL  0B8C
01318:  MOVFF  03,10E
0131C:  MOVFF  02,10D
01320:  MOVFF  01,10C
01324:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
01328:  MOVLB  F
0132A:  MOVF   x5A,W
0132C:  ANDLW  3F
0132E:  MOVWF  01
01330:  MOVLW  06
01332:  MOVWF  x5A
01334:  BTFSS  x5B.7
01336:  BRA    1346
01338:  MOVF   01,W
0133A:  SUBLW  06
0133C:  BZ    1346
0133E:  BSF    x5B.0
01340:  NOP   
01342:  BTFSC  x5B.0
01344:  BRA    1342
....................             read_adc(ADC_START_ONLY);
01346:  BSF    x5B.0
01348:  NOP   
....................             state = 0;
0134A:  MOVLB  1
0134C:  CLRF   x61
....................          break;   
0134E:  BRA    1352
01350:  MOVLB  1
01352:  MOVLB  F
....................       }
....................    }
01354:  MOVLB  0
01356:  GOTO   9422 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
02E26:  MOVLB  5
02E28:  MOVF   xF1,W
02E2A:  MULLW  21
02E2C:  MOVF   FF3,W
02E2E:  MOVLB  6
02E30:  CLRF   x03
02E32:  MOVWF  x02
02E34:  MOVLW  10
02E36:  ADDWF  x02,W
02E38:  MOVWF  01
02E3A:  MOVLW  00
02E3C:  ADDWFC x03,W
02E3E:  MOVWF  03
02E40:  MOVF   01,W
02E42:  ADDLW  0F
02E44:  MOVWF  01
02E46:  MOVLW  01
02E48:  ADDWFC 03,F
02E4A:  MOVFF  01,602
02E4E:  MOVFF  03,603
02E52:  MOVLB  5
02E54:  MOVF   xF1,W
02E56:  MULLW  21
02E58:  MOVF   FF3,W
02E5A:  MOVLB  6
02E5C:  CLRF   x05
02E5E:  MOVWF  x04
02E60:  MOVLW  08
02E62:  ADDWF  x04,W
02E64:  MOVWF  01
02E66:  MOVLW  00
02E68:  ADDWFC x05,W
02E6A:  MOVWF  03
02E6C:  MOVF   01,W
02E6E:  ADDLW  0F
02E70:  MOVWF  FE9
02E72:  MOVLW  01
02E74:  ADDWFC 03,W
02E76:  MOVWF  FEA
02E78:  MOVFF  FEF,00
02E7C:  MOVFF  FEC,01
02E80:  MOVFF  FEC,02
02E84:  MOVFF  FEC,03
02E88:  MOVFF  603,FEA
02E8C:  MOVFF  602,FE9
02E90:  MOVFF  00,FEF
02E94:  MOVFF  01,FEC
02E98:  MOVFF  02,FEC
02E9C:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
02EA0:  MOVLB  5
02EA2:  MOVF   xF1,W
02EA4:  MULLW  21
02EA6:  MOVF   FF3,W
02EA8:  MOVLB  6
02EAA:  CLRF   x03
02EAC:  MOVWF  x02
02EAE:  MOVLW  14
02EB0:  ADDWF  x02,W
02EB2:  MOVWF  01
02EB4:  MOVLW  00
02EB6:  ADDWFC x03,W
02EB8:  MOVWF  03
02EBA:  MOVF   01,W
02EBC:  ADDLW  0F
02EBE:  MOVWF  01
02EC0:  MOVLW  01
02EC2:  ADDWFC 03,F
02EC4:  MOVFF  01,602
02EC8:  MOVFF  03,603
02ECC:  MOVLB  5
02ECE:  MOVF   xF1,W
02ED0:  MULLW  21
02ED2:  MOVF   FF3,W
02ED4:  MOVLB  6
02ED6:  CLRF   x05
02ED8:  MOVWF  x04
02EDA:  MOVLW  0C
02EDC:  ADDWF  x04,W
02EDE:  MOVWF  01
02EE0:  MOVLW  00
02EE2:  ADDWFC x05,W
02EE4:  MOVWF  03
02EE6:  MOVF   01,W
02EE8:  ADDLW  0F
02EEA:  MOVWF  FE9
02EEC:  MOVLW  01
02EEE:  ADDWFC 03,W
02EF0:  MOVWF  FEA
02EF2:  MOVFF  FEF,00
02EF6:  MOVFF  FEC,01
02EFA:  MOVFF  FEC,02
02EFE:  MOVFF  FEC,03
02F02:  MOVFF  603,FEA
02F06:  MOVFF  602,FE9
02F0A:  MOVFF  00,FEF
02F0E:  MOVFF  01,FEC
02F12:  MOVFF  02,FEC
02F16:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
02F1A:  MOVLB  5
02F1C:  MOVF   xF1,W
02F1E:  MULLW  21
02F20:  MOVF   FF3,W
02F22:  MOVLB  6
02F24:  CLRF   x03
02F26:  MOVWF  x02
02F28:  MOVLW  0F
02F2A:  ADDWF  x02,W
02F2C:  MOVWF  FE9
02F2E:  MOVLW  01
02F30:  ADDWFC x03,W
02F32:  MOVWF  FEA
02F34:  MOVFF  5F5,618
02F38:  MOVFF  5F4,617
02F3C:  MOVFF  5F3,616
02F40:  MOVFF  5F2,615
02F44:  MOVLB  0
02F46:  CALL   13EC
02F4A:  MOVFF  00,FEF
02F4E:  MOVFF  01,FEC
02F52:  MOVFF  02,FEC
02F56:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02F5A:  MOVLB  5
02F5C:  MOVF   xF1,W
02F5E:  MULLW  21
02F60:  MOVF   FF3,W
02F62:  MOVLB  6
02F64:  CLRF   x03
02F66:  MOVWF  x02
02F68:  MOVLW  04
02F6A:  ADDWF  x02,W
02F6C:  MOVWF  01
02F6E:  MOVLW  00
02F70:  ADDWFC x03,W
02F72:  MOVWF  03
02F74:  MOVF   01,W
02F76:  ADDLW  0F
02F78:  MOVWF  FE9
02F7A:  MOVLW  01
02F7C:  ADDWFC 03,W
02F7E:  MOVWF  FEA
02F80:  MOVFF  5F9,618
02F84:  MOVFF  5F8,617
02F88:  MOVFF  5F7,616
02F8C:  MOVFF  5F6,615
02F90:  MOVLB  0
02F92:  CALL   13EC
02F96:  MOVFF  00,FEF
02F9A:  MOVFF  01,FEC
02F9E:  MOVFF  02,FEC
02FA2:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02FA6:  MOVLB  5
02FA8:  MOVF   xF1,W
02FAA:  MULLW  21
02FAC:  MOVF   FF3,W
02FAE:  MOVLB  6
02FB0:  CLRF   x03
02FB2:  MOVWF  x02
02FB4:  MOVLW  08
02FB6:  ADDWF  x02,W
02FB8:  MOVWF  01
02FBA:  MOVLW  00
02FBC:  ADDWFC x03,W
02FBE:  MOVWF  03
02FC0:  MOVF   01,W
02FC2:  ADDLW  0F
02FC4:  MOVWF  01
02FC6:  MOVLW  01
02FC8:  ADDWFC 03,F
02FCA:  MOVFF  01,602
02FCE:  MOVFF  03,603
02FD2:  MOVLB  5
02FD4:  MOVF   xF1,W
02FD6:  MULLW  21
02FD8:  MOVF   FF3,W
02FDA:  MOVLB  6
02FDC:  CLRF   x05
02FDE:  MOVWF  x04
02FE0:  MOVLW  0F
02FE2:  ADDWF  x04,W
02FE4:  MOVWF  FE9
02FE6:  MOVLW  01
02FE8:  ADDWFC x05,W
02FEA:  MOVWF  FEA
02FEC:  MOVFF  FEF,64B
02FF0:  MOVFF  FEC,64C
02FF4:  MOVFF  FEC,64D
02FF8:  MOVFF  FEC,64E
02FFC:  MOVLB  5
02FFE:  MOVF   xF1,W
03000:  MULLW  10
03002:  MOVF   FF3,W
03004:  MOVLB  6
03006:  CLRF   x0B
03008:  MOVWF  x0A
0300A:  MOVLW  08
0300C:  ADDWF  x0A,W
0300E:  MOVWF  01
03010:  MOVLW  00
03012:  ADDWFC x0B,W
03014:  MOVWF  03
03016:  MOVF   01,W
03018:  ADDLW  62
0301A:  MOVWF  FE9
0301C:  MOVLW  00
0301E:  ADDWFC 03,W
03020:  MOVWF  FEA
03022:  MOVFF  FEF,64F
03026:  MOVFF  FEC,01
0302A:  MOVFF  FEC,02
0302E:  MOVFF  FEC,03
03032:  MOVFF  03,652
03036:  MOVFF  02,651
0303A:  MOVFF  01,650
0303E:  MOVLB  0
03040:  CALL   0A96
03044:  MOVFF  03,652
03048:  MOVFF  02,651
0304C:  MOVFF  01,650
03050:  MOVFF  00,64F
03054:  MOVLB  5
03056:  MOVF   xF1,W
03058:  MULLW  10
0305A:  MOVF   FF3,W
0305C:  MOVLB  6
0305E:  CLRF   x0B
03060:  MOVWF  x0A
03062:  MOVLW  62
03064:  ADDWF  x0A,W
03066:  MOVWF  FE9
03068:  MOVLW  00
0306A:  ADDWFC x0B,W
0306C:  MOVWF  FEA
0306E:  MOVFF  FEF,653
03072:  MOVFF  FEC,01
03076:  MOVFF  FEC,02
0307A:  MOVFF  FEC,03
0307E:  BCF    FD8.1
03080:  MOVFF  03,656
03084:  MOVFF  02,655
03088:  MOVFF  01,654
0308C:  MOVLB  0
0308E:  CALL   0B8C
03092:  MOVFF  603,FEA
03096:  MOVFF  602,FE9
0309A:  MOVFF  00,FEF
0309E:  MOVFF  01,FEC
030A2:  MOVFF  02,FEC
030A6:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
030AA:  MOVLB  5
030AC:  MOVF   xF1,W
030AE:  MULLW  21
030B0:  MOVF   FF3,W
030B2:  MOVLB  6
030B4:  CLRF   x03
030B6:  MOVWF  x02
030B8:  MOVLW  0C
030BA:  ADDWF  x02,W
030BC:  MOVWF  01
030BE:  MOVLW  00
030C0:  ADDWFC x03,W
030C2:  MOVWF  03
030C4:  MOVF   01,W
030C6:  ADDLW  0F
030C8:  MOVWF  01
030CA:  MOVLW  01
030CC:  ADDWFC 03,F
030CE:  MOVFF  01,602
030D2:  MOVFF  03,603
030D6:  MOVLB  5
030D8:  MOVF   xF1,W
030DA:  MULLW  21
030DC:  MOVF   FF3,W
030DE:  MOVLB  6
030E0:  CLRF   x05
030E2:  MOVWF  x04
030E4:  MOVLW  04
030E6:  ADDWF  x04,W
030E8:  MOVWF  01
030EA:  MOVLW  00
030EC:  ADDWFC x05,W
030EE:  MOVWF  03
030F0:  MOVF   01,W
030F2:  ADDLW  0F
030F4:  MOVWF  FE9
030F6:  MOVLW  01
030F8:  ADDWFC 03,W
030FA:  MOVWF  FEA
030FC:  MOVFF  FEF,64B
03100:  MOVFF  FEC,64C
03104:  MOVFF  FEC,64D
03108:  MOVFF  FEC,64E
0310C:  MOVLB  5
0310E:  MOVF   xF1,W
03110:  MULLW  10
03112:  MOVF   FF3,W
03114:  MOVLB  6
03116:  CLRF   x09
03118:  MOVWF  x08
0311A:  MOVLW  0C
0311C:  ADDWF  x08,W
0311E:  MOVWF  01
03120:  MOVLW  00
03122:  ADDWFC x09,W
03124:  MOVWF  03
03126:  MOVF   01,W
03128:  ADDLW  62
0312A:  MOVWF  FE9
0312C:  MOVLW  00
0312E:  ADDWFC 03,W
03130:  MOVWF  FEA
03132:  MOVFF  FEF,64F
03136:  MOVFF  FEC,01
0313A:  MOVFF  FEC,02
0313E:  MOVFF  FEC,03
03142:  MOVFF  03,652
03146:  MOVFF  02,651
0314A:  MOVFF  01,650
0314E:  MOVLB  0
03150:  CALL   0A96
03154:  MOVFF  03,652
03158:  MOVFF  02,651
0315C:  MOVFF  01,650
03160:  MOVFF  00,64F
03164:  MOVLB  5
03166:  MOVF   xF1,W
03168:  MULLW  10
0316A:  MOVF   FF3,W
0316C:  MOVLB  6
0316E:  CLRF   x09
03170:  MOVWF  x08
03172:  MOVLW  04
03174:  ADDWF  x08,W
03176:  MOVWF  01
03178:  MOVLW  00
0317A:  ADDWFC x09,W
0317C:  MOVWF  03
0317E:  MOVF   01,W
03180:  ADDLW  62
03182:  MOVWF  FE9
03184:  MOVLW  00
03186:  ADDWFC 03,W
03188:  MOVWF  FEA
0318A:  MOVFF  FEF,653
0318E:  MOVFF  FEC,01
03192:  MOVFF  FEC,02
03196:  MOVFF  FEC,03
0319A:  BCF    FD8.1
0319C:  MOVFF  03,656
031A0:  MOVFF  02,655
031A4:  MOVFF  01,654
031A8:  MOVLB  0
031AA:  CALL   0B8C
031AE:  MOVFF  603,FEA
031B2:  MOVFF  602,FE9
031B6:  MOVFF  00,FEF
031BA:  MOVFF  01,FEC
031BE:  MOVFF  02,FEC
031C2:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
031C6:  MOVLB  5
031C8:  CLRF   xFD
031CA:  CLRF   xFC
031CC:  CLRF   xFB
031CE:  CLRF   xFA
031D0:  MOVLB  6
031D2:  CLRF   x01
031D4:  CLRF   x00
031D6:  MOVLB  5
031D8:  CLRF   xFF
031DA:  MOVLW  7F
031DC:  MOVWF  xFE
....................    
....................    if (adcVals[ch].cosCounts < 0){
031DE:  MOVF   xF1,W
031E0:  MULLW  21
031E2:  MOVF   FF3,W
031E4:  MOVLB  6
031E6:  CLRF   x03
031E8:  MOVWF  x02
031EA:  MOVLW  0C
031EC:  ADDWF  x02,W
031EE:  MOVWF  01
031F0:  MOVLW  00
031F2:  ADDWFC x03,W
031F4:  MOVWF  03
031F6:  MOVF   01,W
031F8:  ADDLW  0F
031FA:  MOVWF  FE9
031FC:  MOVLW  01
031FE:  ADDWFC 03,W
03200:  MOVWF  FEA
03202:  MOVFF  FEF,64B
03206:  MOVFF  FEC,64C
0320A:  MOVFF  FEC,64D
0320E:  MOVFF  FEC,64E
03212:  CLRF   x52
03214:  CLRF   x51
03216:  CLRF   x50
03218:  CLRF   x4F
0321A:  MOVLB  0
0321C:  CALL   1446
03220:  BTFSS  FD8.0
03222:  BRA    3398
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03224:  MOVLB  5
03226:  MOVF   xF1,W
03228:  MULLW  21
0322A:  MOVF   FF3,W
0322C:  MOVLB  6
0322E:  CLRF   x03
03230:  MOVWF  x02
03232:  MOVLW  08
03234:  ADDWF  x02,W
03236:  MOVWF  01
03238:  MOVLW  00
0323A:  ADDWFC x03,W
0323C:  MOVWF  03
0323E:  MOVF   01,W
03240:  ADDLW  0F
03242:  MOVWF  FE9
03244:  MOVLW  01
03246:  ADDWFC 03,W
03248:  MOVWF  FEA
0324A:  MOVFF  FEF,64F
0324E:  MOVFF  FEC,603
03252:  MOVFF  FEC,651
03256:  MOVFF  FEC,652
0325A:  CLRF   x4E
0325C:  CLRF   x4D
0325E:  CLRF   x4C
03260:  CLRF   x4B
03262:  MOVFF  603,650
03266:  MOVLB  0
03268:  CALL   1446
0326C:  BNC   32DE
0326E:  MOVLB  5
03270:  MOVF   xF1,W
03272:  MULLW  21
03274:  MOVF   FF3,W
03276:  MOVLB  6
03278:  CLRF   x03
0327A:  MOVWF  x02
0327C:  MOVLW  10
0327E:  ADDWF  x02,W
03280:  MOVWF  01
03282:  MOVLW  00
03284:  ADDWFC x03,W
03286:  MOVWF  03
03288:  MOVF   01,W
0328A:  ADDLW  0F
0328C:  MOVWF  FE9
0328E:  MOVLW  01
03290:  ADDWFC 03,W
03292:  MOVWF  FEA
03294:  MOVFF  FEF,64B
03298:  MOVFF  FEC,64C
0329C:  MOVFF  FEC,64D
032A0:  MOVFF  FEC,64E
032A4:  CLRF   x52
032A6:  CLRF   x51
032A8:  CLRF   x50
032AA:  CLRF   x4F
032AC:  MOVLB  0
032AE:  CALL   1446
032B2:  BNC   32DE
....................          adcVals[ch].npoles--;
032B4:  MOVLB  5
032B6:  MOVF   xF1,W
032B8:  MULLW  21
032BA:  MOVF   FF3,W
032BC:  MOVLB  6
032BE:  CLRF   x03
032C0:  MOVWF  x02
032C2:  MOVLW  1C
032C4:  ADDWF  x02,W
032C6:  MOVWF  01
032C8:  MOVLW  00
032CA:  ADDWFC x03,W
032CC:  MOVWF  03
032CE:  MOVF   01,W
032D0:  ADDLW  0F
032D2:  MOVWF  FE9
032D4:  MOVLW  01
032D6:  ADDWFC 03,W
032D8:  MOVWF  FEA
032DA:  DECF   FEF,F
....................       }
032DC:  BRA    3396
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
032DE:  MOVLB  5
032E0:  MOVF   xF1,W
032E2:  MULLW  21
032E4:  MOVF   FF3,W
032E6:  MOVLB  6
032E8:  CLRF   x03
032EA:  MOVWF  x02
032EC:  MOVLW  08
032EE:  ADDWF  x02,W
032F0:  MOVWF  01
032F2:  MOVLW  00
032F4:  ADDWFC x03,W
032F6:  MOVWF  03
032F8:  MOVF   01,W
032FA:  ADDLW  0F
032FC:  MOVWF  FE9
032FE:  MOVLW  01
03300:  ADDWFC 03,W
03302:  MOVWF  FEA
03304:  MOVFF  FEF,64B
03308:  MOVFF  FEC,603
0330C:  MOVFF  FEC,64D
03310:  MOVFF  FEC,64E
03314:  MOVFF  603,64C
03318:  CLRF   x52
0331A:  CLRF   x51
0331C:  CLRF   x50
0331E:  CLRF   x4F
03320:  MOVLB  0
03322:  CALL   1446
03326:  BNC   3398
03328:  MOVLB  5
0332A:  MOVF   xF1,W
0332C:  MULLW  21
0332E:  MOVF   FF3,W
03330:  MOVLB  6
03332:  CLRF   x03
03334:  MOVWF  x02
03336:  MOVLW  10
03338:  ADDWF  x02,W
0333A:  MOVWF  01
0333C:  MOVLW  00
0333E:  ADDWFC x03,W
03340:  MOVWF  03
03342:  MOVF   01,W
03344:  ADDLW  0F
03346:  MOVWF  FE9
03348:  MOVLW  01
0334A:  ADDWFC 03,W
0334C:  MOVWF  FEA
0334E:  MOVFF  FEF,64F
03352:  MOVFF  FEC,650
03356:  MOVFF  FEC,651
0335A:  MOVFF  FEC,652
0335E:  CLRF   x4E
03360:  CLRF   x4D
03362:  CLRF   x4C
03364:  CLRF   x4B
03366:  MOVLB  0
03368:  CALL   1446
0336C:  BNC   3398
....................          adcVals[ch].npoles++;
0336E:  MOVLB  5
03370:  MOVF   xF1,W
03372:  MULLW  21
03374:  MOVF   FF3,W
03376:  MOVLB  6
03378:  CLRF   x03
0337A:  MOVWF  x02
0337C:  MOVLW  1C
0337E:  ADDWF  x02,W
03380:  MOVWF  01
03382:  MOVLW  00
03384:  ADDWFC x03,W
03386:  MOVWF  03
03388:  MOVF   01,W
0338A:  ADDLW  0F
0338C:  MOVWF  FE9
0338E:  MOVLW  01
03390:  ADDWFC 03,W
03392:  MOVWF  FEA
03394:  INCF   FEF,F
03396:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03398:  MOVLB  5
0339A:  MOVF   xF1,W
0339C:  MULLW  21
0339E:  MOVF   FF3,W
033A0:  MOVLB  6
033A2:  CLRF   x03
033A4:  MOVWF  x02
033A6:  MOVLW  18
033A8:  ADDWF  x02,W
033AA:  MOVWF  01
033AC:  MOVLW  00
033AE:  ADDWFC x03,W
033B0:  MOVWF  03
033B2:  MOVF   01,W
033B4:  ADDLW  0F
033B6:  MOVWF  01
033B8:  MOVLW  01
033BA:  ADDWFC 03,F
033BC:  MOVFF  01,602
033C0:  MOVFF  03,603
033C4:  MOVFF  601,64E
033C8:  MOVFF  600,64D
033CC:  MOVFF  5FF,64C
033D0:  MOVFF  5FE,64B
033D4:  MOVLW  AA
033D6:  MOVWF  x52
033D8:  MOVLW  27
033DA:  MOVWF  x51
033DC:  MOVLW  1F
033DE:  MOVWF  x50
033E0:  MOVLW  86
033E2:  MOVWF  x4F
033E4:  MOVLB  0
033E6:  CALL   0A96
033EA:  MOVFF  03,607
033EE:  MOVFF  02,606
033F2:  MOVFF  01,605
033F6:  MOVFF  00,604
033FA:  MOVLB  5
033FC:  MOVF   xF1,W
033FE:  MULLW  21
03400:  MOVF   FF3,W
03402:  MOVLB  6
03404:  CLRF   x09
03406:  MOVWF  x08
03408:  MOVLW  08
0340A:  ADDWF  x08,W
0340C:  MOVWF  01
0340E:  MOVLW  00
03410:  ADDWFC x09,W
03412:  MOVWF  03
03414:  MOVF   01,W
03416:  ADDLW  0F
03418:  MOVWF  FE9
0341A:  MOVLW  01
0341C:  ADDWFC 03,W
0341E:  MOVWF  FEA
03420:  MOVFF  FEF,608
03424:  MOVFF  FEC,609
03428:  MOVFF  FEC,60A
0342C:  MOVFF  FEC,60B
03430:  MOVLB  5
03432:  MOVF   xF1,W
03434:  MULLW  21
03436:  MOVF   FF3,W
03438:  MOVLB  6
0343A:  CLRF   x0D
0343C:  MOVWF  x0C
0343E:  MOVLW  0C
03440:  ADDWF  x0C,W
03442:  MOVWF  01
03444:  MOVLW  00
03446:  ADDWFC x0D,W
03448:  MOVWF  03
0344A:  MOVF   01,W
0344C:  ADDLW  0F
0344E:  MOVWF  FE9
03450:  MOVLW  01
03452:  ADDWFC 03,W
03454:  MOVWF  FEA
03456:  MOVFF  FEF,00
0345A:  MOVFF  FEC,01
0345E:  MOVFF  FEC,02
03462:  MOVFF  FEC,03
03466:  MOVFF  03,60F
0346A:  MOVFF  02,60E
0346E:  MOVFF  01,60D
03472:  MOVFF  00,60C
03476:  MOVFF  60B,622
0347A:  MOVFF  60A,621
0347E:  MOVFF  609,620
03482:  MOVFF  608,61F
03486:  MOVFF  03,626
0348A:  MOVFF  02,625
0348E:  MOVFF  01,624
03492:  MOVFF  00,623
03496:  MOVLB  0
03498:  GOTO   1B48
0349C:  MOVFF  607,64E
034A0:  MOVFF  606,64D
034A4:  MOVFF  605,64C
034A8:  MOVFF  604,64B
034AC:  MOVFF  03,652
034B0:  MOVFF  02,651
034B4:  MOVFF  01,650
034B8:  MOVFF  00,64F
034BC:  CALL   0A96
034C0:  MOVFF  603,FEA
034C4:  MOVFF  602,FE9
034C8:  MOVFF  00,FEF
034CC:  MOVFF  01,FEC
034D0:  MOVFF  02,FEC
034D4:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
034D8:  MOVLB  5
034DA:  MOVF   xF1,W
034DC:  MULLW  21
034DE:  MOVF   FF3,W
034E0:  MOVLB  6
034E2:  CLRF   x03
034E4:  MOVWF  x02
034E6:  MOVLW  18
034E8:  ADDWF  x02,W
034EA:  MOVWF  01
034EC:  MOVLW  00
034EE:  ADDWFC x03,W
034F0:  MOVWF  03
034F2:  MOVF   01,W
034F4:  ADDLW  0F
034F6:  MOVWF  FE9
034F8:  MOVLW  01
034FA:  ADDWFC 03,W
034FC:  MOVWF  FEA
034FE:  MOVFF  FEF,602
03502:  MOVFF  FEC,603
03506:  MOVFF  FEC,604
0350A:  MOVFF  FEC,605
0350E:  CLRF   x4E
03510:  CLRF   x4D
03512:  MOVLW  7A
03514:  MOVWF  x4C
03516:  MOVLW  88
03518:  MOVWF  x4B
0351A:  MOVFF  601,652
0351E:  MOVFF  600,651
03522:  MOVFF  5FF,650
03526:  MOVFF  5FE,64F
0352A:  MOVLB  0
0352C:  CALL   0A96
03530:  MOVFF  03,609
03534:  MOVFF  02,608
03538:  MOVFF  01,607
0353C:  MOVFF  00,606
03540:  MOVLB  5
03542:  MOVF   xF1,W
03544:  MULLW  21
03546:  MOVF   FF3,W
03548:  MOVLB  6
0354A:  CLRF   x0B
0354C:  MOVWF  x0A
0354E:  MOVLW  1C
03550:  ADDWF  x0A,W
03552:  MOVWF  01
03554:  MOVLW  00
03556:  ADDWFC x0B,W
03558:  MOVWF  03
0355A:  MOVF   01,W
0355C:  ADDLW  0F
0355E:  MOVWF  FE9
03560:  MOVLW  01
03562:  ADDWFC 03,W
03564:  MOVWF  FEA
03566:  MOVF   FEF,W
03568:  CLRF   x42
0356A:  MOVWF  x41
0356C:  BTFSC  x41.7
0356E:  DECF   x42,F
03570:  MOVLB  0
03572:  CALL   1DEA
03576:  MOVFF  609,64E
0357A:  MOVFF  608,64D
0357E:  MOVFF  607,64C
03582:  MOVFF  606,64B
03586:  MOVFF  03,652
0358A:  MOVFF  02,651
0358E:  MOVFF  01,650
03592:  MOVFF  00,64F
03596:  CALL   0A96
0359A:  MOVFF  FEA,607
0359E:  MOVFF  FE9,606
035A2:  BCF    FD8.1
035A4:  MOVFF  605,652
035A8:  MOVFF  604,651
035AC:  MOVFF  603,650
035B0:  MOVFF  602,64F
035B4:  MOVFF  03,656
035B8:  MOVFF  02,655
035BC:  MOVFF  01,654
035C0:  MOVFF  00,653
035C4:  CALL   0B8C
035C8:  MOVFF  607,FEA
035CC:  MOVFF  606,FE9
035D0:  MOVFF  03,5FD
035D4:  MOVFF  02,5FC
035D8:  MOVFF  01,5FB
035DC:  MOVFF  00,5FA
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
035E0:  MOVLB  5
035E2:  MOVF   xF1,W
035E4:  MULLW  21
035E6:  MOVF   FF3,W
035E8:  MOVLB  6
035EA:  CLRF   x03
035EC:  MOVWF  x02
035EE:  MOVLW  1D
035F0:  ADDWF  x02,W
035F2:  MOVWF  01
035F4:  MOVLW  00
035F6:  ADDWFC x03,W
035F8:  MOVWF  03
035FA:  MOVF   01,W
035FC:  ADDLW  0F
035FE:  MOVWF  01
03600:  MOVLW  01
03602:  ADDWFC 03,F
03604:  MOVFF  01,602
03608:  MOVFF  03,603
0360C:  MOVLB  5
0360E:  MOVF   xF1,W
03610:  MULLW  18
03612:  MOVF   FF3,W
03614:  MOVLB  6
03616:  CLRF   x05
03618:  MOVWF  x04
0361A:  MOVLW  14
0361C:  ADDWF  x04,W
0361E:  MOVWF  01
03620:  MOVLW  00
03622:  ADDWFC x05,W
03624:  MOVWF  03
03626:  MOVF   01,W
03628:  ADDLW  82
0362A:  MOVWF  FE9
0362C:  MOVLW  00
0362E:  ADDWFC 03,W
03630:  MOVWF  FEA
03632:  MOVFF  FEF,64F
03636:  MOVFF  FEC,01
0363A:  MOVFF  FEC,02
0363E:  MOVFF  FEC,03
03642:  MOVFF  5FD,64E
03646:  MOVFF  5FC,64D
0364A:  MOVFF  5FB,64C
0364E:  MOVFF  5FA,64B
03652:  MOVFF  03,652
03656:  MOVFF  02,651
0365A:  MOVFF  01,650
0365E:  MOVLB  0
03660:  CALL   0A96
03664:  MOVFF  03,607
03668:  MOVFF  02,606
0366C:  MOVFF  01,605
03670:  MOVFF  00,604
03674:  MOVFF  03,622
03678:  MOVFF  02,621
0367C:  MOVFF  01,620
03680:  MOVFF  00,61F
03684:  MOVLB  6
03686:  CLRF   x26
03688:  CLRF   x25
0368A:  MOVLW  20
0368C:  MOVWF  x24
0368E:  MOVLW  81
03690:  MOVWF  x23
03692:  MOVLB  0
03694:  CALL   2B28
03698:  MOVFF  03,607
0369C:  MOVFF  02,606
036A0:  MOVFF  01,605
036A4:  MOVFF  00,604
036A8:  MOVLB  5
036AA:  MOVF   xF1,W
036AC:  MULLW  18
036AE:  MOVF   FF3,W
036B0:  MOVLB  6
036B2:  CLRF   x09
036B4:  MOVWF  x08
036B6:  MOVLW  10
036B8:  ADDWF  x08,W
036BA:  MOVWF  01
036BC:  MOVLW  00
036BE:  ADDWFC x09,W
036C0:  MOVWF  03
036C2:  MOVF   01,W
036C4:  ADDLW  82
036C6:  MOVWF  FE9
036C8:  MOVLW  00
036CA:  ADDWFC 03,W
036CC:  MOVWF  FEA
036CE:  MOVFF  FEF,64F
036D2:  MOVFF  FEC,01
036D6:  MOVFF  FEC,02
036DA:  MOVFF  FEC,03
036DE:  MOVFF  5FD,64E
036E2:  MOVFF  5FC,64D
036E6:  MOVFF  5FB,64C
036EA:  MOVFF  5FA,64B
036EE:  MOVFF  03,652
036F2:  MOVFF  02,651
036F6:  MOVFF  01,650
036FA:  MOVLB  0
036FC:  CALL   0A96
03700:  MOVFF  03,60B
03704:  MOVFF  02,60A
03708:  MOVFF  01,609
0370C:  MOVFF  00,608
03710:  MOVFF  03,622
03714:  MOVFF  02,621
03718:  MOVFF  01,620
0371C:  MOVFF  00,61F
03720:  MOVLB  6
03722:  CLRF   x26
03724:  CLRF   x25
03726:  CLRF   x24
03728:  MOVLW  81
0372A:  MOVWF  x23
0372C:  MOVLB  0
0372E:  CALL   2B28
03732:  MOVFF  FEA,609
03736:  MOVFF  FE9,608
0373A:  BCF    FD8.1
0373C:  MOVFF  607,652
03740:  MOVFF  606,651
03744:  MOVFF  605,650
03748:  MOVFF  604,64F
0374C:  MOVFF  03,656
03750:  MOVFF  02,655
03754:  MOVFF  01,654
03758:  MOVFF  00,653
0375C:  CALL   0B8C
03760:  MOVFF  609,FEA
03764:  MOVFF  608,FE9
03768:  MOVFF  03,607
0376C:  MOVFF  02,606
03770:  MOVFF  01,605
03774:  MOVFF  00,604
03778:  MOVLB  5
0377A:  MOVF   xF1,W
0377C:  MULLW  18
0377E:  MOVF   FF3,W
03780:  MOVLB  6
03782:  CLRF   x0B
03784:  MOVWF  x0A
03786:  MOVLW  0C
03788:  ADDWF  x0A,W
0378A:  MOVWF  01
0378C:  MOVLW  00
0378E:  ADDWFC x0B,W
03790:  MOVWF  03
03792:  MOVF   01,W
03794:  ADDLW  82
03796:  MOVWF  FE9
03798:  MOVLW  00
0379A:  ADDWFC 03,W
0379C:  MOVWF  FEA
0379E:  MOVFF  FEF,64F
037A2:  MOVFF  FEC,01
037A6:  MOVFF  FEC,02
037AA:  MOVFF  FEC,03
037AE:  MOVFF  5FD,64E
037B2:  MOVFF  5FC,64D
037B6:  MOVFF  5FB,64C
037BA:  MOVFF  5FA,64B
037BE:  MOVFF  03,652
037C2:  MOVFF  02,651
037C6:  MOVFF  01,650
037CA:  MOVLB  0
037CC:  CALL   0A96
037D0:  MOVFF  03,60D
037D4:  MOVFF  02,60C
037D8:  MOVFF  01,60B
037DC:  MOVFF  00,60A
037E0:  MOVFF  03,622
037E4:  MOVFF  02,621
037E8:  MOVFF  01,620
037EC:  MOVFF  00,61F
037F0:  MOVLB  6
037F2:  CLRF   x26
037F4:  CLRF   x25
037F6:  MOVLW  40
037F8:  MOVWF  x24
037FA:  MOVLW  80
037FC:  MOVWF  x23
037FE:  MOVLB  0
03800:  CALL   2B28
03804:  MOVFF  FEA,60B
03808:  MOVFF  FE9,60A
0380C:  BCF    FD8.1
0380E:  MOVFF  607,652
03812:  MOVFF  606,651
03816:  MOVFF  605,650
0381A:  MOVFF  604,64F
0381E:  MOVFF  03,656
03822:  MOVFF  02,655
03826:  MOVFF  01,654
0382A:  MOVFF  00,653
0382E:  CALL   0B8C
03832:  MOVFF  60B,FEA
03836:  MOVFF  60A,FE9
0383A:  MOVFF  03,607
0383E:  MOVFF  02,606
03842:  MOVFF  01,605
03846:  MOVFF  00,604
0384A:  MOVLB  5
0384C:  MOVF   xF1,W
0384E:  MULLW  18
03850:  MOVF   FF3,W
03852:  MOVLB  6
03854:  CLRF   x0D
03856:  MOVWF  x0C
03858:  MOVLW  08
0385A:  ADDWF  x0C,W
0385C:  MOVWF  01
0385E:  MOVLW  00
03860:  ADDWFC x0D,W
03862:  MOVWF  03
03864:  MOVF   01,W
03866:  ADDLW  82
03868:  MOVWF  FE9
0386A:  MOVLW  00
0386C:  ADDWFC 03,W
0386E:  MOVWF  FEA
03870:  MOVFF  FEF,64F
03874:  MOVFF  FEC,01
03878:  MOVFF  FEC,02
0387C:  MOVFF  FEC,03
03880:  MOVFF  5FD,64E
03884:  MOVFF  5FC,64D
03888:  MOVFF  5FB,64C
0388C:  MOVFF  5FA,64B
03890:  MOVFF  03,652
03894:  MOVFF  02,651
03898:  MOVFF  01,650
0389C:  MOVLB  0
0389E:  CALL   0A96
038A2:  MOVFF  03,60F
038A6:  MOVFF  02,60E
038AA:  MOVFF  01,60D
038AE:  MOVFF  00,60C
038B2:  MOVFF  03,622
038B6:  MOVFF  02,621
038BA:  MOVFF  01,620
038BE:  MOVFF  00,61F
038C2:  MOVLB  6
038C4:  CLRF   x26
038C6:  CLRF   x25
038C8:  CLRF   x24
038CA:  MOVLW  80
038CC:  MOVWF  x23
038CE:  MOVLB  0
038D0:  CALL   2B28
038D4:  MOVFF  FEA,60D
038D8:  MOVFF  FE9,60C
038DC:  BCF    FD8.1
038DE:  MOVFF  607,652
038E2:  MOVFF  606,651
038E6:  MOVFF  605,650
038EA:  MOVFF  604,64F
038EE:  MOVFF  03,656
038F2:  MOVFF  02,655
038F6:  MOVFF  01,654
038FA:  MOVFF  00,653
038FE:  CALL   0B8C
03902:  MOVFF  60D,FEA
03906:  MOVFF  60C,FE9
0390A:  MOVFF  03,607
0390E:  MOVFF  02,606
03912:  MOVFF  01,605
03916:  MOVFF  00,604
0391A:  MOVLB  5
0391C:  MOVF   xF1,W
0391E:  MULLW  18
03920:  MOVF   FF3,W
03922:  MOVLB  6
03924:  CLRF   x0F
03926:  MOVWF  x0E
03928:  MOVLW  04
0392A:  ADDWF  x0E,W
0392C:  MOVWF  01
0392E:  MOVLW  00
03930:  ADDWFC x0F,W
03932:  MOVWF  03
03934:  MOVF   01,W
03936:  ADDLW  82
03938:  MOVWF  FE9
0393A:  MOVLW  00
0393C:  ADDWFC 03,W
0393E:  MOVWF  FEA
03940:  MOVFF  FEF,64F
03944:  MOVFF  FEC,01
03948:  MOVFF  FEC,02
0394C:  MOVFF  FEC,03
03950:  MOVFF  5FD,64E
03954:  MOVFF  5FC,64D
03958:  MOVFF  5FB,64C
0395C:  MOVFF  5FA,64B
03960:  MOVFF  03,652
03964:  MOVFF  02,651
03968:  MOVFF  01,650
0396C:  MOVLB  0
0396E:  CALL   0A96
03972:  MOVFF  FEA,60F
03976:  MOVFF  FE9,60E
0397A:  BCF    FD8.1
0397C:  MOVFF  607,652
03980:  MOVFF  606,651
03984:  MOVFF  605,650
03988:  MOVFF  604,64F
0398C:  MOVFF  03,656
03990:  MOVFF  02,655
03994:  MOVFF  01,654
03998:  MOVFF  00,653
0399C:  CALL   0B8C
039A0:  MOVFF  60F,FEA
039A4:  MOVFF  60E,FE9
039A8:  MOVFF  03,652
039AC:  MOVFF  02,651
039B0:  MOVFF  01,650
039B4:  MOVFF  00,64F
039B8:  MOVLB  5
039BA:  MOVF   xF1,W
039BC:  MULLW  18
039BE:  MOVF   FF3,W
039C0:  MOVLB  6
039C2:  CLRF   x11
039C4:  MOVWF  x10
039C6:  MOVLW  82
039C8:  ADDWF  x10,W
039CA:  MOVWF  FE9
039CC:  MOVLW  00
039CE:  ADDWFC x11,W
039D0:  MOVWF  FEA
039D2:  MOVFF  FEF,653
039D6:  MOVFF  FEC,01
039DA:  MOVFF  FEC,02
039DE:  MOVFF  FEC,03
039E2:  BCF    FD8.1
039E4:  MOVFF  03,656
039E8:  MOVFF  02,655
039EC:  MOVFF  01,654
039F0:  MOVLB  0
039F2:  CALL   0B8C
039F6:  MOVFF  603,FEA
039FA:  MOVFF  602,FE9
039FE:  MOVFF  00,FEF
03A02:  MOVFF  01,FEC
03A06:  MOVFF  02,FEC
03A0A:  MOVFF  03,FEC
....................    
....................    PID[ch].PVold = PID[ch].PV;
03A0E:  MOVLB  5
03A10:  MOVF   xF1,W
03A12:  MULLW  20
03A14:  MOVF   FF3,W
03A16:  MOVLB  6
03A18:  CLRF   x03
03A1A:  MOVWF  x02
03A1C:  MOVLW  14
03A1E:  ADDWF  x02,W
03A20:  MOVWF  01
03A22:  MOVLW  00
03A24:  ADDWFC x03,W
03A26:  MOVWF  03
03A28:  MOVF   01,W
03A2A:  ADDLW  20
03A2C:  MOVWF  01
03A2E:  MOVLW  00
03A30:  ADDWFC 03,F
03A32:  MOVFF  01,602
03A36:  MOVFF  03,603
03A3A:  MOVLB  5
03A3C:  MOVF   xF1,W
03A3E:  MULLW  20
03A40:  MOVF   FF3,W
03A42:  MOVLB  6
03A44:  CLRF   x05
03A46:  MOVWF  x04
03A48:  MOVLW  10
03A4A:  ADDWF  x04,W
03A4C:  MOVWF  01
03A4E:  MOVLW  00
03A50:  ADDWFC x05,W
03A52:  MOVWF  03
03A54:  MOVF   01,W
03A56:  ADDLW  20
03A58:  MOVWF  FE9
03A5A:  MOVLW  00
03A5C:  ADDWFC 03,W
03A5E:  MOVWF  FEA
03A60:  MOVFF  FEF,00
03A64:  MOVFF  FEC,01
03A68:  MOVFF  FEC,02
03A6C:  MOVFF  FEC,03
03A70:  MOVFF  603,FEA
03A74:  MOVFF  602,FE9
03A78:  MOVFF  00,FEF
03A7C:  MOVFF  01,FEC
03A80:  MOVFF  02,FEC
03A84:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03A88:  MOVLB  5
03A8A:  MOVF   xF1,W
03A8C:  MULLW  20
03A8E:  MOVF   FF3,W
03A90:  MOVLB  6
03A92:  CLRF   x03
03A94:  MOVWF  x02
03A96:  MOVLW  10
03A98:  ADDWF  x02,W
03A9A:  MOVWF  01
03A9C:  MOVLW  00
03A9E:  ADDWFC x03,W
03AA0:  MOVWF  03
03AA2:  MOVF   01,W
03AA4:  ADDLW  20
03AA6:  MOVWF  01
03AA8:  MOVLW  00
03AAA:  ADDWFC 03,F
03AAC:  MOVFF  01,602
03AB0:  MOVFF  03,603
03AB4:  MOVLB  5
03AB6:  MOVF   xF1,W
03AB8:  MULLW  21
03ABA:  MOVF   FF3,W
03ABC:  MOVLB  6
03ABE:  CLRF   x05
03AC0:  MOVWF  x04
03AC2:  MOVLW  1D
03AC4:  ADDWF  x04,W
03AC6:  MOVWF  01
03AC8:  MOVLW  00
03ACA:  ADDWFC x05,W
03ACC:  MOVWF  03
03ACE:  MOVF   01,W
03AD0:  ADDLW  0F
03AD2:  MOVWF  FE9
03AD4:  MOVLW  01
03AD6:  ADDWFC 03,W
03AD8:  MOVWF  FEA
03ADA:  MOVFF  FEF,00
03ADE:  MOVFF  FEC,01
03AE2:  MOVFF  FEC,02
03AE6:  MOVFF  FEC,03
03AEA:  MOVFF  603,FEA
03AEE:  MOVFF  602,FE9
03AF2:  MOVFF  00,FEF
03AF6:  MOVFF  01,FEC
03AFA:  MOVFF  02,FEC
03AFE:  MOVFF  03,FEC
03B02:  MOVLB  0
03B04:  GOTO   3BC8 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001C0:  MOVLB  6
001C2:  CLRF   x60
001C4:  MOVFF  162,65F
001C8:  MOVLW  5F
001CA:  ADDWF  x5F,W
001CC:  MOVWF  FE9
001CE:  MOVLW  01
001D0:  ADDWFC x60,W
001D2:  MOVWF  FEA
001D4:  BTFSC  FEF.1
001D6:  BRA    0240
....................    {
....................       smData[ch].adcBusy = true;
001D8:  CLRF   x60
001DA:  MOVFF  162,65F
001DE:  MOVLW  5F
001E0:  ADDWF  x5F,W
001E2:  MOVWF  FE9
001E4:  MOVLW  01
001E6:  ADDWFC x60,W
001E8:  MOVWF  FEA
001EA:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001EC:  MOVFF  162,65F
001F0:  MOVLB  0
001F2:  BRA    01A2
....................       ch = !ch;
001F4:  MOVLB  1
001F6:  MOVF   x62,F
001F8:  BZ    01FE
001FA:  MOVLW  00
001FC:  BRA    0200
001FE:  MOVLW  01
00200:  MOVWF  x62
....................       
....................       smData[!ch].dataReady = true;
00202:  MOVF   x62,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVLB  6
0020E:  CLRF   x60
00210:  MOVWF  x5F
00212:  MOVLW  5F
00214:  ADDWF  x5F,W
00216:  MOVWF  FE9
00218:  MOVLW  01
0021A:  ADDWFC x60,W
0021C:  MOVWF  FEA
0021E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00220:  MOVLB  1
00222:  MOVF   x62,F
00224:  BZ    022A
00226:  MOVLW  00
00228:  BRA    022C
0022A:  MOVLW  01
0022C:  MOVLB  6
0022E:  CLRF   x60
00230:  MOVWF  x5F
00232:  MOVLW  5F
00234:  ADDWF  x5F,W
00236:  MOVWF  FE9
00238:  MOVLW  01
0023A:  ADDWFC x60,W
0023C:  MOVWF  FEA
0023E:  BCF    FEF.1
....................    }
00240:  MOVLB  0
00242:  GOTO   0304 (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
03B08:  MOVLB  5
03B0A:  CLRF   xEC
03B0C:  CLRF   xEB
03B0E:  CLRF   xEA
03B10:  CLRF   xE9
03B12:  CLRF   xF0
03B14:  CLRF   xEF
03B16:  CLRF   xEE
03B18:  CLRF   xED
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinRaw = 0;
....................    signed int32 cosRaw = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
03B1A:  CLRF   xF2
03B1C:  MOVFF  163,5F1
03B20:  MOVLW  5F
03B22:  ADDWF  xF1,W
03B24:  MOVWF  FE9
03B26:  MOVLW  01
03B28:  ADDWFC xF2,W
03B2A:  MOVWF  FEA
03B2C:  BTFSC  FEF.1
03B2E:  BRA    3C14
03B30:  CLRF   xF4
03B32:  MOVFF  163,5F3
03B36:  MOVLW  5F
03B38:  ADDWF  xF3,W
03B3A:  MOVWF  FE9
03B3C:  MOVLW  01
03B3E:  ADDWFC xF4,W
03B40:  MOVWF  FEA
03B42:  BTFSS  FEF.0
03B44:  BRA    3C14
....................       smData[ch].adcBusy = true;
03B46:  CLRF   xF2
03B48:  MOVFF  163,5F1
03B4C:  MOVLW  5F
03B4E:  ADDWF  xF1,W
03B50:  MOVWF  FE9
03B52:  MOVLW  01
03B54:  ADDWFC xF2,W
03B56:  MOVWF  FEA
03B58:  BSF    FEF.1
....................       
....................       sinRaw = ads_read_data(ch*2);
03B5A:  BCF    FD8.0
03B5C:  MOVLB  1
03B5E:  RLCF   x63,W
03B60:  MOVLB  5
03B62:  MOVWF  xF1
03B64:  MOVWF  xF2
03B66:  MOVLB  0
03B68:  CALL   139C
03B6C:  MOVFF  03,5EC
03B70:  MOVFF  02,5EB
03B74:  MOVFF  01,5EA
03B78:  MOVFF  00,5E9
....................       cosRaw = ads_read_data(ch*2+1);      
03B7C:  BCF    FD8.0
03B7E:  MOVLB  1
03B80:  RLCF   x63,W
03B82:  ADDLW  01
03B84:  MOVLB  5
03B86:  MOVWF  xF1
03B88:  MOVWF  xF2
03B8A:  MOVLB  0
03B8C:  CALL   139C
03B90:  MOVFF  03,5F0
03B94:  MOVFF  02,5EF
03B98:  MOVFF  01,5EE
03B9C:  MOVFF  00,5ED
....................       
....................       sensor_process_data(ch, sinRaw, cosRaw);
03BA0:  MOVFF  163,5F1
03BA4:  MOVFF  5EC,5F5
03BA8:  MOVFF  5EB,5F4
03BAC:  MOVFF  5EA,5F3
03BB0:  MOVFF  5E9,5F2
03BB4:  MOVFF  5F0,5F9
03BB8:  MOVFF  5EF,5F8
03BBC:  MOVFF  5EE,5F7
03BC0:  MOVFF  5ED,5F6
03BC4:  GOTO   2E26
....................       ch = !ch;
03BC8:  MOVLB  1
03BCA:  MOVF   x63,F
03BCC:  BZ    3BD2
03BCE:  MOVLW  00
03BD0:  BRA    3BD4
03BD2:  MOVLW  01
03BD4:  MOVWF  x63
....................       
....................       smData[!ch].dataReady = false;
03BD6:  MOVF   x63,F
03BD8:  BZ    3BDE
03BDA:  MOVLW  00
03BDC:  BRA    3BE0
03BDE:  MOVLW  01
03BE0:  MOVLB  5
03BE2:  CLRF   xF2
03BE4:  MOVWF  xF1
03BE6:  MOVLW  5F
03BE8:  ADDWF  xF1,W
03BEA:  MOVWF  FE9
03BEC:  MOVLW  01
03BEE:  ADDWFC xF2,W
03BF0:  MOVWF  FEA
03BF2:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
03BF4:  MOVLB  1
03BF6:  MOVF   x63,F
03BF8:  BZ    3BFE
03BFA:  MOVLW  00
03BFC:  BRA    3C00
03BFE:  MOVLW  01
03C00:  MOVLB  5
03C02:  CLRF   xF2
03C04:  MOVWF  xF1
03C06:  MOVLW  5F
03C08:  ADDWF  xF1,W
03C0A:  MOVWF  FE9
03C0C:  MOVLW  01
03C0E:  ADDWFC xF2,W
03C10:  MOVWF  FEA
03C12:  BCF    FEF.1
....................    }
03C14:  MOVLB  0
03C16:  GOTO   9426 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0074E:  MOVLB  5
00750:  CLRF   xE9
00752:  CLRF   xEA
00754:  CLRF   xEB
00756:  CLRF   xEC
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
00758:  CLRF   xED
0075A:  MOVF   xED,W
0075C:  SUBLW  03
0075E:  BNC   0796
....................    {
....................       rc0=reg0config;
00760:  MOVLW  30
00762:  MOVWF  xE9
....................       rc1=reg1config;
00764:  MOVLW  10
00766:  MOVWF  xEA
....................       rc2=reg2config;
00768:  MOVLW  30
0076A:  MOVWF  xEB
....................       rc3=reg3config;
0076C:  CLRF   xEC
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
0076E:  MOVFF  5ED,5EE
00772:  MOVFF  5E9,5EF
00776:  MOVFF  5EA,5F0
0077A:  MOVFF  5EB,5F1
0077E:  MOVFF  5EC,5F2
00782:  MOVLB  0
00784:  BRA    06E4
....................       delay_ms(1);
00786:  MOVLW  01
00788:  MOVLB  5
0078A:  MOVWF  xEE
0078C:  MOVLB  0
0078E:  RCALL  03D0
00790:  MOVLB  5
00792:  INCF   xED,F
00794:  BRA    075A
....................    }   
00796:  MOVLB  0
00798:  GOTO   07FC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0079C:  MOVLW  00
0079E:  MOVLB  F
007A0:  MOVWF  x53
007A2:  MOVLW  40
007A4:  MOVWF  x0C
007A6:  MOVLW  00
007A8:  MOVWF  x14
007AA:  MOVLW  03
007AC:  MOVWF  x1C
007AE:  MOVLW  0F
007B0:  MOVWF  x21
007B2:  MOVLW  00
007B4:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
007B6:  MOVLW  08
007B8:  MOVWF  x55
007BA:  CLRF   x56
007BC:  CLRF   x52
007BE:  SETF   x57
007C0:  CLRF   F61
007C2:  MOVLW  94
007C4:  MOVWF  x5B
....................    output_high(EN_EXC);
007C6:  MOVLW  E8
007C8:  MOVWF  F8B
007CA:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
007CC:  MOVF   x5A,W
007CE:  ANDLW  3F
007D0:  MOVWF  01
007D2:  MOVLW  06
007D4:  MOVWF  x5A
007D6:  BTFSS  x5B.7
007D8:  BRA    07E8
007DA:  MOVF   01,W
007DC:  SUBLW  06
007DE:  BZ    07E8
007E0:  BSF    x5B.0
007E2:  NOP   
007E4:  BTFSC  x5B.0
007E6:  BRA    07E4
....................    delay_ms(10);
007E8:  MOVLW  0A
007EA:  MOVLB  5
007EC:  MOVWF  xEE
007EE:  MOVLB  0
007F0:  RCALL  03D0
....................    read_adc(ADC_START_ONLY);
007F2:  MOVLB  F
007F4:  BSF    x5B.0
007F6:  NOP   
....................    setup_external_ADCs();
007F8:  MOVLB  0
007FA:  BRA    074E
....................    intTimeoutReg = sensorSampleRate;
007FC:  MOVLB  1
007FE:  CLRF   x5E
00800:  MOVLW  32
00802:  MOVWF  x5D
00804:  MOVLB  0
00806:  GOTO   940E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0,0,0,0,0,0,0},
....................    {0.01,0,0,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0,0,0,0,0,0,0},
....................    {0.01,0,0,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
03CAC:  MOVLB  5
03CAE:  MOVF   xED,W
03CB0:  MULLW  20
03CB2:  MOVF   FF3,W
03CB4:  CLRF   xFB
03CB6:  MOVWF  xFA
03CB8:  MOVLW  0C
03CBA:  ADDWF  xFA,W
03CBC:  MOVWF  01
03CBE:  MOVLW  00
03CC0:  ADDWFC xFB,W
03CC2:  MOVWF  03
03CC4:  MOVF   01,W
03CC6:  ADDLW  20
03CC8:  MOVWF  FE9
03CCA:  MOVLW  00
03CCC:  ADDWFC 03,W
03CCE:  MOVWF  FEA
03CD0:  MOVFF  FEF,64F
03CD4:  MOVFF  FEC,650
03CD8:  MOVFF  FEC,651
03CDC:  MOVFF  FEC,652
03CE0:  MOVF   xED,W
03CE2:  MULLW  20
03CE4:  MOVF   FF3,W
03CE6:  CLRF   xFF
03CE8:  MOVWF  xFE
03CEA:  MOVLW  10
03CEC:  ADDWF  xFE,W
03CEE:  MOVWF  01
03CF0:  MOVLW  00
03CF2:  ADDWFC xFF,W
03CF4:  MOVWF  03
03CF6:  MOVF   01,W
03CF8:  ADDLW  20
03CFA:  MOVWF  FE9
03CFC:  MOVLW  00
03CFE:  ADDWFC 03,W
03D00:  MOVWF  FEA
03D02:  MOVFF  FEF,653
03D06:  MOVFF  FEC,01
03D0A:  MOVFF  FEC,02
03D0E:  MOVFF  FEC,03
03D12:  MOVFF  FEA,5FF
03D16:  MOVFF  FE9,5FE
03D1A:  BSF    FD8.1
03D1C:  MOVFF  03,656
03D20:  MOVFF  02,655
03D24:  MOVFF  01,654
03D28:  MOVLB  0
03D2A:  CALL   0B8C
03D2E:  MOVFF  5FF,FEA
03D32:  MOVFF  5FE,FE9
03D36:  MOVFF  03,5F1
03D3A:  MOVFF  02,5F0
03D3E:  MOVFF  01,5EF
03D42:  MOVFF  00,5EE
....................    float err = PID[ch].SP - PID[ch].PV;   // error = set value - measured
....................    PID[ch].I += (err * PID[ch].kI);       // integral value 
03D46:  MOVLB  5
03D48:  MOVF   xED,W
03D4A:  MULLW  20
03D4C:  MOVF   FF3,W
03D4E:  CLRF   xFB
03D50:  MOVWF  xFA
03D52:  MOVLW  1C
03D54:  ADDWF  xFA,W
03D56:  MOVWF  01
03D58:  MOVLW  00
03D5A:  ADDWFC xFB,W
03D5C:  MOVWF  03
03D5E:  MOVF   01,W
03D60:  ADDLW  20
03D62:  MOVWF  01
03D64:  MOVLW  00
03D66:  ADDWFC 03,F
03D68:  MOVFF  01,5FA
03D6C:  MOVFF  03,5FB
03D70:  MOVFF  03,FEA
03D74:  MOVFF  01,FE9
03D78:  MOVFF  FEF,5FC
03D7C:  MOVFF  FEC,5FD
03D80:  MOVFF  FEC,5FE
03D84:  MOVFF  FEC,5FF
03D88:  MOVF   xED,W
03D8A:  MULLW  20
03D8C:  MOVF   FF3,W
03D8E:  MOVLB  6
03D90:  CLRF   x01
03D92:  MOVWF  x00
03D94:  MOVLW  04
03D96:  ADDWF  x00,W
03D98:  MOVWF  01
03D9A:  MOVLW  00
03D9C:  ADDWFC x01,W
03D9E:  MOVWF  03
03DA0:  MOVF   01,W
03DA2:  ADDLW  20
03DA4:  MOVWF  FE9
03DA6:  MOVLW  00
03DA8:  ADDWFC 03,W
03DAA:  MOVWF  FEA
03DAC:  MOVFF  FEF,64F
03DB0:  MOVFF  FEC,01
03DB4:  MOVFF  FEC,02
03DB8:  MOVFF  FEC,03
03DBC:  MOVFF  5F1,64E
03DC0:  MOVFF  5F0,64D
03DC4:  MOVFF  5EF,64C
03DC8:  MOVFF  5EE,64B
03DCC:  MOVFF  03,652
03DD0:  MOVFF  02,651
03DD4:  MOVFF  01,650
03DD8:  MOVLB  0
03DDA:  CALL   0A96
03DDE:  BCF    FD8.1
03DE0:  MOVFF  5FF,652
03DE4:  MOVFF  5FE,651
03DE8:  MOVFF  5FD,650
03DEC:  MOVFF  5FC,64F
03DF0:  MOVFF  03,656
03DF4:  MOVFF  02,655
03DF8:  MOVFF  01,654
03DFC:  MOVFF  00,653
03E00:  CALL   0B8C
03E04:  MOVFF  5FB,FEA
03E08:  MOVFF  5FA,FE9
03E0C:  MOVFF  00,FEF
03E10:  MOVFF  01,FEC
03E14:  MOVFF  02,FEC
03E18:  MOVFF  03,FEC
....................    float P = err * PID[ch].kP;            // proportional value
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold); // derivative value
03E1C:  MOVLB  5
03E1E:  MOVF   xED,W
03E20:  MULLW  20
03E22:  MOVF   FF3,W
03E24:  CLRF   xFB
03E26:  MOVWF  xFA
03E28:  MOVLW  20
03E2A:  ADDWF  xFA,W
03E2C:  MOVWF  FE9
03E2E:  MOVLW  00
03E30:  ADDWFC xFB,W
03E32:  MOVWF  FEA
03E34:  MOVFF  FEF,64F
03E38:  MOVFF  FEC,01
03E3C:  MOVFF  FEC,02
03E40:  MOVFF  FEC,03
03E44:  MOVFF  5F1,64E
03E48:  MOVFF  5F0,64D
03E4C:  MOVFF  5EF,64C
03E50:  MOVFF  5EE,64B
03E54:  MOVFF  03,652
03E58:  MOVFF  02,651
03E5C:  MOVFF  01,650
03E60:  MOVLB  0
03E62:  CALL   0A96
03E66:  MOVFF  03,5F5
03E6A:  MOVFF  02,5F4
03E6E:  MOVFF  01,5F3
03E72:  MOVFF  00,5F2
03E76:  MOVLB  5
03E78:  MOVF   xED,W
03E7A:  MULLW  20
03E7C:  MOVF   FF3,W
03E7E:  CLRF   xFD
03E80:  MOVWF  xFC
03E82:  MOVLW  08
03E84:  ADDWF  xFC,W
03E86:  MOVWF  01
03E88:  MOVLW  00
03E8A:  ADDWFC xFD,W
03E8C:  MOVWF  03
03E8E:  MOVF   01,W
03E90:  ADDLW  20
03E92:  MOVWF  FE9
03E94:  MOVLW  00
03E96:  ADDWFC 03,W
03E98:  MOVWF  FEA
03E9A:  MOVFF  FEF,5FC
03E9E:  MOVFF  FEC,5FD
03EA2:  MOVFF  FEC,5FE
03EA6:  MOVFF  FEC,5FF
03EAA:  MOVF   xED,W
03EAC:  MULLW  20
03EAE:  MOVF   FF3,W
03EB0:  MOVLB  6
03EB2:  CLRF   x01
03EB4:  MOVWF  x00
03EB6:  MOVLW  10
03EB8:  ADDWF  x00,W
03EBA:  MOVWF  01
03EBC:  MOVLW  00
03EBE:  ADDWFC x01,W
03EC0:  MOVWF  03
03EC2:  MOVF   01,W
03EC4:  ADDLW  20
03EC6:  MOVWF  FE9
03EC8:  MOVLW  00
03ECA:  ADDWFC 03,W
03ECC:  MOVWF  FEA
03ECE:  MOVFF  FEF,64F
03ED2:  MOVFF  FEC,650
03ED6:  MOVFF  FEC,651
03EDA:  MOVFF  FEC,652
03EDE:  MOVLB  5
03EE0:  MOVF   xED,W
03EE2:  MULLW  20
03EE4:  MOVF   FF3,W
03EE6:  MOVLB  6
03EE8:  CLRF   x05
03EEA:  MOVWF  x04
03EEC:  MOVLW  14
03EEE:  ADDWF  x04,W
03EF0:  MOVWF  01
03EF2:  MOVLW  00
03EF4:  ADDWFC x05,W
03EF6:  MOVWF  03
03EF8:  MOVF   01,W
03EFA:  ADDLW  20
03EFC:  MOVWF  FE9
03EFE:  MOVLW  00
03F00:  ADDWFC 03,W
03F02:  MOVWF  FEA
03F04:  MOVFF  FEF,653
03F08:  MOVFF  FEC,01
03F0C:  MOVFF  FEC,02
03F10:  MOVFF  FEC,03
03F14:  MOVFF  FEA,605
03F18:  MOVFF  FE9,604
03F1C:  BSF    FD8.1
03F1E:  MOVFF  03,656
03F22:  MOVFF  02,655
03F26:  MOVFF  01,654
03F2A:  MOVLB  0
03F2C:  CALL   0B8C
03F30:  MOVFF  605,FEA
03F34:  MOVFF  604,FE9
03F38:  MOVFF  5FF,64E
03F3C:  MOVFF  5FE,64D
03F40:  MOVFF  5FD,64C
03F44:  MOVFF  5FC,64B
03F48:  MOVFF  03,652
03F4C:  MOVFF  02,651
03F50:  MOVFF  01,650
03F54:  MOVFF  00,64F
03F58:  CALL   0A96
03F5C:  MOVFF  03,5F9
03F60:  MOVFF  02,5F8
03F64:  MOVFF  01,5F7
03F68:  MOVFF  00,5F6
....................    PID[ch].CV = P + PID[ch].I + D;        // new control variable
03F6C:  MOVLB  5
03F6E:  MOVF   xED,W
03F70:  MULLW  20
03F72:  MOVF   FF3,W
03F74:  CLRF   xFB
03F76:  MOVWF  xFA
03F78:  MOVLW  18
03F7A:  ADDWF  xFA,W
03F7C:  MOVWF  01
03F7E:  MOVLW  00
03F80:  ADDWFC xFB,W
03F82:  MOVWF  03
03F84:  MOVF   01,W
03F86:  ADDLW  20
03F88:  MOVWF  01
03F8A:  MOVLW  00
03F8C:  ADDWFC 03,F
03F8E:  MOVFF  01,5FA
03F92:  MOVFF  03,5FB
03F96:  MOVF   xED,W
03F98:  MULLW  20
03F9A:  MOVF   FF3,W
03F9C:  CLRF   xFD
03F9E:  MOVWF  xFC
03FA0:  MOVLW  1C
03FA2:  ADDWF  xFC,W
03FA4:  MOVWF  01
03FA6:  MOVLW  00
03FA8:  ADDWFC xFD,W
03FAA:  MOVWF  03
03FAC:  MOVF   01,W
03FAE:  ADDLW  20
03FB0:  MOVWF  FE9
03FB2:  MOVLW  00
03FB4:  ADDWFC 03,W
03FB6:  MOVWF  FEA
03FB8:  MOVFF  FEF,653
03FBC:  MOVFF  FEC,01
03FC0:  MOVFF  FEC,02
03FC4:  MOVFF  FEC,03
03FC8:  MOVFF  FEA,5FD
03FCC:  MOVFF  FE9,5FC
03FD0:  BCF    FD8.1
03FD2:  MOVFF  5F5,652
03FD6:  MOVFF  5F4,651
03FDA:  MOVFF  5F3,650
03FDE:  MOVFF  5F2,64F
03FE2:  MOVFF  03,656
03FE6:  MOVFF  02,655
03FEA:  MOVFF  01,654
03FEE:  MOVLB  0
03FF0:  CALL   0B8C
03FF4:  MOVFF  5FD,FEA
03FF8:  MOVFF  5FC,FE9
03FFC:  MOVFF  03,601
04000:  MOVFF  02,600
04004:  MOVFF  01,5FF
04008:  MOVFF  00,5FE
0400C:  BCF    FD8.1
0400E:  MOVFF  03,652
04012:  MOVFF  02,651
04016:  MOVFF  01,650
0401A:  MOVFF  00,64F
0401E:  MOVFF  5F9,656
04022:  MOVFF  5F8,655
04026:  MOVFF  5F7,654
0402A:  MOVFF  5F6,653
0402E:  CALL   0B8C
04032:  MOVFF  5FB,FEA
04036:  MOVFF  5FA,FE9
0403A:  MOVFF  00,FEF
0403E:  MOVFF  01,FEC
04042:  MOVFF  02,FEC
04046:  MOVFF  03,FEC
....................    if (PID[ch].CV > 100) 
0404A:  MOVLB  5
0404C:  MOVF   xED,W
0404E:  MULLW  20
04050:  MOVF   FF3,W
04052:  CLRF   xFB
04054:  MOVWF  xFA
04056:  MOVLW  18
04058:  ADDWF  xFA,W
0405A:  MOVWF  01
0405C:  MOVLW  00
0405E:  ADDWFC xFB,W
04060:  MOVWF  03
04062:  MOVF   01,W
04064:  ADDLW  20
04066:  MOVWF  FE9
04068:  MOVLW  00
0406A:  ADDWFC 03,W
0406C:  MOVWF  FEA
0406E:  MOVFF  FEF,64F
04072:  MOVFF  FEC,650
04076:  MOVFF  FEC,651
0407A:  MOVFF  FEC,652
0407E:  MOVLB  6
04080:  CLRF   x4E
04082:  CLRF   x4D
04084:  MOVLW  48
04086:  MOVWF  x4C
04088:  MOVLW  85
0408A:  MOVWF  x4B
0408C:  MOVLB  0
0408E:  CALL   1446
04092:  BNC   40C4
....................    {
....................       PID[ch].CV = 100;// limit output to 100%
04094:  MOVLB  5
04096:  MOVF   xED,W
04098:  MULLW  20
0409A:  MOVF   FF3,W
0409C:  CLRF   xFB
0409E:  MOVWF  xFA
040A0:  MOVLW  18
040A2:  ADDWF  xFA,W
040A4:  MOVWF  01
040A6:  MOVLW  00
040A8:  ADDWFC xFB,W
040AA:  MOVWF  03
040AC:  MOVF   01,W
040AE:  ADDLW  20
040B0:  MOVWF  FE9
040B2:  MOVLW  00
040B4:  ADDWFC 03,W
040B6:  MOVWF  FEA
040B8:  MOVLW  85
040BA:  MOVWF  FEF
040BC:  MOVLW  48
040BE:  MOVWF  FEC
040C0:  CLRF   FEC
040C2:  CLRF   FEC
040C4:  MOVLB  0
....................    }
040C6:  GOTO   413E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
.................... //!   if (adcVals[ch].pReal != PID[ch].PV) pid_update(ch);
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
040CA:  MOVLB  5
040CC:  MOVF   xEC,W
040CE:  MULLW  20
040D0:  MOVF   FF3,W
040D2:  CLRF   xEE
040D4:  MOVWF  xED
040D6:  MOVLW  0C
040D8:  ADDWF  xED,W
040DA:  MOVWF  01
040DC:  MOVLW  00
040DE:  ADDWFC xEE,W
040E0:  MOVWF  03
040E2:  MOVF   01,W
040E4:  ADDLW  20
040E6:  MOVWF  FE9
040E8:  MOVLW  00
040EA:  ADDWFC 03,W
040EC:  MOVWF  FEA
040EE:  MOVFF  FEF,64B
040F2:  MOVFF  FEC,64C
040F6:  MOVFF  FEC,64D
040FA:  MOVFF  FEC,64E
040FE:  MOVF   xEC,W
04100:  MULLW  20
04102:  MOVF   FF3,W
04104:  CLRF   xF2
04106:  MOVWF  xF1
04108:  MOVLW  10
0410A:  ADDWF  xF1,W
0410C:  MOVWF  01
0410E:  MOVLW  00
04110:  ADDWFC xF2,W
04112:  MOVWF  03
04114:  MOVF   01,W
04116:  ADDLW  20
04118:  MOVWF  FE9
0411A:  MOVLW  00
0411C:  ADDWFC 03,W
0411E:  MOVWF  FEA
04120:  MOVFF  FEF,64F
04124:  MOVFF  FEC,650
04128:  MOVFF  FEC,651
0412C:  MOVFF  FEC,652
04130:  MOVLB  0
04132:  CALL   1446
04136:  BZ    413E
04138:  MOVFF  5EC,5ED
0413C:  BRA    3CAC
....................    if ((index++) >= numChannels) index = 0;
0413E:  MOVLB  1
04140:  MOVF   x64,W
04142:  INCF   x64,F
04144:  SUBLW  01
04146:  BC    414A
04148:  CLRF   x64
0414A:  MOVLB  0
0414C:  GOTO   423C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=0, STREAM=SPI_ctrl)
*
0080A:  CLRF   03
0080C:  MOVF   F91,W
0080E:  MOVFF  5EE,F91
00812:  RRCF   F94,W
00814:  BNC   0812
00816:  MOVF   F91,W
00818:  MOVWF  02
0081A:  MOVFF  5ED,F91
0081E:  RRCF   F94,W
00820:  BNC   081E
00822:  MOVF   F91,W
00824:  MOVWF  01
00826:  MOVFF  5EC,F91
0082A:  RRCF   F94,W
0082C:  BNC   082A
0082E:  MOVFF  F91,00
00832:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
03C50:  MOVLB  5
03C52:  MOVF   xED,F
03C54:  BZ    3C80
....................       if (chMap[0] == ch) output_low(INV_HVX);
03C56:  MOVLW  00
03C58:  MOVLB  0
03C5A:  BTFSC  x60.0
03C5C:  MOVLW  01
03C5E:  MOVLB  5
03C60:  SUBWF  xEC,W
03C62:  BNZ   3C6A
03C64:  MOVLW  C4
03C66:  MOVWF  F88
03C68:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
03C6A:  MOVLW  00
03C6C:  MOVLB  0
03C6E:  BTFSC  x60.1
03C70:  MOVLW  01
03C72:  MOVLB  5
03C74:  SUBWF  xEC,W
03C76:  BNZ   3C7E
03C78:  MOVLW  C4
03C7A:  MOVWF  F88
03C7C:  BCF    F83.5
....................    }
03C7E:  BRA    3CA8
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
03C80:  MOVLW  00
03C82:  MOVLB  0
03C84:  BTFSC  x60.0
03C86:  MOVLW  01
03C88:  MOVLB  5
03C8A:  SUBWF  xEC,W
03C8C:  BNZ   3C94
03C8E:  MOVLW  C4
03C90:  MOVWF  F88
03C92:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
03C94:  MOVLW  00
03C96:  MOVLB  0
03C98:  BTFSC  x60.1
03C9A:  MOVLW  01
03C9C:  MOVLB  5
03C9E:  SUBWF  xEC,W
03CA0:  BNZ   3CA8
03CA2:  MOVLW  C4
03CA4:  MOVWF  F88
03CA6:  BSF    F83.5
....................    }
03CA8:  MOVLB  0
03CAA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04150:  MOVLB  5
04152:  CLRF   xEB
04154:  CLRF   xEA
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04156:  MOVFF  5E9,5F6
0415A:  CLRF   xF8
0415C:  MOVLW  61
0415E:  MOVWF  xF7
04160:  MOVLB  0
04162:  RCALL  3C1A
04164:  MOVF   01,F
04166:  BNZ   4236
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04168:  MOVLB  5
0416A:  MOVF   xE9,W
0416C:  MULLW  04
0416E:  MOVF   FF3,W
04170:  CLRF   03
04172:  ADDLW  EA
04174:  MOVWF  FE9
04176:  MOVLW  00
04178:  ADDWFC 03,W
0417A:  MOVWF  FEA
0417C:  MOVFF  FEF,64B
04180:  MOVFF  FEC,64C
04184:  MOVFF  FEC,64D
04188:  MOVFF  FEC,64E
0418C:  MOVLB  6
0418E:  CLRF   x52
04190:  CLRF   x51
04192:  CLRF   x50
04194:  CLRF   x4F
04196:  MOVLB  0
04198:  CALL   1446
0419C:  BNC   41AE
0419E:  MOVFF  5E9,5EC
041A2:  MOVLW  01
041A4:  MOVLB  5
041A6:  MOVWF  xED
041A8:  MOVLB  0
041AA:  RCALL  3C50
041AC:  BRA    41BA
....................       else                             invert_voltage(ch, FALSE);
041AE:  MOVFF  5E9,5EC
041B2:  MOVLB  5
041B4:  CLRF   xED
041B6:  MOVLB  0
041B8:  RCALL  3C50
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
041BA:  MOVLB  5
041BC:  MOVF   xE9,W
041BE:  MULLW  04
041C0:  MOVF   FF3,W
041C2:  CLRF   03
041C4:  ADDLW  EA
041C6:  MOVWF  FE9
041C8:  MOVLW  00
041CA:  ADDWFC 03,W
041CC:  MOVWF  FEA
041CE:  MOVFF  FEF,00
041D2:  MOVFF  FEC,01
041D6:  MOVFF  FEC,02
041DA:  MOVFF  FEC,03
041DE:  BCF    01.7
041E0:  MOVFF  03,5EF
041E4:  MOVFF  02,5EE
041E8:  MOVFF  01,5ED
041EC:  MOVFF  00,5EC
041F0:  MOVFF  03,64E
041F4:  MOVFF  02,64D
041F8:  MOVFF  01,64C
041FC:  MOVFF  00,64B
04200:  MOVLW  66
04202:  MOVLB  6
04204:  MOVWF  x52
04206:  MOVLW  D6
04208:  MOVWF  x51
0420A:  MOVLW  23
0420C:  MOVWF  x50
0420E:  MOVLW  88
04210:  MOVWF  x4F
04212:  MOVLB  0
04214:  CALL   0A96
04218:  MOVFF  03,64E
0421C:  MOVFF  02,64D
04220:  MOVFF  01,64C
04224:  MOVFF  00,64B
04228:  CALL   1E3A
0422C:  MOVFF  02,5EB
04230:  MOVFF  01,5EA
....................    }
04234:  BRA    4328
....................    else {
....................       pid_task(ch);
04236:  MOVFF  5E9,5EC
0423A:  BRA    40CA
....................       if ( PID[(int)ch].CV < 0) invert_voltage(ch, TRUE); 
0423C:  MOVLB  5
0423E:  MOVF   xE9,W
04240:  MULLW  20
04242:  MOVF   FF3,W
04244:  CLRF   xED
04246:  MOVWF  xEC
04248:  MOVLW  18
0424A:  ADDWF  xEC,W
0424C:  MOVWF  01
0424E:  MOVLW  00
04250:  ADDWFC xED,W
04252:  MOVWF  03
04254:  MOVF   01,W
04256:  ADDLW  20
04258:  MOVWF  FE9
0425A:  MOVLW  00
0425C:  ADDWFC 03,W
0425E:  MOVWF  FEA
04260:  MOVFF  FEF,64B
04264:  MOVFF  FEC,64C
04268:  MOVFF  FEC,64D
0426C:  MOVFF  FEC,64E
04270:  MOVLB  6
04272:  CLRF   x52
04274:  CLRF   x51
04276:  CLRF   x50
04278:  CLRF   x4F
0427A:  MOVLB  0
0427C:  CALL   1446
04280:  BNC   4292
04282:  MOVFF  5E9,5EC
04286:  MOVLW  01
04288:  MOVLB  5
0428A:  MOVWF  xED
0428C:  MOVLB  0
0428E:  RCALL  3C50
04290:  BRA    429E
....................       else                      invert_voltage(ch, FALSE);
04292:  MOVFF  5E9,5EC
04296:  MOVLB  5
04298:  CLRF   xED
0429A:  MOVLB  0
0429C:  RCALL  3C50
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
0429E:  MOVLB  5
042A0:  MOVF   xE9,W
042A2:  MULLW  20
042A4:  MOVF   FF3,W
042A6:  CLRF   xED
042A8:  MOVWF  xEC
042AA:  MOVLW  18
042AC:  ADDWF  xEC,W
042AE:  MOVWF  01
042B0:  MOVLW  00
042B2:  ADDWFC xED,W
042B4:  MOVWF  03
042B6:  MOVF   01,W
042B8:  ADDLW  20
042BA:  MOVWF  FE9
042BC:  MOVLW  00
042BE:  ADDWFC 03,W
042C0:  MOVWF  FEA
042C2:  MOVFF  FEF,00
042C6:  MOVFF  FEC,01
042CA:  MOVFF  FEC,02
042CE:  MOVFF  FEC,03
042D2:  BCF    01.7
042D4:  MOVFF  03,5EF
042D8:  MOVFF  02,5EE
042DC:  MOVFF  01,5ED
042E0:  MOVFF  00,5EC
042E4:  MOVFF  03,64E
042E8:  MOVFF  02,64D
042EC:  MOVFF  01,64C
042F0:  MOVFF  00,64B
042F4:  MOVLW  66
042F6:  MOVLB  6
042F8:  MOVWF  x52
042FA:  MOVLW  D6
042FC:  MOVWF  x51
042FE:  MOVLW  23
04300:  MOVWF  x50
04302:  MOVLW  88
04304:  MOVWF  x4F
04306:  MOVLB  0
04308:  CALL   0A96
0430C:  MOVFF  03,64E
04310:  MOVFF  02,64D
04314:  MOVFF  01,64C
04318:  MOVFF  00,64B
0431C:  CALL   1E3A
04320:  MOVFF  02,5EB
04324:  MOVFF  01,5EA
....................    }
....................       
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04328:  MOVLW  00
0432A:  BTFSC  x60.0
0432C:  MOVLW  01
0432E:  MOVLB  5
04330:  SUBWF  xE9,W
04332:  BNZ   433A
04334:  MOVLW  E8
04336:  MOVWF  F8B
04338:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
0433A:  MOVLW  00
0433C:  MOVLB  0
0433E:  BTFSC  x60.1
04340:  MOVLW  01
04342:  MOVLB  5
04344:  SUBWF  xE9,W
04346:  BNZ   434E
04348:  MOVLW  E8
0434A:  MOVWF  F8B
0434C:  BSF    F86.1
....................    
....................    delay_ms(1);
0434E:  MOVLW  01
04350:  MOVWF  xEE
04352:  MOVLB  0
04354:  CALL   03D0
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04358:  MOVLW  00
0435A:  BTFSC  x60.0
0435C:  MOVLW  01
0435E:  MOVLB  5
04360:  SUBWF  xE9,W
04362:  BNZ   436A
04364:  MOVLW  E8
04366:  MOVWF  F8B
04368:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
0436A:  MOVLW  00
0436C:  MOVLB  0
0436E:  BTFSC  x60.1
04370:  MOVLW  01
04372:  MOVLB  5
04374:  SUBWF  xE9,W
04376:  BNZ   437E
04378:  MOVLW  E8
0437A:  MOVWF  F8B
0437C:  BCF    F86.1
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
0437E:  CLRF   xEF
04380:  CLRF   xEE
04382:  MOVFF  5EB,5ED
04386:  MOVFF  5EA,5EC
0438A:  MOVLB  0
0438C:  CALL   080A
....................    
....................    delay_ms(1);
04390:  MOVLW  01
04392:  MOVLB  5
04394:  MOVWF  xEE
04396:  MOVLB  0
04398:  CALL   03D0
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
0439C:  MOVLW  00
0439E:  BTFSC  x60.0
043A0:  MOVLW  01
043A2:  MOVLB  5
043A4:  SUBWF  xE9,W
043A6:  BNZ   43AE
043A8:  MOVLW  E8
043AA:  MOVWF  F8B
043AC:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
043AE:  MOVLW  00
043B0:  MOVLB  0
043B2:  BTFSC  x60.1
043B4:  MOVLW  01
043B6:  MOVLB  5
043B8:  SUBWF  xE9,W
043BA:  BNZ   43C2
043BC:  MOVLW  E8
043BE:  MOVWF  F8B
043C0:  BSF    F86.1
043C2:  MOVLB  0
043C4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
043C6:  MOVLB  1
043C8:  MOVF   x65,W
043CA:  XORLW  00
043CC:  MOVLB  0
043CE:  BZ    43D6
043D0:  XORLW  01
043D2:  BZ    43E8
043D4:  BRA    43F8
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
043D6:  MOVLB  5
043D8:  CLRF   xE9
043DA:  MOVLB  0
043DC:  RCALL  4150
....................          state = 1;
043DE:  MOVLW  01
043E0:  MOVLB  1
043E2:  MOVWF  x65
....................       break;
043E4:  MOVLB  0
043E6:  BRA    43F8
....................       case 1:
....................          set_nanoDAC_outputs(chY);
043E8:  MOVLW  01
043EA:  MOVLB  5
043EC:  MOVWF  xE9
043EE:  MOVLB  0
043F0:  RCALL  4150
....................          state = 0;
043F2:  MOVLB  1
043F4:  CLRF   x65
....................       break;
043F6:  MOVLB  0
....................    }
043F8:  GOTO   942A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00834:  MOVLB  5
00836:  CLRF   xEF
00838:  CLRF   xEE
0083A:  CLRF   xED
0083C:  CLRF   xEC
0083E:  MOVLB  0
00840:  RCALL  080A
....................    output_low(_SYNC_X);
00842:  MOVLW  E8
00844:  MOVWF  F8B
00846:  BCF    F86.2
....................    output_low(_SYNC_Y);
00848:  MOVWF  F8B
0084A:  BCF    F86.1
....................    output_high(_SYNC_X);
0084C:  MOVWF  F8B
0084E:  BSF    F86.2
....................    output_high(_SYNC_Y);
00850:  MOVWF  F8B
00852:  BSF    F86.1
00854:  GOTO   9412 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
0087A:  MOVLB  5
0087C:  MOVF   xEA,W
0087E:  SUBLW  03
00880:  BTFSS  FD8.0
00882:  BRA    0A00
....................    {
....................       for (int i = 0; i <numParam; i ++)
00884:  CLRF   xEB
00886:  MOVF   xEB,W
00888:  SUBLW  06
0088A:  BNC   08DE
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
0088C:  MOVLB  6
0088E:  CLRF   x2B
00890:  MOVFF  5EA,62A
00894:  CLRF   x2D
00896:  MOVLW  B5
00898:  MOVWF  x2C
0089A:  MOVLB  0
0089C:  RCALL  0858
0089E:  MOVFF  02,5ED
008A2:  MOVFF  01,5EC
008A6:  MOVLW  06
008A8:  MOVLB  5
008AA:  ADDWF  xEC,F
008AC:  MOVLW  00
008AE:  ADDWFC xED,F
008B0:  MOVLB  6
008B2:  CLRF   x2B
008B4:  MOVFF  5EB,62A
008B8:  CLRF   x2D
008BA:  MOVLW  19
008BC:  MOVWF  x2C
008BE:  MOVLB  0
008C0:  RCALL  0858
008C2:  MOVF   01,W
008C4:  MOVLB  5
008C6:  ADDWF  xEC,F
008C8:  MOVF   02,W
008CA:  ADDWFC xED,F
008CC:  MOVLW  66
008CE:  ADDWF  xEC,W
008D0:  MOVWF  FE9
008D2:  MOVLW  01
008D4:  ADDWFC xED,W
008D6:  MOVWF  FEA
008D8:  CLRF   FEF
008DA:  INCF   xEB,F
008DC:  BRA    0886
....................       }
....................       SERcmd[recNum].t = 0;
008DE:  MOVLB  6
008E0:  CLRF   x2B
008E2:  MOVFF  5EA,62A
008E6:  CLRF   x2D
008E8:  MOVLW  B5
008EA:  MOVWF  x2C
008EC:  MOVLB  0
008EE:  RCALL  0858
008F0:  MOVFF  01,5EC
008F4:  MOVLW  05
008F6:  MOVLB  5
008F8:  ADDWF  01,W
008FA:  MOVWF  01
008FC:  MOVLW  00
008FE:  ADDWFC 02,W
00900:  MOVWF  03
00902:  MOVF   01,W
00904:  ADDLW  66
00906:  MOVWF  FE9
00908:  MOVLW  01
0090A:  ADDWFC 03,W
0090C:  MOVWF  FEA
0090E:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00910:  MOVLB  6
00912:  CLRF   x2B
00914:  MOVFF  5EA,62A
00918:  CLRF   x2D
0091A:  MOVLW  B5
0091C:  MOVWF  x2C
0091E:  MOVLB  0
00920:  RCALL  0858
00922:  MOVFF  01,5EC
00926:  MOVLW  01
00928:  MOVLB  5
0092A:  ADDWF  01,W
0092C:  MOVWF  01
0092E:  MOVLW  00
00930:  ADDWFC 02,W
00932:  MOVWF  03
00934:  MOVF   01,W
00936:  ADDLW  66
00938:  MOVWF  FE9
0093A:  MOVLW  01
0093C:  ADDWFC 03,W
0093E:  MOVWF  FEA
00940:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00942:  MOVLB  6
00944:  CLRF   x2B
00946:  MOVFF  5EA,62A
0094A:  CLRF   x2D
0094C:  MOVLW  B5
0094E:  MOVWF  x2C
00950:  MOVLB  0
00952:  RCALL  0858
00954:  MOVFF  01,5EC
00958:  MOVLW  02
0095A:  MOVLB  5
0095C:  ADDWF  01,W
0095E:  MOVWF  01
00960:  MOVLW  00
00962:  ADDWFC 02,W
00964:  MOVWF  03
00966:  MOVF   01,W
00968:  ADDLW  66
0096A:  MOVWF  FE9
0096C:  MOVLW  01
0096E:  ADDWFC 03,W
00970:  MOVWF  FEA
00972:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00974:  MOVLB  6
00976:  CLRF   x2B
00978:  MOVFF  5EA,62A
0097C:  CLRF   x2D
0097E:  MOVLW  B5
00980:  MOVWF  x2C
00982:  MOVLB  0
00984:  RCALL  0858
00986:  MOVFF  01,5EC
0098A:  MOVLW  03
0098C:  MOVLB  5
0098E:  ADDWF  01,W
00990:  MOVWF  01
00992:  MOVLW  00
00994:  ADDWFC 02,W
00996:  MOVWF  03
00998:  MOVF   01,W
0099A:  ADDLW  66
0099C:  MOVWF  FE9
0099E:  MOVLW  01
009A0:  ADDWFC 03,W
009A2:  MOVWF  FEA
009A4:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
009A6:  MOVLB  6
009A8:  CLRF   x2B
009AA:  MOVFF  5EA,62A
009AE:  CLRF   x2D
009B0:  MOVLW  B5
009B2:  MOVWF  x2C
009B4:  MOVLB  0
009B6:  RCALL  0858
009B8:  MOVFF  01,5EC
009BC:  MOVLW  04
009BE:  MOVLB  5
009C0:  ADDWF  01,W
009C2:  MOVWF  01
009C4:  MOVLW  00
009C6:  ADDWFC 02,W
009C8:  MOVWF  03
009CA:  MOVF   01,W
009CC:  ADDLW  66
009CE:  MOVWF  FE9
009D0:  MOVLW  01
009D2:  ADDWFC 03,W
009D4:  MOVWF  FEA
009D6:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
009D8:  MOVLB  6
009DA:  CLRF   x2B
009DC:  MOVFF  5EA,62A
009E0:  CLRF   x2D
009E2:  MOVLW  B5
009E4:  MOVWF  x2C
009E6:  MOVLB  0
009E8:  RCALL  0858
009EA:  MOVLW  66
009EC:  MOVLB  5
009EE:  ADDWF  01,W
009F0:  MOVWF  FE9
009F2:  MOVLW  01
009F4:  ADDWFC 02,W
009F6:  MOVWF  FEA
009F8:  BCF    FEF.0
....................       retData[0] = '\0';
009FA:  MOVLB  4
009FC:  CLRF   x3C
009FE:  MOVLB  5
....................    }
00A00:  MOVLB  0
00A02:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
049A6:  MOVLB  6
049A8:  CLRF   x2B
049AA:  MOVFF  43A,62A
049AE:  CLRF   x2D
049B0:  MOVLW  B5
049B2:  MOVWF  x2C
049B4:  MOVLB  0
049B6:  CALL   0858
049BA:  MOVFF  02,5EB
049BE:  MOVFF  01,5EA
049C2:  MOVLW  66
049C4:  MOVLB  5
049C6:  ADDWF  01,W
049C8:  MOVWF  FE9
049CA:  MOVLW  01
049CC:  ADDWFC 02,W
049CE:  MOVWF  FEA
049D0:  BTFSC  FEF.0
049D2:  BRA    49F4
....................    {
....................       if (SRI == SWI) return FALSE;
049D4:  MOVLB  4
049D6:  MOVF   x3B,W
049D8:  SUBWF  x3A,W
049DA:  BNZ   49E2
049DC:  MOVLW  00
049DE:  MOVWF  01
049E0:  BRA    49FA
....................       SRI +=1;
049E2:  MOVLW  01
049E4:  ADDWF  x3A,F
....................       if (SRI >= numRecords) SRI=0;
049E6:  MOVF   x3A,W
049E8:  SUBLW  03
049EA:  BC    49EE
049EC:  CLRF   x3A
049EE:  MOVLB  0
049F0:  BRA    49A6
049F2:  MOVLB  5
....................    }
....................    return TRUE;
049F4:  MOVLW  01
049F6:  MOVWF  01
049F8:  MOVLB  4
049FA:  MOVLB  0
049FC:  GOTO   8F8C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
04430:  MOVLW  01
04432:  MOVLB  4
04434:  ADDWF  x3B,F
....................    if (SWI >= numRecords) SWI=0;
04436:  MOVF   x3B,W
04438:  SUBLW  03
0443A:  BC    443E
0443C:  CLRF   x3B
0443E:  MOVLB  0
04440:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4DF
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xDF.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
04442:  MOVLW  93
04444:  MOVWF  F89
04446:  BSF    F84.5
04448:  MOVLB  E
0444A:  BTFSS  xC8.4
0444C:  BRA    444A
0444E:  MOVLW  93
04450:  MOVWF  F89
04452:  BSF    F84.5
04454:  MOVLB  5
04456:  MOVFF  5F0,F99
0445A:  NOP   
0445C:  BTFSS  F9D.1
0445E:  BRA    445C
04460:  MOVLW  93
04462:  MOVWF  F89
04464:  BCF    F84.5
04466:  MOVLB  0
04468:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xDC,W
000F6:  ADDLW  A0
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,662
00104:  MOVFF  FE9,661
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  662,FEA
00110:  MOVFF  661,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xDC,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xDC,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xDC
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xDE.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
043FC:  CLRF   03
043FE:  MOVLB  4
04400:  MOVF   xDD,W
04402:  ADDLW  A0
04404:  MOVWF  FE9
04406:  MOVLW  04
04408:  ADDWFC 03,W
0440A:  MOVWF  FEA
0440C:  MOVFF  FEF,5EA
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
04410:  MOVLW  01
04412:  ADDWF  xDD,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
04414:  MOVF   xDD,W
04416:  SUBLW  3B
04418:  BC    441C
0441A:  CLRF   xDD
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
0441C:  MOVF   xDC,W
0441E:  SUBWF  xDD,W
04420:  BNZ   4424
04422:  BCF    xDE.0
....................    return data;
04424:  MOVLB  5
04426:  MOVFF  5EA,01
0442A:  MOVLB  0
0442C:  GOTO   44D0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
0448E:  MOVLB  4
04490:  BTFSS  xDE.0
04492:  BRA    49A0
04494:  MOVLB  6
04496:  CLRF   x2B
04498:  MOVFF  43B,62A
0449C:  CLRF   x2D
0449E:  MOVLW  B5
044A0:  MOVWF  x2C
044A2:  MOVLB  0
044A4:  CALL   0858
044A8:  MOVFF  02,5EB
044AC:  MOVFF  01,5EA
044B0:  MOVLW  66
044B2:  MOVLB  5
044B4:  ADDWF  01,W
044B6:  MOVWF  01
044B8:  MOVLW  01
044BA:  ADDWFC 02,W
044BC:  MOVWF  03
044BE:  MOVFF  01,FE9
044C2:  MOVWF  FEA
044C4:  BTFSS  FEF.0
044C6:  BRA    44CC
044C8:  MOVLB  4
044CA:  BRA    49A0
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
044CC:  MOVLB  0
044CE:  BRA    43FC
044D0:  MOVFF  01,5E9
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
044D4:  MOVLB  5
044D6:  MOVF   xE9,W
044D8:  SUBLW  0D
044DA:  BZ    44E2
044DC:  MOVF   xE9,W
044DE:  SUBLW  20
044E0:  BNZ   44E4
....................       {
....................       }
044E2:  BRA    499A
....................       else if (rxChar == UART_SOT_CHAR)
044E4:  MOVF   xE9,W
044E6:  SUBLW  7E
044E8:  BNZ   452C
....................       {
....................          resetSERcmd(SWI);
044EA:  MOVFF  43B,5EA
044EE:  MOVLB  0
044F0:  CALL   087A
....................          SERcmd[SWI].t = rxChar;
044F4:  MOVLB  6
044F6:  CLRF   x2B
044F8:  MOVFF  43B,62A
044FC:  CLRF   x2D
044FE:  MOVLW  B5
04500:  MOVWF  x2C
04502:  MOVLB  0
04504:  CALL   0858
04508:  MOVFF  01,5EA
0450C:  MOVLW  05
0450E:  MOVLB  5
04510:  ADDWF  01,W
04512:  MOVWF  01
04514:  MOVLW  00
04516:  ADDWFC 02,W
04518:  MOVWF  03
0451A:  MOVF   01,W
0451C:  ADDLW  66
0451E:  MOVWF  FE9
04520:  MOVLW  01
04522:  ADDWFC 03,W
04524:  MOVWF  FEA
04526:  MOVFF  5E9,FEF
....................       }
0452A:  BRA    499A
....................       else if (rxChar >= oneByteCmdTestValue)
0452C:  MOVF   xE9,W
0452E:  SUBLW  7F
04530:  BC    459E
....................       {
....................          resetSERcmd(SWI);
04532:  MOVFF  43B,5EA
04536:  MOVLB  0
04538:  CALL   087A
....................          SERcmd[SWI].t = rxChar;
0453C:  MOVLB  6
0453E:  CLRF   x2B
04540:  MOVFF  43B,62A
04544:  CLRF   x2D
04546:  MOVLW  B5
04548:  MOVWF  x2C
0454A:  MOVLB  0
0454C:  CALL   0858
04550:  MOVFF  01,5EA
04554:  MOVLW  05
04556:  MOVLB  5
04558:  ADDWF  01,W
0455A:  MOVWF  01
0455C:  MOVLW  00
0455E:  ADDWFC 02,W
04560:  MOVWF  03
04562:  MOVF   01,W
04564:  ADDLW  66
04566:  MOVWF  FE9
04568:  MOVLW  01
0456A:  ADDWFC 03,W
0456C:  MOVWF  FEA
0456E:  MOVFF  5E9,FEF
....................          SERcmd[SWI].full = TRUE;
04572:  MOVLB  6
04574:  CLRF   x2B
04576:  MOVFF  43B,62A
0457A:  CLRF   x2D
0457C:  MOVLW  B5
0457E:  MOVWF  x2C
04580:  MOVLB  0
04582:  CALL   0858
04586:  MOVLW  66
04588:  MOVLB  5
0458A:  ADDWF  01,W
0458C:  MOVWF  FE9
0458E:  MOVLW  01
04590:  ADDWFC 02,W
04592:  MOVWF  FEA
04594:  BSF    FEF.0
....................          setNextSERWriteIndex();
04596:  MOVLB  0
04598:  RCALL  4430
....................       }
0459A:  BRA    4998
0459C:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
0459E:  MOVF   xE9,W
045A0:  SUBLW  0A
045A2:  BTFSS  FD8.2
045A4:  BRA    46B2
....................       {
....................          SERcmd[SWI].full = TRUE;
045A6:  MOVLB  6
045A8:  CLRF   x2B
045AA:  MOVFF  43B,62A
045AE:  CLRF   x2D
045B0:  MOVLW  B5
045B2:  MOVWF  x2C
045B4:  MOVLB  0
045B6:  CALL   0858
045BA:  MOVLW  66
045BC:  MOVLB  5
045BE:  ADDWF  01,W
045C0:  MOVWF  FE9
045C2:  MOVLW  01
045C4:  ADDWFC 02,W
045C6:  MOVWF  FEA
045C8:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
045CA:  MOVLB  6
045CC:  CLRF   x2B
045CE:  MOVFF  43B,62A
045D2:  CLRF   x2D
045D4:  MOVLW  B5
045D6:  MOVWF  x2C
045D8:  MOVLB  0
045DA:  CALL   0858
045DE:  MOVFF  01,5EA
045E2:  MOVLW  04
045E4:  ADDWF  01,W
045E6:  MOVWF  01
045E8:  MOVLW  00
045EA:  ADDWFC 02,W
045EC:  MOVWF  03
045EE:  MOVF   01,W
045F0:  ADDLW  66
045F2:  MOVWF  01
045F4:  MOVLW  01
045F6:  ADDWFC 03,F
045F8:  MOVFF  01,5EA
045FC:  MOVFF  03,5EB
04600:  MOVLB  6
04602:  CLRF   x2B
04604:  MOVFF  43B,62A
04608:  CLRF   x2D
0460A:  MOVLW  B5
0460C:  MOVWF  x2C
0460E:  MOVLB  0
04610:  CALL   0858
04614:  MOVFF  01,5EC
04618:  MOVLW  02
0461A:  MOVLB  5
0461C:  ADDWF  01,W
0461E:  MOVWF  01
04620:  MOVLW  00
04622:  ADDWFC 02,W
04624:  MOVWF  03
04626:  MOVF   01,W
04628:  ADDLW  66
0462A:  MOVWF  FE9
0462C:  MOVLW  01
0462E:  ADDWFC 03,W
04630:  MOVWF  FEA
04632:  MOVFF  FEF,5EC
04636:  MOVFF  5EB,FEA
0463A:  MOVFF  5EA,FE9
0463E:  MOVFF  5EC,FEF
....................          SERcmd[SWI].chrIndex = 0;
04642:  MOVLB  6
04644:  CLRF   x2B
04646:  MOVFF  43B,62A
0464A:  CLRF   x2D
0464C:  MOVLW  B5
0464E:  MOVWF  x2C
04650:  MOVLB  0
04652:  CALL   0858
04656:  MOVFF  01,5EA
0465A:  MOVLW  01
0465C:  MOVLB  5
0465E:  ADDWF  01,W
04660:  MOVWF  01
04662:  MOVLW  00
04664:  ADDWFC 02,W
04666:  MOVWF  03
04668:  MOVF   01,W
0466A:  ADDLW  66
0466C:  MOVWF  FE9
0466E:  MOVLW  01
04670:  ADDWFC 03,W
04672:  MOVWF  FEA
04674:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
04676:  MOVLB  6
04678:  CLRF   x2B
0467A:  MOVFF  43B,62A
0467E:  CLRF   x2D
04680:  MOVLW  B5
04682:  MOVWF  x2C
04684:  MOVLB  0
04686:  CALL   0858
0468A:  MOVFF  01,5EA
0468E:  MOVLW  02
04690:  MOVLB  5
04692:  ADDWF  01,W
04694:  MOVWF  01
04696:  MOVLW  00
04698:  ADDWFC 02,W
0469A:  MOVWF  03
0469C:  MOVF   01,W
0469E:  ADDLW  66
046A0:  MOVWF  FE9
046A2:  MOVLW  01
046A4:  ADDWFC 03,W
046A6:  MOVWF  FEA
046A8:  CLRF   FEF
....................          setNextSERWriteIndex();
046AA:  MOVLB  0
046AC:  RCALL  4430
....................       }
046AE:  BRA    4998
046B0:  MOVLB  5
....................       else if (rxChar == delimiter)
046B2:  MOVF   xE9,W
046B4:  SUBLW  2C
046B6:  BNZ   477A
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
046B8:  MOVLB  6
046BA:  CLRF   x2B
046BC:  MOVFF  43B,62A
046C0:  CLRF   x2D
046C2:  MOVLW  B5
046C4:  MOVWF  x2C
046C6:  MOVLB  0
046C8:  CALL   0858
046CC:  MOVFF  02,5EB
046D0:  MOVFF  01,5EA
046D4:  MOVLW  02
046D6:  MOVLB  5
046D8:  ADDWF  01,W
046DA:  MOVWF  01
046DC:  MOVLW  00
046DE:  ADDWFC 02,W
046E0:  MOVWF  03
046E2:  MOVF   01,W
046E4:  ADDLW  66
046E6:  MOVWF  FE9
046E8:  MOVLW  01
046EA:  ADDWFC 03,W
046EC:  MOVWF  FEA
046EE:  MOVF   FEF,W
046F0:  SUBLW  05
046F2:  BNC   4762
....................          {
....................             SERcmd[SWI].paramIndex +=1;
046F4:  MOVLB  6
046F6:  CLRF   x2B
046F8:  MOVFF  43B,62A
046FC:  CLRF   x2D
046FE:  MOVLW  B5
04700:  MOVWF  x2C
04702:  MOVLB  0
04704:  CALL   0858
04708:  MOVFF  01,5EA
0470C:  MOVLW  02
0470E:  MOVLB  5
04710:  ADDWF  01,W
04712:  MOVWF  01
04714:  MOVLW  00
04716:  ADDWFC 02,W
04718:  MOVWF  03
0471A:  MOVF   01,W
0471C:  ADDLW  66
0471E:  MOVWF  FE9
04720:  MOVLW  01
04722:  ADDWFC 03,W
04724:  MOVWF  FEA
04726:  MOVLW  01
04728:  ADDWF  FEF,W
0472A:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0472C:  MOVLB  6
0472E:  CLRF   x2B
04730:  MOVFF  43B,62A
04734:  CLRF   x2D
04736:  MOVLW  B5
04738:  MOVWF  x2C
0473A:  MOVLB  0
0473C:  CALL   0858
04740:  MOVFF  01,5EA
04744:  MOVLW  01
04746:  MOVLB  5
04748:  ADDWF  01,W
0474A:  MOVWF  01
0474C:  MOVLW  00
0474E:  ADDWFC 02,W
04750:  MOVWF  03
04752:  MOVF   01,W
04754:  ADDLW  66
04756:  MOVWF  FE9
04758:  MOVLW  01
0475A:  ADDWFC 03,W
0475C:  MOVWF  FEA
0475E:  CLRF   FEF
....................          }
04760:  BRA    4778
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
04762:  MOVFF  43B,5EA
04766:  MOVLB  0
04768:  CALL   087A
....................             fprintf(SERIAL, retData);
0476C:  MOVLW  04
0476E:  MOVWF  FEA
04770:  MOVLW  3C
04772:  MOVWF  FE9
04774:  RCALL  446A
04776:  MOVLB  5
....................          }
....................       }
04778:  BRA    499A
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
0477A:  MOVLB  6
0477C:  CLRF   x2B
0477E:  MOVFF  43B,62A
04782:  CLRF   x2D
04784:  MOVLW  B5
04786:  MOVWF  x2C
04788:  MOVLB  0
0478A:  CALL   0858
0478E:  MOVFF  02,5EB
04792:  MOVFF  01,5EA
04796:  MOVLW  01
04798:  MOVLB  5
0479A:  ADDWF  01,W
0479C:  MOVWF  01
0479E:  MOVLW  00
047A0:  ADDWFC 02,W
047A2:  MOVWF  03
047A4:  MOVF   01,W
047A6:  ADDLW  66
047A8:  MOVWF  FE9
047AA:  MOVLW  01
047AC:  ADDWFC 03,W
047AE:  MOVWF  FEA
047B0:  MOVF   FEF,W
047B2:  SUBLW  18
047B4:  BTFSS  FD8.0
047B6:  BRA    4984
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
047B8:  MOVLB  6
047BA:  CLRF   x2B
047BC:  MOVFF  43B,62A
047C0:  CLRF   x2D
047C2:  MOVLW  B5
047C4:  MOVWF  x2C
047C6:  MOVLB  0
047C8:  CALL   0858
047CC:  MOVFF  02,5EB
047D0:  MOVFF  01,5EA
047D4:  MOVLW  06
047D6:  MOVLB  5
047D8:  ADDWF  xEA,F
047DA:  MOVLW  00
047DC:  ADDWFC xEB,F
047DE:  MOVLB  6
047E0:  CLRF   x2B
047E2:  MOVFF  43B,62A
047E6:  CLRF   x2D
047E8:  MOVLW  B5
047EA:  MOVWF  x2C
047EC:  MOVLB  0
047EE:  CALL   0858
047F2:  MOVFF  02,5ED
047F6:  MOVFF  01,5EC
047FA:  MOVLW  02
047FC:  ADDWF  01,W
047FE:  MOVWF  01
04800:  MOVLW  00
04802:  ADDWFC 02,W
04804:  MOVWF  03
04806:  MOVF   01,W
04808:  ADDLW  66
0480A:  MOVWF  FE9
0480C:  MOVLW  01
0480E:  ADDWFC 03,W
04810:  MOVWF  FEA
04812:  MOVLB  6
04814:  CLRF   x2B
04816:  MOVFF  FEF,62A
0481A:  CLRF   x2D
0481C:  MOVLW  19
0481E:  MOVWF  x2C
04820:  MOVLB  0
04822:  CALL   0858
04826:  MOVFF  02,03
0482A:  MOVF   01,W
0482C:  MOVLB  5
0482E:  ADDWF  xEA,F
04830:  MOVF   02,W
04832:  ADDWFC xEB,F
04834:  MOVLB  6
04836:  CLRF   x2B
04838:  MOVFF  43B,62A
0483C:  CLRF   x2D
0483E:  MOVLW  B5
04840:  MOVWF  x2C
04842:  MOVLB  0
04844:  CALL   0858
04848:  MOVFF  01,5EC
0484C:  MOVLW  01
0484E:  MOVLB  5
04850:  ADDWF  01,W
04852:  MOVWF  01
04854:  MOVLW  00
04856:  ADDWFC 02,W
04858:  MOVWF  03
0485A:  MOVF   01,W
0485C:  ADDLW  66
0485E:  MOVWF  FE9
04860:  MOVLW  01
04862:  ADDWFC 03,W
04864:  MOVWF  FEA
04866:  MOVF   FEF,W
04868:  ADDWF  xEA,W
0486A:  MOVWF  01
0486C:  MOVLW  00
0486E:  ADDWFC xEB,W
04870:  MOVWF  03
04872:  MOVF   01,W
04874:  ADDLW  66
04876:  MOVWF  FE9
04878:  MOVLW  01
0487A:  ADDWFC 03,W
0487C:  MOVWF  FEA
0487E:  MOVFF  5E9,FEF
....................             SERcmd[SWI].chrIndex += 1;
04882:  MOVLB  6
04884:  CLRF   x2B
04886:  MOVFF  43B,62A
0488A:  CLRF   x2D
0488C:  MOVLW  B5
0488E:  MOVWF  x2C
04890:  MOVLB  0
04892:  CALL   0858
04896:  MOVFF  01,5EA
0489A:  MOVLW  01
0489C:  MOVLB  5
0489E:  ADDWF  01,W
048A0:  MOVWF  01
048A2:  MOVLW  00
048A4:  ADDWFC 02,W
048A6:  MOVWF  03
048A8:  MOVF   01,W
048AA:  ADDLW  66
048AC:  MOVWF  FE9
048AE:  MOVLW  01
048B0:  ADDWFC 03,W
048B2:  MOVWF  FEA
048B4:  MOVLW  01
048B6:  ADDWF  FEF,W
048B8:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
048BA:  MOVLB  6
048BC:  CLRF   x2B
048BE:  MOVFF  43B,62A
048C2:  CLRF   x2D
048C4:  MOVLW  B5
048C6:  MOVWF  x2C
048C8:  MOVLB  0
048CA:  CALL   0858
048CE:  MOVFF  02,5EB
048D2:  MOVFF  01,5EA
048D6:  MOVLW  06
048D8:  MOVLB  5
048DA:  ADDWF  xEA,F
048DC:  MOVLW  00
048DE:  ADDWFC xEB,F
048E0:  MOVLB  6
048E2:  CLRF   x2B
048E4:  MOVFF  43B,62A
048E8:  CLRF   x2D
048EA:  MOVLW  B5
048EC:  MOVWF  x2C
048EE:  MOVLB  0
048F0:  CALL   0858
048F4:  MOVFF  02,5ED
048F8:  MOVFF  01,5EC
048FC:  MOVLW  02
048FE:  ADDWF  01,W
04900:  MOVWF  01
04902:  MOVLW  00
04904:  ADDWFC 02,W
04906:  MOVWF  03
04908:  MOVF   01,W
0490A:  ADDLW  66
0490C:  MOVWF  FE9
0490E:  MOVLW  01
04910:  ADDWFC 03,W
04912:  MOVWF  FEA
04914:  MOVLB  6
04916:  CLRF   x2B
04918:  MOVFF  FEF,62A
0491C:  CLRF   x2D
0491E:  MOVLW  19
04920:  MOVWF  x2C
04922:  MOVLB  0
04924:  CALL   0858
04928:  MOVFF  02,03
0492C:  MOVF   01,W
0492E:  MOVLB  5
04930:  ADDWF  xEA,F
04932:  MOVF   02,W
04934:  ADDWFC xEB,F
04936:  MOVLB  6
04938:  CLRF   x2B
0493A:  MOVFF  43B,62A
0493E:  CLRF   x2D
04940:  MOVLW  B5
04942:  MOVWF  x2C
04944:  MOVLB  0
04946:  CALL   0858
0494A:  MOVFF  01,5EC
0494E:  MOVLW  01
04950:  MOVLB  5
04952:  ADDWF  01,W
04954:  MOVWF  01
04956:  MOVLW  00
04958:  ADDWFC 02,W
0495A:  MOVWF  03
0495C:  MOVF   01,W
0495E:  ADDLW  66
04960:  MOVWF  FE9
04962:  MOVLW  01
04964:  ADDWFC 03,W
04966:  MOVWF  FEA
04968:  MOVF   FEF,W
0496A:  ADDWF  xEA,W
0496C:  MOVWF  01
0496E:  MOVLW  00
04970:  ADDWFC xEB,W
04972:  MOVWF  03
04974:  MOVF   01,W
04976:  ADDLW  66
04978:  MOVWF  FE9
0497A:  MOVLW  01
0497C:  ADDWFC 03,W
0497E:  MOVWF  FEA
04980:  CLRF   FEF
....................          }
04982:  BRA    499A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
04984:  MOVFF  43B,5EA
04988:  MOVLB  0
0498A:  CALL   087A
....................             fprintf(SERIAL, retData);
0498E:  MOVLW  04
04990:  MOVWF  FEA
04992:  MOVLW  3C
04994:  MOVWF  FE9
04996:  RCALL  446A
04998:  MOVLB  5
....................          }
....................       }
0499A:  MOVLB  0
0499C:  BRA    448E
0499E:  MOVLB  4
....................    }          
049A0:  MOVLB  0
049A2:  GOTO   942E (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00A04:  MOVLB  5
00A06:  CLRF   xE9
00A08:  MOVF   xE9,W
00A0A:  SUBLW  03
00A0C:  BNC   0A1C
....................    {
....................       resetSERcmd(i);
00A0E:  MOVFF  5E9,5EA
00A12:  MOVLB  0
00A14:  RCALL  087A
00A16:  MOVLB  5
00A18:  INCF   xE9,F
00A1A:  BRA    0A08
....................    }
....................    enable_interrupts(INT_RDA);
00A1C:  MOVLB  E
00A1E:  BSF    xC0.5
00A20:  MOVLB  0
00A22:  GOTO   9416 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;   // error = set value - measured
....................    PID[ch].I += (err * PID[ch].kI);       // integral value 
....................    float P = err * PID[ch].kP;            // proportional value
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold); // derivative value
....................    PID[ch].CV = P + PID[ch].I + D;        // new control variable
....................    if (PID[ch].CV > 100) 
....................    {
....................       PID[ch].CV = 100;// limit output to 100%
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
.................... //!   if (adcVals[ch].pReal != PID[ch].PV) pid_update(ch);
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0,0,0,0,0,0,0},
....................    {0.01,0,0,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00A26:  MOVLB  E
00A28:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00A2A:  MOVLW  01
00A2C:  MOVWF  FD1
00A2E:  MOVLW  07
00A30:  MOVWF  FCE
00A32:  CLRF   FCF
00A34:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00A36:  MOVLB  1
00A38:  CLRF   x54
00A3A:  CLRF   x53
00A3C:  CLRF   x52
00A3E:  CLRF   x51
....................    timeoutReg1 = 0;
00A40:  CLRF   x58
00A42:  CLRF   x57
00A44:  CLRF   x56
00A46:  CLRF   x55
....................    timeoutReg2 = 0;
00A48:  CLRF   x5C
00A4A:  CLRF   x5B
00A4C:  CLRF   x5A
00A4E:  CLRF   x59
....................    intTimeoutReg = 50;
00A50:  CLRF   x5E
00A52:  MOVLW  32
00A54:  MOVWF  x5D
....................    enable_interrupts(INT_TIMER1);
00A56:  MOVLB  E
00A58:  BSF    xC1.0
00A5A:  MOVLB  0
00A5C:  GOTO   941A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00246:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00248:  MOVLW  0B
0024A:  MOVWF  FCD
0024C:  MOVLW  DB
0024E:  MOVWF  FCC
00250:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00252:  MOVLB  1
00254:  MOVF   x54,F
00256:  BNZ   0266
00258:  MOVF   x53,F
0025A:  BNZ   0266
0025C:  MOVF   x52,F
0025E:  BNZ   0266
00260:  MOVF   x51,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x51,F
0026A:  MOVLW  00
0026C:  SUBWFB x52,F
0026E:  SUBWFB x53,F
00270:  SUBWFB x54,F
00272:  BRA    027C
00274:  CLRF   x54
00276:  CLRF   x53
00278:  CLRF   x52
0027A:  CLRF   x51
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
0027C:  MOVF   x58,F
0027E:  BNZ   028E
00280:  MOVF   x57,F
00282:  BNZ   028E
00284:  MOVF   x56,F
00286:  BNZ   028E
00288:  MOVF   x55,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x55,F
00292:  MOVLW  00
00294:  SUBWFB x56,F
00296:  SUBWFB x57,F
00298:  SUBWFB x58,F
0029A:  BRA    02A4
0029C:  CLRF   x58
0029E:  CLRF   x57
002A0:  CLRF   x56
002A2:  CLRF   x55
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002A4:  MOVF   x5C,F
002A6:  BNZ   02B6
002A8:  MOVF   x5B,F
002AA:  BNZ   02B6
002AC:  MOVF   x5A,F
002AE:  BNZ   02B6
002B0:  MOVF   x59,W
002B2:  SUBLW  0A
002B4:  BC    02C4
002B6:  MOVLW  0A
002B8:  SUBWF  x59,F
002BA:  MOVLW  00
002BC:  SUBWFB x5A,F
002BE:  SUBWFB x5B,F
002C0:  SUBWFB x5C,F
002C2:  BRA    02CC
002C4:  CLRF   x5C
002C6:  CLRF   x5B
002C8:  CLRF   x5A
002CA:  CLRF   x59
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002CC:  MOVF   x5D,F
002CE:  BNZ   02D4
002D0:  MOVF   x5E,F
002D2:  BZ    0310
....................    {
....................       timeCounter+=10;
002D4:  MOVLW  0A
002D6:  MOVLB  4
002D8:  ADDWF  xE2,F
002DA:  MOVLW  00
002DC:  ADDWFC xE3,F
002DE:  ADDWFC xE4,F
002E0:  ADDWFC xE5,F
....................       if (timeCounter >= intTimeoutReg)
002E2:  MOVF   xE5,F
002E4:  BNZ   0300
002E6:  MOVF   xE4,F
002E8:  BNZ   0300
002EA:  MOVLB  1
002EC:  MOVF   x5E,W
002EE:  MOVLB  4
002F0:  SUBWF  xE3,W
002F2:  BNC   030E
002F4:  BNZ   0300
002F6:  MOVLB  1
002F8:  MOVF   x5D,W
002FA:  MOVLB  4
002FC:  SUBWF  xE2,W
002FE:  BNC   030E
....................       {
....................          sensor_monitor_interrupt_task();
00300:  MOVLB  0
00302:  BRA    01C0
....................          timeCounter = 0;
00304:  MOVLB  4
00306:  CLRF   xE5
00308:  CLRF   xE4
0030A:  CLRF   xE3
0030C:  CLRF   xE2
0030E:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0,0,0,0,0,0,0},
....................    {0.01,0,0,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00310:  MOVLB  E
00312:  BCF    xC9.0
00314:  MOVLB  0
00316:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
04B2A:  MOVLW  04
04B2C:  MOVLB  6
04B2E:  MOVWF  x2B
04B30:  MOVLW  3C
04B32:  MOVWF  x2A
04B34:  MOVLB  0
04B36:  RCALL  4A3A
04B38:  MOVFF  02,03
04B3C:  MOVF   01,W
04B3E:  ADDLW  3C
04B40:  MOVLB  5
04B42:  MOVWF  xF4
04B44:  MOVLW  04
04B46:  ADDWFC 02,W
04B48:  MOVWF  xF5
04B4A:  MOVFF  FE8,4E1
04B4E:  MOVFF  5F4,4E0
04B52:  MOVLW  1A
04B54:  MOVWF  FF6
04B56:  MOVLW  03
04B58:  MOVWF  FF7
04B5A:  MOVLB  0
04B5C:  RCALL  4B0A
04B5E:  MOVLW  2C
04B60:  MOVLB  6
04B62:  MOVWF  x39
04B64:  MOVLB  0
04B66:  RCALL  4AEA
....................    return SUCCESS;
04B68:  MOVLW  00
04B6A:  MOVWF  01
04B6C:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
04B6E:  MOVLW  04
04B70:  MOVLB  6
04B72:  MOVWF  x2B
04B74:  MOVLW  3C
04B76:  MOVWF  x2A
04B78:  MOVLB  0
04B7A:  RCALL  4A3A
04B7C:  MOVFF  02,03
04B80:  MOVF   01,W
04B82:  ADDLW  3C
04B84:  MOVLB  5
04B86:  MOVWF  xF4
04B88:  MOVLW  04
04B8A:  ADDWFC 02,W
04B8C:  MOVWF  xF5
04B8E:  MOVFF  FE8,4E1
04B92:  MOVFF  5F4,4E0
04B96:  MOVLW  24
04B98:  MOVWF  FF6
04B9A:  MOVLW  03
04B9C:  MOVWF  FF7
04B9E:  MOVLB  0
04BA0:  RCALL  4B0A
04BA2:  MOVLW  2C
04BA4:  MOVLB  6
04BA6:  MOVWF  x39
04BA8:  MOVLB  0
04BAA:  RCALL  4AEA
....................    return SUCCESS;
04BAC:  MOVLW  00
04BAE:  MOVWF  01
04BB0:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04FF6:  MOVLB  6
04FF8:  CLRF   x2B
04FFA:  MOVFF  5E8,62A
04FFE:  CLRF   x2D
05000:  MOVLW  B5
05002:  MOVWF  x2C
05004:  MOVLB  0
05006:  CALL   0858
0500A:  MOVFF  02,5F6
0500E:  MOVFF  01,5F5
05012:  MOVLW  06
05014:  MOVLB  5
05016:  ADDWF  xF5,F
05018:  MOVLW  00
0501A:  ADDWFC xF6,F
0501C:  MOVLW  32
0501E:  ADDWF  xF5,W
05020:  MOVWF  01
05022:  MOVLW  00
05024:  ADDWFC xF6,W
05026:  MOVWF  03
05028:  MOVF   01,W
0502A:  ADDLW  66
0502C:  MOVWF  01
0502E:  MOVLW  01
05030:  ADDWFC 03,F
05032:  MOVFF  01,5F5
05036:  MOVFF  03,5F6
0503A:  MOVFF  03,61D
0503E:  MOVFF  01,61C
05042:  MOVLB  0
05044:  RCALL  4BB2
05046:  MOVF   01,F
05048:  BNZ   5052
0504A:  MOVLW  02
0504C:  MOVWF  01
0504E:  BRA    5166
05050:  BRA    50B0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05052:  MOVLB  6
05054:  CLRF   x2B
05056:  MOVFF  5E8,62A
0505A:  CLRF   x2D
0505C:  MOVLW  B5
0505E:  MOVWF  x2C
05060:  MOVLB  0
05062:  CALL   0858
05066:  MOVFF  02,5F6
0506A:  MOVFF  01,5F5
0506E:  MOVLW  06
05070:  MOVLB  5
05072:  ADDWF  xF5,F
05074:  MOVLW  00
05076:  ADDWFC xF6,F
05078:  MOVLW  32
0507A:  ADDWF  xF5,W
0507C:  MOVWF  01
0507E:  MOVLW  00
05080:  ADDWFC xF6,W
05082:  MOVWF  03
05084:  MOVF   01,W
05086:  ADDLW  66
05088:  MOVWF  01
0508A:  MOVLW  01
0508C:  ADDWFC 03,F
0508E:  MOVFF  01,5F5
05092:  MOVFF  03,5F6
05096:  MOVFF  03,61D
0509A:  MOVFF  01,61C
0509E:  MOVLB  6
050A0:  CLRF   x1F
050A2:  CLRF   x1E
050A4:  MOVLW  0A
050A6:  MOVWF  x20
050A8:  MOVLB  0
050AA:  RCALL  4CA2
050AC:  MOVFF  01,5F4
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'X');
050B0:  MOVLW  01
050B2:  MOVLB  5
050B4:  SUBWF  xF4,W
050B6:  MOVWF  xF6
050B8:  CLRF   xF8
050BA:  MOVLW  60
050BC:  MOVWF  xF7
050BE:  MOVLB  0
050C0:  CALL   3C1A
050C4:  BTFSC  01.0
050C6:  BRA    5106
050C8:  MOVLW  04
050CA:  MOVLB  6
050CC:  MOVWF  x2B
050CE:  MOVLW  3C
050D0:  MOVWF  x2A
050D2:  MOVLB  0
050D4:  RCALL  4A3A
050D6:  MOVFF  02,03
050DA:  MOVF   01,W
050DC:  ADDLW  3C
050DE:  MOVLB  5
050E0:  MOVWF  xF5
050E2:  MOVLW  04
050E4:  ADDWFC 02,W
050E6:  MOVWF  xF6
050E8:  MOVFF  FE8,4E1
050EC:  MOVFF  5F5,4E0
050F0:  MOVLW  58
050F2:  MOVLB  6
050F4:  MOVWF  x39
050F6:  MOVLB  0
050F8:  RCALL  4AEA
050FA:  MOVLW  2C
050FC:  MOVLB  6
050FE:  MOVWF  x39
05100:  MOVLB  0
05102:  RCALL  4AEA
05104:  BRA    5162
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'Y');
05106:  MOVLW  01
05108:  MOVLB  5
0510A:  SUBWF  xF4,W
0510C:  MOVWF  xF6
0510E:  CLRF   xF8
05110:  MOVLW  60
05112:  MOVWF  xF7
05114:  MOVLB  0
05116:  CALL   3C1A
0511A:  BTFSS  01.0
0511C:  BRA    515C
0511E:  MOVLW  04
05120:  MOVLB  6
05122:  MOVWF  x2B
05124:  MOVLW  3C
05126:  MOVWF  x2A
05128:  MOVLB  0
0512A:  RCALL  4A3A
0512C:  MOVFF  02,03
05130:  MOVF   01,W
05132:  ADDLW  3C
05134:  MOVLB  5
05136:  MOVWF  xF5
05138:  MOVLW  04
0513A:  ADDWFC 02,W
0513C:  MOVWF  xF6
0513E:  MOVFF  FE8,4E1
05142:  MOVFF  5F5,4E0
05146:  MOVLW  59
05148:  MOVLB  6
0514A:  MOVWF  x39
0514C:  MOVLB  0
0514E:  RCALL  4AEA
05150:  MOVLW  2C
05152:  MOVLB  6
05154:  MOVWF  x39
05156:  MOVLB  0
05158:  RCALL  4AEA
0515A:  BRA    5162
....................    else return INV_PARAM;
0515C:  MOVLW  02
0515E:  MOVWF  01
05160:  BRA    5166
....................    
....................    return SUCCESS;
05162:  MOVLW  00
05164:  MOVWF  01
05166:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
051AA:  MOVLB  6
051AC:  CLRF   x2B
051AE:  MOVFF  5E8,62A
051B2:  CLRF   x2D
051B4:  MOVLW  B5
051B6:  MOVWF  x2C
051B8:  MOVLB  0
051BA:  CALL   0858
051BE:  MOVFF  02,5F7
051C2:  MOVFF  01,5F6
051C6:  MOVLW  06
051C8:  MOVLB  5
051CA:  ADDWF  xF6,F
051CC:  MOVLW  00
051CE:  ADDWFC xF7,F
051D0:  MOVLW  32
051D2:  ADDWF  xF6,W
051D4:  MOVWF  01
051D6:  MOVLW  00
051D8:  ADDWFC xF7,W
051DA:  MOVWF  03
051DC:  MOVF   01,W
051DE:  ADDLW  66
051E0:  MOVWF  01
051E2:  MOVLW  01
051E4:  ADDWFC 03,F
051E6:  MOVFF  01,5F6
051EA:  MOVFF  03,5F7
051EE:  MOVFF  03,61D
051F2:  MOVFF  01,61C
051F6:  MOVLB  0
051F8:  RCALL  4BB2
051FA:  MOVF   01,F
051FC:  BNZ   5206
051FE:  MOVLW  02
05200:  MOVWF  01
05202:  BRA    5360
05204:  BRA    5264
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05206:  MOVLB  6
05208:  CLRF   x2B
0520A:  MOVFF  5E8,62A
0520E:  CLRF   x2D
05210:  MOVLW  B5
05212:  MOVWF  x2C
05214:  MOVLB  0
05216:  CALL   0858
0521A:  MOVFF  02,5F7
0521E:  MOVFF  01,5F6
05222:  MOVLW  06
05224:  MOVLB  5
05226:  ADDWF  xF6,F
05228:  MOVLW  00
0522A:  ADDWFC xF7,F
0522C:  MOVLW  32
0522E:  ADDWF  xF6,W
05230:  MOVWF  01
05232:  MOVLW  00
05234:  ADDWFC xF7,W
05236:  MOVWF  03
05238:  MOVF   01,W
0523A:  ADDLW  66
0523C:  MOVWF  01
0523E:  MOVLW  01
05240:  ADDWFC 03,F
05242:  MOVFF  01,5F6
05246:  MOVFF  03,5F7
0524A:  MOVFF  03,61D
0524E:  MOVFF  01,61C
05252:  MOVLB  6
05254:  CLRF   x1F
05256:  CLRF   x1E
05258:  MOVLW  0A
0525A:  MOVWF  x20
0525C:  MOVLB  0
0525E:  RCALL  4CA2
05260:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05264:  MOVLB  6
05266:  CLRF   x2B
05268:  MOVFF  5E8,62A
0526C:  CLRF   x2D
0526E:  MOVLW  B5
05270:  MOVWF  x2C
05272:  MOVLB  0
05274:  CALL   0858
05278:  MOVFF  02,5F7
0527C:  MOVFF  01,5F6
05280:  MOVLW  06
05282:  MOVLB  5
05284:  ADDWF  xF6,F
05286:  MOVLW  00
05288:  ADDWFC xF7,F
0528A:  MOVLW  4B
0528C:  ADDWF  xF6,W
0528E:  MOVWF  01
05290:  MOVLW  00
05292:  ADDWFC xF7,W
05294:  MOVWF  03
05296:  MOVF   01,W
05298:  ADDLW  66
0529A:  MOVWF  01
0529C:  MOVLW  01
0529E:  ADDWFC 03,F
052A0:  MOVFF  01,5F6
052A4:  MOVFF  03,5F7
052A8:  MOVFF  03,62B
052AC:  MOVFF  01,62A
052B0:  MOVLB  0
052B2:  CALL   4A3A
052B6:  MOVFF  02,03
052BA:  MOVF   01,W
052BC:  SUBLW  01
052BE:  BNZ   52C4
052C0:  MOVF   03,F
052C2:  BZ    52CC
052C4:  MOVLW  02
052C6:  MOVWF  01
052C8:  BRA    5360
052CA:  BRA    530C
....................    else arg2 = SERcmd[rec].p[3][0];
052CC:  MOVLB  6
052CE:  CLRF   x2B
052D0:  MOVFF  5E8,62A
052D4:  CLRF   x2D
052D6:  MOVLW  B5
052D8:  MOVWF  x2C
052DA:  MOVLB  0
052DC:  CALL   0858
052E0:  MOVFF  02,5F7
052E4:  MOVFF  01,5F6
052E8:  MOVLW  06
052EA:  MOVLB  5
052EC:  ADDWF  xF6,F
052EE:  MOVLW  00
052F0:  ADDWFC xF7,F
052F2:  MOVLW  4B
052F4:  ADDWF  xF6,F
052F6:  MOVLW  00
052F8:  ADDWFC xF7,F
052FA:  MOVLW  66
052FC:  ADDWF  xF6,W
052FE:  MOVWF  FE9
05300:  MOVLW  01
05302:  ADDWFC xF7,W
05304:  MOVWF  FEA
05306:  MOVFF  FEF,5F5
0530A:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
0530C:  MOVLB  5
0530E:  MOVF   xF5,W
05310:  SUBLW  58
05312:  BNZ   5330
05314:  MOVLW  01
05316:  SUBWF  xF4,W
05318:  MOVWF  xF6
0531A:  MOVFF  FE8,60B
0531E:  MOVLB  6
05320:  CLRF   x0C
05322:  CLRF   x0E
05324:  MOVLW  60
05326:  MOVWF  x0D
05328:  MOVLB  0
0532A:  RCALL  5168
0532C:  BRA    535C
0532E:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
05330:  MOVF   xF5,W
05332:  SUBLW  59
05334:  BNZ   5354
05336:  MOVLW  01
05338:  SUBWF  xF4,W
0533A:  MOVWF  xF6
0533C:  MOVFF  FE8,60B
05340:  MOVLW  01
05342:  MOVLB  6
05344:  MOVWF  x0C
05346:  CLRF   x0E
05348:  MOVLW  60
0534A:  MOVWF  x0D
0534C:  MOVLB  0
0534E:  RCALL  5168
05350:  BRA    535C
05352:  MOVLB  5
....................    else return INV_PARAM;
05354:  MOVLW  02
05356:  MOVWF  01
05358:  MOVLB  0
0535A:  BRA    5360
....................    
....................    return SUCCESS;
0535C:  MOVLW  00
0535E:  MOVWF  01
05360:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05362:  MOVLB  6
05364:  CLRF   x2B
05366:  MOVFF  5E8,62A
0536A:  CLRF   x2D
0536C:  MOVLW  B5
0536E:  MOVWF  x2C
05370:  MOVLB  0
05372:  CALL   0858
05376:  MOVFF  02,5F6
0537A:  MOVFF  01,5F5
0537E:  MOVLW  06
05380:  MOVLB  5
05382:  ADDWF  xF5,F
05384:  MOVLW  00
05386:  ADDWFC xF6,F
05388:  MOVLW  32
0538A:  ADDWF  xF5,W
0538C:  MOVWF  01
0538E:  MOVLW  00
05390:  ADDWFC xF6,W
05392:  MOVWF  03
05394:  MOVF   01,W
05396:  ADDLW  66
05398:  MOVWF  01
0539A:  MOVLW  01
0539C:  ADDWFC 03,F
0539E:  MOVFF  01,5F5
053A2:  MOVFF  03,5F6
053A6:  MOVFF  03,61D
053AA:  MOVFF  01,61C
053AE:  MOVLB  0
053B0:  RCALL  4BB2
053B2:  MOVF   01,F
053B4:  BNZ   53BE
053B6:  MOVLW  02
053B8:  MOVWF  01
053BA:  BRA    54CA
053BC:  BRA    541C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
053BE:  MOVLB  6
053C0:  CLRF   x2B
053C2:  MOVFF  5E8,62A
053C6:  CLRF   x2D
053C8:  MOVLW  B5
053CA:  MOVWF  x2C
053CC:  MOVLB  0
053CE:  CALL   0858
053D2:  MOVFF  02,5F6
053D6:  MOVFF  01,5F5
053DA:  MOVLW  06
053DC:  MOVLB  5
053DE:  ADDWF  xF5,F
053E0:  MOVLW  00
053E2:  ADDWFC xF6,F
053E4:  MOVLW  32
053E6:  ADDWF  xF5,W
053E8:  MOVWF  01
053EA:  MOVLW  00
053EC:  ADDWFC xF6,W
053EE:  MOVWF  03
053F0:  MOVF   01,W
053F2:  ADDLW  66
053F4:  MOVWF  01
053F6:  MOVLW  01
053F8:  ADDWFC 03,F
053FA:  MOVFF  01,5F5
053FE:  MOVFF  03,5F6
05402:  MOVFF  03,61D
05406:  MOVFF  01,61C
0540A:  MOVLB  6
0540C:  CLRF   x1F
0540E:  CLRF   x1E
05410:  MOVLW  0A
05412:  MOVWF  x20
05414:  MOVLB  0
05416:  RCALL  4CA2
05418:  MOVFF  01,5F4
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MANUAL,");
0541C:  MOVLW  01
0541E:  MOVLB  5
05420:  SUBWF  xF4,W
05422:  MOVWF  xF6
05424:  CLRF   xF8
05426:  MOVLW  61
05428:  MOVWF  xF7
0542A:  MOVLB  0
0542C:  CALL   3C1A
05430:  BTFSC  01.0
05432:  BRA    546E
05434:  MOVLW  04
05436:  MOVLB  6
05438:  MOVWF  x2B
0543A:  MOVLW  3C
0543C:  MOVWF  x2A
0543E:  MOVLB  0
05440:  CALL   4A3A
05444:  MOVFF  02,03
05448:  MOVF   01,W
0544A:  ADDLW  3C
0544C:  MOVLB  5
0544E:  MOVWF  xF5
05450:  MOVLW  04
05452:  ADDWFC 02,W
05454:  MOVWF  xF6
05456:  MOVFF  FE8,4E1
0545A:  MOVFF  5F5,4E0
0545E:  MOVLW  2A
05460:  MOVWF  FF6
05462:  MOVLW  03
05464:  MOVWF  FF7
05466:  MOVLB  0
05468:  CALL   4B0A
0546C:  BRA    54C6
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MAGSNS,");
0546E:  MOVLW  01
05470:  MOVLB  5
05472:  SUBWF  xF4,W
05474:  MOVWF  xF6
05476:  CLRF   xF8
05478:  MOVLW  61
0547A:  MOVWF  xF7
0547C:  MOVLB  0
0547E:  CALL   3C1A
05482:  BTFSS  01.0
05484:  BRA    54C0
05486:  MOVLW  04
05488:  MOVLB  6
0548A:  MOVWF  x2B
0548C:  MOVLW  3C
0548E:  MOVWF  x2A
05490:  MOVLB  0
05492:  CALL   4A3A
05496:  MOVFF  02,03
0549A:  MOVF   01,W
0549C:  ADDLW  3C
0549E:  MOVLB  5
054A0:  MOVWF  xF5
054A2:  MOVLW  04
054A4:  ADDWFC 02,W
054A6:  MOVWF  xF6
054A8:  MOVFF  FE8,4E1
054AC:  MOVFF  5F5,4E0
054B0:  MOVLW  32
054B2:  MOVWF  FF6
054B4:  MOVLW  03
054B6:  MOVWF  FF7
054B8:  MOVLB  0
054BA:  CALL   4B0A
054BE:  BRA    54C6
....................    else return INV_PARAM;
054C0:  MOVLW  02
054C2:  MOVWF  01
054C4:  BRA    54CA
....................    
....................    return SUCCESS;
054C6:  MOVLW  00
054C8:  MOVWF  01
054CA:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
054CC:  MOVLW  4D
054CE:  MOVLB  5
054D0:  MOVWF  xF9
054D2:  MOVLW  41
054D4:  MOVWF  xFA
054D6:  MOVLW  4E
054D8:  MOVWF  xFB
054DA:  MOVLW  55
054DC:  MOVWF  xFC
054DE:  MOVLW  41
054E0:  MOVWF  xFD
054E2:  MOVLW  4C
054E4:  MOVWF  xFE
054E6:  CLRF   xFF
054E8:  MOVLW  05
054EA:  MOVWF  xF8
054EC:  MOVLW  F9
054EE:  MOVWF  xF7
....................    char *s_magsns = "MAGSNS";
054F0:  MOVLW  4D
054F2:  MOVLB  6
054F4:  MOVWF  x02
054F6:  MOVLW  41
054F8:  MOVWF  x03
054FA:  MOVLW  47
054FC:  MOVWF  x04
054FE:  MOVLW  53
05500:  MOVWF  x05
05502:  MOVLW  4E
05504:  MOVWF  x06
05506:  MOVLW  53
05508:  MOVWF  x07
0550A:  CLRF   x08
0550C:  MOVLW  06
0550E:  MOVWF  x01
05510:  MOVLW  02
05512:  MOVWF  x00
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05514:  CLRF   x2B
05516:  MOVFF  5E8,62A
0551A:  CLRF   x2D
0551C:  MOVLW  B5
0551E:  MOVWF  x2C
05520:  MOVLB  0
05522:  CALL   0858
05526:  MOVFF  02,60A
0552A:  MOVFF  01,609
0552E:  MOVLW  06
05530:  MOVLB  6
05532:  ADDWF  x09,F
05534:  MOVLW  00
05536:  ADDWFC x0A,F
05538:  MOVLW  32
0553A:  ADDWF  x09,W
0553C:  MOVWF  01
0553E:  MOVLW  00
05540:  ADDWFC x0A,W
05542:  MOVWF  03
05544:  MOVF   01,W
05546:  ADDLW  66
05548:  MOVWF  01
0554A:  MOVLW  01
0554C:  ADDWFC 03,F
0554E:  MOVFF  01,609
05552:  MOVFF  03,60A
05556:  MOVFF  03,61D
0555A:  MOVFF  01,61C
0555E:  MOVLB  0
05560:  CALL   4BB2
05564:  MOVF   01,F
05566:  BNZ   5570
05568:  MOVLW  02
0556A:  MOVWF  01
0556C:  BRA    56EA
0556E:  BRA    55CE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05570:  MOVLB  6
05572:  CLRF   x2B
05574:  MOVFF  5E8,62A
05578:  CLRF   x2D
0557A:  MOVLW  B5
0557C:  MOVWF  x2C
0557E:  MOVLB  0
05580:  CALL   0858
05584:  MOVFF  02,60A
05588:  MOVFF  01,609
0558C:  MOVLW  06
0558E:  MOVLB  6
05590:  ADDWF  x09,F
05592:  MOVLW  00
05594:  ADDWFC x0A,F
05596:  MOVLW  32
05598:  ADDWF  x09,W
0559A:  MOVWF  01
0559C:  MOVLW  00
0559E:  ADDWFC x0A,W
055A0:  MOVWF  03
055A2:  MOVF   01,W
055A4:  ADDLW  66
055A6:  MOVWF  01
055A8:  MOVLW  01
055AA:  ADDWFC 03,F
055AC:  MOVFF  01,609
055B0:  MOVFF  03,60A
055B4:  MOVFF  03,61D
055B8:  MOVFF  01,61C
055BC:  CLRF   x1F
055BE:  CLRF   x1E
055C0:  MOVLW  0A
055C2:  MOVWF  x20
055C4:  MOVLB  0
055C6:  CALL   4CA2
055CA:  MOVFF  01,5F4
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
055CE:  MOVLB  6
055D0:  CLRF   x2B
055D2:  MOVFF  5E8,62A
055D6:  CLRF   x2D
055D8:  MOVLW  B5
055DA:  MOVWF  x2C
055DC:  MOVLB  0
055DE:  CALL   0858
055E2:  MOVFF  02,60A
055E6:  MOVFF  01,609
055EA:  MOVLW  06
055EC:  MOVLB  6
055EE:  ADDWF  x09,F
055F0:  MOVLW  00
055F2:  ADDWFC x0A,F
055F4:  MOVLW  4B
055F6:  ADDWF  x09,W
055F8:  MOVWF  01
055FA:  MOVLW  00
055FC:  ADDWFC x0A,W
055FE:  MOVWF  03
05600:  MOVF   01,W
05602:  ADDLW  66
05604:  MOVWF  01
05606:  MOVLW  01
05608:  ADDWFC 03,F
0560A:  MOVFF  01,609
0560E:  MOVFF  03,60A
05612:  MOVFF  03,62B
05616:  MOVFF  01,62A
0561A:  MOVLB  0
0561C:  CALL   4A3A
05620:  MOVFF  02,03
05624:  MOVF   01,W
05626:  BNZ   5634
05628:  MOVF   03,F
0562A:  BNZ   5634
0562C:  MOVLW  02
0562E:  MOVWF  01
05630:  BRA    56EA
05632:  BRA    567A
....................    else arg2 = SERcmd[rec].p[3];
05634:  MOVLB  6
05636:  CLRF   x2B
05638:  MOVFF  5E8,62A
0563C:  CLRF   x2D
0563E:  MOVLW  B5
05640:  MOVWF  x2C
05642:  MOVLB  0
05644:  CALL   0858
05648:  MOVFF  02,60A
0564C:  MOVFF  01,609
05650:  MOVLW  06
05652:  MOVLB  6
05654:  ADDWF  x09,F
05656:  MOVLW  00
05658:  ADDWFC x0A,F
0565A:  MOVLW  4B
0565C:  ADDWF  x09,W
0565E:  MOVWF  01
05660:  MOVLW  00
05662:  ADDWFC x0A,W
05664:  MOVWF  03
05666:  MOVF   01,W
05668:  ADDLW  66
0566A:  MOVWF  01
0566C:  MOVLW  01
0566E:  ADDWFC 03,F
05670:  MOVFF  01,5F5
05674:  MOVFF  03,5F6
05678:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
0567A:  MOVFF  5F8,62B
0567E:  MOVFF  5F7,62A
05682:  MOVFF  5F6,62D
05686:  MOVFF  5F5,62C
0568A:  CALL   4A72
0568E:  MOVF   01,F
05690:  BNZ   56AC
05692:  MOVLW  01
05694:  MOVLB  5
05696:  SUBWF  xF4,W
05698:  MOVLB  6
0569A:  MOVWF  x09
0569C:  MOVWF  x0B
0569E:  CLRF   x0C
056A0:  CLRF   x0E
056A2:  MOVLW  61
056A4:  MOVWF  x0D
056A6:  MOVLB  0
056A8:  RCALL  5168
056AA:  BRA    56E6
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
056AC:  MOVFF  601,62B
056B0:  MOVFF  600,62A
056B4:  MOVFF  5F6,62D
056B8:  MOVFF  5F5,62C
056BC:  CALL   4A72
056C0:  MOVF   01,F
056C2:  BNZ   56E0
056C4:  MOVLW  01
056C6:  MOVLB  5
056C8:  SUBWF  xF4,W
056CA:  MOVLB  6
056CC:  MOVWF  x09
056CE:  MOVWF  x0B
056D0:  MOVLW  01
056D2:  MOVWF  x0C
056D4:  CLRF   x0E
056D6:  MOVLW  61
056D8:  MOVWF  x0D
056DA:  MOVLB  0
056DC:  RCALL  5168
056DE:  BRA    56E6
....................    else return INV_PARAM;
056E0:  MOVLW  02
056E2:  MOVWF  01
056E4:  BRA    56EA
....................    
....................    return SUCCESS;
056E6:  MOVLW  00
056E8:  MOVWF  01
056EA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05972:  MOVLB  6
05974:  CLRF   x2B
05976:  MOVFF  5E8,62A
0597A:  CLRF   x2D
0597C:  MOVLW  B5
0597E:  MOVWF  x2C
05980:  MOVLB  0
05982:  CALL   0858
05986:  MOVFF  02,601
0598A:  MOVFF  01,600
0598E:  MOVLW  06
05990:  MOVLB  6
05992:  ADDWF  x00,F
05994:  MOVLW  00
05996:  ADDWFC x01,F
05998:  MOVLW  32
0599A:  ADDWF  x00,W
0599C:  MOVWF  01
0599E:  MOVLW  00
059A0:  ADDWFC x01,W
059A2:  MOVWF  03
059A4:  MOVF   01,W
059A6:  ADDLW  66
059A8:  MOVWF  01
059AA:  MOVLW  01
059AC:  ADDWFC 03,F
059AE:  MOVFF  01,600
059B2:  MOVFF  03,601
059B6:  MOVFF  03,61D
059BA:  MOVFF  01,61C
059BE:  MOVLB  0
059C0:  CALL   4BB2
059C4:  MOVF   01,F
059C6:  BNZ   59D0
059C8:  MOVLW  02
059CA:  MOVWF  01
059CC:  BRA    5D8A
059CE:  BRA    5A2E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
059D0:  MOVLB  6
059D2:  CLRF   x2B
059D4:  MOVFF  5E8,62A
059D8:  CLRF   x2D
059DA:  MOVLW  B5
059DC:  MOVWF  x2C
059DE:  MOVLB  0
059E0:  CALL   0858
059E4:  MOVFF  02,601
059E8:  MOVFF  01,600
059EC:  MOVLW  06
059EE:  MOVLB  6
059F0:  ADDWF  x00,F
059F2:  MOVLW  00
059F4:  ADDWFC x01,F
059F6:  MOVLW  32
059F8:  ADDWF  x00,W
059FA:  MOVWF  01
059FC:  MOVLW  00
059FE:  ADDWFC x01,W
05A00:  MOVWF  03
05A02:  MOVF   01,W
05A04:  ADDLW  66
05A06:  MOVWF  01
05A08:  MOVLW  01
05A0A:  ADDWFC 03,F
05A0C:  MOVFF  01,600
05A10:  MOVFF  03,601
05A14:  MOVFF  03,61D
05A18:  MOVFF  01,61C
05A1C:  CLRF   x1F
05A1E:  CLRF   x1E
05A20:  MOVLW  0A
05A22:  MOVWF  x20
05A24:  MOVLB  0
05A26:  CALL   4CA2
05A2A:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05A2E:  MOVLB  6
05A30:  CLRF   x2B
05A32:  MOVFF  5E8,62A
05A36:  CLRF   x2D
05A38:  MOVLW  B5
05A3A:  MOVWF  x2C
05A3C:  MOVLB  0
05A3E:  CALL   0858
05A42:  MOVFF  02,601
05A46:  MOVFF  01,600
05A4A:  MOVLW  06
05A4C:  MOVLB  6
05A4E:  ADDWF  x00,F
05A50:  MOVLW  00
05A52:  ADDWFC x01,F
05A54:  MOVLW  4B
05A56:  ADDWF  x00,W
05A58:  MOVWF  01
05A5A:  MOVLW  00
05A5C:  ADDWFC x01,W
05A5E:  MOVWF  03
05A60:  MOVF   01,W
05A62:  ADDLW  66
05A64:  MOVWF  01
05A66:  MOVLW  01
05A68:  ADDWFC 03,F
05A6A:  MOVFF  01,600
05A6E:  MOVFF  03,601
05A72:  MOVFF  03,62B
05A76:  MOVFF  01,62A
05A7A:  MOVLB  0
05A7C:  CALL   4A3A
05A80:  MOVFF  02,03
05A84:  MOVF   01,W
05A86:  SUBLW  01
05A88:  BNZ   5A8E
05A8A:  MOVF   03,F
05A8C:  BZ    5A96
05A8E:  MOVLW  02
05A90:  MOVWF  01
05A92:  BRA    5D8A
05A94:  BRA    5AD6
....................    else arg2 = SERcmd[rec].p[3][0];
05A96:  MOVLB  6
05A98:  CLRF   x2B
05A9A:  MOVFF  5E8,62A
05A9E:  CLRF   x2D
05AA0:  MOVLW  B5
05AA2:  MOVWF  x2C
05AA4:  MOVLB  0
05AA6:  CALL   0858
05AAA:  MOVFF  02,601
05AAE:  MOVFF  01,600
05AB2:  MOVLW  06
05AB4:  MOVLB  6
05AB6:  ADDWF  x00,F
05AB8:  MOVLW  00
05ABA:  ADDWFC x01,F
05ABC:  MOVLW  4B
05ABE:  ADDWF  x00,F
05AC0:  MOVLW  00
05AC2:  ADDWFC x01,F
05AC4:  MOVLW  66
05AC6:  ADDWF  x00,W
05AC8:  MOVWF  FE9
05ACA:  MOVLW  01
05ACC:  ADDWFC x01,W
05ACE:  MOVWF  FEA
05AD0:  MOVFF  FEF,5F5
05AD4:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kP);
05AD6:  MOVLB  5
05AD8:  MOVF   xF5,W
05ADA:  SUBLW  50
05ADC:  BNZ   5B50
05ADE:  MOVLW  04
05AE0:  MOVLB  6
05AE2:  MOVWF  x2B
05AE4:  MOVLW  3C
05AE6:  MOVWF  x2A
05AE8:  MOVLB  0
05AEA:  CALL   4A3A
05AEE:  MOVFF  02,03
05AF2:  MOVF   01,W
05AF4:  ADDLW  3C
05AF6:  MOVLB  6
05AF8:  MOVWF  x00
05AFA:  MOVLW  04
05AFC:  ADDWFC 02,W
05AFE:  MOVWF  x01
05B00:  MOVLW  01
05B02:  MOVLB  5
05B04:  SUBWF  xF4,W
05B06:  MULLW  20
05B08:  MOVF   FF3,W
05B0A:  MOVLB  6
05B0C:  CLRF   x03
05B0E:  MOVWF  x02
05B10:  MOVLW  20
05B12:  ADDWF  x02,W
05B14:  MOVWF  FE9
05B16:  MOVLW  00
05B18:  ADDWFC x03,W
05B1A:  MOVWF  FEA
05B1C:  MOVFF  FEF,62C
05B20:  MOVFF  FEC,62D
05B24:  MOVFF  FEC,62E
05B28:  MOVFF  FEC,62F
05B2C:  MOVFF  601,4E1
05B30:  MOVFF  600,4E0
05B34:  MOVLW  89
05B36:  MOVWF  FE9
05B38:  MOVLW  02
05B3A:  MOVWF  x30
05B3C:  MOVLB  0
05B3E:  RCALL  57C2
05B40:  MOVLW  2C
05B42:  MOVLB  6
05B44:  MOVWF  x39
05B46:  MOVLB  0
05B48:  CALL   4AEA
05B4C:  BRA    5D86
05B4E:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kI);
05B50:  MOVF   xF5,W
05B52:  SUBLW  49
05B54:  BNZ   5BD0
05B56:  MOVLW  04
05B58:  MOVLB  6
05B5A:  MOVWF  x2B
05B5C:  MOVLW  3C
05B5E:  MOVWF  x2A
05B60:  MOVLB  0
05B62:  CALL   4A3A
05B66:  MOVF   01,W
05B68:  ADDLW  3C
05B6A:  MOVLB  6
05B6C:  MOVWF  x00
05B6E:  MOVLW  04
05B70:  ADDWFC 02,W
05B72:  MOVWF  x01
05B74:  MOVLW  01
05B76:  MOVLB  5
05B78:  SUBWF  xF4,W
05B7A:  MULLW  20
05B7C:  MOVF   FF3,W
05B7E:  MOVLB  6
05B80:  CLRF   x03
05B82:  MOVWF  x02
05B84:  MOVLW  04
05B86:  ADDWF  x02,W
05B88:  MOVWF  01
05B8A:  MOVLW  00
05B8C:  ADDWFC x03,W
05B8E:  MOVWF  03
05B90:  MOVF   01,W
05B92:  ADDLW  20
05B94:  MOVWF  FE9
05B96:  MOVLW  00
05B98:  ADDWFC 03,W
05B9A:  MOVWF  FEA
05B9C:  MOVFF  FEF,62C
05BA0:  MOVFF  FEC,62D
05BA4:  MOVFF  FEC,62E
05BA8:  MOVFF  FEC,62F
05BAC:  MOVFF  601,4E1
05BB0:  MOVFF  600,4E0
05BB4:  MOVLW  89
05BB6:  MOVWF  FE9
05BB8:  MOVLW  02
05BBA:  MOVWF  x30
05BBC:  MOVLB  0
05BBE:  RCALL  57C2
05BC0:  MOVLW  2C
05BC2:  MOVLB  6
05BC4:  MOVWF  x39
05BC6:  MOVLB  0
05BC8:  CALL   4AEA
05BCC:  BRA    5D86
05BCE:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kD);
05BD0:  MOVF   xF5,W
05BD2:  SUBLW  44
05BD4:  BNZ   5C50
05BD6:  MOVLW  04
05BD8:  MOVLB  6
05BDA:  MOVWF  x2B
05BDC:  MOVLW  3C
05BDE:  MOVWF  x2A
05BE0:  MOVLB  0
05BE2:  CALL   4A3A
05BE6:  MOVF   01,W
05BE8:  ADDLW  3C
05BEA:  MOVLB  6
05BEC:  MOVWF  x00
05BEE:  MOVLW  04
05BF0:  ADDWFC 02,W
05BF2:  MOVWF  x01
05BF4:  MOVLW  01
05BF6:  MOVLB  5
05BF8:  SUBWF  xF4,W
05BFA:  MULLW  20
05BFC:  MOVF   FF3,W
05BFE:  MOVLB  6
05C00:  CLRF   x03
05C02:  MOVWF  x02
05C04:  MOVLW  08
05C06:  ADDWF  x02,W
05C08:  MOVWF  01
05C0A:  MOVLW  00
05C0C:  ADDWFC x03,W
05C0E:  MOVWF  03
05C10:  MOVF   01,W
05C12:  ADDLW  20
05C14:  MOVWF  FE9
05C16:  MOVLW  00
05C18:  ADDWFC 03,W
05C1A:  MOVWF  FEA
05C1C:  MOVFF  FEF,62C
05C20:  MOVFF  FEC,62D
05C24:  MOVFF  FEC,62E
05C28:  MOVFF  FEC,62F
05C2C:  MOVFF  601,4E1
05C30:  MOVFF  600,4E0
05C34:  MOVLW  89
05C36:  MOVWF  FE9
05C38:  MOVLW  02
05C3A:  MOVWF  x30
05C3C:  MOVLB  0
05C3E:  RCALL  57C2
05C40:  MOVLW  2C
05C42:  MOVLB  6
05C44:  MOVWF  x39
05C46:  MOVLB  0
05C48:  CALL   4AEA
05C4C:  BRA    5D86
05C4E:  MOVLB  5
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%f,%f,%f", PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
05C50:  MOVF   xF5,W
05C52:  SUBLW  41
05C54:  BTFSS  FD8.2
05C56:  BRA    5D7E
05C58:  MOVLW  04
05C5A:  MOVLB  6
05C5C:  MOVWF  x2B
05C5E:  MOVLW  3C
05C60:  MOVWF  x2A
05C62:  MOVLB  0
05C64:  CALL   4A3A
05C68:  MOVF   01,W
05C6A:  ADDLW  3C
05C6C:  MOVLB  6
05C6E:  MOVWF  x00
05C70:  MOVLW  04
05C72:  ADDWFC 02,W
05C74:  MOVWF  x01
05C76:  MOVLW  01
05C78:  MOVLB  5
05C7A:  SUBWF  xF4,W
05C7C:  MULLW  20
05C7E:  MOVF   FF3,W
05C80:  MOVLB  6
05C82:  CLRF   x03
05C84:  MOVWF  x02
05C86:  MOVLW  20
05C88:  ADDWF  x02,W
05C8A:  MOVWF  FE9
05C8C:  MOVLW  00
05C8E:  ADDWFC x03,W
05C90:  MOVWF  FEA
05C92:  MOVFF  FEF,62C
05C96:  MOVFF  FEC,62D
05C9A:  MOVFF  FEC,62E
05C9E:  MOVFF  FEC,62F
05CA2:  MOVLW  01
05CA4:  MOVLB  5
05CA6:  SUBWF  xF4,W
05CA8:  MULLW  20
05CAA:  MOVF   FF3,W
05CAC:  MOVLB  6
05CAE:  CLRF   x09
05CB0:  MOVWF  x08
05CB2:  MOVLW  04
05CB4:  ADDWF  x08,W
05CB6:  MOVWF  01
05CB8:  MOVLW  00
05CBA:  ADDWFC x09,W
05CBC:  MOVWF  03
05CBE:  MOVF   01,W
05CC0:  ADDLW  20
05CC2:  MOVWF  FE9
05CC4:  MOVLW  00
05CC6:  ADDWFC 03,W
05CC8:  MOVWF  FEA
05CCA:  MOVFF  FEF,608
05CCE:  MOVFF  FEC,609
05CD2:  MOVFF  FEC,60A
05CD6:  MOVFF  FEC,60B
05CDA:  MOVLW  01
05CDC:  MOVLB  5
05CDE:  SUBWF  xF4,W
05CE0:  MULLW  20
05CE2:  MOVF   FF3,W
05CE4:  MOVLB  6
05CE6:  CLRF   x0D
05CE8:  MOVWF  x0C
05CEA:  MOVLW  08
05CEC:  ADDWF  x0C,W
05CEE:  MOVWF  01
05CF0:  MOVLW  00
05CF2:  ADDWFC x0D,W
05CF4:  MOVWF  03
05CF6:  MOVF   01,W
05CF8:  ADDLW  20
05CFA:  MOVWF  FE9
05CFC:  MOVLW  00
05CFE:  ADDWFC 03,W
05D00:  MOVWF  FEA
05D02:  MOVFF  FEF,60C
05D06:  MOVFF  FEC,60D
05D0A:  MOVFF  FEC,60E
05D0E:  MOVFF  FEC,60F
05D12:  MOVFF  601,4E1
05D16:  MOVFF  600,4E0
05D1A:  MOVLW  89
05D1C:  MOVWF  FE9
05D1E:  MOVLW  02
05D20:  MOVWF  x30
05D22:  MOVLB  0
05D24:  RCALL  57C2
05D26:  MOVLW  2C
05D28:  MOVLB  6
05D2A:  MOVWF  x39
05D2C:  MOVLB  0
05D2E:  CALL   4AEA
05D32:  MOVLW  89
05D34:  MOVWF  FE9
05D36:  MOVFF  60B,62F
05D3A:  MOVFF  60A,62E
05D3E:  MOVFF  609,62D
05D42:  MOVFF  608,62C
05D46:  MOVLW  02
05D48:  MOVLB  6
05D4A:  MOVWF  x30
05D4C:  MOVLB  0
05D4E:  RCALL  57C2
05D50:  MOVLW  2C
05D52:  MOVLB  6
05D54:  MOVWF  x39
05D56:  MOVLB  0
05D58:  CALL   4AEA
05D5C:  MOVLW  89
05D5E:  MOVWF  FE9
05D60:  MOVFF  60F,62F
05D64:  MOVFF  60E,62E
05D68:  MOVFF  60D,62D
05D6C:  MOVFF  60C,62C
05D70:  MOVLW  02
05D72:  MOVLB  6
05D74:  MOVWF  x30
05D76:  MOVLB  0
05D78:  RCALL  57C2
05D7A:  BRA    5D86
05D7C:  MOVLB  5
....................    else return INV_PARAM;
05D7E:  MOVLW  02
05D80:  MOVWF  01
05D82:  MOVLB  0
05D84:  BRA    5D8A
....................    
....................    return SUCCESS;
05D86:  MOVLW  00
05D88:  MOVWF  01
05D8A:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
060D6:  MOVLB  6
060D8:  CLRF   x2B
060DA:  MOVFF  5E8,62A
060DE:  CLRF   x2D
060E0:  MOVLW  B5
060E2:  MOVWF  x2C
060E4:  MOVLB  0
060E6:  CALL   0858
060EA:  MOVFF  02,5FB
060EE:  MOVFF  01,5FA
060F2:  MOVLW  06
060F4:  MOVLB  5
060F6:  ADDWF  xFA,F
060F8:  MOVLW  00
060FA:  ADDWFC xFB,F
060FC:  MOVLW  32
060FE:  ADDWF  xFA,W
06100:  MOVWF  01
06102:  MOVLW  00
06104:  ADDWFC xFB,W
06106:  MOVWF  03
06108:  MOVF   01,W
0610A:  ADDLW  66
0610C:  MOVWF  01
0610E:  MOVLW  01
06110:  ADDWFC 03,F
06112:  MOVFF  01,5FA
06116:  MOVFF  03,5FB
0611A:  MOVFF  03,61D
0611E:  MOVFF  01,61C
06122:  MOVLB  0
06124:  CALL   4BB2
06128:  MOVF   01,F
0612A:  BNZ   6134
0612C:  MOVLW  02
0612E:  MOVWF  01
06130:  BRA    63BA
06132:  BRA    6194
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06134:  MOVLB  6
06136:  CLRF   x2B
06138:  MOVFF  5E8,62A
0613C:  CLRF   x2D
0613E:  MOVLW  B5
06140:  MOVWF  x2C
06142:  MOVLB  0
06144:  CALL   0858
06148:  MOVFF  02,5FB
0614C:  MOVFF  01,5FA
06150:  MOVLW  06
06152:  MOVLB  5
06154:  ADDWF  xFA,F
06156:  MOVLW  00
06158:  ADDWFC xFB,F
0615A:  MOVLW  32
0615C:  ADDWF  xFA,W
0615E:  MOVWF  01
06160:  MOVLW  00
06162:  ADDWFC xFB,W
06164:  MOVWF  03
06166:  MOVF   01,W
06168:  ADDLW  66
0616A:  MOVWF  01
0616C:  MOVLW  01
0616E:  ADDWFC 03,F
06170:  MOVFF  01,5FA
06174:  MOVFF  03,5FB
06178:  MOVFF  03,61D
0617C:  MOVFF  01,61C
06180:  MOVLB  6
06182:  CLRF   x1F
06184:  CLRF   x1E
06186:  MOVLW  0A
06188:  MOVWF  x20
0618A:  MOVLB  0
0618C:  CALL   4CA2
06190:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06194:  MOVLB  6
06196:  CLRF   x2B
06198:  MOVFF  5E8,62A
0619C:  CLRF   x2D
0619E:  MOVLW  B5
061A0:  MOVWF  x2C
061A2:  MOVLB  0
061A4:  CALL   0858
061A8:  MOVFF  02,5FB
061AC:  MOVFF  01,5FA
061B0:  MOVLW  06
061B2:  MOVLB  5
061B4:  ADDWF  xFA,F
061B6:  MOVLW  00
061B8:  ADDWFC xFB,F
061BA:  MOVLW  4B
061BC:  ADDWF  xFA,W
061BE:  MOVWF  01
061C0:  MOVLW  00
061C2:  ADDWFC xFB,W
061C4:  MOVWF  03
061C6:  MOVF   01,W
061C8:  ADDLW  66
061CA:  MOVWF  01
061CC:  MOVLW  01
061CE:  ADDWFC 03,F
061D0:  MOVFF  01,5FA
061D4:  MOVFF  03,5FB
061D8:  MOVFF  03,62B
061DC:  MOVFF  01,62A
061E0:  MOVLB  0
061E2:  CALL   4A3A
061E6:  MOVFF  02,03
061EA:  MOVF   01,W
061EC:  SUBLW  01
061EE:  BNZ   61F4
061F0:  MOVF   03,F
061F2:  BZ    61FC
061F4:  MOVLW  02
061F6:  MOVWF  01
061F8:  BRA    63BA
061FA:  BRA    623C
....................    else arg2 = SERcmd[rec].p[3][0];
061FC:  MOVLB  6
061FE:  CLRF   x2B
06200:  MOVFF  5E8,62A
06204:  CLRF   x2D
06206:  MOVLW  B5
06208:  MOVWF  x2C
0620A:  MOVLB  0
0620C:  CALL   0858
06210:  MOVFF  02,5FB
06214:  MOVFF  01,5FA
06218:  MOVLW  06
0621A:  MOVLB  5
0621C:  ADDWF  xFA,F
0621E:  MOVLW  00
06220:  ADDWFC xFB,F
06222:  MOVLW  4B
06224:  ADDWF  xFA,F
06226:  MOVLW  00
06228:  ADDWFC xFB,F
0622A:  MOVLW  66
0622C:  ADDWF  xFA,W
0622E:  MOVWF  FE9
06230:  MOVLW  01
06232:  ADDWFC xFB,W
06234:  MOVWF  FEA
06236:  MOVFF  FEF,5F5
0623A:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0623C:  MOVLB  6
0623E:  CLRF   x2B
06240:  MOVFF  5E8,62A
06244:  CLRF   x2D
06246:  MOVLW  B5
06248:  MOVWF  x2C
0624A:  MOVLB  0
0624C:  CALL   0858
06250:  MOVFF  02,5FB
06254:  MOVFF  01,5FA
06258:  MOVLW  06
0625A:  MOVLB  5
0625C:  ADDWF  xFA,F
0625E:  MOVLW  00
06260:  ADDWFC xFB,F
06262:  MOVLW  64
06264:  ADDWF  xFA,W
06266:  MOVWF  01
06268:  MOVLW  00
0626A:  ADDWFC xFB,W
0626C:  MOVWF  03
0626E:  MOVF   01,W
06270:  ADDLW  66
06272:  MOVWF  01
06274:  MOVLW  01
06276:  ADDWFC 03,F
06278:  MOVFF  01,5FA
0627C:  MOVFF  03,5FB
06280:  MOVFF  03,5FE
06284:  MOVFF  01,5FD
06288:  MOVLB  0
0628A:  RCALL  5D8C
0628C:  MOVF   01,F
0628E:  BNZ   6298
06290:  MOVLW  02
06292:  MOVWF  01
06294:  BRA    63BA
06296:  BRA    6300
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06298:  MOVLB  6
0629A:  CLRF   x2B
0629C:  MOVFF  5E8,62A
062A0:  CLRF   x2D
062A2:  MOVLW  B5
062A4:  MOVWF  x2C
062A6:  MOVLB  0
062A8:  CALL   0858
062AC:  MOVFF  02,5FB
062B0:  MOVFF  01,5FA
062B4:  MOVLW  06
062B6:  MOVLB  5
062B8:  ADDWF  xFA,F
062BA:  MOVLW  00
062BC:  ADDWFC xFB,F
062BE:  MOVLW  64
062C0:  ADDWF  xFA,W
062C2:  MOVWF  01
062C4:  MOVLW  00
062C6:  ADDWFC xFB,W
062C8:  MOVWF  03
062CA:  MOVF   01,W
062CC:  ADDLW  66
062CE:  MOVWF  01
062D0:  MOVLW  01
062D2:  ADDWFC 03,F
062D4:  MOVFF  01,5FA
062D8:  MOVFF  03,5FB
062DC:  MOVFF  03,5FE
062E0:  MOVFF  01,5FD
062E4:  MOVLB  6
062E6:  CLRF   x00
062E8:  MOVLB  5
062EA:  CLRF   xFF
062EC:  MOVLB  0
062EE:  RCALL  5E60
062F0:  MOVFF  03,5F9
062F4:  MOVFF  02,5F8
062F8:  MOVFF  01,5F7
062FC:  MOVFF  00,5F6
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
06300:  MOVLB  5
06302:  MOVF   xF5,W
06304:  SUBLW  50
06306:  BNZ   6332
06308:  MOVLW  01
0630A:  SUBWF  xF4,W
0630C:  MULLW  20
0630E:  MOVF   FF3,W
06310:  CLRF   xFB
06312:  MOVWF  xFA
06314:  MOVLW  20
06316:  ADDWF  xFA,W
06318:  MOVWF  FE9
0631A:  MOVLW  00
0631C:  ADDWFC xFB,W
0631E:  MOVWF  FEA
06320:  MOVFF  5F6,FEF
06324:  MOVFF  5F7,FEC
06328:  MOVFF  5F8,FEC
0632C:  MOVFF  5F9,FEC
06330:  BRA    63B4
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
06332:  MOVF   xF5,W
06334:  SUBLW  49
06336:  BNZ   636E
06338:  MOVLW  01
0633A:  SUBWF  xF4,W
0633C:  MULLW  20
0633E:  MOVF   FF3,W
06340:  CLRF   xFB
06342:  MOVWF  xFA
06344:  MOVLW  04
06346:  ADDWF  xFA,W
06348:  MOVWF  01
0634A:  MOVLW  00
0634C:  ADDWFC xFB,W
0634E:  MOVWF  03
06350:  MOVF   01,W
06352:  ADDLW  20
06354:  MOVWF  FE9
06356:  MOVLW  00
06358:  ADDWFC 03,W
0635A:  MOVWF  FEA
0635C:  MOVFF  5F6,FEF
06360:  MOVFF  5F7,FEC
06364:  MOVFF  5F8,FEC
06368:  MOVFF  5F9,FEC
0636C:  BRA    63B4
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
0636E:  MOVF   xF5,W
06370:  SUBLW  44
06372:  BNZ   63AA
06374:  MOVLW  01
06376:  SUBWF  xF4,W
06378:  MULLW  20
0637A:  MOVF   FF3,W
0637C:  CLRF   xFB
0637E:  MOVWF  xFA
06380:  MOVLW  08
06382:  ADDWF  xFA,W
06384:  MOVWF  01
06386:  MOVLW  00
06388:  ADDWFC xFB,W
0638A:  MOVWF  03
0638C:  MOVF   01,W
0638E:  ADDLW  20
06390:  MOVWF  FE9
06392:  MOVLW  00
06394:  ADDWFC 03,W
06396:  MOVWF  FEA
06398:  MOVFF  5F6,FEF
0639C:  MOVFF  5F7,FEC
063A0:  MOVFF  5F8,FEC
063A4:  MOVFF  5F9,FEC
063A8:  BRA    63B4
....................    else return INV_PARAM;
063AA:  MOVLW  02
063AC:  MOVWF  01
063AE:  MOVLB  0
063B0:  BRA    63BA
063B2:  MOVLB  5
....................    
....................    return SUCCESS;
063B4:  MOVLW  00
063B6:  MOVWF  01
063B8:  MOVLB  0
063BA:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
063BC:  MOVLB  6
063BE:  CLRF   x2B
063C0:  MOVFF  5E8,62A
063C4:  CLRF   x2D
063C6:  MOVLW  B5
063C8:  MOVWF  x2C
063CA:  MOVLB  0
063CC:  CALL   0858
063D0:  MOVFF  02,5F6
063D4:  MOVFF  01,5F5
063D8:  MOVLW  06
063DA:  MOVLB  5
063DC:  ADDWF  xF5,F
063DE:  MOVLW  00
063E0:  ADDWFC xF6,F
063E2:  MOVLW  32
063E4:  ADDWF  xF5,W
063E6:  MOVWF  01
063E8:  MOVLW  00
063EA:  ADDWFC xF6,W
063EC:  MOVWF  03
063EE:  MOVF   01,W
063F0:  ADDLW  66
063F2:  MOVWF  01
063F4:  MOVLW  01
063F6:  ADDWFC 03,F
063F8:  MOVFF  01,5F5
063FC:  MOVFF  03,5F6
06400:  MOVFF  03,61D
06404:  MOVFF  01,61C
06408:  MOVLB  0
0640A:  CALL   4BB2
0640E:  MOVF   01,F
06410:  BNZ   641A
06412:  MOVLW  02
06414:  MOVWF  01
06416:  BRA    64F4
06418:  BRA    647A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0641A:  MOVLB  6
0641C:  CLRF   x2B
0641E:  MOVFF  5E8,62A
06422:  CLRF   x2D
06424:  MOVLW  B5
06426:  MOVWF  x2C
06428:  MOVLB  0
0642A:  CALL   0858
0642E:  MOVFF  02,5F6
06432:  MOVFF  01,5F5
06436:  MOVLW  06
06438:  MOVLB  5
0643A:  ADDWF  xF5,F
0643C:  MOVLW  00
0643E:  ADDWFC xF6,F
06440:  MOVLW  32
06442:  ADDWF  xF5,W
06444:  MOVWF  01
06446:  MOVLW  00
06448:  ADDWFC xF6,W
0644A:  MOVWF  03
0644C:  MOVF   01,W
0644E:  ADDLW  66
06450:  MOVWF  01
06452:  MOVLW  01
06454:  ADDWFC 03,F
06456:  MOVFF  01,5F5
0645A:  MOVFF  03,5F6
0645E:  MOVFF  03,61D
06462:  MOVFF  01,61C
06466:  MOVLB  6
06468:  CLRF   x1F
0646A:  CLRF   x1E
0646C:  MOVLW  0A
0646E:  MOVWF  x20
06470:  MOVLB  0
06472:  CALL   4CA2
06476:  MOVFF  01,5F4
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%f,", PID[arg1-1].SP);
0647A:  MOVLW  04
0647C:  MOVLB  6
0647E:  MOVWF  x2B
06480:  MOVLW  3C
06482:  MOVWF  x2A
06484:  MOVLB  0
06486:  CALL   4A3A
0648A:  MOVF   01,W
0648C:  ADDLW  3C
0648E:  MOVLB  5
06490:  MOVWF  xF5
06492:  MOVLW  04
06494:  ADDWFC 02,W
06496:  MOVWF  xF6
06498:  MOVLW  01
0649A:  SUBWF  xF4,W
0649C:  MULLW  20
0649E:  MOVF   FF3,W
064A0:  CLRF   xF8
064A2:  MOVWF  xF7
064A4:  MOVLW  0C
064A6:  ADDWF  xF7,W
064A8:  MOVWF  01
064AA:  MOVLW  00
064AC:  ADDWFC xF8,W
064AE:  MOVWF  03
064B0:  MOVF   01,W
064B2:  ADDLW  20
064B4:  MOVWF  FE9
064B6:  MOVLW  00
064B8:  ADDWFC 03,W
064BA:  MOVWF  FEA
064BC:  MOVFF  FEF,62C
064C0:  MOVFF  FEC,62D
064C4:  MOVFF  FEC,62E
064C8:  MOVFF  FEC,62F
064CC:  MOVFF  5F6,4E1
064D0:  MOVFF  5F5,4E0
064D4:  MOVLW  89
064D6:  MOVWF  FE9
064D8:  MOVLW  02
064DA:  MOVLB  6
064DC:  MOVWF  x30
064DE:  MOVLB  0
064E0:  CALL   57C2
064E4:  MOVLW  2C
064E6:  MOVLB  6
064E8:  MOVWF  x39
064EA:  MOVLB  0
064EC:  CALL   4AEA
....................    return SUCCESS;
064F0:  MOVLW  00
064F2:  MOVWF  01
064F4:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
064F6:  MOVLB  6
064F8:  CLRF   x2B
064FA:  MOVFF  5E8,62A
064FE:  CLRF   x2D
06500:  MOVLW  B5
06502:  MOVWF  x2C
06504:  MOVLB  0
06506:  CALL   0858
0650A:  MOVFF  02,5FA
0650E:  MOVFF  01,5F9
06512:  MOVLW  06
06514:  MOVLB  5
06516:  ADDWF  xF9,F
06518:  MOVLW  00
0651A:  ADDWFC xFA,F
0651C:  MOVLW  32
0651E:  ADDWF  xF9,W
06520:  MOVWF  01
06522:  MOVLW  00
06524:  ADDWFC xFA,W
06526:  MOVWF  03
06528:  MOVF   01,W
0652A:  ADDLW  66
0652C:  MOVWF  01
0652E:  MOVLW  01
06530:  ADDWFC 03,F
06532:  MOVFF  01,5F9
06536:  MOVFF  03,5FA
0653A:  MOVFF  03,61D
0653E:  MOVFF  01,61C
06542:  MOVLB  0
06544:  CALL   4BB2
06548:  MOVF   01,F
0654A:  BNZ   6554
0654C:  MOVLW  02
0654E:  MOVWF  01
06550:  BRA    66B8
06552:  BRA    65B4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06554:  MOVLB  6
06556:  CLRF   x2B
06558:  MOVFF  5E8,62A
0655C:  CLRF   x2D
0655E:  MOVLW  B5
06560:  MOVWF  x2C
06562:  MOVLB  0
06564:  CALL   0858
06568:  MOVFF  02,5FA
0656C:  MOVFF  01,5F9
06570:  MOVLW  06
06572:  MOVLB  5
06574:  ADDWF  xF9,F
06576:  MOVLW  00
06578:  ADDWFC xFA,F
0657A:  MOVLW  32
0657C:  ADDWF  xF9,W
0657E:  MOVWF  01
06580:  MOVLW  00
06582:  ADDWFC xFA,W
06584:  MOVWF  03
06586:  MOVF   01,W
06588:  ADDLW  66
0658A:  MOVWF  01
0658C:  MOVLW  01
0658E:  ADDWFC 03,F
06590:  MOVFF  01,5F9
06594:  MOVFF  03,5FA
06598:  MOVFF  03,61D
0659C:  MOVFF  01,61C
065A0:  MOVLB  6
065A2:  CLRF   x1F
065A4:  CLRF   x1E
065A6:  MOVLW  0A
065A8:  MOVWF  x20
065AA:  MOVLB  0
065AC:  CALL   4CA2
065B0:  MOVFF  01,5F4
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
065B4:  MOVLB  6
065B6:  CLRF   x2B
065B8:  MOVFF  5E8,62A
065BC:  CLRF   x2D
065BE:  MOVLW  B5
065C0:  MOVWF  x2C
065C2:  MOVLB  0
065C4:  CALL   0858
065C8:  MOVFF  02,5FA
065CC:  MOVFF  01,5F9
065D0:  MOVLW  06
065D2:  MOVLB  5
065D4:  ADDWF  xF9,F
065D6:  MOVLW  00
065D8:  ADDWFC xFA,F
065DA:  MOVLW  4B
065DC:  ADDWF  xF9,W
065DE:  MOVWF  01
065E0:  MOVLW  00
065E2:  ADDWFC xFA,W
065E4:  MOVWF  03
065E6:  MOVF   01,W
065E8:  ADDLW  66
065EA:  MOVWF  01
065EC:  MOVLW  01
065EE:  ADDWFC 03,F
065F0:  MOVFF  01,5F9
065F4:  MOVFF  03,5FA
065F8:  MOVFF  03,5FE
065FC:  MOVFF  01,5FD
06600:  MOVLB  0
06602:  CALL   5D8C
06606:  MOVF   01,F
06608:  BNZ   6612
0660A:  MOVLW  02
0660C:  MOVWF  01
0660E:  BRA    66B8
06610:  BRA    667C
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
06612:  MOVLB  6
06614:  CLRF   x2B
06616:  MOVFF  5E8,62A
0661A:  CLRF   x2D
0661C:  MOVLW  B5
0661E:  MOVWF  x2C
06620:  MOVLB  0
06622:  CALL   0858
06626:  MOVFF  02,5FA
0662A:  MOVFF  01,5F9
0662E:  MOVLW  06
06630:  MOVLB  5
06632:  ADDWF  xF9,F
06634:  MOVLW  00
06636:  ADDWFC xFA,F
06638:  MOVLW  4B
0663A:  ADDWF  xF9,W
0663C:  MOVWF  01
0663E:  MOVLW  00
06640:  ADDWFC xFA,W
06642:  MOVWF  03
06644:  MOVF   01,W
06646:  ADDLW  66
06648:  MOVWF  01
0664A:  MOVLW  01
0664C:  ADDWFC 03,F
0664E:  MOVFF  01,5F9
06652:  MOVFF  03,5FA
06656:  MOVFF  03,5FE
0665A:  MOVFF  01,5FD
0665E:  MOVLB  6
06660:  CLRF   x00
06662:  MOVLB  5
06664:  CLRF   xFF
06666:  MOVLB  0
06668:  CALL   5E60
0666C:  MOVFF  03,5F8
06670:  MOVFF  02,5F7
06674:  MOVFF  01,5F6
06678:  MOVFF  00,5F5
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0667C:  MOVLW  01
0667E:  MOVLB  5
06680:  SUBWF  xF4,W
06682:  MULLW  20
06684:  MOVF   FF3,W
06686:  CLRF   xFA
06688:  MOVWF  xF9
0668A:  MOVLW  0C
0668C:  ADDWF  xF9,W
0668E:  MOVWF  01
06690:  MOVLW  00
06692:  ADDWFC xFA,W
06694:  MOVWF  03
06696:  MOVF   01,W
06698:  ADDLW  20
0669A:  MOVWF  FE9
0669C:  MOVLW  00
0669E:  ADDWFC 03,W
066A0:  MOVWF  FEA
066A2:  MOVFF  5F5,FEF
066A6:  MOVFF  5F6,FEC
066AA:  MOVFF  5F7,FEC
066AE:  MOVFF  5F8,FEC
....................    
....................    return SUCCESS;
066B2:  MOVLW  00
066B4:  MOVWF  01
066B6:  MOVLB  0
066B8:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
066BA:  MOVLB  6
066BC:  CLRF   x2B
066BE:  MOVFF  5E8,62A
066C2:  CLRF   x2D
066C4:  MOVLW  B5
066C6:  MOVWF  x2C
066C8:  MOVLB  0
066CA:  CALL   0858
066CE:  MOVFF  02,5F6
066D2:  MOVFF  01,5F5
066D6:  MOVLW  06
066D8:  MOVLB  5
066DA:  ADDWF  xF5,F
066DC:  MOVLW  00
066DE:  ADDWFC xF6,F
066E0:  MOVLW  32
066E2:  ADDWF  xF5,W
066E4:  MOVWF  01
066E6:  MOVLW  00
066E8:  ADDWFC xF6,W
066EA:  MOVWF  03
066EC:  MOVF   01,W
066EE:  ADDLW  66
066F0:  MOVWF  01
066F2:  MOVLW  01
066F4:  ADDWFC 03,F
066F6:  MOVFF  01,5F5
066FA:  MOVFF  03,5F6
066FE:  MOVFF  03,61D
06702:  MOVFF  01,61C
06706:  MOVLB  0
06708:  CALL   4BB2
0670C:  MOVF   01,F
0670E:  BNZ   6718
06710:  MOVLW  02
06712:  MOVWF  01
06714:  BRA    6A38
06716:  BRA    6778
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06718:  MOVLB  6
0671A:  CLRF   x2B
0671C:  MOVFF  5E8,62A
06720:  CLRF   x2D
06722:  MOVLW  B5
06724:  MOVWF  x2C
06726:  MOVLB  0
06728:  CALL   0858
0672C:  MOVFF  02,5F6
06730:  MOVFF  01,5F5
06734:  MOVLW  06
06736:  MOVLB  5
06738:  ADDWF  xF5,F
0673A:  MOVLW  00
0673C:  ADDWFC xF6,F
0673E:  MOVLW  32
06740:  ADDWF  xF5,W
06742:  MOVWF  01
06744:  MOVLW  00
06746:  ADDWFC xF6,W
06748:  MOVWF  03
0674A:  MOVF   01,W
0674C:  ADDLW  66
0674E:  MOVWF  01
06750:  MOVLW  01
06752:  ADDWFC 03,F
06754:  MOVFF  01,5F5
06758:  MOVFF  03,5F6
0675C:  MOVFF  03,61D
06760:  MOVFF  01,61C
06764:  MOVLB  6
06766:  CLRF   x1F
06768:  CLRF   x1E
0676A:  MOVLW  0A
0676C:  MOVWF  x20
0676E:  MOVLB  0
06770:  CALL   4CA2
06774:  MOVFF  01,5F4
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
06778:  MOVLW  04
0677A:  MOVLB  6
0677C:  MOVWF  x2B
0677E:  MOVLW  3C
06780:  MOVWF  x2A
06782:  MOVLB  0
06784:  CALL   4A3A
06788:  MOVFF  02,03
0678C:  MOVF   01,W
0678E:  ADDLW  3C
06790:  MOVLB  5
06792:  MOVWF  xF5
06794:  MOVLW  04
06796:  ADDWFC 02,W
06798:  MOVWF  xF6
0679A:  MOVLW  01
0679C:  SUBWF  xF4,W
0679E:  MULLW  18
067A0:  MOVF   FF3,W
067A2:  CLRF   xF8
067A4:  MOVWF  xF7
067A6:  MOVLW  82
067A8:  ADDWF  xF7,W
067AA:  MOVWF  FE9
067AC:  MOVLW  00
067AE:  ADDWFC xF8,W
067B0:  MOVWF  FEA
067B2:  MOVFF  FEF,62C
067B6:  MOVFF  FEC,62D
067BA:  MOVFF  FEC,62E
067BE:  MOVFF  FEC,62F
067C2:  MOVFF  5F6,4E1
067C6:  MOVFF  5F5,4E0
067CA:  MOVLW  89
067CC:  MOVWF  FE9
067CE:  MOVLW  02
067D0:  MOVLB  6
067D2:  MOVWF  x30
067D4:  MOVLB  0
067D6:  CALL   57C2
067DA:  MOVLW  2C
067DC:  MOVLB  6
067DE:  MOVWF  x39
067E0:  MOVLB  0
067E2:  CALL   4AEA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
067E6:  MOVLW  04
067E8:  MOVLB  6
067EA:  MOVWF  x2B
067EC:  MOVLW  3C
067EE:  MOVWF  x2A
067F0:  MOVLB  0
067F2:  CALL   4A3A
067F6:  MOVF   01,W
067F8:  ADDLW  3C
067FA:  MOVLB  5
067FC:  MOVWF  xF5
067FE:  MOVLW  04
06800:  ADDWFC 02,W
06802:  MOVWF  xF6
06804:  MOVLW  01
06806:  SUBWF  xF4,W
06808:  MULLW  18
0680A:  MOVF   FF3,W
0680C:  CLRF   xF8
0680E:  MOVWF  xF7
06810:  MOVLW  04
06812:  ADDWF  xF7,W
06814:  MOVWF  01
06816:  MOVLW  00
06818:  ADDWFC xF8,W
0681A:  MOVWF  03
0681C:  MOVF   01,W
0681E:  ADDLW  82
06820:  MOVWF  FE9
06822:  MOVLW  00
06824:  ADDWFC 03,W
06826:  MOVWF  FEA
06828:  MOVFF  FEF,62C
0682C:  MOVFF  FEC,62D
06830:  MOVFF  FEC,62E
06834:  MOVFF  FEC,62F
06838:  MOVFF  5F6,4E1
0683C:  MOVFF  5F5,4E0
06840:  MOVLW  89
06842:  MOVWF  FE9
06844:  MOVLW  02
06846:  MOVLB  6
06848:  MOVWF  x30
0684A:  MOVLB  0
0684C:  CALL   57C2
06850:  MOVLW  2C
06852:  MOVLB  6
06854:  MOVWF  x39
06856:  MOVLB  0
06858:  CALL   4AEA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
0685C:  MOVLW  04
0685E:  MOVLB  6
06860:  MOVWF  x2B
06862:  MOVLW  3C
06864:  MOVWF  x2A
06866:  MOVLB  0
06868:  CALL   4A3A
0686C:  MOVF   01,W
0686E:  ADDLW  3C
06870:  MOVLB  5
06872:  MOVWF  xF5
06874:  MOVLW  04
06876:  ADDWFC 02,W
06878:  MOVWF  xF6
0687A:  MOVLW  01
0687C:  SUBWF  xF4,W
0687E:  MULLW  18
06880:  MOVF   FF3,W
06882:  CLRF   xF8
06884:  MOVWF  xF7
06886:  MOVLW  08
06888:  ADDWF  xF7,W
0688A:  MOVWF  01
0688C:  MOVLW  00
0688E:  ADDWFC xF8,W
06890:  MOVWF  03
06892:  MOVF   01,W
06894:  ADDLW  82
06896:  MOVWF  FE9
06898:  MOVLW  00
0689A:  ADDWFC 03,W
0689C:  MOVWF  FEA
0689E:  MOVFF  FEF,62C
068A2:  MOVFF  FEC,62D
068A6:  MOVFF  FEC,62E
068AA:  MOVFF  FEC,62F
068AE:  MOVFF  5F6,4E1
068B2:  MOVFF  5F5,4E0
068B6:  MOVLW  89
068B8:  MOVWF  FE9
068BA:  MOVLW  02
068BC:  MOVLB  6
068BE:  MOVWF  x30
068C0:  MOVLB  0
068C2:  CALL   57C2
068C6:  MOVLW  2C
068C8:  MOVLB  6
068CA:  MOVWF  x39
068CC:  MOVLB  0
068CE:  CALL   4AEA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
068D2:  MOVLW  04
068D4:  MOVLB  6
068D6:  MOVWF  x2B
068D8:  MOVLW  3C
068DA:  MOVWF  x2A
068DC:  MOVLB  0
068DE:  CALL   4A3A
068E2:  MOVF   01,W
068E4:  ADDLW  3C
068E6:  MOVLB  5
068E8:  MOVWF  xF5
068EA:  MOVLW  04
068EC:  ADDWFC 02,W
068EE:  MOVWF  xF6
068F0:  MOVLW  01
068F2:  SUBWF  xF4,W
068F4:  MULLW  18
068F6:  MOVF   FF3,W
068F8:  CLRF   xF8
068FA:  MOVWF  xF7
068FC:  MOVLW  0C
068FE:  ADDWF  xF7,W
06900:  MOVWF  01
06902:  MOVLW  00
06904:  ADDWFC xF8,W
06906:  MOVWF  03
06908:  MOVF   01,W
0690A:  ADDLW  82
0690C:  MOVWF  FE9
0690E:  MOVLW  00
06910:  ADDWFC 03,W
06912:  MOVWF  FEA
06914:  MOVFF  FEF,62C
06918:  MOVFF  FEC,62D
0691C:  MOVFF  FEC,62E
06920:  MOVFF  FEC,62F
06924:  MOVFF  5F6,4E1
06928:  MOVFF  5F5,4E0
0692C:  MOVLW  89
0692E:  MOVWF  FE9
06930:  MOVLW  02
06932:  MOVLB  6
06934:  MOVWF  x30
06936:  MOVLB  0
06938:  CALL   57C2
0693C:  MOVLW  2C
0693E:  MOVLB  6
06940:  MOVWF  x39
06942:  MOVLB  0
06944:  CALL   4AEA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
06948:  MOVLW  04
0694A:  MOVLB  6
0694C:  MOVWF  x2B
0694E:  MOVLW  3C
06950:  MOVWF  x2A
06952:  MOVLB  0
06954:  CALL   4A3A
06958:  MOVF   01,W
0695A:  ADDLW  3C
0695C:  MOVLB  5
0695E:  MOVWF  xF5
06960:  MOVLW  04
06962:  ADDWFC 02,W
06964:  MOVWF  xF6
06966:  MOVLW  01
06968:  SUBWF  xF4,W
0696A:  MULLW  18
0696C:  MOVF   FF3,W
0696E:  CLRF   xF8
06970:  MOVWF  xF7
06972:  MOVLW  10
06974:  ADDWF  xF7,W
06976:  MOVWF  01
06978:  MOVLW  00
0697A:  ADDWFC xF8,W
0697C:  MOVWF  03
0697E:  MOVF   01,W
06980:  ADDLW  82
06982:  MOVWF  FE9
06984:  MOVLW  00
06986:  ADDWFC 03,W
06988:  MOVWF  FEA
0698A:  MOVFF  FEF,62C
0698E:  MOVFF  FEC,62D
06992:  MOVFF  FEC,62E
06996:  MOVFF  FEC,62F
0699A:  MOVFF  5F6,4E1
0699E:  MOVFF  5F5,4E0
069A2:  MOVLW  89
069A4:  MOVWF  FE9
069A6:  MOVLW  02
069A8:  MOVLB  6
069AA:  MOVWF  x30
069AC:  MOVLB  0
069AE:  CALL   57C2
069B2:  MOVLW  2C
069B4:  MOVLB  6
069B6:  MOVWF  x39
069B8:  MOVLB  0
069BA:  CALL   4AEA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
069BE:  MOVLW  04
069C0:  MOVLB  6
069C2:  MOVWF  x2B
069C4:  MOVLW  3C
069C6:  MOVWF  x2A
069C8:  MOVLB  0
069CA:  CALL   4A3A
069CE:  MOVF   01,W
069D0:  ADDLW  3C
069D2:  MOVLB  5
069D4:  MOVWF  xF5
069D6:  MOVLW  04
069D8:  ADDWFC 02,W
069DA:  MOVWF  xF6
069DC:  MOVLW  01
069DE:  SUBWF  xF4,W
069E0:  MULLW  18
069E2:  MOVF   FF3,W
069E4:  CLRF   xF8
069E6:  MOVWF  xF7
069E8:  MOVLW  14
069EA:  ADDWF  xF7,W
069EC:  MOVWF  01
069EE:  MOVLW  00
069F0:  ADDWFC xF8,W
069F2:  MOVWF  03
069F4:  MOVF   01,W
069F6:  ADDLW  82
069F8:  MOVWF  FE9
069FA:  MOVLW  00
069FC:  ADDWFC 03,W
069FE:  MOVWF  FEA
06A00:  MOVFF  FEF,62C
06A04:  MOVFF  FEC,62D
06A08:  MOVFF  FEC,62E
06A0C:  MOVFF  FEC,62F
06A10:  MOVFF  5F6,4E1
06A14:  MOVFF  5F5,4E0
06A18:  MOVLW  89
06A1A:  MOVWF  FE9
06A1C:  MOVLW  02
06A1E:  MOVLB  6
06A20:  MOVWF  x30
06A22:  MOVLB  0
06A24:  CALL   57C2
06A28:  MOVLW  2C
06A2A:  MOVLB  6
06A2C:  MOVWF  x39
06A2E:  MOVLB  0
06A30:  CALL   4AEA
....................    
....................    return SUCCESS;
06A34:  MOVLW  00
06A36:  MOVWF  01
06A38:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06A3A:  MOVLB  6
06A3C:  CLRF   x2B
06A3E:  MOVFF  5E8,62A
06A42:  CLRF   x2D
06A44:  MOVLW  B5
06A46:  MOVWF  x2C
06A48:  MOVLB  0
06A4A:  CALL   0858
06A4E:  MOVFF  02,5F7
06A52:  MOVFF  01,5F6
06A56:  MOVLW  06
06A58:  MOVLB  5
06A5A:  ADDWF  xF6,F
06A5C:  MOVLW  00
06A5E:  ADDWFC xF7,F
06A60:  MOVLW  32
06A62:  ADDWF  xF6,W
06A64:  MOVWF  01
06A66:  MOVLW  00
06A68:  ADDWFC xF7,W
06A6A:  MOVWF  03
06A6C:  MOVF   01,W
06A6E:  ADDLW  66
06A70:  MOVWF  01
06A72:  MOVLW  01
06A74:  ADDWFC 03,F
06A76:  MOVFF  01,5F6
06A7A:  MOVFF  03,5F7
06A7E:  MOVFF  03,61D
06A82:  MOVFF  01,61C
06A86:  MOVLB  0
06A88:  CALL   4BB2
06A8C:  MOVF   01,F
06A8E:  BNZ   6A98
06A90:  MOVLW  02
06A92:  MOVWF  01
06A94:  BRA    6EA6
06A96:  BRA    6AF8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06A98:  MOVLB  6
06A9A:  CLRF   x2B
06A9C:  MOVFF  5E8,62A
06AA0:  CLRF   x2D
06AA2:  MOVLW  B5
06AA4:  MOVWF  x2C
06AA6:  MOVLB  0
06AA8:  CALL   0858
06AAC:  MOVFF  02,5F7
06AB0:  MOVFF  01,5F6
06AB4:  MOVLW  06
06AB6:  MOVLB  5
06AB8:  ADDWF  xF6,F
06ABA:  MOVLW  00
06ABC:  ADDWFC xF7,F
06ABE:  MOVLW  32
06AC0:  ADDWF  xF6,W
06AC2:  MOVWF  01
06AC4:  MOVLW  00
06AC6:  ADDWFC xF7,W
06AC8:  MOVWF  03
06ACA:  MOVF   01,W
06ACC:  ADDLW  66
06ACE:  MOVWF  01
06AD0:  MOVLW  01
06AD2:  ADDWFC 03,F
06AD4:  MOVFF  01,5F6
06AD8:  MOVFF  03,5F7
06ADC:  MOVFF  03,61D
06AE0:  MOVFF  01,61C
06AE4:  MOVLB  6
06AE6:  CLRF   x1F
06AE8:  CLRF   x1E
06AEA:  MOVLW  0A
06AEC:  MOVWF  x20
06AEE:  MOVLB  0
06AF0:  CALL   4CA2
06AF4:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06AF8:  MOVLB  6
06AFA:  CLRF   x2B
06AFC:  MOVFF  5E8,62A
06B00:  CLRF   x2D
06B02:  MOVLW  B5
06B04:  MOVWF  x2C
06B06:  MOVLB  0
06B08:  CALL   0858
06B0C:  MOVFF  02,5F7
06B10:  MOVFF  01,5F6
06B14:  MOVLW  06
06B16:  MOVLB  5
06B18:  ADDWF  xF6,F
06B1A:  MOVLW  00
06B1C:  ADDWFC xF7,F
06B1E:  MOVLW  4B
06B20:  ADDWF  xF6,W
06B22:  MOVWF  01
06B24:  MOVLW  00
06B26:  ADDWFC xF7,W
06B28:  MOVWF  03
06B2A:  MOVF   01,W
06B2C:  ADDLW  66
06B2E:  MOVWF  01
06B30:  MOVLW  01
06B32:  ADDWFC 03,F
06B34:  MOVFF  01,5F6
06B38:  MOVFF  03,5F7
06B3C:  MOVFF  03,62B
06B40:  MOVFF  01,62A
06B44:  MOVLB  0
06B46:  CALL   4A3A
06B4A:  MOVFF  02,03
06B4E:  MOVF   01,W
06B50:  SUBLW  01
06B52:  BNZ   6B58
06B54:  MOVF   03,F
06B56:  BZ    6B60
06B58:  MOVLW  02
06B5A:  MOVWF  01
06B5C:  BRA    6EA6
06B5E:  BRA    6BA0
....................    else arg2 = SERcmd[rec].p[3][0];
06B60:  MOVLB  6
06B62:  CLRF   x2B
06B64:  MOVFF  5E8,62A
06B68:  CLRF   x2D
06B6A:  MOVLW  B5
06B6C:  MOVWF  x2C
06B6E:  MOVLB  0
06B70:  CALL   0858
06B74:  MOVFF  02,5F7
06B78:  MOVFF  01,5F6
06B7C:  MOVLW  06
06B7E:  MOVLB  5
06B80:  ADDWF  xF6,F
06B82:  MOVLW  00
06B84:  ADDWFC xF7,F
06B86:  MOVLW  4B
06B88:  ADDWF  xF6,F
06B8A:  MOVLW  00
06B8C:  ADDWFC xF7,F
06B8E:  MOVLW  66
06B90:  ADDWF  xF6,W
06B92:  MOVWF  FE9
06B94:  MOVLW  01
06B96:  ADDWFC xF7,W
06B98:  MOVWF  FEA
06B9A:  MOVFF  FEF,5F5
06B9E:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
06BA0:  MOVLB  5
06BA2:  MOVF   xF5,W
06BA4:  SUBLW  30
06BA6:  BNZ   6C1A
06BA8:  MOVLW  04
06BAA:  MOVLB  6
06BAC:  MOVWF  x2B
06BAE:  MOVLW  3C
06BB0:  MOVWF  x2A
06BB2:  MOVLB  0
06BB4:  CALL   4A3A
06BB8:  MOVFF  02,03
06BBC:  MOVF   01,W
06BBE:  ADDLW  3C
06BC0:  MOVLB  5
06BC2:  MOVWF  xF6
06BC4:  MOVLW  04
06BC6:  ADDWFC 02,W
06BC8:  MOVWF  xF7
06BCA:  MOVLW  01
06BCC:  SUBWF  xF4,W
06BCE:  MULLW  18
06BD0:  MOVF   FF3,W
06BD2:  CLRF   xF9
06BD4:  MOVWF  xF8
06BD6:  MOVLW  82
06BD8:  ADDWF  xF8,W
06BDA:  MOVWF  FE9
06BDC:  MOVLW  00
06BDE:  ADDWFC xF9,W
06BE0:  MOVWF  FEA
06BE2:  MOVFF  FEF,62C
06BE6:  MOVFF  FEC,62D
06BEA:  MOVFF  FEC,62E
06BEE:  MOVFF  FEC,62F
06BF2:  MOVFF  5F7,4E1
06BF6:  MOVFF  5F6,4E0
06BFA:  MOVLW  89
06BFC:  MOVWF  FE9
06BFE:  MOVLW  02
06C00:  MOVLB  6
06C02:  MOVWF  x30
06C04:  MOVLB  0
06C06:  CALL   57C2
06C0A:  MOVLW  2C
06C0C:  MOVLB  6
06C0E:  MOVWF  x39
06C10:  MOVLB  0
06C12:  CALL   4AEA
06C16:  BRA    6EA2
06C18:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
06C1A:  MOVF   xF5,W
06C1C:  SUBLW  31
06C1E:  BNZ   6C9A
06C20:  MOVLW  04
06C22:  MOVLB  6
06C24:  MOVWF  x2B
06C26:  MOVLW  3C
06C28:  MOVWF  x2A
06C2A:  MOVLB  0
06C2C:  CALL   4A3A
06C30:  MOVF   01,W
06C32:  ADDLW  3C
06C34:  MOVLB  5
06C36:  MOVWF  xF6
06C38:  MOVLW  04
06C3A:  ADDWFC 02,W
06C3C:  MOVWF  xF7
06C3E:  MOVLW  01
06C40:  SUBWF  xF4,W
06C42:  MULLW  18
06C44:  MOVF   FF3,W
06C46:  CLRF   xF9
06C48:  MOVWF  xF8
06C4A:  MOVLW  04
06C4C:  ADDWF  xF8,W
06C4E:  MOVWF  01
06C50:  MOVLW  00
06C52:  ADDWFC xF9,W
06C54:  MOVWF  03
06C56:  MOVF   01,W
06C58:  ADDLW  82
06C5A:  MOVWF  FE9
06C5C:  MOVLW  00
06C5E:  ADDWFC 03,W
06C60:  MOVWF  FEA
06C62:  MOVFF  FEF,62C
06C66:  MOVFF  FEC,62D
06C6A:  MOVFF  FEC,62E
06C6E:  MOVFF  FEC,62F
06C72:  MOVFF  5F7,4E1
06C76:  MOVFF  5F6,4E0
06C7A:  MOVLW  89
06C7C:  MOVWF  FE9
06C7E:  MOVLW  02
06C80:  MOVLB  6
06C82:  MOVWF  x30
06C84:  MOVLB  0
06C86:  CALL   57C2
06C8A:  MOVLW  2C
06C8C:  MOVLB  6
06C8E:  MOVWF  x39
06C90:  MOVLB  0
06C92:  CALL   4AEA
06C96:  BRA    6EA2
06C98:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
06C9A:  MOVF   xF5,W
06C9C:  SUBLW  32
06C9E:  BNZ   6D1A
06CA0:  MOVLW  04
06CA2:  MOVLB  6
06CA4:  MOVWF  x2B
06CA6:  MOVLW  3C
06CA8:  MOVWF  x2A
06CAA:  MOVLB  0
06CAC:  CALL   4A3A
06CB0:  MOVF   01,W
06CB2:  ADDLW  3C
06CB4:  MOVLB  5
06CB6:  MOVWF  xF6
06CB8:  MOVLW  04
06CBA:  ADDWFC 02,W
06CBC:  MOVWF  xF7
06CBE:  MOVLW  01
06CC0:  SUBWF  xF4,W
06CC2:  MULLW  18
06CC4:  MOVF   FF3,W
06CC6:  CLRF   xF9
06CC8:  MOVWF  xF8
06CCA:  MOVLW  08
06CCC:  ADDWF  xF8,W
06CCE:  MOVWF  01
06CD0:  MOVLW  00
06CD2:  ADDWFC xF9,W
06CD4:  MOVWF  03
06CD6:  MOVF   01,W
06CD8:  ADDLW  82
06CDA:  MOVWF  FE9
06CDC:  MOVLW  00
06CDE:  ADDWFC 03,W
06CE0:  MOVWF  FEA
06CE2:  MOVFF  FEF,62C
06CE6:  MOVFF  FEC,62D
06CEA:  MOVFF  FEC,62E
06CEE:  MOVFF  FEC,62F
06CF2:  MOVFF  5F7,4E1
06CF6:  MOVFF  5F6,4E0
06CFA:  MOVLW  89
06CFC:  MOVWF  FE9
06CFE:  MOVLW  02
06D00:  MOVLB  6
06D02:  MOVWF  x30
06D04:  MOVLB  0
06D06:  CALL   57C2
06D0A:  MOVLW  2C
06D0C:  MOVLB  6
06D0E:  MOVWF  x39
06D10:  MOVLB  0
06D12:  CALL   4AEA
06D16:  BRA    6EA2
06D18:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
06D1A:  MOVF   xF5,W
06D1C:  SUBLW  33
06D1E:  BNZ   6D9A
06D20:  MOVLW  04
06D22:  MOVLB  6
06D24:  MOVWF  x2B
06D26:  MOVLW  3C
06D28:  MOVWF  x2A
06D2A:  MOVLB  0
06D2C:  CALL   4A3A
06D30:  MOVF   01,W
06D32:  ADDLW  3C
06D34:  MOVLB  5
06D36:  MOVWF  xF6
06D38:  MOVLW  04
06D3A:  ADDWFC 02,W
06D3C:  MOVWF  xF7
06D3E:  MOVLW  01
06D40:  SUBWF  xF4,W
06D42:  MULLW  18
06D44:  MOVF   FF3,W
06D46:  CLRF   xF9
06D48:  MOVWF  xF8
06D4A:  MOVLW  0C
06D4C:  ADDWF  xF8,W
06D4E:  MOVWF  01
06D50:  MOVLW  00
06D52:  ADDWFC xF9,W
06D54:  MOVWF  03
06D56:  MOVF   01,W
06D58:  ADDLW  82
06D5A:  MOVWF  FE9
06D5C:  MOVLW  00
06D5E:  ADDWFC 03,W
06D60:  MOVWF  FEA
06D62:  MOVFF  FEF,62C
06D66:  MOVFF  FEC,62D
06D6A:  MOVFF  FEC,62E
06D6E:  MOVFF  FEC,62F
06D72:  MOVFF  5F7,4E1
06D76:  MOVFF  5F6,4E0
06D7A:  MOVLW  89
06D7C:  MOVWF  FE9
06D7E:  MOVLW  02
06D80:  MOVLB  6
06D82:  MOVWF  x30
06D84:  MOVLB  0
06D86:  CALL   57C2
06D8A:  MOVLW  2C
06D8C:  MOVLB  6
06D8E:  MOVWF  x39
06D90:  MOVLB  0
06D92:  CALL   4AEA
06D96:  BRA    6EA2
06D98:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
06D9A:  MOVF   xF5,W
06D9C:  SUBLW  34
06D9E:  BNZ   6E1A
06DA0:  MOVLW  04
06DA2:  MOVLB  6
06DA4:  MOVWF  x2B
06DA6:  MOVLW  3C
06DA8:  MOVWF  x2A
06DAA:  MOVLB  0
06DAC:  CALL   4A3A
06DB0:  MOVF   01,W
06DB2:  ADDLW  3C
06DB4:  MOVLB  5
06DB6:  MOVWF  xF6
06DB8:  MOVLW  04
06DBA:  ADDWFC 02,W
06DBC:  MOVWF  xF7
06DBE:  MOVLW  01
06DC0:  SUBWF  xF4,W
06DC2:  MULLW  18
06DC4:  MOVF   FF3,W
06DC6:  CLRF   xF9
06DC8:  MOVWF  xF8
06DCA:  MOVLW  10
06DCC:  ADDWF  xF8,W
06DCE:  MOVWF  01
06DD0:  MOVLW  00
06DD2:  ADDWFC xF9,W
06DD4:  MOVWF  03
06DD6:  MOVF   01,W
06DD8:  ADDLW  82
06DDA:  MOVWF  FE9
06DDC:  MOVLW  00
06DDE:  ADDWFC 03,W
06DE0:  MOVWF  FEA
06DE2:  MOVFF  FEF,62C
06DE6:  MOVFF  FEC,62D
06DEA:  MOVFF  FEC,62E
06DEE:  MOVFF  FEC,62F
06DF2:  MOVFF  5F7,4E1
06DF6:  MOVFF  5F6,4E0
06DFA:  MOVLW  89
06DFC:  MOVWF  FE9
06DFE:  MOVLW  02
06E00:  MOVLB  6
06E02:  MOVWF  x30
06E04:  MOVLB  0
06E06:  CALL   57C2
06E0A:  MOVLW  2C
06E0C:  MOVLB  6
06E0E:  MOVWF  x39
06E10:  MOVLB  0
06E12:  CALL   4AEA
06E16:  BRA    6EA2
06E18:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
06E1A:  MOVF   xF5,W
06E1C:  SUBLW  35
06E1E:  BNZ   6E9A
06E20:  MOVLW  04
06E22:  MOVLB  6
06E24:  MOVWF  x2B
06E26:  MOVLW  3C
06E28:  MOVWF  x2A
06E2A:  MOVLB  0
06E2C:  CALL   4A3A
06E30:  MOVF   01,W
06E32:  ADDLW  3C
06E34:  MOVLB  5
06E36:  MOVWF  xF6
06E38:  MOVLW  04
06E3A:  ADDWFC 02,W
06E3C:  MOVWF  xF7
06E3E:  MOVLW  01
06E40:  SUBWF  xF4,W
06E42:  MULLW  18
06E44:  MOVF   FF3,W
06E46:  CLRF   xF9
06E48:  MOVWF  xF8
06E4A:  MOVLW  14
06E4C:  ADDWF  xF8,W
06E4E:  MOVWF  01
06E50:  MOVLW  00
06E52:  ADDWFC xF9,W
06E54:  MOVWF  03
06E56:  MOVF   01,W
06E58:  ADDLW  82
06E5A:  MOVWF  FE9
06E5C:  MOVLW  00
06E5E:  ADDWFC 03,W
06E60:  MOVWF  FEA
06E62:  MOVFF  FEF,62C
06E66:  MOVFF  FEC,62D
06E6A:  MOVFF  FEC,62E
06E6E:  MOVFF  FEC,62F
06E72:  MOVFF  5F7,4E1
06E76:  MOVFF  5F6,4E0
06E7A:  MOVLW  89
06E7C:  MOVWF  FE9
06E7E:  MOVLW  02
06E80:  MOVLB  6
06E82:  MOVWF  x30
06E84:  MOVLB  0
06E86:  CALL   57C2
06E8A:  MOVLW  2C
06E8C:  MOVLB  6
06E8E:  MOVWF  x39
06E90:  MOVLB  0
06E92:  CALL   4AEA
06E96:  BRA    6EA2
06E98:  MOVLB  5
....................    else return INV_PARAM;
06E9A:  MOVLW  02
06E9C:  MOVWF  01
06E9E:  MOVLB  0
06EA0:  BRA    6EA6
....................    
....................    return SUCCESS;
06EA2:  MOVLW  00
06EA4:  MOVWF  01
06EA6:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06EA8:  MOVLB  6
06EAA:  CLRF   x2B
06EAC:  MOVFF  5E8,62A
06EB0:  CLRF   x2D
06EB2:  MOVLW  B5
06EB4:  MOVWF  x2C
06EB6:  MOVLB  0
06EB8:  CALL   0858
06EBC:  MOVFF  02,5FB
06EC0:  MOVFF  01,5FA
06EC4:  MOVLW  06
06EC6:  MOVLB  5
06EC8:  ADDWF  xFA,F
06ECA:  MOVLW  00
06ECC:  ADDWFC xFB,F
06ECE:  MOVLW  32
06ED0:  ADDWF  xFA,W
06ED2:  MOVWF  01
06ED4:  MOVLW  00
06ED6:  ADDWFC xFB,W
06ED8:  MOVWF  03
06EDA:  MOVF   01,W
06EDC:  ADDLW  66
06EDE:  MOVWF  01
06EE0:  MOVLW  01
06EE2:  ADDWFC 03,F
06EE4:  MOVFF  01,5FA
06EE8:  MOVFF  03,5FB
06EEC:  MOVFF  03,61D
06EF0:  MOVFF  01,61C
06EF4:  MOVLB  0
06EF6:  CALL   4BB2
06EFA:  MOVF   01,F
06EFC:  BNZ   6F06
06EFE:  MOVLW  02
06F00:  MOVWF  01
06F02:  BRA    7244
06F04:  BRA    6F66
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06F06:  MOVLB  6
06F08:  CLRF   x2B
06F0A:  MOVFF  5E8,62A
06F0E:  CLRF   x2D
06F10:  MOVLW  B5
06F12:  MOVWF  x2C
06F14:  MOVLB  0
06F16:  CALL   0858
06F1A:  MOVFF  02,5FB
06F1E:  MOVFF  01,5FA
06F22:  MOVLW  06
06F24:  MOVLB  5
06F26:  ADDWF  xFA,F
06F28:  MOVLW  00
06F2A:  ADDWFC xFB,F
06F2C:  MOVLW  32
06F2E:  ADDWF  xFA,W
06F30:  MOVWF  01
06F32:  MOVLW  00
06F34:  ADDWFC xFB,W
06F36:  MOVWF  03
06F38:  MOVF   01,W
06F3A:  ADDLW  66
06F3C:  MOVWF  01
06F3E:  MOVLW  01
06F40:  ADDWFC 03,F
06F42:  MOVFF  01,5FA
06F46:  MOVFF  03,5FB
06F4A:  MOVFF  03,61D
06F4E:  MOVFF  01,61C
06F52:  MOVLB  6
06F54:  CLRF   x1F
06F56:  CLRF   x1E
06F58:  MOVLW  0A
06F5A:  MOVWF  x20
06F5C:  MOVLB  0
06F5E:  CALL   4CA2
06F62:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06F66:  MOVLB  6
06F68:  CLRF   x2B
06F6A:  MOVFF  5E8,62A
06F6E:  CLRF   x2D
06F70:  MOVLW  B5
06F72:  MOVWF  x2C
06F74:  MOVLB  0
06F76:  CALL   0858
06F7A:  MOVFF  02,5FB
06F7E:  MOVFF  01,5FA
06F82:  MOVLW  06
06F84:  MOVLB  5
06F86:  ADDWF  xFA,F
06F88:  MOVLW  00
06F8A:  ADDWFC xFB,F
06F8C:  MOVLW  4B
06F8E:  ADDWF  xFA,W
06F90:  MOVWF  01
06F92:  MOVLW  00
06F94:  ADDWFC xFB,W
06F96:  MOVWF  03
06F98:  MOVF   01,W
06F9A:  ADDLW  66
06F9C:  MOVWF  01
06F9E:  MOVLW  01
06FA0:  ADDWFC 03,F
06FA2:  MOVFF  01,5FA
06FA6:  MOVFF  03,5FB
06FAA:  MOVFF  03,62B
06FAE:  MOVFF  01,62A
06FB2:  MOVLB  0
06FB4:  CALL   4A3A
06FB8:  MOVFF  02,03
06FBC:  MOVF   01,W
06FBE:  SUBLW  01
06FC0:  BNZ   6FC6
06FC2:  MOVF   03,F
06FC4:  BZ    6FCE
06FC6:  MOVLW  02
06FC8:  MOVWF  01
06FCA:  BRA    7244
06FCC:  BRA    700E
....................    else arg2 = SERcmd[rec].p[3][0];
06FCE:  MOVLB  6
06FD0:  CLRF   x2B
06FD2:  MOVFF  5E8,62A
06FD6:  CLRF   x2D
06FD8:  MOVLW  B5
06FDA:  MOVWF  x2C
06FDC:  MOVLB  0
06FDE:  CALL   0858
06FE2:  MOVFF  02,5FB
06FE6:  MOVFF  01,5FA
06FEA:  MOVLW  06
06FEC:  MOVLB  5
06FEE:  ADDWF  xFA,F
06FF0:  MOVLW  00
06FF2:  ADDWFC xFB,F
06FF4:  MOVLW  4B
06FF6:  ADDWF  xFA,F
06FF8:  MOVLW  00
06FFA:  ADDWFC xFB,F
06FFC:  MOVLW  66
06FFE:  ADDWF  xFA,W
07000:  MOVWF  FE9
07002:  MOVLW  01
07004:  ADDWFC xFB,W
07006:  MOVWF  FEA
07008:  MOVFF  FEF,5F5
0700C:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0700E:  MOVLB  6
07010:  CLRF   x2B
07012:  MOVFF  5E8,62A
07016:  CLRF   x2D
07018:  MOVLW  B5
0701A:  MOVWF  x2C
0701C:  MOVLB  0
0701E:  CALL   0858
07022:  MOVFF  02,5FB
07026:  MOVFF  01,5FA
0702A:  MOVLW  06
0702C:  MOVLB  5
0702E:  ADDWF  xFA,F
07030:  MOVLW  00
07032:  ADDWFC xFB,F
07034:  MOVLW  64
07036:  ADDWF  xFA,W
07038:  MOVWF  01
0703A:  MOVLW  00
0703C:  ADDWFC xFB,W
0703E:  MOVWF  03
07040:  MOVF   01,W
07042:  ADDLW  66
07044:  MOVWF  01
07046:  MOVLW  01
07048:  ADDWFC 03,F
0704A:  MOVFF  01,5FA
0704E:  MOVFF  03,5FB
07052:  MOVFF  03,5FE
07056:  MOVFF  01,5FD
0705A:  MOVLB  0
0705C:  CALL   5D8C
07060:  MOVF   01,F
07062:  BNZ   706C
07064:  MOVLW  02
07066:  MOVWF  01
07068:  BRA    7244
0706A:  BRA    70D6
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0706C:  MOVLB  6
0706E:  CLRF   x2B
07070:  MOVFF  5E8,62A
07074:  CLRF   x2D
07076:  MOVLW  B5
07078:  MOVWF  x2C
0707A:  MOVLB  0
0707C:  CALL   0858
07080:  MOVFF  02,5FB
07084:  MOVFF  01,5FA
07088:  MOVLW  06
0708A:  MOVLB  5
0708C:  ADDWF  xFA,F
0708E:  MOVLW  00
07090:  ADDWFC xFB,F
07092:  MOVLW  64
07094:  ADDWF  xFA,W
07096:  MOVWF  01
07098:  MOVLW  00
0709A:  ADDWFC xFB,W
0709C:  MOVWF  03
0709E:  MOVF   01,W
070A0:  ADDLW  66
070A2:  MOVWF  01
070A4:  MOVLW  01
070A6:  ADDWFC 03,F
070A8:  MOVFF  01,5FA
070AC:  MOVFF  03,5FB
070B0:  MOVFF  03,5FE
070B4:  MOVFF  01,5FD
070B8:  MOVLB  6
070BA:  CLRF   x00
070BC:  MOVLB  5
070BE:  CLRF   xFF
070C0:  MOVLB  0
070C2:  CALL   5E60
070C6:  MOVFF  03,5F9
070CA:  MOVFF  02,5F8
070CE:  MOVFF  01,5F7
070D2:  MOVFF  00,5F6
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
070D6:  MOVLB  5
070D8:  MOVF   xF5,W
070DA:  SUBLW  30
070DC:  BNZ   7108
070DE:  MOVLW  01
070E0:  SUBWF  xF4,W
070E2:  MULLW  18
070E4:  MOVF   FF3,W
070E6:  CLRF   xFB
070E8:  MOVWF  xFA
070EA:  MOVLW  82
070EC:  ADDWF  xFA,W
070EE:  MOVWF  FE9
070F0:  MOVLW  00
070F2:  ADDWFC xFB,W
070F4:  MOVWF  FEA
070F6:  MOVFF  5F6,FEF
070FA:  MOVFF  5F7,FEC
070FE:  MOVFF  5F8,FEC
07102:  MOVFF  5F9,FEC
07106:  BRA    723E
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
07108:  MOVF   xF5,W
0710A:  SUBLW  31
0710C:  BNZ   7144
0710E:  MOVLW  01
07110:  SUBWF  xF4,W
07112:  MULLW  18
07114:  MOVF   FF3,W
07116:  CLRF   xFB
07118:  MOVWF  xFA
0711A:  MOVLW  04
0711C:  ADDWF  xFA,W
0711E:  MOVWF  01
07120:  MOVLW  00
07122:  ADDWFC xFB,W
07124:  MOVWF  03
07126:  MOVF   01,W
07128:  ADDLW  82
0712A:  MOVWF  FE9
0712C:  MOVLW  00
0712E:  ADDWFC 03,W
07130:  MOVWF  FEA
07132:  MOVFF  5F6,FEF
07136:  MOVFF  5F7,FEC
0713A:  MOVFF  5F8,FEC
0713E:  MOVFF  5F9,FEC
07142:  BRA    723E
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
07144:  MOVF   xF5,W
07146:  SUBLW  32
07148:  BNZ   7180
0714A:  MOVLW  01
0714C:  SUBWF  xF4,W
0714E:  MULLW  18
07150:  MOVF   FF3,W
07152:  CLRF   xFB
07154:  MOVWF  xFA
07156:  MOVLW  08
07158:  ADDWF  xFA,W
0715A:  MOVWF  01
0715C:  MOVLW  00
0715E:  ADDWFC xFB,W
07160:  MOVWF  03
07162:  MOVF   01,W
07164:  ADDLW  82
07166:  MOVWF  FE9
07168:  MOVLW  00
0716A:  ADDWFC 03,W
0716C:  MOVWF  FEA
0716E:  MOVFF  5F6,FEF
07172:  MOVFF  5F7,FEC
07176:  MOVFF  5F8,FEC
0717A:  MOVFF  5F9,FEC
0717E:  BRA    723E
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
07180:  MOVF   xF5,W
07182:  SUBLW  33
07184:  BNZ   71BC
07186:  MOVLW  01
07188:  SUBWF  xF4,W
0718A:  MULLW  18
0718C:  MOVF   FF3,W
0718E:  CLRF   xFB
07190:  MOVWF  xFA
07192:  MOVLW  0C
07194:  ADDWF  xFA,W
07196:  MOVWF  01
07198:  MOVLW  00
0719A:  ADDWFC xFB,W
0719C:  MOVWF  03
0719E:  MOVF   01,W
071A0:  ADDLW  82
071A2:  MOVWF  FE9
071A4:  MOVLW  00
071A6:  ADDWFC 03,W
071A8:  MOVWF  FEA
071AA:  MOVFF  5F6,FEF
071AE:  MOVFF  5F7,FEC
071B2:  MOVFF  5F8,FEC
071B6:  MOVFF  5F9,FEC
071BA:  BRA    723E
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
071BC:  MOVF   xF5,W
071BE:  SUBLW  34
071C0:  BNZ   71F8
071C2:  MOVLW  01
071C4:  SUBWF  xF4,W
071C6:  MULLW  18
071C8:  MOVF   FF3,W
071CA:  CLRF   xFB
071CC:  MOVWF  xFA
071CE:  MOVLW  10
071D0:  ADDWF  xFA,W
071D2:  MOVWF  01
071D4:  MOVLW  00
071D6:  ADDWFC xFB,W
071D8:  MOVWF  03
071DA:  MOVF   01,W
071DC:  ADDLW  82
071DE:  MOVWF  FE9
071E0:  MOVLW  00
071E2:  ADDWFC 03,W
071E4:  MOVWF  FEA
071E6:  MOVFF  5F6,FEF
071EA:  MOVFF  5F7,FEC
071EE:  MOVFF  5F8,FEC
071F2:  MOVFF  5F9,FEC
071F6:  BRA    723E
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
071F8:  MOVF   xF5,W
071FA:  SUBLW  35
071FC:  BNZ   7234
071FE:  MOVLW  01
07200:  SUBWF  xF4,W
07202:  MULLW  18
07204:  MOVF   FF3,W
07206:  CLRF   xFB
07208:  MOVWF  xFA
0720A:  MOVLW  14
0720C:  ADDWF  xFA,W
0720E:  MOVWF  01
07210:  MOVLW  00
07212:  ADDWFC xFB,W
07214:  MOVWF  03
07216:  MOVF   01,W
07218:  ADDLW  82
0721A:  MOVWF  FE9
0721C:  MOVLW  00
0721E:  ADDWFC 03,W
07220:  MOVWF  FEA
07222:  MOVFF  5F6,FEF
07226:  MOVFF  5F7,FEC
0722A:  MOVFF  5F8,FEC
0722E:  MOVFF  5F9,FEC
07232:  BRA    723E
....................    else return INV_PARAM;
07234:  MOVLW  02
07236:  MOVWF  01
07238:  MOVLB  0
0723A:  BRA    7244
0723C:  MOVLB  5
....................    
....................    return SUCCESS;
0723E:  MOVLW  00
07240:  MOVWF  01
07242:  MOVLB  0
07244:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
07246:  MOVLW  4E
07248:  MOVLB  5
0724A:  MOVWF  xF8
0724C:  MOVLW  31
0724E:  MOVWF  xF9
07250:  MOVLW  35
07252:  MOVWF  xFA
07254:  CLRF   xFB
07256:  MOVLW  05
07258:  MOVWF  xF7
0725A:  MOVLW  F8
0725C:  MOVWF  xF6
....................    char *s_200 = "200";
0725E:  MOVLW  32
07260:  MOVWF  xFE
07262:  MOVLW  30
07264:  MOVWF  xFF
07266:  MOVLB  6
07268:  MOVWF  x00
0726A:  CLRF   x01
0726C:  MOVLW  05
0726E:  MOVLB  5
07270:  MOVWF  xFD
07272:  MOVLW  FE
07274:  MOVWF  xFC
....................    char *s_5V6 = "5V6";
07276:  MOVLW  35
07278:  MOVLB  6
0727A:  MOVWF  x04
0727C:  MOVLW  56
0727E:  MOVWF  x05
07280:  MOVLW  36
07282:  MOVWF  x06
07284:  CLRF   x07
07286:  MOVLW  06
07288:  MOVWF  x03
0728A:  MOVLW  04
0728C:  MOVWF  x02
....................    char *s_5VA = "5VA";
0728E:  MOVLW  35
07290:  MOVWF  x0A
07292:  MOVLW  56
07294:  MOVWF  x0B
07296:  MOVLW  41
07298:  MOVWF  x0C
0729A:  CLRF   x0D
0729C:  MOVLW  06
0729E:  MOVWF  x09
072A0:  MOVLW  0A
072A2:  MOVWF  x08
....................    char *s_3V6X = "3V6X";
072A4:  MOVLW  33
072A6:  MOVWF  x10
072A8:  MOVLW  56
072AA:  MOVWF  x11
072AC:  MOVLW  36
072AE:  MOVWF  x12
072B0:  MOVLW  58
072B2:  MOVWF  x13
072B4:  CLRF   x14
072B6:  MOVLW  06
072B8:  MOVWF  x0F
072BA:  MOVLW  10
072BC:  MOVWF  x0E
....................    char *s_3V3A = "3V3A";
072BE:  MOVLW  33
072C0:  MOVWF  x17
072C2:  MOVLW  56
072C4:  MOVWF  x18
072C6:  MOVLW  33
072C8:  MOVWF  x19
072CA:  MOVLW  41
072CC:  MOVWF  x1A
072CE:  CLRF   x1B
072D0:  MOVLW  06
072D2:  MOVWF  x16
072D4:  MOVLW  17
072D6:  MOVWF  x15
....................    char *s_3V3D = "3V3D";
072D8:  MOVLW  33
072DA:  MOVWF  x1E
072DC:  MOVLW  56
072DE:  MOVWF  x1F
072E0:  MOVLW  33
072E2:  MOVWF  x20
072E4:  MOVLW  44
072E6:  MOVWF  x21
072E8:  CLRF   x22
072EA:  MOVLW  06
072EC:  MOVWF  x1D
072EE:  MOVLW  1E
072F0:  MOVWF  x1C
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
072F2:  CLRF   x2B
072F4:  MOVFF  5E8,62A
072F8:  CLRF   x2D
072FA:  MOVLW  B5
072FC:  MOVWF  x2C
072FE:  MOVLB  0
07300:  CALL   0858
07304:  MOVFF  02,624
07308:  MOVFF  01,623
0730C:  MOVLW  06
0730E:  MOVLB  6
07310:  ADDWF  x23,F
07312:  MOVLW  00
07314:  ADDWFC x24,F
07316:  MOVLW  32
07318:  ADDWF  x23,W
0731A:  MOVWF  01
0731C:  MOVLW  00
0731E:  ADDWFC x24,W
07320:  MOVWF  03
07322:  MOVF   01,W
07324:  ADDLW  66
07326:  MOVWF  01
07328:  MOVLW  01
0732A:  ADDWFC 03,F
0732C:  MOVFF  01,5F4
07330:  MOVLB  5
07332:  MOVFF  03,5F5
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
07336:  MOVFF  5F7,62B
0733A:  MOVFF  5F6,62A
0733E:  MOVFF  5F5,62D
07342:  MOVFF  5F4,62C
07346:  MOVLB  0
07348:  CALL   4A72
0734C:  MOVF   01,F
0734E:  BNZ   73D2
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
07350:  MOVLW  04
07352:  MOVLB  6
07354:  MOVWF  x2B
07356:  MOVLW  3C
07358:  MOVWF  x2A
0735A:  MOVLB  0
0735C:  CALL   4A3A
07360:  MOVFF  02,03
07364:  MOVF   01,W
07366:  ADDLW  3C
07368:  MOVLB  6
0736A:  MOVWF  x23
0736C:  MOVLW  04
0736E:  ADDWFC 02,W
07370:  MOVWF  x24
07372:  MOVFF  FE8,4E1
07376:  MOVFF  623,4E0
0737A:  MOVLW  89
0737C:  MOVWF  FE9
0737E:  MOVFF  B5,62F
07382:  MOVFF  B4,62E
07386:  MOVFF  B3,62D
0738A:  MOVFF  B2,62C
0738E:  MOVLW  02
07390:  MOVWF  x30
07392:  MOVLB  0
07394:  CALL   57C2
07398:  MOVLW  2C
0739A:  MOVLB  6
0739C:  MOVWF  x39
0739E:  MOVLB  0
073A0:  CALL   4AEA
073A4:  MOVLW  89
073A6:  MOVWF  FE9
073A8:  MOVFF  B9,62F
073AC:  MOVFF  B8,62E
073B0:  MOVFF  B7,62D
073B4:  MOVFF  B6,62C
073B8:  MOVLW  02
073BA:  MOVLB  6
073BC:  MOVWF  x30
073BE:  MOVLB  0
073C0:  CALL   57C2
073C4:  MOVLW  2C
073C6:  MOVLB  6
073C8:  MOVWF  x39
073CA:  MOVLB  0
073CC:  CALL   4AEA
....................    }
073D0:  BRA    7774
....................    else if (0 == strcmp(s_200, arg1)) {
073D2:  MOVFF  5FD,62B
073D6:  MOVFF  5FC,62A
073DA:  MOVFF  5F5,62D
073DE:  MOVFF  5F4,62C
073E2:  CALL   4A72
073E6:  MOVF   01,F
073E8:  BNZ   746C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
073EA:  MOVLW  04
073EC:  MOVLB  6
073EE:  MOVWF  x2B
073F0:  MOVLW  3C
073F2:  MOVWF  x2A
073F4:  MOVLB  0
073F6:  CALL   4A3A
073FA:  MOVFF  02,03
073FE:  MOVF   01,W
07400:  ADDLW  3C
07402:  MOVLB  6
07404:  MOVWF  x23
07406:  MOVLW  04
07408:  ADDWFC 02,W
0740A:  MOVWF  x24
0740C:  MOVFF  FE8,4E1
07410:  MOVFF  623,4E0
07414:  MOVLW  89
07416:  MOVWF  FE9
07418:  MOVFF  BD,62F
0741C:  MOVFF  BC,62E
07420:  MOVFF  BB,62D
07424:  MOVFF  BA,62C
07428:  MOVLW  02
0742A:  MOVWF  x30
0742C:  MOVLB  0
0742E:  CALL   57C2
07432:  MOVLW  2C
07434:  MOVLB  6
07436:  MOVWF  x39
07438:  MOVLB  0
0743A:  CALL   4AEA
0743E:  MOVLW  89
07440:  MOVWF  FE9
07442:  MOVFF  C1,62F
07446:  MOVFF  C0,62E
0744A:  MOVFF  BF,62D
0744E:  MOVFF  BE,62C
07452:  MOVLW  02
07454:  MOVLB  6
07456:  MOVWF  x30
07458:  MOVLB  0
0745A:  CALL   57C2
0745E:  MOVLW  2C
07460:  MOVLB  6
07462:  MOVWF  x39
07464:  MOVLB  0
07466:  CALL   4AEA
....................    }
0746A:  BRA    7774
....................    else if (0 == strcmp(s_5V6, arg1)) {
0746C:  MOVFF  603,62B
07470:  MOVFF  602,62A
07474:  MOVFF  5F5,62D
07478:  MOVFF  5F4,62C
0747C:  CALL   4A72
07480:  MOVF   01,F
07482:  BNZ   7506
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
07484:  MOVLW  04
07486:  MOVLB  6
07488:  MOVWF  x2B
0748A:  MOVLW  3C
0748C:  MOVWF  x2A
0748E:  MOVLB  0
07490:  CALL   4A3A
07494:  MOVFF  02,03
07498:  MOVF   01,W
0749A:  ADDLW  3C
0749C:  MOVLB  6
0749E:  MOVWF  x23
074A0:  MOVLW  04
074A2:  ADDWFC 02,W
074A4:  MOVWF  x24
074A6:  MOVFF  FE8,4E1
074AA:  MOVFF  623,4E0
074AE:  MOVLW  89
074B0:  MOVWF  FE9
074B2:  MOVFF  C5,62F
074B6:  MOVFF  C4,62E
074BA:  MOVFF  C3,62D
074BE:  MOVFF  C2,62C
074C2:  MOVLW  02
074C4:  MOVWF  x30
074C6:  MOVLB  0
074C8:  CALL   57C2
074CC:  MOVLW  2C
074CE:  MOVLB  6
074D0:  MOVWF  x39
074D2:  MOVLB  0
074D4:  CALL   4AEA
074D8:  MOVLW  89
074DA:  MOVWF  FE9
074DC:  MOVFF  C9,62F
074E0:  MOVFF  C8,62E
074E4:  MOVFF  C7,62D
074E8:  MOVFF  C6,62C
074EC:  MOVLW  02
074EE:  MOVLB  6
074F0:  MOVWF  x30
074F2:  MOVLB  0
074F4:  CALL   57C2
074F8:  MOVLW  2C
074FA:  MOVLB  6
074FC:  MOVWF  x39
074FE:  MOVLB  0
07500:  CALL   4AEA
....................    }
07504:  BRA    7774
....................    else if (0 == strcmp(s_5VA, arg1)) {
07506:  MOVFF  609,62B
0750A:  MOVFF  608,62A
0750E:  MOVFF  5F5,62D
07512:  MOVFF  5F4,62C
07516:  CALL   4A72
0751A:  MOVF   01,F
0751C:  BNZ   75A0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
0751E:  MOVLW  04
07520:  MOVLB  6
07522:  MOVWF  x2B
07524:  MOVLW  3C
07526:  MOVWF  x2A
07528:  MOVLB  0
0752A:  CALL   4A3A
0752E:  MOVFF  02,03
07532:  MOVF   01,W
07534:  ADDLW  3C
07536:  MOVLB  6
07538:  MOVWF  x23
0753A:  MOVLW  04
0753C:  ADDWFC 02,W
0753E:  MOVWF  x24
07540:  MOVFF  FE8,4E1
07544:  MOVFF  623,4E0
07548:  MOVLW  89
0754A:  MOVWF  FE9
0754C:  MOVFF  CD,62F
07550:  MOVFF  CC,62E
07554:  MOVFF  CB,62D
07558:  MOVFF  CA,62C
0755C:  MOVLW  02
0755E:  MOVWF  x30
07560:  MOVLB  0
07562:  CALL   57C2
07566:  MOVLW  2C
07568:  MOVLB  6
0756A:  MOVWF  x39
0756C:  MOVLB  0
0756E:  CALL   4AEA
07572:  MOVLW  89
07574:  MOVWF  FE9
07576:  MOVFF  D1,62F
0757A:  MOVFF  D0,62E
0757E:  MOVFF  CF,62D
07582:  MOVFF  CE,62C
07586:  MOVLW  02
07588:  MOVLB  6
0758A:  MOVWF  x30
0758C:  MOVLB  0
0758E:  CALL   57C2
07592:  MOVLW  2C
07594:  MOVLB  6
07596:  MOVWF  x39
07598:  MOVLB  0
0759A:  CALL   4AEA
....................    }
0759E:  BRA    7774
....................    else if (0 == strcmp(s_3V6X, arg1)) {
075A0:  MOVFF  60F,62B
075A4:  MOVFF  60E,62A
075A8:  MOVFF  5F5,62D
075AC:  MOVFF  5F4,62C
075B0:  CALL   4A72
075B4:  MOVF   01,F
075B6:  BNZ   763A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
075B8:  MOVLW  04
075BA:  MOVLB  6
075BC:  MOVWF  x2B
075BE:  MOVLW  3C
075C0:  MOVWF  x2A
075C2:  MOVLB  0
075C4:  CALL   4A3A
075C8:  MOVFF  02,03
075CC:  MOVF   01,W
075CE:  ADDLW  3C
075D0:  MOVLB  6
075D2:  MOVWF  x23
075D4:  MOVLW  04
075D6:  ADDWFC 02,W
075D8:  MOVWF  x24
075DA:  MOVFF  FE8,4E1
075DE:  MOVFF  623,4E0
075E2:  MOVLW  89
075E4:  MOVWF  FE9
075E6:  MOVFF  D5,62F
075EA:  MOVFF  D4,62E
075EE:  MOVFF  D3,62D
075F2:  MOVFF  D2,62C
075F6:  MOVLW  02
075F8:  MOVWF  x30
075FA:  MOVLB  0
075FC:  CALL   57C2
07600:  MOVLW  2C
07602:  MOVLB  6
07604:  MOVWF  x39
07606:  MOVLB  0
07608:  CALL   4AEA
0760C:  MOVLW  89
0760E:  MOVWF  FE9
07610:  MOVFF  D9,62F
07614:  MOVFF  D8,62E
07618:  MOVFF  D7,62D
0761C:  MOVFF  D6,62C
07620:  MOVLW  02
07622:  MOVLB  6
07624:  MOVWF  x30
07626:  MOVLB  0
07628:  CALL   57C2
0762C:  MOVLW  2C
0762E:  MOVLB  6
07630:  MOVWF  x39
07632:  MOVLB  0
07634:  CALL   4AEA
....................    }
07638:  BRA    7774
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0763A:  MOVFF  616,62B
0763E:  MOVFF  615,62A
07642:  MOVFF  5F5,62D
07646:  MOVFF  5F4,62C
0764A:  CALL   4A72
0764E:  MOVF   01,F
07650:  BNZ   76D4
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
07652:  MOVLW  04
07654:  MOVLB  6
07656:  MOVWF  x2B
07658:  MOVLW  3C
0765A:  MOVWF  x2A
0765C:  MOVLB  0
0765E:  CALL   4A3A
07662:  MOVFF  02,03
07666:  MOVF   01,W
07668:  ADDLW  3C
0766A:  MOVLB  6
0766C:  MOVWF  x23
0766E:  MOVLW  04
07670:  ADDWFC 02,W
07672:  MOVWF  x24
07674:  MOVFF  FE8,4E1
07678:  MOVFF  623,4E0
0767C:  MOVLW  89
0767E:  MOVWF  FE9
07680:  MOVFF  DD,62F
07684:  MOVFF  DC,62E
07688:  MOVFF  DB,62D
0768C:  MOVFF  DA,62C
07690:  MOVLW  02
07692:  MOVWF  x30
07694:  MOVLB  0
07696:  CALL   57C2
0769A:  MOVLW  2C
0769C:  MOVLB  6
0769E:  MOVWF  x39
076A0:  MOVLB  0
076A2:  CALL   4AEA
076A6:  MOVLW  89
076A8:  MOVWF  FE9
076AA:  MOVFF  E1,62F
076AE:  MOVFF  E0,62E
076B2:  MOVFF  DF,62D
076B6:  MOVFF  DE,62C
076BA:  MOVLW  02
076BC:  MOVLB  6
076BE:  MOVWF  x30
076C0:  MOVLB  0
076C2:  CALL   57C2
076C6:  MOVLW  2C
076C8:  MOVLB  6
076CA:  MOVWF  x39
076CC:  MOVLB  0
076CE:  CALL   4AEA
....................    }
076D2:  BRA    7774
....................    else if (0 == strcmp(s_3V3D, arg1)) {
076D4:  MOVFF  61D,62B
076D8:  MOVFF  61C,62A
076DC:  MOVFF  5F5,62D
076E0:  MOVFF  5F4,62C
076E4:  CALL   4A72
076E8:  MOVF   01,F
076EA:  BNZ   776E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
076EC:  MOVLW  04
076EE:  MOVLB  6
076F0:  MOVWF  x2B
076F2:  MOVLW  3C
076F4:  MOVWF  x2A
076F6:  MOVLB  0
076F8:  CALL   4A3A
076FC:  MOVFF  02,03
07700:  MOVF   01,W
07702:  ADDLW  3C
07704:  MOVLB  6
07706:  MOVWF  x23
07708:  MOVLW  04
0770A:  ADDWFC 02,W
0770C:  MOVWF  x24
0770E:  MOVFF  FE8,4E1
07712:  MOVFF  623,4E0
07716:  MOVLW  89
07718:  MOVWF  FE9
0771A:  MOVFF  E5,62F
0771E:  MOVFF  E4,62E
07722:  MOVFF  E3,62D
07726:  MOVFF  E2,62C
0772A:  MOVLW  02
0772C:  MOVWF  x30
0772E:  MOVLB  0
07730:  CALL   57C2
07734:  MOVLW  2C
07736:  MOVLB  6
07738:  MOVWF  x39
0773A:  MOVLB  0
0773C:  CALL   4AEA
07740:  MOVLW  89
07742:  MOVWF  FE9
07744:  MOVFF  E9,62F
07748:  MOVFF  E8,62E
0774C:  MOVFF  E7,62D
07750:  MOVFF  E6,62C
07754:  MOVLW  02
07756:  MOVLB  6
07758:  MOVWF  x30
0775A:  MOVLB  0
0775C:  CALL   57C2
07760:  MOVLW  2C
07762:  MOVLB  6
07764:  MOVWF  x39
07766:  MOVLB  0
07768:  CALL   4AEA
....................    }
0776C:  BRA    7774
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
0776E:  MOVLW  02
07770:  MOVWF  01
07772:  BRA    7778
....................    
....................    return SUCCESS;
07774:  MOVLW  00
07776:  MOVWF  01
07778:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
0777A:  MOVLW  00
0777C:  MOVWF  01
0777E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
07780:  MOVLW  4E
07782:  MOVLB  5
07784:  MOVWF  xF8
07786:  MOVLW  31
07788:  MOVWF  xF9
0778A:  MOVLW  35
0778C:  MOVWF  xFA
0778E:  CLRF   xFB
07790:  MOVLW  05
07792:  MOVWF  xF7
07794:  MOVLW  F8
07796:  MOVWF  xF6
....................    char *s_200 = "200";
07798:  MOVLW  32
0779A:  MOVWF  xFE
0779C:  MOVLW  30
0779E:  MOVWF  xFF
077A0:  MOVLB  6
077A2:  MOVWF  x00
077A4:  CLRF   x01
077A6:  MOVLW  05
077A8:  MOVLB  5
077AA:  MOVWF  xFD
077AC:  MOVLW  FE
077AE:  MOVWF  xFC
....................    char *s_5V6 = "5V6";
077B0:  MOVLW  35
077B2:  MOVLB  6
077B4:  MOVWF  x04
077B6:  MOVLW  56
077B8:  MOVWF  x05
077BA:  MOVLW  36
077BC:  MOVWF  x06
077BE:  CLRF   x07
077C0:  MOVLW  06
077C2:  MOVWF  x03
077C4:  MOVLW  04
077C6:  MOVWF  x02
....................    char *s_5VA = "5VA";
077C8:  MOVLW  35
077CA:  MOVWF  x0A
077CC:  MOVLW  56
077CE:  MOVWF  x0B
077D0:  MOVLW  41
077D2:  MOVWF  x0C
077D4:  CLRF   x0D
077D6:  MOVLW  06
077D8:  MOVWF  x09
077DA:  MOVLW  0A
077DC:  MOVWF  x08
....................    char *s_3V6X = "3V6X";
077DE:  MOVLW  33
077E0:  MOVWF  x10
077E2:  MOVLW  56
077E4:  MOVWF  x11
077E6:  MOVLW  36
077E8:  MOVWF  x12
077EA:  MOVLW  58
077EC:  MOVWF  x13
077EE:  CLRF   x14
077F0:  MOVLW  06
077F2:  MOVWF  x0F
077F4:  MOVLW  10
077F6:  MOVWF  x0E
....................    char *s_3V3A = "3V3A";
077F8:  MOVLW  33
077FA:  MOVWF  x17
077FC:  MOVLW  56
077FE:  MOVWF  x18
07800:  MOVLW  33
07802:  MOVWF  x19
07804:  MOVLW  41
07806:  MOVWF  x1A
07808:  CLRF   x1B
0780A:  MOVLW  06
0780C:  MOVWF  x16
0780E:  MOVLW  17
07810:  MOVWF  x15
....................    char *s_3V3D = "3V3D";
07812:  MOVLW  33
07814:  MOVWF  x1E
07816:  MOVLW  56
07818:  MOVWF  x1F
0781A:  MOVLW  33
0781C:  MOVWF  x20
0781E:  MOVLW  44
07820:  MOVWF  x21
07822:  CLRF   x22
07824:  MOVLW  06
07826:  MOVWF  x1D
07828:  MOVLW  1E
0782A:  MOVWF  x1C
....................    char *s_all = "all";
0782C:  MOVLW  61
0782E:  MOVWF  x25
07830:  MOVLW  6C
07832:  MOVWF  x26
07834:  MOVWF  x27
07836:  CLRF   x28
07838:  MOVLW  06
0783A:  MOVWF  x24
0783C:  MOVLW  25
0783E:  MOVWF  x23
....................    
....................    arg1 = SERcmd[rec].p[2];
07840:  CLRF   x2B
07842:  MOVFF  5E8,62A
07846:  CLRF   x2D
07848:  MOVLW  B5
0784A:  MOVWF  x2C
0784C:  MOVLB  0
0784E:  CALL   0858
07852:  MOVFF  02,62A
07856:  MOVFF  01,629
0785A:  MOVLW  06
0785C:  MOVLB  6
0785E:  ADDWF  x29,F
07860:  MOVLW  00
07862:  ADDWFC x2A,F
07864:  MOVLW  32
07866:  ADDWF  x29,W
07868:  MOVWF  01
0786A:  MOVLW  00
0786C:  ADDWFC x2A,W
0786E:  MOVWF  03
07870:  MOVF   01,W
07872:  ADDLW  66
07874:  MOVWF  01
07876:  MOVLW  01
07878:  ADDWFC 03,F
0787A:  MOVFF  01,5F4
0787E:  MOVLB  5
07880:  MOVFF  03,5F5
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
07884:  MOVFF  5F7,62B
07888:  MOVFF  5F6,62A
0788C:  MOVFF  5F5,62D
07890:  MOVFF  5F4,62C
07894:  MOVLB  0
07896:  CALL   4A72
0789A:  MOVF   01,F
0789C:  BNZ   78F4
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0789E:  MOVLW  04
078A0:  MOVLB  6
078A2:  MOVWF  x2B
078A4:  MOVLW  3C
078A6:  MOVWF  x2A
078A8:  MOVLB  0
078AA:  CALL   4A3A
078AE:  MOVFF  02,03
078B2:  MOVF   01,W
078B4:  ADDLW  3C
078B6:  MOVLB  6
078B8:  MOVWF  x29
078BA:  MOVLW  04
078BC:  ADDWFC 02,W
078BE:  MOVWF  x2A
078C0:  MOVFF  FE8,4E1
078C4:  MOVFF  629,4E0
078C8:  MOVLW  89
078CA:  MOVWF  FE9
078CC:  MOVFF  F6,62F
078D0:  MOVFF  F5,62E
078D4:  MOVFF  F4,62D
078D8:  MOVFF  F3,62C
078DC:  MOVLW  02
078DE:  MOVWF  x30
078E0:  MOVLB  0
078E2:  CALL   57C2
078E6:  MOVLW  2C
078E8:  MOVLB  6
078EA:  MOVWF  x39
078EC:  MOVLB  0
078EE:  CALL   4AEA
....................    }
078F2:  BRA    7DF6
....................    else if (0 == strcmp(s_200, arg1)) {
078F4:  MOVFF  5FD,62B
078F8:  MOVFF  5FC,62A
078FC:  MOVFF  5F5,62D
07900:  MOVFF  5F4,62C
07904:  CALL   4A72
07908:  MOVF   01,F
0790A:  BNZ   7962
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
0790C:  MOVLW  04
0790E:  MOVLB  6
07910:  MOVWF  x2B
07912:  MOVLW  3C
07914:  MOVWF  x2A
07916:  MOVLB  0
07918:  CALL   4A3A
0791C:  MOVFF  02,03
07920:  MOVF   01,W
07922:  ADDLW  3C
07924:  MOVLB  6
07926:  MOVWF  x29
07928:  MOVLW  04
0792A:  ADDWFC 02,W
0792C:  MOVWF  x2A
0792E:  MOVFF  FE8,4E1
07932:  MOVFF  629,4E0
07936:  MOVLW  89
07938:  MOVWF  FE9
0793A:  MOVFF  FA,62F
0793E:  MOVFF  F9,62E
07942:  MOVFF  F8,62D
07946:  MOVFF  F7,62C
0794A:  MOVLW  01
0794C:  MOVWF  x30
0794E:  MOVLB  0
07950:  CALL   57C2
07954:  MOVLW  2C
07956:  MOVLB  6
07958:  MOVWF  x39
0795A:  MOVLB  0
0795C:  CALL   4AEA
....................    }
07960:  BRA    7DF6
....................    else if (0 == strcmp(s_5V6, arg1)) {
07962:  MOVFF  603,62B
07966:  MOVFF  602,62A
0796A:  MOVFF  5F5,62D
0796E:  MOVFF  5F4,62C
07972:  CALL   4A72
07976:  MOVF   01,F
07978:  BNZ   79D0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
0797A:  MOVLW  04
0797C:  MOVLB  6
0797E:  MOVWF  x2B
07980:  MOVLW  3C
07982:  MOVWF  x2A
07984:  MOVLB  0
07986:  CALL   4A3A
0798A:  MOVFF  02,03
0798E:  MOVF   01,W
07990:  ADDLW  3C
07992:  MOVLB  6
07994:  MOVWF  x29
07996:  MOVLW  04
07998:  ADDWFC 02,W
0799A:  MOVWF  x2A
0799C:  MOVFF  FE8,4E1
079A0:  MOVFF  629,4E0
079A4:  MOVLW  89
079A6:  MOVWF  FE9
079A8:  MOVFF  FE,62F
079AC:  MOVFF  FD,62E
079B0:  MOVFF  FC,62D
079B4:  MOVFF  FB,62C
079B8:  MOVLW  03
079BA:  MOVWF  x30
079BC:  MOVLB  0
079BE:  CALL   57C2
079C2:  MOVLW  2C
079C4:  MOVLB  6
079C6:  MOVWF  x39
079C8:  MOVLB  0
079CA:  CALL   4AEA
....................    }
079CE:  BRA    7DF6
....................    else if (0 == strcmp(s_5VA, arg1)) {
079D0:  MOVFF  609,62B
079D4:  MOVFF  608,62A
079D8:  MOVFF  5F5,62D
079DC:  MOVFF  5F4,62C
079E0:  CALL   4A72
079E4:  MOVF   01,F
079E6:  BNZ   7A3E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
079E8:  MOVLW  04
079EA:  MOVLB  6
079EC:  MOVWF  x2B
079EE:  MOVLW  3C
079F0:  MOVWF  x2A
079F2:  MOVLB  0
079F4:  CALL   4A3A
079F8:  MOVFF  02,03
079FC:  MOVF   01,W
079FE:  ADDLW  3C
07A00:  MOVLB  6
07A02:  MOVWF  x29
07A04:  MOVLW  04
07A06:  ADDWFC 02,W
07A08:  MOVWF  x2A
07A0A:  MOVFF  FE8,4E1
07A0E:  MOVFF  629,4E0
07A12:  MOVLW  89
07A14:  MOVWF  FE9
07A16:  MOVFF  102,62F
07A1A:  MOVFF  101,62E
07A1E:  MOVFF  100,62D
07A22:  MOVFF  FF,62C
07A26:  MOVLW  03
07A28:  MOVWF  x30
07A2A:  MOVLB  0
07A2C:  CALL   57C2
07A30:  MOVLW  2C
07A32:  MOVLB  6
07A34:  MOVWF  x39
07A36:  MOVLB  0
07A38:  CALL   4AEA
....................    }
07A3C:  BRA    7DF6
....................    else if (0 == strcmp(s_3V6X, arg1)) {
07A3E:  MOVFF  60F,62B
07A42:  MOVFF  60E,62A
07A46:  MOVFF  5F5,62D
07A4A:  MOVFF  5F4,62C
07A4E:  CALL   4A72
07A52:  MOVF   01,F
07A54:  BNZ   7AAC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
07A56:  MOVLW  04
07A58:  MOVLB  6
07A5A:  MOVWF  x2B
07A5C:  MOVLW  3C
07A5E:  MOVWF  x2A
07A60:  MOVLB  0
07A62:  CALL   4A3A
07A66:  MOVFF  02,03
07A6A:  MOVF   01,W
07A6C:  ADDLW  3C
07A6E:  MOVLB  6
07A70:  MOVWF  x29
07A72:  MOVLW  04
07A74:  ADDWFC 02,W
07A76:  MOVWF  x2A
07A78:  MOVFF  FE8,4E1
07A7C:  MOVFF  629,4E0
07A80:  MOVLW  89
07A82:  MOVWF  FE9
07A84:  MOVFF  106,62F
07A88:  MOVFF  105,62E
07A8C:  MOVFF  104,62D
07A90:  MOVFF  103,62C
07A94:  MOVLW  03
07A96:  MOVWF  x30
07A98:  MOVLB  0
07A9A:  CALL   57C2
07A9E:  MOVLW  2C
07AA0:  MOVLB  6
07AA2:  MOVWF  x39
07AA4:  MOVLB  0
07AA6:  CALL   4AEA
....................    }
07AAA:  BRA    7DF6
....................    else if (0 == strcmp(s_3V3A, arg1)) {
07AAC:  MOVFF  616,62B
07AB0:  MOVFF  615,62A
07AB4:  MOVFF  5F5,62D
07AB8:  MOVFF  5F4,62C
07ABC:  CALL   4A72
07AC0:  MOVF   01,F
07AC2:  BNZ   7B1A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
07AC4:  MOVLW  04
07AC6:  MOVLB  6
07AC8:  MOVWF  x2B
07ACA:  MOVLW  3C
07ACC:  MOVWF  x2A
07ACE:  MOVLB  0
07AD0:  CALL   4A3A
07AD4:  MOVFF  02,03
07AD8:  MOVF   01,W
07ADA:  ADDLW  3C
07ADC:  MOVLB  6
07ADE:  MOVWF  x29
07AE0:  MOVLW  04
07AE2:  ADDWFC 02,W
07AE4:  MOVWF  x2A
07AE6:  MOVFF  FE8,4E1
07AEA:  MOVFF  629,4E0
07AEE:  MOVLW  89
07AF0:  MOVWF  FE9
07AF2:  MOVFF  10A,62F
07AF6:  MOVFF  109,62E
07AFA:  MOVFF  108,62D
07AFE:  MOVFF  107,62C
07B02:  MOVLW  03
07B04:  MOVWF  x30
07B06:  MOVLB  0
07B08:  CALL   57C2
07B0C:  MOVLW  2C
07B0E:  MOVLB  6
07B10:  MOVWF  x39
07B12:  MOVLB  0
07B14:  CALL   4AEA
....................    }
07B18:  BRA    7DF6
....................    else if (0 == strcmp(s_3V3D, arg1)) {
07B1A:  MOVFF  61D,62B
07B1E:  MOVFF  61C,62A
07B22:  MOVFF  5F5,62D
07B26:  MOVFF  5F4,62C
07B2A:  CALL   4A72
07B2E:  MOVF   01,F
07B30:  BNZ   7B88
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
07B32:  MOVLW  04
07B34:  MOVLB  6
07B36:  MOVWF  x2B
07B38:  MOVLW  3C
07B3A:  MOVWF  x2A
07B3C:  MOVLB  0
07B3E:  CALL   4A3A
07B42:  MOVFF  02,03
07B46:  MOVF   01,W
07B48:  ADDLW  3C
07B4A:  MOVLB  6
07B4C:  MOVWF  x29
07B4E:  MOVLW  04
07B50:  ADDWFC 02,W
07B52:  MOVWF  x2A
07B54:  MOVFF  FE8,4E1
07B58:  MOVFF  629,4E0
07B5C:  MOVLW  89
07B5E:  MOVWF  FE9
07B60:  MOVFF  10E,62F
07B64:  MOVFF  10D,62E
07B68:  MOVFF  10C,62D
07B6C:  MOVFF  10B,62C
07B70:  MOVLW  03
07B72:  MOVWF  x30
07B74:  MOVLB  0
07B76:  CALL   57C2
07B7A:  MOVLW  2C
07B7C:  MOVLB  6
07B7E:  MOVWF  x39
07B80:  MOVLB  0
07B82:  CALL   4AEA
....................    }
07B86:  BRA    7DF6
....................    else if (0 == strcmp(s_all, arg1)) {
07B88:  MOVFF  624,62B
07B8C:  MOVFF  623,62A
07B90:  MOVFF  5F5,62D
07B94:  MOVFF  5F4,62C
07B98:  CALL   4A72
07B9C:  MOVF   01,F
07B9E:  BTFSS  FD8.2
07BA0:  BRA    7DF0
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
07BA2:  MOVLW  04
07BA4:  MOVLB  6
07BA6:  MOVWF  x2B
07BA8:  MOVLW  3C
07BAA:  MOVWF  x2A
07BAC:  MOVLB  0
07BAE:  CALL   4A3A
07BB2:  MOVFF  02,03
07BB6:  MOVF   01,W
07BB8:  ADDLW  3C
07BBA:  MOVLB  6
07BBC:  MOVWF  x29
07BBE:  MOVLW  04
07BC0:  ADDWFC 02,W
07BC2:  MOVWF  x2A
07BC4:  MOVFF  FE8,4E1
07BC8:  MOVFF  629,4E0
07BCC:  MOVLW  89
07BCE:  MOVWF  FE9
07BD0:  MOVFF  F6,62F
07BD4:  MOVFF  F5,62E
07BD8:  MOVFF  F4,62D
07BDC:  MOVFF  F3,62C
07BE0:  MOVLW  02
07BE2:  MOVWF  x30
07BE4:  MOVLB  0
07BE6:  CALL   57C2
07BEA:  MOVLW  2C
07BEC:  MOVLB  6
07BEE:  MOVWF  x39
07BF0:  MOVLB  0
07BF2:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
07BF6:  MOVLW  04
07BF8:  MOVLB  6
07BFA:  MOVWF  x2B
07BFC:  MOVLW  3C
07BFE:  MOVWF  x2A
07C00:  MOVLB  0
07C02:  CALL   4A3A
07C06:  MOVFF  02,03
07C0A:  MOVF   01,W
07C0C:  ADDLW  3C
07C0E:  MOVLB  6
07C10:  MOVWF  x29
07C12:  MOVLW  04
07C14:  ADDWFC 02,W
07C16:  MOVWF  x2A
07C18:  MOVFF  FE8,4E1
07C1C:  MOVFF  629,4E0
07C20:  MOVLW  89
07C22:  MOVWF  FE9
07C24:  MOVFF  FA,62F
07C28:  MOVFF  F9,62E
07C2C:  MOVFF  F8,62D
07C30:  MOVFF  F7,62C
07C34:  MOVLW  01
07C36:  MOVWF  x30
07C38:  MOVLB  0
07C3A:  CALL   57C2
07C3E:  MOVLW  2C
07C40:  MOVLB  6
07C42:  MOVWF  x39
07C44:  MOVLB  0
07C46:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
07C4A:  MOVLW  04
07C4C:  MOVLB  6
07C4E:  MOVWF  x2B
07C50:  MOVLW  3C
07C52:  MOVWF  x2A
07C54:  MOVLB  0
07C56:  CALL   4A3A
07C5A:  MOVFF  02,03
07C5E:  MOVF   01,W
07C60:  ADDLW  3C
07C62:  MOVLB  6
07C64:  MOVWF  x29
07C66:  MOVLW  04
07C68:  ADDWFC 02,W
07C6A:  MOVWF  x2A
07C6C:  MOVFF  FE8,4E1
07C70:  MOVFF  629,4E0
07C74:  MOVLW  89
07C76:  MOVWF  FE9
07C78:  MOVFF  FE,62F
07C7C:  MOVFF  FD,62E
07C80:  MOVFF  FC,62D
07C84:  MOVFF  FB,62C
07C88:  MOVLW  03
07C8A:  MOVWF  x30
07C8C:  MOVLB  0
07C8E:  CALL   57C2
07C92:  MOVLW  2C
07C94:  MOVLB  6
07C96:  MOVWF  x39
07C98:  MOVLB  0
07C9A:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
07C9E:  MOVLW  04
07CA0:  MOVLB  6
07CA2:  MOVWF  x2B
07CA4:  MOVLW  3C
07CA6:  MOVWF  x2A
07CA8:  MOVLB  0
07CAA:  CALL   4A3A
07CAE:  MOVFF  02,03
07CB2:  MOVF   01,W
07CB4:  ADDLW  3C
07CB6:  MOVLB  6
07CB8:  MOVWF  x29
07CBA:  MOVLW  04
07CBC:  ADDWFC 02,W
07CBE:  MOVWF  x2A
07CC0:  MOVFF  FE8,4E1
07CC4:  MOVFF  629,4E0
07CC8:  MOVLW  89
07CCA:  MOVWF  FE9
07CCC:  MOVFF  102,62F
07CD0:  MOVFF  101,62E
07CD4:  MOVFF  100,62D
07CD8:  MOVFF  FF,62C
07CDC:  MOVLW  03
07CDE:  MOVWF  x30
07CE0:  MOVLB  0
07CE2:  CALL   57C2
07CE6:  MOVLW  2C
07CE8:  MOVLB  6
07CEA:  MOVWF  x39
07CEC:  MOVLB  0
07CEE:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
07CF2:  MOVLW  04
07CF4:  MOVLB  6
07CF6:  MOVWF  x2B
07CF8:  MOVLW  3C
07CFA:  MOVWF  x2A
07CFC:  MOVLB  0
07CFE:  CALL   4A3A
07D02:  MOVFF  02,03
07D06:  MOVF   01,W
07D08:  ADDLW  3C
07D0A:  MOVLB  6
07D0C:  MOVWF  x29
07D0E:  MOVLW  04
07D10:  ADDWFC 02,W
07D12:  MOVWF  x2A
07D14:  MOVFF  FE8,4E1
07D18:  MOVFF  629,4E0
07D1C:  MOVLW  89
07D1E:  MOVWF  FE9
07D20:  MOVFF  106,62F
07D24:  MOVFF  105,62E
07D28:  MOVFF  104,62D
07D2C:  MOVFF  103,62C
07D30:  MOVLW  03
07D32:  MOVWF  x30
07D34:  MOVLB  0
07D36:  CALL   57C2
07D3A:  MOVLW  2C
07D3C:  MOVLB  6
07D3E:  MOVWF  x39
07D40:  MOVLB  0
07D42:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
07D46:  MOVLW  04
07D48:  MOVLB  6
07D4A:  MOVWF  x2B
07D4C:  MOVLW  3C
07D4E:  MOVWF  x2A
07D50:  MOVLB  0
07D52:  CALL   4A3A
07D56:  MOVFF  02,03
07D5A:  MOVF   01,W
07D5C:  ADDLW  3C
07D5E:  MOVLB  6
07D60:  MOVWF  x29
07D62:  MOVLW  04
07D64:  ADDWFC 02,W
07D66:  MOVWF  x2A
07D68:  MOVFF  FE8,4E1
07D6C:  MOVFF  629,4E0
07D70:  MOVLW  89
07D72:  MOVWF  FE9
07D74:  MOVFF  10A,62F
07D78:  MOVFF  109,62E
07D7C:  MOVFF  108,62D
07D80:  MOVFF  107,62C
07D84:  MOVLW  03
07D86:  MOVWF  x30
07D88:  MOVLB  0
07D8A:  CALL   57C2
07D8E:  MOVLW  2C
07D90:  MOVLB  6
07D92:  MOVWF  x39
07D94:  MOVLB  0
07D96:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
07D9A:  MOVLW  04
07D9C:  MOVLB  6
07D9E:  MOVWF  x2B
07DA0:  MOVLW  3C
07DA2:  MOVWF  x2A
07DA4:  MOVLB  0
07DA6:  CALL   4A3A
07DAA:  MOVFF  02,03
07DAE:  MOVF   01,W
07DB0:  ADDLW  3C
07DB2:  MOVLB  6
07DB4:  MOVWF  x29
07DB6:  MOVLW  04
07DB8:  ADDWFC 02,W
07DBA:  MOVWF  x2A
07DBC:  MOVFF  FE8,4E1
07DC0:  MOVFF  629,4E0
07DC4:  MOVLW  89
07DC6:  MOVWF  FE9
07DC8:  MOVFF  10E,62F
07DCC:  MOVFF  10D,62E
07DD0:  MOVFF  10C,62D
07DD4:  MOVFF  10B,62C
07DD8:  MOVLW  03
07DDA:  MOVWF  x30
07DDC:  MOVLB  0
07DDE:  CALL   57C2
07DE2:  MOVLW  2C
07DE4:  MOVLB  6
07DE6:  MOVWF  x39
07DE8:  MOVLB  0
07DEA:  CALL   4AEA
....................    }
07DEE:  BRA    7DF6
....................    else return INV_PARAM;
07DF0:  MOVLW  02
07DF2:  MOVWF  01
07DF4:  BRA    7DFA
....................    
....................    return SUCCESS;
07DF6:  MOVLW  00
07DF8:  MOVWF  01
07DFA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
07DFC:  MOVLW  50
07DFE:  MOVLB  5
07E00:  MOVWF  xF9
07E02:  MOVLW  56
07E04:  MOVWF  xFA
07E06:  CLRF   xFB
07E08:  MOVLW  05
07E0A:  MOVWF  xF8
07E0C:  MOVLW  F9
07E0E:  MOVWF  xF7
....................    char *s_CV = "CV";
07E10:  MOVLW  43
07E12:  MOVWF  xFE
07E14:  MOVLW  56
07E16:  MOVWF  xFF
07E18:  MOVLB  6
07E1A:  CLRF   x00
07E1C:  MOVLW  05
07E1E:  MOVLB  5
07E20:  MOVWF  xFD
07E22:  MOVLW  FE
07E24:  MOVWF  xFC
....................    char *s_PVold = "PVold";
07E26:  MOVLW  50
07E28:  MOVLB  6
07E2A:  MOVWF  x03
07E2C:  MOVLW  56
07E2E:  MOVWF  x04
07E30:  MOVLW  6F
07E32:  MOVWF  x05
07E34:  MOVLW  6C
07E36:  MOVWF  x06
07E38:  MOVLW  64
07E3A:  MOVWF  x07
07E3C:  CLRF   x08
07E3E:  MOVLW  06
07E40:  MOVWF  x02
07E42:  MOVLW  03
07E44:  MOVWF  x01
....................    char *s_I = "I";
07E46:  MOVLW  49
07E48:  MOVWF  x0B
07E4A:  CLRF   x0C
07E4C:  MOVLW  06
07E4E:  MOVWF  x0A
07E50:  MOVLW  0B
07E52:  MOVWF  x09
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07E54:  CLRF   x2B
07E56:  MOVFF  5E8,62A
07E5A:  CLRF   x2D
07E5C:  MOVLW  B5
07E5E:  MOVWF  x2C
07E60:  MOVLB  0
07E62:  CALL   0858
07E66:  MOVFF  02,60E
07E6A:  MOVFF  01,60D
07E6E:  MOVLW  06
07E70:  MOVLB  6
07E72:  ADDWF  x0D,F
07E74:  MOVLW  00
07E76:  ADDWFC x0E,F
07E78:  MOVLW  32
07E7A:  ADDWF  x0D,W
07E7C:  MOVWF  01
07E7E:  MOVLW  00
07E80:  ADDWFC x0E,W
07E82:  MOVWF  03
07E84:  MOVF   01,W
07E86:  ADDLW  66
07E88:  MOVWF  01
07E8A:  MOVLW  01
07E8C:  ADDWFC 03,F
07E8E:  MOVFF  01,60D
07E92:  MOVFF  03,60E
07E96:  MOVFF  03,61D
07E9A:  MOVFF  01,61C
07E9E:  MOVLB  0
07EA0:  CALL   4BB2
07EA4:  MOVF   01,F
07EA6:  BNZ   7EB0
07EA8:  MOVLW  02
07EAA:  MOVWF  01
07EAC:  BRA    81A8
07EAE:  BRA    7F0E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07EB0:  MOVLB  6
07EB2:  CLRF   x2B
07EB4:  MOVFF  5E8,62A
07EB8:  CLRF   x2D
07EBA:  MOVLW  B5
07EBC:  MOVWF  x2C
07EBE:  MOVLB  0
07EC0:  CALL   0858
07EC4:  MOVFF  02,60E
07EC8:  MOVFF  01,60D
07ECC:  MOVLW  06
07ECE:  MOVLB  6
07ED0:  ADDWF  x0D,F
07ED2:  MOVLW  00
07ED4:  ADDWFC x0E,F
07ED6:  MOVLW  32
07ED8:  ADDWF  x0D,W
07EDA:  MOVWF  01
07EDC:  MOVLW  00
07EDE:  ADDWFC x0E,W
07EE0:  MOVWF  03
07EE2:  MOVF   01,W
07EE4:  ADDLW  66
07EE6:  MOVWF  01
07EE8:  MOVLW  01
07EEA:  ADDWFC 03,F
07EEC:  MOVFF  01,60D
07EF0:  MOVFF  03,60E
07EF4:  MOVFF  03,61D
07EF8:  MOVFF  01,61C
07EFC:  CLRF   x1F
07EFE:  CLRF   x1E
07F00:  MOVLW  0A
07F02:  MOVWF  x20
07F04:  MOVLB  0
07F06:  CALL   4CA2
07F0A:  MOVFF  01,5F4
....................    
....................    arg2 = SERcmd[rec].p[3];
07F0E:  MOVLB  6
07F10:  CLRF   x2B
07F12:  MOVFF  5E8,62A
07F16:  CLRF   x2D
07F18:  MOVLW  B5
07F1A:  MOVWF  x2C
07F1C:  MOVLB  0
07F1E:  CALL   0858
07F22:  MOVFF  02,60E
07F26:  MOVFF  01,60D
07F2A:  MOVLW  06
07F2C:  MOVLB  6
07F2E:  ADDWF  x0D,F
07F30:  MOVLW  00
07F32:  ADDWFC x0E,F
07F34:  MOVLW  4B
07F36:  ADDWF  x0D,W
07F38:  MOVWF  01
07F3A:  MOVLW  00
07F3C:  ADDWFC x0E,W
07F3E:  MOVWF  03
07F40:  MOVF   01,W
07F42:  ADDLW  66
07F44:  MOVWF  01
07F46:  MOVLW  01
07F48:  ADDWFC 03,F
07F4A:  MOVFF  01,5F5
07F4E:  MOVLB  5
07F50:  MOVFF  03,5F6
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%f,", PID[arg1-1].PV);
07F54:  MOVFF  5F8,62B
07F58:  MOVFF  5F7,62A
07F5C:  MOVFF  5F6,62D
07F60:  MOVFF  5F5,62C
07F64:  MOVLB  0
07F66:  CALL   4A72
07F6A:  MOVF   01,F
07F6C:  BNZ   7FE8
07F6E:  MOVLW  04
07F70:  MOVLB  6
07F72:  MOVWF  x2B
07F74:  MOVLW  3C
07F76:  MOVWF  x2A
07F78:  MOVLB  0
07F7A:  CALL   4A3A
07F7E:  MOVF   01,W
07F80:  ADDLW  3C
07F82:  MOVLB  6
07F84:  MOVWF  x0D
07F86:  MOVLW  04
07F88:  ADDWFC 02,W
07F8A:  MOVWF  x0E
07F8C:  MOVLW  01
07F8E:  MOVLB  5
07F90:  SUBWF  xF4,W
07F92:  MULLW  20
07F94:  MOVF   FF3,W
07F96:  MOVLB  6
07F98:  CLRF   x10
07F9A:  MOVWF  x0F
07F9C:  MOVLW  10
07F9E:  ADDWF  x0F,W
07FA0:  MOVWF  01
07FA2:  MOVLW  00
07FA4:  ADDWFC x10,W
07FA6:  MOVWF  03
07FA8:  MOVF   01,W
07FAA:  ADDLW  20
07FAC:  MOVWF  FE9
07FAE:  MOVLW  00
07FB0:  ADDWFC 03,W
07FB2:  MOVWF  FEA
07FB4:  MOVFF  FEF,62C
07FB8:  MOVFF  FEC,62D
07FBC:  MOVFF  FEC,62E
07FC0:  MOVFF  FEC,62F
07FC4:  MOVFF  60E,4E1
07FC8:  MOVFF  60D,4E0
07FCC:  MOVLW  89
07FCE:  MOVWF  FE9
07FD0:  MOVLW  02
07FD2:  MOVWF  x30
07FD4:  MOVLB  0
07FD6:  CALL   57C2
07FDA:  MOVLW  2C
07FDC:  MOVLB  6
07FDE:  MOVWF  x39
07FE0:  MOVLB  0
07FE2:  CALL   4AEA
07FE6:  BRA    81A4
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%f,", PID[arg1-1].CV);
07FE8:  MOVFF  5FD,62B
07FEC:  MOVFF  5FC,62A
07FF0:  MOVFF  5F6,62D
07FF4:  MOVFF  5F5,62C
07FF8:  CALL   4A72
07FFC:  MOVF   01,F
07FFE:  BNZ   807A
08000:  MOVLW  04
08002:  MOVLB  6
08004:  MOVWF  x2B
08006:  MOVLW  3C
08008:  MOVWF  x2A
0800A:  MOVLB  0
0800C:  CALL   4A3A
08010:  MOVF   01,W
08012:  ADDLW  3C
08014:  MOVLB  6
08016:  MOVWF  x0D
08018:  MOVLW  04
0801A:  ADDWFC 02,W
0801C:  MOVWF  x0E
0801E:  MOVLW  01
08020:  MOVLB  5
08022:  SUBWF  xF4,W
08024:  MULLW  20
08026:  MOVF   FF3,W
08028:  MOVLB  6
0802A:  CLRF   x10
0802C:  MOVWF  x0F
0802E:  MOVLW  18
08030:  ADDWF  x0F,W
08032:  MOVWF  01
08034:  MOVLW  00
08036:  ADDWFC x10,W
08038:  MOVWF  03
0803A:  MOVF   01,W
0803C:  ADDLW  20
0803E:  MOVWF  FE9
08040:  MOVLW  00
08042:  ADDWFC 03,W
08044:  MOVWF  FEA
08046:  MOVFF  FEF,62C
0804A:  MOVFF  FEC,62D
0804E:  MOVFF  FEC,62E
08052:  MOVFF  FEC,62F
08056:  MOVFF  60E,4E1
0805A:  MOVFF  60D,4E0
0805E:  MOVLW  89
08060:  MOVWF  FE9
08062:  MOVLW  02
08064:  MOVWF  x30
08066:  MOVLB  0
08068:  CALL   57C2
0806C:  MOVLW  2C
0806E:  MOVLB  6
08070:  MOVWF  x39
08072:  MOVLB  0
08074:  CALL   4AEA
08078:  BRA    81A4
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%f,", PID[arg1-1].PVold);
0807A:  MOVFF  602,62B
0807E:  MOVFF  601,62A
08082:  MOVFF  5F6,62D
08086:  MOVFF  5F5,62C
0808A:  CALL   4A72
0808E:  MOVF   01,F
08090:  BNZ   810C
08092:  MOVLW  04
08094:  MOVLB  6
08096:  MOVWF  x2B
08098:  MOVLW  3C
0809A:  MOVWF  x2A
0809C:  MOVLB  0
0809E:  CALL   4A3A
080A2:  MOVF   01,W
080A4:  ADDLW  3C
080A6:  MOVLB  6
080A8:  MOVWF  x0D
080AA:  MOVLW  04
080AC:  ADDWFC 02,W
080AE:  MOVWF  x0E
080B0:  MOVLW  01
080B2:  MOVLB  5
080B4:  SUBWF  xF4,W
080B6:  MULLW  20
080B8:  MOVF   FF3,W
080BA:  MOVLB  6
080BC:  CLRF   x10
080BE:  MOVWF  x0F
080C0:  MOVLW  14
080C2:  ADDWF  x0F,W
080C4:  MOVWF  01
080C6:  MOVLW  00
080C8:  ADDWFC x10,W
080CA:  MOVWF  03
080CC:  MOVF   01,W
080CE:  ADDLW  20
080D0:  MOVWF  FE9
080D2:  MOVLW  00
080D4:  ADDWFC 03,W
080D6:  MOVWF  FEA
080D8:  MOVFF  FEF,62C
080DC:  MOVFF  FEC,62D
080E0:  MOVFF  FEC,62E
080E4:  MOVFF  FEC,62F
080E8:  MOVFF  60E,4E1
080EC:  MOVFF  60D,4E0
080F0:  MOVLW  89
080F2:  MOVWF  FE9
080F4:  MOVLW  02
080F6:  MOVWF  x30
080F8:  MOVLB  0
080FA:  CALL   57C2
080FE:  MOVLW  2C
08100:  MOVLB  6
08102:  MOVWF  x39
08104:  MOVLB  0
08106:  CALL   4AEA
0810A:  BRA    81A4
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%f,", PID[arg1-1].I);
0810C:  MOVFF  60A,62B
08110:  MOVFF  609,62A
08114:  MOVFF  5F6,62D
08118:  MOVFF  5F5,62C
0811C:  CALL   4A72
08120:  MOVF   01,F
08122:  BNZ   819E
08124:  MOVLW  04
08126:  MOVLB  6
08128:  MOVWF  x2B
0812A:  MOVLW  3C
0812C:  MOVWF  x2A
0812E:  MOVLB  0
08130:  CALL   4A3A
08134:  MOVF   01,W
08136:  ADDLW  3C
08138:  MOVLB  6
0813A:  MOVWF  x0D
0813C:  MOVLW  04
0813E:  ADDWFC 02,W
08140:  MOVWF  x0E
08142:  MOVLW  01
08144:  MOVLB  5
08146:  SUBWF  xF4,W
08148:  MULLW  20
0814A:  MOVF   FF3,W
0814C:  MOVLB  6
0814E:  CLRF   x10
08150:  MOVWF  x0F
08152:  MOVLW  1C
08154:  ADDWF  x0F,W
08156:  MOVWF  01
08158:  MOVLW  00
0815A:  ADDWFC x10,W
0815C:  MOVWF  03
0815E:  MOVF   01,W
08160:  ADDLW  20
08162:  MOVWF  FE9
08164:  MOVLW  00
08166:  ADDWFC 03,W
08168:  MOVWF  FEA
0816A:  MOVFF  FEF,62C
0816E:  MOVFF  FEC,62D
08172:  MOVFF  FEC,62E
08176:  MOVFF  FEC,62F
0817A:  MOVFF  60E,4E1
0817E:  MOVFF  60D,4E0
08182:  MOVLW  89
08184:  MOVWF  FE9
08186:  MOVLW  02
08188:  MOVWF  x30
0818A:  MOVLB  0
0818C:  CALL   57C2
08190:  MOVLW  2C
08192:  MOVLB  6
08194:  MOVWF  x39
08196:  MOVLB  0
08198:  CALL   4AEA
0819C:  BRA    81A4
....................    else return INV_PARAM;
0819E:  MOVLW  02
081A0:  MOVWF  01
081A2:  BRA    81A8
....................    
....................    return SUCCESS;
081A4:  MOVLW  00
081A6:  MOVWF  01
081A8:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
083B8:  MOVLW  72
083BA:  MOVLB  5
083BC:  MOVWF  xF9
083BE:  MOVLW  61
083C0:  MOVWF  xFA
083C2:  MOVLW  77
083C4:  MOVWF  xFB
083C6:  CLRF   xFC
083C8:  MOVLW  05
083CA:  MOVWF  xF8
083CC:  MOVLW  F9
083CE:  MOVWF  xF7
....................    char *s_calibrated = "calib";
083D0:  MOVLW  63
083D2:  MOVWF  xFF
083D4:  MOVLW  61
083D6:  MOVLB  6
083D8:  MOVWF  x00
083DA:  MOVLW  6C
083DC:  MOVWF  x01
083DE:  MOVLW  69
083E0:  MOVWF  x02
083E2:  MOVLW  62
083E4:  MOVWF  x03
083E6:  CLRF   x04
083E8:  MOVLW  05
083EA:  MOVLB  5
083EC:  MOVWF  xFE
083EE:  SETF   xFD
....................    char *s_p0 = "p0";
083F0:  MOVLW  70
083F2:  MOVLB  6
083F4:  MOVWF  x07
083F6:  MOVLW  30
083F8:  MOVWF  x08
083FA:  CLRF   x09
083FC:  MOVLW  06
083FE:  MOVWF  x06
08400:  MOVLW  07
08402:  MOVWF  x05
....................    char *s_poles = "poles";
08404:  MOVLW  70
08406:  MOVWF  x0C
08408:  MOVLW  6F
0840A:  MOVWF  x0D
0840C:  MOVLW  6C
0840E:  MOVWF  x0E
08410:  MOVLW  65
08412:  MOVWF  x0F
08414:  MOVLW  73
08416:  MOVWF  x10
08418:  CLRF   x11
0841A:  MOVLW  06
0841C:  MOVWF  x0B
0841E:  MOVLW  0C
08420:  MOVWF  x0A
....................    char *s_real = "real";
08422:  MOVLW  72
08424:  MOVWF  x14
08426:  MOVLW  65
08428:  MOVWF  x15
0842A:  MOVLW  61
0842C:  MOVWF  x16
0842E:  MOVLW  6C
08430:  MOVWF  x17
08432:  CLRF   x18
08434:  MOVLW  06
08436:  MOVWF  x13
08438:  MOVLW  14
0843A:  MOVWF  x12
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0843C:  CLRF   x2B
0843E:  MOVFF  5E8,62A
08442:  CLRF   x2D
08444:  MOVLW  B5
08446:  MOVWF  x2C
08448:  MOVLB  0
0844A:  CALL   0858
0844E:  MOVFF  02,61A
08452:  MOVFF  01,619
08456:  MOVLW  06
08458:  MOVLB  6
0845A:  ADDWF  x19,F
0845C:  MOVLW  00
0845E:  ADDWFC x1A,F
08460:  MOVLW  32
08462:  ADDWF  x19,W
08464:  MOVWF  01
08466:  MOVLW  00
08468:  ADDWFC x1A,W
0846A:  MOVWF  03
0846C:  MOVF   01,W
0846E:  ADDLW  66
08470:  MOVWF  01
08472:  MOVLW  01
08474:  ADDWFC 03,F
08476:  MOVFF  01,619
0847A:  MOVFF  03,61A
0847E:  MOVFF  03,61D
08482:  MOVFF  01,61C
08486:  MOVLB  0
08488:  CALL   4BB2
0848C:  MOVF   01,F
0848E:  BNZ   8498
08490:  MOVLW  02
08492:  MOVWF  01
08494:  BRA    8AF2
08496:  BRA    84F6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08498:  MOVLB  6
0849A:  CLRF   x2B
0849C:  MOVFF  5E8,62A
084A0:  CLRF   x2D
084A2:  MOVLW  B5
084A4:  MOVWF  x2C
084A6:  MOVLB  0
084A8:  CALL   0858
084AC:  MOVFF  02,61A
084B0:  MOVFF  01,619
084B4:  MOVLW  06
084B6:  MOVLB  6
084B8:  ADDWF  x19,F
084BA:  MOVLW  00
084BC:  ADDWFC x1A,F
084BE:  MOVLW  32
084C0:  ADDWF  x19,W
084C2:  MOVWF  01
084C4:  MOVLW  00
084C6:  ADDWFC x1A,W
084C8:  MOVWF  03
084CA:  MOVF   01,W
084CC:  ADDLW  66
084CE:  MOVWF  01
084D0:  MOVLW  01
084D2:  ADDWFC 03,F
084D4:  MOVFF  01,619
084D8:  MOVFF  03,61A
084DC:  MOVFF  03,61D
084E0:  MOVFF  01,61C
084E4:  CLRF   x1F
084E6:  CLRF   x1E
084E8:  MOVLW  0A
084EA:  MOVWF  x20
084EC:  MOVLB  0
084EE:  CALL   4CA2
084F2:  MOVFF  01,5F4
....................    
....................    arg2 = SERcmd[rec].p[3];
084F6:  MOVLB  6
084F8:  CLRF   x2B
084FA:  MOVFF  5E8,62A
084FE:  CLRF   x2D
08500:  MOVLW  B5
08502:  MOVWF  x2C
08504:  MOVLB  0
08506:  CALL   0858
0850A:  MOVFF  02,61A
0850E:  MOVFF  01,619
08512:  MOVLW  06
08514:  MOVLB  6
08516:  ADDWF  x19,F
08518:  MOVLW  00
0851A:  ADDWFC x1A,F
0851C:  MOVLW  4B
0851E:  ADDWF  x19,W
08520:  MOVWF  01
08522:  MOVLW  00
08524:  ADDWFC x1A,W
08526:  MOVWF  03
08528:  MOVF   01,W
0852A:  ADDLW  66
0852C:  MOVWF  01
0852E:  MOVLW  01
08530:  ADDWFC 03,F
08532:  MOVFF  01,5F5
08536:  MOVLB  5
08538:  MOVFF  03,5F6
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0853C:  MOVFF  5F8,62B
08540:  MOVFF  5F7,62A
08544:  MOVFF  5F6,62D
08548:  MOVFF  5F5,62C
0854C:  MOVLB  0
0854E:  CALL   4A72
08552:  MOVF   01,F
08554:  BTFSS  FD8.2
08556:  BRA    86D8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
08558:  MOVLW  04
0855A:  MOVLB  6
0855C:  MOVWF  x2B
0855E:  MOVLW  3C
08560:  MOVWF  x2A
08562:  MOVLB  0
08564:  CALL   4A3A
08568:  MOVFF  02,03
0856C:  MOVF   01,W
0856E:  ADDLW  3C
08570:  MOVLB  6
08572:  MOVWF  x19
08574:  MOVLW  04
08576:  ADDWFC 02,W
08578:  MOVWF  x1A
0857A:  MOVFF  FE8,4E1
0857E:  MOVFF  619,4E0
08582:  MOVFF  5F4,61D
08586:  MOVLW  18
08588:  MOVWF  x1E
0858A:  MOVLB  0
0858C:  RCALL  81D6
0858E:  MOVLW  2C
08590:  MOVLB  6
08592:  MOVWF  x39
08594:  MOVLB  0
08596:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0859A:  MOVLW  04
0859C:  MOVLB  6
0859E:  MOVWF  x2B
085A0:  MOVLW  3C
085A2:  MOVWF  x2A
085A4:  MOVLB  0
085A6:  CALL   4A3A
085AA:  MOVFF  02,03
085AE:  MOVF   01,W
085B0:  ADDLW  3C
085B2:  MOVLB  6
085B4:  MOVWF  x19
085B6:  MOVLW  04
085B8:  ADDWFC 02,W
085BA:  MOVWF  x1A
085BC:  MOVLW  01
085BE:  MOVLB  5
085C0:  SUBWF  xF4,W
085C2:  MULLW  21
085C4:  MOVF   FF3,W
085C6:  MOVLB  6
085C8:  CLRF   x1C
085CA:  MOVWF  x1B
085CC:  MOVLW  0F
085CE:  ADDWF  x1B,W
085D0:  MOVWF  FE9
085D2:  MOVLW  01
085D4:  ADDWFC x1C,W
085D6:  MOVWF  FEA
085D8:  MOVFF  FEF,639
085DC:  MOVFF  FEC,01
085E0:  MOVFF  FEC,02
085E4:  MOVFF  FEC,03
085E8:  MOVFF  03,63C
085EC:  MOVFF  02,63B
085F0:  MOVFF  01,63A
085F4:  MOVLB  0
085F6:  CALL   56EC
085FA:  MOVFF  03,620
085FE:  MOVFF  02,61F
08602:  MOVFF  01,61E
08606:  MOVFF  00,61D
0860A:  MOVFF  61A,4E1
0860E:  MOVFF  619,4E0
08612:  MOVLW  41
08614:  MOVWF  FE9
08616:  MOVFF  03,625
0861A:  MOVFF  02,624
0861E:  MOVFF  01,623
08622:  MOVFF  00,622
08626:  RCALL  829A
08628:  MOVLW  2C
0862A:  MOVLB  6
0862C:  MOVWF  x39
0862E:  MOVLB  0
08630:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
08634:  MOVLW  04
08636:  MOVLB  6
08638:  MOVWF  x2B
0863A:  MOVLW  3C
0863C:  MOVWF  x2A
0863E:  MOVLB  0
08640:  CALL   4A3A
08644:  MOVF   01,W
08646:  ADDLW  3C
08648:  MOVLB  6
0864A:  MOVWF  x19
0864C:  MOVLW  04
0864E:  ADDWFC 02,W
08650:  MOVWF  x1A
08652:  MOVLW  01
08654:  MOVLB  5
08656:  SUBWF  xF4,W
08658:  MULLW  21
0865A:  MOVF   FF3,W
0865C:  MOVLB  6
0865E:  CLRF   x1C
08660:  MOVWF  x1B
08662:  MOVLW  04
08664:  ADDWF  x1B,W
08666:  MOVWF  01
08668:  MOVLW  00
0866A:  ADDWFC x1C,W
0866C:  MOVWF  03
0866E:  MOVF   01,W
08670:  ADDLW  0F
08672:  MOVWF  FE9
08674:  MOVLW  01
08676:  ADDWFC 03,W
08678:  MOVWF  FEA
0867A:  MOVFF  FEF,639
0867E:  MOVFF  FEC,01
08682:  MOVFF  FEC,02
08686:  MOVFF  FEC,03
0868A:  MOVFF  03,63C
0868E:  MOVFF  02,63B
08692:  MOVFF  01,63A
08696:  MOVLB  0
08698:  CALL   56EC
0869C:  MOVFF  03,61E
086A0:  MOVFF  02,61D
086A4:  MOVFF  01,61C
086A8:  MOVFF  00,61B
086AC:  MOVFF  61A,4E1
086B0:  MOVFF  619,4E0
086B4:  MOVLW  41
086B6:  MOVWF  FE9
086B8:  MOVFF  03,625
086BC:  MOVFF  02,624
086C0:  MOVFF  01,623
086C4:  MOVFF  00,622
086C8:  RCALL  829A
086CA:  MOVLW  2C
086CC:  MOVLB  6
086CE:  MOVWF  x39
086D0:  MOVLB  0
086D2:  CALL   4AEA
....................    }
086D6:  BRA    8AEE
....................    else if (0 == strcmp(s_calibrated, arg2)) {
086D8:  MOVFF  5FE,62B
086DC:  MOVFF  5FD,62A
086E0:  MOVFF  5F6,62D
086E4:  MOVFF  5F5,62C
086E8:  CALL   4A72
086EC:  MOVF   01,F
086EE:  BTFSS  FD8.2
086F0:  BRA    887A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
086F2:  MOVLW  04
086F4:  MOVLB  6
086F6:  MOVWF  x2B
086F8:  MOVLW  3C
086FA:  MOVWF  x2A
086FC:  MOVLB  0
086FE:  CALL   4A3A
08702:  MOVFF  02,03
08706:  MOVF   01,W
08708:  ADDLW  3C
0870A:  MOVLB  6
0870C:  MOVWF  x19
0870E:  MOVLW  04
08710:  ADDWFC 02,W
08712:  MOVWF  x1A
08714:  MOVFF  FE8,4E1
08718:  MOVFF  619,4E0
0871C:  MOVFF  5F4,61D
08720:  MOVLW  18
08722:  MOVWF  x1E
08724:  MOVLB  0
08726:  RCALL  81D6
08728:  MOVLW  2C
0872A:  MOVLB  6
0872C:  MOVWF  x39
0872E:  MOVLB  0
08730:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
08734:  MOVLW  04
08736:  MOVLB  6
08738:  MOVWF  x2B
0873A:  MOVLW  3C
0873C:  MOVWF  x2A
0873E:  MOVLB  0
08740:  CALL   4A3A
08744:  MOVF   01,W
08746:  ADDLW  3C
08748:  MOVLB  6
0874A:  MOVWF  x19
0874C:  MOVLW  04
0874E:  ADDWFC 02,W
08750:  MOVWF  x1A
08752:  MOVLW  01
08754:  MOVLB  5
08756:  SUBWF  xF4,W
08758:  MULLW  21
0875A:  MOVF   FF3,W
0875C:  MOVLB  6
0875E:  CLRF   x1C
08760:  MOVWF  x1B
08762:  MOVLW  08
08764:  ADDWF  x1B,W
08766:  MOVWF  01
08768:  MOVLW  00
0876A:  ADDWFC x1C,W
0876C:  MOVWF  03
0876E:  MOVF   01,W
08770:  ADDLW  0F
08772:  MOVWF  FE9
08774:  MOVLW  01
08776:  ADDWFC 03,W
08778:  MOVWF  FEA
0877A:  MOVFF  FEF,639
0877E:  MOVFF  FEC,01
08782:  MOVFF  FEC,02
08786:  MOVFF  FEC,03
0878A:  MOVFF  03,63C
0878E:  MOVFF  02,63B
08792:  MOVFF  01,63A
08796:  MOVLB  0
08798:  CALL   56EC
0879C:  MOVFF  03,61E
087A0:  MOVFF  02,61D
087A4:  MOVFF  01,61C
087A8:  MOVFF  00,61B
087AC:  MOVFF  61A,4E1
087B0:  MOVFF  619,4E0
087B4:  MOVLW  41
087B6:  MOVWF  FE9
087B8:  MOVFF  03,625
087BC:  MOVFF  02,624
087C0:  MOVFF  01,623
087C4:  MOVFF  00,622
087C8:  RCALL  829A
087CA:  MOVLW  2C
087CC:  MOVLB  6
087CE:  MOVWF  x39
087D0:  MOVLB  0
087D2:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
087D6:  MOVLW  04
087D8:  MOVLB  6
087DA:  MOVWF  x2B
087DC:  MOVLW  3C
087DE:  MOVWF  x2A
087E0:  MOVLB  0
087E2:  CALL   4A3A
087E6:  MOVF   01,W
087E8:  ADDLW  3C
087EA:  MOVLB  6
087EC:  MOVWF  x19
087EE:  MOVLW  04
087F0:  ADDWFC 02,W
087F2:  MOVWF  x1A
087F4:  MOVLW  01
087F6:  MOVLB  5
087F8:  SUBWF  xF4,W
087FA:  MULLW  21
087FC:  MOVF   FF3,W
087FE:  MOVLB  6
08800:  CLRF   x1C
08802:  MOVWF  x1B
08804:  MOVLW  0C
08806:  ADDWF  x1B,W
08808:  MOVWF  01
0880A:  MOVLW  00
0880C:  ADDWFC x1C,W
0880E:  MOVWF  03
08810:  MOVF   01,W
08812:  ADDLW  0F
08814:  MOVWF  FE9
08816:  MOVLW  01
08818:  ADDWFC 03,W
0881A:  MOVWF  FEA
0881C:  MOVFF  FEF,639
08820:  MOVFF  FEC,01
08824:  MOVFF  FEC,02
08828:  MOVFF  FEC,03
0882C:  MOVFF  03,63C
08830:  MOVFF  02,63B
08834:  MOVFF  01,63A
08838:  MOVLB  0
0883A:  CALL   56EC
0883E:  MOVFF  03,61E
08842:  MOVFF  02,61D
08846:  MOVFF  01,61C
0884A:  MOVFF  00,61B
0884E:  MOVFF  61A,4E1
08852:  MOVFF  619,4E0
08856:  MOVLW  41
08858:  MOVWF  FE9
0885A:  MOVFF  03,625
0885E:  MOVFF  02,624
08862:  MOVFF  01,623
08866:  MOVFF  00,622
0886A:  RCALL  829A
0886C:  MOVLW  2C
0886E:  MOVLB  6
08870:  MOVWF  x39
08872:  MOVLB  0
08874:  CALL   4AEA
....................    }
08878:  BRA    8AEE
....................    else if (0 == strcmp(s_p0, arg2)) {
0887A:  MOVFF  606,62B
0887E:  MOVFF  605,62A
08882:  MOVFF  5F6,62D
08886:  MOVFF  5F5,62C
0888A:  CALL   4A72
0888E:  MOVF   01,F
08890:  BNZ   894E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
08892:  MOVLW  04
08894:  MOVLB  6
08896:  MOVWF  x2B
08898:  MOVLW  3C
0889A:  MOVWF  x2A
0889C:  MOVLB  0
0889E:  CALL   4A3A
088A2:  MOVFF  02,03
088A6:  MOVF   01,W
088A8:  ADDLW  3C
088AA:  MOVLB  6
088AC:  MOVWF  x19
088AE:  MOVLW  04
088B0:  ADDWFC 02,W
088B2:  MOVWF  x1A
088B4:  MOVFF  FE8,4E1
088B8:  MOVFF  619,4E0
088BC:  MOVFF  5F4,61D
088C0:  MOVLW  18
088C2:  MOVWF  x1E
088C4:  MOVLB  0
088C6:  RCALL  81D6
088C8:  MOVLW  2C
088CA:  MOVLB  6
088CC:  MOVWF  x39
088CE:  MOVLB  0
088D0:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
088D4:  MOVLW  04
088D6:  MOVLB  6
088D8:  MOVWF  x2B
088DA:  MOVLW  3C
088DC:  MOVWF  x2A
088DE:  MOVLB  0
088E0:  CALL   4A3A
088E4:  MOVF   01,W
088E6:  ADDLW  3C
088E8:  MOVLB  6
088EA:  MOVWF  x19
088EC:  MOVLW  04
088EE:  ADDWFC 02,W
088F0:  MOVWF  x1A
088F2:  MOVLW  01
088F4:  MOVLB  5
088F6:  SUBWF  xF4,W
088F8:  MULLW  21
088FA:  MOVF   FF3,W
088FC:  MOVLB  6
088FE:  CLRF   x1C
08900:  MOVWF  x1B
08902:  MOVLW  18
08904:  ADDWF  x1B,W
08906:  MOVWF  01
08908:  MOVLW  00
0890A:  ADDWFC x1C,W
0890C:  MOVWF  03
0890E:  MOVF   01,W
08910:  ADDLW  0F
08912:  MOVWF  FE9
08914:  MOVLW  01
08916:  ADDWFC 03,W
08918:  MOVWF  FEA
0891A:  MOVFF  FEF,62C
0891E:  MOVFF  FEC,62D
08922:  MOVFF  FEC,62E
08926:  MOVFF  FEC,62F
0892A:  MOVFF  61A,4E1
0892E:  MOVFF  619,4E0
08932:  MOVLW  89
08934:  MOVWF  FE9
08936:  MOVLW  02
08938:  MOVWF  x30
0893A:  MOVLB  0
0893C:  CALL   57C2
08940:  MOVLW  2C
08942:  MOVLB  6
08944:  MOVWF  x39
08946:  MOVLB  0
08948:  CALL   4AEA
....................    }
0894C:  BRA    8AEE
....................    else if (0 == strcmp(s_poles, arg2)) {
0894E:  MOVFF  60B,62B
08952:  MOVFF  60A,62A
08956:  MOVFF  5F6,62D
0895A:  MOVFF  5F5,62C
0895E:  CALL   4A72
08962:  MOVF   01,F
08964:  BNZ   8A12
....................       sprintf(retData+strlen(retData), "%d,", arg1);
08966:  MOVLW  04
08968:  MOVLB  6
0896A:  MOVWF  x2B
0896C:  MOVLW  3C
0896E:  MOVWF  x2A
08970:  MOVLB  0
08972:  CALL   4A3A
08976:  MOVFF  02,03
0897A:  MOVF   01,W
0897C:  ADDLW  3C
0897E:  MOVLB  6
08980:  MOVWF  x19
08982:  MOVLW  04
08984:  ADDWFC 02,W
08986:  MOVWF  x1A
08988:  MOVFF  FE8,4E1
0898C:  MOVFF  619,4E0
08990:  MOVFF  5F4,61D
08994:  MOVLW  18
08996:  MOVWF  x1E
08998:  MOVLB  0
0899A:  RCALL  81D6
0899C:  MOVLW  2C
0899E:  MOVLB  6
089A0:  MOVWF  x39
089A2:  MOVLB  0
089A4:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
089A8:  MOVLW  04
089AA:  MOVLB  6
089AC:  MOVWF  x2B
089AE:  MOVLW  3C
089B0:  MOVWF  x2A
089B2:  MOVLB  0
089B4:  CALL   4A3A
089B8:  MOVF   01,W
089BA:  ADDLW  3C
089BC:  MOVLB  6
089BE:  MOVWF  x19
089C0:  MOVLW  04
089C2:  ADDWFC 02,W
089C4:  MOVWF  x1A
089C6:  MOVLW  01
089C8:  MOVLB  5
089CA:  SUBWF  xF4,W
089CC:  MULLW  21
089CE:  MOVF   FF3,W
089D0:  MOVLB  6
089D2:  CLRF   x1C
089D4:  MOVWF  x1B
089D6:  MOVLW  1C
089D8:  ADDWF  x1B,W
089DA:  MOVWF  01
089DC:  MOVLW  00
089DE:  ADDWFC x1C,W
089E0:  MOVWF  03
089E2:  MOVF   01,W
089E4:  ADDLW  0F
089E6:  MOVWF  FE9
089E8:  MOVLW  01
089EA:  ADDWFC 03,W
089EC:  MOVWF  FEA
089EE:  MOVFF  FEF,61D
089F2:  MOVFF  61A,4E1
089F6:  MOVFF  619,4E0
089FA:  MOVLW  18
089FC:  MOVWF  x1E
089FE:  MOVLB  0
08A00:  CALL   81D6
08A04:  MOVLW  2C
08A06:  MOVLB  6
08A08:  MOVWF  x39
08A0A:  MOVLB  0
08A0C:  CALL   4AEA
....................    }
08A10:  BRA    8AEE
....................    else if (0 == strcmp(s_real, arg2)) {
08A12:  MOVFF  613,62B
08A16:  MOVFF  612,62A
08A1A:  MOVFF  5F6,62D
08A1E:  MOVFF  5F5,62C
08A22:  CALL   4A72
08A26:  MOVF   01,F
08A28:  BNZ   8AE8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
08A2A:  MOVLW  04
08A2C:  MOVLB  6
08A2E:  MOVWF  x2B
08A30:  MOVLW  3C
08A32:  MOVWF  x2A
08A34:  MOVLB  0
08A36:  CALL   4A3A
08A3A:  MOVFF  02,03
08A3E:  MOVF   01,W
08A40:  ADDLW  3C
08A42:  MOVLB  6
08A44:  MOVWF  x19
08A46:  MOVLW  04
08A48:  ADDWFC 02,W
08A4A:  MOVWF  x1A
08A4C:  MOVFF  FE8,4E1
08A50:  MOVFF  619,4E0
08A54:  MOVFF  5F4,61D
08A58:  MOVLW  18
08A5A:  MOVWF  x1E
08A5C:  MOVLB  0
08A5E:  CALL   81D6
08A62:  MOVLW  2C
08A64:  MOVLB  6
08A66:  MOVWF  x39
08A68:  MOVLB  0
08A6A:  CALL   4AEA
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
08A6E:  MOVLW  04
08A70:  MOVLB  6
08A72:  MOVWF  x2B
08A74:  MOVLW  3C
08A76:  MOVWF  x2A
08A78:  MOVLB  0
08A7A:  CALL   4A3A
08A7E:  MOVF   01,W
08A80:  ADDLW  3C
08A82:  MOVLB  6
08A84:  MOVWF  x19
08A86:  MOVLW  04
08A88:  ADDWFC 02,W
08A8A:  MOVWF  x1A
08A8C:  MOVLW  01
08A8E:  MOVLB  5
08A90:  SUBWF  xF4,W
08A92:  MULLW  21
08A94:  MOVF   FF3,W
08A96:  MOVLB  6
08A98:  CLRF   x1C
08A9A:  MOVWF  x1B
08A9C:  MOVLW  1D
08A9E:  ADDWF  x1B,W
08AA0:  MOVWF  01
08AA2:  MOVLW  00
08AA4:  ADDWFC x1C,W
08AA6:  MOVWF  03
08AA8:  MOVF   01,W
08AAA:  ADDLW  0F
08AAC:  MOVWF  FE9
08AAE:  MOVLW  01
08AB0:  ADDWFC 03,W
08AB2:  MOVWF  FEA
08AB4:  MOVFF  FEF,62C
08AB8:  MOVFF  FEC,62D
08ABC:  MOVFF  FEC,62E
08AC0:  MOVFF  FEC,62F
08AC4:  MOVFF  61A,4E1
08AC8:  MOVFF  619,4E0
08ACC:  MOVLW  89
08ACE:  MOVWF  FE9
08AD0:  MOVLW  02
08AD2:  MOVWF  x30
08AD4:  MOVLB  0
08AD6:  CALL   57C2
08ADA:  MOVLW  2C
08ADC:  MOVLB  6
08ADE:  MOVWF  x39
08AE0:  MOVLB  0
08AE2:  CALL   4AEA
....................    }
08AE6:  BRA    8AEE
....................    else return INV_PARAM;
08AE8:  MOVLW  02
08AEA:  MOVWF  01
08AEC:  BRA    8AF2
....................    
....................    return SUCCESS;
08AEE:  MOVLW  00
08AF0:  MOVWF  01
08AF2:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08AF4:  MOVLB  6
08AF6:  CLRF   x2B
08AF8:  MOVFF  5E8,62A
08AFC:  CLRF   x2D
08AFE:  MOVLW  B5
08B00:  MOVWF  x2C
08B02:  MOVLB  0
08B04:  CALL   0858
08B08:  MOVFF  02,5F6
08B0C:  MOVFF  01,5F5
08B10:  MOVLW  06
08B12:  MOVLB  5
08B14:  ADDWF  xF5,F
08B16:  MOVLW  00
08B18:  ADDWFC xF6,F
08B1A:  MOVLW  32
08B1C:  ADDWF  xF5,W
08B1E:  MOVWF  01
08B20:  MOVLW  00
08B22:  ADDWFC xF6,W
08B24:  MOVWF  03
08B26:  MOVF   01,W
08B28:  ADDLW  66
08B2A:  MOVWF  01
08B2C:  MOVLW  01
08B2E:  ADDWFC 03,F
08B30:  MOVFF  01,5F5
08B34:  MOVFF  03,5F6
08B38:  MOVFF  03,61D
08B3C:  MOVFF  01,61C
08B40:  MOVLB  0
08B42:  CALL   4BB2
08B46:  MOVF   01,F
08B48:  BNZ   8B52
08B4A:  MOVLW  02
08B4C:  MOVWF  01
08B4E:  BRA    8C1C
08B50:  BRA    8BB2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08B52:  MOVLB  6
08B54:  CLRF   x2B
08B56:  MOVFF  5E8,62A
08B5A:  CLRF   x2D
08B5C:  MOVLW  B5
08B5E:  MOVWF  x2C
08B60:  MOVLB  0
08B62:  CALL   0858
08B66:  MOVFF  02,5F6
08B6A:  MOVFF  01,5F5
08B6E:  MOVLW  06
08B70:  MOVLB  5
08B72:  ADDWF  xF5,F
08B74:  MOVLW  00
08B76:  ADDWFC xF6,F
08B78:  MOVLW  32
08B7A:  ADDWF  xF5,W
08B7C:  MOVWF  01
08B7E:  MOVLW  00
08B80:  ADDWFC xF6,W
08B82:  MOVWF  03
08B84:  MOVF   01,W
08B86:  ADDLW  66
08B88:  MOVWF  01
08B8A:  MOVLW  01
08B8C:  ADDWFC 03,F
08B8E:  MOVFF  01,5F5
08B92:  MOVFF  03,5F6
08B96:  MOVFF  03,61D
08B9A:  MOVFF  01,61C
08B9E:  MOVLB  6
08BA0:  CLRF   x1F
08BA2:  CLRF   x1E
08BA4:  MOVLW  0A
08BA6:  MOVWF  x20
08BA8:  MOVLB  0
08BAA:  CALL   4CA2
08BAE:  MOVFF  01,5F4
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%f,", manualOutputValues[arg1-1]);
08BB2:  MOVLW  04
08BB4:  MOVLB  6
08BB6:  MOVWF  x2B
08BB8:  MOVLW  3C
08BBA:  MOVWF  x2A
08BBC:  MOVLB  0
08BBE:  CALL   4A3A
08BC2:  MOVF   01,W
08BC4:  ADDLW  3C
08BC6:  MOVLB  5
08BC8:  MOVWF  xF5
08BCA:  MOVLW  04
08BCC:  ADDWFC 02,W
08BCE:  MOVWF  xF6
08BD0:  MOVLW  01
08BD2:  SUBWF  xF4,W
08BD4:  MULLW  04
08BD6:  MOVF   FF3,W
08BD8:  CLRF   03
08BDA:  ADDLW  EA
08BDC:  MOVWF  FE9
08BDE:  MOVLW  00
08BE0:  ADDWFC 03,W
08BE2:  MOVWF  FEA
08BE4:  MOVFF  FEF,62C
08BE8:  MOVFF  FEC,62D
08BEC:  MOVFF  FEC,62E
08BF0:  MOVFF  FEC,62F
08BF4:  MOVFF  5F6,4E1
08BF8:  MOVFF  5F5,4E0
08BFC:  MOVLW  89
08BFE:  MOVWF  FE9
08C00:  MOVLW  02
08C02:  MOVLB  6
08C04:  MOVWF  x30
08C06:  MOVLB  0
08C08:  CALL   57C2
08C0C:  MOVLW  2C
08C0E:  MOVLB  6
08C10:  MOVWF  x39
08C12:  MOVLB  0
08C14:  CALL   4AEA
....................    
....................    return SUCCESS;
08C18:  MOVLW  00
08C1A:  MOVWF  01
08C1C:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08C1E:  MOVLB  6
08C20:  CLRF   x2B
08C22:  MOVFF  5E8,62A
08C26:  CLRF   x2D
08C28:  MOVLW  B5
08C2A:  MOVWF  x2C
08C2C:  MOVLB  0
08C2E:  CALL   0858
08C32:  MOVFF  02,5FA
08C36:  MOVFF  01,5F9
08C3A:  MOVLW  06
08C3C:  MOVLB  5
08C3E:  ADDWF  xF9,F
08C40:  MOVLW  00
08C42:  ADDWFC xFA,F
08C44:  MOVLW  32
08C46:  ADDWF  xF9,W
08C48:  MOVWF  01
08C4A:  MOVLW  00
08C4C:  ADDWFC xFA,W
08C4E:  MOVWF  03
08C50:  MOVF   01,W
08C52:  ADDLW  66
08C54:  MOVWF  01
08C56:  MOVLW  01
08C58:  ADDWFC 03,F
08C5A:  MOVFF  01,5F9
08C5E:  MOVFF  03,5FA
08C62:  MOVFF  03,61D
08C66:  MOVFF  01,61C
08C6A:  MOVLB  0
08C6C:  CALL   4BB2
08C70:  MOVF   01,F
08C72:  BNZ   8C7C
08C74:  MOVLW  02
08C76:  MOVWF  01
08C78:  BRA    8DD0
08C7A:  BRA    8CDC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08C7C:  MOVLB  6
08C7E:  CLRF   x2B
08C80:  MOVFF  5E8,62A
08C84:  CLRF   x2D
08C86:  MOVLW  B5
08C88:  MOVWF  x2C
08C8A:  MOVLB  0
08C8C:  CALL   0858
08C90:  MOVFF  02,5FA
08C94:  MOVFF  01,5F9
08C98:  MOVLW  06
08C9A:  MOVLB  5
08C9C:  ADDWF  xF9,F
08C9E:  MOVLW  00
08CA0:  ADDWFC xFA,F
08CA2:  MOVLW  32
08CA4:  ADDWF  xF9,W
08CA6:  MOVWF  01
08CA8:  MOVLW  00
08CAA:  ADDWFC xFA,W
08CAC:  MOVWF  03
08CAE:  MOVF   01,W
08CB0:  ADDLW  66
08CB2:  MOVWF  01
08CB4:  MOVLW  01
08CB6:  ADDWFC 03,F
08CB8:  MOVFF  01,5F9
08CBC:  MOVFF  03,5FA
08CC0:  MOVFF  03,61D
08CC4:  MOVFF  01,61C
08CC8:  MOVLB  6
08CCA:  CLRF   x1F
08CCC:  CLRF   x1E
08CCE:  MOVLW  0A
08CD0:  MOVWF  x20
08CD2:  MOVLB  0
08CD4:  CALL   4CA2
08CD8:  MOVFF  01,5F4
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
08CDC:  MOVLB  6
08CDE:  CLRF   x2B
08CE0:  MOVFF  5E8,62A
08CE4:  CLRF   x2D
08CE6:  MOVLW  B5
08CE8:  MOVWF  x2C
08CEA:  MOVLB  0
08CEC:  CALL   0858
08CF0:  MOVFF  02,5FA
08CF4:  MOVFF  01,5F9
08CF8:  MOVLW  06
08CFA:  MOVLB  5
08CFC:  ADDWF  xF9,F
08CFE:  MOVLW  00
08D00:  ADDWFC xFA,F
08D02:  MOVLW  4B
08D04:  ADDWF  xF9,W
08D06:  MOVWF  01
08D08:  MOVLW  00
08D0A:  ADDWFC xFA,W
08D0C:  MOVWF  03
08D0E:  MOVF   01,W
08D10:  ADDLW  66
08D12:  MOVWF  01
08D14:  MOVLW  01
08D16:  ADDWFC 03,F
08D18:  MOVFF  01,5F9
08D1C:  MOVFF  03,5FA
08D20:  MOVFF  03,5FE
08D24:  MOVFF  01,5FD
08D28:  MOVLB  0
08D2A:  CALL   5D8C
08D2E:  MOVF   01,F
08D30:  BNZ   8D3A
08D32:  MOVLW  02
08D34:  MOVWF  01
08D36:  BRA    8DD0
08D38:  BRA    8DA4
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
08D3A:  MOVLB  6
08D3C:  CLRF   x2B
08D3E:  MOVFF  5E8,62A
08D42:  CLRF   x2D
08D44:  MOVLW  B5
08D46:  MOVWF  x2C
08D48:  MOVLB  0
08D4A:  CALL   0858
08D4E:  MOVFF  02,5FA
08D52:  MOVFF  01,5F9
08D56:  MOVLW  06
08D58:  MOVLB  5
08D5A:  ADDWF  xF9,F
08D5C:  MOVLW  00
08D5E:  ADDWFC xFA,F
08D60:  MOVLW  4B
08D62:  ADDWF  xF9,W
08D64:  MOVWF  01
08D66:  MOVLW  00
08D68:  ADDWFC xFA,W
08D6A:  MOVWF  03
08D6C:  MOVF   01,W
08D6E:  ADDLW  66
08D70:  MOVWF  01
08D72:  MOVLW  01
08D74:  ADDWFC 03,F
08D76:  MOVFF  01,5F9
08D7A:  MOVFF  03,5FA
08D7E:  MOVFF  03,5FE
08D82:  MOVFF  01,5FD
08D86:  MOVLB  6
08D88:  CLRF   x00
08D8A:  MOVLB  5
08D8C:  CLRF   xFF
08D8E:  MOVLB  0
08D90:  CALL   5E60
08D94:  MOVFF  03,5F8
08D98:  MOVFF  02,5F7
08D9C:  MOVFF  01,5F6
08DA0:  MOVFF  00,5F5
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    manualOutputValues[arg1-1] = arg2;
08DA4:  MOVLW  01
08DA6:  MOVLB  5
08DA8:  SUBWF  xF4,W
08DAA:  MULLW  04
08DAC:  MOVF   FF3,W
08DAE:  CLRF   03
08DB0:  ADDLW  EA
08DB2:  MOVWF  FE9
08DB4:  MOVLW  00
08DB6:  ADDWFC 03,W
08DB8:  MOVWF  FEA
08DBA:  MOVFF  5F5,FEF
08DBE:  MOVFF  5F6,FEC
08DC2:  MOVFF  5F7,FEC
08DC6:  MOVFF  5F8,FEC
....................    
....................    return SUCCESS;
08DCA:  MOVLW  00
08DCC:  MOVWF  01
08DCE:  MOVLB  0
08DD0:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
08DD2:  MOVLW  01
08DD4:  MOVWF  01
08DD6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
05D8C:  MOVLB  5
05D8E:  BCF    xFF.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
05D90:  MOVLB  6
05D92:  CLRF   x00
05D94:  MOVFF  5FE,62B
05D98:  MOVFF  5FD,62A
05D9C:  MOVLB  0
05D9E:  CALL   4A3A
05DA2:  MOVFF  02,03
05DA6:  MOVF   01,W
05DA8:  MOVF   03,F
05DAA:  BNZ   5DB6
05DAC:  MOVF   01,W
05DAE:  MOVLB  6
05DB0:  SUBWF  x00,W
05DB2:  BC    5E56
05DB4:  MOVLB  0
....................       if (!isdigit(arg[i])){
05DB6:  MOVLB  6
05DB8:  MOVF   x00,W
05DBA:  MOVLB  5
05DBC:  ADDWF  xFD,W
05DBE:  MOVWF  FE9
05DC0:  MOVLW  00
05DC2:  ADDWFC xFE,W
05DC4:  MOVWF  FEA
05DC6:  MOVFF  FEF,601
05DCA:  MOVLB  6
05DCC:  MOVF   x01,W
05DCE:  SUBLW  2F
05DD0:  BC    5DD8
05DD2:  MOVF   x01,W
05DD4:  SUBLW  39
05DD6:  BC    5E52
....................          // Check for negative sign
....................          if ('-' != arg[i]){
05DD8:  MOVF   x00,W
05DDA:  MOVLB  5
05DDC:  ADDWF  xFD,W
05DDE:  MOVWF  FE9
05DE0:  MOVLW  00
05DE2:  ADDWFC xFE,W
05DE4:  MOVWF  FEA
05DE6:  MOVF   FEF,W
05DE8:  SUBLW  2D
05DEA:  BZ    5E1A
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
05DEC:  MOVLB  6
05DEE:  MOVF   x00,W
05DF0:  MOVLB  5
05DF2:  ADDWF  xFD,W
05DF4:  MOVWF  FE9
05DF6:  MOVLW  00
05DF8:  ADDWFC xFE,W
05DFA:  MOVWF  FEA
05DFC:  MOVF   FEF,W
05DFE:  SUBLW  2E
05E00:  BZ    5E0A
05E02:  MOVLW  00
05E04:  MOVWF  01
05E06:  BRA    5E5C
05E08:  BRA    5E18
....................             else if  (decimal) return FALSE;
05E0A:  BTFSS  xFF.0
05E0C:  BRA    5E16
05E0E:  MOVLW  00
05E10:  MOVWF  01
05E12:  BRA    5E5C
05E14:  BRA    5E18
....................             else decimal = TRUE;
05E16:  BSF    xFF.0
....................          }
05E18:  BRA    5E4E
....................          else if (0 != i) return FALSE;
05E1A:  MOVLB  6
05E1C:  MOVF   x00,F
05E1E:  BZ    5E2A
05E20:  MOVLW  00
05E22:  MOVWF  01
05E24:  MOVLB  5
05E26:  BRA    5E5C
05E28:  BRA    5E4E
....................          else if (1 == strlen(arg)) return FALSE;
05E2A:  MOVFF  5FE,62B
05E2E:  MOVFF  5FD,62A
05E32:  MOVLB  0
05E34:  CALL   4A3A
05E38:  MOVFF  02,03
05E3C:  MOVF   01,W
05E3E:  SUBLW  01
05E40:  BNZ   5E50
05E42:  MOVF   03,F
05E44:  BNZ   5E50
05E46:  MOVLW  00
05E48:  MOVWF  01
05E4A:  MOVLB  5
05E4C:  BRA    5E5C
05E4E:  MOVLB  0
05E50:  MOVLB  6
....................       }
05E52:  INCF   x00,F
05E54:  BRA    5D94
....................    }
....................    return TRUE;
05E56:  MOVLW  01
05E58:  MOVWF  01
05E5A:  MOVLB  5
05E5C:  MOVLB  0
05E5E:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
04BB2:  MOVFF  61D,62B
04BB6:  MOVFF  61C,62A
04BBA:  RCALL  4A3A
04BBC:  MOVFF  02,03
04BC0:  MOVF   01,W
04BC2:  SUBLW  01
04BC4:  BNZ   4BCA
04BC6:  MOVF   03,F
04BC8:  BZ    4BD2
04BCA:  MOVLW  00
04BCC:  MOVWF  01
04BCE:  BRA    4C00
04BD0:  BRA    4BF8
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
04BD2:  MOVLB  6
04BD4:  MOVFF  61C,FE9
04BD8:  MOVFF  61D,FEA
04BDC:  MOVF   FEF,W
04BDE:  SUBLW  31
04BE0:  BZ    4BFA
04BE2:  MOVFF  61C,FE9
04BE6:  MOVFF  61D,FEA
04BEA:  MOVF   FEF,W
04BEC:  SUBLW  32
04BEE:  BZ    4BFA
04BF0:  MOVLW  00
04BF2:  MOVWF  01
04BF4:  MOVLB  0
04BF6:  BRA    4C00
04BF8:  MOVLB  6
....................     return TRUE;
04BFA:  MOVLW  01
04BFC:  MOVWF  01
04BFE:  MOVLB  0
04C00:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
04A00:  MOVLB  5
04A02:  MOVF   xF3,W
04A04:  SUBLW  2F
04A06:  BC    4A18
04A08:  MOVF   xF3,W
04A0A:  SUBLW  39
04A0C:  BNC   4A18
04A0E:  MOVLW  30
04A10:  SUBWF  xF3,W
04A12:  MOVWF  01
04A14:  BRA    4A34
04A16:  BRA    4A34
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
04A18:  MOVF   xF3,W
04A1A:  SUBLW  40
04A1C:  BC    4A30
04A1E:  MOVF   xF3,W
04A20:  SUBLW  46
04A22:  BNC   4A30
04A24:  MOVLW  41
04A26:  SUBWF  xF3,W
04A28:  ADDLW  0A
04A2A:  MOVWF  01
04A2C:  BRA    4A34
04A2E:  BRA    4A34
....................    else return 0xFF;
04A30:  MOVLW  FF
04A32:  MOVWF  01
04A34:  MOVLB  0
04A36:  GOTO   8E7E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
08DD8:  MOVLB  6
08DDA:  CLRF   x2B
08DDC:  MOVFF  5EA,62A
08DE0:  CLRF   x2D
08DE2:  MOVLW  B5
08DE4:  MOVWF  x2C
08DE6:  MOVLB  0
08DE8:  CALL   0858
08DEC:  MOVFF  02,5F3
08DF0:  MOVFF  01,5F2
08DF4:  MOVLW  06
08DF6:  MOVLB  5
08DF8:  ADDWF  xF2,F
08DFA:  MOVLW  00
08DFC:  ADDWFC xF3,F
08DFE:  MOVLW  66
08E00:  ADDWF  xF2,W
08E02:  MOVWF  01
08E04:  MOVLW  01
08E06:  ADDWFC xF3,W
08E08:  MOVWF  03
08E0A:  MOVFF  01,5EB
08E0E:  MOVWF  xEC
08E10:  MOVLB  6
08E12:  CLRF   x2B
08E14:  MOVFF  5EA,62A
08E18:  CLRF   x2D
08E1A:  MOVLW  B5
08E1C:  MOVWF  x2C
08E1E:  MOVLB  0
08E20:  CALL   0858
08E24:  MOVFF  02,5F5
08E28:  MOVFF  01,5F4
08E2C:  MOVLW  06
08E2E:  MOVLB  5
08E30:  ADDWF  xF4,F
08E32:  MOVLW  00
08E34:  ADDWFC xF5,F
08E36:  MOVLW  19
08E38:  ADDWF  xF4,W
08E3A:  MOVWF  01
08E3C:  MOVLW  00
08E3E:  ADDWFC xF5,W
08E40:  MOVWF  03
08E42:  MOVF   01,W
08E44:  ADDLW  66
08E46:  MOVWF  01
08E48:  MOVLW  01
08E4A:  ADDWFC 03,F
08E4C:  MOVFF  01,5ED
08E50:  MOVFF  03,5EE
08E54:  CLRF   xEF
08E56:  CLRF   xF0
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
08E58:  MOVFF  5EB,FE9
08E5C:  MOVFF  5EC,FEA
08E60:  MOVF   FEF,W
08E62:  SUBLW  44
08E64:  BTFSS  FD8.2
08E66:  BRA    8F56
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
08E68:  MOVLW  01
08E6A:  ADDWF  xEB,W
08E6C:  MOVWF  FE9
08E6E:  MOVLW  00
08E70:  ADDWFC xEC,W
08E72:  MOVWF  FEA
08E74:  MOVFF  FEF,5F3
08E78:  MOVLB  0
08E7A:  GOTO   4A00
08E7E:  MOVFF  01,5F2
08E82:  MOVLB  5
08E84:  MOVF   xEF,W
08E86:  ANDLW  0F
08E88:  SUBWF  01,W
08E8A:  BNZ   8F4E
....................          while (0 != strlen(cmd_list[i].cmd_name)){
08E8C:  MOVF   xF0,W
08E8E:  MULLW  04
08E90:  MOVF   FF3,W
08E92:  CLRF   xF3
08E94:  MOVWF  xF2
08E96:  MOVLW  E6
08E98:  ADDWF  xF2,W
08E9A:  MOVWF  FE9
08E9C:  MOVLW  04
08E9E:  ADDWFC xF3,W
08EA0:  MOVWF  FEA
08EA2:  MOVFF  FEC,62B
08EA6:  MOVF   FED,F
08EA8:  MOVFF  FEF,62A
08EAC:  MOVLB  0
08EAE:  CALL   4A3A
08EB2:  MOVFF  02,03
08EB6:  MOVF   01,W
08EB8:  BNZ   8EBE
08EBA:  MOVF   03,F
08EBC:  BZ    8F44
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
08EBE:  MOVLB  5
08EC0:  MOVF   xF0,W
08EC2:  MULLW  04
08EC4:  MOVF   FF3,W
08EC6:  CLRF   xF3
08EC8:  MOVWF  xF2
08ECA:  MOVLW  E6
08ECC:  ADDWF  xF2,W
08ECE:  MOVWF  FE9
08ED0:  MOVLW  04
08ED2:  ADDWFC xF3,W
08ED4:  MOVWF  FEA
08ED6:  MOVFF  FEC,62D
08EDA:  MOVF   FED,F
08EDC:  MOVFF  FEF,62C
08EE0:  MOVFF  5EE,62B
08EE4:  MOVFF  5ED,62A
08EE8:  MOVLB  0
08EEA:  CALL   4A72
08EEE:  MOVF   01,F
08EF0:  BNZ   8F3C
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
08EF2:  MOVLB  5
08EF4:  MOVF   xF0,W
08EF6:  MULLW  04
08EF8:  MOVF   FF3,W
08EFA:  CLRF   xF3
08EFC:  MOVWF  xF2
08EFE:  MOVLW  02
08F00:  ADDWF  xF2,W
08F02:  MOVWF  01
08F04:  MOVLW  00
08F06:  ADDWFC xF3,W
08F08:  MOVWF  03
08F0A:  MOVF   01,W
08F0C:  ADDLW  E6
08F0E:  MOVWF  01
08F10:  MOVLW  04
08F12:  ADDWFC 03,F
08F14:  MOVFF  01,5F2
08F18:  MOVFF  03,5F3
08F1C:  MOVFF  03,FEA
08F20:  MOVFF  01,FE9
08F24:  MOVFF  5EA,5E8
08F28:  MOVLB  0
08F2A:  CALL   00BC
08F2E:  MOVFF  01,5F1
....................                return return_code;
08F32:  MOVLB  5
08F34:  MOVFF  5F1,01
08F38:  BRA    8F5A
08F3A:  MOVLB  0
....................             }
....................             i++;
08F3C:  MOVLB  5
08F3E:  INCF   xF0,F
08F40:  BRA    8E8C
08F42:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
08F44:  MOVLW  01
08F46:  MOVWF  01
08F48:  MOVLB  5
08F4A:  BRA    8F5A
....................       } else return 254; // NOT THIS ADDRESS
08F4C:  BRA    8F54
08F4E:  MOVLW  FE
08F50:  MOVWF  01
08F52:  BRA    8F5A
....................    } else return 255; // NOT THIS DEVICE TYPE
08F54:  BRA    8F5A
08F56:  MOVLW  FF
08F58:  MOVWF  01
08F5A:  MOVLB  0
08F5C:  GOTO   8F96 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
08F88:  GOTO   49A6
08F8C:  MOVF   01,F
08F8E:  BZ    907E
....................    {
....................       int8 return_code = command_parser(SRI);
08F90:  MOVFF  43A,5EA
08F94:  BRA    8DD8
08F96:  MOVFF  01,5E9
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
08F9A:  MOVLW  04
08F9C:  MOVLB  6
08F9E:  MOVWF  x2B
08FA0:  MOVLW  3C
08FA2:  MOVWF  x2A
08FA4:  MOVLB  0
08FA6:  CALL   4A3A
08FAA:  MOVF   01,W
08FAC:  ADDLW  3C
08FAE:  MOVLB  5
08FB0:  MOVWF  xEA
08FB2:  MOVLW  04
08FB4:  ADDWFC 02,W
08FB6:  MOVWF  xEB
08FB8:  MOVF   xE9,W
08FBA:  MULLW  03
08FBC:  MOVF   FF3,W
08FBE:  CLRF   xED
08FC0:  MOVWF  xEC
08FC2:  MOVLW  01
08FC4:  ADDWF  xEC,W
08FC6:  MOVWF  01
08FC8:  MOVLW  00
08FCA:  ADDWFC xED,W
08FCC:  MOVWF  03
08FCE:  MOVF   01,W
08FD0:  ADDLW  B5
08FD2:  MOVWF  FE9
08FD4:  MOVLW  05
08FD6:  ADDWFC 03,W
08FD8:  MOVWF  FEA
08FDA:  MOVFF  FEC,5ED
08FDE:  MOVF   FED,F
08FE0:  MOVFF  FEF,5EC
08FE4:  MOVFF  5EB,4E1
08FE8:  MOVFF  5EA,4E0
08FEC:  MOVFF  4E1,FEA
08FF0:  MOVFF  4E0,FE9
08FF4:  CLRF   FEF
08FF6:  MOVFF  5ED,FEA
08FFA:  MOVFF  5EC,FE9
08FFE:  MOVLB  0
09000:  BRA    8F60
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
09002:  MOVLB  6
09004:  CLRF   x2B
09006:  MOVFF  43A,62A
0900A:  CLRF   x2D
0900C:  MOVLW  B5
0900E:  MOVWF  x2C
09010:  MOVLB  0
09012:  CALL   0858
09016:  MOVFF  02,5EB
0901A:  MOVFF  01,5EA
0901E:  MOVLW  06
09020:  MOVLB  5
09022:  ADDWF  xEA,F
09024:  MOVLW  00
09026:  ADDWFC xEB,F
09028:  MOVLW  66
0902A:  ADDWF  xEA,W
0902C:  MOVWF  01
0902E:  MOVLW  01
09030:  ADDWFC xEB,W
09032:  MOVWF  03
09034:  MOVFF  01,5EC
09038:  MOVWF  xED
0903A:  MOVLW  24
0903C:  MOVWF  xF0
0903E:  MOVLB  0
09040:  CALL   4442
09044:  MOVFF  5ED,FEA
09048:  MOVFF  5EC,FE9
0904C:  CALL   446A
09050:  MOVLW  2C
09052:  MOVLB  5
09054:  MOVWF  xF0
09056:  MOVLB  0
09058:  CALL   4442
0905C:  MOVLW  04
0905E:  MOVWF  FEA
09060:  MOVLW  3C
09062:  MOVWF  FE9
09064:  CALL   446A
09068:  MOVLW  0A
0906A:  MOVLB  5
0906C:  MOVWF  xF0
0906E:  MOVLB  0
09070:  CALL   4442
....................       
....................       resetSERcmd(SRI);
09074:  MOVFF  43A,5EA
09078:  CALL   087A
0907C:  BRA    8F88
....................    }
0907E:  GOTO   9430 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... //!#define DEBUG_1
.................... //!#define DEBUG_2
.................... 
.................... void main()
09082:  CLRF   FF8
09084:  BCF    FF2.5
09086:  BSF    07.7
09088:  MOVLB  E
0908A:  MOVLW  55
0908C:  MOVWF  x9B
0908E:  MOVLW  AA
09090:  MOVWF  x9B
09092:  BCF    x9B.0
09094:  MOVLW  17
09096:  MOVWF  xB0
09098:  MOVLW  13
0909A:  MOVWF  xB2
0909C:  MOVLW  09
0909E:  MOVWF  x8A
090A0:  MOVLW  0A
090A2:  MOVWF  x8B
090A4:  MOVLW  11
090A6:  MOVWF  xEB
090A8:  MOVLW  12
090AA:  MOVWF  xED
090AC:  MOVLW  10
090AE:  MOVWF  xF4
090B0:  MOVLW  0F
090B2:  MOVWF  xF5
090B4:  MOVLW  09
090B6:  MOVWF  xF8
090B8:  MOVLW  55
090BA:  MOVWF  x9B
090BC:  MOVLW  AA
090BE:  MOVWF  x9B
090C0:  BSF    x9B.0
090C2:  CLRF   xD8
090C4:  CLRF   xD5
090C6:  CLRF   xD7
090C8:  MOVLW  08
090CA:  MOVWF  xD9
090CC:  MOVLW  60
090CE:  MOVWF  xD3
090D0:  MOVLW  AA
090D2:  MOVLB  0
090D4:  MOVWF  xF2
090D6:  MOVLB  1
090D8:  CLRF   x54
090DA:  CLRF   x53
090DC:  CLRF   x52
090DE:  CLRF   x51
090E0:  CLRF   x58
090E2:  CLRF   x57
090E4:  CLRF   x56
090E6:  CLRF   x55
090E8:  CLRF   x5C
090EA:  CLRF   x5B
090EC:  CLRF   x5A
090EE:  CLRF   x59
090F0:  CLRF   x5E
090F2:  CLRF   x5D
090F4:  MOVLB  E
090F6:  BCF    x91.5
090F8:  MOVLW  00
090FA:  MOVWF  x90
090FC:  MOVLW  0F
090FE:  MOVWF  x8E
09100:  MOVLW  2A
09102:  MOVWF  x91
09104:  MOVLW  C4
09106:  MOVWF  F88
09108:  MOVWF  F88
0910A:  MOVWF  F88
0910C:  BCF    F95.5
0910E:  MOVLW  40
09110:  MOVWF  F94
09112:  MOVLW  9F
09114:  MOVWF  F92
09116:  MOVLW  2A
09118:  MOVWF  F95
0911A:  MOVLW  93
0911C:  MOVWF  F89
0911E:  MOVWF  F89
09120:  MOVLB  4
09122:  CLRF   x3A
09124:  CLRF   x3B
09126:  CLRF   xDC
09128:  CLRF   xDD
0912A:  BCF    xDE.0
0912C:  CLRF   xDF
0912E:  BSF    F9E.3
09130:  MOVLW  7C
09132:  MOVWF  F9A
09134:  MOVLW  00
09136:  MOVWF  F9B
09138:  MOVLW  A6
0913A:  MOVWF  F9D
0913C:  MOVLW  90
0913E:  MOVWF  F9C
09140:  MOVLW  93
09142:  MOVWF  F89
09144:  BCF    F84.5
09146:  CLRF   xE1
09148:  CLRF   xE0
0914A:  CLRF   xE5
0914C:  CLRF   xE4
0914E:  CLRF   xE3
09150:  CLRF   xE2
09152:  MOVLB  F
09154:  CLRF   x0C
09156:  CLRF   x14
09158:  CLRF   x1C
0915A:  CLRF   x21
0915C:  CLRF   x29
0915E:  CLRF   x35
09160:  CLRF   x36
09162:  CLRF   x37
09164:  CLRF   x34
09166:  CLRF   x31
09168:  CLRF   x32
0916A:  CLRF   x33
0916C:  CLRF   x30
0916E:  MOVLW  4B
09170:  MOVLB  4
09172:  MOVWF  xE9
09174:  MOVLW  2A
09176:  MOVWF  xE8
09178:  MOVLW  4B
0917A:  MOVWF  xED
0917C:  MOVLW  6E
0917E:  MOVWF  xEC
09180:  MOVLW  4F
09182:  MOVWF  xF1
09184:  MOVLW  F6
09186:  MOVWF  xF0
09188:  MOVLW  51
0918A:  MOVWF  xF5
0918C:  MOVLW  AA
0918E:  MOVWF  xF4
09190:  MOVLW  53
09192:  MOVWF  xF9
09194:  MOVLW  62
09196:  MOVWF  xF8
09198:  MOVLW  54
0919A:  MOVWF  xFD
0919C:  MOVLW  CC
0919E:  MOVWF  xFC
091A0:  MOVLW  59
091A2:  MOVLB  5
091A4:  MOVWF  x01
091A6:  MOVLW  72
091A8:  MOVWF  x00
091AA:  MOVLW  60
091AC:  MOVWF  x05
091AE:  MOVLW  D6
091B0:  MOVWF  x04
091B2:  MOVLW  63
091B4:  MOVWF  x09
091B6:  MOVLW  BC
091B8:  MOVWF  x08
091BA:  MOVLW  64
091BC:  MOVWF  x0D
091BE:  MOVLW  F6
091C0:  MOVWF  x0C
091C2:  MOVLW  66
091C4:  MOVWF  x11
091C6:  MOVLW  BA
091C8:  MOVWF  x10
091CA:  MOVLW  6A
091CC:  MOVWF  x15
091CE:  MOVLW  3A
091D0:  MOVWF  x14
091D2:  MOVLW  6E
091D4:  MOVWF  x19
091D6:  MOVLW  A8
091D8:  MOVWF  x18
091DA:  MOVLW  72
091DC:  MOVWF  x1D
091DE:  MOVLW  46
091E0:  MOVWF  x1C
091E2:  MOVLW  77
091E4:  MOVWF  x21
091E6:  MOVLW  7A
091E8:  MOVWF  x20
091EA:  MOVLW  77
091EC:  MOVWF  x25
091EE:  MOVLW  80
091F0:  MOVWF  x24
091F2:  MOVLW  7D
091F4:  MOVWF  x29
091F6:  MOVLW  FC
091F8:  MOVWF  x28
091FA:  MOVLW  83
091FC:  MOVWF  x2D
091FE:  MOVLW  B8
09200:  MOVWF  x2C
09202:  MOVLW  8A
09204:  MOVWF  x31
09206:  MOVLW  F4
09208:  MOVWF  x30
0920A:  MOVLW  8C
0920C:  MOVWF  x35
0920E:  MOVLW  1E
09210:  MOVWF  x34
09212:  MOVLW  8D
09214:  MOVWF  x39
09216:  MOVLW  D2
09218:  MOVWF  x38
0921A:  BRA    93C2
0921C:  DATA 02,00
0921E:  DATA 1A,00
09220:  DATA 00,04
09222:  DATA 00,20
09224:  DATA 78,23
09226:  DATA D7,0A
09228:  DATA 1C,C0
0922A:  DATA 00,04
0922C:  DATA 80,78
0922E:  DATA 23,D7
09230:  DATA 0A,1C
09232:  DATA C0,00
09234:  DATA 01,80
09236:  DATA 02,09
09238:  DATA C0,00
0923A:  DATA 05,80
0923C:  DATA 7F,00
0923E:  DATA 00,00
09240:  DATA 7F,0B
09242:  DATA C0,00
09244:  DATA 05,80
09246:  DATA 7F,00
09248:  DATA 00,00
0924A:  DATA 7F,07
0924C:  DATA C0,00
0924E:  DATA 01,80
09250:  DATA 7F,17
09252:  DATA C0,00
09254:  DATA 01,80
09256:  DATA 7F,17
09258:  DATA C0,00
0925A:  DATA 04,80
0925C:  DATA 79,B7
0925E:  DATA F3,BD
09260:  DATA 04,C0
09262:  DATA 00,04
09264:  DATA 80,7C
09266:  DATA 59,DF
09268:  DATA 4E,04
0926A:  DATA C0,00
0926C:  DATA 04,80
0926E:  DATA 78,0A
09270:  DATA 28,88
09272:  DATA 04,C0
09274:  DATA 00,04
09276:  DATA 80,78
09278:  DATA 05,EA
0927A:  DATA 16,04
0927C:  DATA C0,00
0927E:  DATA 04,80
09280:  DATA 78,1E
09282:  DATA 33,D7
09284:  DATA 04,C0
09286:  DATA 00,04
09288:  DATA 80,77
0928A:  DATA 68,7B
0928C:  DATA BB,04
0928E:  DATA C0,00
09290:  DATA 04,80
09292:  DATA 77,68
09294:  DATA 0D,C6
09296:  DATA 08,C0
09298:  DATA 00,5E
0929A:  DATA 40,F3
0929C:  DATA 00,07
0929E:  DATA 41,5F
092A0:  DATA 00,3C
092A2:  DATA 44,A0
092A4:  DATA 00,02
092A6:  DATA 04,E6
092A8:  DATA 3A,05
092AA:  DATA 02,04
092AC:  DATA EA,3D
092AE:  DATA 05,02
092B0:  DATA 04,EE
092B2:  DATA 40,05
092B4:  DATA 02,04
092B6:  DATA F2,47
092B8:  DATA 05,02
092BA:  DATA 04,F6
092BC:  DATA 4E,05
092BE:  DATA 02,04
092C0:  DATA FA,56
092C2:  DATA 05,02
092C4:  DATA 04,FE
092C6:  DATA 5E,05
092C8:  DATA 02,05
092CA:  DATA 02,63
092CC:  DATA 05,02
092CE:  DATA 05,06
092D0:  DATA 68,05
092D2:  DATA 02,05
092D4:  DATA 0A,6C
092D6:  DATA 05,02
092D8:  DATA 05,0E
092DA:  DATA 70,05
092DC:  DATA 02,05
092DE:  DATA 12,77
092E0:  DATA 05,02
092E2:  DATA 05,16
092E4:  DATA 7D,05
092E6:  DATA 02,05
092E8:  DATA 1A,83
092EA:  DATA 05,02
092EC:  DATA 05,1E
092EE:  DATA 89,05
092F0:  DATA 02,05
092F2:  DATA 22,8F
092F4:  DATA 05,02
092F6:  DATA 05,26
092F8:  DATA 94,05
092FA:  DATA 02,05
092FC:  DATA 2A,9D
092FE:  DATA 05,02
09300:  DATA 05,2E
09302:  DATA A5,05
09304:  DATA 02,05
09306:  DATA 32,AC
09308:  DATA 05,02
0930A:  DATA 05,36
0930C:  DATA B3,05
0930E:  DATA 78,05
09310:  DATA 3A,67
09312:  DATA 72,00
09314:  DATA 67,73
09316:  DATA 00,67
09318:  DATA 43,68
0931A:  DATA 4D,61
0931C:  DATA 70,00
0931E:  DATA 73,43
09320:  DATA 68,4D
09322:  DATA 61,70
09324:  DATA 00,67
09326:  DATA 43,68
09328:  DATA 4D,6F
0932A:  DATA 64,65
0932C:  DATA 00,73
0932E:  DATA 43,68
09330:  DATA 4D,6F
09332:  DATA 64,65
09334:  DATA 00,67
09336:  DATA 50,49
09338:  DATA 44,00
0933A:  DATA 73,50
0933C:  DATA 49,44
0933E:  DATA 00,67
09340:  DATA 53,50
09342:  DATA 00,73
09344:  DATA 53,50
09346:  DATA 00,67
09348:  DATA 53,43
0934A:  DATA 61,6C
0934C:  DATA 73,00
0934E:  DATA 67,53
09350:  DATA 43,61
09352:  DATA 6C,00
09354:  DATA 73,53
09356:  DATA 43,61
09358:  DATA 6C,00
0935A:  DATA 67,4D
0935C:  DATA 43,61
0935E:  DATA 6C,00
09360:  DATA 73,4D
09362:  DATA 43,61
09364:  DATA 6C,00
09366:  DATA 67,4D
09368:  DATA 6F,6E
0936A:  DATA 00,67
0936C:  DATA 50,49
0936E:  DATA 44,64
09370:  DATA 61,74
09372:  DATA 61,00
09374:  DATA 67,49
09376:  DATA 50,64
09378:  DATA 61,74
0937A:  DATA 61,00
0937C:  DATA 67,4D
0937E:  DATA 61,6E
09380:  DATA 4F,50
09382:  DATA 00,73
09384:  DATA 4D,61
09386:  DATA 6E,4F
09388:  DATA 50,04
0938A:  DATA C0,00
0938C:  DATA 32,80
0938E:  DATA BE,05
09390:  DATA 01,C6
09392:  DATA 05,02
09394:  DATA D6,05
09396:  DATA 53,55
09398:  DATA 43,43
0939A:  DATA 45,53
0939C:  DATA 53,00
0939E:  DATA 49,4E
093A0:  DATA 56,41
093A2:  DATA 4C,49
093A4:  DATA 44,20
093A6:  DATA 43,4F
093A8:  DATA 4D,4D
093AA:  DATA 41,4E
093AC:  DATA 44,00
093AE:  DATA 49,4E
093B0:  DATA 56,41
093B2:  DATA 4C,49
093B4:  DATA 44,20
093B6:  DATA 50,41
093B8:  DATA 52,41
093BA:  DATA 4D,45
093BC:  DATA 54,45
093BE:  DATA 52,00
093C0:  DATA 00,00
093C2:  MOVLW  00
093C4:  MOVWF  FF8
093C6:  MOVLW  92
093C8:  MOVWF  FF7
093CA:  MOVLW  1C
093CC:  MOVWF  FF6
093CE:  TBLRD*+
093D0:  MOVF   FF5,W
093D2:  MOVWF  00
093D4:  XORLW  00
093D6:  BZ    93FE
093D8:  TBLRD*+
093DA:  MOVF   FF5,W
093DC:  MOVWF  01
093DE:  BTFSC  FE8.7
093E0:  BRA    93EC
093E2:  ANDLW  3F
093E4:  MOVWF  FEA
093E6:  TBLRD*+
093E8:  MOVFF  FF5,FE9
093EC:  BTFSC  01.6
093EE:  TBLRD*+
093F0:  BTFSS  01.6
093F2:  TBLRD*+
093F4:  MOVFF  FF5,FEE
093F8:  DCFSNZ 00,F
093FA:  BRA    93CE
093FC:  BRA    93F0
093FE:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
09400:  MOVLB  0
09402:  GOTO   033A
....................    params_init();                // load parameters
09406:  GOTO   05E2
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0940A:  GOTO   079C
....................    control_init();               // initialize the output control DACs
0940E:  GOTO   0834
....................    serial_init();                // setup the serial port
09412:  GOTO   0A04
....................    event_timer_init();
09416:  GOTO   0A26
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0941A:  MOVLW  C0
0941C:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0941E:  GOTO   0E04
....................       sensor_monitor_task();     //get magnetoresistive sensor data
09422:  GOTO   3B08
....................       control_task();            //output control
09426:  GOTO   43C6
....................       serial_task();             //serial port 
0942A:  GOTO   448E
....................       
....................       #ifdef DEBUG_1
....................       fprintf(SERIAL, "#D0,1,%.0f,%.0f,SUCCESS\n", adcVals[0].sinCounts, adcVals[0].cosCounts);
....................       fprintf(SERIAL, "#D0,2,%.0f,%.0f,SUCCESS\n", adcVals[1].sinCounts, adcVals[1].cosCounts);
....................       fprintf(SERIAL, "#D0,1,%3.3f,SUCCESS\n", adcVals[0].pReal);
....................       fprintf(SERIAL, "#D0,2,%3.3f,SUCCESS\n", adcVals[1].pReal);
....................       #endif
....................       
....................       #ifdef DEBUG_2
....................       set_adc_channel(vMon3V6X);
....................       delay_ms(10);
....................       int16 mon3V6X = read_adc(ADC_READ_ONLY);
....................       delay_ms(10);
....................       read_adc(ADC_START_ONLY);
....................       delay_ms(10);
....................       fprintf(SERIAL, "%Ld\n", mon3V6X);
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0942E:  BRA    8F88
....................       
....................       delay_ms(200);
09430:  MOVLW  C8
09432:  MOVLB  5
09434:  MOVWF  xEE
09436:  MOVLB  0
09438:  CALL   03D0
0943C:  BRA    941E
....................    }
.................... }
0943E:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
