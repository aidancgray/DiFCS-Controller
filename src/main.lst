CCS PCH C Compiler, Version 5.109, 62303               15-Dec-25 14:04

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43796 bytes (67%)
                           Largest free fragment is 21738
               RAM used:   1798 (50%) at main() level
                           1909 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A31A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   010C
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   029E
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00372:  DATA 32,30
00374:  DATA 32,35
00376:  DATA 31,32
00378:  DATA 30,38
0037A:  DATA 00,00
0037C:  DATA 30,30
0037E:  DATA 30,30
00380:  DATA 00,00
00382:  DATA 25,64
00384:  DATA 2C,4D
00386:  DATA 41,4E
00388:  DATA 55,41
0038A:  DATA 4C,2C
0038C:  DATA 00,00
0038E:  DATA 25,64
00390:  DATA 2C,4D
00392:  DATA 41,47
00394:  DATA 53,4E
00396:  DATA 53,2C
00398:  DATA 00,00
0039A:  DATA 43,4E
0039C:  DATA 54,2C
0039E:  DATA 25,75
003A0:  DATA 2C,25
003A2:  DATA 2E,30
003A4:  DATA 66,2C
003A6:  DATA 25,2E
003A8:  DATA 30,66
003AA:  DATA 3B,00
003AC:  DATA 50,4F
003AE:  DATA 53,2C
003B0:  DATA 25,75
003B2:  DATA 2C,25
003B4:  DATA 33,2E
003B6:  DATA 33,66
003B8:  DATA 3B,00
003BA:  DATA 4F,55
003BC:  DATA 54,2C
003BE:  DATA 25,75
003C0:  DATA 2C,2D
003C2:  DATA 2C,25
003C4:  DATA 4C,75
003C6:  DATA 3B,00
003C8:  DATA 4F,55
003CA:  DATA 54,2C
003CC:  DATA 25,75
003CE:  DATA 2C,2B
003D0:  DATA 2C,25
003D2:  DATA 4C,75
003D4:  DATA 3B,00
*
0071A:  ADDWF  FE8,W
0071C:  CLRF   FF7
0071E:  RLCF   FF7,F
00720:  ADDLW  35
00722:  MOVWF  FF6
00724:  MOVLW  07
00726:  ADDWFC FF7,F
00728:  TBLRD*-
0072A:  MOVF   FF5,W
0072C:  MOVWF  FFA
0072E:  TBLRD*
00730:  MOVF   FF5,W
00732:  MOVWF  FF9
00734:  DATA E4,06
00736:  DATA EE,06
00738:  DATA F8,06
0073A:  DATA 02,07
*
008AC:  MOVLB  7
008AE:  MOVF   x41,W
008B0:  MULWF  x43
008B2:  MOVFF  FF3,01
008B6:  MOVFF  FF4,00
008BA:  MULWF  x44
008BC:  MOVF   FF3,W
008BE:  ADDWF  00,F
008C0:  MOVF   x42,W
008C2:  MULWF  x43
008C4:  MOVF   FF3,W
008C6:  ADDWFC 00,W
008C8:  MOVWF  02
008CA:  MOVLB  0
008CC:  RETURN 0
008CE:  MOVLB  7
008D0:  MOVF   x3B,W
008D2:  CLRF   01
008D4:  SUBWF  x3A,W
008D6:  BC    08DE
008D8:  MOVFF  73A,00
008DC:  BRA    08F6
008DE:  CLRF   00
008E0:  MOVLW  08
008E2:  MOVWF  x3C
008E4:  RLCF   x3A,F
008E6:  RLCF   00,F
008E8:  MOVF   x3B,W
008EA:  SUBWF  00,W
008EC:  BTFSC  FD8.0
008EE:  MOVWF  00
008F0:  RLCF   01,F
008F2:  DECFSZ x3C,F
008F4:  BRA    08E4
008F6:  MOVLB  0
008F8:  RETURN 0
*
00D60:  MOVLW  8E
00D62:  MOVWF  00
00D64:  MOVFF  74B,01
00D68:  MOVFF  74A,02
00D6C:  CLRF   03
00D6E:  MOVF   01,F
00D70:  BNZ   0D84
00D72:  MOVFF  02,01
00D76:  CLRF   02
00D78:  MOVLW  08
00D7A:  SUBWF  00,F
00D7C:  MOVF   01,F
00D7E:  BNZ   0D84
00D80:  CLRF   00
00D82:  BRA    0D94
00D84:  BCF    FD8.0
00D86:  BTFSC  01.7
00D88:  BRA    0D92
00D8A:  RLCF   02,F
00D8C:  RLCF   01,F
00D8E:  DECF   00,F
00D90:  BRA    0D84
00D92:  BCF    01.7
00D94:  RETURN 0
00D96:  MOVLB  7
00D98:  MOVF   x50,W
00D9A:  BTFSC  FD8.2
00D9C:  BRA    0E80
00D9E:  MOVWF  00
00DA0:  MOVF   x54,W
00DA2:  BTFSC  FD8.2
00DA4:  BRA    0E80
00DA6:  ADDWF  00,F
00DA8:  BNC   0DB2
00DAA:  MOVLW  81
00DAC:  ADDWF  00,F
00DAE:  BC    0E80
00DB0:  BRA    0DBA
00DB2:  MOVLW  7F
00DB4:  SUBWF  00,F
00DB6:  BNC   0E80
00DB8:  BZ    0E80
00DBA:  MOVFF  751,758
00DBE:  MOVF   x55,W
00DC0:  XORWF  x58,F
00DC2:  BSF    x51.7
00DC4:  BSF    x55.7
00DC6:  MOVF   x53,W
00DC8:  MULWF  x57
00DCA:  MOVFF  FF4,75A
00DCE:  MOVF   x52,W
00DD0:  MULWF  x56
00DD2:  MOVFF  FF4,03
00DD6:  MOVFF  FF3,759
00DDA:  MULWF  x57
00DDC:  MOVF   FF3,W
00DDE:  ADDWF  x5A,F
00DE0:  MOVF   FF4,W
00DE2:  ADDWFC x59,F
00DE4:  MOVLW  00
00DE6:  ADDWFC 03,F
00DE8:  MOVF   x53,W
00DEA:  MULWF  x56
00DEC:  MOVF   FF3,W
00DEE:  ADDWF  x5A,F
00DF0:  MOVF   FF4,W
00DF2:  ADDWFC x59,F
00DF4:  MOVLW  00
00DF6:  CLRF   02
00DF8:  ADDWFC 03,F
00DFA:  ADDWFC 02,F
00DFC:  MOVF   x51,W
00DFE:  MULWF  x57
00E00:  MOVF   FF3,W
00E02:  ADDWF  x59,F
00E04:  MOVF   FF4,W
00E06:  ADDWFC 03,F
00E08:  MOVLW  00
00E0A:  ADDWFC 02,F
00E0C:  MOVF   x51,W
00E0E:  MULWF  x56
00E10:  MOVF   FF3,W
00E12:  ADDWF  03,F
00E14:  MOVF   FF4,W
00E16:  ADDWFC 02,F
00E18:  MOVLW  00
00E1A:  CLRF   01
00E1C:  ADDWFC 01,F
00E1E:  MOVF   x53,W
00E20:  MULWF  x55
00E22:  MOVF   FF3,W
00E24:  ADDWF  x59,F
00E26:  MOVF   FF4,W
00E28:  ADDWFC 03,F
00E2A:  MOVLW  00
00E2C:  ADDWFC 02,F
00E2E:  ADDWFC 01,F
00E30:  MOVF   x52,W
00E32:  MULWF  x55
00E34:  MOVF   FF3,W
00E36:  ADDWF  03,F
00E38:  MOVF   FF4,W
00E3A:  ADDWFC 02,F
00E3C:  MOVLW  00
00E3E:  ADDWFC 01,F
00E40:  MOVF   x51,W
00E42:  MULWF  x55
00E44:  MOVF   FF3,W
00E46:  ADDWF  02,F
00E48:  MOVF   FF4,W
00E4A:  ADDWFC 01,F
00E4C:  INCF   00,F
00E4E:  BTFSC  01.7
00E50:  BRA    0E5C
00E52:  RLCF   x59,F
00E54:  RLCF   03,F
00E56:  RLCF   02,F
00E58:  RLCF   01,F
00E5A:  DECF   00,F
00E5C:  MOVLW  00
00E5E:  BTFSS  x59.7
00E60:  BRA    0E76
00E62:  INCF   03,F
00E64:  ADDWFC 02,F
00E66:  ADDWFC 01,F
00E68:  MOVF   01,W
00E6A:  BNZ   0E76
00E6C:  MOVF   02,W
00E6E:  BNZ   0E76
00E70:  MOVF   03,W
00E72:  BNZ   0E76
00E74:  INCF   00,F
00E76:  BTFSC  x58.7
00E78:  BSF    01.7
00E7A:  BTFSS  x58.7
00E7C:  BCF    01.7
00E7E:  BRA    0E88
00E80:  CLRF   00
00E82:  CLRF   01
00E84:  CLRF   02
00E86:  CLRF   03
00E88:  MOVLB  0
00E8A:  RETURN 0
00E8C:  MOVLW  80
00E8E:  BTFSS  FD8.1
00E90:  BRA    0E96
00E92:  MOVLB  7
00E94:  XORWF  x4F,F
00E96:  MOVLB  7
00E98:  CLRF   x54
00E9A:  CLRF   x55
00E9C:  MOVFF  74B,753
00EA0:  MOVF   x4F,W
00EA2:  XORWF  x53,F
00EA4:  MOVF   x4A,W
00EA6:  BTFSC  FD8.2
00EA8:  BRA    1068
00EAA:  MOVWF  x52
00EAC:  MOVWF  00
00EAE:  MOVF   x4E,W
00EB0:  BTFSC  FD8.2
00EB2:  BRA    107A
00EB4:  SUBWF  x52,F
00EB6:  BTFSC  FD8.2
00EB8:  BRA    0FC0
00EBA:  BNC   0F38
00EBC:  MOVFF  74F,758
00EC0:  BSF    x58.7
00EC2:  MOVFF  750,757
00EC6:  MOVFF  751,756
00ECA:  CLRF   x55
00ECC:  BCF    FD8.0
00ECE:  RRCF   x58,F
00ED0:  RRCF   x57,F
00ED2:  RRCF   x56,F
00ED4:  RRCF   x55,F
00ED6:  DECFSZ x52,F
00ED8:  BRA    0ECA
00EDA:  BTFSS  x53.7
00EDC:  BRA    0EE4
00EDE:  BSF    x54.0
00EE0:  BRA    10A2
00EE2:  BCF    x54.0
00EE4:  BCF    x52.0
00EE6:  BSF    x54.4
00EE8:  MOVLW  07
00EEA:  MOVWF  FEA
00EEC:  MOVLW  4D
00EEE:  MOVWF  FE9
00EF0:  BRA    10C8
00EF2:  BCF    x54.4
00EF4:  BTFSC  x53.7
00EF6:  BRA    0F0C
00EF8:  BTFSS  x52.0
00EFA:  BRA    0F22
00EFC:  RRCF   x58,F
00EFE:  RRCF   x57,F
00F00:  RRCF   x56,F
00F02:  RRCF   x55,F
00F04:  INCF   00,F
00F06:  BTFSC  FD8.2
00F08:  BRA    1098
00F0A:  BRA    0F22
00F0C:  BTFSC  x58.7
00F0E:  BRA    0F28
00F10:  BCF    FD8.0
00F12:  RLCF   x55,F
00F14:  RLCF   x56,F
00F16:  RLCF   x57,F
00F18:  RLCF   x58,F
00F1A:  DECF   00,F
00F1C:  BTFSC  FD8.2
00F1E:  BRA    1098
00F20:  BRA    0F0C
00F22:  BSF    x54.6
00F24:  BRA    1000
00F26:  BCF    x54.6
00F28:  MOVFF  74B,753
00F2C:  BTFSS  x4B.7
00F2E:  BRA    0F34
00F30:  BSF    x58.7
00F32:  BRA    108A
00F34:  BCF    x58.7
00F36:  BRA    108A
00F38:  MOVFF  74E,752
00F3C:  MOVFF  74E,00
00F40:  MOVF   x4A,W
00F42:  SUBWF  x52,F
00F44:  MOVFF  74B,758
00F48:  BSF    x58.7
00F4A:  MOVFF  74C,757
00F4E:  MOVFF  74D,756
00F52:  CLRF   x55
00F54:  BCF    FD8.0
00F56:  RRCF   x58,F
00F58:  RRCF   x57,F
00F5A:  RRCF   x56,F
00F5C:  RRCF   x55,F
00F5E:  DECFSZ x52,F
00F60:  BRA    0F52
00F62:  BTFSS  x53.7
00F64:  BRA    0F6C
00F66:  BSF    x54.1
00F68:  BRA    10A2
00F6A:  BCF    x54.1
00F6C:  BCF    x52.0
00F6E:  BSF    x54.5
00F70:  MOVLW  07
00F72:  MOVWF  FEA
00F74:  MOVLW  51
00F76:  MOVWF  FE9
00F78:  BRA    10C8
00F7A:  BCF    x54.5
00F7C:  BTFSC  x53.7
00F7E:  BRA    0F94
00F80:  BTFSS  x52.0
00F82:  BRA    0FAA
00F84:  RRCF   x58,F
00F86:  RRCF   x57,F
00F88:  RRCF   x56,F
00F8A:  RRCF   x55,F
00F8C:  INCF   00,F
00F8E:  BTFSC  FD8.2
00F90:  BRA    1098
00F92:  BRA    0FAA
00F94:  BTFSC  x58.7
00F96:  BRA    0FB0
00F98:  BCF    FD8.0
00F9A:  RLCF   x55,F
00F9C:  RLCF   x56,F
00F9E:  RLCF   x57,F
00FA0:  RLCF   x58,F
00FA2:  DECF   00,F
00FA4:  BTFSC  FD8.2
00FA6:  BRA    1098
00FA8:  BRA    0F94
00FAA:  BSF    x54.7
00FAC:  BRA    1000
00FAE:  BCF    x54.7
00FB0:  MOVFF  74F,753
00FB4:  BTFSS  x4F.7
00FB6:  BRA    0FBC
00FB8:  BSF    x58.7
00FBA:  BRA    108A
00FBC:  BCF    x58.7
00FBE:  BRA    108A
00FC0:  MOVFF  74F,758
00FC4:  BSF    x58.7
00FC6:  MOVFF  750,757
00FCA:  MOVFF  751,756
00FCE:  BTFSS  x53.7
00FD0:  BRA    0FDA
00FD2:  BCF    x58.7
00FD4:  BSF    x54.2
00FD6:  BRA    10A2
00FD8:  BCF    x54.2
00FDA:  CLRF   x55
00FDC:  BCF    x52.0
00FDE:  MOVLW  07
00FE0:  MOVWF  FEA
00FE2:  MOVLW  4D
00FE4:  MOVWF  FE9
00FE6:  BRA    10C8
00FE8:  BTFSC  x53.7
00FEA:  BRA    1024
00FEC:  MOVFF  74B,753
00FF0:  BTFSS  x52.0
00FF2:  BRA    1000
00FF4:  RRCF   x58,F
00FF6:  RRCF   x57,F
00FF8:  RRCF   x56,F
00FFA:  RRCF   x55,F
00FFC:  INCF   00,F
00FFE:  BZ    1098
01000:  BTFSS  x55.7
01002:  BRA    101A
01004:  INCF   x56,F
01006:  BNZ   101A
01008:  INCF   x57,F
0100A:  BNZ   101A
0100C:  INCF   x58,F
0100E:  BNZ   101A
01010:  RRCF   x58,F
01012:  RRCF   x57,F
01014:  RRCF   x56,F
01016:  INCF   00,F
01018:  BZ    1098
0101A:  BTFSC  x54.6
0101C:  BRA    0F26
0101E:  BTFSC  x54.7
01020:  BRA    0FAE
01022:  BRA    105C
01024:  MOVLW  80
01026:  XORWF  x58,F
01028:  BTFSS  x58.7
0102A:  BRA    1034
0102C:  BRA    10A2
0102E:  MOVFF  74F,753
01032:  BRA    1048
01034:  MOVFF  74B,753
01038:  MOVF   x58,F
0103A:  BNZ   1048
0103C:  MOVF   x57,F
0103E:  BNZ   1048
01040:  MOVF   x56,F
01042:  BNZ   1048
01044:  CLRF   00
01046:  BRA    108A
01048:  BTFSC  x58.7
0104A:  BRA    105C
0104C:  BCF    FD8.0
0104E:  RLCF   x55,F
01050:  RLCF   x56,F
01052:  RLCF   x57,F
01054:  RLCF   x58,F
01056:  DECFSZ 00,F
01058:  BRA    1048
0105A:  BRA    1098
0105C:  BTFSS  x53.7
0105E:  BRA    1064
01060:  BSF    x58.7
01062:  BRA    108A
01064:  BCF    x58.7
01066:  BRA    108A
01068:  MOVFF  74E,00
0106C:  MOVFF  74F,758
01070:  MOVFF  750,757
01074:  MOVFF  751,756
01078:  BRA    108A
0107A:  MOVFF  74A,00
0107E:  MOVFF  74B,758
01082:  MOVFF  74C,757
01086:  MOVFF  74D,756
0108A:  MOVFF  758,01
0108E:  MOVFF  757,02
01092:  MOVFF  756,03
01096:  BRA    1100
01098:  CLRF   00
0109A:  CLRF   01
0109C:  CLRF   02
0109E:  CLRF   03
010A0:  BRA    1100
010A2:  CLRF   x55
010A4:  COMF   x56,F
010A6:  COMF   x57,F
010A8:  COMF   x58,F
010AA:  COMF   x55,F
010AC:  INCF   x55,F
010AE:  BNZ   10BA
010B0:  INCF   x56,F
010B2:  BNZ   10BA
010B4:  INCF   x57,F
010B6:  BNZ   10BA
010B8:  INCF   x58,F
010BA:  BTFSC  x54.0
010BC:  BRA    0EE2
010BE:  BTFSC  x54.1
010C0:  BRA    0F6A
010C2:  BTFSC  x54.2
010C4:  BRA    0FD8
010C6:  BRA    102E
010C8:  MOVF   FEF,W
010CA:  ADDWF  x56,F
010CC:  BNC   10D8
010CE:  INCF   x57,F
010D0:  BNZ   10D8
010D2:  INCF   x58,F
010D4:  BTFSC  FD8.2
010D6:  BSF    x52.0
010D8:  MOVF   FED,F
010DA:  MOVF   FEF,W
010DC:  ADDWF  x57,F
010DE:  BNC   10E6
010E0:  INCF   x58,F
010E2:  BTFSC  FD8.2
010E4:  BSF    x52.0
010E6:  MOVF   FED,F
010E8:  MOVF   FEF,W
010EA:  BTFSC  FEF.7
010EC:  BRA    10F0
010EE:  XORLW  80
010F0:  ADDWF  x58,F
010F2:  BTFSC  FD8.0
010F4:  BSF    x52.0
010F6:  BTFSC  x54.4
010F8:  BRA    0EF2
010FA:  BTFSC  x54.5
010FC:  BRA    0F7A
010FE:  BRA    0FE8
01100:  MOVLB  0
01102:  RETURN 0
*
0165A:  ADDWF  FE8,W
0165C:  CLRF   FF7
0165E:  RLCF   FF7,F
01660:  ADDLW  75
01662:  MOVWF  FF6
01664:  MOVLW  16
01666:  ADDWFC FF7,F
01668:  TBLRD*-
0166A:  MOVF   FF5,W
0166C:  MOVWF  FFA
0166E:  TBLRD*
01670:  MOVF   FF5,W
01672:  MOVWF  FF9
01674:  DATA 1C,11
01676:  DATA DC,11
01678:  DATA 9C,12
0167A:  DATA 5C,13
0167C:  DATA 1C,14
0167E:  DATA DC,14
01680:  DATA 9C,15
01682:  BTFSC  FD8.1
01684:  BRA    168E
01686:  MOVLW  07
01688:  MOVWF  FEA
0168A:  MOVLW  39
0168C:  MOVWF  FE9
0168E:  MOVLB  7
01690:  MOVF   x34,W
01692:  XORWF  x38,W
01694:  ANDLW  80
01696:  MOVWF  x3E
01698:  BTFSS  x34.7
0169A:  BRA    16B2
0169C:  COMF   x31,F
0169E:  COMF   x32,F
016A0:  COMF   x33,F
016A2:  COMF   x34,F
016A4:  INCF   x31,F
016A6:  BTFSC  FD8.2
016A8:  INCF   x32,F
016AA:  BTFSC  FD8.2
016AC:  INCF   x33,F
016AE:  BTFSC  FD8.2
016B0:  INCF   x34,F
016B2:  BTFSS  x38.7
016B4:  BRA    16CC
016B6:  COMF   x35,F
016B8:  COMF   x36,F
016BA:  COMF   x37,F
016BC:  COMF   x38,F
016BE:  INCF   x35,F
016C0:  BTFSC  FD8.2
016C2:  INCF   x36,F
016C4:  BTFSC  FD8.2
016C6:  INCF   x37,F
016C8:  BTFSC  FD8.2
016CA:  INCF   x38,F
016CC:  CLRF   00
016CE:  CLRF   01
016D0:  CLRF   02
016D2:  CLRF   03
016D4:  CLRF   x39
016D6:  CLRF   x3A
016D8:  CLRF   x3B
016DA:  CLRF   x3C
016DC:  MOVF   x38,W
016DE:  IORWF  x37,W
016E0:  IORWF  x36,W
016E2:  IORWF  x35,W
016E4:  BZ    173E
016E6:  MOVLW  20
016E8:  MOVWF  x3D
016EA:  BCF    FD8.0
016EC:  RLCF   x31,F
016EE:  RLCF   x32,F
016F0:  RLCF   x33,F
016F2:  RLCF   x34,F
016F4:  RLCF   x39,F
016F6:  RLCF   x3A,F
016F8:  RLCF   x3B,F
016FA:  RLCF   x3C,F
016FC:  MOVF   x38,W
016FE:  SUBWF  x3C,W
01700:  BNZ   1712
01702:  MOVF   x37,W
01704:  SUBWF  x3B,W
01706:  BNZ   1712
01708:  MOVF   x36,W
0170A:  SUBWF  x3A,W
0170C:  BNZ   1712
0170E:  MOVF   x35,W
01710:  SUBWF  x39,W
01712:  BNC   1732
01714:  MOVF   x35,W
01716:  SUBWF  x39,F
01718:  MOVF   x36,W
0171A:  BTFSS  FD8.0
0171C:  INCFSZ x36,W
0171E:  SUBWF  x3A,F
01720:  MOVF   x37,W
01722:  BTFSS  FD8.0
01724:  INCFSZ x37,W
01726:  SUBWF  x3B,F
01728:  MOVF   x38,W
0172A:  BTFSS  FD8.0
0172C:  INCFSZ x38,W
0172E:  SUBWF  x3C,F
01730:  BSF    FD8.0
01732:  RLCF   00,F
01734:  RLCF   01,F
01736:  RLCF   02,F
01738:  RLCF   03,F
0173A:  DECFSZ x3D,F
0173C:  BRA    16EA
0173E:  BTFSS  x3E.7
01740:  BRA    1758
01742:  COMF   00,F
01744:  COMF   01,F
01746:  COMF   02,F
01748:  COMF   03,F
0174A:  INCF   00,F
0174C:  BTFSC  FD8.2
0174E:  INCF   01,F
01750:  BTFSC  FD8.2
01752:  INCF   02,F
01754:  BTFSC  FD8.2
01756:  INCF   03,F
01758:  MOVFF  739,FEF
0175C:  MOVFF  73A,FEC
01760:  MOVFF  73B,FEC
01764:  MOVFF  73C,FEC
01768:  MOVLB  0
0176A:  RETURN 0
*
01CC8:  MOVLW  B6
01CCA:  MOVWF  00
01CCC:  CLRF   03
01CCE:  CLRF   02
01CD0:  CLRF   01
01CD2:  MOVLB  7
01CD4:  BCF    x14.0
01CD6:  BTFSS  x13.7
01CD8:  BRA    1CF2
01CDA:  BSF    x14.0
01CDC:  COMF   x10,F
01CDE:  COMF   x11,F
01CE0:  COMF   x12,F
01CE2:  COMF   x13,F
01CE4:  INCF   x10,F
01CE6:  BNZ   1CF2
01CE8:  INCF   x11,F
01CEA:  BNZ   1CF2
01CEC:  INCF   x12,F
01CEE:  BTFSC  FD8.2
01CF0:  INCF   x13,F
01CF2:  MOVF   x10,W
01CF4:  IORWF  x11,W
01CF6:  IORWF  x12,W
01CF8:  IORWF  x13,W
01CFA:  BNZ   1D00
01CFC:  CLRF   00
01CFE:  BRA    1D1E
01D00:  BCF    FD8.0
01D02:  BTFSC  01.7
01D04:  BRA    1D18
01D06:  RLCF   x10,F
01D08:  RLCF   x11,F
01D0A:  RLCF   x12,F
01D0C:  RLCF   x13,F
01D0E:  RLCF   03,F
01D10:  RLCF   02,F
01D12:  RLCF   01,F
01D14:  DECFSZ 00,F
01D16:  BRA    1D00
01D18:  BCF    01.7
01D1A:  BTFSC  x14.0
01D1C:  BSF    01.7
01D1E:  MOVLB  0
01D20:  RETURN 0
01D22:  MOVFF  747,74E
01D26:  MOVLB  7
01D28:  MOVF   x4B,W
01D2A:  XORWF  x4E,F
01D2C:  BTFSS  x4E.7
01D2E:  BRA    1D3A
01D30:  BCF    FD8.2
01D32:  BCF    FD8.0
01D34:  BTFSC  x47.7
01D36:  BSF    FD8.0
01D38:  BRA    1D98
01D3A:  MOVFF  747,74E
01D3E:  MOVFF  74A,74F
01D42:  MOVF   x46,W
01D44:  SUBWF  x4F,F
01D46:  BZ    1D54
01D48:  BTFSS  x4E.7
01D4A:  BRA    1D98
01D4C:  MOVF   FD8,W
01D4E:  XORLW  01
01D50:  MOVWF  FD8
01D52:  BRA    1D98
01D54:  MOVFF  74B,74F
01D58:  MOVF   x47,W
01D5A:  SUBWF  x4F,F
01D5C:  BZ    1D6A
01D5E:  BTFSS  x4E.7
01D60:  BRA    1D98
01D62:  MOVF   FD8,W
01D64:  XORLW  01
01D66:  MOVWF  FD8
01D68:  BRA    1D98
01D6A:  MOVFF  74C,74F
01D6E:  MOVF   x48,W
01D70:  SUBWF  x4F,F
01D72:  BZ    1D80
01D74:  BTFSS  x4E.7
01D76:  BRA    1D98
01D78:  MOVF   FD8,W
01D7A:  XORLW  01
01D7C:  MOVWF  FD8
01D7E:  BRA    1D98
01D80:  MOVFF  74D,74F
01D84:  MOVF   x49,W
01D86:  SUBWF  x4F,F
01D88:  BZ    1D96
01D8A:  BTFSS  x4E.7
01D8C:  BRA    1D98
01D8E:  MOVF   FD8,W
01D90:  XORLW  01
01D92:  MOVWF  FD8
01D94:  BRA    1D98
01D96:  BCF    FD8.0
01D98:  MOVLB  0
01D9A:  RETURN 0
01D9C:  MOVLB  7
01D9E:  MOVF   x3F,W
01DA0:  BTFSC  FD8.2
01DA2:  BRA    1EEE
01DA4:  MOVWF  x4B
01DA6:  MOVF   x43,W
01DA8:  BTFSC  FD8.2
01DAA:  BRA    1EEE
01DAC:  SUBWF  x4B,F
01DAE:  BNC   1DBA
01DB0:  MOVLW  7F
01DB2:  ADDWF  x4B,F
01DB4:  BTFSC  FD8.0
01DB6:  BRA    1EEE
01DB8:  BRA    1DC6
01DBA:  MOVLW  81
01DBC:  SUBWF  x4B,F
01DBE:  BTFSS  FD8.0
01DC0:  BRA    1EEE
01DC2:  BTFSC  FD8.2
01DC4:  BRA    1EEE
01DC6:  MOVFF  74B,00
01DCA:  CLRF   01
01DCC:  CLRF   02
01DCE:  CLRF   03
01DD0:  CLRF   x4A
01DD2:  MOVFF  740,749
01DD6:  BSF    x49.7
01DD8:  MOVFF  741,748
01DDC:  MOVFF  742,747
01DE0:  MOVLW  19
01DE2:  MOVWF  x4B
01DE4:  MOVF   x46,W
01DE6:  SUBWF  x47,F
01DE8:  BC    1E04
01DEA:  MOVLW  01
01DEC:  SUBWF  x48,F
01DEE:  BC    1E04
01DF0:  SUBWF  x49,F
01DF2:  BC    1E04
01DF4:  SUBWF  x4A,F
01DF6:  BC    1E04
01DF8:  INCF   x4A,F
01DFA:  INCF   x49,F
01DFC:  INCF   x48,F
01DFE:  MOVF   x46,W
01E00:  ADDWF  x47,F
01E02:  BRA    1E54
01E04:  MOVF   x45,W
01E06:  SUBWF  x48,F
01E08:  BC    1E2E
01E0A:  MOVLW  01
01E0C:  SUBWF  x49,F
01E0E:  BC    1E2E
01E10:  SUBWF  x4A,F
01E12:  BC    1E2E
01E14:  INCF   x4A,F
01E16:  INCF   x49,F
01E18:  MOVF   x45,W
01E1A:  ADDWF  x48,F
01E1C:  MOVF   x46,W
01E1E:  ADDWF  x47,F
01E20:  BNC   1E54
01E22:  INCF   x48,F
01E24:  BNZ   1E54
01E26:  INCF   x49,F
01E28:  BNZ   1E54
01E2A:  INCF   x4A,F
01E2C:  BRA    1E54
01E2E:  MOVF   x44,W
01E30:  IORLW  80
01E32:  SUBWF  x49,F
01E34:  BC    1E52
01E36:  MOVLW  01
01E38:  SUBWF  x4A,F
01E3A:  BC    1E52
01E3C:  INCF   x4A,F
01E3E:  MOVF   x44,W
01E40:  IORLW  80
01E42:  ADDWF  x49,F
01E44:  MOVF   x45,W
01E46:  ADDWF  x48,F
01E48:  BNC   1E1C
01E4A:  INCF   x49,F
01E4C:  BNZ   1E1C
01E4E:  INCF   x4A,F
01E50:  BRA    1E1C
01E52:  BSF    03.0
01E54:  DECFSZ x4B,F
01E56:  BRA    1E5A
01E58:  BRA    1E70
01E5A:  BCF    FD8.0
01E5C:  RLCF   x47,F
01E5E:  RLCF   x48,F
01E60:  RLCF   x49,F
01E62:  RLCF   x4A,F
01E64:  BCF    FD8.0
01E66:  RLCF   03,F
01E68:  RLCF   02,F
01E6A:  RLCF   01,F
01E6C:  RLCF   x4C,F
01E6E:  BRA    1DE4
01E70:  BTFSS  x4C.0
01E72:  BRA    1E80
01E74:  BCF    FD8.0
01E76:  RRCF   01,F
01E78:  RRCF   02,F
01E7A:  RRCF   03,F
01E7C:  RRCF   x4C,F
01E7E:  BRA    1E84
01E80:  DECF   00,F
01E82:  BZ    1EEE
01E84:  BTFSC  x4C.7
01E86:  BRA    1EC4
01E88:  BCF    FD8.0
01E8A:  RLCF   x47,F
01E8C:  RLCF   x48,F
01E8E:  RLCF   x49,F
01E90:  RLCF   x4A,F
01E92:  MOVF   x46,W
01E94:  SUBWF  x47,F
01E96:  BC    1EA6
01E98:  MOVLW  01
01E9A:  SUBWF  x48,F
01E9C:  BC    1EA6
01E9E:  SUBWF  x49,F
01EA0:  BC    1EA6
01EA2:  SUBWF  x4A,F
01EA4:  BNC   1EDA
01EA6:  MOVF   x45,W
01EA8:  SUBWF  x48,F
01EAA:  BC    1EB6
01EAC:  MOVLW  01
01EAE:  SUBWF  x49,F
01EB0:  BC    1EB6
01EB2:  SUBWF  x4A,F
01EB4:  BNC   1EDA
01EB6:  MOVF   x44,W
01EB8:  IORLW  80
01EBA:  SUBWF  x49,F
01EBC:  BC    1EC4
01EBE:  MOVLW  01
01EC0:  SUBWF  x4A,F
01EC2:  BNC   1EDA
01EC4:  INCF   03,F
01EC6:  BNZ   1EDA
01EC8:  INCF   02,F
01ECA:  BNZ   1EDA
01ECC:  INCF   01,F
01ECE:  BNZ   1EDA
01ED0:  INCF   00,F
01ED2:  BZ    1EEE
01ED4:  RRCF   01,F
01ED6:  RRCF   02,F
01ED8:  RRCF   03,F
01EDA:  MOVFF  740,74B
01EDE:  MOVF   x44,W
01EE0:  XORWF  x4B,F
01EE2:  BTFSS  x4B.7
01EE4:  BRA    1EEA
01EE6:  BSF    01.7
01EE8:  BRA    1EF6
01EEA:  BCF    01.7
01EEC:  BRA    1EF6
01EEE:  CLRF   00
01EF0:  CLRF   01
01EF2:  CLRF   02
01EF4:  CLRF   03
01EF6:  MOVLB  0
01EF8:  RETURN 0
*
026A4:  ADDWF  FE8,W
026A6:  CLRF   FF7
026A8:  RLCF   FF7,F
026AA:  ADDLW  BF
026AC:  MOVWF  FF6
026AE:  MOVLW  26
026B0:  ADDWFC FF7,F
026B2:  TBLRD*-
026B4:  MOVF   FF5,W
026B6:  MOVWF  FFA
026B8:  TBLRD*
026BA:  MOVF   FF5,W
026BC:  MOVWF  FF9
026BE:  DATA AC,25
026C0:  DATA C6,25
026C2:  DATA 1A,26
026C4:  DATA 7E,26
026C6:  MOVLW  8E
026C8:  MOVWF  00
026CA:  MOVFF  73D,01
026CE:  MOVFF  73C,02
026D2:  CLRF   03
026D4:  BTFSS  01.7
026D6:  BRA    26E2
026D8:  COMF   01,F
026DA:  COMF   02,F
026DC:  INCF   02,F
026DE:  BNZ   26E2
026E0:  INCF   01,F
026E2:  MOVF   01,F
026E4:  BNZ   26F8
026E6:  MOVFF  02,01
026EA:  CLRF   02
026EC:  MOVLW  08
026EE:  SUBWF  00,F
026F0:  MOVF   01,F
026F2:  BNZ   26F8
026F4:  CLRF   00
026F6:  BRA    2714
026F8:  BCF    FD8.0
026FA:  BTFSC  01.7
026FC:  BRA    2706
026FE:  RLCF   02,F
02700:  RLCF   01,F
02702:  DECF   00,F
02704:  BRA    26F8
02706:  MOVLB  7
02708:  BTFSS  x3D.7
0270A:  BRA    2710
0270C:  MOVLB  0
0270E:  BRA    2714
02710:  BCF    01.7
02712:  MOVLB  0
02714:  RETURN 0
02716:  MOVLW  8E
02718:  MOVWF  00
0271A:  MOVLB  7
0271C:  MOVF   x46,W
0271E:  SUBWF  00,F
02720:  MOVFF  747,02
02724:  MOVFF  748,01
02728:  BSF    02.7
0272A:  MOVF   00,F
0272C:  BZ    2740
0272E:  BCF    FD8.0
02730:  MOVF   02,F
02732:  BNZ   2738
02734:  MOVF   01,F
02736:  BZ    2740
02738:  RRCF   02,F
0273A:  RRCF   01,F
0273C:  DECFSZ 00,F
0273E:  BRA    272E
02740:  BTFSS  x47.7
02742:  BRA    274E
02744:  COMF   01,F
02746:  COMF   02,F
02748:  INCF   01,F
0274A:  BTFSC  FD8.2
0274C:  INCF   02,F
0274E:  MOVLB  0
02750:  RETURN 0
*
0460A:  MOVLB  7
0460C:  MOVF   x0D,W
0460E:  ANDLW  07
04610:  MOVWF  00
04612:  RRCF   x0D,W
04614:  MOVWF  01
04616:  RRCF   01,F
04618:  RRCF   01,F
0461A:  MOVLW  1F
0461C:  ANDWF  01,F
0461E:  MOVF   01,W
04620:  ADDWF  x0E,W
04622:  MOVWF  FE9
04624:  MOVLW  00
04626:  ADDWFC x0F,W
04628:  MOVWF  FEA
0462A:  MOVFF  FEF,01
0462E:  INCF   00,F
04630:  BRA    4634
04632:  RRCF   01,F
04634:  DECFSZ 00,F
04636:  BRA    4632
04638:  MOVLW  01
0463A:  ANDWF  01,F
0463C:  MOVLB  0
0463E:  RETURN 0
*
0504C:  MOVF   FEF,F
0504E:  BZ    5074
05050:  MOVFF  FEA,704
05054:  MOVFF  FE9,703
05058:  MOVF   FEF,W
0505A:  MOVLB  E
0505C:  BTFSS  xC8.4
0505E:  BRA    505C
05060:  MOVWF  F99
05062:  MOVFF  704,FEA
05066:  MOVFF  703,FE9
0506A:  INCF   FE9,F
0506C:  BTFSC  FD8.2
0506E:  INCF   FEA,F
05070:  MOVLB  0
05072:  BRA    504C
05074:  RETURN 0
*
055C6:  MOVFF  565,FEA
055CA:  MOVFF  564,FE9
055CE:  MOVFF  750,FEF
055D2:  INCF   FE9,F
055D4:  BTFSC  FD8.2
055D6:  INCF   FEA,F
055D8:  CLRF   FEF
055DA:  MOVLB  5
055DC:  INCF   x64,F
055DE:  BTFSC  FD8.2
055E0:  INCF   x65,F
055E2:  MOVLB  0
055E4:  RETURN 0
055E6:  TBLRD*+
055E8:  MOVFF  FF6,710
055EC:  MOVFF  FF7,711
055F0:  MOVFF  FF5,750
055F4:  RCALL  55C6
055F6:  MOVFF  710,FF6
055FA:  MOVFF  711,FF7
055FE:  MOVLB  7
05600:  DECFSZ x0F,F
05602:  BRA    5606
05604:  BRA    560A
05606:  MOVLB  0
05608:  BRA    55E6
0560A:  MOVLB  0
0560C:  RETURN 0
0560E:  MOVF   01,W
05610:  MOVFF  706,73A
05614:  MOVLW  64
05616:  MOVLB  7
05618:  MOVWF  x3B
0561A:  MOVLB  0
0561C:  CALL   08CE
05620:  MOVFF  00,706
05624:  MOVF   01,W
05626:  MOVLW  30
05628:  BNZ   563A
0562A:  MOVLB  7
0562C:  BTFSS  x07.1
0562E:  BRA    564E
05630:  BTFSC  x07.3
05632:  BRA    564E
05634:  BTFSC  x07.4
05636:  MOVLW  20
05638:  BRA    5642
0563A:  MOVLB  7
0563C:  BCF    x07.3
0563E:  BCF    x07.4
05640:  BSF    x07.0
05642:  ADDWF  01,F
05644:  MOVFF  01,750
05648:  MOVLB  0
0564A:  RCALL  55C6
0564C:  MOVLB  7
0564E:  MOVFF  706,73A
05652:  MOVLW  0A
05654:  MOVWF  x3B
05656:  MOVLB  0
05658:  CALL   08CE
0565C:  MOVFF  00,706
05660:  MOVF   01,W
05662:  MOVLW  30
05664:  BNZ   5676
05666:  MOVLB  7
05668:  BTFSC  x07.3
0566A:  BRA    5680
0566C:  BTFSS  x07.0
0566E:  BRA    5680
05670:  BTFSC  x07.4
05672:  MOVLW  20
05674:  MOVLB  0
05676:  ADDWF  01,F
05678:  MOVFF  01,750
0567C:  RCALL  55C6
0567E:  MOVLB  7
05680:  MOVLW  30
05682:  ADDWF  x06,F
05684:  MOVFF  706,750
05688:  MOVLB  0
0568A:  RCALL  55C6
0568C:  RETURN 0
0568E:  MOVLB  7
05690:  MOVF   x50,W
05692:  SUBLW  B6
05694:  MOVWF  x50
05696:  CLRF   03
05698:  MOVFF  751,754
0569C:  BSF    x51.7
0569E:  BCF    FD8.0
056A0:  RRCF   x51,F
056A2:  RRCF   x52,F
056A4:  RRCF   x53,F
056A6:  RRCF   03,F
056A8:  RRCF   02,F
056AA:  RRCF   01,F
056AC:  RRCF   00,F
056AE:  DECFSZ x50,F
056B0:  BRA    569E
056B2:  BTFSS  x54.7
056B4:  BRA    56CC
056B6:  COMF   00,F
056B8:  COMF   01,F
056BA:  COMF   02,F
056BC:  COMF   03,F
056BE:  INCF   00,F
056C0:  BTFSC  FD8.2
056C2:  INCF   01,F
056C4:  BTFSC  FD8.2
056C6:  INCF   02,F
056C8:  BTFSC  FD8.2
056CA:  INCF   03,F
056CC:  MOVLB  0
056CE:  RETURN 0
056D0:  BTFSC  FD8.1
056D2:  BRA    56DC
056D4:  MOVLW  07
056D6:  MOVWF  FEA
056D8:  MOVLW  58
056DA:  MOVWF  FE9
056DC:  CLRF   00
056DE:  CLRF   01
056E0:  CLRF   02
056E2:  CLRF   03
056E4:  MOVLB  7
056E6:  CLRF   x58
056E8:  CLRF   x59
056EA:  CLRF   x5A
056EC:  CLRF   x5B
056EE:  MOVF   x57,W
056F0:  IORWF  x56,W
056F2:  IORWF  x55,W
056F4:  IORWF  x54,W
056F6:  BZ    5750
056F8:  MOVLW  20
056FA:  MOVWF  x5C
056FC:  BCF    FD8.0
056FE:  RLCF   x50,F
05700:  RLCF   x51,F
05702:  RLCF   x52,F
05704:  RLCF   x53,F
05706:  RLCF   x58,F
05708:  RLCF   x59,F
0570A:  RLCF   x5A,F
0570C:  RLCF   x5B,F
0570E:  MOVF   x57,W
05710:  SUBWF  x5B,W
05712:  BNZ   5724
05714:  MOVF   x56,W
05716:  SUBWF  x5A,W
05718:  BNZ   5724
0571A:  MOVF   x55,W
0571C:  SUBWF  x59,W
0571E:  BNZ   5724
05720:  MOVF   x54,W
05722:  SUBWF  x58,W
05724:  BNC   5744
05726:  MOVF   x54,W
05728:  SUBWF  x58,F
0572A:  MOVF   x55,W
0572C:  BTFSS  FD8.0
0572E:  INCFSZ x55,W
05730:  SUBWF  x59,F
05732:  MOVF   x56,W
05734:  BTFSS  FD8.0
05736:  INCFSZ x56,W
05738:  SUBWF  x5A,F
0573A:  MOVF   x57,W
0573C:  BTFSS  FD8.0
0573E:  INCFSZ x57,W
05740:  SUBWF  x5B,F
05742:  BSF    FD8.0
05744:  RLCF   00,F
05746:  RLCF   01,F
05748:  RLCF   02,F
0574A:  RLCF   03,F
0574C:  DECFSZ x5C,F
0574E:  BRA    56FC
05750:  MOVFF  758,FEF
05754:  MOVFF  759,FEC
05758:  MOVFF  75A,FEC
0575C:  MOVFF  75B,FEC
05760:  MOVLB  0
05762:  RETURN 0
05764:  MOVF   FE9,W
05766:  MOVLB  7
05768:  MOVWF  x48
0576A:  MOVF   x47,W
0576C:  MOVWF  x4A
0576E:  BZ    57A8
05770:  MOVFF  746,753
05774:  MOVFF  745,752
05778:  MOVFF  744,751
0577C:  MOVFF  743,750
05780:  CLRF   x57
05782:  CLRF   x56
05784:  MOVLW  20
05786:  MOVWF  x55
05788:  MOVLW  82
0578A:  MOVWF  x54
0578C:  MOVLB  0
0578E:  CALL   0D96
05792:  MOVFF  03,746
05796:  MOVFF  02,745
0579A:  MOVFF  01,744
0579E:  MOVFF  00,743
057A2:  MOVLB  7
057A4:  DECFSZ x4A,F
057A6:  BRA    5770
057A8:  MOVFF  746,753
057AC:  MOVFF  745,752
057B0:  MOVFF  744,751
057B4:  MOVFF  743,750
057B8:  MOVLB  0
057BA:  RCALL  568E
057BC:  MOVFF  03,746
057C0:  MOVFF  02,745
057C4:  MOVFF  01,744
057C8:  MOVFF  00,743
057CC:  MOVLB  7
057CE:  BTFSS  x46.7
057D0:  BRA    57EC
057D2:  DECF   x48,F
057D4:  BSF    x48.5
057D6:  COMF   x43,F
057D8:  COMF   x44,F
057DA:  COMF   x45,F
057DC:  COMF   x46,F
057DE:  INCF   x43,F
057E0:  BTFSC  FD8.2
057E2:  INCF   x44,F
057E4:  BTFSC  FD8.2
057E6:  INCF   x45,F
057E8:  BTFSC  FD8.2
057EA:  INCF   x46,F
057EC:  MOVLW  3B
057EE:  MOVWF  x4F
057F0:  MOVLW  9A
057F2:  MOVWF  x4E
057F4:  MOVLW  CA
057F6:  MOVWF  x4D
057F8:  CLRF   x4C
057FA:  MOVLW  0A
057FC:  MOVWF  x4A
057FE:  MOVF   x47,W
05800:  BTFSC  FD8.2
05802:  INCF   x48,F
05804:  BSF    FD8.1
05806:  MOVLW  07
05808:  MOVWF  FEA
0580A:  MOVLW  43
0580C:  MOVWF  FE9
0580E:  MOVFF  746,753
05812:  MOVFF  745,752
05816:  MOVFF  744,751
0581A:  MOVFF  743,750
0581E:  MOVFF  74F,757
05822:  MOVFF  74E,756
05826:  MOVFF  74D,755
0582A:  MOVFF  74C,754
0582E:  MOVLB  0
05830:  RCALL  56D0
05832:  MOVF   01,W
05834:  MOVF   00,F
05836:  BNZ   585E
05838:  MOVLB  7
0583A:  INCF   x47,W
0583C:  SUBWF  x4A,W
0583E:  BTFSS  FD8.2
05840:  BRA    5846
05842:  MOVLB  0
05844:  BRA    585E
05846:  MOVF   x48,W
05848:  BZ    5864
0584A:  ANDLW  0F
0584C:  SUBWF  x4A,W
0584E:  BZ    5852
05850:  BC    58D2
05852:  BTFSC  x48.7
05854:  BRA    58D2
05856:  BTFSC  x48.6
05858:  BRA    5864
0585A:  MOVLW  20
0585C:  BRA    58C6
0585E:  MOVLW  20
05860:  MOVLB  7
05862:  ANDWF  x48,F
05864:  BTFSS  x48.5
05866:  BRA    5884
05868:  BCF    x48.5
0586A:  MOVF   x47,W
0586C:  BTFSS  FD8.2
0586E:  DECF   x48,F
05870:  MOVF   00,W
05872:  MOVWF  x48
05874:  MOVLW  2D
05876:  MOVWF  x50
05878:  MOVLB  0
0587A:  RCALL  55C6
0587C:  MOVLB  7
0587E:  MOVF   x48,W
05880:  MOVWF  00
05882:  CLRF   x48
05884:  MOVF   x47,W
05886:  SUBWF  x4A,W
05888:  BNZ   58A2
0588A:  MOVF   00,W
0588C:  MOVWF  x48
0588E:  MOVLW  2E
05890:  MOVWF  x50
05892:  MOVLB  0
05894:  RCALL  55C6
05896:  MOVLB  7
05898:  MOVF   x48,W
0589A:  MOVWF  00
0589C:  MOVLW  20
0589E:  ANDWF  x48,F
058A0:  MOVLW  00
058A2:  MOVLW  30
058A4:  BTFSS  x48.5
058A6:  BRA    58C6
058A8:  BCF    x48.5
058AA:  MOVF   x47,W
058AC:  BTFSS  FD8.2
058AE:  DECF   x48,F
058B0:  MOVF   00,W
058B2:  MOVWF  x48
058B4:  MOVLW  2D
058B6:  MOVWF  x50
058B8:  MOVLB  0
058BA:  RCALL  55C6
058BC:  MOVLB  7
058BE:  MOVF   x48,W
058C0:  MOVWF  00
058C2:  CLRF   x48
058C4:  MOVLW  30
058C6:  ADDWF  00,F
058C8:  MOVFF  00,750
058CC:  MOVLB  0
058CE:  RCALL  55C6
058D0:  MOVLB  7
058D2:  BCF    FD8.1
058D4:  MOVFF  74F,753
058D8:  MOVFF  74E,752
058DC:  MOVFF  74D,751
058E0:  MOVFF  74C,750
058E4:  CLRF   x57
058E6:  CLRF   x56
058E8:  CLRF   x55
058EA:  MOVLW  0A
058EC:  MOVWF  x54
058EE:  MOVLB  0
058F0:  RCALL  56D0
058F2:  MOVFF  03,74F
058F6:  MOVFF  02,74E
058FA:  MOVFF  01,74D
058FE:  MOVFF  00,74C
05902:  MOVLB  7
05904:  DECFSZ x4A,F
05906:  BRA    5804
05908:  MOVLB  0
0590A:  RETURN 0
0590C:  MOVFF  FEA,708
05910:  MOVFF  FE9,707
05914:  MOVLB  7
05916:  SWAPF  x01,W
05918:  IORLW  F0
0591A:  MOVWF  x03
0591C:  ADDWF  x03,F
0591E:  ADDLW  E2
05920:  MOVWF  x04
05922:  ADDLW  32
05924:  MOVWF  x06
05926:  MOVF   x01,W
05928:  ANDLW  0F
0592A:  ADDWF  x04,F
0592C:  ADDWF  x04,F
0592E:  ADDWF  x06,F
05930:  ADDLW  E9
05932:  MOVWF  x05
05934:  ADDWF  x05,F
05936:  ADDWF  x05,F
05938:  SWAPF  x00,W
0593A:  ANDLW  0F
0593C:  ADDWF  x05,F
0593E:  ADDWF  x06,F
05940:  RLCF   x05,F
05942:  RLCF   x06,F
05944:  COMF   x06,F
05946:  RLCF   x06,F
05948:  MOVF   x00,W
0594A:  ANDLW  0F
0594C:  ADDWF  x06,F
0594E:  RLCF   x03,F
05950:  MOVLW  07
05952:  MOVWF  x02
05954:  MOVLW  0A
05956:  DECF   x05,F
05958:  ADDWF  x06,F
0595A:  BNC   5956
0595C:  DECF   x04,F
0595E:  ADDWF  x05,F
05960:  BNC   595C
05962:  DECF   x03,F
05964:  ADDWF  x04,F
05966:  BNC   5962
05968:  DECF   x02,F
0596A:  ADDWF  x03,F
0596C:  BNC   5968
0596E:  MOVLW  07
05970:  MOVWF  FEA
05972:  MOVLW  02
05974:  MOVWF  FE9
05976:  MOVLW  07
05978:  ANDWF  x07,W
0597A:  BCF    x07.6
0597C:  ADDWF  FE9,F
0597E:  MOVLW  00
05980:  ADDWFC FEA,F
05982:  MOVF   FE9,W
05984:  SUBLW  06
05986:  BNZ   5990
05988:  MOVF   FEA,W
0598A:  SUBLW  07
0598C:  BNZ   5990
0598E:  BSF    x07.6
05990:  MOVF   FEF,W
05992:  MOVWF  00
05994:  BNZ   59A6
05996:  BTFSC  x07.6
05998:  BRA    59A6
0599A:  BTFSC  x07.4
0599C:  BRA    59C8
0599E:  BTFSC  x07.3
059A0:  BRA    59A6
059A2:  MOVLW  20
059A4:  BRA    59AC
059A6:  BSF    x07.3
059A8:  BCF    x07.4
059AA:  MOVLW  30
059AC:  ADDWF  00,F
059AE:  MOVFF  FEA,701
059B2:  MOVFF  FE9,700
059B6:  MOVFF  00,750
059BA:  MOVLB  0
059BC:  RCALL  55C6
059BE:  MOVFF  701,FEA
059C2:  MOVFF  700,FE9
059C6:  MOVLB  7
059C8:  MOVF   FEE,W
059CA:  BTFSS  x07.6
059CC:  BRA    5982
059CE:  MOVLB  0
059D0:  RETURN 0
*
05A24:  MOVF   FEF,F
05A26:  BZ    5A46
05A28:  MOVFF  FEA,6FC
05A2C:  MOVFF  FE9,6FB
05A30:  MOVFF  FEF,6FD
05A34:  RCALL  59D2
05A36:  MOVFF  6FC,FEA
05A3A:  MOVFF  6FB,FE9
05A3E:  INCF   FE9,F
05A40:  BTFSC  FD8.2
05A42:  INCF   FEA,F
05A44:  BRA    5A24
05A46:  GOTO   AADC (RETURN)
*
05AA4:  MOVF   FEF,F
05AA6:  BZ    5AC6
05AA8:  MOVFF  FEA,708
05AAC:  MOVFF  FE9,707
05AB0:  MOVFF  FEF,750
05AB4:  RCALL  55C6
05AB6:  MOVFF  708,FEA
05ABA:  MOVFF  707,FE9
05ABE:  INCF   FE9,F
05AC0:  BTFSC  FD8.2
05AC2:  INCF   FEA,F
05AC4:  BRA    5AA4
05AC6:  RETURN 0
*
05B7A:  TBLRD*+
05B7C:  MOVF   FF5,F
05B7E:  BZ    5B98
05B80:  MOVFF  FF6,70E
05B84:  MOVFF  FF7,70F
05B88:  MOVFF  FF5,750
05B8C:  RCALL  55C6
05B8E:  MOVFF  70E,FF6
05B92:  MOVFF  70F,FF7
05B96:  BRA    5B7A
05B98:  RETURN 0
*
05CBC:  MOVLB  7
05CBE:  MOVF   x68,W
05CC0:  XORWF  x6A,W
05CC2:  ANDLW  80
05CC4:  MOVWF  x6C
05CC6:  BTFSS  x68.7
05CC8:  BRA    5CD4
05CCA:  COMF   x67,F
05CCC:  COMF   x68,F
05CCE:  INCF   x67,F
05CD0:  BTFSC  FD8.2
05CD2:  INCF   x68,F
05CD4:  BTFSS  x6A.7
05CD6:  BRA    5CE2
05CD8:  COMF   x69,F
05CDA:  COMF   x6A,F
05CDC:  INCF   x69,F
05CDE:  BTFSC  FD8.2
05CE0:  INCF   x6A,F
05CE2:  MOVF   x67,W
05CE4:  MULWF  x69
05CE6:  MOVFF  FF3,01
05CEA:  MOVFF  FF4,00
05CEE:  MULWF  x6A
05CF0:  MOVF   FF3,W
05CF2:  ADDWF  00,F
05CF4:  MOVF   x68,W
05CF6:  MULWF  x69
05CF8:  MOVF   FF3,W
05CFA:  ADDWFC 00,W
05CFC:  MOVWF  02
05CFE:  BTFSS  x6C.7
05D00:  BRA    5D0C
05D02:  COMF   01,F
05D04:  COMF   02,F
05D06:  INCF   01,F
05D08:  BTFSC  FD8.2
05D0A:  INCF   02,F
05D0C:  MOVLB  0
05D0E:  GOTO   5FA2 (RETURN)
*
06066:  MOVLW  20
06068:  MOVLB  7
0606A:  BTFSS  x35.4
0606C:  MOVLW  30
0606E:  MOVWF  x36
06070:  MOVFF  734,00
06074:  BTFSS  00.7
06076:  BRA    6088
06078:  COMF   00,F
0607A:  INCF   00,F
0607C:  MOVFF  00,734
06080:  MOVLW  2D
06082:  MOVWF  x36
06084:  BSF    x35.7
06086:  BSF    x35.0
06088:  MOVF   01,W
0608A:  MOVFF  734,73A
0608E:  MOVLW  64
06090:  MOVWF  x3B
06092:  MOVLB  0
06094:  CALL   08CE
06098:  MOVFF  00,734
0609C:  MOVLW  30
0609E:  ADDWF  01,W
060A0:  MOVLB  7
060A2:  MOVWF  x37
060A4:  MOVFF  734,73A
060A8:  MOVLW  0A
060AA:  MOVWF  x3B
060AC:  MOVLB  0
060AE:  CALL   08CE
060B2:  MOVLW  30
060B4:  ADDWF  00,W
060B6:  MOVLB  7
060B8:  MOVWF  x39
060BA:  MOVLW  30
060BC:  ADDWF  01,W
060BE:  MOVWF  x38
060C0:  MOVFF  736,00
060C4:  MOVLW  30
060C6:  SUBWF  x37,W
060C8:  BZ    60D2
060CA:  BSF    x35.1
060CC:  BTFSC  x35.7
060CE:  BSF    x35.2
060D0:  BRA    60F6
060D2:  MOVFF  736,737
060D6:  MOVLW  20
060D8:  MOVWF  x36
060DA:  MOVLW  30
060DC:  SUBWF  x38,W
060DE:  BZ    60E8
060E0:  BSF    x35.0
060E2:  BTFSC  x35.7
060E4:  BSF    x35.1
060E6:  BRA    60F6
060E8:  BTFSS  FD8.2
060EA:  BSF    x35.0
060EC:  BNZ   60F6
060EE:  MOVFF  737,738
060F2:  MOVLW  20
060F4:  MOVWF  x37
060F6:  BTFSC  x35.2
060F8:  BRA    6104
060FA:  BTFSC  x35.1
060FC:  BRA    610E
060FE:  BTFSC  x35.0
06100:  BRA    6118
06102:  BRA    6122
06104:  MOVFF  736,750
06108:  MOVLB  0
0610A:  CALL   55C6
0610E:  MOVFF  737,750
06112:  MOVLB  0
06114:  CALL   55C6
06118:  MOVFF  738,750
0611C:  MOVLB  0
0611E:  CALL   55C6
06122:  MOVFF  739,750
06126:  MOVLB  0
06128:  CALL   55C6
0612C:  RETURN 0
*
062DA:  MOVLB  7
062DC:  MOVF   x22,W
062DE:  ANDLW  07
062E0:  MOVWF  00
062E2:  RRCF   x22,W
062E4:  MOVWF  01
062E6:  RRCF   01,F
062E8:  RRCF   01,F
062EA:  MOVLW  1F
062EC:  ANDWF  01,F
062EE:  MOVF   01,W
062F0:  ADDWF  x24,W
062F2:  MOVWF  FE9
062F4:  MOVLW  00
062F6:  ADDWFC x25,W
062F8:  MOVWF  FEA
062FA:  CLRF   01
062FC:  INCF   01,F
062FE:  INCF   00,F
06300:  BRA    6304
06302:  RLCF   01,F
06304:  DECFSZ 00,F
06306:  BRA    6302
06308:  MOVF   x23,F
0630A:  BZ    6312
0630C:  MOVF   01,W
0630E:  IORWF  FEF,F
06310:  BRA    6318
06312:  COMF   01,F
06314:  MOVF   01,W
06316:  ANDWF  FEF,F
06318:  MOVLB  0
0631A:  RETURN 0
*
092E8:  MOVF   FE9,W
092EA:  MOVLB  7
092EC:  MOVWF  x3D
092EE:  BTFSS  x3C.7
092F0:  BRA    930C
092F2:  DECF   x3D,F
092F4:  BSF    x3D.5
092F6:  COMF   x39,F
092F8:  COMF   x3A,F
092FA:  COMF   x3B,F
092FC:  COMF   x3C,F
092FE:  INCF   x39,F
09300:  BTFSC  FD8.2
09302:  INCF   x3A,F
09304:  BTFSC  FD8.2
09306:  INCF   x3B,F
09308:  BTFSC  FD8.2
0930A:  INCF   x3C,F
0930C:  MOVLW  3B
0930E:  MOVWF  x44
09310:  MOVLW  9A
09312:  MOVWF  x43
09314:  MOVLW  CA
09316:  MOVWF  x42
09318:  CLRF   x41
0931A:  MOVLW  0A
0931C:  MOVWF  x3F
0931E:  BSF    FD8.1
09320:  MOVLW  07
09322:  MOVWF  FEA
09324:  MOVLW  39
09326:  MOVWF  FE9
09328:  MOVFF  73C,753
0932C:  MOVFF  73B,752
09330:  MOVFF  73A,751
09334:  MOVFF  739,750
09338:  MOVFF  744,757
0933C:  MOVFF  743,756
09340:  MOVFF  742,755
09344:  MOVFF  741,754
09348:  MOVLB  0
0934A:  CALL   56D0
0934E:  MOVF   01,W
09350:  MOVF   00,F
09352:  BNZ   937A
09354:  MOVLB  7
09356:  MOVF   x3F,W
09358:  XORLW  01
0935A:  BTFSS  FD8.2
0935C:  BRA    9362
0935E:  MOVLB  0
09360:  BRA    937A
09362:  MOVF   x3D,W
09364:  BZ    9380
09366:  ANDLW  0F
09368:  SUBWF  x3F,W
0936A:  BZ    936E
0936C:  BC    93CA
0936E:  BTFSC  x3D.7
09370:  BRA    93CA
09372:  BTFSC  x3D.6
09374:  BRA    9380
09376:  MOVLW  20
09378:  BRA    93BC
0937A:  MOVLW  20
0937C:  MOVLB  7
0937E:  ANDWF  x3D,F
09380:  BTFSS  x3D.5
09382:  BRA    939C
09384:  BCF    x3D.5
09386:  MOVFF  00,73D
0938A:  MOVLW  2D
0938C:  MOVWF  x50
0938E:  MOVLB  0
09390:  CALL   55C6
09394:  MOVLB  7
09396:  MOVFF  73D,00
0939A:  CLRF   x3D
0939C:  MOVLW  30
0939E:  BTFSS  x3D.5
093A0:  BRA    93BC
093A2:  BCF    x3D.5
093A4:  MOVFF  00,73D
093A8:  MOVLW  2D
093AA:  MOVWF  x50
093AC:  MOVLB  0
093AE:  CALL   55C6
093B2:  MOVLB  7
093B4:  MOVFF  73D,00
093B8:  CLRF   x3D
093BA:  MOVLW  30
093BC:  ADDWF  00,F
093BE:  MOVFF  00,750
093C2:  MOVLB  0
093C4:  CALL   55C6
093C8:  MOVLB  7
093CA:  BCF    FD8.1
093CC:  MOVFF  744,753
093D0:  MOVFF  743,752
093D4:  MOVFF  742,751
093D8:  MOVFF  741,750
093DC:  CLRF   x57
093DE:  CLRF   x56
093E0:  CLRF   x55
093E2:  MOVLW  0A
093E4:  MOVWF  x54
093E6:  MOVLB  0
093E8:  CALL   56D0
093EC:  MOVFF  03,744
093F0:  MOVFF  02,743
093F4:  MOVFF  01,742
093F8:  MOVFF  00,741
093FC:  MOVLB  7
093FE:  DECFSZ x3F,F
09400:  BRA    931E
09402:  MOVLB  0
09404:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
000CA:  MOVLW  01
000CC:  MOVLB  7
000CE:  SUBWF  x72,F
000D0:  BNC   00EA
000D2:  MOVLW  07
000D4:  MOVWF  FEA
000D6:  MOVLW  72
000D8:  MOVWF  FE9
000DA:  MOVF   FEF,W
000DC:  BZ    00EA
000DE:  MOVLW  04
000E0:  MOVWF  00
000E2:  DECFSZ 00,F
000E4:  BRA    00E2
000E6:  DECFSZ FEF,F
000E8:  BRA    00DE
000EA:  MOVLB  0
000EC:  RETURN 0
*
003D6:  MOVLW  07
003D8:  MOVWF  FEA
003DA:  MOVLW  01
003DC:  MOVWF  FE9
003DE:  MOVF   FEF,W
003E0:  BZ    03FE
003E2:  MOVLW  14
003E4:  MOVWF  01
003E6:  CLRF   00
003E8:  DECFSZ 00,F
003EA:  BRA    03E8
003EC:  DECFSZ 01,F
003EE:  BRA    03E6
003F0:  MOVLW  BF
003F2:  MOVWF  00
003F4:  DECFSZ 00,F
003F6:  BRA    03F4
003F8:  BRA    03FA
003FA:  DECFSZ FEF,F
003FC:  BRA    03E2
003FE:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
00400:  MOVLW  CF
00402:  MOVWF  F87
00404:  CLRF   F82
....................    output_b(portB_reset);
00406:  MOVLW  04
00408:  MOVWF  F88
0040A:  CLRF   F83
....................    output_c(portC_reset);
0040C:  MOVLW  93
0040E:  MOVWF  F89
00410:  CLRF   F84
....................    output_d(portD_reset);
00412:  MOVLW  1F
00414:  MOVWF  F8A
00416:  CLRF   F85
....................    output_e(portE_reset);
00418:  BCF    F8B.0
0041A:  BCF    F8B.1
0041C:  BCF    F8B.2
0041E:  BCF    F8B.3
00420:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00422:  MOVLB  F
00424:  SETF   x0B
....................    port_b_pullups(portB_pullups);
00426:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00428:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
0042A:  SETF   x20
....................    port_e_pullups(portE_pullups);
0042C:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
0042E:  MOVLW  40
00430:  MOVWF  x0C
00432:  CLRF   x14
00434:  MOVLW  03
00436:  MOVWF  x1C
00438:  MOVLW  0F
0043A:  MOVWF  x21
0043C:  CLRF   x29
0043E:  MOVLB  0
00440:  GOTO   A72A (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05B02:  MOVFF  742,FEA
05B06:  MOVLB  7
05B08:  MOVFF  741,FE9
05B0C:  MOVFF  FEF,745
05B10:  MOVFF  744,FEA
05B14:  MOVFF  743,FE9
05B18:  MOVF   FEF,W
05B1A:  SUBWF  x45,W
05B1C:  BNZ   5B4C
....................       if (*s1 == '\0')
05B1E:  MOVFF  742,03
05B22:  MOVFF  741,FE9
05B26:  MOVFF  03,FEA
05B2A:  MOVF   FEF,F
05B2C:  BNZ   5B34
....................          return(0);
05B2E:  MOVLW  00
05B30:  MOVWF  01
05B32:  BRA    5B76
05B34:  MOVFF  742,03
05B38:  MOVF   x41,W
05B3A:  INCF   x41,F
05B3C:  BTFSC  FD8.2
05B3E:  INCF   x42,F
05B40:  INCF   x43,F
05B42:  BTFSC  FD8.2
05B44:  INCF   x44,F
05B46:  MOVLB  0
05B48:  BRA    5B02
05B4A:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05B4C:  MOVFF  742,03
05B50:  MOVFF  741,FE9
05B54:  MOVFF  03,FEA
05B58:  MOVFF  FEF,745
05B5C:  MOVFF  744,03
05B60:  MOVFF  743,FE9
05B64:  MOVFF  03,FEA
05B68:  MOVF   FEF,W
05B6A:  SUBWF  x45,W
05B6C:  BC    5B72
05B6E:  MOVLW  FF
05B70:  BRA    5B74
05B72:  MOVLW  01
05B74:  MOVWF  01
05B76:  MOVLB  0
05B78:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05C72:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
05C76:  MOVFF  767,76D
05C7A:  MOVFF  766,76C
05C7E:  MOVLB  7
05C80:  MOVF   x6A,F
05C82:  BNZ   5C8A
05C84:  MOVF   x69,W
05C86:  SUBLW  00
05C88:  BC    5CB2
....................       if(*su==uc)
05C8A:  MOVFF  76D,FEA
05C8E:  MOVFF  76C,FE9
05C92:  MOVF   x6B,W
05C94:  SUBWF  FEF,W
05C96:  BNZ   5CA2
....................       return su;
05C98:  MOVFF  76C,01
05C9C:  MOVFF  76D,02
05CA0:  BRA    5CB8
05CA2:  INCF   x6C,F
05CA4:  BTFSC  FD8.2
05CA6:  INCF   x6D,F
05CA8:  MOVF   x69,W
05CAA:  BTFSC  FD8.2
05CAC:  DECF   x6A,F
05CAE:  DECF   x69,F
05CB0:  BRA    5C80
....................    return NULL;
05CB2:  MOVLW  00
05CB4:  MOVWF  01
05CB6:  MOVWF  02
05CB8:  MOVLB  0
05CBA:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0558E:  MOVFF  742,744
05592:  MOVFF  741,743
05596:  MOVFF  744,FEA
0559A:  MOVLB  7
0559C:  MOVFF  743,FE9
055A0:  MOVF   FEF,F
055A2:  BZ    55B0
055A4:  INCF   x43,F
055A6:  BTFSC  FD8.2
055A8:  INCF   x44,F
055AA:  MOVLB  0
055AC:  BRA    5596
055AE:  MOVLB  7
....................    return(sc - s);
055B0:  MOVF   x41,W
055B2:  SUBWF  x43,W
055B4:  MOVWF  00
055B6:  MOVF   x42,W
055B8:  SUBWFB x44,W
055BA:  MOVWF  03
055BC:  MOVFF  00,01
055C0:  MOVWF  02
055C2:  MOVLB  0
055C4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06DF8:  MOVLB  7
06DFA:  CLRF   x1B
06DFC:  CLRF   x1A
06DFE:  CLRF   x19
06E00:  MOVLW  7F
06E02:  MOVWF  x18
06E04:  CLRF   x1F
06E06:  CLRF   x1E
06E08:  CLRF   x1D
06E0A:  CLRF   x1C
06E0C:  BSF    x20.0
06E0E:  BCF    x20.1
06E10:  BCF    x20.2
06E12:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06E14:  MOVF   x14,W
06E16:  IORWF  x15,W
06E18:  BNZ   6E24
....................       return 0;
06E1A:  CLRF   00
06E1C:  CLRF   01
06E1E:  CLRF   02
06E20:  CLRF   03
06E22:  BRA    704E
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06E24:  MOVF   x22,W
06E26:  INCF   x22,F
06E28:  ADDWF  x14,W
06E2A:  MOVWF  FE9
06E2C:  MOVLW  00
06E2E:  ADDWFC x15,W
06E30:  MOVWF  FEA
06E32:  MOVFF  FEF,721
06E36:  MOVF   x21,F
06E38:  BTFSC  FD8.2
06E3A:  BRA    6FD2
....................    {
....................       if (skip && !isspace(c))
06E3C:  BTFSS  x20.0
06E3E:  BRA    6E5E
06E40:  MOVF   x21,W
06E42:  SUBLW  20
06E44:  BZ    6E5E
....................       {
....................          skip = 0;
06E46:  BCF    x20.0
....................          if (c == '+')
06E48:  MOVF   x21,W
06E4A:  SUBLW  2B
06E4C:  BNZ   6E54
....................          {
....................             sign = 0;
06E4E:  BCF    x20.1
....................             continue;
06E50:  BRA    6FBA
....................          }            
06E52:  BRA    6E5E
....................          else if (c == '-')
06E54:  MOVF   x21,W
06E56:  SUBLW  2D
06E58:  BNZ   6E5E
....................          {
....................             sign = 1;
06E5A:  BSF    x20.1
....................             continue;
06E5C:  BRA    6FBA
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06E5E:  BTFSC  x20.0
06E60:  BRA    6E70
06E62:  MOVF   x21,W
06E64:  SUBLW  2E
06E66:  BNZ   6E70
06E68:  BTFSC  x20.2
06E6A:  BRA    6E70
....................          point = 1;
06E6C:  BSF    x20.2
06E6E:  BRA    6FBA
....................       else if (!skip && isdigit(c))
06E70:  BTFSC  x20.0
06E72:  BRA    6FB4
06E74:  MOVF   x21,W
06E76:  SUBLW  2F
06E78:  BTFSC  FD8.0
06E7A:  BRA    6FB4
06E7C:  MOVF   x21,W
06E7E:  SUBLW  39
06E80:  BTFSS  FD8.0
06E82:  BRA    6FB4
....................       {
....................          c -= '0';
06E84:  MOVLW  30
06E86:  SUBWF  x21,F
....................          if (point)
06E88:  BTFSS  x20.2
06E8A:  BRA    6F3A
....................          {
....................             pow10 = pow10 * 10.0;
06E8C:  MOVFF  71B,753
06E90:  MOVFF  71A,752
06E94:  MOVFF  719,751
06E98:  MOVFF  718,750
06E9C:  CLRF   x57
06E9E:  CLRF   x56
06EA0:  MOVLW  20
06EA2:  MOVWF  x55
06EA4:  MOVLW  82
06EA6:  MOVWF  x54
06EA8:  MOVLB  0
06EAA:  CALL   0D96
06EAE:  MOVFF  03,71B
06EB2:  MOVFF  02,71A
06EB6:  MOVFF  01,719
06EBA:  MOVFF  00,718
....................             result += (float)c / pow10;   
06EBE:  MOVLB  7
06EC0:  CLRF   x4B
06EC2:  MOVFF  721,74A
06EC6:  MOVLB  0
06EC8:  CALL   0D60
06ECC:  MOVFF  03,726
06ED0:  MOVFF  02,725
06ED4:  MOVFF  01,724
06ED8:  MOVFF  00,723
06EDC:  MOVFF  03,742
06EE0:  MOVFF  02,741
06EE4:  MOVFF  01,740
06EE8:  MOVFF  00,73F
06EEC:  MOVFF  71B,746
06EF0:  MOVFF  71A,745
06EF4:  MOVFF  719,744
06EF8:  MOVFF  718,743
06EFC:  CALL   1D9C
06F00:  BCF    FD8.1
06F02:  MOVFF  71F,74D
06F06:  MOVFF  71E,74C
06F0A:  MOVFF  71D,74B
06F0E:  MOVFF  71C,74A
06F12:  MOVFF  03,751
06F16:  MOVFF  02,750
06F1A:  MOVFF  01,74F
06F1E:  MOVFF  00,74E
06F22:  CALL   0E8C
06F26:  MOVFF  03,71F
06F2A:  MOVFF  02,71E
06F2E:  MOVFF  01,71D
06F32:  MOVFF  00,71C
....................          }
06F36:  BRA    6FB0
06F38:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06F3A:  CLRF   x53
06F3C:  CLRF   x52
06F3E:  MOVLW  20
06F40:  MOVWF  x51
06F42:  MOVLW  82
06F44:  MOVWF  x50
06F46:  MOVFF  71F,757
06F4A:  MOVFF  71E,756
06F4E:  MOVFF  71D,755
06F52:  MOVFF  71C,754
06F56:  MOVLB  0
06F58:  CALL   0D96
06F5C:  MOVFF  03,726
06F60:  MOVFF  02,725
06F64:  MOVFF  01,724
06F68:  MOVFF  00,723
06F6C:  MOVLB  7
06F6E:  CLRF   x4B
06F70:  MOVFF  721,74A
06F74:  MOVLB  0
06F76:  CALL   0D60
06F7A:  BCF    FD8.1
06F7C:  MOVFF  726,74D
06F80:  MOVFF  725,74C
06F84:  MOVFF  724,74B
06F88:  MOVFF  723,74A
06F8C:  MOVFF  03,751
06F90:  MOVFF  02,750
06F94:  MOVFF  01,74F
06F98:  MOVFF  00,74E
06F9C:  CALL   0E8C
06FA0:  MOVFF  03,71F
06FA4:  MOVFF  02,71E
06FA8:  MOVFF  01,71D
06FAC:  MOVFF  00,71C
....................          }
....................       }
06FB0:  BRA    6FBC
06FB2:  MOVLB  7
....................       else if (!skip)
06FB4:  BTFSC  x20.0
06FB6:  BRA    6FBA
....................          break;
06FB8:  BRA    6FD2
06FBA:  MOVLB  0
06FBC:  MOVLB  7
06FBE:  MOVF   x22,W
06FC0:  INCF   x22,F
06FC2:  ADDWF  x14,W
06FC4:  MOVWF  FE9
06FC6:  MOVLW  00
06FC8:  ADDWFC x15,W
06FCA:  MOVWF  FEA
06FCC:  MOVFF  FEF,721
06FD0:  BRA    6E36
....................    }
.................... 
....................    if (sign)
06FD2:  BTFSS  x20.1
06FD4:  BRA    700A
....................       result = -1*result;
06FD6:  CLRF   x53
06FD8:  CLRF   x52
06FDA:  MOVLW  80
06FDC:  MOVWF  x51
06FDE:  MOVLW  7F
06FE0:  MOVWF  x50
06FE2:  MOVFF  71F,757
06FE6:  MOVFF  71E,756
06FEA:  MOVFF  71D,755
06FEE:  MOVFF  71C,754
06FF2:  MOVLB  0
06FF4:  CALL   0D96
06FF8:  MOVFF  03,71F
06FFC:  MOVFF  02,71E
07000:  MOVFF  01,71D
07004:  MOVFF  00,71C
07008:  MOVLB  7
....................       
....................    if(endptr)
0700A:  MOVF   x16,W
0700C:  IORWF  x17,W
0700E:  BZ    703E
....................    {
....................       if (ptr) {
07010:  MOVF   x22,F
07012:  BZ    702C
....................          ptr--;
07014:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07016:  MOVFF  717,FEA
0701A:  MOVFF  716,FE9
0701E:  MOVF   x22,W
07020:  ADDWF  x14,W
07022:  MOVWF  FEF
07024:  MOVLW  00
07026:  ADDWFC x15,W
07028:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0702A:  BRA    703E
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0702C:  MOVFF  717,FEA
07030:  MOVFF  716,FE9
07034:  MOVFF  715,FEC
07038:  MOVF   FED,F
0703A:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
0703E:  MOVFF  71C,00
07042:  MOVFF  71D,01
07046:  MOVFF  71E,02
0704A:  MOVFF  71F,03
0704E:  MOVLB  0
07050:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05D12:  MOVLB  7
05D14:  CLRF   x3F
05D16:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05D18:  MOVLW  30
05D1A:  MOVWF  x41
05D1C:  MOVLW  31
05D1E:  MOVWF  x42
05D20:  MOVLW  32
05D22:  MOVWF  x43
05D24:  MOVLW  33
05D26:  MOVWF  x44
05D28:  MOVLW  34
05D2A:  MOVWF  x45
05D2C:  MOVLW  35
05D2E:  MOVWF  x46
05D30:  MOVLW  36
05D32:  MOVWF  x47
05D34:  MOVLW  37
05D36:  MOVWF  x48
05D38:  MOVLW  38
05D3A:  MOVWF  x49
05D3C:  MOVLW  39
05D3E:  MOVWF  x4A
05D40:  MOVLW  61
05D42:  MOVWF  x4B
05D44:  MOVLW  62
05D46:  MOVWF  x4C
05D48:  MOVLW  63
05D4A:  MOVWF  x4D
05D4C:  MOVLW  64
05D4E:  MOVWF  x4E
05D50:  MOVLW  65
05D52:  MOVWF  x4F
05D54:  MOVLW  66
05D56:  MOVWF  x50
05D58:  MOVLW  67
05D5A:  MOVWF  x51
05D5C:  MOVLW  68
05D5E:  MOVWF  x52
05D60:  MOVLW  69
05D62:  MOVWF  x53
05D64:  MOVLW  6A
05D66:  MOVWF  x54
05D68:  MOVLW  6B
05D6A:  MOVWF  x55
05D6C:  MOVLW  6C
05D6E:  MOVWF  x56
05D70:  MOVLW  6D
05D72:  MOVWF  x57
05D74:  MOVLW  6E
05D76:  MOVWF  x58
05D78:  MOVLW  6F
05D7A:  MOVWF  x59
05D7C:  MOVLW  70
05D7E:  MOVWF  x5A
05D80:  MOVLW  71
05D82:  MOVWF  x5B
05D84:  MOVLW  73
05D86:  MOVWF  x5C
05D88:  MOVLW  74
05D8A:  MOVWF  x5D
05D8C:  MOVLW  75
05D8E:  MOVWF  x5E
05D90:  MOVLW  76
05D92:  MOVWF  x5F
05D94:  MOVLW  77
05D96:  MOVWF  x60
05D98:  MOVLW  78
05D9A:  MOVWF  x61
05D9C:  MOVLW  79
05D9E:  MOVWF  x62
05DA0:  MOVLW  7A
05DA2:  MOVWF  x63
05DA4:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
05DA6:  MOVFF  734,739
05DAA:  MOVFF  733,738
05DAE:  MOVFF  739,FEA
05DB2:  MOVFF  738,FE9
05DB6:  MOVF   FEF,W
05DB8:  SUBLW  20
05DBA:  BNZ   5DC4
05DBC:  INCF   x38,F
05DBE:  BTFSC  FD8.2
05DC0:  INCF   x39,F
05DC2:  BRA    5DAE
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05DC4:  MOVFF  739,03
05DC8:  MOVFF  738,FE9
05DCC:  MOVFF  03,FEA
05DD0:  MOVF   FEF,W
05DD2:  SUBLW  2D
05DD4:  BZ    5DE4
05DD6:  MOVFF  739,FEA
05DDA:  MOVFF  738,FE9
05DDE:  MOVF   FEF,W
05DE0:  SUBLW  2B
05DE2:  BNZ   5DF6
05DE4:  MOVFF  739,FEA
05DE8:  MOVF   x38,W
05DEA:  INCF   x38,F
05DEC:  BTFSC  FD8.2
05DEE:  INCF   x39,F
05DF0:  MOVWF  FE9
05DF2:  MOVF   FEF,W
05DF4:  BRA    5DF8
05DF6:  MOVLW  2B
05DF8:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05DFA:  MOVF   x40,W
05DFC:  SUBLW  2D
05DFE:  BZ    5E14
05E00:  BTFSC  x37.7
05E02:  BRA    5E14
05E04:  DECFSZ x37,W
05E06:  BRA    5E0A
05E08:  BRA    5E14
05E0A:  BTFSC  x37.7
05E0C:  BRA    5E18
05E0E:  MOVF   x37,W
05E10:  SUBLW  24
05E12:  BC    5E18
....................    goto StrtoulGO;
05E14:  BRA    6020
05E16:  BRA    5F10
.................... 
....................    else if (base)
05E18:  MOVF   x37,F
05E1A:  BZ    5EA8
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05E1C:  MOVF   x37,W
05E1E:  SUBLW  10
05E20:  BNZ   5E5C
05E22:  MOVFF  739,FEA
05E26:  MOVFF  738,FE9
05E2A:  MOVF   FEF,W
05E2C:  SUBLW  30
05E2E:  BNZ   5E5C
05E30:  MOVLW  01
05E32:  ADDWF  x38,W
05E34:  MOVWF  FE9
05E36:  MOVLW  00
05E38:  ADDWFC x39,W
05E3A:  MOVWF  FEA
05E3C:  MOVF   FEF,W
05E3E:  SUBLW  78
05E40:  BZ    5E54
05E42:  MOVLW  01
05E44:  ADDWF  x38,W
05E46:  MOVWF  FE9
05E48:  MOVLW  00
05E4A:  ADDWFC x39,W
05E4C:  MOVWF  FEA
05E4E:  MOVF   FEF,W
05E50:  SUBLW  58
05E52:  BNZ   5E5C
....................          sc+=2;
05E54:  MOVLW  02
05E56:  ADDWF  x38,F
05E58:  MOVLW  00
05E5A:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
05E5C:  MOVF   x37,W
05E5E:  SUBLW  08
05E60:  BNZ   5E78
05E62:  MOVFF  739,FEA
05E66:  MOVFF  738,FE9
05E6A:  MOVF   FEF,W
05E6C:  SUBLW  30
05E6E:  BNZ   5E78
....................          sc+=1;
05E70:  MOVLW  01
05E72:  ADDWF  x38,F
05E74:  MOVLW  00
05E76:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05E78:  MOVF   x37,W
05E7A:  SUBLW  02
05E7C:  BNZ   5EA6
05E7E:  MOVFF  739,FEA
05E82:  MOVFF  738,FE9
05E86:  MOVF   FEF,W
05E88:  SUBLW  30
05E8A:  BNZ   5EA6
05E8C:  MOVLW  01
05E8E:  ADDWF  x38,W
05E90:  MOVWF  FE9
05E92:  MOVLW  00
05E94:  ADDWFC x39,W
05E96:  MOVWF  FEA
05E98:  MOVF   FEF,W
05E9A:  SUBLW  62
05E9C:  BNZ   5EA6
....................          sc+=2;
05E9E:  MOVLW  02
05EA0:  ADDWF  x38,F
05EA2:  MOVLW  00
05EA4:  ADDWFC x39,F
.................... 
....................    }
05EA6:  BRA    5F10
....................    else if(*sc!='0') // base is 0, find base
05EA8:  MOVFF  739,FEA
05EAC:  MOVFF  738,FE9
05EB0:  MOVF   FEF,W
05EB2:  SUBLW  30
05EB4:  BZ    5EBC
....................       base=10;
05EB6:  MOVLW  0A
05EB8:  MOVWF  x37
05EBA:  BRA    5F10
....................    else if (sc[1]=='x' || sc[1]=='X')
05EBC:  MOVLW  01
05EBE:  ADDWF  x38,W
05EC0:  MOVWF  FE9
05EC2:  MOVLW  00
05EC4:  ADDWFC x39,W
05EC6:  MOVWF  FEA
05EC8:  MOVF   FEF,W
05ECA:  SUBLW  78
05ECC:  BZ    5EE0
05ECE:  MOVLW  01
05ED0:  ADDWF  x38,W
05ED2:  MOVWF  FE9
05ED4:  MOVLW  00
05ED6:  ADDWFC x39,W
05ED8:  MOVWF  FEA
05EDA:  MOVF   FEF,W
05EDC:  SUBLW  58
05EDE:  BNZ   5EEE
....................       base =16,sc+=2;
05EE0:  MOVLW  10
05EE2:  MOVWF  x37
05EE4:  MOVLW  02
05EE6:  ADDWF  x38,F
05EE8:  MOVLW  00
05EEA:  ADDWFC x39,F
05EEC:  BRA    5F10
....................    else if(sc[1]=='b')
05EEE:  MOVLW  01
05EF0:  ADDWF  x38,W
05EF2:  MOVWF  FE9
05EF4:  MOVLW  00
05EF6:  ADDWFC x39,W
05EF8:  MOVWF  FEA
05EFA:  MOVF   FEF,W
05EFC:  SUBLW  62
05EFE:  BNZ   5F0C
....................       base=2,sc+=2;
05F00:  MOVLW  02
05F02:  MOVWF  x37
05F04:  ADDWF  x38,F
05F06:  MOVLW  00
05F08:  ADDWFC x39,F
05F0A:  BRA    5F10
....................    else
....................       base=8;
05F0C:  MOVLW  08
05F0E:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05F10:  MOVFF  739,73B
05F14:  MOVFF  738,73A
05F18:  MOVFF  739,FEA
05F1C:  MOVFF  738,FE9
05F20:  MOVF   FEF,W
05F22:  SUBLW  30
05F24:  BNZ   5F2E
05F26:  INCF   x38,F
05F28:  BTFSC  FD8.2
05F2A:  INCF   x39,F
05F2C:  BRA    5F18
....................    sd=memchr(digits,tolower(*sc),base);
05F2E:  MOVFF  739,03
05F32:  MOVFF  738,FE9
05F36:  MOVFF  03,FEA
05F3A:  MOVFF  FEF,765
05F3E:  MOVF   x65,W
05F40:  SUBLW  40
05F42:  BC    5F50
05F44:  MOVF   x65,W
05F46:  SUBLW  5A
05F48:  BNC   5F50
05F4A:  MOVF   x65,W
05F4C:  IORLW  20
05F4E:  BRA    5F52
05F50:  MOVF   x65,W
05F52:  MOVWF  x65
05F54:  MOVLW  07
05F56:  MOVWF  x67
05F58:  MOVLW  41
05F5A:  MOVWF  x66
05F5C:  MOVFF  765,768
05F60:  CLRF   x6A
05F62:  MOVFF  737,769
05F66:  BTFSC  x69.7
05F68:  DECF   x6A,F
05F6A:  MOVLB  0
05F6C:  RCALL  5C72
05F6E:  MOVFF  02,73D
05F72:  MOVFF  01,73C
....................    for(; sd!=0; )
05F76:  MOVLB  7
05F78:  MOVF   x3C,F
05F7A:  BNZ   5F80
05F7C:  MOVF   x3D,F
05F7E:  BZ    6014
....................    {
....................       x=x*base+(int16)(sd-digits);
05F80:  CLRF   03
05F82:  MOVF   x37,W
05F84:  MOVWF  00
05F86:  BTFSC  FE8.7
05F88:  DECF   03,F
05F8A:  MOVWF  x65
05F8C:  MOVFF  03,766
05F90:  MOVFF  73F,768
05F94:  MOVFF  73E,767
05F98:  MOVFF  03,76A
05F9C:  MOVWF  x69
05F9E:  MOVLB  0
05FA0:  BRA    5CBC
05FA2:  MOVFF  01,765
05FA6:  MOVLW  41
05FA8:  MOVLB  7
05FAA:  SUBWF  x3C,W
05FAC:  MOVWF  00
05FAE:  MOVLW  07
05FB0:  SUBWFB x3D,W
05FB2:  MOVWF  03
05FB4:  MOVF   00,W
05FB6:  ADDWF  01,W
05FB8:  MOVWF  01
05FBA:  MOVF   02,W
05FBC:  ADDWFC 03,F
05FBE:  MOVFF  01,73E
05FC2:  MOVFF  03,73F
....................       ++sc;
05FC6:  INCF   x38,F
05FC8:  BTFSC  FD8.2
05FCA:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
05FCC:  MOVFF  739,FEA
05FD0:  MOVFF  738,FE9
05FD4:  MOVFF  FEF,765
05FD8:  MOVF   x65,W
05FDA:  SUBLW  40
05FDC:  BC    5FEA
05FDE:  MOVF   x65,W
05FE0:  SUBLW  5A
05FE2:  BNC   5FEA
05FE4:  MOVF   x65,W
05FE6:  IORLW  20
05FE8:  BRA    5FEC
05FEA:  MOVF   x65,W
05FEC:  MOVWF  x65
05FEE:  MOVLW  07
05FF0:  MOVWF  x67
05FF2:  MOVLW  41
05FF4:  MOVWF  x66
05FF6:  MOVFF  765,768
05FFA:  CLRF   x6A
05FFC:  MOVFF  737,769
06000:  BTFSC  x69.7
06002:  DECF   x6A,F
06004:  MOVLB  0
06006:  RCALL  5C72
06008:  MOVFF  02,73D
0600C:  MOVFF  01,73C
06010:  BRA    5F76
06012:  MOVLB  7
....................    }
....................    if(s1==sc)
06014:  MOVF   x38,W
06016:  SUBWF  x3A,W
06018:  BNZ   6042
0601A:  MOVF   x39,W
0601C:  SUBWF  x3B,W
0601E:  BNZ   6042
....................    {
....................    StrtoulGO:
....................       if (endptr)
06020:  MOVLB  7
06022:  MOVF   x35,W
06024:  IORWF  x36,W
06026:  BZ    603A
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06028:  MOVFF  736,FEA
0602C:  MOVFF  735,FE9
06030:  MOVFF  734,FEC
06034:  MOVF   FED,F
06036:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
0603A:  MOVLW  00
0603C:  MOVWF  01
0603E:  MOVWF  02
06040:  BRA    6062
....................    }
....................    if (endptr)
06042:  MOVF   x35,W
06044:  IORWF  x36,W
06046:  BZ    605A
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
06048:  MOVFF  736,FEA
0604C:  MOVFF  735,FE9
06050:  MOVFF  739,FEC
06054:  MOVF   FED,F
06056:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
0605A:  MOVFF  73E,01
0605E:  MOVFF  73F,02
06062:  MOVLB  0
06064:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
004A6:  MOVLB  7
004A8:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
004AA:  CLRF   x00
004AC:  MOVLB  6
004AE:  MOVF   xFF,W
004B0:  MOVLB  7
004B2:  SUBWF  x00,W
004B4:  BC    0516
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
004B6:  MOVF   x00,W
004B8:  MOVLB  6
004BA:  ADDWF  xFD,W
004BC:  MOVLB  7
004BE:  MOVWF  x01
004C0:  MOVLW  00
004C2:  MOVLB  6
004C4:  ADDWFC xFE,W
004C6:  MOVLB  7
004C8:  MOVWF  x02
004CA:  MOVF   x00,W
004CC:  MOVLB  6
004CE:  ADDWF  xFB,W
004D0:  MOVWF  01
004D2:  MOVLW  00
004D4:  ADDWFC xFC,W
004D6:  MOVWF  03
004D8:  MOVF   01,W
004DA:  MOVWF  FE9
004DC:  MOVFF  03,FEA
004E0:  MOVFF  FEF,703
004E4:  BSF    F7F.7
004E6:  MOVF   FF2,W
004E8:  MOVWF  00
004EA:  BCF    FF2.7
004EC:  MOVFF  702,F7A
004F0:  MOVFF  701,F79
004F4:  MOVLW  31
004F6:  MOVWF  F7B
004F8:  MOVFF  703,F7C
004FC:  MOVLB  F
004FE:  MOVLW  55
00500:  MOVWF  F81
00502:  MOVLW  AA
00504:  MOVWF  F81
00506:  BSF    F80.4
00508:  BTFSC  F80.4
0050A:  BRA    0508
0050C:  MOVF   00,W
0050E:  IORWF  FF2,F
00510:  MOVLB  7
00512:  INCF   x00,F
00514:  BRA    04AC
....................    }
00516:  MOVLB  0
00518:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00444:  MOVLB  7
00446:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00448:  CLRF   x00
0044A:  MOVLB  6
0044C:  MOVF   xFF,W
0044E:  MOVLB  7
00450:  SUBWF  x00,W
00452:  BC    04A2
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00454:  MOVF   x00,W
00456:  MOVLB  6
00458:  ADDWF  xFB,W
0045A:  MOVWF  01
0045C:  MOVLW  00
0045E:  ADDWFC xFC,W
00460:  MOVWF  03
00462:  MOVF   01,W
00464:  MOVWF  FE9
00466:  MOVFF  03,FEA
0046A:  MOVLB  7
0046C:  MOVF   x00,W
0046E:  MOVLB  6
00470:  ADDWF  xFD,W
00472:  MOVLB  7
00474:  MOVWF  x03
00476:  MOVLW  00
00478:  MOVLB  6
0047A:  ADDWFC xFE,W
0047C:  MOVLB  7
0047E:  MOVWF  x04
00480:  BSF    F7F.7
00482:  MOVFF  FF2,705
00486:  BCF    FF2.7
00488:  MOVFF  704,F7A
0048C:  MOVFF  703,F79
00490:  MOVLW  31
00492:  MOVWF  F7B
00494:  BSF    F80.0
00496:  MOVF   F7C,W
00498:  BTFSC  x05.7
0049A:  BSF    FF2.7
0049C:  MOVWF  FEF
0049E:  INCF   x00,F
004A0:  BRA    044A
....................    }
004A2:  MOVLB  0
004A4:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0051A:  MOVLB  6
0051C:  CLRF   xFC
0051E:  MOVLW  20
00520:  MOVWF  xFB
00522:  CLRF   xFE
00524:  CLRF   xFD
00526:  MOVLW  80
00528:  MOVWF  xFF
0052A:  MOVLB  0
0052C:  RCALL  04A6
....................    delay_ms(1);
0052E:  MOVLW  01
00530:  MOVLB  7
00532:  MOVWF  x01
00534:  MOVLB  0
00536:  RCALL  03D6
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
00538:  MOVLB  6
0053A:  CLRF   xFC
0053C:  MOVLW  70
0053E:  MOVWF  xFB
00540:  CLRF   xFE
00542:  MOVLW  80
00544:  MOVWF  xFD
00546:  MOVLW  02
00548:  MOVWF  xFF
0054A:  MOVLB  0
0054C:  RCALL  04A6
....................    delay_ms(1);
0054E:  MOVLW  01
00550:  MOVLB  7
00552:  MOVWF  x01
00554:  MOVLB  0
00556:  RCALL  03D6
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00558:  MOVLB  6
0055A:  CLRF   xFC
0055C:  MOVLW  71
0055E:  MOVWF  xFB
00560:  CLRF   xFE
00562:  MOVLW  90
00564:  MOVWF  xFD
00566:  MOVLW  02
00568:  MOVWF  xFF
0056A:  MOVLB  0
0056C:  RCALL  04A6
....................    delay_ms(1);
0056E:  MOVLW  01
00570:  MOVLB  7
00572:  MOVWF  x01
00574:  MOVLB  0
00576:  RCALL  03D6
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00578:  MOVLB  6
0057A:  CLRF   xFC
0057C:  MOVLW  72
0057E:  MOVWF  xFB
00580:  CLRF   xFE
00582:  MOVLW  A0
00584:  MOVWF  xFD
00586:  MOVLW  20
00588:  MOVWF  xFF
0058A:  MOVLB  0
0058C:  RCALL  04A6
....................    delay_ms(1);
0058E:  MOVLW  01
00590:  MOVLB  7
00592:  MOVWF  x01
00594:  MOVLB  0
00596:  RCALL  03D6
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00598:  MOVLB  6
0059A:  CLRF   xFC
0059C:  MOVLW  92
0059E:  MOVWF  xFB
005A0:  CLRF   xFE
005A2:  MOVLW  C0
005A4:  MOVWF  xFD
005A6:  MOVLW  30
005A8:  MOVWF  xFF
005AA:  MOVLB  0
005AC:  RCALL  04A6
....................    delay_ms(1);
005AE:  MOVLW  01
005B0:  MOVLB  7
005B2:  MOVWF  x01
005B4:  MOVLB  0
005B6:  RCALL  03D6
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005B8:  MOVLB  6
005BA:  CLRF   xFC
005BC:  MOVLW  C2
005BE:  MOVWF  xFB
005C0:  CLRF   xFE
005C2:  MOVLW  F0
005C4:  MOVWF  xFD
005C6:  MOVLW  38
005C8:  MOVWF  xFF
005CA:  MOVLB  0
005CC:  RCALL  04A6
....................    delay_ms(1);
005CE:  MOVLW  01
005D0:  MOVLB  7
005D2:  MOVWF  x01
005D4:  MOVLB  0
005D6:  RCALL  03D6
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005D8:  MOVLB  6
005DA:  CLRF   xFC
005DC:  MOVLW  FA
005DE:  MOVWF  xFB
005E0:  MOVLW  01
005E2:  MOVWF  xFE
005E4:  MOVLW  40
005E6:  MOVWF  xFD
005E8:  MOVLW  01
005EA:  MOVWF  xFF
005EC:  MOVLB  0
005EE:  RCALL  04A6
....................    delay_ms(1);
005F0:  MOVLW  01
005F2:  MOVLB  7
005F4:  MOVWF  x01
005F6:  MOVLB  0
005F8:  RCALL  03D6
005FA:  GOTO   06CA (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005FE:  MOVLB  6
00600:  CLRF   xFC
00602:  MOVLW  20
00604:  MOVWF  xFB
00606:  CLRF   xFE
00608:  CLRF   xFD
0060A:  MOVLW  80
0060C:  MOVWF  xFF
0060E:  MOVLB  0
00610:  RCALL  0444
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00612:  MOVLB  6
00614:  CLRF   xFC
00616:  MOVLW  70
00618:  MOVWF  xFB
0061A:  CLRF   xFE
0061C:  MOVLW  80
0061E:  MOVWF  xFD
00620:  MOVLW  02
00622:  MOVWF  xFF
00624:  MOVLB  0
00626:  RCALL  0444
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00628:  MOVLB  6
0062A:  CLRF   xFC
0062C:  MOVLW  71
0062E:  MOVWF  xFB
00630:  CLRF   xFE
00632:  MOVLW  90
00634:  MOVWF  xFD
00636:  MOVLW  02
00638:  MOVWF  xFF
0063A:  MOVLB  0
0063C:  RCALL  0444
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0063E:  MOVLB  6
00640:  CLRF   xFC
00642:  MOVLW  72
00644:  MOVWF  xFB
00646:  CLRF   xFE
00648:  MOVLW  A0
0064A:  MOVWF  xFD
0064C:  MOVLW  20
0064E:  MOVWF  xFF
00650:  MOVLB  0
00652:  RCALL  0444
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00654:  MOVLB  6
00656:  CLRF   xFC
00658:  MOVLW  92
0065A:  MOVWF  xFB
0065C:  CLRF   xFE
0065E:  MOVLW  C0
00660:  MOVWF  xFD
00662:  MOVLW  30
00664:  MOVWF  xFF
00666:  MOVLB  0
00668:  RCALL  0444
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0066A:  MOVLB  6
0066C:  CLRF   xFC
0066E:  MOVLW  C2
00670:  MOVWF  xFB
00672:  CLRF   xFE
00674:  MOVLW  F0
00676:  MOVWF  xFD
00678:  MOVLW  38
0067A:  MOVWF  xFF
0067C:  MOVLB  0
0067E:  RCALL  0444
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00680:  MOVLB  6
00682:  CLRF   xFC
00684:  MOVLW  FA
00686:  MOVWF  xFB
00688:  MOVLW  01
0068A:  MOVWF  xFE
0068C:  MOVLW  40
0068E:  MOVWF  xFD
00690:  MOVLW  01
00692:  MOVWF  xFF
00694:  MOVLB  0
00696:  RCALL  0444
00698:  GOTO   06CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0069C:  MOVLB  6
0069E:  CLRF   xFC
006A0:  MOVLW  FA
006A2:  MOVWF  xFB
006A4:  MOVLW  01
006A6:  MOVWF  xFE
006A8:  MOVLW  40
006AA:  MOVWF  xFD
006AC:  MOVLW  01
006AE:  MOVWF  xFF
006B0:  MOVLB  0
006B2:  RCALL  0444
....................    delay_ms(1);
006B4:  MOVLW  01
006B6:  MOVLB  7
006B8:  MOVWF  x01
006BA:  MOVLB  0
006BC:  RCALL  03D6
....................    if (paramsValid != isValid)
006BE:  MOVF   xFA,W
006C0:  SUBLW  AA
006C2:  BZ    06CC
....................    {
....................       paramsValid = isValid;
006C4:  MOVLW  AA
006C6:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
006C8:  BRA    051A
....................    }
006CA:  BRA    06CE
....................    else
....................    {
....................       params_load_from_ee();
006CC:  BRA    05FE
....................    }
006CE:  GOTO   A72E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
0017A:  MOVLW  1F
0017C:  MOVWF  F8A
0017E:  BSF    F85.5
....................    output_high(_CS1);
00180:  MOVWF  F8A
00182:  BSF    F85.6
....................    output_high(_CS2);
00184:  MOVWF  F8A
00186:  BSF    F85.7
....................    output_high(_CS3); 
00188:  MOVLW  04
0018A:  MOVWF  F88
0018C:  BSF    F83.0
....................    delay_us(10);
0018E:  MOVLW  35
00190:  MOVWF  00
00192:  DECFSZ 00,F
00194:  BRA    0192
00196:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
006D2:  RCALL  017A
....................    switch(ch)
006D4:  MOVLB  7
006D6:  MOVF   x0C,W
006D8:  ADDLW  FC
006DA:  BC    070E
006DC:  ADDLW  04
006DE:  MOVLB  0
006E0:  GOTO   071A
....................    {
....................       case 0:
....................          output_low(_CS0);
006E4:  MOVLW  1F
006E6:  MOVWF  F8A
006E8:  BCF    F85.5
....................       break; 
006EA:  MOVLB  7
006EC:  BRA    070E
....................       case 1:
....................          output_low(_CS1);
006EE:  MOVLW  1F
006F0:  MOVWF  F8A
006F2:  BCF    F85.6
....................       break;   
006F4:  MOVLB  7
006F6:  BRA    070E
....................       case 2:
....................          output_low(_CS2);
006F8:  MOVLW  1F
006FA:  MOVWF  F8A
006FC:  BCF    F85.7
....................       break;
006FE:  MOVLB  7
00700:  BRA    070E
....................       case 3:
....................          output_low(_CS3);
00702:  MOVLW  04
00704:  MOVWF  F88
00706:  BCF    F83.0
....................       break;              
00708:  MOVLB  7
0070A:  BRA    070E
0070C:  MOVLB  7
....................    }
....................    delay_us(10);
0070E:  MOVLW  35
00710:  MOVWF  00
00712:  DECFSZ 00,F
00714:  BRA    0712
00716:  MOVLB  0
00718:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00198:  RCALL  017A
....................    switch(block)
0019A:  MOVLB  7
0019C:  MOVF   x74,W
0019E:  XORLW  00
001A0:  MOVLB  0
001A2:  BZ    01AA
001A4:  XORLW  01
001A6:  BZ    01B6
001A8:  BRA    01C2
....................    {
....................       case 0:
....................          output_low(_CS0);
001AA:  MOVLW  1F
001AC:  MOVWF  F8A
001AE:  BCF    F85.5
....................          output_low(_CS1);
001B0:  MOVWF  F8A
001B2:  BCF    F85.6
....................       break; 
001B4:  BRA    01C2
....................       case 1:         
....................          output_low(_CS2);
001B6:  MOVLW  1F
001B8:  MOVWF  F8A
001BA:  BCF    F85.7
....................          output_low(_CS3);
001BC:  MOVLW  04
001BE:  MOVWF  F88
001C0:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
001C2:  MOVLW  35
001C4:  MOVWF  00
001C6:  DECFSZ 00,F
001C8:  BRA    01C6
001CA:  GOTO   01D4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007EE:  MOVLW  1F
007F0:  MOVWF  F8A
007F2:  BCF    F85.5
....................    output_low(_CS1);
007F4:  MOVWF  F8A
007F6:  BCF    F85.6
....................    output_low(_CS2);
007F8:  MOVWF  F8A
007FA:  BCF    F85.7
....................    output_low(_CS3);
007FC:  MOVLW  04
007FE:  MOVWF  F88
00800:  BCF    F83.0
....................    delay_us(10);
00802:  MOVLW  35
00804:  MOVWF  00
00806:  DECFSZ 00,F
00808:  BRA    0806
0080A:  GOTO   0810 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0073C:  MOVFF  70A,70C
00740:  RCALL  06D2
....................    spi_write2(command);
00742:  MOVLB  E
00744:  MOVF   x8D,W
00746:  MOVFF  70B,E8D
0074A:  RRCF   x90,W
0074C:  BNC   074A
0074E:  MOVLB  0
00750:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001CE:  MOVFF  772,774
001D2:  BRA    0198
....................    spi_write2(command);
001D4:  MOVLB  E
001D6:  MOVF   x8D,W
001D8:  MOVFF  773,E8D
001DC:  RRCF   x90,W
001DE:  BNC   01DC
001E0:  MOVLB  0
001E2:  GOTO   01F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
0080E:  BRA    07EE
....................    spi_write2(command);
00810:  MOVLB  E
00812:  MOVF   x8D,W
00814:  MOVFF  701,E8D
00818:  RRCF   x90,W
0081A:  BNC   0818
0081C:  MOVLB  0
0081E:  GOTO   082C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0083A:  MOVFF  709,70C
0083E:  RCALL  06D2
....................    spi_read2(command);
00840:  MOVLB  E
00842:  MOVF   x8D,W
00844:  MOVFF  70A,E8D
00848:  RRCF   x90,W
0084A:  BNC   0848
0084C:  MOVLB  0
0084E:  GOTO   0860 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00752:  MOVLB  7
00754:  MOVF   x07,W
00756:  IORLW  40
00758:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0075A:  MOVFF  706,70A
0075E:  MOVFF  709,70B
00762:  MOVLB  0
00764:  RCALL  073C
....................    spi_write2(data);
00766:  MOVLB  E
00768:  MOVF   x8D,W
0076A:  MOVFF  708,E8D
0076E:  RRCF   x90,W
00770:  BNC   076E
....................    ads_deselect_all();
00772:  MOVLB  0
00774:  RCALL  017A
00776:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001E6:  MOVFF  771,772
001EA:  MOVLW  08
001EC:  MOVLB  7
001EE:  MOVWF  x73
001F0:  MOVLB  0
001F2:  BRA    01CE
....................    delay_us(10);
001F4:  MOVLW  35
001F6:  MOVWF  00
001F8:  DECFSZ 00,F
001FA:  BRA    01F8
....................    ads_deselect_all();
001FC:  RCALL  017A
001FE:  GOTO   0244 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
00822:  MOVLW  08
00824:  MOVLB  7
00826:  MOVWF  x01
00828:  MOVLB  0
0082A:  BRA    080E
....................    delay_us(10);
0082C:  MOVLW  35
0082E:  MOVWF  00
00830:  DECFSZ 00,F
00832:  BRA    0830
....................    ads_deselect_all();
00834:  RCALL  017A
00836:  GOTO   09BC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00852:  MOVFF  704,709
00856:  MOVLW  10
00858:  MOVLB  7
0085A:  MOVWF  x0A
0085C:  MOVLB  0
0085E:  BRA    083A
....................    data.dBytes[3] = 0;
00860:  MOVLB  7
00862:  CLRF   x08
....................    data.dBytes[2] = spi_read2(0);
00864:  MOVLB  E
00866:  MOVF   x8D,W
00868:  CLRF   x8D
0086A:  RRCF   x90,W
0086C:  BNC   086A
0086E:  MOVFF  E8D,707
....................    data.dBytes[1] = spi_read2(0);
00872:  MOVF   x8D,W
00874:  CLRF   x8D
00876:  RRCF   x90,W
00878:  BNC   0876
0087A:  MOVFF  E8D,706
....................    data.dBytes[0] = spi_read2(0);
0087E:  MOVF   x8D,W
00880:  CLRF   x8D
00882:  RRCF   x90,W
00884:  BNC   0882
00886:  MOVFF  E8D,705
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
0088A:  MOVLB  7
0088C:  MOVF   x07,W
0088E:  ANDLW  80
00890:  BZ    0896
00892:  MOVLW  FF
00894:  IORWF  x08,F
....................    
....................    ads_deselect_all();
00896:  MOVLB  0
00898:  RCALL  017A
....................    return data.dWord;
0089A:  MOVFF  705,00
0089E:  MOVFF  706,01
008A2:  MOVFF  707,02
008A6:  MOVFF  708,03
008AA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00778:  MOVFF  701,70A
0077C:  MOVLW  06
0077E:  MOVLB  7
00780:  MOVWF  x0B
00782:  MOVLB  0
00784:  RCALL  073C
....................    delay_us(300);                    
00786:  MOVLW  02
00788:  MOVLB  7
0078A:  MOVWF  x06
0078C:  CLRF   19
0078E:  BTFSC  FF2.7
00790:  BSF    19.7
00792:  BCF    FF2.7
00794:  MOVLW  96
00796:  MOVWF  x72
00798:  MOVLB  0
0079A:  RCALL  00CA
0079C:  BTFSC  19.7
0079E:  BSF    FF2.7
007A0:  MOVLB  7
007A2:  DECFSZ x06,F
007A4:  BRA    078C
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
007A6:  MOVFF  701,706
007AA:  CLRF   x07
007AC:  MOVFF  702,708
007B0:  MOVLB  0
007B2:  RCALL  0752
....................    ads_write_reg(ch, reg1, rc1);
007B4:  MOVFF  701,706
007B8:  MOVLW  04
007BA:  MOVLB  7
007BC:  MOVWF  x07
007BE:  MOVFF  703,708
007C2:  MOVLB  0
007C4:  RCALL  0752
....................    ads_write_reg(ch, reg2, rc2);
007C6:  MOVFF  701,706
007CA:  MOVLW  08
007CC:  MOVLB  7
007CE:  MOVWF  x07
007D0:  MOVFF  704,708
007D4:  MOVLB  0
007D6:  RCALL  0752
....................    ads_write_reg(ch, reg3, rc3);  
007D8:  MOVFF  701,706
007DC:  MOVLW  0C
007DE:  MOVLB  7
007E0:  MOVWF  x07
007E2:  MOVFF  705,708
007E6:  MOVLB  0
007E8:  RCALL  0752
007EA:  GOTO   0996 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02752:  MOVLB  7
02754:  BCF    x45.0
....................    y = x;
02756:  MOVFF  739,73E
0275A:  MOVFF  738,73D
0275E:  MOVFF  737,73C
02762:  MOVFF  736,73B
.................... 
....................    if (x < 0)
02766:  MOVFF  739,749
0276A:  MOVFF  738,748
0276E:  MOVFF  737,747
02772:  MOVFF  736,746
02776:  CLRF   x4D
02778:  CLRF   x4C
0277A:  CLRF   x4B
0277C:  CLRF   x4A
0277E:  MOVLB  0
02780:  CALL   1D22
02784:  BNC   2792
....................    {
....................       s = 1;
02786:  MOVLB  7
02788:  BSF    x45.0
....................       y = -y;
0278A:  MOVF   x3C,W
0278C:  XORLW  80
0278E:  MOVWF  x3C
02790:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02792:  MOVFF  73E,749
02796:  MOVFF  73D,748
0279A:  MOVFF  73C,747
0279E:  MOVFF  73B,746
027A2:  MOVLB  7
027A4:  CLRF   x4D
027A6:  CLRF   x4C
027A8:  CLRF   x4B
027AA:  MOVLW  8E
027AC:  MOVWF  x4A
027AE:  MOVLB  0
027B0:  CALL   1D22
027B4:  BC    27B8
027B6:  BNZ   27E8
....................       res = (float32)(unsigned int16)y;
027B8:  MOVFF  73E,749
027BC:  MOVFF  73D,748
027C0:  MOVFF  73C,747
027C4:  MOVFF  73B,746
027C8:  RCALL  2716
027CA:  MOVFF  02,74B
027CE:  MOVFF  01,74A
027D2:  CALL   0D60
027D6:  MOVFF  03,742
027DA:  MOVFF  02,741
027DE:  MOVFF  01,740
027E2:  MOVFF  00,73F
027E6:  BRA    298A
.................... 
....................  else if (y < 10000000.0)
027E8:  MOVFF  73E,749
027EC:  MOVFF  73D,748
027F0:  MOVFF  73C,747
027F4:  MOVFF  73B,746
027F8:  MOVLW  80
027FA:  MOVLB  7
027FC:  MOVWF  x4D
027FE:  MOVLW  96
02800:  MOVWF  x4C
02802:  MOVLW  18
02804:  MOVWF  x4B
02806:  MOVLW  96
02808:  MOVWF  x4A
0280A:  MOVLB  0
0280C:  CALL   1D22
02810:  BTFSS  FD8.0
02812:  BRA    297A
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02814:  MOVFF  73E,753
02818:  MOVFF  73D,752
0281C:  MOVFF  73C,751
02820:  MOVFF  73B,750
02824:  MOVLB  7
02826:  CLRF   x57
02828:  CLRF   x56
0282A:  CLRF   x55
0282C:  MOVLW  70
0282E:  MOVWF  x54
02830:  MOVLB  0
02832:  CALL   0D96
02836:  MOVFF  03,749
0283A:  MOVFF  02,748
0283E:  MOVFF  01,747
02842:  MOVFF  00,746
02846:  RCALL  2716
02848:  MOVFF  02,744
0284C:  MOVFF  01,743
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02850:  MOVFF  73E,753
02854:  MOVFF  73D,752
02858:  MOVFF  73C,751
0285C:  MOVFF  73B,750
02860:  MOVLB  7
02862:  CLRF   x57
02864:  CLRF   x56
02866:  CLRF   x55
02868:  MOVLW  70
0286A:  MOVWF  x54
0286C:  MOVLB  0
0286E:  CALL   0D96
02872:  MOVFF  03,749
02876:  MOVFF  02,748
0287A:  MOVFF  01,747
0287E:  MOVFF  00,746
02882:  MOVFF  744,74B
02886:  MOVFF  743,74A
0288A:  CALL   0D60
0288E:  BSF    FD8.1
02890:  MOVFF  749,74D
02894:  MOVFF  748,74C
02898:  MOVFF  747,74B
0289C:  MOVFF  746,74A
028A0:  MOVFF  03,751
028A4:  MOVFF  02,750
028A8:  MOVFF  01,74F
028AC:  MOVFF  00,74E
028B0:  CALL   0E8C
028B4:  MOVLB  7
028B6:  CLRF   x53
028B8:  CLRF   x52
028BA:  CLRF   x51
028BC:  MOVLW  8E
028BE:  MOVWF  x50
028C0:  MOVFF  03,757
028C4:  MOVFF  02,756
028C8:  MOVFF  01,755
028CC:  MOVFF  00,754
028D0:  MOVLB  0
028D2:  CALL   0D96
028D6:  MOVFF  03,73E
028DA:  MOVFF  02,73D
028DE:  MOVFF  01,73C
028E2:  MOVFF  00,73B
....................       res = 32768.0*(float32)l;
028E6:  MOVFF  744,74B
028EA:  MOVFF  743,74A
028EE:  CALL   0D60
028F2:  MOVLB  7
028F4:  CLRF   x53
028F6:  CLRF   x52
028F8:  CLRF   x51
028FA:  MOVLW  8E
028FC:  MOVWF  x50
028FE:  MOVFF  03,757
02902:  MOVFF  02,756
02906:  MOVFF  01,755
0290A:  MOVFF  00,754
0290E:  MOVLB  0
02910:  CALL   0D96
02914:  MOVFF  03,742
02918:  MOVFF  02,741
0291C:  MOVFF  01,740
02920:  MOVFF  00,73F
....................       res += (float32)(unsigned int16)y;
02924:  MOVFF  73E,749
02928:  MOVFF  73D,748
0292C:  MOVFF  73C,747
02930:  MOVFF  73B,746
02934:  RCALL  2716
02936:  MOVFF  02,74B
0293A:  MOVFF  01,74A
0293E:  CALL   0D60
02942:  BCF    FD8.1
02944:  MOVFF  742,74D
02948:  MOVFF  741,74C
0294C:  MOVFF  740,74B
02950:  MOVFF  73F,74A
02954:  MOVFF  03,751
02958:  MOVFF  02,750
0295C:  MOVFF  01,74F
02960:  MOVFF  00,74E
02964:  CALL   0E8C
02968:  MOVFF  03,742
0296C:  MOVFF  02,741
02970:  MOVFF  01,740
02974:  MOVFF  00,73F
....................    }
02978:  BRA    298A
.................... 
....................  else
....................   res = y;
0297A:  MOVFF  73E,742
0297E:  MOVFF  73D,741
02982:  MOVFF  73C,740
02986:  MOVFF  73B,73F
.................... 
....................  y = y - (float32)(unsigned int16)y;
0298A:  MOVFF  73E,749
0298E:  MOVFF  73D,748
02992:  MOVFF  73C,747
02996:  MOVFF  73B,746
0299A:  RCALL  2716
0299C:  MOVFF  02,74B
029A0:  MOVFF  01,74A
029A4:  CALL   0D60
029A8:  BSF    FD8.1
029AA:  MOVFF  73E,74D
029AE:  MOVFF  73D,74C
029B2:  MOVFF  73C,74B
029B6:  MOVFF  73B,74A
029BA:  MOVFF  03,751
029BE:  MOVFF  02,750
029C2:  MOVFF  01,74F
029C6:  MOVFF  00,74E
029CA:  CALL   0E8C
029CE:  MOVFF  03,73E
029D2:  MOVFF  02,73D
029D6:  MOVFF  01,73C
029DA:  MOVFF  00,73B
.................... 
....................  if (s)
029DE:  MOVLB  7
029E0:  BTFSS  x45.0
029E2:  BRA    29EA
....................   res = -res;
029E4:  MOVF   x40,W
029E6:  XORLW  80
029E8:  MOVWF  x40
.................... 
....................  if (y != 0)
029EA:  MOVFF  73E,749
029EE:  MOVFF  73D,748
029F2:  MOVFF  73C,747
029F6:  MOVFF  73B,746
029FA:  CLRF   x4D
029FC:  CLRF   x4C
029FE:  CLRF   x4B
02A00:  CLRF   x4A
02A02:  MOVLB  0
02A04:  CALL   1D22
02A08:  BZ    2A82
....................  {
....................   if (s == 1 && n == 0)
02A0A:  MOVLB  7
02A0C:  BTFSS  x45.0
02A0E:  BRA    2A48
02A10:  MOVF   x3A,F
02A12:  BNZ   2A48
....................    res -= 1.0;
02A14:  BSF    FD8.1
02A16:  MOVFF  742,74D
02A1A:  MOVFF  741,74C
02A1E:  MOVFF  740,74B
02A22:  MOVFF  73F,74A
02A26:  CLRF   x51
02A28:  CLRF   x50
02A2A:  CLRF   x4F
02A2C:  MOVLW  7F
02A2E:  MOVWF  x4E
02A30:  MOVLB  0
02A32:  CALL   0E8C
02A36:  MOVFF  03,742
02A3A:  MOVFF  02,741
02A3E:  MOVFF  01,740
02A42:  MOVFF  00,73F
02A46:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A48:  BTFSC  x45.0
02A4A:  BRA    2A84
02A4C:  DECFSZ x3A,W
02A4E:  BRA    2A84
....................    res += 1.0;
02A50:  BCF    FD8.1
02A52:  MOVFF  742,74D
02A56:  MOVFF  741,74C
02A5A:  MOVFF  740,74B
02A5E:  MOVFF  73F,74A
02A62:  CLRF   x51
02A64:  CLRF   x50
02A66:  CLRF   x4F
02A68:  MOVLW  7F
02A6A:  MOVWF  x4E
02A6C:  MOVLB  0
02A6E:  CALL   0E8C
02A72:  MOVFF  03,742
02A76:  MOVFF  02,741
02A7A:  MOVFF  01,740
02A7E:  MOVFF  00,73F
02A82:  MOVLB  7
....................  }
....................  if (x == 0)
02A84:  MOVFF  739,749
02A88:  MOVFF  738,748
02A8C:  MOVFF  737,747
02A90:  MOVFF  736,746
02A94:  CLRF   x4D
02A96:  CLRF   x4C
02A98:  CLRF   x4B
02A9A:  CLRF   x4A
02A9C:  MOVLB  0
02A9E:  CALL   1D22
02AA2:  BNZ   2AB0
....................     res = 0;
02AA4:  MOVLB  7
02AA6:  CLRF   x42
02AA8:  CLRF   x41
02AAA:  CLRF   x40
02AAC:  CLRF   x3F
02AAE:  MOVLB  0
.................... 
....................  return (res);
02AB0:  MOVFF  73F,00
02AB4:  MOVFF  740,01
02AB8:  MOVFF  741,02
02ABC:  MOVFF  742,03
02AC0:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AE0:  MOVFF  735,739
02AE4:  MOVFF  734,738
02AE8:  MOVFF  733,737
02AEC:  MOVFF  732,736
02AF0:  MOVLB  7
02AF2:  CLRF   x3A
02AF4:  MOVLB  0
02AF6:  RCALL  2752
02AF8:  GOTO   2C04 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02AC2:  MOVFF  735,739
02AC6:  MOVFF  734,738
02ACA:  MOVFF  733,737
02ACE:  MOVFF  732,736
02AD2:  MOVLW  01
02AD4:  MOVLB  7
02AD6:  MOVWF  x3A
02AD8:  MOVLB  0
02ADA:  RCALL  2752
02ADC:  GOTO   2BBC (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AFC:  MOVFF  729,749
02B00:  MOVFF  728,748
02B04:  MOVFF  727,747
02B08:  MOVFF  726,746
02B0C:  MOVLB  7
02B0E:  CLRF   x4D
02B10:  CLRF   x4C
02B12:  CLRF   x4B
02B14:  CLRF   x4A
02B16:  MOVLB  0
02B18:  CALL   1D22
02B1C:  BTFSC  FD8.2
02B1E:  BRA    2C60
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02B20:  MOVFF  725,742
02B24:  MOVFF  724,741
02B28:  MOVFF  723,740
02B2C:  MOVFF  722,73F
02B30:  MOVFF  729,746
02B34:  MOVFF  728,745
02B38:  MOVFF  727,744
02B3C:  MOVFF  726,743
02B40:  CALL   1D9C
02B44:  MOVFF  03,731
02B48:  MOVFF  02,730
02B4C:  MOVFF  01,72F
02B50:  MOVFF  00,72E
02B54:  MOVFF  03,749
02B58:  MOVFF  02,748
02B5C:  MOVFF  01,747
02B60:  MOVFF  00,746
02B64:  MOVLB  7
02B66:  CLRF   x4D
02B68:  CLRF   x4C
02B6A:  CLRF   x4B
02B6C:  CLRF   x4A
02B6E:  MOVLB  0
02B70:  CALL   1D22
02B74:  BNC   2BBE
02B76:  MOVFF  725,742
02B7A:  MOVFF  724,741
02B7E:  MOVFF  723,740
02B82:  MOVFF  722,73F
02B86:  MOVFF  729,746
02B8A:  MOVFF  728,745
02B8E:  MOVFF  727,744
02B92:  MOVFF  726,743
02B96:  CALL   1D9C
02B9A:  MOVFF  03,731
02B9E:  MOVFF  02,730
02BA2:  MOVFF  01,72F
02BA6:  MOVFF  00,72E
02BAA:  MOVFF  03,735
02BAE:  MOVFF  02,734
02BB2:  MOVFF  01,733
02BB6:  MOVFF  00,732
02BBA:  BRA    2AC2
02BBC:  BRA    2C04
02BBE:  MOVFF  725,742
02BC2:  MOVFF  724,741
02BC6:  MOVFF  723,740
02BCA:  MOVFF  722,73F
02BCE:  MOVFF  729,746
02BD2:  MOVFF  728,745
02BD6:  MOVFF  727,744
02BDA:  MOVFF  726,743
02BDE:  CALL   1D9C
02BE2:  MOVFF  03,731
02BE6:  MOVFF  02,730
02BEA:  MOVFF  01,72F
02BEE:  MOVFF  00,72E
02BF2:  MOVFF  03,735
02BF6:  MOVFF  02,734
02BFA:  MOVFF  01,733
02BFE:  MOVFF  00,732
02C02:  BRA    2AE0
02C04:  MOVFF  03,72D
02C08:  MOVFF  02,72C
02C0C:  MOVFF  01,72B
02C10:  MOVFF  00,72A
....................       return(x-(i*y));
02C14:  MOVFF  72D,753
02C18:  MOVFF  72C,752
02C1C:  MOVFF  72B,751
02C20:  MOVFF  72A,750
02C24:  MOVFF  729,757
02C28:  MOVFF  728,756
02C2C:  MOVFF  727,755
02C30:  MOVFF  726,754
02C34:  CALL   0D96
02C38:  BSF    FD8.1
02C3A:  MOVFF  725,74D
02C3E:  MOVFF  724,74C
02C42:  MOVFF  723,74B
02C46:  MOVFF  722,74A
02C4A:  MOVFF  03,751
02C4E:  MOVFF  02,750
02C52:  MOVFF  01,74F
02C56:  MOVFF  00,74E
02C5A:  CALL   0E8C
02C5E:  BRA    2C60
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C60:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FF6:  MOVFF  729,753
02FFA:  MOVFF  728,752
02FFE:  MOVFF  727,751
03002:  MOVFF  726,750
03006:  MOVLW  3B
03008:  MOVLB  7
0300A:  MOVWF  x57
0300C:  MOVLW  AA
0300E:  MOVWF  x56
03010:  MOVLW  38
03012:  MOVWF  x55
03014:  MOVLW  7F
03016:  MOVWF  x54
03018:  MOVLB  0
0301A:  CALL   0D96
0301E:  MOVFF  03,749
03022:  MOVFF  02,748
03026:  MOVFF  01,747
0302A:  MOVFF  00,746
0302E:  CALL   2716
03032:  MOVFF  01,736
....................    s = 0;
03036:  MOVLB  7
03038:  BCF    x37.0
....................    y = x;
0303A:  MOVFF  729,72D
0303E:  MOVFF  728,72C
03042:  MOVFF  727,72B
03046:  MOVFF  726,72A
.................... 
....................    if (x < 0)
0304A:  MOVFF  729,749
0304E:  MOVFF  728,748
03052:  MOVFF  727,747
03056:  MOVFF  726,746
0305A:  CLRF   x4D
0305C:  CLRF   x4C
0305E:  CLRF   x4B
03060:  CLRF   x4A
03062:  MOVLB  0
03064:  CALL   1D22
03068:  BNC   3078
....................    {
....................       s = 1;
0306A:  MOVLB  7
0306C:  BSF    x37.0
....................       n = -n;
0306E:  NEGF   x36
....................       y = -y;
03070:  MOVF   x2B,W
03072:  XORLW  80
03074:  MOVWF  x2B
03076:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03078:  MOVLB  7
0307A:  CLRF   x31
0307C:  CLRF   x30
0307E:  CLRF   x2F
03080:  CLRF   x2E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03082:  MOVLW  07
03084:  MOVWF  x39
03086:  MOVLW  2E
03088:  MOVFF  739,FEA
0308C:  MOVWF  FE9
0308E:  MOVLW  7F
03090:  ADDWF  x36,W
03092:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03094:  MOVFF  72D,753
03098:  MOVFF  72C,752
0309C:  MOVFF  72B,751
030A0:  MOVFF  72A,750
030A4:  MOVLW  3B
030A6:  MOVWF  x57
030A8:  MOVLW  AA
030AA:  MOVWF  x56
030AC:  MOVLW  38
030AE:  MOVWF  x55
030B0:  MOVLW  7F
030B2:  MOVWF  x54
030B4:  MOVLB  0
030B6:  CALL   0D96
030BA:  MOVFF  03,73B
030BE:  MOVFF  02,73A
030C2:  MOVFF  01,739
030C6:  MOVFF  00,738
030CA:  MOVLB  7
030CC:  CLRF   x3D
030CE:  MOVFF  736,73C
030D2:  BTFSC  x3C.7
030D4:  DECF   x3D,F
030D6:  MOVLB  0
030D8:  CALL   26C6
030DC:  BSF    FD8.1
030DE:  MOVFF  73B,74D
030E2:  MOVFF  73A,74C
030E6:  MOVFF  739,74B
030EA:  MOVFF  738,74A
030EE:  MOVFF  03,751
030F2:  MOVFF  02,750
030F6:  MOVFF  01,74F
030FA:  MOVFF  00,74E
030FE:  CALL   0E8C
03102:  MOVFF  03,72D
03106:  MOVFF  02,72C
0310A:  MOVFF  01,72B
0310E:  MOVFF  00,72A
.................... 
....................    r = pe[0]*y + pe[1];
03112:  MOVLW  7C
03114:  MOVLB  7
03116:  MOVWF  x53
03118:  MOVLW  88
0311A:  MOVWF  x52
0311C:  MOVLW  59
0311E:  MOVWF  x51
03120:  MOVLW  72
03122:  MOVWF  x50
03124:  MOVFF  72D,757
03128:  MOVFF  72C,756
0312C:  MOVFF  72B,755
03130:  MOVFF  72A,754
03134:  MOVLB  0
03136:  CALL   0D96
0313A:  MOVFF  03,73B
0313E:  MOVFF  02,73A
03142:  MOVFF  01,739
03146:  MOVFF  00,738
0314A:  BCF    FD8.1
0314C:  MOVFF  03,74D
03150:  MOVFF  02,74C
03154:  MOVFF  01,74B
03158:  MOVFF  00,74A
0315C:  MOVLW  E0
0315E:  MOVLB  7
03160:  MOVWF  x51
03162:  MOVLW  97
03164:  MOVWF  x50
03166:  MOVLW  26
03168:  MOVWF  x4F
0316A:  MOVLW  75
0316C:  MOVWF  x4E
0316E:  MOVLB  0
03170:  CALL   0E8C
03174:  MOVFF  03,735
03178:  MOVFF  02,734
0317C:  MOVFF  01,733
03180:  MOVFF  00,732
....................    r = r*y + pe[2];
03184:  MOVFF  735,753
03188:  MOVFF  734,752
0318C:  MOVFF  733,751
03190:  MOVFF  732,750
03194:  MOVFF  72D,757
03198:  MOVFF  72C,756
0319C:  MOVFF  72B,755
031A0:  MOVFF  72A,754
031A4:  CALL   0D96
031A8:  MOVFF  03,73B
031AC:  MOVFF  02,73A
031B0:  MOVFF  01,739
031B4:  MOVFF  00,738
031B8:  BCF    FD8.1
031BA:  MOVFF  03,74D
031BE:  MOVFF  02,74C
031C2:  MOVFF  01,74B
031C6:  MOVFF  00,74A
031CA:  MOVLW  C4
031CC:  MOVLB  7
031CE:  MOVWF  x51
031D0:  MOVLW  1D
031D2:  MOVWF  x50
031D4:  MOVLW  1E
031D6:  MOVWF  x4F
031D8:  MOVLW  78
031DA:  MOVWF  x4E
031DC:  MOVLB  0
031DE:  CALL   0E8C
031E2:  MOVFF  03,735
031E6:  MOVFF  02,734
031EA:  MOVFF  01,733
031EE:  MOVFF  00,732
....................    r = r*y + pe[3];
031F2:  MOVFF  735,753
031F6:  MOVFF  734,752
031FA:  MOVFF  733,751
031FE:  MOVFF  732,750
03202:  MOVFF  72D,757
03206:  MOVFF  72C,756
0320A:  MOVFF  72B,755
0320E:  MOVFF  72A,754
03212:  CALL   0D96
03216:  MOVFF  03,73B
0321A:  MOVFF  02,73A
0321E:  MOVFF  01,739
03222:  MOVFF  00,738
03226:  BCF    FD8.1
03228:  MOVFF  03,74D
0322C:  MOVFF  02,74C
03230:  MOVFF  01,74B
03234:  MOVFF  00,74A
03238:  MOVLW  5E
0323A:  MOVLB  7
0323C:  MOVWF  x51
0323E:  MOVLW  50
03240:  MOVWF  x50
03242:  MOVLW  63
03244:  MOVWF  x4F
03246:  MOVLW  7A
03248:  MOVWF  x4E
0324A:  MOVLB  0
0324C:  CALL   0E8C
03250:  MOVFF  03,735
03254:  MOVFF  02,734
03258:  MOVFF  01,733
0325C:  MOVFF  00,732
....................    r = r*y + pe[4];
03260:  MOVFF  735,753
03264:  MOVFF  734,752
03268:  MOVFF  733,751
0326C:  MOVFF  732,750
03270:  MOVFF  72D,757
03274:  MOVFF  72C,756
03278:  MOVFF  72B,755
0327C:  MOVFF  72A,754
03280:  CALL   0D96
03284:  MOVFF  03,73B
03288:  MOVFF  02,73A
0328C:  MOVFF  01,739
03290:  MOVFF  00,738
03294:  BCF    FD8.1
03296:  MOVFF  03,74D
0329A:  MOVFF  02,74C
0329E:  MOVFF  01,74B
032A2:  MOVFF  00,74A
032A6:  MOVLW  1A
032A8:  MOVLB  7
032AA:  MOVWF  x51
032AC:  MOVLW  FE
032AE:  MOVWF  x50
032B0:  MOVLW  75
032B2:  MOVWF  x4F
032B4:  MOVLW  7C
032B6:  MOVWF  x4E
032B8:  MOVLB  0
032BA:  CALL   0E8C
032BE:  MOVFF  03,735
032C2:  MOVFF  02,734
032C6:  MOVFF  01,733
032CA:  MOVFF  00,732
....................    r = r*y + pe[5];
032CE:  MOVFF  735,753
032D2:  MOVFF  734,752
032D6:  MOVFF  733,751
032DA:  MOVFF  732,750
032DE:  MOVFF  72D,757
032E2:  MOVFF  72C,756
032E6:  MOVFF  72B,755
032EA:  MOVFF  72A,754
032EE:  CALL   0D96
032F2:  MOVFF  03,73B
032F6:  MOVFF  02,73A
032FA:  MOVFF  01,739
032FE:  MOVFF  00,738
03302:  BCF    FD8.1
03304:  MOVFF  03,74D
03308:  MOVFF  02,74C
0330C:  MOVFF  01,74B
03310:  MOVFF  00,74A
03314:  MOVLW  18
03316:  MOVLB  7
03318:  MOVWF  x51
0331A:  MOVLW  72
0331C:  MOVWF  x50
0331E:  MOVLW  31
03320:  MOVWF  x4F
03322:  MOVLW  7E
03324:  MOVWF  x4E
03326:  MOVLB  0
03328:  CALL   0E8C
0332C:  MOVFF  03,735
03330:  MOVFF  02,734
03334:  MOVFF  01,733
03338:  MOVFF  00,732
.................... 
....................    res = res*(1.0 + y*r);
0333C:  MOVFF  72D,753
03340:  MOVFF  72C,752
03344:  MOVFF  72B,751
03348:  MOVFF  72A,750
0334C:  MOVFF  735,757
03350:  MOVFF  734,756
03354:  MOVFF  733,755
03358:  MOVFF  732,754
0335C:  CALL   0D96
03360:  BCF    FD8.1
03362:  MOVLB  7
03364:  CLRF   x4D
03366:  CLRF   x4C
03368:  CLRF   x4B
0336A:  MOVLW  7F
0336C:  MOVWF  x4A
0336E:  MOVFF  03,751
03372:  MOVFF  02,750
03376:  MOVFF  01,74F
0337A:  MOVFF  00,74E
0337E:  MOVLB  0
03380:  CALL   0E8C
03384:  MOVFF  731,753
03388:  MOVFF  730,752
0338C:  MOVFF  72F,751
03390:  MOVFF  72E,750
03394:  MOVFF  03,757
03398:  MOVFF  02,756
0339C:  MOVFF  01,755
033A0:  MOVFF  00,754
033A4:  CALL   0D96
033A8:  MOVFF  03,731
033AC:  MOVFF  02,730
033B0:  MOVFF  01,72F
033B4:  MOVFF  00,72E
.................... 
....................    if (s)
033B8:  MOVLB  7
033BA:  BTFSS  x37.0
033BC:  BRA    33F0
....................       res = 1.0/res;
033BE:  CLRF   x42
033C0:  CLRF   x41
033C2:  CLRF   x40
033C4:  MOVLW  7F
033C6:  MOVWF  x3F
033C8:  MOVFF  731,746
033CC:  MOVFF  730,745
033D0:  MOVFF  72F,744
033D4:  MOVFF  72E,743
033D8:  MOVLB  0
033DA:  CALL   1D9C
033DE:  MOVFF  03,731
033E2:  MOVFF  02,730
033E6:  MOVFF  01,72F
033EA:  MOVFF  00,72E
033EE:  MOVLB  7
....................    return(res);
033F0:  MOVFF  72E,00
033F4:  MOVFF  72F,01
033F8:  MOVFF  730,02
033FC:  MOVFF  731,03
03400:  MOVLB  0
03402:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C62:  MOVFF  729,72D
02C66:  MOVFF  728,72C
02C6A:  MOVFF  727,72B
02C6E:  MOVFF  726,72A
.................... 
....................    if (y != 1.0)
02C72:  MOVFF  72D,749
02C76:  MOVFF  72C,748
02C7A:  MOVFF  72B,747
02C7E:  MOVFF  72A,746
02C82:  MOVLB  7
02C84:  CLRF   x4D
02C86:  CLRF   x4C
02C88:  CLRF   x4B
02C8A:  MOVLW  7F
02C8C:  MOVWF  x4A
02C8E:  MOVLB  0
02C90:  CALL   1D22
02C94:  BTFSC  FD8.2
02C96:  BRA    2FD8
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C98:  MOVLW  07
02C9A:  MOVLB  7
02C9C:  MOVWF  x3C
02C9E:  MOVLW  2A
02CA0:  MOVFF  73C,FEA
02CA4:  MOVWF  FE9
02CA6:  MOVLW  7E
02CA8:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02CAA:  BSF    FD8.1
02CAC:  MOVFF  72D,74D
02CB0:  MOVFF  72C,74C
02CB4:  MOVFF  72B,74B
02CB8:  MOVFF  72A,74A
02CBC:  CLRF   x51
02CBE:  CLRF   x50
02CC0:  CLRF   x4F
02CC2:  MOVLW  7F
02CC4:  MOVWF  x4E
02CC6:  MOVLB  0
02CC8:  CALL   0E8C
02CCC:  MOVFF  03,73E
02CD0:  MOVFF  02,73D
02CD4:  MOVFF  01,73C
02CD8:  MOVFF  00,73B
02CDC:  BCF    FD8.1
02CDE:  MOVFF  72D,74D
02CE2:  MOVFF  72C,74C
02CE6:  MOVFF  72B,74B
02CEA:  MOVFF  72A,74A
02CEE:  MOVLB  7
02CF0:  CLRF   x51
02CF2:  CLRF   x50
02CF4:  CLRF   x4F
02CF6:  MOVLW  7F
02CF8:  MOVWF  x4E
02CFA:  MOVLB  0
02CFC:  CALL   0E8C
02D00:  MOVFF  73E,742
02D04:  MOVFF  73D,741
02D08:  MOVFF  73C,740
02D0C:  MOVFF  73B,73F
02D10:  MOVFF  03,746
02D14:  MOVFF  02,745
02D18:  MOVFF  01,744
02D1C:  MOVFF  00,743
02D20:  CALL   1D9C
02D24:  MOVFF  03,72D
02D28:  MOVFF  02,72C
02D2C:  MOVFF  01,72B
02D30:  MOVFF  00,72A
.................... 
....................       y2=y*y;
02D34:  MOVFF  72D,753
02D38:  MOVFF  72C,752
02D3C:  MOVFF  72B,751
02D40:  MOVFF  72A,750
02D44:  MOVFF  72D,757
02D48:  MOVFF  72C,756
02D4C:  MOVFF  72B,755
02D50:  MOVFF  72A,754
02D54:  CALL   0D96
02D58:  MOVFF  03,739
02D5C:  MOVFF  02,738
02D60:  MOVFF  01,737
02D64:  MOVFF  00,736
.................... 
....................       res = pl[0]*y2 + pl[1];
02D68:  MOVLW  99
02D6A:  MOVLB  7
02D6C:  MOVWF  x53
02D6E:  MOVLW  47
02D70:  MOVWF  x52
02D72:  MOVLW  8A
02D74:  MOVWF  x51
02D76:  MOVLW  7F
02D78:  MOVWF  x50
02D7A:  MOVFF  739,757
02D7E:  MOVFF  738,756
02D82:  MOVFF  737,755
02D86:  MOVFF  736,754
02D8A:  MOVLB  0
02D8C:  CALL   0D96
02D90:  MOVFF  03,73E
02D94:  MOVFF  02,73D
02D98:  MOVFF  01,73C
02D9C:  MOVFF  00,73B
02DA0:  BCF    FD8.1
02DA2:  MOVFF  03,74D
02DA6:  MOVFF  02,74C
02DAA:  MOVFF  01,74B
02DAE:  MOVFF  00,74A
02DB2:  MOVLB  7
02DB4:  CLRF   x51
02DB6:  CLRF   x50
02DB8:  CLRF   x4F
02DBA:  MOVLW  80
02DBC:  MOVWF  x4E
02DBE:  MOVLB  0
02DC0:  CALL   0E8C
02DC4:  MOVFF  03,731
02DC8:  MOVFF  02,730
02DCC:  MOVFF  01,72F
02DD0:  MOVFF  00,72E
.................... 
....................       r = ql[0]*y2 + ql[1];
02DD4:  MOVLW  4C
02DD6:  MOVLB  7
02DD8:  MOVWF  x53
02DDA:  MOVLW  F3
02DDC:  MOVWF  x52
02DDE:  MOVLW  3A
02DE0:  MOVWF  x51
02DE2:  MOVLW  7B
02DE4:  MOVWF  x50
02DE6:  MOVFF  739,757
02DEA:  MOVFF  738,756
02DEE:  MOVFF  737,755
02DF2:  MOVFF  736,754
02DF6:  MOVLB  0
02DF8:  CALL   0D96
02DFC:  MOVFF  03,73E
02E00:  MOVFF  02,73D
02E04:  MOVFF  01,73C
02E08:  MOVFF  00,73B
02E0C:  BCF    FD8.1
02E0E:  MOVFF  03,74D
02E12:  MOVFF  02,74C
02E16:  MOVFF  01,74B
02E1A:  MOVFF  00,74A
02E1E:  MOVLW  2B
02E20:  MOVLB  7
02E22:  MOVWF  x51
02E24:  MOVLW  9D
02E26:  MOVWF  x50
02E28:  MOVLW  DF
02E2A:  MOVWF  x4F
02E2C:  MOVLW  7E
02E2E:  MOVWF  x4E
02E30:  MOVLB  0
02E32:  CALL   0E8C
02E36:  MOVFF  03,735
02E3A:  MOVFF  02,734
02E3E:  MOVFF  01,733
02E42:  MOVFF  00,732
....................       r = r*y2 + 1.0;
02E46:  MOVFF  735,753
02E4A:  MOVFF  734,752
02E4E:  MOVFF  733,751
02E52:  MOVFF  732,750
02E56:  MOVFF  739,757
02E5A:  MOVFF  738,756
02E5E:  MOVFF  737,755
02E62:  MOVFF  736,754
02E66:  CALL   0D96
02E6A:  MOVFF  03,73E
02E6E:  MOVFF  02,73D
02E72:  MOVFF  01,73C
02E76:  MOVFF  00,73B
02E7A:  BCF    FD8.1
02E7C:  MOVFF  03,74D
02E80:  MOVFF  02,74C
02E84:  MOVFF  01,74B
02E88:  MOVFF  00,74A
02E8C:  MOVLB  7
02E8E:  CLRF   x51
02E90:  CLRF   x50
02E92:  CLRF   x4F
02E94:  MOVLW  7F
02E96:  MOVWF  x4E
02E98:  MOVLB  0
02E9A:  CALL   0E8C
02E9E:  MOVFF  03,735
02EA2:  MOVFF  02,734
02EA6:  MOVFF  01,733
02EAA:  MOVFF  00,732
.................... 
....................       res = y*res/r;
02EAE:  MOVFF  72D,753
02EB2:  MOVFF  72C,752
02EB6:  MOVFF  72B,751
02EBA:  MOVFF  72A,750
02EBE:  MOVFF  731,757
02EC2:  MOVFF  730,756
02EC6:  MOVFF  72F,755
02ECA:  MOVFF  72E,754
02ECE:  CALL   0D96
02ED2:  MOVFF  03,73E
02ED6:  MOVFF  02,73D
02EDA:  MOVFF  01,73C
02EDE:  MOVFF  00,73B
02EE2:  MOVFF  03,742
02EE6:  MOVFF  02,741
02EEA:  MOVFF  01,740
02EEE:  MOVFF  00,73F
02EF2:  MOVFF  735,746
02EF6:  MOVFF  734,745
02EFA:  MOVFF  733,744
02EFE:  MOVFF  732,743
02F02:  CALL   1D9C
02F06:  MOVFF  03,731
02F0A:  MOVFF  02,730
02F0E:  MOVFF  01,72F
02F12:  MOVFF  00,72E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02F16:  MOVLW  07
02F18:  MOVLB  7
02F1A:  MOVWF  x3C
02F1C:  MOVLW  26
02F1E:  MOVFF  73C,FEA
02F22:  MOVWF  FE9
02F24:  MOVLW  7E
02F26:  SUBWF  FEF,W
02F28:  MOVWF  x3A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02F2A:  BTFSS  x3A.7
02F2C:  BRA    2F58
....................          r = -(float32)-n;
02F2E:  MOVLW  00
02F30:  BSF    FD8.0
02F32:  SUBFWB x3A,W
02F34:  CLRF   x3D
02F36:  MOVWF  x3C
02F38:  BTFSC  x3C.7
02F3A:  DECF   x3D,F
02F3C:  MOVLB  0
02F3E:  CALL   26C6
02F42:  MOVFF  00,732
02F46:  MOVF   01,W
02F48:  XORLW  80
02F4A:  MOVLB  7
02F4C:  MOVWF  x33
02F4E:  MOVFF  02,734
02F52:  MOVFF  03,735
02F56:  BRA    2F7A
....................       else
....................          r = (float32)n;
02F58:  CLRF   x3D
02F5A:  MOVFF  73A,73C
02F5E:  BTFSC  x3C.7
02F60:  DECF   x3D,F
02F62:  MOVLB  0
02F64:  CALL   26C6
02F68:  MOVFF  03,735
02F6C:  MOVFF  02,734
02F70:  MOVFF  01,733
02F74:  MOVFF  00,732
02F78:  MOVLB  7
.................... 
....................       res += r*LN2;
02F7A:  MOVFF  735,753
02F7E:  MOVFF  734,752
02F82:  MOVFF  733,751
02F86:  MOVFF  732,750
02F8A:  MOVLW  18
02F8C:  MOVWF  x57
02F8E:  MOVLW  72
02F90:  MOVWF  x56
02F92:  MOVLW  31
02F94:  MOVWF  x55
02F96:  MOVLW  7E
02F98:  MOVWF  x54
02F9A:  MOVLB  0
02F9C:  CALL   0D96
02FA0:  BCF    FD8.1
02FA2:  MOVFF  731,74D
02FA6:  MOVFF  730,74C
02FAA:  MOVFF  72F,74B
02FAE:  MOVFF  72E,74A
02FB2:  MOVFF  03,751
02FB6:  MOVFF  02,750
02FBA:  MOVFF  01,74F
02FBE:  MOVFF  00,74E
02FC2:  CALL   0E8C
02FC6:  MOVFF  03,731
02FCA:  MOVFF  02,730
02FCE:  MOVFF  01,72F
02FD2:  MOVFF  00,72E
....................    }
02FD6:  BRA    2FE4
.................... 
....................    else
....................       res = 0.0;
02FD8:  MOVLB  7
02FDA:  CLRF   x31
02FDC:  CLRF   x30
02FDE:  CLRF   x2F
02FE0:  CLRF   x2E
02FE2:  MOVLB  0
.................... 
....................    return(res);
02FE4:  MOVFF  72E,00
02FE8:  MOVFF  72F,01
02FEC:  MOVFF  730,02
02FF0:  MOVFF  731,03
02FF4:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03404:  MOVFF  71D,749
03408:  MOVFF  71C,748
0340C:  MOVFF  71B,747
03410:  MOVFF  71A,746
03414:  MOVLB  7
03416:  CLRF   x4D
03418:  CLRF   x4C
0341A:  CLRF   x4B
0341C:  CLRF   x4A
0341E:  MOVLB  0
03420:  CALL   1D22
03424:  BTFSS  FD8.0
03426:  BRA    35C2
03428:  MOVFF  721,725
0342C:  MOVFF  720,724
03430:  MOVFF  71F,723
03434:  MOVFF  71E,722
03438:  MOVLB  7
0343A:  CLRF   x29
0343C:  CLRF   x28
0343E:  CLRF   x27
03440:  MOVLW  7F
03442:  MOVWF  x26
03444:  MOVLB  0
03446:  CALL   2AFC
0344A:  MOVFF  03,725
0344E:  MOVFF  02,724
03452:  MOVFF  01,723
03456:  MOVFF  00,722
0345A:  MOVFF  03,749
0345E:  MOVFF  02,748
03462:  MOVFF  01,747
03466:  MOVFF  00,746
0346A:  MOVLB  7
0346C:  CLRF   x4D
0346E:  CLRF   x4C
03470:  CLRF   x4B
03472:  CLRF   x4A
03474:  MOVLB  0
03476:  CALL   1D22
0347A:  BTFSS  FD8.2
0347C:  BRA    35C2
....................       if(fmod(y, 2) == 0) {
0347E:  MOVFF  721,725
03482:  MOVFF  720,724
03486:  MOVFF  71F,723
0348A:  MOVFF  71E,722
0348E:  MOVLB  7
03490:  CLRF   x29
03492:  CLRF   x28
03494:  CLRF   x27
03496:  MOVLW  80
03498:  MOVWF  x26
0349A:  MOVLB  0
0349C:  CALL   2AFC
034A0:  MOVFF  03,725
034A4:  MOVFF  02,724
034A8:  MOVFF  01,723
034AC:  MOVFF  00,722
034B0:  MOVFF  03,749
034B4:  MOVFF  02,748
034B8:  MOVFF  01,747
034BC:  MOVFF  00,746
034C0:  MOVLB  7
034C2:  CLRF   x4D
034C4:  CLRF   x4C
034C6:  CLRF   x4B
034C8:  CLRF   x4A
034CA:  MOVLB  0
034CC:  CALL   1D22
034D0:  BNZ   3548
....................          return (exp(log(-x) * y));
034D2:  MOVLB  7
034D4:  MOVF   x1B,W
034D6:  XORLW  80
034D8:  MOVWF  x23
034DA:  MOVFF  71D,729
034DE:  MOVFF  71C,728
034E2:  MOVWF  x27
034E4:  MOVFF  71A,726
034E8:  MOVLB  0
034EA:  CALL   2C62
034EE:  MOVFF  03,725
034F2:  MOVFF  02,724
034F6:  MOVFF  01,723
034FA:  MOVFF  00,722
034FE:  MOVFF  03,753
03502:  MOVFF  02,752
03506:  MOVFF  01,751
0350A:  MOVFF  00,750
0350E:  MOVFF  721,757
03512:  MOVFF  720,756
03516:  MOVFF  71F,755
0351A:  MOVFF  71E,754
0351E:  CALL   0D96
03522:  MOVFF  03,725
03526:  MOVFF  02,724
0352A:  MOVFF  01,723
0352E:  MOVFF  00,722
03532:  MOVFF  03,729
03536:  MOVFF  02,728
0353A:  MOVFF  01,727
0353E:  MOVFF  00,726
03542:  RCALL  2FF6
03544:  BRA    3700
....................       } else {
03546:  BRA    35C0
....................          return (-exp(log(-x) * y));
03548:  MOVLB  7
0354A:  MOVF   x1B,W
0354C:  XORLW  80
0354E:  MOVWF  x23
03550:  MOVFF  71D,729
03554:  MOVFF  71C,728
03558:  MOVWF  x27
0355A:  MOVFF  71A,726
0355E:  MOVLB  0
03560:  CALL   2C62
03564:  MOVFF  03,725
03568:  MOVFF  02,724
0356C:  MOVFF  01,723
03570:  MOVFF  00,722
03574:  MOVFF  03,753
03578:  MOVFF  02,752
0357C:  MOVFF  01,751
03580:  MOVFF  00,750
03584:  MOVFF  721,757
03588:  MOVFF  720,756
0358C:  MOVFF  71F,755
03590:  MOVFF  71E,754
03594:  CALL   0D96
03598:  MOVFF  03,725
0359C:  MOVFF  02,724
035A0:  MOVFF  01,723
035A4:  MOVFF  00,722
035A8:  MOVFF  03,729
035AC:  MOVFF  02,728
035B0:  MOVFF  01,727
035B4:  MOVFF  00,726
035B8:  RCALL  2FF6
035BA:  MOVLW  80
035BC:  XORWF  01,F
035BE:  BRA    3700
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
035C0:  BRA    3700
035C2:  MOVFF  71D,749
035C6:  MOVFF  71C,748
035CA:  MOVFF  71B,747
035CE:  MOVFF  71A,746
035D2:  MOVLB  7
035D4:  CLRF   x4D
035D6:  CLRF   x4C
035D8:  CLRF   x4B
035DA:  CLRF   x4A
035DC:  MOVLB  0
035DE:  CALL   1D22
035E2:  BNC   3644
035E4:  MOVFF  721,725
035E8:  MOVFF  720,724
035EC:  MOVFF  71F,723
035F0:  MOVFF  71E,722
035F4:  MOVLB  7
035F6:  CLRF   x29
035F8:  CLRF   x28
035FA:  CLRF   x27
035FC:  MOVLW  7F
035FE:  MOVWF  x26
03600:  MOVLB  0
03602:  CALL   2AFC
03606:  MOVFF  03,725
0360A:  MOVFF  02,724
0360E:  MOVFF  01,723
03612:  MOVFF  00,722
03616:  MOVFF  03,749
0361A:  MOVFF  02,748
0361E:  MOVFF  01,747
03622:  MOVFF  00,746
03626:  MOVLB  7
03628:  CLRF   x4D
0362A:  CLRF   x4C
0362C:  CLRF   x4B
0362E:  CLRF   x4A
03630:  MOVLB  0
03632:  CALL   1D22
03636:  BZ    3644
....................       return 0;
03638:  CLRF   00
0363A:  CLRF   01
0363C:  CLRF   02
0363E:  CLRF   03
03640:  BRA    3700
....................    } else {
03642:  BRA    3700
....................       if(x != 0 || 0 >= y) {
03644:  MOVFF  71D,749
03648:  MOVFF  71C,748
0364C:  MOVFF  71B,747
03650:  MOVFF  71A,746
03654:  MOVLB  7
03656:  CLRF   x4D
03658:  CLRF   x4C
0365A:  CLRF   x4B
0365C:  CLRF   x4A
0365E:  MOVLB  0
03660:  CALL   1D22
03664:  BNZ   368A
03666:  MOVFF  721,749
0366A:  MOVFF  720,748
0366E:  MOVFF  71F,747
03672:  MOVFF  71E,746
03676:  MOVLB  7
03678:  CLRF   x4D
0367A:  CLRF   x4C
0367C:  CLRF   x4B
0367E:  CLRF   x4A
03680:  MOVLB  0
03682:  CALL   1D22
03686:  BC    368A
03688:  BNZ   36F8
....................          return (exp(log(x) * y));
0368A:  MOVFF  71D,729
0368E:  MOVFF  71C,728
03692:  MOVFF  71B,727
03696:  MOVFF  71A,726
0369A:  CALL   2C62
0369E:  MOVFF  03,725
036A2:  MOVFF  02,724
036A6:  MOVFF  01,723
036AA:  MOVFF  00,722
036AE:  MOVFF  03,753
036B2:  MOVFF  02,752
036B6:  MOVFF  01,751
036BA:  MOVFF  00,750
036BE:  MOVFF  721,757
036C2:  MOVFF  720,756
036C6:  MOVFF  71F,755
036CA:  MOVFF  71E,754
036CE:  CALL   0D96
036D2:  MOVFF  03,725
036D6:  MOVFF  02,724
036DA:  MOVFF  01,723
036DE:  MOVFF  00,722
036E2:  MOVFF  03,729
036E6:  MOVFF  02,728
036EA:  MOVFF  01,727
036EE:  MOVFF  00,726
036F2:  RCALL  2FF6
036F4:  BRA    3700
....................       } else return 0;
036F6:  BRA    3700
036F8:  CLRF   00
036FA:  CLRF   01
036FC:  CLRF   02
036FE:  CLRF   03
....................    }
03700:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01EFA:  MOVLB  7
01EFC:  BCF    x38.0
....................    flag = 0;
01EFE:  BCF    x38.1
....................    y = x;
01F00:  MOVFF  72B,72F
01F04:  MOVFF  72A,72E
01F08:  MOVFF  729,72D
01F0C:  MOVFF  728,72C
.................... 
....................    if (x < 0)
01F10:  MOVFF  72B,749
01F14:  MOVFF  72A,748
01F18:  MOVFF  729,747
01F1C:  MOVFF  728,746
01F20:  CLRF   x4D
01F22:  CLRF   x4C
01F24:  CLRF   x4B
01F26:  CLRF   x4A
01F28:  MOVLB  0
01F2A:  RCALL  1D22
01F2C:  BNC   1F3A
....................    {
....................       s = 1;
01F2E:  MOVLB  7
01F30:  BSF    x38.0
....................       y = -y;
01F32:  MOVF   x2D,W
01F34:  XORLW  80
01F36:  MOVWF  x2D
01F38:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F3A:  MOVLB  7
01F3C:  CLRF   x49
01F3E:  CLRF   x48
01F40:  CLRF   x47
01F42:  MOVLW  7F
01F44:  MOVWF  x46
01F46:  MOVFF  72F,74D
01F4A:  MOVFF  72E,74C
01F4E:  MOVFF  72D,74B
01F52:  MOVFF  72C,74A
01F56:  MOVLB  0
01F58:  RCALL  1D22
01F5A:  BNC   1F92
....................    {
....................       y = 1.0/y;
01F5C:  MOVLB  7
01F5E:  CLRF   x42
01F60:  CLRF   x41
01F62:  CLRF   x40
01F64:  MOVLW  7F
01F66:  MOVWF  x3F
01F68:  MOVFF  72F,746
01F6C:  MOVFF  72E,745
01F70:  MOVFF  72D,744
01F74:  MOVFF  72C,743
01F78:  MOVLB  0
01F7A:  RCALL  1D9C
01F7C:  MOVFF  03,72F
01F80:  MOVFF  02,72E
01F84:  MOVFF  01,72D
01F88:  MOVFF  00,72C
....................       flag = 1;
01F8C:  MOVLB  7
01F8E:  BSF    x38.1
01F90:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F92:  MOVLW  0A
01F94:  MOVLB  7
01F96:  MOVWF  x53
01F98:  MOVLW  89
01F9A:  MOVWF  x52
01F9C:  MOVLW  34
01F9E:  MOVWF  x51
01FA0:  MOVLW  7C
01FA2:  MOVWF  x50
01FA4:  MOVFF  72F,757
01FA8:  MOVFF  72E,756
01FAC:  MOVFF  72D,755
01FB0:  MOVFF  72C,754
01FB4:  MOVLB  0
01FB6:  CALL   0D96
01FBA:  MOVFF  03,73C
01FBE:  MOVFF  02,73B
01FC2:  MOVFF  01,73A
01FC6:  MOVFF  00,739
01FCA:  MOVFF  03,753
01FCE:  MOVFF  02,752
01FD2:  MOVFF  01,751
01FD6:  MOVFF  00,750
01FDA:  MOVFF  72F,757
01FDE:  MOVFF  72E,756
01FE2:  MOVFF  72D,755
01FE6:  MOVFF  72C,754
01FEA:  CALL   0D96
01FEE:  MOVFF  03,73C
01FF2:  MOVFF  02,73B
01FF6:  MOVFF  01,73A
01FFA:  MOVFF  00,739
01FFE:  BCF    FD8.1
02000:  MOVFF  03,74D
02004:  MOVFF  02,74C
02008:  MOVFF  01,74B
0200C:  MOVFF  00,74A
02010:  MOVLW  7C
02012:  MOVLB  7
02014:  MOVWF  x51
02016:  MOVLW  79
02018:  MOVWF  x50
0201A:  MOVLW  35
0201C:  MOVWF  x4F
0201E:  MOVLW  81
02020:  MOVWF  x4E
02022:  MOVLB  0
02024:  CALL   0E8C
02028:  MOVFF  03,733
0202C:  MOVFF  02,732
02030:  MOVFF  01,731
02034:  MOVFF  00,730
....................    res = res*y*y + pat[2];
02038:  MOVFF  733,753
0203C:  MOVFF  732,752
02040:  MOVFF  731,751
02044:  MOVFF  730,750
02048:  MOVFF  72F,757
0204C:  MOVFF  72E,756
02050:  MOVFF  72D,755
02054:  MOVFF  72C,754
02058:  CALL   0D96
0205C:  MOVFF  03,73C
02060:  MOVFF  02,73B
02064:  MOVFF  01,73A
02068:  MOVFF  00,739
0206C:  MOVFF  03,753
02070:  MOVFF  02,752
02074:  MOVFF  01,751
02078:  MOVFF  00,750
0207C:  MOVFF  72F,757
02080:  MOVFF  72E,756
02084:  MOVFF  72D,755
02088:  MOVFF  72C,754
0208C:  CALL   0D96
02090:  MOVFF  03,73C
02094:  MOVFF  02,73B
02098:  MOVFF  01,73A
0209C:  MOVFF  00,739
020A0:  BCF    FD8.1
020A2:  MOVFF  03,74D
020A6:  MOVFF  02,74C
020AA:  MOVFF  01,74B
020AE:  MOVFF  00,74A
020B2:  MOVLW  3F
020B4:  MOVLB  7
020B6:  MOVWF  x51
020B8:  MOVLW  02
020BA:  MOVWF  x50
020BC:  MOVLW  33
020BE:  MOVWF  x4F
020C0:  MOVLW  83
020C2:  MOVWF  x4E
020C4:  MOVLB  0
020C6:  CALL   0E8C
020CA:  MOVFF  03,733
020CE:  MOVFF  02,732
020D2:  MOVFF  01,731
020D6:  MOVFF  00,730
....................    res = res*y*y + pat[3];
020DA:  MOVFF  733,753
020DE:  MOVFF  732,752
020E2:  MOVFF  731,751
020E6:  MOVFF  730,750
020EA:  MOVFF  72F,757
020EE:  MOVFF  72E,756
020F2:  MOVFF  72D,755
020F6:  MOVFF  72C,754
020FA:  CALL   0D96
020FE:  MOVFF  03,73C
02102:  MOVFF  02,73B
02106:  MOVFF  01,73A
0210A:  MOVFF  00,739
0210E:  MOVFF  03,753
02112:  MOVFF  02,752
02116:  MOVFF  01,751
0211A:  MOVFF  00,750
0211E:  MOVFF  72F,757
02122:  MOVFF  72E,756
02126:  MOVFF  72D,755
0212A:  MOVFF  72C,754
0212E:  CALL   0D96
02132:  MOVFF  03,73C
02136:  MOVFF  02,73B
0213A:  MOVFF  01,73A
0213E:  MOVFF  00,739
02142:  BCF    FD8.1
02144:  MOVFF  03,74D
02148:  MOVFF  02,74C
0214C:  MOVFF  01,74B
02150:  MOVFF  00,74A
02154:  MOVLW  33
02156:  MOVLB  7
02158:  MOVWF  x51
0215A:  MOVLW  8C
0215C:  MOVWF  x50
0215E:  MOVLW  1E
02160:  MOVWF  x4F
02162:  MOVLW  83
02164:  MOVWF  x4E
02166:  MOVLB  0
02168:  CALL   0E8C
0216C:  MOVFF  03,733
02170:  MOVFF  02,732
02174:  MOVFF  01,731
02178:  MOVFF  00,730
.................... 
....................    r = qat[0]*y*y + qat[1];
0217C:  MOVLB  7
0217E:  CLRF   x53
02180:  CLRF   x52
02182:  CLRF   x51
02184:  MOVLW  7F
02186:  MOVWF  x50
02188:  MOVFF  72F,757
0218C:  MOVFF  72E,756
02190:  MOVFF  72D,755
02194:  MOVFF  72C,754
02198:  MOVLB  0
0219A:  CALL   0D96
0219E:  MOVFF  03,73C
021A2:  MOVFF  02,73B
021A6:  MOVFF  01,73A
021AA:  MOVFF  00,739
021AE:  MOVFF  03,753
021B2:  MOVFF  02,752
021B6:  MOVFF  01,751
021BA:  MOVFF  00,750
021BE:  MOVFF  72F,757
021C2:  MOVFF  72E,756
021C6:  MOVFF  72D,755
021CA:  MOVFF  72C,754
021CE:  CALL   0D96
021D2:  MOVFF  03,73C
021D6:  MOVFF  02,73B
021DA:  MOVFF  01,73A
021DE:  MOVFF  00,739
021E2:  BCF    FD8.1
021E4:  MOVFF  03,74D
021E8:  MOVFF  02,74C
021EC:  MOVFF  01,74B
021F0:  MOVFF  00,74A
021F4:  MOVLW  1B
021F6:  MOVLB  7
021F8:  MOVWF  x51
021FA:  MOVLW  E4
021FC:  MOVWF  x50
021FE:  MOVLW  35
02200:  MOVWF  x4F
02202:  MOVLW  82
02204:  MOVWF  x4E
02206:  MOVLB  0
02208:  CALL   0E8C
0220C:  MOVFF  03,737
02210:  MOVFF  02,736
02214:  MOVFF  01,735
02218:  MOVFF  00,734
....................    r = r*y*y + qat[2];
0221C:  MOVFF  737,753
02220:  MOVFF  736,752
02224:  MOVFF  735,751
02228:  MOVFF  734,750
0222C:  MOVFF  72F,757
02230:  MOVFF  72E,756
02234:  MOVFF  72D,755
02238:  MOVFF  72C,754
0223C:  CALL   0D96
02240:  MOVFF  03,73C
02244:  MOVFF  02,73B
02248:  MOVFF  01,73A
0224C:  MOVFF  00,739
02250:  MOVFF  03,753
02254:  MOVFF  02,752
02258:  MOVFF  01,751
0225C:  MOVFF  00,750
02260:  MOVFF  72F,757
02264:  MOVFF  72E,756
02268:  MOVFF  72D,755
0226C:  MOVFF  72C,754
02270:  CALL   0D96
02274:  MOVFF  03,73C
02278:  MOVFF  02,73B
0227C:  MOVFF  01,73A
02280:  MOVFF  00,739
02284:  BCF    FD8.1
02286:  MOVFF  03,74D
0228A:  MOVFF  02,74C
0228E:  MOVFF  01,74B
02292:  MOVFF  00,74A
02296:  MOVLW  A4
02298:  MOVLB  7
0229A:  MOVWF  x51
0229C:  MOVLW  DB
0229E:  MOVWF  x50
022A0:  MOVLW  67
022A2:  MOVWF  x4F
022A4:  MOVLW  83
022A6:  MOVWF  x4E
022A8:  MOVLB  0
022AA:  CALL   0E8C
022AE:  MOVFF  03,737
022B2:  MOVFF  02,736
022B6:  MOVFF  01,735
022BA:  MOVFF  00,734
....................    r = r*y*y + qat[3];
022BE:  MOVFF  737,753
022C2:  MOVFF  736,752
022C6:  MOVFF  735,751
022CA:  MOVFF  734,750
022CE:  MOVFF  72F,757
022D2:  MOVFF  72E,756
022D6:  MOVFF  72D,755
022DA:  MOVFF  72C,754
022DE:  CALL   0D96
022E2:  MOVFF  03,73C
022E6:  MOVFF  02,73B
022EA:  MOVFF  01,73A
022EE:  MOVFF  00,739
022F2:  MOVFF  03,753
022F6:  MOVFF  02,752
022FA:  MOVFF  01,751
022FE:  MOVFF  00,750
02302:  MOVFF  72F,757
02306:  MOVFF  72E,756
0230A:  MOVFF  72D,755
0230E:  MOVFF  72C,754
02312:  CALL   0D96
02316:  MOVFF  03,73C
0231A:  MOVFF  02,73B
0231E:  MOVFF  01,73A
02322:  MOVFF  00,739
02326:  BCF    FD8.1
02328:  MOVFF  03,74D
0232C:  MOVFF  02,74C
02330:  MOVFF  01,74B
02334:  MOVFF  00,74A
02338:  MOVLW  33
0233A:  MOVLB  7
0233C:  MOVWF  x51
0233E:  MOVLW  8C
02340:  MOVWF  x50
02342:  MOVLW  1E
02344:  MOVWF  x4F
02346:  MOVLW  83
02348:  MOVWF  x4E
0234A:  MOVLB  0
0234C:  CALL   0E8C
02350:  MOVFF  03,737
02354:  MOVFF  02,736
02358:  MOVFF  01,735
0235C:  MOVFF  00,734
.................... 
....................    res = y*res/r;
02360:  MOVFF  72F,753
02364:  MOVFF  72E,752
02368:  MOVFF  72D,751
0236C:  MOVFF  72C,750
02370:  MOVFF  733,757
02374:  MOVFF  732,756
02378:  MOVFF  731,755
0237C:  MOVFF  730,754
02380:  CALL   0D96
02384:  MOVFF  03,73C
02388:  MOVFF  02,73B
0238C:  MOVFF  01,73A
02390:  MOVFF  00,739
02394:  MOVFF  03,742
02398:  MOVFF  02,741
0239C:  MOVFF  01,740
023A0:  MOVFF  00,73F
023A4:  MOVFF  737,746
023A8:  MOVFF  736,745
023AC:  MOVFF  735,744
023B0:  MOVFF  734,743
023B4:  RCALL  1D9C
023B6:  MOVFF  03,733
023BA:  MOVFF  02,732
023BE:  MOVFF  01,731
023C2:  MOVFF  00,730
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
023C6:  MOVLB  7
023C8:  BTFSS  x38.1
023CA:  BRA    2406
....................       res = PI_DIV_BY_TWO - res;
023CC:  BSF    FD8.1
023CE:  MOVLW  DB
023D0:  MOVWF  x4D
023D2:  MOVLW  0F
023D4:  MOVWF  x4C
023D6:  MOVLW  49
023D8:  MOVWF  x4B
023DA:  MOVLW  7F
023DC:  MOVWF  x4A
023DE:  MOVFF  733,751
023E2:  MOVFF  732,750
023E6:  MOVFF  731,74F
023EA:  MOVFF  730,74E
023EE:  MOVLB  0
023F0:  CALL   0E8C
023F4:  MOVFF  03,733
023F8:  MOVFF  02,732
023FC:  MOVFF  01,731
02400:  MOVFF  00,730
02404:  MOVLB  7
....................    if (s)
02406:  BTFSS  x38.0
02408:  BRA    2410
....................       res = -res;
0240A:  MOVF   x31,W
0240C:  XORLW  80
0240E:  MOVWF  x31
.................... 
....................    return(res);
02410:  MOVFF  730,00
02414:  MOVFF  731,01
02418:  MOVFF  732,02
0241C:  MOVFF  733,03
02420:  MOVLB  0
02422:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02424:  MOVLB  7
02426:  BCF    x26.0
....................    quad=0; //quadrant
02428:  CLRF   x27
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
0242A:  MOVFF  71D,749
0242E:  MOVFF  71C,748
02432:  MOVFF  71B,747
02436:  MOVFF  71A,746
0243A:  CLRF   x4D
0243C:  CLRF   x4C
0243E:  CLRF   x4B
02440:  CLRF   x4A
02442:  MOVLB  0
02444:  RCALL  1D22
02446:  BC    244A
02448:  BNZ   2474
0244A:  MOVFF  721,749
0244E:  MOVFF  720,748
02452:  MOVFF  71F,747
02456:  MOVFF  71E,746
0245A:  MOVLB  7
0245C:  CLRF   x4D
0245E:  CLRF   x4C
02460:  CLRF   x4B
02462:  CLRF   x4A
02464:  MOVLB  0
02466:  RCALL  1D22
02468:  BC    246C
0246A:  BNZ   2470
0246C:  MOVLW  03
0246E:  BRA    2472
02470:  MOVLW  04
02472:  BRA    249A
02474:  MOVFF  721,749
02478:  MOVFF  720,748
0247C:  MOVFF  71F,747
02480:  MOVFF  71E,746
02484:  MOVLB  7
02486:  CLRF   x4D
02488:  CLRF   x4C
0248A:  CLRF   x4B
0248C:  CLRF   x4A
0248E:  MOVLB  0
02490:  RCALL  1D22
02492:  BNC   2498
02494:  MOVLW  02
02496:  BRA    249A
02498:  MOVLW  01
0249A:  MOVLB  7
0249C:  MOVWF  x27
....................    if(y<0.0)
0249E:  MOVFF  71D,749
024A2:  MOVFF  71C,748
024A6:  MOVFF  71B,747
024AA:  MOVFF  71A,746
024AE:  CLRF   x4D
024B0:  CLRF   x4C
024B2:  CLRF   x4B
024B4:  CLRF   x4A
024B6:  MOVLB  0
024B8:  RCALL  1D22
024BA:  BNC   24C8
....................    {
....................       sign=1;
024BC:  MOVLB  7
024BE:  BSF    x26.0
....................       y=-y;
024C0:  MOVF   x1B,W
024C2:  XORLW  80
024C4:  MOVWF  x1B
024C6:  MOVLB  0
....................    }
....................    if(x<0.0)
024C8:  MOVFF  721,749
024CC:  MOVFF  720,748
024D0:  MOVFF  71F,747
024D4:  MOVFF  71E,746
024D8:  MOVLB  7
024DA:  CLRF   x4D
024DC:  CLRF   x4C
024DE:  CLRF   x4B
024E0:  CLRF   x4A
024E2:  MOVLB  0
024E4:  RCALL  1D22
024E6:  BNC   24F2
....................    {
....................       x=-x;
024E8:  MOVLB  7
024EA:  MOVF   x1F,W
024EC:  XORLW  80
024EE:  MOVWF  x1F
024F0:  MOVLB  0
....................    }
....................    if (x==0.0)
024F2:  MOVFF  721,749
024F6:  MOVFF  720,748
024FA:  MOVFF  71F,747
024FE:  MOVFF  71E,746
02502:  MOVLB  7
02504:  CLRF   x4D
02506:  CLRF   x4C
02508:  CLRF   x4B
0250A:  CLRF   x4A
0250C:  MOVLB  0
0250E:  RCALL  1D22
02510:  BNZ   2566
....................    {
....................       if(y==0.0)
02512:  MOVFF  71D,749
02516:  MOVFF  71C,748
0251A:  MOVFF  71B,747
0251E:  MOVFF  71A,746
02522:  MOVLB  7
02524:  CLRF   x4D
02526:  CLRF   x4C
02528:  CLRF   x4B
0252A:  CLRF   x4A
0252C:  MOVLB  0
0252E:  CALL   1D22
02532:  BNZ   2536
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02534:  BRA    2564
....................       else
....................       {
....................          if(sign)
02536:  MOVLB  7
02538:  BTFSS  x26.0
0253A:  BRA    2550
....................          {
....................          return (-(PI_DIV_BY_TWO));
0253C:  MOVLW  7F
0253E:  MOVWF  00
02540:  MOVLW  C9
02542:  MOVWF  01
02544:  MOVLW  0F
02546:  MOVWF  02
02548:  MOVLW  DB
0254A:  MOVWF  03
0254C:  BRA    269E
....................          }
0254E:  BRA    2562
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02550:  MOVLW  7F
02552:  MOVWF  00
02554:  MOVLW  49
02556:  MOVWF  01
02558:  MOVLW  0F
0255A:  MOVWF  02
0255C:  MOVLW  DB
0255E:  MOVWF  03
02560:  BRA    269E
02562:  MOVLB  0
....................          }
....................       }
....................    }
02564:  BRA    269C
....................    else
....................    {
....................       z=y/x;
02566:  MOVFF  71D,742
0256A:  MOVFF  71C,741
0256E:  MOVFF  71B,740
02572:  MOVFF  71A,73F
02576:  MOVFF  721,746
0257A:  MOVFF  720,745
0257E:  MOVFF  71F,744
02582:  MOVFF  71E,743
02586:  RCALL  1D9C
02588:  MOVFF  03,725
0258C:  MOVFF  02,724
02590:  MOVFF  01,723
02594:  MOVFF  00,722
....................       switch(quad)
02598:  MOVLW  01
0259A:  MOVLB  7
0259C:  SUBWF  x27,W
0259E:  ADDLW  FC
025A0:  BTFSC  FD8.0
025A2:  BRA    269E
025A4:  ADDLW  04
025A6:  MOVLB  0
025A8:  GOTO   26A4
....................       {
....................          case 1:
....................          {
....................             return atan(z);
025AC:  MOVFF  725,72B
025B0:  MOVFF  724,72A
025B4:  MOVFF  723,729
025B8:  MOVFF  722,728
025BC:  RCALL  1EFA
025BE:  MOVLB  7
025C0:  BRA    269E
....................             break;
025C2:  BRA    269E
025C4:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
025C6:  MOVFF  725,72B
025CA:  MOVFF  724,72A
025CE:  MOVFF  723,729
025D2:  MOVFF  722,728
025D6:  RCALL  1EFA
025D8:  MOVFF  FEA,729
025DC:  MOVFF  FE9,728
025E0:  BSF    FD8.1
025E2:  MOVLW  DB
025E4:  MOVLB  7
025E6:  MOVWF  x4D
025E8:  MOVLW  0F
025EA:  MOVWF  x4C
025EC:  MOVLW  49
025EE:  MOVWF  x4B
025F0:  MOVLW  80
025F2:  MOVWF  x4A
025F4:  MOVFF  03,751
025F8:  MOVFF  02,750
025FC:  MOVFF  01,74F
02600:  MOVFF  00,74E
02604:  MOVLB  0
02606:  CALL   0E8C
0260A:  MOVFF  729,FEA
0260E:  MOVFF  728,FE9
02612:  MOVLB  7
02614:  BRA    269E
....................             break;
02616:  BRA    269E
02618:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
0261A:  MOVFF  725,72B
0261E:  MOVFF  724,72A
02622:  MOVFF  723,729
02626:  MOVFF  722,728
0262A:  RCALL  1EFA
0262C:  MOVFF  03,72B
02630:  MOVFF  02,72A
02634:  MOVFF  01,729
02638:  MOVFF  00,728
0263C:  MOVFF  FEA,72D
02640:  MOVFF  FE9,72C
02644:  BSF    FD8.1
02646:  MOVFF  03,74D
0264A:  MOVFF  02,74C
0264E:  MOVFF  01,74B
02652:  MOVFF  00,74A
02656:  MOVLW  DB
02658:  MOVLB  7
0265A:  MOVWF  x51
0265C:  MOVLW  0F
0265E:  MOVWF  x50
02660:  MOVLW  49
02662:  MOVWF  x4F
02664:  MOVLW  80
02666:  MOVWF  x4E
02668:  MOVLB  0
0266A:  CALL   0E8C
0266E:  MOVFF  72D,FEA
02672:  MOVFF  72C,FE9
02676:  MOVLB  7
02678:  BRA    269E
....................             break;
0267A:  BRA    269E
0267C:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
0267E:  MOVFF  725,72B
02682:  MOVFF  724,72A
02686:  MOVFF  723,729
0268A:  MOVFF  722,728
0268E:  RCALL  1EFA
02690:  MOVLW  80
02692:  XORWF  01,F
02694:  MOVLB  7
02696:  BRA    269E
....................             break;
02698:  BRA    269E
0269A:  MOVLB  0
0269C:  MOVLB  7
....................          }
....................       }
....................    }
0269E:  MOVLB  0
026A0:  GOTO   3DAA (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008FA:  MOVFF  730,FEA
008FE:  MOVLB  7
00900:  MOVFF  72F,FE9
00904:  CLRF   x42
00906:  MOVFF  FEF,741
0090A:  CLRF   x44
0090C:  MOVLW  04
0090E:  MOVWF  x43
00910:  MOVLB  0
00912:  RCALL  08AC
00914:  MOVF   01,W
00916:  MOVLB  7
00918:  ADDWF  x2D,W
0091A:  MOVWF  FE9
0091C:  MOVF   x2E,W
0091E:  ADDWFC 02,W
00920:  MOVWF  FEA
00922:  MOVFF  731,FEF
00926:  MOVFF  732,FEC
0092A:  MOVFF  733,FEC
0092E:  MOVFF  734,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
00932:  MOVFF  730,736
00936:  MOVFF  730,FEA
0093A:  MOVFF  72F,FE9
0093E:  MOVLW  01
00940:  ADDWF  FEF,W
00942:  MOVWF  x38
00944:  MOVWF  x3A
00946:  MOVLW  05
00948:  MOVWF  x3B
0094A:  MOVLB  0
0094C:  RCALL  08CE
0094E:  MOVLB  7
00950:  MOVFF  736,FEA
00954:  MOVFF  72F,FE9
00958:  MOVFF  00,FEF
0095C:  MOVLB  0
0095E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
01104:  MOVLB  F
01106:  BTFSC  x5B.0
01108:  BRA    1654
....................       switch (state)
0110A:  MOVLB  1
0110C:  MOVF   xE6,W
0110E:  ADDLW  F9
01110:  BTFSC  FD8.0
01112:  BRA    1652
01114:  ADDLW  07
01116:  MOVLB  0
01118:  GOTO   165A
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
0111C:  MOVLB  F
0111E:  BTFSC  x5B.0
01120:  BRA    111E
01122:  MOVFF  F5F,02
01126:  MOVFF  F5E,01
0112A:  MOVFF  02,6FC
0112E:  MOVFF  01,6FB
01132:  MOVFF  02,74B
01136:  MOVFF  01,74A
0113A:  MOVLB  0
0113C:  RCALL  0D60
0113E:  MOVFF  03,753
01142:  MOVFF  02,752
01146:  MOVFF  01,751
0114A:  MOVFF  00,750
0114E:  MOVFF  C9,757
01152:  MOVFF  C8,756
01156:  MOVFF  C7,755
0115A:  MOVFF  C6,754
0115E:  RCALL  0D96
01160:  MOVFF  03,6FE
01164:  MOVFF  02,6FD
01168:  MOVFF  01,6FC
0116C:  MOVFF  00,6FB
01170:  BCF    FD8.1
01172:  MOVFF  03,74D
01176:  MOVFF  02,74C
0117A:  MOVFF  01,74B
0117E:  MOVFF  00,74A
01182:  MOVFF  C5,751
01186:  MOVFF  C4,750
0118A:  MOVFF  C3,74F
0118E:  MOVFF  C2,74E
01192:  RCALL  0E8C
01194:  MOVFF  03,FE
01198:  MOVFF  02,FD
0119C:  MOVFF  01,FC
011A0:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
011A4:  MOVLB  F
011A6:  MOVF   x5A,W
011A8:  ANDLW  3F
011AA:  MOVWF  01
011AC:  MOVLW  10
011AE:  MOVWF  x5A
011B0:  BTFSS  x5B.7
011B2:  BRA    11C2
011B4:  MOVF   01,W
011B6:  SUBLW  10
011B8:  BZ    11C2
011BA:  BSF    x5B.0
011BC:  NOP   
011BE:  BTFSC  x5B.0
011C0:  BRA    11BE
....................             delay_ms(10);
011C2:  MOVLW  0A
011C4:  MOVLB  7
011C6:  MOVWF  x01
011C8:  MOVLB  0
011CA:  CALL   03D6
....................             read_adc(ADC_START_ONLY);
011CE:  MOVLB  F
011D0:  BSF    x5B.0
011D2:  NOP   
....................             state = 1;
011D4:  MOVLW  01
011D6:  MOVLB  1
011D8:  MOVWF  xE6
....................          break;
011DA:  BRA    1652
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011DC:  MOVLB  F
011DE:  BTFSC  x5B.0
011E0:  BRA    11DE
011E2:  MOVFF  F5F,02
011E6:  MOVFF  F5E,01
011EA:  MOVFF  02,6FC
011EE:  MOVFF  01,6FB
011F2:  MOVFF  02,74B
011F6:  MOVFF  01,74A
011FA:  MOVLB  0
011FC:  RCALL  0D60
011FE:  MOVFF  03,753
01202:  MOVFF  02,752
01206:  MOVFF  01,751
0120A:  MOVFF  00,750
0120E:  MOVFF  D1,757
01212:  MOVFF  D0,756
01216:  MOVFF  CF,755
0121A:  MOVFF  CE,754
0121E:  RCALL  0D96
01220:  MOVFF  03,6FE
01224:  MOVFF  02,6FD
01228:  MOVFF  01,6FC
0122C:  MOVFF  00,6FB
01230:  BCF    FD8.1
01232:  MOVFF  03,74D
01236:  MOVFF  02,74C
0123A:  MOVFF  01,74B
0123E:  MOVFF  00,74A
01242:  MOVFF  CD,751
01246:  MOVFF  CC,750
0124A:  MOVFF  CB,74F
0124E:  MOVFF  CA,74E
01252:  RCALL  0E8C
01254:  MOVFF  03,102
01258:  MOVFF  02,101
0125C:  MOVFF  01,100
01260:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
01264:  MOVLB  F
01266:  MOVF   x5A,W
01268:  ANDLW  3F
0126A:  MOVWF  01
0126C:  MOVLW  18
0126E:  MOVWF  x5A
01270:  BTFSS  x5B.7
01272:  BRA    1282
01274:  MOVF   01,W
01276:  SUBLW  18
01278:  BZ    1282
0127A:  BSF    x5B.0
0127C:  NOP   
0127E:  BTFSC  x5B.0
01280:  BRA    127E
....................             delay_ms(10);
01282:  MOVLW  0A
01284:  MOVLB  7
01286:  MOVWF  x01
01288:  MOVLB  0
0128A:  CALL   03D6
....................             read_adc(ADC_START_ONLY);
0128E:  MOVLB  F
01290:  BSF    x5B.0
01292:  NOP   
....................             state = 2;
01294:  MOVLW  02
01296:  MOVLB  1
01298:  MOVWF  xE6
....................          break;
0129A:  BRA    1652
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
0129C:  MOVLB  F
0129E:  BTFSC  x5B.0
012A0:  BRA    129E
012A2:  MOVFF  F5F,02
012A6:  MOVFF  F5E,01
012AA:  MOVFF  02,6FC
012AE:  MOVFF  01,6FB
012B2:  MOVFF  02,74B
012B6:  MOVFF  01,74A
012BA:  MOVLB  0
012BC:  RCALL  0D60
012BE:  MOVFF  03,753
012C2:  MOVFF  02,752
012C6:  MOVFF  01,751
012CA:  MOVFF  00,750
012CE:  MOVFF  D9,757
012D2:  MOVFF  D8,756
012D6:  MOVFF  D7,755
012DA:  MOVFF  D6,754
012DE:  RCALL  0D96
012E0:  MOVFF  03,6FE
012E4:  MOVFF  02,6FD
012E8:  MOVFF  01,6FC
012EC:  MOVFF  00,6FB
012F0:  BCF    FD8.1
012F2:  MOVFF  03,74D
012F6:  MOVFF  02,74C
012FA:  MOVFF  01,74B
012FE:  MOVFF  00,74A
01302:  MOVFF  D5,751
01306:  MOVFF  D4,750
0130A:  MOVFF  D3,74F
0130E:  MOVFF  D2,74E
01312:  RCALL  0E8C
01314:  MOVFF  03,106
01318:  MOVFF  02,105
0131C:  MOVFF  01,104
01320:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
01324:  MOVLB  F
01326:  MOVF   x5A,W
01328:  ANDLW  3F
0132A:  MOVWF  01
0132C:  MOVLW  19
0132E:  MOVWF  x5A
01330:  BTFSS  x5B.7
01332:  BRA    1342
01334:  MOVF   01,W
01336:  SUBLW  19
01338:  BZ    1342
0133A:  BSF    x5B.0
0133C:  NOP   
0133E:  BTFSC  x5B.0
01340:  BRA    133E
....................             delay_ms(10);
01342:  MOVLW  0A
01344:  MOVLB  7
01346:  MOVWF  x01
01348:  MOVLB  0
0134A:  CALL   03D6
....................             read_adc(ADC_START_ONLY);
0134E:  MOVLB  F
01350:  BSF    x5B.0
01352:  NOP   
....................             state = 3;
01354:  MOVLW  03
01356:  MOVLB  1
01358:  MOVWF  xE6
....................          break;
0135A:  BRA    1652
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
0135C:  MOVLB  F
0135E:  BTFSC  x5B.0
01360:  BRA    135E
01362:  MOVFF  F5F,02
01366:  MOVFF  F5E,01
0136A:  MOVFF  02,6FC
0136E:  MOVFF  01,6FB
01372:  MOVFF  02,74B
01376:  MOVFF  01,74A
0137A:  MOVLB  0
0137C:  RCALL  0D60
0137E:  MOVFF  03,753
01382:  MOVFF  02,752
01386:  MOVFF  01,751
0138A:  MOVFF  00,750
0138E:  MOVFF  E1,757
01392:  MOVFF  E0,756
01396:  MOVFF  DF,755
0139A:  MOVFF  DE,754
0139E:  RCALL  0D96
013A0:  MOVFF  03,6FE
013A4:  MOVFF  02,6FD
013A8:  MOVFF  01,6FC
013AC:  MOVFF  00,6FB
013B0:  BCF    FD8.1
013B2:  MOVFF  03,74D
013B6:  MOVFF  02,74C
013BA:  MOVFF  01,74B
013BE:  MOVFF  00,74A
013C2:  MOVFF  DD,751
013C6:  MOVFF  DC,750
013CA:  MOVFF  DB,74F
013CE:  MOVFF  DA,74E
013D2:  RCALL  0E8C
013D4:  MOVFF  03,10A
013D8:  MOVFF  02,109
013DC:  MOVFF  01,108
013E0:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
013E4:  MOVLB  F
013E6:  MOVF   x5A,W
013E8:  ANDLW  3F
013EA:  MOVWF  01
013EC:  MOVLW  11
013EE:  MOVWF  x5A
013F0:  BTFSS  x5B.7
013F2:  BRA    1402
013F4:  MOVF   01,W
013F6:  SUBLW  11
013F8:  BZ    1402
013FA:  BSF    x5B.0
013FC:  NOP   
013FE:  BTFSC  x5B.0
01400:  BRA    13FE
....................             delay_ms(10);
01402:  MOVLW  0A
01404:  MOVLB  7
01406:  MOVWF  x01
01408:  MOVLB  0
0140A:  CALL   03D6
....................             read_adc(ADC_START_ONLY);
0140E:  MOVLB  F
01410:  BSF    x5B.0
01412:  NOP   
....................             state = 4;
01414:  MOVLW  04
01416:  MOVLB  1
01418:  MOVWF  xE6
....................          break;
0141A:  BRA    1652
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0141C:  MOVLB  F
0141E:  BTFSC  x5B.0
01420:  BRA    141E
01422:  MOVFF  F5F,02
01426:  MOVFF  F5E,01
0142A:  MOVFF  02,6FC
0142E:  MOVFF  01,6FB
01432:  MOVFF  02,74B
01436:  MOVFF  01,74A
0143A:  MOVLB  0
0143C:  RCALL  0D60
0143E:  MOVFF  03,753
01442:  MOVFF  02,752
01446:  MOVFF  01,751
0144A:  MOVFF  00,750
0144E:  MOVFF  E9,757
01452:  MOVFF  E8,756
01456:  MOVFF  E7,755
0145A:  MOVFF  E6,754
0145E:  RCALL  0D96
01460:  MOVFF  03,6FE
01464:  MOVFF  02,6FD
01468:  MOVFF  01,6FC
0146C:  MOVFF  00,6FB
01470:  BCF    FD8.1
01472:  MOVFF  03,74D
01476:  MOVFF  02,74C
0147A:  MOVFF  01,74B
0147E:  MOVFF  00,74A
01482:  MOVFF  E5,751
01486:  MOVFF  E4,750
0148A:  MOVFF  E3,74F
0148E:  MOVFF  E2,74E
01492:  RCALL  0E8C
01494:  MOVFF  03,10E
01498:  MOVFF  02,10D
0149C:  MOVFF  01,10C
014A0:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
014A4:  MOVLB  F
014A6:  MOVF   x5A,W
014A8:  ANDLW  3F
014AA:  MOVWF  01
014AC:  MOVLW  1B
014AE:  MOVWF  x5A
014B0:  BTFSS  x5B.7
014B2:  BRA    14C2
014B4:  MOVF   01,W
014B6:  SUBLW  1B
014B8:  BZ    14C2
014BA:  BSF    x5B.0
014BC:  NOP   
014BE:  BTFSC  x5B.0
014C0:  BRA    14BE
....................             delay_ms(10);
014C2:  MOVLW  0A
014C4:  MOVLB  7
014C6:  MOVWF  x01
014C8:  MOVLB  0
014CA:  CALL   03D6
....................             read_adc(ADC_START_ONLY);
014CE:  MOVLB  F
014D0:  BSF    x5B.0
014D2:  NOP   
....................             state = 5;
014D4:  MOVLW  05
014D6:  MOVLB  1
014D8:  MOVWF  xE6
....................          break;
014DA:  BRA    1652
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014DC:  MOVLB  F
014DE:  BTFSC  x5B.0
014E0:  BRA    14DE
014E2:  MOVFF  F5F,02
014E6:  MOVFF  F5E,01
014EA:  MOVFF  02,6FC
014EE:  MOVFF  01,6FB
014F2:  MOVFF  02,74B
014F6:  MOVFF  01,74A
014FA:  MOVLB  0
014FC:  RCALL  0D60
014FE:  MOVFF  03,753
01502:  MOVFF  02,752
01506:  MOVFF  01,751
0150A:  MOVFF  00,750
0150E:  MOVFF  F1,757
01512:  MOVFF  F0,756
01516:  MOVFF  EF,755
0151A:  MOVFF  EE,754
0151E:  RCALL  0D96
01520:  MOVFF  03,6FE
01524:  MOVFF  02,6FD
01528:  MOVFF  01,6FC
0152C:  MOVFF  00,6FB
01530:  BCF    FD8.1
01532:  MOVFF  03,74D
01536:  MOVFF  02,74C
0153A:  MOVFF  01,74B
0153E:  MOVFF  00,74A
01542:  MOVFF  ED,751
01546:  MOVFF  EC,750
0154A:  MOVFF  EB,74F
0154E:  MOVFF  EA,74E
01552:  RCALL  0E8C
01554:  MOVFF  03,112
01558:  MOVFF  02,111
0155C:  MOVFF  01,110
01560:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
01564:  MOVLB  F
01566:  MOVF   x5A,W
01568:  ANDLW  3F
0156A:  MOVWF  01
0156C:  MOVLW  1A
0156E:  MOVWF  x5A
01570:  BTFSS  x5B.7
01572:  BRA    1582
01574:  MOVF   01,W
01576:  SUBLW  1A
01578:  BZ    1582
0157A:  BSF    x5B.0
0157C:  NOP   
0157E:  BTFSC  x5B.0
01580:  BRA    157E
....................             delay_ms(10);
01582:  MOVLW  0A
01584:  MOVLB  7
01586:  MOVWF  x01
01588:  MOVLB  0
0158A:  CALL   03D6
....................             read_adc(ADC_START_ONLY);
0158E:  MOVLB  F
01590:  BSF    x5B.0
01592:  NOP   
....................             state = 6;
01594:  MOVLW  06
01596:  MOVLB  1
01598:  MOVWF  xE6
....................          break;
0159A:  BRA    1652
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
0159C:  MOVLB  F
0159E:  BTFSC  x5B.0
015A0:  BRA    159E
015A2:  MOVFF  F5F,02
015A6:  MOVFF  F5E,01
015AA:  MOVFF  02,6FC
015AE:  MOVFF  01,6FB
015B2:  MOVFF  02,74B
015B6:  MOVFF  01,74A
015BA:  MOVLB  0
015BC:  CALL   0D60
015C0:  MOVFF  03,753
015C4:  MOVFF  02,752
015C8:  MOVFF  01,751
015CC:  MOVFF  00,750
015D0:  MOVFF  F9,757
015D4:  MOVFF  F8,756
015D8:  MOVFF  F7,755
015DC:  MOVFF  F6,754
015E0:  CALL   0D96
015E4:  MOVFF  03,6FE
015E8:  MOVFF  02,6FD
015EC:  MOVFF  01,6FC
015F0:  MOVFF  00,6FB
015F4:  BCF    FD8.1
015F6:  MOVFF  03,74D
015FA:  MOVFF  02,74C
015FE:  MOVFF  01,74B
01602:  MOVFF  00,74A
01606:  MOVFF  F5,751
0160A:  MOVFF  F4,750
0160E:  MOVFF  F3,74F
01612:  MOVFF  F2,74E
01616:  RCALL  0E8C
01618:  MOVFF  03,116
0161C:  MOVFF  02,115
01620:  MOVFF  01,114
01624:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
01628:  MOVLB  F
0162A:  MOVF   x5A,W
0162C:  ANDLW  3F
0162E:  MOVWF  01
01630:  MOVLW  06
01632:  MOVWF  x5A
01634:  BTFSS  x5B.7
01636:  BRA    1646
01638:  MOVF   01,W
0163A:  SUBLW  06
0163C:  BZ    1646
0163E:  BSF    x5B.0
01640:  NOP   
01642:  BTFSC  x5B.0
01644:  BRA    1642
....................             read_adc(ADC_START_ONLY);
01646:  BSF    x5B.0
01648:  NOP   
....................             state = 0;
0164A:  MOVLB  1
0164C:  CLRF   xE6
....................          break;   
0164E:  BRA    1652
01650:  MOVLB  1
01652:  MOVLB  F
....................       }
....................    }
01654:  MOVLB  0
01656:  GOTO   A74C (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03702:  MOVLB  7
03704:  MOVF   x03,W
03706:  MULLW  26
03708:  MOVF   FF3,W
0370A:  CLRF   x0D
0370C:  MOVWF  x0C
0370E:  MOVLW  10
03710:  ADDWF  x0C,W
03712:  MOVWF  01
03714:  MOVLW  00
03716:  ADDWFC x0D,W
03718:  MOVWF  03
0371A:  MOVF   01,W
0371C:  ADDLW  17
0371E:  MOVWF  01
03720:  MOVLW  01
03722:  ADDWFC 03,F
03724:  MOVFF  01,70C
03728:  MOVFF  03,70D
0372C:  MOVF   x03,W
0372E:  MULLW  26
03730:  MOVF   FF3,W
03732:  CLRF   x0F
03734:  MOVWF  x0E
03736:  MOVLW  08
03738:  ADDWF  x0E,W
0373A:  MOVWF  01
0373C:  MOVLW  00
0373E:  ADDWFC x0F,W
03740:  MOVWF  03
03742:  MOVF   01,W
03744:  ADDLW  17
03746:  MOVWF  FE9
03748:  MOVLW  01
0374A:  ADDWFC 03,W
0374C:  MOVWF  FEA
0374E:  MOVFF  FEF,00
03752:  MOVFF  FEC,01
03756:  MOVFF  FEC,02
0375A:  MOVFF  FEC,03
0375E:  MOVFF  70D,FEA
03762:  MOVFF  70C,FE9
03766:  MOVFF  00,FEF
0376A:  MOVFF  01,FEC
0376E:  MOVFF  02,FEC
03772:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03776:  MOVF   x03,W
03778:  MULLW  26
0377A:  MOVF   FF3,W
0377C:  CLRF   x0D
0377E:  MOVWF  x0C
03780:  MOVLW  14
03782:  ADDWF  x0C,W
03784:  MOVWF  01
03786:  MOVLW  00
03788:  ADDWFC x0D,W
0378A:  MOVWF  03
0378C:  MOVF   01,W
0378E:  ADDLW  17
03790:  MOVWF  01
03792:  MOVLW  01
03794:  ADDWFC 03,F
03796:  MOVFF  01,70C
0379A:  MOVFF  03,70D
0379E:  MOVF   x03,W
037A0:  MULLW  26
037A2:  MOVF   FF3,W
037A4:  CLRF   x0F
037A6:  MOVWF  x0E
037A8:  MOVLW  0C
037AA:  ADDWF  x0E,W
037AC:  MOVWF  01
037AE:  MOVLW  00
037B0:  ADDWFC x0F,W
037B2:  MOVWF  03
037B4:  MOVF   01,W
037B6:  ADDLW  17
037B8:  MOVWF  FE9
037BA:  MOVLW  01
037BC:  ADDWFC 03,W
037BE:  MOVWF  FEA
037C0:  MOVFF  FEF,00
037C4:  MOVFF  FEC,01
037C8:  MOVFF  FEC,02
037CC:  MOVFF  FEC,03
037D0:  MOVFF  70D,FEA
037D4:  MOVFF  70C,FE9
037D8:  MOVFF  00,FEF
037DC:  MOVFF  01,FEC
037E0:  MOVFF  02,FEC
037E4:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037E8:  MOVF   x03,W
037EA:  MULLW  26
037EC:  MOVF   FF3,W
037EE:  CLRF   x0D
037F0:  MOVWF  x0C
037F2:  MOVLW  17
037F4:  ADDWF  x0C,W
037F6:  MOVWF  01
037F8:  MOVLW  01
037FA:  ADDWFC x0D,W
037FC:  MOVWF  03
037FE:  MOVFF  01,70E
03802:  MOVWF  x0F
03804:  MOVF   x03,W
03806:  MULLW  09
03808:  MOVF   FF3,W
0380A:  CLRF   x11
0380C:  MOVWF  x10
0380E:  MOVLW  01
03810:  ADDWF  x10,W
03812:  MOVWF  01
03814:  MOVLW  00
03816:  ADDWFC x11,W
03818:  MOVWF  03
0381A:  MOVF   01,W
0381C:  ADDLW  D4
0381E:  MOVWF  FE9
03820:  MOVLW  01
03822:  ADDWFC 03,W
03824:  MOVWF  FEA
03826:  MOVFF  FEF,710
0382A:  MOVFF  FEC,01
0382E:  MOVFF  FEC,02
03832:  MOVFF  FEC,03
03836:  MOVFF  03,713
0383A:  MOVFF  02,712
0383E:  MOVFF  01,711
03842:  MOVLB  0
03844:  CALL   1CC8
03848:  MOVFF  70F,FEA
0384C:  MOVFF  70E,FE9
03850:  MOVFF  00,FEF
03854:  MOVFF  01,FEC
03858:  MOVFF  02,FEC
0385C:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03860:  MOVLB  7
03862:  MOVF   x03,W
03864:  MULLW  26
03866:  MOVF   FF3,W
03868:  CLRF   x0D
0386A:  MOVWF  x0C
0386C:  MOVLW  04
0386E:  ADDWF  x0C,W
03870:  MOVWF  01
03872:  MOVLW  00
03874:  ADDWFC x0D,W
03876:  MOVWF  03
03878:  MOVF   01,W
0387A:  ADDLW  17
0387C:  MOVWF  01
0387E:  MOVLW  01
03880:  ADDWFC 03,F
03882:  MOVFF  01,70C
03886:  MOVFF  03,70D
0388A:  MOVF   x03,W
0388C:  MULLW  09
0388E:  MOVF   FF3,W
03890:  CLRF   x0F
03892:  MOVWF  x0E
03894:  MOVLW  05
03896:  ADDWF  x0E,W
03898:  MOVWF  01
0389A:  MOVLW  00
0389C:  ADDWFC x0F,W
0389E:  MOVWF  03
038A0:  MOVF   01,W
038A2:  ADDLW  D4
038A4:  MOVWF  FE9
038A6:  MOVLW  01
038A8:  ADDWFC 03,W
038AA:  MOVWF  FEA
038AC:  MOVFF  FEF,710
038B0:  MOVFF  FEC,01
038B4:  MOVFF  FEC,02
038B8:  MOVFF  FEC,03
038BC:  MOVFF  03,713
038C0:  MOVFF  02,712
038C4:  MOVFF  01,711
038C8:  MOVLB  0
038CA:  CALL   1CC8
038CE:  MOVFF  70D,FEA
038D2:  MOVFF  70C,FE9
038D6:  MOVFF  00,FEF
038DA:  MOVFF  01,FEC
038DE:  MOVFF  02,FEC
038E2:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038E6:  MOVLB  7
038E8:  MOVF   x03,W
038EA:  MULLW  26
038EC:  MOVF   FF3,W
038EE:  CLRF   x0D
038F0:  MOVWF  x0C
038F2:  MOVLW  08
038F4:  ADDWF  x0C,W
038F6:  MOVWF  01
038F8:  MOVLW  00
038FA:  ADDWFC x0D,W
038FC:  MOVWF  03
038FE:  MOVF   01,W
03900:  ADDLW  17
03902:  MOVWF  01
03904:  MOVLW  01
03906:  ADDWFC 03,F
03908:  MOVFF  01,70C
0390C:  MOVFF  03,70D
03910:  MOVF   x03,W
03912:  MULLW  26
03914:  MOVF   FF3,W
03916:  CLRF   x0F
03918:  MOVWF  x0E
0391A:  MOVLW  17
0391C:  ADDWF  x0E,W
0391E:  MOVWF  FE9
03920:  MOVLW  01
03922:  ADDWFC x0F,W
03924:  MOVWF  FEA
03926:  MOVFF  FEF,750
0392A:  MOVFF  FEC,751
0392E:  MOVFF  FEC,752
03932:  MOVFF  FEC,753
03936:  MOVF   x03,W
03938:  MULLW  10
0393A:  MOVF   FF3,W
0393C:  CLRF   x15
0393E:  MOVWF  x14
03940:  MOVLW  08
03942:  ADDWF  x14,W
03944:  MOVWF  01
03946:  MOVLW  00
03948:  ADDWFC x15,W
0394A:  MOVWF  03
0394C:  MOVF   01,W
0394E:  ADDLW  72
03950:  MOVWF  FE9
03952:  MOVLW  00
03954:  ADDWFC 03,W
03956:  MOVWF  FEA
03958:  MOVFF  FEF,754
0395C:  MOVFF  FEC,01
03960:  MOVFF  FEC,02
03964:  MOVFF  FEC,03
03968:  MOVFF  03,757
0396C:  MOVFF  02,756
03970:  MOVFF  01,755
03974:  MOVLB  0
03976:  CALL   0D96
0397A:  MOVFF  03,74D
0397E:  MOVFF  02,74C
03982:  MOVFF  01,74B
03986:  MOVFF  00,74A
0398A:  MOVLB  7
0398C:  MOVF   x03,W
0398E:  MULLW  10
03990:  MOVF   FF3,W
03992:  CLRF   x15
03994:  MOVWF  x14
03996:  MOVLW  72
03998:  ADDWF  x14,W
0399A:  MOVWF  FE9
0399C:  MOVLW  00
0399E:  ADDWFC x15,W
039A0:  MOVWF  FEA
039A2:  MOVFF  FEF,74E
039A6:  MOVFF  FEC,01
039AA:  MOVFF  FEC,02
039AE:  MOVFF  FEC,03
039B2:  BCF    FD8.1
039B4:  MOVFF  03,751
039B8:  MOVFF  02,750
039BC:  MOVFF  01,74F
039C0:  MOVLB  0
039C2:  CALL   0E8C
039C6:  MOVFF  70D,FEA
039CA:  MOVFF  70C,FE9
039CE:  MOVFF  00,FEF
039D2:  MOVFF  01,FEC
039D6:  MOVFF  02,FEC
039DA:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039DE:  MOVLB  7
039E0:  MOVF   x03,W
039E2:  MULLW  26
039E4:  MOVF   FF3,W
039E6:  CLRF   x0D
039E8:  MOVWF  x0C
039EA:  MOVLW  0C
039EC:  ADDWF  x0C,W
039EE:  MOVWF  01
039F0:  MOVLW  00
039F2:  ADDWFC x0D,W
039F4:  MOVWF  03
039F6:  MOVF   01,W
039F8:  ADDLW  17
039FA:  MOVWF  01
039FC:  MOVLW  01
039FE:  ADDWFC 03,F
03A00:  MOVFF  01,70C
03A04:  MOVFF  03,70D
03A08:  MOVF   x03,W
03A0A:  MULLW  26
03A0C:  MOVF   FF3,W
03A0E:  CLRF   x0F
03A10:  MOVWF  x0E
03A12:  MOVLW  04
03A14:  ADDWF  x0E,W
03A16:  MOVWF  01
03A18:  MOVLW  00
03A1A:  ADDWFC x0F,W
03A1C:  MOVWF  03
03A1E:  MOVF   01,W
03A20:  ADDLW  17
03A22:  MOVWF  FE9
03A24:  MOVLW  01
03A26:  ADDWFC 03,W
03A28:  MOVWF  FEA
03A2A:  MOVFF  FEF,750
03A2E:  MOVFF  FEC,751
03A32:  MOVFF  FEC,752
03A36:  MOVFF  FEC,753
03A3A:  MOVF   x03,W
03A3C:  MULLW  10
03A3E:  MOVF   FF3,W
03A40:  CLRF   x13
03A42:  MOVWF  x12
03A44:  MOVLW  0C
03A46:  ADDWF  x12,W
03A48:  MOVWF  01
03A4A:  MOVLW  00
03A4C:  ADDWFC x13,W
03A4E:  MOVWF  03
03A50:  MOVF   01,W
03A52:  ADDLW  72
03A54:  MOVWF  FE9
03A56:  MOVLW  00
03A58:  ADDWFC 03,W
03A5A:  MOVWF  FEA
03A5C:  MOVFF  FEF,754
03A60:  MOVFF  FEC,01
03A64:  MOVFF  FEC,02
03A68:  MOVFF  FEC,03
03A6C:  MOVFF  03,757
03A70:  MOVFF  02,756
03A74:  MOVFF  01,755
03A78:  MOVLB  0
03A7A:  CALL   0D96
03A7E:  MOVFF  03,74D
03A82:  MOVFF  02,74C
03A86:  MOVFF  01,74B
03A8A:  MOVFF  00,74A
03A8E:  MOVLB  7
03A90:  MOVF   x03,W
03A92:  MULLW  10
03A94:  MOVF   FF3,W
03A96:  CLRF   x13
03A98:  MOVWF  x12
03A9A:  MOVLW  04
03A9C:  ADDWF  x12,W
03A9E:  MOVWF  01
03AA0:  MOVLW  00
03AA2:  ADDWFC x13,W
03AA4:  MOVWF  03
03AA6:  MOVF   01,W
03AA8:  ADDLW  72
03AAA:  MOVWF  FE9
03AAC:  MOVLW  00
03AAE:  ADDWFC 03,W
03AB0:  MOVWF  FEA
03AB2:  MOVFF  FEF,74E
03AB6:  MOVFF  FEC,01
03ABA:  MOVFF  FEC,02
03ABE:  MOVFF  FEC,03
03AC2:  BCF    FD8.1
03AC4:  MOVFF  03,751
03AC8:  MOVFF  02,750
03ACC:  MOVFF  01,74F
03AD0:  MOVLB  0
03AD2:  CALL   0E8C
03AD6:  MOVFF  70D,FEA
03ADA:  MOVFF  70C,FE9
03ADE:  MOVFF  00,FEF
03AE2:  MOVFF  01,FEC
03AE6:  MOVFF  02,FEC
03AEA:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AEE:  MOVLB  7
03AF0:  CLRF   x07
03AF2:  CLRF   x06
03AF4:  CLRF   x05
03AF6:  CLRF   x04
03AF8:  CLRF   x0B
03AFA:  CLRF   x0A
03AFC:  CLRF   x09
03AFE:  MOVLW  7F
03B00:  MOVWF  x08
....................    
....................    if (adcVals[ch].cosCounts < 0){
03B02:  MOVF   x03,W
03B04:  MULLW  26
03B06:  MOVF   FF3,W
03B08:  CLRF   x0D
03B0A:  MOVWF  x0C
03B0C:  MOVLW  0C
03B0E:  ADDWF  x0C,W
03B10:  MOVWF  01
03B12:  MOVLW  00
03B14:  ADDWFC x0D,W
03B16:  MOVWF  03
03B18:  MOVF   01,W
03B1A:  ADDLW  17
03B1C:  MOVWF  FE9
03B1E:  MOVLW  01
03B20:  ADDWFC 03,W
03B22:  MOVWF  FEA
03B24:  MOVFF  FEF,746
03B28:  MOVFF  FEC,747
03B2C:  MOVFF  FEC,748
03B30:  MOVFF  FEC,749
03B34:  CLRF   x4D
03B36:  CLRF   x4C
03B38:  CLRF   x4B
03B3A:  CLRF   x4A
03B3C:  MOVLB  0
03B3E:  CALL   1D22
03B42:  BTFSS  FD8.0
03B44:  BRA    3CAE
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B46:  MOVLB  7
03B48:  MOVF   x03,W
03B4A:  MULLW  26
03B4C:  MOVF   FF3,W
03B4E:  CLRF   x0D
03B50:  MOVWF  x0C
03B52:  MOVLW  08
03B54:  ADDWF  x0C,W
03B56:  MOVWF  01
03B58:  MOVLW  00
03B5A:  ADDWFC x0D,W
03B5C:  MOVWF  03
03B5E:  MOVF   01,W
03B60:  ADDLW  17
03B62:  MOVWF  FE9
03B64:  MOVLW  01
03B66:  ADDWFC 03,W
03B68:  MOVWF  FEA
03B6A:  MOVFF  FEF,74A
03B6E:  MOVFF  FEC,70D
03B72:  MOVFF  FEC,74C
03B76:  MOVFF  FEC,74D
03B7A:  CLRF   x49
03B7C:  CLRF   x48
03B7E:  CLRF   x47
03B80:  CLRF   x46
03B82:  MOVFF  70D,74B
03B86:  MOVLB  0
03B88:  CALL   1D22
03B8C:  BNC   3BFA
03B8E:  MOVLB  7
03B90:  MOVF   x03,W
03B92:  MULLW  26
03B94:  MOVF   FF3,W
03B96:  CLRF   x0D
03B98:  MOVWF  x0C
03B9A:  MOVLW  10
03B9C:  ADDWF  x0C,W
03B9E:  MOVWF  01
03BA0:  MOVLW  00
03BA2:  ADDWFC x0D,W
03BA4:  MOVWF  03
03BA6:  MOVF   01,W
03BA8:  ADDLW  17
03BAA:  MOVWF  FE9
03BAC:  MOVLW  01
03BAE:  ADDWFC 03,W
03BB0:  MOVWF  FEA
03BB2:  MOVFF  FEF,746
03BB6:  MOVFF  FEC,747
03BBA:  MOVFF  FEC,748
03BBE:  MOVFF  FEC,749
03BC2:  CLRF   x4D
03BC4:  CLRF   x4C
03BC6:  CLRF   x4B
03BC8:  CLRF   x4A
03BCA:  MOVLB  0
03BCC:  CALL   1D22
03BD0:  BNC   3BFA
....................          adcVals[ch].npoles--;
03BD2:  MOVLB  7
03BD4:  MOVF   x03,W
03BD6:  MULLW  26
03BD8:  MOVF   FF3,W
03BDA:  CLRF   x0D
03BDC:  MOVWF  x0C
03BDE:  MOVLW  1C
03BE0:  ADDWF  x0C,W
03BE2:  MOVWF  01
03BE4:  MOVLW  00
03BE6:  ADDWFC x0D,W
03BE8:  MOVWF  03
03BEA:  MOVF   01,W
03BEC:  ADDLW  17
03BEE:  MOVWF  FE9
03BF0:  MOVLW  01
03BF2:  ADDWFC 03,W
03BF4:  MOVWF  FEA
03BF6:  DECF   FEF,F
....................       }
03BF8:  BRA    3CAC
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03BFA:  MOVLB  7
03BFC:  MOVF   x03,W
03BFE:  MULLW  26
03C00:  MOVF   FF3,W
03C02:  CLRF   x0D
03C04:  MOVWF  x0C
03C06:  MOVLW  08
03C08:  ADDWF  x0C,W
03C0A:  MOVWF  01
03C0C:  MOVLW  00
03C0E:  ADDWFC x0D,W
03C10:  MOVWF  03
03C12:  MOVF   01,W
03C14:  ADDLW  17
03C16:  MOVWF  FE9
03C18:  MOVLW  01
03C1A:  ADDWFC 03,W
03C1C:  MOVWF  FEA
03C1E:  MOVFF  FEF,746
03C22:  MOVFF  FEC,70D
03C26:  MOVFF  FEC,748
03C2A:  MOVFF  FEC,749
03C2E:  MOVFF  70D,747
03C32:  CLRF   x4D
03C34:  CLRF   x4C
03C36:  CLRF   x4B
03C38:  CLRF   x4A
03C3A:  MOVLB  0
03C3C:  CALL   1D22
03C40:  BNC   3CAE
03C42:  MOVLB  7
03C44:  MOVF   x03,W
03C46:  MULLW  26
03C48:  MOVF   FF3,W
03C4A:  CLRF   x0D
03C4C:  MOVWF  x0C
03C4E:  MOVLW  10
03C50:  ADDWF  x0C,W
03C52:  MOVWF  01
03C54:  MOVLW  00
03C56:  ADDWFC x0D,W
03C58:  MOVWF  03
03C5A:  MOVF   01,W
03C5C:  ADDLW  17
03C5E:  MOVWF  FE9
03C60:  MOVLW  01
03C62:  ADDWFC 03,W
03C64:  MOVWF  FEA
03C66:  MOVFF  FEF,74A
03C6A:  MOVFF  FEC,74B
03C6E:  MOVFF  FEC,74C
03C72:  MOVFF  FEC,74D
03C76:  CLRF   x49
03C78:  CLRF   x48
03C7A:  CLRF   x47
03C7C:  CLRF   x46
03C7E:  MOVLB  0
03C80:  CALL   1D22
03C84:  BNC   3CAE
....................          adcVals[ch].npoles++;
03C86:  MOVLB  7
03C88:  MOVF   x03,W
03C8A:  MULLW  26
03C8C:  MOVF   FF3,W
03C8E:  CLRF   x0D
03C90:  MOVWF  x0C
03C92:  MOVLW  1C
03C94:  ADDWF  x0C,W
03C96:  MOVWF  01
03C98:  MOVLW  00
03C9A:  ADDWFC x0D,W
03C9C:  MOVWF  03
03C9E:  MOVF   01,W
03CA0:  ADDLW  17
03CA2:  MOVWF  FE9
03CA4:  MOVLW  01
03CA6:  ADDWFC 03,W
03CA8:  MOVWF  FEA
03CAA:  INCF   FEF,F
03CAC:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03CAE:  MOVLB  7
03CB0:  MOVF   x03,W
03CB2:  MULLW  26
03CB4:  MOVF   FF3,W
03CB6:  CLRF   x0D
03CB8:  MOVWF  x0C
03CBA:  MOVLW  18
03CBC:  ADDWF  x0C,W
03CBE:  MOVWF  01
03CC0:  MOVLW  00
03CC2:  ADDWFC x0D,W
03CC4:  MOVWF  03
03CC6:  MOVF   01,W
03CC8:  ADDLW  17
03CCA:  MOVWF  01
03CCC:  MOVLW  01
03CCE:  ADDWFC 03,F
03CD0:  MOVFF  01,70C
03CD4:  MOVFF  03,70D
03CD8:  MOVFF  70B,753
03CDC:  MOVFF  70A,752
03CE0:  MOVFF  709,751
03CE4:  MOVFF  708,750
03CE8:  MOVLW  AA
03CEA:  MOVWF  x57
03CEC:  MOVLW  27
03CEE:  MOVWF  x56
03CF0:  MOVLW  1F
03CF2:  MOVWF  x55
03CF4:  MOVLW  86
03CF6:  MOVWF  x54
03CF8:  MOVLB  0
03CFA:  CALL   0D96
03CFE:  MOVFF  03,711
03D02:  MOVFF  02,710
03D06:  MOVFF  01,70F
03D0A:  MOVFF  00,70E
03D0E:  MOVLB  7
03D10:  MOVF   x03,W
03D12:  MULLW  26
03D14:  MOVF   FF3,W
03D16:  CLRF   x13
03D18:  MOVWF  x12
03D1A:  MOVLW  08
03D1C:  ADDWF  x12,W
03D1E:  MOVWF  01
03D20:  MOVLW  00
03D22:  ADDWFC x13,W
03D24:  MOVWF  03
03D26:  MOVF   01,W
03D28:  ADDLW  17
03D2A:  MOVWF  FE9
03D2C:  MOVLW  01
03D2E:  ADDWFC 03,W
03D30:  MOVWF  FEA
03D32:  MOVFF  FEF,712
03D36:  MOVFF  FEC,713
03D3A:  MOVFF  FEC,714
03D3E:  MOVFF  FEC,715
03D42:  MOVF   x03,W
03D44:  MULLW  26
03D46:  MOVF   FF3,W
03D48:  CLRF   x17
03D4A:  MOVWF  x16
03D4C:  MOVLW  0C
03D4E:  ADDWF  x16,W
03D50:  MOVWF  01
03D52:  MOVLW  00
03D54:  ADDWFC x17,W
03D56:  MOVWF  03
03D58:  MOVF   01,W
03D5A:  ADDLW  17
03D5C:  MOVWF  FE9
03D5E:  MOVLW  01
03D60:  ADDWFC 03,W
03D62:  MOVWF  FEA
03D64:  MOVFF  FEF,00
03D68:  MOVFF  FEC,01
03D6C:  MOVFF  FEC,02
03D70:  MOVFF  FEC,03
03D74:  MOVFF  03,719
03D78:  MOVFF  02,718
03D7C:  MOVFF  01,717
03D80:  MOVFF  00,716
03D84:  MOVFF  715,71D
03D88:  MOVFF  714,71C
03D8C:  MOVFF  713,71B
03D90:  MOVFF  712,71A
03D94:  MOVFF  03,721
03D98:  MOVFF  02,720
03D9C:  MOVFF  01,71F
03DA0:  MOVFF  00,71E
03DA4:  MOVLB  0
03DA6:  GOTO   2424
03DAA:  MOVFF  711,753
03DAE:  MOVFF  710,752
03DB2:  MOVFF  70F,751
03DB6:  MOVFF  70E,750
03DBA:  MOVFF  03,757
03DBE:  MOVFF  02,756
03DC2:  MOVFF  01,755
03DC6:  MOVFF  00,754
03DCA:  CALL   0D96
03DCE:  MOVFF  70D,FEA
03DD2:  MOVFF  70C,FE9
03DD6:  MOVFF  00,FEF
03DDA:  MOVFF  01,FEC
03DDE:  MOVFF  02,FEC
03DE2:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DE6:  MOVLB  7
03DE8:  MOVF   x03,W
03DEA:  MULLW  26
03DEC:  MOVF   FF3,W
03DEE:  CLRF   x0D
03DF0:  MOVWF  x0C
03DF2:  MOVLW  18
03DF4:  ADDWF  x0C,W
03DF6:  MOVWF  01
03DF8:  MOVLW  00
03DFA:  ADDWFC x0D,W
03DFC:  MOVWF  03
03DFE:  MOVF   01,W
03E00:  ADDLW  17
03E02:  MOVWF  FE9
03E04:  MOVLW  01
03E06:  ADDWFC 03,W
03E08:  MOVWF  FEA
03E0A:  MOVFF  FEF,70C
03E0E:  MOVFF  FEC,70D
03E12:  MOVFF  FEC,70E
03E16:  MOVFF  FEC,70F
03E1A:  CLRF   x53
03E1C:  CLRF   x52
03E1E:  MOVLW  7A
03E20:  MOVWF  x51
03E22:  MOVLW  88
03E24:  MOVWF  x50
03E26:  MOVFF  70B,757
03E2A:  MOVFF  70A,756
03E2E:  MOVFF  709,755
03E32:  MOVFF  708,754
03E36:  MOVLB  0
03E38:  CALL   0D96
03E3C:  MOVFF  03,713
03E40:  MOVFF  02,712
03E44:  MOVFF  01,711
03E48:  MOVFF  00,710
03E4C:  MOVLB  7
03E4E:  MOVF   x03,W
03E50:  MULLW  26
03E52:  MOVF   FF3,W
03E54:  CLRF   x15
03E56:  MOVWF  x14
03E58:  MOVLW  1C
03E5A:  ADDWF  x14,W
03E5C:  MOVWF  01
03E5E:  MOVLW  00
03E60:  ADDWFC x15,W
03E62:  MOVWF  03
03E64:  MOVF   01,W
03E66:  ADDLW  17
03E68:  MOVWF  FE9
03E6A:  MOVLW  01
03E6C:  ADDWFC 03,W
03E6E:  MOVWF  FEA
03E70:  MOVF   FEF,W
03E72:  CLRF   x3D
03E74:  MOVWF  x3C
03E76:  BTFSC  x3C.7
03E78:  DECF   x3D,F
03E7A:  MOVLB  0
03E7C:  CALL   26C6
03E80:  MOVFF  713,753
03E84:  MOVFF  712,752
03E88:  MOVFF  711,751
03E8C:  MOVFF  710,750
03E90:  MOVFF  03,757
03E94:  MOVFF  02,756
03E98:  MOVFF  01,755
03E9C:  MOVFF  00,754
03EA0:  CALL   0D96
03EA4:  MOVFF  FEA,711
03EA8:  MOVFF  FE9,710
03EAC:  BCF    FD8.1
03EAE:  MOVFF  70F,74D
03EB2:  MOVFF  70E,74C
03EB6:  MOVFF  70D,74B
03EBA:  MOVFF  70C,74A
03EBE:  MOVFF  03,751
03EC2:  MOVFF  02,750
03EC6:  MOVFF  01,74F
03ECA:  MOVFF  00,74E
03ECE:  CALL   0E8C
03ED2:  MOVFF  711,FEA
03ED6:  MOVFF  710,FE9
03EDA:  MOVFF  03,707
03EDE:  MOVFF  02,706
03EE2:  MOVFF  01,705
03EE6:  MOVFF  00,704
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EEA:  MOVLB  7
03EEC:  MOVF   x03,W
03EEE:  MULLW  26
03EF0:  MOVF   FF3,W
03EF2:  CLRF   x0D
03EF4:  MOVWF  x0C
03EF6:  MOVLW  1D
03EF8:  ADDWF  x0C,W
03EFA:  MOVWF  01
03EFC:  MOVLW  00
03EFE:  ADDWFC x0D,W
03F00:  MOVWF  03
03F02:  MOVF   01,W
03F04:  ADDLW  17
03F06:  MOVWF  01
03F08:  MOVLW  01
03F0A:  ADDWFC 03,F
03F0C:  MOVFF  01,70C
03F10:  MOVFF  03,70D
03F14:  MOVF   x03,W
03F16:  MULLW  18
03F18:  MOVF   FF3,W
03F1A:  CLRF   x0F
03F1C:  MOVWF  x0E
03F1E:  MOVLW  14
03F20:  ADDWF  x0E,W
03F22:  MOVWF  01
03F24:  MOVLW  00
03F26:  ADDWFC x0F,W
03F28:  MOVWF  03
03F2A:  MOVF   01,W
03F2C:  ADDLW  92
03F2E:  MOVWF  FE9
03F30:  MOVLW  00
03F32:  ADDWFC 03,W
03F34:  MOVWF  FEA
03F36:  MOVFF  FEF,754
03F3A:  MOVFF  FEC,01
03F3E:  MOVFF  FEC,02
03F42:  MOVFF  FEC,03
03F46:  MOVFF  707,753
03F4A:  MOVFF  706,752
03F4E:  MOVFF  705,751
03F52:  MOVFF  704,750
03F56:  MOVFF  03,757
03F5A:  MOVFF  02,756
03F5E:  MOVFF  01,755
03F62:  MOVLB  0
03F64:  CALL   0D96
03F68:  MOVFF  03,711
03F6C:  MOVFF  02,710
03F70:  MOVFF  01,70F
03F74:  MOVFF  00,70E
03F78:  MOVFF  03,71D
03F7C:  MOVFF  02,71C
03F80:  MOVFF  01,71B
03F84:  MOVFF  00,71A
03F88:  MOVLB  7
03F8A:  CLRF   x21
03F8C:  CLRF   x20
03F8E:  MOVLW  20
03F90:  MOVWF  x1F
03F92:  MOVLW  81
03F94:  MOVWF  x1E
03F96:  MOVLB  0
03F98:  CALL   3404
03F9C:  MOVFF  03,711
03FA0:  MOVFF  02,710
03FA4:  MOVFF  01,70F
03FA8:  MOVFF  00,70E
03FAC:  MOVLB  7
03FAE:  MOVF   x03,W
03FB0:  MULLW  18
03FB2:  MOVF   FF3,W
03FB4:  CLRF   x13
03FB6:  MOVWF  x12
03FB8:  MOVLW  10
03FBA:  ADDWF  x12,W
03FBC:  MOVWF  01
03FBE:  MOVLW  00
03FC0:  ADDWFC x13,W
03FC2:  MOVWF  03
03FC4:  MOVF   01,W
03FC6:  ADDLW  92
03FC8:  MOVWF  FE9
03FCA:  MOVLW  00
03FCC:  ADDWFC 03,W
03FCE:  MOVWF  FEA
03FD0:  MOVFF  FEF,754
03FD4:  MOVFF  FEC,01
03FD8:  MOVFF  FEC,02
03FDC:  MOVFF  FEC,03
03FE0:  MOVFF  707,753
03FE4:  MOVFF  706,752
03FE8:  MOVFF  705,751
03FEC:  MOVFF  704,750
03FF0:  MOVFF  03,757
03FF4:  MOVFF  02,756
03FF8:  MOVFF  01,755
03FFC:  MOVLB  0
03FFE:  CALL   0D96
04002:  MOVFF  03,715
04006:  MOVFF  02,714
0400A:  MOVFF  01,713
0400E:  MOVFF  00,712
04012:  MOVFF  03,71D
04016:  MOVFF  02,71C
0401A:  MOVFF  01,71B
0401E:  MOVFF  00,71A
04022:  MOVLB  7
04024:  CLRF   x21
04026:  CLRF   x20
04028:  CLRF   x1F
0402A:  MOVLW  81
0402C:  MOVWF  x1E
0402E:  MOVLB  0
04030:  CALL   3404
04034:  MOVFF  FEA,713
04038:  MOVFF  FE9,712
0403C:  BCF    FD8.1
0403E:  MOVFF  711,74D
04042:  MOVFF  710,74C
04046:  MOVFF  70F,74B
0404A:  MOVFF  70E,74A
0404E:  MOVFF  03,751
04052:  MOVFF  02,750
04056:  MOVFF  01,74F
0405A:  MOVFF  00,74E
0405E:  CALL   0E8C
04062:  MOVFF  713,FEA
04066:  MOVFF  712,FE9
0406A:  MOVFF  03,711
0406E:  MOVFF  02,710
04072:  MOVFF  01,70F
04076:  MOVFF  00,70E
0407A:  MOVLB  7
0407C:  MOVF   x03,W
0407E:  MULLW  18
04080:  MOVF   FF3,W
04082:  CLRF   x15
04084:  MOVWF  x14
04086:  MOVLW  0C
04088:  ADDWF  x14,W
0408A:  MOVWF  01
0408C:  MOVLW  00
0408E:  ADDWFC x15,W
04090:  MOVWF  03
04092:  MOVF   01,W
04094:  ADDLW  92
04096:  MOVWF  FE9
04098:  MOVLW  00
0409A:  ADDWFC 03,W
0409C:  MOVWF  FEA
0409E:  MOVFF  FEF,754
040A2:  MOVFF  FEC,01
040A6:  MOVFF  FEC,02
040AA:  MOVFF  FEC,03
040AE:  MOVFF  707,753
040B2:  MOVFF  706,752
040B6:  MOVFF  705,751
040BA:  MOVFF  704,750
040BE:  MOVFF  03,757
040C2:  MOVFF  02,756
040C6:  MOVFF  01,755
040CA:  MOVLB  0
040CC:  CALL   0D96
040D0:  MOVFF  03,717
040D4:  MOVFF  02,716
040D8:  MOVFF  01,715
040DC:  MOVFF  00,714
040E0:  MOVFF  03,71D
040E4:  MOVFF  02,71C
040E8:  MOVFF  01,71B
040EC:  MOVFF  00,71A
040F0:  MOVLB  7
040F2:  CLRF   x21
040F4:  CLRF   x20
040F6:  MOVLW  40
040F8:  MOVWF  x1F
040FA:  MOVLW  80
040FC:  MOVWF  x1E
040FE:  MOVLB  0
04100:  CALL   3404
04104:  MOVFF  FEA,715
04108:  MOVFF  FE9,714
0410C:  BCF    FD8.1
0410E:  MOVFF  711,74D
04112:  MOVFF  710,74C
04116:  MOVFF  70F,74B
0411A:  MOVFF  70E,74A
0411E:  MOVFF  03,751
04122:  MOVFF  02,750
04126:  MOVFF  01,74F
0412A:  MOVFF  00,74E
0412E:  CALL   0E8C
04132:  MOVFF  715,FEA
04136:  MOVFF  714,FE9
0413A:  MOVFF  03,711
0413E:  MOVFF  02,710
04142:  MOVFF  01,70F
04146:  MOVFF  00,70E
0414A:  MOVLB  7
0414C:  MOVF   x03,W
0414E:  MULLW  18
04150:  MOVF   FF3,W
04152:  CLRF   x17
04154:  MOVWF  x16
04156:  MOVLW  08
04158:  ADDWF  x16,W
0415A:  MOVWF  01
0415C:  MOVLW  00
0415E:  ADDWFC x17,W
04160:  MOVWF  03
04162:  MOVF   01,W
04164:  ADDLW  92
04166:  MOVWF  FE9
04168:  MOVLW  00
0416A:  ADDWFC 03,W
0416C:  MOVWF  FEA
0416E:  MOVFF  FEF,754
04172:  MOVFF  FEC,01
04176:  MOVFF  FEC,02
0417A:  MOVFF  FEC,03
0417E:  MOVFF  707,753
04182:  MOVFF  706,752
04186:  MOVFF  705,751
0418A:  MOVFF  704,750
0418E:  MOVFF  03,757
04192:  MOVFF  02,756
04196:  MOVFF  01,755
0419A:  MOVLB  0
0419C:  CALL   0D96
041A0:  MOVFF  03,719
041A4:  MOVFF  02,718
041A8:  MOVFF  01,717
041AC:  MOVFF  00,716
041B0:  MOVFF  03,71D
041B4:  MOVFF  02,71C
041B8:  MOVFF  01,71B
041BC:  MOVFF  00,71A
041C0:  MOVLB  7
041C2:  CLRF   x21
041C4:  CLRF   x20
041C6:  CLRF   x1F
041C8:  MOVLW  80
041CA:  MOVWF  x1E
041CC:  MOVLB  0
041CE:  CALL   3404
041D2:  MOVFF  FEA,717
041D6:  MOVFF  FE9,716
041DA:  BCF    FD8.1
041DC:  MOVFF  711,74D
041E0:  MOVFF  710,74C
041E4:  MOVFF  70F,74B
041E8:  MOVFF  70E,74A
041EC:  MOVFF  03,751
041F0:  MOVFF  02,750
041F4:  MOVFF  01,74F
041F8:  MOVFF  00,74E
041FC:  CALL   0E8C
04200:  MOVFF  717,FEA
04204:  MOVFF  716,FE9
04208:  MOVFF  03,711
0420C:  MOVFF  02,710
04210:  MOVFF  01,70F
04214:  MOVFF  00,70E
04218:  MOVLB  7
0421A:  MOVF   x03,W
0421C:  MULLW  18
0421E:  MOVF   FF3,W
04220:  CLRF   x19
04222:  MOVWF  x18
04224:  MOVLW  04
04226:  ADDWF  x18,W
04228:  MOVWF  01
0422A:  MOVLW  00
0422C:  ADDWFC x19,W
0422E:  MOVWF  03
04230:  MOVF   01,W
04232:  ADDLW  92
04234:  MOVWF  FE9
04236:  MOVLW  00
04238:  ADDWFC 03,W
0423A:  MOVWF  FEA
0423C:  MOVFF  FEF,754
04240:  MOVFF  FEC,01
04244:  MOVFF  FEC,02
04248:  MOVFF  FEC,03
0424C:  MOVFF  707,753
04250:  MOVFF  706,752
04254:  MOVFF  705,751
04258:  MOVFF  704,750
0425C:  MOVFF  03,757
04260:  MOVFF  02,756
04264:  MOVFF  01,755
04268:  MOVLB  0
0426A:  CALL   0D96
0426E:  MOVFF  FEA,719
04272:  MOVFF  FE9,718
04276:  BCF    FD8.1
04278:  MOVFF  711,74D
0427C:  MOVFF  710,74C
04280:  MOVFF  70F,74B
04284:  MOVFF  70E,74A
04288:  MOVFF  03,751
0428C:  MOVFF  02,750
04290:  MOVFF  01,74F
04294:  MOVFF  00,74E
04298:  CALL   0E8C
0429C:  MOVFF  719,FEA
042A0:  MOVFF  718,FE9
042A4:  MOVFF  03,74D
042A8:  MOVFF  02,74C
042AC:  MOVFF  01,74B
042B0:  MOVFF  00,74A
042B4:  MOVLB  7
042B6:  MOVF   x03,W
042B8:  MULLW  18
042BA:  MOVF   FF3,W
042BC:  CLRF   x1B
042BE:  MOVWF  x1A
042C0:  MOVLW  92
042C2:  ADDWF  x1A,W
042C4:  MOVWF  FE9
042C6:  MOVLW  00
042C8:  ADDWFC x1B,W
042CA:  MOVWF  FEA
042CC:  MOVFF  FEF,74E
042D0:  MOVFF  FEC,01
042D4:  MOVFF  FEC,02
042D8:  MOVFF  FEC,03
042DC:  BCF    FD8.1
042DE:  MOVFF  03,751
042E2:  MOVFF  02,750
042E6:  MOVFF  01,74F
042EA:  MOVLB  0
042EC:  CALL   0E8C
042F0:  MOVFF  70D,FEA
042F4:  MOVFF  70C,FE9
042F8:  MOVFF  00,FEF
042FC:  MOVFF  01,FEC
04300:  MOVFF  02,FEC
04304:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04308:  MOVLB  7
0430A:  MOVF   x03,F
0430C:  BNZ   436A
0430E:  MOVF   x03,W
04310:  MULLW  26
04312:  MOVF   FF3,W
04314:  CLRF   x0D
04316:  MOVWF  x0C
04318:  MOVLW  1D
0431A:  ADDWF  x0C,W
0431C:  MOVWF  01
0431E:  MOVLW  00
04320:  ADDWFC x0D,W
04322:  MOVWF  03
04324:  MOVF   01,W
04326:  ADDLW  17
04328:  MOVWF  FE9
0432A:  MOVLW  01
0432C:  ADDWFC 03,W
0432E:  MOVWF  FEA
04330:  MOVFF  FEF,750
04334:  MOVFF  FEC,751
04338:  MOVFF  FEC,752
0433C:  MOVFF  FEC,753
04340:  MOVF   FED,F
04342:  MOVF   FED,F
04344:  MOVF   FED,F
04346:  CLRF   x57
04348:  CLRF   x56
0434A:  MOVLW  80
0434C:  MOVWF  x55
0434E:  MOVLW  7F
04350:  MOVWF  x54
04352:  MOVLB  0
04354:  CALL   0D96
04358:  MOVFF  00,FEF
0435C:  MOVFF  01,FEC
04360:  MOVFF  02,FEC
04364:  MOVFF  03,FEC
04368:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
0436A:  MOVF   x03,W
0436C:  MULLW  28
0436E:  MOVF   FF3,W
04370:  CLRF   x0D
04372:  MOVWF  x0C
04374:  MOVLW  14
04376:  ADDWF  x0C,W
04378:  MOVWF  01
0437A:  MOVLW  00
0437C:  ADDWFC x0D,W
0437E:  MOVWF  03
04380:  MOVF   01,W
04382:  ADDLW  20
04384:  MOVWF  01
04386:  MOVLW  00
04388:  ADDWFC 03,F
0438A:  MOVFF  01,70C
0438E:  MOVFF  03,70D
04392:  MOVF   x03,W
04394:  MULLW  28
04396:  MOVF   FF3,W
04398:  CLRF   x0F
0439A:  MOVWF  x0E
0439C:  MOVLW  10
0439E:  ADDWF  x0E,W
043A0:  MOVWF  01
043A2:  MOVLW  00
043A4:  ADDWFC x0F,W
043A6:  MOVWF  03
043A8:  MOVF   01,W
043AA:  ADDLW  20
043AC:  MOVWF  FE9
043AE:  MOVLW  00
043B0:  ADDWFC 03,W
043B2:  MOVWF  FEA
043B4:  MOVFF  FEF,00
043B8:  MOVFF  FEC,01
043BC:  MOVFF  FEC,02
043C0:  MOVFF  FEC,03
043C4:  MOVFF  70D,FEA
043C8:  MOVFF  70C,FE9
043CC:  MOVFF  00,FEF
043D0:  MOVFF  01,FEC
043D4:  MOVFF  02,FEC
043D8:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043DC:  MOVF   x03,W
043DE:  MULLW  28
043E0:  MOVF   FF3,W
043E2:  CLRF   x0D
043E4:  MOVWF  x0C
043E6:  MOVLW  10
043E8:  ADDWF  x0C,W
043EA:  MOVWF  01
043EC:  MOVLW  00
043EE:  ADDWFC x0D,W
043F0:  MOVWF  03
043F2:  MOVF   01,W
043F4:  ADDLW  20
043F6:  MOVWF  01
043F8:  MOVLW  00
043FA:  ADDWFC 03,F
043FC:  MOVFF  01,70C
04400:  MOVFF  03,70D
04404:  MOVF   x03,W
04406:  MULLW  26
04408:  MOVF   FF3,W
0440A:  CLRF   x0F
0440C:  MOVWF  x0E
0440E:  MOVLW  1D
04410:  ADDWF  x0E,W
04412:  MOVWF  01
04414:  MOVLW  00
04416:  ADDWFC x0F,W
04418:  MOVWF  03
0441A:  MOVF   01,W
0441C:  ADDLW  17
0441E:  MOVWF  FE9
04420:  MOVLW  01
04422:  ADDWFC 03,W
04424:  MOVWF  FEA
04426:  MOVFF  FEF,00
0442A:  MOVFF  FEC,01
0442E:  MOVFF  FEC,02
04432:  MOVFF  FEC,03
04436:  MOVFF  70D,FEA
0443A:  MOVFF  70C,FE9
0443E:  MOVFF  00,FEF
04442:  MOVFF  01,FEC
04446:  MOVFF  02,FEC
0444A:  MOVFF  03,FEC
0444E:  MOVLB  0
04450:  GOTO   45B0 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
00202:  MOVLB  1
00204:  MOVF   xE7,W
00206:  MULLW  09
00208:  MOVF   FF3,W
0020A:  MOVLB  7
0020C:  CLRF   x72
0020E:  MOVWF  x71
00210:  MOVLW  D4
00212:  ADDWF  x71,W
00214:  MOVWF  FE9
00216:  MOVLW  01
00218:  ADDWFC x72,W
0021A:  MOVWF  FEA
0021C:  BTFSC  FEF.1
0021E:  BRA    0298
....................       smData[ch].adcBusy = true;
00220:  MOVLB  1
00222:  MOVF   xE7,W
00224:  MULLW  09
00226:  MOVF   FF3,W
00228:  MOVLB  7
0022A:  CLRF   x72
0022C:  MOVWF  x71
0022E:  MOVLW  D4
00230:  ADDWF  x71,W
00232:  MOVWF  FE9
00234:  MOVLW  01
00236:  ADDWFC x72,W
00238:  MOVWF  FEA
0023A:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
0023C:  MOVFF  1E7,771
00240:  MOVLB  0
00242:  BRA    01E6
....................       ch = !ch;
00244:  MOVLB  1
00246:  MOVF   xE7,F
00248:  BZ    024E
0024A:  MOVLW  00
0024C:  BRA    0250
0024E:  MOVLW  01
00250:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00252:  MOVF   xE7,F
00254:  BZ    025A
00256:  MOVLW  00
00258:  BRA    025C
0025A:  MOVLW  01
0025C:  MULLW  09
0025E:  MOVF   FF3,W
00260:  MOVLB  7
00262:  CLRF   x72
00264:  MOVWF  x71
00266:  MOVLW  D4
00268:  ADDWF  x71,W
0026A:  MOVWF  FE9
0026C:  MOVLW  01
0026E:  ADDWFC x72,W
00270:  MOVWF  FEA
00272:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00274:  MOVLB  1
00276:  MOVF   xE7,F
00278:  BZ    027E
0027A:  MOVLW  00
0027C:  BRA    0280
0027E:  MOVLW  01
00280:  MULLW  09
00282:  MOVF   FF3,W
00284:  MOVLB  7
00286:  CLRF   x72
00288:  MOVWF  x71
0028A:  MOVLW  D4
0028C:  ADDWF  x71,W
0028E:  MOVWF  FE9
00290:  MOVLW  01
00292:  ADDWFC x72,W
00294:  MOVWF  FEA
00296:  BCF    FEF.1
....................    }
00298:  MOVLB  0
0029A:  GOTO   035C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
0176C:  MOVLB  7
0176E:  CLRF   x17
01770:  CLRF   x16
01772:  CLRF   x15
01774:  CLRF   x14
01776:  CLRF   x1B
01778:  CLRF   x1A
0177A:  CLRF   x19
0177C:  CLRF   x18
0177E:  CLRF   x1F
01780:  CLRF   x1E
01782:  CLRF   x1D
01784:  CLRF   x1C
01786:  CLRF   x23
01788:  CLRF   x22
0178A:  CLRF   x21
0178C:  CLRF   x20
0178E:  CLRF   x27
01790:  CLRF   x26
01792:  CLRF   x25
01794:  CLRF   x24
01796:  CLRF   x2B
01798:  CLRF   x2A
0179A:  CLRF   x29
0179C:  CLRF   x28
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
0179E:  MOVF   x03,F
017A0:  BNZ   17C4
....................       sQ_ch = sQ_x;
017A2:  MOVLW  01
017A4:  MOVWF  x0D
017A6:  MOVLW  80
017A8:  MOVWF  x0C
....................       cQ_ch = cQ_x;
017AA:  MOVLW  01
017AC:  MOVWF  x0F
017AE:  MOVLW  94
017B0:  MOVWF  x0E
....................       sIn_ch = &sIn_x;
017B2:  MOVLW  01
017B4:  MOVWF  x11
017B6:  MOVLW  D0
017B8:  MOVWF  x10
....................       cIn_ch = &cIn_x;
017BA:  MOVLW  01
017BC:  MOVWF  x13
017BE:  MOVLW  D1
017C0:  MOVWF  x12
....................    }
017C2:  BRA    17E8
....................    else if (ch==1){
017C4:  DECFSZ x03,W
017C6:  BRA    17E8
....................       sQ_ch = sQ_y;
017C8:  MOVLW  01
017CA:  MOVWF  x0D
017CC:  MOVLW  A8
017CE:  MOVWF  x0C
....................       cQ_ch = cQ_y;
017D0:  MOVLW  01
017D2:  MOVWF  x0F
017D4:  MOVLW  BC
017D6:  MOVWF  x0E
....................       sIn_ch = &sIn_y;
017D8:  MOVLW  01
017DA:  MOVWF  x11
017DC:  MOVLW  D2
017DE:  MOVWF  x10
....................       cIn_ch = &cIn_y;
017E0:  MOVLW  01
017E2:  MOVWF  x13
017E4:  MOVLW  D3
017E6:  MOVWF  x12
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017E8:  MOVFF  70D,72E
017EC:  MOVFF  70C,72D
017F0:  MOVFF  711,730
017F4:  MOVFF  710,72F
017F8:  MOVFF  707,734
017FC:  MOVFF  706,733
01800:  MOVFF  705,732
01804:  MOVFF  704,731
01808:  MOVLB  0
0180A:  CALL   08FA
....................    push(cQ_ch, cIn_ch, cosCnts);
0180E:  MOVFF  70F,72E
01812:  MOVFF  70E,72D
01816:  MOVFF  713,730
0181A:  MOVFF  712,72F
0181E:  MOVFF  70B,734
01822:  MOVFF  70A,733
01826:  MOVFF  709,732
0182A:  MOVFF  708,731
0182E:  CALL   08FA
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01832:  MOVLB  7
01834:  MOVFF  70C,FE9
01838:  MOVFF  70D,FEA
0183C:  MOVFF  FEF,71C
01840:  MOVFF  FEC,71D
01844:  MOVFF  FEC,71E
01848:  MOVFF  FEC,71F
....................    sinMin=sQ_ch[0];
0184C:  MOVFF  70C,FE9
01850:  MOVFF  70D,FEA
01854:  MOVFF  FEF,720
01858:  MOVFF  FEC,721
0185C:  MOVFF  FEC,722
01860:  MOVFF  FEC,723
....................    cosMax=cQ_ch[0];
01864:  MOVFF  70E,FE9
01868:  MOVFF  70F,FEA
0186C:  MOVFF  FEF,724
01870:  MOVFF  FEC,725
01874:  MOVFF  FEC,726
01878:  MOVFF  FEC,727
....................    cosMin=cQ_ch[0];
0187C:  MOVFF  70E,FE9
01880:  MOVFF  70F,FEA
01884:  MOVFF  FEF,728
01888:  MOVFF  FEC,729
0188C:  MOVFF  FEC,72A
01890:  MOVFF  FEC,72B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01894:  MOVLW  01
01896:  MOVWF  x2C
01898:  MOVF   x2C,W
0189A:  SUBLW  04
0189C:  BTFSS  FD8.0
0189E:  BRA    1BAE
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
018A0:  CLRF   x42
018A2:  MOVFF  72C,741
018A6:  CLRF   x44
018A8:  MOVLW  04
018AA:  MOVWF  x43
018AC:  MOVLB  0
018AE:  CALL   08AC
018B2:  MOVFF  02,03
018B6:  MOVF   01,W
018B8:  MOVLB  7
018BA:  ADDWF  x0C,W
018BC:  MOVWF  FE9
018BE:  MOVF   x0D,W
018C0:  ADDWFC 02,W
018C2:  MOVWF  FEA
018C4:  MOVFF  FEF,00
018C8:  MOVFF  FEC,01
018CC:  MOVFF  FEC,02
018D0:  MOVFF  FEC,03
018D4:  BTFSS  x1F.7
018D6:  BRA    18DE
018D8:  BTFSS  03.7
018DA:  BRA    1900
018DC:  BRA    18E2
018DE:  BTFSC  03.7
018E0:  BRA    1936
018E2:  MOVF   x1F,W
018E4:  SUBWF  03,W
018E6:  BNC   1936
018E8:  BNZ   1900
018EA:  MOVF   x1E,W
018EC:  SUBWF  02,W
018EE:  BNC   1936
018F0:  BNZ   1900
018F2:  MOVF   x1D,W
018F4:  SUBWF  01,W
018F6:  BNC   1936
018F8:  BNZ   1900
018FA:  MOVF   00,W
018FC:  SUBWF  x1C,W
018FE:  BC    1936
01900:  CLRF   x42
01902:  MOVFF  72C,741
01906:  CLRF   x44
01908:  MOVLW  04
0190A:  MOVWF  x43
0190C:  MOVLB  0
0190E:  CALL   08AC
01912:  MOVFF  02,03
01916:  MOVF   01,W
01918:  MOVLB  7
0191A:  ADDWF  x0C,W
0191C:  MOVWF  FE9
0191E:  MOVF   x0D,W
01920:  ADDWFC 02,W
01922:  MOVWF  FEA
01924:  MOVFF  FEF,71C
01928:  MOVFF  FEC,71D
0192C:  MOVFF  FEC,71E
01930:  MOVFF  FEC,71F
01934:  MOVF   x1C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
01936:  CLRF   x42
01938:  MOVFF  72C,741
0193C:  CLRF   x44
0193E:  MOVLW  04
01940:  MOVWF  x43
01942:  MOVLB  0
01944:  CALL   08AC
01948:  MOVFF  02,03
0194C:  MOVF   01,W
0194E:  MOVLB  7
01950:  ADDWF  x0C,W
01952:  MOVWF  FE9
01954:  MOVF   x0D,W
01956:  ADDWFC 02,W
01958:  MOVWF  FEA
0195A:  MOVFF  FEF,00
0195E:  MOVFF  FEC,01
01962:  MOVFF  FEC,02
01966:  MOVFF  FEC,03
0196A:  BTFSS  03.7
0196C:  BRA    1974
0196E:  BTFSS  x23.7
01970:  BRA    1996
01972:  BRA    1978
01974:  BTFSC  x23.7
01976:  BRA    19DA
01978:  MOVF   03,W
0197A:  SUBWF  x23,W
0197C:  BNC   19DA
0197E:  BNZ   1996
01980:  MOVF   02,W
01982:  SUBWF  x22,W
01984:  BNC   19DA
01986:  BNZ   1996
01988:  MOVF   01,W
0198A:  SUBWF  x21,W
0198C:  BNC   19DA
0198E:  BNZ   1996
01990:  MOVF   x20,W
01992:  SUBWF  00,W
01994:  BC    19DA
01996:  CLRF   x42
01998:  MOVFF  72C,741
0199C:  CLRF   x44
0199E:  MOVLW  04
019A0:  MOVWF  x43
019A2:  MOVLB  0
019A4:  CALL   08AC
019A8:  MOVFF  02,03
019AC:  MOVF   01,W
019AE:  MOVLB  7
019B0:  ADDWF  x0C,W
019B2:  MOVWF  FE9
019B4:  MOVF   x0D,W
019B6:  ADDWFC 02,W
019B8:  MOVWF  FEA
019BA:  MOVFF  FEF,720
019BE:  MOVFF  FEC,721
019C2:  MOVFF  FEC,722
019C6:  MOVFF  FEC,723
019CA:  MOVFF  720,00
019CE:  MOVFF  721,01
019D2:  MOVFF  722,02
019D6:  MOVFF  723,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019DA:  CLRF   x42
019DC:  MOVFF  72C,741
019E0:  CLRF   x44
019E2:  MOVLW  04
019E4:  MOVWF  x43
019E6:  MOVLB  0
019E8:  CALL   08AC
019EC:  MOVFF  02,03
019F0:  MOVF   01,W
019F2:  MOVLB  7
019F4:  ADDWF  x0E,W
019F6:  MOVWF  FE9
019F8:  MOVF   x0F,W
019FA:  ADDWFC 02,W
019FC:  MOVWF  FEA
019FE:  MOVFF  FEF,00
01A02:  MOVFF  FEC,01
01A06:  MOVFF  FEC,02
01A0A:  MOVFF  FEC,03
01A0E:  BTFSS  x27.7
01A10:  BRA    1A18
01A12:  BTFSS  03.7
01A14:  BRA    1A3A
01A16:  BRA    1A1C
01A18:  BTFSC  03.7
01A1A:  BRA    1A7E
01A1C:  MOVF   x27,W
01A1E:  SUBWF  03,W
01A20:  BNC   1A7E
01A22:  BNZ   1A3A
01A24:  MOVF   x26,W
01A26:  SUBWF  02,W
01A28:  BNC   1A7E
01A2A:  BNZ   1A3A
01A2C:  MOVF   x25,W
01A2E:  SUBWF  01,W
01A30:  BNC   1A7E
01A32:  BNZ   1A3A
01A34:  MOVF   00,W
01A36:  SUBWF  x24,W
01A38:  BC    1A7E
01A3A:  CLRF   x42
01A3C:  MOVFF  72C,741
01A40:  CLRF   x44
01A42:  MOVLW  04
01A44:  MOVWF  x43
01A46:  MOVLB  0
01A48:  CALL   08AC
01A4C:  MOVFF  02,03
01A50:  MOVF   01,W
01A52:  MOVLB  7
01A54:  ADDWF  x0E,W
01A56:  MOVWF  FE9
01A58:  MOVF   x0F,W
01A5A:  ADDWFC 02,W
01A5C:  MOVWF  FEA
01A5E:  MOVFF  FEF,724
01A62:  MOVFF  FEC,725
01A66:  MOVFF  FEC,726
01A6A:  MOVFF  FEC,727
01A6E:  MOVFF  724,00
01A72:  MOVFF  725,01
01A76:  MOVFF  726,02
01A7A:  MOVFF  727,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A7E:  CLRF   x42
01A80:  MOVFF  72C,741
01A84:  CLRF   x44
01A86:  MOVLW  04
01A88:  MOVWF  x43
01A8A:  MOVLB  0
01A8C:  CALL   08AC
01A90:  MOVFF  02,03
01A94:  MOVF   01,W
01A96:  MOVLB  7
01A98:  ADDWF  x0E,W
01A9A:  MOVWF  FE9
01A9C:  MOVF   x0F,W
01A9E:  ADDWFC 02,W
01AA0:  MOVWF  FEA
01AA2:  MOVFF  FEF,00
01AA6:  MOVFF  FEC,01
01AAA:  MOVFF  FEC,02
01AAE:  MOVFF  FEC,03
01AB2:  BTFSS  03.7
01AB4:  BRA    1ABC
01AB6:  BTFSS  x2B.7
01AB8:  BRA    1ADE
01ABA:  BRA    1AC0
01ABC:  BTFSC  x2B.7
01ABE:  BRA    1B22
01AC0:  MOVF   03,W
01AC2:  SUBWF  x2B,W
01AC4:  BNC   1B22
01AC6:  BNZ   1ADE
01AC8:  MOVF   02,W
01ACA:  SUBWF  x2A,W
01ACC:  BNC   1B22
01ACE:  BNZ   1ADE
01AD0:  MOVF   01,W
01AD2:  SUBWF  x29,W
01AD4:  BNC   1B22
01AD6:  BNZ   1ADE
01AD8:  MOVF   x28,W
01ADA:  SUBWF  00,W
01ADC:  BC    1B22
01ADE:  CLRF   x42
01AE0:  MOVFF  72C,741
01AE4:  CLRF   x44
01AE6:  MOVLW  04
01AE8:  MOVWF  x43
01AEA:  MOVLB  0
01AEC:  CALL   08AC
01AF0:  MOVFF  02,03
01AF4:  MOVF   01,W
01AF6:  MOVLB  7
01AF8:  ADDWF  x0E,W
01AFA:  MOVWF  FE9
01AFC:  MOVF   x0F,W
01AFE:  ADDWFC 02,W
01B00:  MOVWF  FEA
01B02:  MOVFF  FEF,728
01B06:  MOVFF  FEC,729
01B0A:  MOVFF  FEC,72A
01B0E:  MOVFF  FEC,72B
01B12:  MOVFF  728,00
01B16:  MOVFF  729,01
01B1A:  MOVFF  72A,02
01B1E:  MOVFF  72B,03
....................       sumSin+=sQ_ch[i];
01B22:  CLRF   x42
01B24:  MOVFF  72C,741
01B28:  CLRF   x44
01B2A:  MOVLW  04
01B2C:  MOVWF  x43
01B2E:  MOVLB  0
01B30:  CALL   08AC
01B34:  MOVFF  02,03
01B38:  MOVF   01,W
01B3A:  MOVLB  7
01B3C:  ADDWF  x0C,W
01B3E:  MOVWF  FE9
01B40:  MOVF   x0D,W
01B42:  ADDWFC 02,W
01B44:  MOVWF  FEA
01B46:  MOVFF  FEF,00
01B4A:  MOVFF  FEC,01
01B4E:  MOVFF  FEC,02
01B52:  MOVFF  FEC,03
01B56:  MOVF   00,W
01B58:  ADDWF  x14,F
01B5A:  MOVF   01,W
01B5C:  ADDWFC x15,F
01B5E:  MOVF   02,W
01B60:  ADDWFC x16,F
01B62:  MOVF   03,W
01B64:  ADDWFC x17,F
....................       sumCos+=cQ_ch[i];
01B66:  CLRF   x42
01B68:  MOVFF  72C,741
01B6C:  CLRF   x44
01B6E:  MOVLW  04
01B70:  MOVWF  x43
01B72:  MOVLB  0
01B74:  CALL   08AC
01B78:  MOVFF  02,03
01B7C:  MOVF   01,W
01B7E:  MOVLB  7
01B80:  ADDWF  x0E,W
01B82:  MOVWF  FE9
01B84:  MOVF   x0F,W
01B86:  ADDWFC 02,W
01B88:  MOVWF  FEA
01B8A:  MOVFF  FEF,00
01B8E:  MOVFF  FEC,01
01B92:  MOVFF  FEC,02
01B96:  MOVFF  FEC,03
01B9A:  MOVF   00,W
01B9C:  ADDWF  x18,F
01B9E:  MOVF   01,W
01BA0:  ADDWFC x19,F
01BA2:  MOVF   02,W
01BA4:  ADDWFC x1A,F
01BA6:  MOVF   03,W
01BA8:  ADDWFC x1B,F
01BAA:  INCF   x2C,F
01BAC:  BRA    1898
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01BAE:  MOVF   x20,W
01BB0:  ADDWF  x1C,W
01BB2:  MOVWF  00
01BB4:  MOVF   x21,W
01BB6:  ADDWFC x1D,W
01BB8:  MOVWF  01
01BBA:  MOVF   x22,W
01BBC:  ADDWFC x1E,W
01BBE:  MOVWF  02
01BC0:  MOVF   x23,W
01BC2:  ADDWFC x1F,W
01BC4:  MOVWF  03
01BC6:  MOVF   00,W
01BC8:  SUBWF  x14,F
01BCA:  MOVF   01,W
01BCC:  SUBWFB x15,F
01BCE:  MOVF   02,W
01BD0:  SUBWFB x16,F
01BD2:  MOVF   03,W
01BD4:  SUBWFB x17,F
....................    sumCos-=(cosMax+cosMin);
01BD6:  MOVF   x28,W
01BD8:  ADDWF  x24,W
01BDA:  MOVWF  00
01BDC:  MOVF   x29,W
01BDE:  ADDWFC x25,W
01BE0:  MOVWF  01
01BE2:  MOVF   x2A,W
01BE4:  ADDWFC x26,W
01BE6:  MOVWF  02
01BE8:  MOVF   x2B,W
01BEA:  ADDWFC x27,W
01BEC:  MOVWF  03
01BEE:  MOVF   00,W
01BF0:  SUBWF  x18,F
01BF2:  MOVF   01,W
01BF4:  SUBWFB x19,F
01BF6:  MOVF   02,W
01BF8:  SUBWFB x1A,F
01BFA:  MOVF   03,W
01BFC:  SUBWFB x1B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BFE:  MOVF   x03,W
01C00:  MULLW  09
01C02:  MOVF   FF3,W
01C04:  CLRF   x2E
01C06:  MOVWF  x2D
01C08:  MOVLW  01
01C0A:  ADDWF  x2D,W
01C0C:  MOVWF  01
01C0E:  MOVLW  00
01C10:  ADDWFC x2E,W
01C12:  MOVWF  03
01C14:  MOVF   01,W
01C16:  ADDLW  D4
01C18:  MOVWF  FE9
01C1A:  MOVLW  01
01C1C:  ADDWFC 03,W
01C1E:  MOVWF  FEA
01C20:  MOVFF  FEA,730
01C24:  MOVFF  FE9,72F
01C28:  BCF    FD8.1
01C2A:  MOVFF  717,734
01C2E:  MOVFF  716,733
01C32:  MOVFF  715,732
01C36:  MOVFF  714,731
01C3A:  CLRF   x38
01C3C:  CLRF   x37
01C3E:  CLRF   x36
01C40:  MOVLW  03
01C42:  MOVWF  x35
01C44:  MOVLB  0
01C46:  RCALL  1682
01C48:  MOVFF  730,FEA
01C4C:  MOVFF  72F,FE9
01C50:  MOVFF  00,FEF
01C54:  MOVFF  01,FEC
01C58:  MOVFF  02,FEC
01C5C:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C60:  MOVLB  7
01C62:  MOVF   x03,W
01C64:  MULLW  09
01C66:  MOVF   FF3,W
01C68:  CLRF   x2E
01C6A:  MOVWF  x2D
01C6C:  MOVLW  05
01C6E:  ADDWF  x2D,W
01C70:  MOVWF  01
01C72:  MOVLW  00
01C74:  ADDWFC x2E,W
01C76:  MOVWF  03
01C78:  MOVF   01,W
01C7A:  ADDLW  D4
01C7C:  MOVWF  FE9
01C7E:  MOVLW  01
01C80:  ADDWFC 03,W
01C82:  MOVWF  FEA
01C84:  MOVFF  FEA,730
01C88:  MOVFF  FE9,72F
01C8C:  BCF    FD8.1
01C8E:  MOVFF  71B,734
01C92:  MOVFF  71A,733
01C96:  MOVFF  719,732
01C9A:  MOVFF  718,731
01C9E:  CLRF   x38
01CA0:  CLRF   x37
01CA2:  CLRF   x36
01CA4:  MOVLW  03
01CA6:  MOVWF  x35
01CA8:  MOVLB  0
01CAA:  RCALL  1682
01CAC:  MOVFF  730,FEA
01CB0:  MOVFF  72F,FE9
01CB4:  MOVFF  00,FEF
01CB8:  MOVFF  01,FEC
01CBC:  MOVFF  02,FEC
01CC0:  MOVFF  03,FEC
01CC4:  GOTO   4538 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04454:  MOVLB  6
04456:  CLRF   xFE
04458:  CLRF   xFD
0445A:  CLRF   xFC
0445C:  CLRF   xFB
0445E:  MOVLB  7
04460:  CLRF   x02
04462:  CLRF   x01
04464:  CLRF   x00
04466:  MOVLB  6
04468:  CLRF   xFF
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
0446A:  MOVLB  1
0446C:  MOVF   xE8,W
0446E:  MULLW  09
04470:  MOVF   FF3,W
04472:  MOVLB  7
04474:  CLRF   x04
04476:  MOVWF  x03
04478:  MOVLW  D4
0447A:  ADDWF  x03,W
0447C:  MOVWF  FE9
0447E:  MOVLW  01
04480:  ADDWFC x04,W
04482:  MOVWF  FEA
04484:  BTFSC  FEF.1
04486:  BRA    4604
04488:  MOVLB  1
0448A:  MOVF   xE8,W
0448C:  MULLW  09
0448E:  MOVF   FF3,W
04490:  MOVLB  7
04492:  CLRF   x06
04494:  MOVWF  x05
04496:  MOVLW  D4
04498:  ADDWF  x05,W
0449A:  MOVWF  FE9
0449C:  MOVLW  01
0449E:  ADDWFC x06,W
044A0:  MOVWF  FEA
044A2:  BTFSS  FEF.0
044A4:  BRA    4604
....................       smData[ch].adcBusy = true;
044A6:  MOVLB  1
044A8:  MOVF   xE8,W
044AA:  MULLW  09
044AC:  MOVF   FF3,W
044AE:  MOVLB  7
044B0:  CLRF   x04
044B2:  MOVWF  x03
044B4:  MOVLW  D4
044B6:  ADDWF  x03,W
044B8:  MOVWF  FE9
044BA:  MOVLW  01
044BC:  ADDWFC x04,W
044BE:  MOVWF  FEA
044C0:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
044C2:  BCF    FD8.0
044C4:  MOVLB  1
044C6:  RLCF   xE8,W
044C8:  MOVLB  7
044CA:  MOVWF  x03
044CC:  MOVWF  x04
044CE:  MOVLB  0
044D0:  CALL   0852
044D4:  MOVFF  03,6FE
044D8:  MOVFF  02,6FD
044DC:  MOVFF  01,6FC
044E0:  MOVFF  00,6FB
....................       cosNew = ads_read_data(ch*2+1);      
044E4:  BCF    FD8.0
044E6:  MOVLB  1
044E8:  RLCF   xE8,W
044EA:  ADDLW  01
044EC:  MOVLB  7
044EE:  MOVWF  x03
044F0:  MOVWF  x04
044F2:  MOVLB  0
044F4:  CALL   0852
044F8:  MOVFF  03,702
044FC:  MOVFF  02,701
04500:  MOVFF  01,700
04504:  MOVFF  00,6FF
....................       
....................       if (adcFilter){
04508:  MOVLB  1
0450A:  BTFSS  x63.0
0450C:  BRA    453C
....................          iqm_ring_buffer(ch, sinNew, cosNew);
0450E:  MOVFF  1E8,703
04512:  MOVFF  6FE,707
04516:  MOVFF  6FD,706
0451A:  MOVFF  6FC,705
0451E:  MOVFF  6FB,704
04522:  MOVFF  702,70B
04526:  MOVFF  701,70A
0452A:  MOVFF  700,709
0452E:  MOVFF  6FF,708
04532:  MOVLB  0
04534:  GOTO   176C
....................       }
04538:  BRA    45A8
0453A:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
0453C:  MOVF   xE8,W
0453E:  MULLW  09
04540:  MOVF   FF3,W
04542:  MOVLB  7
04544:  CLRF   x04
04546:  MOVWF  x03
04548:  MOVLW  01
0454A:  ADDWF  x03,W
0454C:  MOVWF  01
0454E:  MOVLW  00
04550:  ADDWFC x04,W
04552:  MOVWF  03
04554:  MOVF   01,W
04556:  ADDLW  D4
04558:  MOVWF  FE9
0455A:  MOVLW  01
0455C:  ADDWFC 03,W
0455E:  MOVWF  FEA
04560:  MOVFF  6FB,FEF
04564:  MOVFF  6FC,FEC
04568:  MOVFF  6FD,FEC
0456C:  MOVFF  6FE,FEC
....................          smData[ch].avgCos = cosNew;
04570:  MOVLB  1
04572:  MOVF   xE8,W
04574:  MULLW  09
04576:  MOVF   FF3,W
04578:  MOVLB  7
0457A:  CLRF   x04
0457C:  MOVWF  x03
0457E:  MOVLW  05
04580:  ADDWF  x03,W
04582:  MOVWF  01
04584:  MOVLW  00
04586:  ADDWFC x04,W
04588:  MOVWF  03
0458A:  MOVF   01,W
0458C:  ADDLW  D4
0458E:  MOVWF  FE9
04590:  MOVLW  01
04592:  ADDWFC 03,W
04594:  MOVWF  FEA
04596:  MOVFF  6FF,FEF
0459A:  MOVFF  700,FEC
0459E:  MOVFF  701,FEC
045A2:  MOVFF  702,FEC
045A6:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045A8:  MOVFF  1E8,703
045AC:  GOTO   3702
....................       ch = !ch;
045B0:  MOVLB  1
045B2:  MOVF   xE8,F
045B4:  BZ    45BA
045B6:  MOVLW  00
045B8:  BRA    45BC
045BA:  MOVLW  01
045BC:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
045BE:  MOVF   xE8,F
045C0:  BZ    45C6
045C2:  MOVLW  00
045C4:  BRA    45C8
045C6:  MOVLW  01
045C8:  MULLW  09
045CA:  MOVF   FF3,W
045CC:  MOVLB  7
045CE:  CLRF   x04
045D0:  MOVWF  x03
045D2:  MOVLW  D4
045D4:  ADDWF  x03,W
045D6:  MOVWF  FE9
045D8:  MOVLW  01
045DA:  ADDWFC x04,W
045DC:  MOVWF  FEA
045DE:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045E0:  MOVLB  1
045E2:  MOVF   xE8,F
045E4:  BZ    45EA
045E6:  MOVLW  00
045E8:  BRA    45EC
045EA:  MOVLW  01
045EC:  MULLW  09
045EE:  MOVF   FF3,W
045F0:  MOVLB  7
045F2:  CLRF   x04
045F4:  MOVWF  x03
045F6:  MOVLW  D4
045F8:  ADDWF  x03,W
045FA:  MOVWF  FE9
045FC:  MOVLW  01
045FE:  ADDWFC x04,W
04600:  MOVWF  FEA
04602:  BCF    FEF.1
....................    }
04604:  MOVLB  0
04606:  GOTO   A750 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00960:  MOVLB  6
00962:  CLRF   xFB
00964:  CLRF   xFC
00966:  CLRF   xFD
00968:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
0096A:  CLRF   xFF
0096C:  MOVF   xFF,W
0096E:  SUBLW  03
00970:  BNC   09A6
....................       rc0=reg0config;
00972:  MOVLW  30
00974:  MOVWF  xFB
....................       rc1=reg1config;
00976:  MOVLW  10
00978:  MOVWF  xFC
....................       rc2=reg2config;
0097A:  CLRF   xFD
....................       rc3=reg3config;
0097C:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
0097E:  MOVFF  6FF,701
00982:  MOVFF  6FB,702
00986:  MOVFF  6FC,703
0098A:  MOVFF  6FD,704
0098E:  MOVFF  6FE,705
00992:  MOVLB  0
00994:  BRA    0778
....................       delay_ms(100);
00996:  MOVLW  64
00998:  MOVLB  7
0099A:  MOVWF  x01
0099C:  MOVLB  0
0099E:  RCALL  03D6
009A0:  MOVLB  6
009A2:  INCF   xFF,F
009A4:  BRA    096C
....................    }
....................    
....................    if (adcFilter){
009A6:  MOVLB  1
009A8:  BTFSS  x63.0
009AA:  BRA    0ACC
....................       for (int i = 0; i < BUFFER_SIZE; i++){
009AC:  MOVLB  7
009AE:  CLRF   x00
009B0:  MOVF   x00,W
009B2:  SUBLW  04
009B4:  BTFSS  FD8.0
009B6:  BRA    0ACA
....................          ads_start_conv_all();
009B8:  MOVLB  0
009BA:  BRA    0822
....................          delay_ms(50);
009BC:  MOVLW  32
009BE:  MOVLB  7
009C0:  MOVWF  x01
009C2:  MOVLB  0
009C4:  RCALL  03D6
....................          push(sQ_x, &sIn_x, ads_read_data(0));
009C6:  MOVLB  7
009C8:  CLRF   x04
009CA:  MOVLB  0
009CC:  RCALL  0852
009CE:  MOVFF  03,704
009D2:  MOVFF  02,703
009D6:  MOVFF  01,702
009DA:  MOVFF  00,701
009DE:  MOVLW  01
009E0:  MOVLB  7
009E2:  MOVWF  x2E
009E4:  MOVLW  80
009E6:  MOVWF  x2D
009E8:  MOVLW  01
009EA:  MOVWF  x30
009EC:  MOVLW  D0
009EE:  MOVWF  x2F
009F0:  MOVFF  03,734
009F4:  MOVFF  02,733
009F8:  MOVFF  01,732
009FC:  MOVFF  00,731
00A00:  MOVLB  0
00A02:  RCALL  08FA
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
00A04:  MOVLW  01
00A06:  MOVLB  7
00A08:  MOVWF  x04
00A0A:  MOVLB  0
00A0C:  RCALL  0852
00A0E:  MOVFF  03,704
00A12:  MOVFF  02,703
00A16:  MOVFF  01,702
00A1A:  MOVFF  00,701
00A1E:  MOVLW  01
00A20:  MOVLB  7
00A22:  MOVWF  x2E
00A24:  MOVLW  94
00A26:  MOVWF  x2D
00A28:  MOVLW  01
00A2A:  MOVWF  x30
00A2C:  MOVLW  D1
00A2E:  MOVWF  x2F
00A30:  MOVFF  03,734
00A34:  MOVFF  02,733
00A38:  MOVFF  01,732
00A3C:  MOVFF  00,731
00A40:  MOVLB  0
00A42:  RCALL  08FA
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A44:  MOVLW  02
00A46:  MOVLB  7
00A48:  MOVWF  x04
00A4A:  MOVLB  0
00A4C:  RCALL  0852
00A4E:  MOVFF  03,704
00A52:  MOVFF  02,703
00A56:  MOVFF  01,702
00A5A:  MOVFF  00,701
00A5E:  MOVLW  01
00A60:  MOVLB  7
00A62:  MOVWF  x2E
00A64:  MOVLW  A8
00A66:  MOVWF  x2D
00A68:  MOVLW  01
00A6A:  MOVWF  x30
00A6C:  MOVLW  D2
00A6E:  MOVWF  x2F
00A70:  MOVFF  03,734
00A74:  MOVFF  02,733
00A78:  MOVFF  01,732
00A7C:  MOVFF  00,731
00A80:  MOVLB  0
00A82:  RCALL  08FA
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A84:  MOVLW  03
00A86:  MOVLB  7
00A88:  MOVWF  x04
00A8A:  MOVLB  0
00A8C:  RCALL  0852
00A8E:  MOVFF  03,704
00A92:  MOVFF  02,703
00A96:  MOVFF  01,702
00A9A:  MOVFF  00,701
00A9E:  MOVLW  01
00AA0:  MOVLB  7
00AA2:  MOVWF  x2E
00AA4:  MOVLW  BC
00AA6:  MOVWF  x2D
00AA8:  MOVLW  01
00AAA:  MOVWF  x30
00AAC:  MOVLW  D3
00AAE:  MOVWF  x2F
00AB0:  MOVFF  03,734
00AB4:  MOVFF  02,733
00AB8:  MOVFF  01,732
00ABC:  MOVFF  00,731
00AC0:  MOVLB  0
00AC2:  RCALL  08FA
00AC4:  MOVLB  7
00AC6:  INCF   x00,F
00AC8:  BRA    09B0
00ACA:  MOVLB  1
....................       }
....................    }
00ACC:  MOVLB  0
00ACE:  GOTO   0B32 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00AD2:  MOVLW  00
00AD4:  MOVLB  F
00AD6:  MOVWF  x53
00AD8:  MOVLW  40
00ADA:  MOVWF  x0C
00ADC:  MOVLW  00
00ADE:  MOVWF  x14
00AE0:  MOVLW  03
00AE2:  MOVWF  x1C
00AE4:  MOVLW  0F
00AE6:  MOVWF  x21
00AE8:  MOVLW  00
00AEA:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AEC:  MOVLW  08
00AEE:  MOVWF  x55
00AF0:  CLRF   x56
00AF2:  CLRF   x52
00AF4:  SETF   x57
00AF6:  CLRF   F61
00AF8:  MOVLW  94
00AFA:  MOVWF  x5B
....................    output_high(EN_EXC);
00AFC:  MOVLW  E8
00AFE:  MOVWF  F8B
00B00:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B02:  MOVF   x5A,W
00B04:  ANDLW  3F
00B06:  MOVWF  01
00B08:  MOVLW  06
00B0A:  MOVWF  x5A
00B0C:  BTFSS  x5B.7
00B0E:  BRA    0B1E
00B10:  MOVF   01,W
00B12:  SUBLW  06
00B14:  BZ    0B1E
00B16:  BSF    x5B.0
00B18:  NOP   
00B1A:  BTFSC  x5B.0
00B1C:  BRA    0B1A
....................    delay_ms(10);
00B1E:  MOVLW  0A
00B20:  MOVLB  7
00B22:  MOVWF  x01
00B24:  MOVLB  0
00B26:  RCALL  03D6
....................    read_adc(ADC_START_ONLY);
00B28:  MOVLB  F
00B2A:  BSF    x5B.0
00B2C:  NOP   
....................    setup_external_ADCs();
00B2E:  MOVLB  0
00B30:  BRA    0960
....................    intTimeoutReg = sensorSampleRate;
00B32:  MOVLB  1
00B34:  CLRF   x7F
00B36:  MOVLW  32
00B38:  MOVWF  x7E
00B3A:  MOVLB  0
00B3C:  GOTO   A732 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046D2:  MOVLB  7
046D4:  MOVF   x01,W
046D6:  MULLW  28
046D8:  MOVF   FF3,W
046DA:  CLRF   x0F
046DC:  MOVWF  x0E
046DE:  MOVLW  0C
046E0:  ADDWF  x0E,W
046E2:  MOVWF  01
046E4:  MOVLW  00
046E6:  ADDWFC x0F,W
046E8:  MOVWF  03
046EA:  MOVF   01,W
046EC:  ADDLW  20
046EE:  MOVWF  FE9
046F0:  MOVLW  00
046F2:  ADDWFC 03,W
046F4:  MOVWF  FEA
046F6:  MOVFF  FEF,74A
046FA:  MOVFF  FEC,74B
046FE:  MOVFF  FEC,74C
04702:  MOVFF  FEC,74D
04706:  MOVF   x01,W
04708:  MULLW  28
0470A:  MOVF   FF3,W
0470C:  CLRF   x13
0470E:  MOVWF  x12
04710:  MOVLW  10
04712:  ADDWF  x12,W
04714:  MOVWF  01
04716:  MOVLW  00
04718:  ADDWFC x13,W
0471A:  MOVWF  03
0471C:  MOVF   01,W
0471E:  ADDLW  20
04720:  MOVWF  FE9
04722:  MOVLW  00
04724:  ADDWFC 03,W
04726:  MOVWF  FEA
04728:  MOVFF  FEF,74E
0472C:  MOVFF  FEC,01
04730:  MOVFF  FEC,02
04734:  MOVFF  FEC,03
04738:  MOVFF  FEA,713
0473C:  MOVFF  FE9,712
04740:  BSF    FD8.1
04742:  MOVFF  03,751
04746:  MOVFF  02,750
0474A:  MOVFF  01,74F
0474E:  MOVLB  0
04750:  CALL   0E8C
04754:  MOVFF  713,FEA
04758:  MOVFF  712,FE9
0475C:  MOVFF  03,705
04760:  MOVFF  02,704
04764:  MOVFF  01,703
04768:  MOVFF  00,702
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
0476C:  MOVLB  7
0476E:  MOVF   x01,W
04770:  MULLW  28
04772:  MOVF   FF3,W
04774:  CLRF   x0F
04776:  MOVWF  x0E
04778:  MOVLW  1C
0477A:  ADDWF  x0E,W
0477C:  MOVWF  01
0477E:  MOVLW  00
04780:  ADDWFC x0F,W
04782:  MOVWF  03
04784:  MOVF   01,W
04786:  ADDLW  20
04788:  MOVWF  01
0478A:  MOVLW  00
0478C:  ADDWFC 03,F
0478E:  MOVFF  01,70E
04792:  MOVFF  03,70F
04796:  MOVFF  03,FEA
0479A:  MOVFF  01,FE9
0479E:  MOVFF  FEF,710
047A2:  MOVFF  FEC,711
047A6:  MOVFF  FEC,712
047AA:  MOVFF  FEC,713
047AE:  MOVF   x01,W
047B0:  MULLW  28
047B2:  MOVF   FF3,W
047B4:  CLRF   x15
047B6:  MOVWF  x14
047B8:  MOVLW  04
047BA:  ADDWF  x14,W
047BC:  MOVWF  01
047BE:  MOVLW  00
047C0:  ADDWFC x15,W
047C2:  MOVWF  03
047C4:  MOVF   01,W
047C6:  ADDLW  20
047C8:  MOVWF  FE9
047CA:  MOVLW  00
047CC:  ADDWFC 03,W
047CE:  MOVWF  FEA
047D0:  MOVFF  FEF,754
047D4:  MOVFF  FEC,01
047D8:  MOVFF  FEC,02
047DC:  MOVFF  FEC,03
047E0:  MOVFF  705,753
047E4:  MOVFF  704,752
047E8:  MOVFF  703,751
047EC:  MOVFF  702,750
047F0:  MOVFF  03,757
047F4:  MOVFF  02,756
047F8:  MOVFF  01,755
047FC:  MOVLB  0
047FE:  CALL   0D96
04802:  BCF    FD8.1
04804:  MOVFF  713,74D
04808:  MOVFF  712,74C
0480C:  MOVFF  711,74B
04810:  MOVFF  710,74A
04814:  MOVFF  03,751
04818:  MOVFF  02,750
0481C:  MOVFF  01,74F
04820:  MOVFF  00,74E
04824:  CALL   0E8C
04828:  MOVFF  70F,FEA
0482C:  MOVFF  70E,FE9
04830:  MOVFF  00,FEF
04834:  MOVFF  01,FEC
04838:  MOVFF  02,FEC
0483C:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
04840:  MOVLB  7
04842:  MOVF   x01,W
04844:  MULLW  28
04846:  MOVF   FF3,W
04848:  CLRF   x0F
0484A:  MOVWF  x0E
0484C:  MOVLW  1C
0484E:  ADDWF  x0E,W
04850:  MOVWF  01
04852:  MOVLW  00
04854:  ADDWFC x0F,W
04856:  MOVWF  03
04858:  MOVF   01,W
0485A:  ADDLW  20
0485C:  MOVWF  FE9
0485E:  MOVLW  00
04860:  ADDWFC 03,W
04862:  MOVWF  FEA
04864:  MOVFF  FEF,74A
04868:  MOVFF  FEC,70F
0486C:  MOVFF  FEC,74C
04870:  MOVFF  FEC,74D
04874:  CLRF   x49
04876:  CLRF   x48
04878:  MOVLW  7C
0487A:  MOVWF  x47
0487C:  MOVLW  84
0487E:  MOVWF  x46
04880:  MOVFF  70F,74B
04884:  MOVLB  0
04886:  CALL   1D22
0488A:  BNC   48BE
0488C:  MOVLB  7
0488E:  MOVF   x01,W
04890:  MULLW  28
04892:  MOVF   FF3,W
04894:  CLRF   x0F
04896:  MOVWF  x0E
04898:  MOVLW  1C
0489A:  ADDWF  x0E,W
0489C:  MOVWF  01
0489E:  MOVLW  00
048A0:  ADDWFC x0F,W
048A2:  MOVWF  03
048A4:  MOVF   01,W
048A6:  ADDLW  20
048A8:  MOVWF  FE9
048AA:  MOVLW  00
048AC:  ADDWFC 03,W
048AE:  MOVWF  FEA
048B0:  MOVLW  84
048B2:  MOVWF  FEF
048B4:  MOVLW  7C
048B6:  MOVWF  FEC
048B8:  CLRF   FEC
048BA:  CLRF   FEC
048BC:  BRA    493A
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
048BE:  MOVLB  7
048C0:  MOVF   x01,W
048C2:  MULLW  28
048C4:  MOVF   FF3,W
048C6:  CLRF   x0F
048C8:  MOVWF  x0E
048CA:  MOVLW  1C
048CC:  ADDWF  x0E,W
048CE:  MOVWF  01
048D0:  MOVLW  00
048D2:  ADDWFC x0F,W
048D4:  MOVWF  03
048D6:  MOVF   01,W
048D8:  ADDLW  20
048DA:  MOVWF  FE9
048DC:  MOVLW  00
048DE:  ADDWFC 03,W
048E0:  MOVWF  FEA
048E2:  MOVFF  FEF,746
048E6:  MOVFF  FEC,70F
048EA:  MOVFF  FEC,748
048EE:  MOVFF  FEC,749
048F2:  MOVFF  70F,747
048F6:  CLRF   x4D
048F8:  CLRF   x4C
048FA:  MOVLW  C0
048FC:  MOVWF  x4B
048FE:  MOVLW  82
04900:  MOVWF  x4A
04902:  MOVLB  0
04904:  CALL   1D22
04908:  BNC   493C
0490A:  MOVLB  7
0490C:  MOVF   x01,W
0490E:  MULLW  28
04910:  MOVF   FF3,W
04912:  CLRF   x0F
04914:  MOVWF  x0E
04916:  MOVLW  1C
04918:  ADDWF  x0E,W
0491A:  MOVWF  01
0491C:  MOVLW  00
0491E:  ADDWFC x0F,W
04920:  MOVWF  03
04922:  MOVF   01,W
04924:  ADDLW  20
04926:  MOVWF  FE9
04928:  MOVLW  00
0492A:  ADDWFC 03,W
0492C:  MOVWF  FEA
0492E:  MOVLW  82
04930:  MOVWF  FEF
04932:  MOVLW  C0
04934:  MOVWF  FEC
04936:  CLRF   FEC
04938:  CLRF   FEC
0493A:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
0493C:  MOVLB  7
0493E:  MOVF   x01,W
04940:  MULLW  28
04942:  MOVF   FF3,W
04944:  CLRF   x0F
04946:  MOVWF  x0E
04948:  MOVLW  20
0494A:  ADDWF  x0E,W
0494C:  MOVWF  FE9
0494E:  MOVLW  00
04950:  ADDWFC x0F,W
04952:  MOVWF  FEA
04954:  MOVFF  FEF,754
04958:  MOVFF  FEC,01
0495C:  MOVFF  FEC,02
04960:  MOVFF  FEC,03
04964:  MOVFF  705,753
04968:  MOVFF  704,752
0496C:  MOVFF  703,751
04970:  MOVFF  702,750
04974:  MOVFF  03,757
04978:  MOVFF  02,756
0497C:  MOVFF  01,755
04980:  MOVLB  0
04982:  CALL   0D96
04986:  MOVFF  03,709
0498A:  MOVFF  02,708
0498E:  MOVFF  01,707
04992:  MOVFF  00,706
04996:  MOVLB  7
04998:  MOVF   x01,W
0499A:  MULLW  28
0499C:  MOVF   FF3,W
0499E:  CLRF   x11
049A0:  MOVWF  x10
049A2:  MOVLW  08
049A4:  ADDWF  x10,W
049A6:  MOVWF  01
049A8:  MOVLW  00
049AA:  ADDWFC x11,W
049AC:  MOVWF  03
049AE:  MOVF   01,W
049B0:  ADDLW  20
049B2:  MOVWF  FE9
049B4:  MOVLW  00
049B6:  ADDWFC 03,W
049B8:  MOVWF  FEA
049BA:  MOVFF  FEF,710
049BE:  MOVFF  FEC,711
049C2:  MOVFF  FEC,712
049C6:  MOVFF  FEC,713
049CA:  MOVF   x01,W
049CC:  MULLW  28
049CE:  MOVF   FF3,W
049D0:  CLRF   x15
049D2:  MOVWF  x14
049D4:  MOVLW  10
049D6:  ADDWF  x14,W
049D8:  MOVWF  01
049DA:  MOVLW  00
049DC:  ADDWFC x15,W
049DE:  MOVWF  03
049E0:  MOVF   01,W
049E2:  ADDLW  20
049E4:  MOVWF  FE9
049E6:  MOVLW  00
049E8:  ADDWFC 03,W
049EA:  MOVWF  FEA
049EC:  MOVFF  FEF,74A
049F0:  MOVFF  FEC,74B
049F4:  MOVFF  FEC,74C
049F8:  MOVFF  FEC,74D
049FC:  MOVF   x01,W
049FE:  MULLW  28
04A00:  MOVF   FF3,W
04A02:  CLRF   x19
04A04:  MOVWF  x18
04A06:  MOVLW  14
04A08:  ADDWF  x18,W
04A0A:  MOVWF  01
04A0C:  MOVLW  00
04A0E:  ADDWFC x19,W
04A10:  MOVWF  03
04A12:  MOVF   01,W
04A14:  ADDLW  20
04A16:  MOVWF  FE9
04A18:  MOVLW  00
04A1A:  ADDWFC 03,W
04A1C:  MOVWF  FEA
04A1E:  MOVFF  FEF,74E
04A22:  MOVFF  FEC,01
04A26:  MOVFF  FEC,02
04A2A:  MOVFF  FEC,03
04A2E:  MOVFF  FEA,719
04A32:  MOVFF  FE9,718
04A36:  BSF    FD8.1
04A38:  MOVFF  03,751
04A3C:  MOVFF  02,750
04A40:  MOVFF  01,74F
04A44:  MOVLB  0
04A46:  CALL   0E8C
04A4A:  MOVFF  719,FEA
04A4E:  MOVFF  718,FE9
04A52:  MOVFF  713,753
04A56:  MOVFF  712,752
04A5A:  MOVFF  711,751
04A5E:  MOVFF  710,750
04A62:  MOVFF  03,757
04A66:  MOVFF  02,756
04A6A:  MOVFF  01,755
04A6E:  MOVFF  00,754
04A72:  CALL   0D96
04A76:  MOVFF  03,70D
04A7A:  MOVFF  02,70C
04A7E:  MOVFF  01,70B
04A82:  MOVFF  00,70A
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A86:  MOVLB  7
04A88:  MOVF   x01,W
04A8A:  MULLW  28
04A8C:  MOVF   FF3,W
04A8E:  CLRF   x0F
04A90:  MOVWF  x0E
04A92:  MOVLW  18
04A94:  ADDWF  x0E,W
04A96:  MOVWF  01
04A98:  MOVLW  00
04A9A:  ADDWFC x0F,W
04A9C:  MOVWF  03
04A9E:  MOVF   01,W
04AA0:  ADDLW  20
04AA2:  MOVWF  01
04AA4:  MOVLW  00
04AA6:  ADDWFC 03,F
04AA8:  MOVFF  01,70E
04AAC:  MOVFF  03,70F
04AB0:  MOVF   x01,W
04AB2:  MULLW  28
04AB4:  MOVF   FF3,W
04AB6:  CLRF   x11
04AB8:  MOVWF  x10
04ABA:  MOVLW  1C
04ABC:  ADDWF  x10,W
04ABE:  MOVWF  01
04AC0:  MOVLW  00
04AC2:  ADDWFC x11,W
04AC4:  MOVWF  03
04AC6:  MOVF   01,W
04AC8:  ADDLW  20
04ACA:  MOVWF  FE9
04ACC:  MOVLW  00
04ACE:  ADDWFC 03,W
04AD0:  MOVWF  FEA
04AD2:  MOVFF  FEF,74E
04AD6:  MOVFF  FEC,01
04ADA:  MOVFF  FEC,02
04ADE:  MOVFF  FEC,03
04AE2:  MOVFF  FEA,711
04AE6:  MOVFF  FE9,710
04AEA:  BCF    FD8.1
04AEC:  MOVFF  709,74D
04AF0:  MOVFF  708,74C
04AF4:  MOVFF  707,74B
04AF8:  MOVFF  706,74A
04AFC:  MOVFF  03,751
04B00:  MOVFF  02,750
04B04:  MOVFF  01,74F
04B08:  MOVLB  0
04B0A:  CALL   0E8C
04B0E:  MOVFF  711,FEA
04B12:  MOVFF  710,FE9
04B16:  MOVFF  03,715
04B1A:  MOVFF  02,714
04B1E:  MOVFF  01,713
04B22:  MOVFF  00,712
04B26:  BCF    FD8.1
04B28:  MOVFF  03,74D
04B2C:  MOVFF  02,74C
04B30:  MOVFF  01,74B
04B34:  MOVFF  00,74A
04B38:  MOVFF  70D,751
04B3C:  MOVFF  70C,750
04B40:  MOVFF  70B,74F
04B44:  MOVFF  70A,74E
04B48:  CALL   0E8C
04B4C:  MOVFF  70F,FEA
04B50:  MOVFF  70E,FE9
04B54:  MOVFF  00,FEF
04B58:  MOVFF  01,FEC
04B5C:  MOVFF  02,FEC
04B60:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B64:  MOVLB  7
04B66:  MOVF   x01,W
04B68:  MULLW  28
04B6A:  MOVF   FF3,W
04B6C:  CLRF   x0F
04B6E:  MOVWF  x0E
04B70:  MOVLW  18
04B72:  ADDWF  x0E,W
04B74:  MOVWF  01
04B76:  MOVLW  00
04B78:  ADDWFC x0F,W
04B7A:  MOVWF  03
04B7C:  MOVF   01,W
04B7E:  ADDLW  20
04B80:  MOVWF  FE9
04B82:  MOVLW  00
04B84:  ADDWFC 03,W
04B86:  MOVWF  FEA
04B88:  MOVFF  FEF,74A
04B8C:  MOVFF  FEC,70F
04B90:  MOVFF  FEC,74C
04B94:  MOVFF  FEC,74D
04B98:  CLRF   x49
04B9A:  CLRF   x48
04B9C:  MOVLW  7C
04B9E:  MOVWF  x47
04BA0:  MOVLW  84
04BA2:  MOVWF  x46
04BA4:  MOVFF  70F,74B
04BA8:  MOVLB  0
04BAA:  CALL   1D22
04BAE:  BNC   4BE2
04BB0:  MOVLB  7
04BB2:  MOVF   x01,W
04BB4:  MULLW  28
04BB6:  MOVF   FF3,W
04BB8:  CLRF   x0F
04BBA:  MOVWF  x0E
04BBC:  MOVLW  18
04BBE:  ADDWF  x0E,W
04BC0:  MOVWF  01
04BC2:  MOVLW  00
04BC4:  ADDWFC x0F,W
04BC6:  MOVWF  03
04BC8:  MOVF   01,W
04BCA:  ADDLW  20
04BCC:  MOVWF  FE9
04BCE:  MOVLW  00
04BD0:  ADDWFC 03,W
04BD2:  MOVWF  FEA
04BD4:  MOVLW  84
04BD6:  MOVWF  FEF
04BD8:  MOVLW  7C
04BDA:  MOVWF  FEC
04BDC:  CLRF   FEC
04BDE:  CLRF   FEC
04BE0:  BRA    4C5E
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BE2:  MOVLB  7
04BE4:  MOVF   x01,W
04BE6:  MULLW  28
04BE8:  MOVF   FF3,W
04BEA:  CLRF   x0F
04BEC:  MOVWF  x0E
04BEE:  MOVLW  18
04BF0:  ADDWF  x0E,W
04BF2:  MOVWF  01
04BF4:  MOVLW  00
04BF6:  ADDWFC x0F,W
04BF8:  MOVWF  03
04BFA:  MOVF   01,W
04BFC:  ADDLW  20
04BFE:  MOVWF  FE9
04C00:  MOVLW  00
04C02:  ADDWFC 03,W
04C04:  MOVWF  FEA
04C06:  MOVFF  FEF,746
04C0A:  MOVFF  FEC,70F
04C0E:  MOVFF  FEC,748
04C12:  MOVFF  FEC,749
04C16:  MOVFF  70F,747
04C1A:  CLRF   x4D
04C1C:  CLRF   x4C
04C1E:  MOVLW  C0
04C20:  MOVWF  x4B
04C22:  MOVLW  82
04C24:  MOVWF  x4A
04C26:  MOVLB  0
04C28:  CALL   1D22
04C2C:  BNC   4C5E
04C2E:  MOVLB  7
04C30:  MOVF   x01,W
04C32:  MULLW  28
04C34:  MOVF   FF3,W
04C36:  CLRF   x0F
04C38:  MOVWF  x0E
04C3A:  MOVLW  18
04C3C:  ADDWF  x0E,W
04C3E:  MOVWF  01
04C40:  MOVLW  00
04C42:  ADDWFC x0F,W
04C44:  MOVWF  03
04C46:  MOVF   01,W
04C48:  ADDLW  20
04C4A:  MOVWF  FE9
04C4C:  MOVLW  00
04C4E:  ADDWFC 03,W
04C50:  MOVWF  FEA
04C52:  MOVLW  82
04C54:  MOVWF  FEF
04C56:  MOVLW  C0
04C58:  MOVWF  FEC
04C5A:  CLRF   FEC
04C5C:  CLRF   FEC
04C5E:  MOVLB  0
04C60:  GOTO   4CDE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C64:  MOVLB  6
04C66:  MOVF   xFE,W
04C68:  MULLW  28
04C6A:  MOVF   FF3,W
04C6C:  MOVLB  7
04C6E:  CLRF   x01
04C70:  MOVWF  x00
04C72:  MOVLW  0C
04C74:  ADDWF  x00,W
04C76:  MOVWF  01
04C78:  MOVLW  00
04C7A:  ADDWFC x01,W
04C7C:  MOVWF  03
04C7E:  MOVF   01,W
04C80:  ADDLW  20
04C82:  MOVWF  FE9
04C84:  MOVLW  00
04C86:  ADDWFC 03,W
04C88:  MOVWF  FEA
04C8A:  MOVFF  FEF,746
04C8E:  MOVFF  FEC,747
04C92:  MOVFF  FEC,748
04C96:  MOVFF  FEC,749
04C9A:  MOVLB  6
04C9C:  MOVF   xFE,W
04C9E:  MULLW  28
04CA0:  MOVF   FF3,W
04CA2:  MOVLB  7
04CA4:  CLRF   x05
04CA6:  MOVWF  x04
04CA8:  MOVLW  10
04CAA:  ADDWF  x04,W
04CAC:  MOVWF  01
04CAE:  MOVLW  00
04CB0:  ADDWFC x05,W
04CB2:  MOVWF  03
04CB4:  MOVF   01,W
04CB6:  ADDLW  20
04CB8:  MOVWF  FE9
04CBA:  MOVLW  00
04CBC:  ADDWFC 03,W
04CBE:  MOVWF  FEA
04CC0:  MOVFF  FEF,74A
04CC4:  MOVFF  FEC,74B
04CC8:  MOVFF  FEC,74C
04CCC:  MOVFF  FEC,74D
04CD0:  MOVLB  0
04CD2:  CALL   1D22
04CD6:  BZ    4CDE
04CD8:  MOVFF  6FE,701
04CDC:  BRA    46D2
....................    if ((index++) >= numChannels) index = 0;
04CDE:  MOVLB  1
04CE0:  MOVF   xE9,W
04CE2:  INCF   xE9,F
04CE4:  SUBLW  01
04CE6:  BC    4CEA
04CE8:  CLRF   xE9
04CEA:  MOVLB  0
04CEC:  GOTO   4DFE (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B40:  CLRF   03
00B42:  MOVF   F91,W
00B44:  MOVFF  700,F91
00B48:  RRCF   F94,W
00B4A:  BNC   0B48
00B4C:  MOVF   F91,W
00B4E:  MOVWF  02
00B50:  MOVFF  6FF,F91
00B54:  RRCF   F94,W
00B56:  BNC   0B54
00B58:  MOVF   F91,W
00B5A:  MOVWF  01
00B5C:  MOVFF  6FE,F91
00B60:  RRCF   F94,W
00B62:  BNC   0B60
00B64:  MOVFF  F91,00
00B68:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04640:  MOVLB  6
04642:  MOVF   xFF,F
04644:  BZ    468C
....................       if (chMap[0] == ch) output_low(INV_HVX);
04646:  MOVLW  00
04648:  MOVLB  0
0464A:  BTFSC  x70.0
0464C:  MOVLW  01
0464E:  MOVLB  6
04650:  SUBWF  xFE,W
04652:  BNZ   465A
04654:  MOVLW  04
04656:  MOVWF  F88
04658:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0465A:  MOVLW  00
0465C:  MOVLB  0
0465E:  BTFSC  x70.1
04660:  MOVLW  01
04662:  MOVLB  6
04664:  SUBWF  xFE,W
04666:  BNZ   466E
04668:  MOVLW  04
0466A:  MOVWF  F88
0466C:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
0466E:  MOVF   xFE,W
04670:  MULLW  07
04672:  MOVF   FF3,W
04674:  MOVLB  7
04676:  CLRF   x01
04678:  MOVWF  x00
0467A:  MOVLW  64
0467C:  ADDWF  x00,W
0467E:  MOVWF  FE9
04680:  MOVLW  01
04682:  ADDWFC x01,W
04684:  MOVWF  FEA
04686:  BSF    FEF.0
....................    }
04688:  BRA    46CE
0468A:  MOVLB  6
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
0468C:  MOVLW  00
0468E:  MOVLB  0
04690:  BTFSC  x70.0
04692:  MOVLW  01
04694:  MOVLB  6
04696:  SUBWF  xFE,W
04698:  BNZ   46A0
0469A:  MOVLW  04
0469C:  MOVWF  F88
0469E:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
046A0:  MOVLW  00
046A2:  MOVLB  0
046A4:  BTFSC  x70.1
046A6:  MOVLW  01
046A8:  MOVLB  6
046AA:  SUBWF  xFE,W
046AC:  BNZ   46B4
046AE:  MOVLW  04
046B0:  MOVWF  F88
046B2:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
046B4:  MOVF   xFE,W
046B6:  MULLW  07
046B8:  MOVF   FF3,W
046BA:  MOVLB  7
046BC:  CLRF   x01
046BE:  MOVWF  x00
046C0:  MOVLW  64
046C2:  ADDWF  x00,W
046C4:  MOVWF  FE9
046C6:  MOVLW  01
046C8:  ADDWFC x01,W
046CA:  MOVWF  FEA
046CC:  BCF    FEF.0
....................    }
046CE:  MOVLB  0
046D0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04CF0:  MOVLB  6
04CF2:  CLRF   xFD
04CF4:  CLRF   xFC
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04CF6:  MOVFF  6FB,70D
04CFA:  MOVLB  7
04CFC:  CLRF   x0F
04CFE:  MOVLW  71
04D00:  MOVWF  x0E
04D02:  MOVLB  0
04D04:  RCALL  460A
04D06:  MOVF   01,F
04D08:  BNZ   4DF8
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04D0A:  MOVLB  6
04D0C:  MOVF   xFB,W
04D0E:  MULLW  07
04D10:  MOVF   FF3,W
04D12:  CLRF   xFF
04D14:  MOVWF  xFE
04D16:  MOVLW  03
04D18:  ADDWF  xFE,W
04D1A:  MOVWF  01
04D1C:  MOVLW  00
04D1E:  ADDWFC xFF,W
04D20:  MOVWF  03
04D22:  MOVF   01,W
04D24:  ADDLW  64
04D26:  MOVWF  FE9
04D28:  MOVLW  01
04D2A:  ADDWFC 03,W
04D2C:  MOVWF  FEA
04D2E:  MOVFF  FEF,746
04D32:  MOVFF  FEC,747
04D36:  MOVFF  FEC,748
04D3A:  MOVFF  FEC,749
04D3E:  MOVLB  7
04D40:  CLRF   x4D
04D42:  CLRF   x4C
04D44:  CLRF   x4B
04D46:  CLRF   x4A
04D48:  MOVLB  0
04D4A:  CALL   1D22
04D4E:  BNC   4D60
04D50:  MOVFF  6FB,6FE
04D54:  MOVLW  01
04D56:  MOVLB  6
04D58:  MOVWF  xFF
04D5A:  MOVLB  0
04D5C:  RCALL  4640
04D5E:  BRA    4D6C
....................         else                         invert_voltage(ch, FALSE);
04D60:  MOVFF  6FB,6FE
04D64:  MOVLB  6
04D66:  CLRF   xFF
04D68:  MOVLB  0
04D6A:  RCALL  4640
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D6C:  MOVLB  6
04D6E:  MOVF   xFB,W
04D70:  MULLW  07
04D72:  MOVF   FF3,W
04D74:  CLRF   xFF
04D76:  MOVWF  xFE
04D78:  MOVLW  03
04D7A:  ADDWF  xFE,W
04D7C:  MOVWF  01
04D7E:  MOVLW  00
04D80:  ADDWFC xFF,W
04D82:  MOVWF  03
04D84:  MOVF   01,W
04D86:  ADDLW  64
04D88:  MOVWF  FE9
04D8A:  MOVLW  01
04D8C:  ADDWFC 03,W
04D8E:  MOVWF  FEA
04D90:  MOVFF  FEF,00
04D94:  MOVFF  FEC,01
04D98:  MOVFF  FEC,02
04D9C:  MOVFF  FEC,03
04DA0:  BCF    01.7
04DA2:  MOVFF  03,701
04DA6:  MOVFF  02,700
04DAA:  MOVFF  01,6FF
04DAE:  MOVFF  00,6FE
04DB2:  MOVFF  03,753
04DB6:  MOVFF  02,752
04DBA:  MOVFF  01,751
04DBE:  MOVFF  00,750
04DC2:  MOVLW  66
04DC4:  MOVLB  7
04DC6:  MOVWF  x57
04DC8:  MOVLW  D6
04DCA:  MOVWF  x56
04DCC:  MOVLW  23
04DCE:  MOVWF  x55
04DD0:  MOVLW  88
04DD2:  MOVWF  x54
04DD4:  MOVLB  0
04DD6:  CALL   0D96
04DDA:  MOVFF  03,749
04DDE:  MOVFF  02,748
04DE2:  MOVFF  01,747
04DE6:  MOVFF  00,746
04DEA:  CALL   2716
04DEE:  MOVFF  02,6FD
04DF2:  MOVFF  01,6FC
....................     }
04DF6:  BRA    4EEE
....................     else {
....................         pid_task(ch);
04DF8:  MOVFF  6FB,6FE
04DFC:  BRA    4C64
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04DFE:  MOVLB  6
04E00:  MOVF   xFB,W
04E02:  MULLW  28
04E04:  MOVF   FF3,W
04E06:  CLRF   xFF
04E08:  MOVWF  xFE
04E0A:  MOVLW  18
04E0C:  ADDWF  xFE,W
04E0E:  MOVWF  01
04E10:  MOVLW  00
04E12:  ADDWFC xFF,W
04E14:  MOVWF  03
04E16:  MOVF   01,W
04E18:  ADDLW  20
04E1A:  MOVWF  FE9
04E1C:  MOVLW  00
04E1E:  ADDWFC 03,W
04E20:  MOVWF  FEA
04E22:  MOVFF  FEF,746
04E26:  MOVFF  FEC,747
04E2A:  MOVFF  FEC,748
04E2E:  MOVFF  FEC,749
04E32:  MOVLB  7
04E34:  CLRF   x4D
04E36:  CLRF   x4C
04E38:  CLRF   x4B
04E3A:  CLRF   x4A
04E3C:  MOVLB  0
04E3E:  CALL   1D22
04E42:  BNC   4E56
04E44:  MOVFF  6FB,6FE
04E48:  MOVLW  01
04E4A:  MOVLB  6
04E4C:  MOVWF  xFF
04E4E:  MOVLB  0
04E50:  CALL   4640
04E54:  BRA    4E64
....................         else                       invert_voltage(ch, FALSE);
04E56:  MOVFF  6FB,6FE
04E5A:  MOVLB  6
04E5C:  CLRF   xFF
04E5E:  MOVLB  0
04E60:  CALL   4640
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E64:  MOVLB  6
04E66:  MOVF   xFB,W
04E68:  MULLW  28
04E6A:  MOVF   FF3,W
04E6C:  CLRF   xFF
04E6E:  MOVWF  xFE
04E70:  MOVLW  18
04E72:  ADDWF  xFE,W
04E74:  MOVWF  01
04E76:  MOVLW  00
04E78:  ADDWFC xFF,W
04E7A:  MOVWF  03
04E7C:  MOVF   01,W
04E7E:  ADDLW  20
04E80:  MOVWF  FE9
04E82:  MOVLW  00
04E84:  ADDWFC 03,W
04E86:  MOVWF  FEA
04E88:  MOVFF  FEF,00
04E8C:  MOVFF  FEC,01
04E90:  MOVFF  FEC,02
04E94:  MOVFF  FEC,03
04E98:  BCF    01.7
04E9A:  MOVFF  03,701
04E9E:  MOVFF  02,700
04EA2:  MOVFF  01,6FF
04EA6:  MOVFF  00,6FE
04EAA:  MOVFF  03,753
04EAE:  MOVFF  02,752
04EB2:  MOVFF  01,751
04EB6:  MOVFF  00,750
04EBA:  MOVLW  66
04EBC:  MOVLB  7
04EBE:  MOVWF  x57
04EC0:  MOVLW  D6
04EC2:  MOVWF  x56
04EC4:  MOVLW  23
04EC6:  MOVWF  x55
04EC8:  MOVLW  88
04ECA:  MOVWF  x54
04ECC:  MOVLB  0
04ECE:  CALL   0D96
04ED2:  MOVFF  03,749
04ED6:  MOVFF  02,748
04EDA:  MOVFF  01,747
04EDE:  MOVFF  00,746
04EE2:  CALL   2716
04EE6:  MOVFF  02,6FD
04EEA:  MOVFF  01,6FC
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04EEE:  MOVLB  6
04EF0:  MOVF   xFB,W
04EF2:  MULLW  07
04EF4:  MOVF   FF3,W
04EF6:  CLRF   xFF
04EF8:  MOVWF  xFE
04EFA:  MOVLW  01
04EFC:  ADDWF  xFE,W
04EFE:  MOVWF  01
04F00:  MOVLW  00
04F02:  ADDWFC xFF,W
04F04:  MOVWF  03
04F06:  MOVF   01,W
04F08:  ADDLW  64
04F0A:  MOVWF  FE9
04F0C:  MOVLW  01
04F0E:  ADDWFC 03,W
04F10:  MOVWF  FEA
04F12:  MOVFF  6FD,FEC
04F16:  MOVF   FED,F
04F18:  MOVFF  6FC,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F1C:  MOVLW  00
04F1E:  MOVLB  0
04F20:  BTFSC  x70.0
04F22:  MOVLW  01
04F24:  MOVLB  6
04F26:  SUBWF  xFB,W
04F28:  BNZ   4F30
04F2A:  MOVLW  E8
04F2C:  MOVWF  F8B
04F2E:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F30:  MOVLW  00
04F32:  MOVLB  0
04F34:  BTFSC  x70.1
04F36:  MOVLW  01
04F38:  MOVLB  6
04F3A:  SUBWF  xFB,W
04F3C:  BNZ   4F44
04F3E:  MOVLW  E8
04F40:  MOVWF  F8B
04F42:  BSF    F86.1
....................    
....................     delay_ms(1);
04F44:  MOVLW  01
04F46:  MOVLB  7
04F48:  MOVWF  x01
04F4A:  MOVLB  0
04F4C:  CALL   03D6
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04F50:  MOVLW  00
04F52:  BTFSC  x70.0
04F54:  MOVLW  01
04F56:  MOVLB  6
04F58:  SUBWF  xFB,W
04F5A:  BNZ   4F62
04F5C:  MOVLW  E8
04F5E:  MOVWF  F8B
04F60:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04F62:  MOVLW  00
04F64:  MOVLB  0
04F66:  BTFSC  x70.1
04F68:  MOVLW  01
04F6A:  MOVLB  6
04F6C:  SUBWF  xFB,W
04F6E:  BNZ   4F76
04F70:  MOVLW  E8
04F72:  MOVWF  F8B
04F74:  BCF    F86.1
....................     delay_ms(1);
04F76:  MOVLW  01
04F78:  MOVLB  7
04F7A:  MOVWF  x01
04F7C:  MOVLB  0
04F7E:  CALL   03D6
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F82:  MOVLB  7
04F84:  CLRF   x01
04F86:  CLRF   x00
04F88:  MOVFF  6FD,6FF
04F8C:  MOVFF  6FC,6FE
04F90:  MOVLB  0
04F92:  CALL   0B40
....................     delay_ms(1);
04F96:  MOVLW  01
04F98:  MOVLB  7
04F9A:  MOVWF  x01
04F9C:  MOVLB  0
04F9E:  CALL   03D6
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04FA2:  MOVLW  00
04FA4:  BTFSC  x70.0
04FA6:  MOVLW  01
04FA8:  MOVLB  6
04FAA:  SUBWF  xFB,W
04FAC:  BNZ   4FB4
04FAE:  MOVLW  E8
04FB0:  MOVWF  F8B
04FB2:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04FB4:  MOVLW  00
04FB6:  MOVLB  0
04FB8:  BTFSC  x70.1
04FBA:  MOVLW  01
04FBC:  MOVLB  6
04FBE:  SUBWF  xFB,W
04FC0:  BNZ   4FC8
04FC2:  MOVLW  E8
04FC4:  MOVWF  F8B
04FC6:  BSF    F86.1
04FC8:  MOVLB  0
04FCA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04FCC:  MOVLB  1
04FCE:  MOVF   xEA,W
04FD0:  XORLW  00
04FD2:  MOVLB  0
04FD4:  BZ    4FDC
04FD6:  XORLW  01
04FD8:  BZ    4FEE
04FDA:  BRA    4FFE
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04FDC:  MOVLB  6
04FDE:  CLRF   xFB
04FE0:  MOVLB  0
04FE2:  RCALL  4CF0
....................          state = 1;
04FE4:  MOVLW  01
04FE6:  MOVLB  1
04FE8:  MOVWF  xEA
....................       break;
04FEA:  MOVLB  0
04FEC:  BRA    4FFE
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04FEE:  MOVLW  01
04FF0:  MOVLB  6
04FF2:  MOVWF  xFB
04FF4:  MOVLB  0
04FF6:  RCALL  4CF0
....................          state = 0;
04FF8:  MOVLB  1
04FFA:  CLRF   xEA
....................       break;
04FFC:  MOVLB  0
....................    }
04FFE:  GOTO   A762 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B6A:  MOVLB  7
00B6C:  CLRF   x01
00B6E:  CLRF   x00
00B70:  MOVLB  6
00B72:  CLRF   xFF
00B74:  CLRF   xFE
00B76:  MOVLB  0
00B78:  RCALL  0B40
....................    output_low(_SYNC_X);
00B7A:  MOVLW  E8
00B7C:  MOVWF  F8B
00B7E:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B80:  MOVWF  F8B
00B82:  BCF    F86.1
....................    output_high(_SYNC_X);
00B84:  MOVWF  F8B
00B86:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B88:  MOVWF  F8B
00B8A:  BSF    F86.1
00B8C:  GOTO   A736 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B90:  MOVLB  7
00B92:  MOVF   x01,W
00B94:  SUBLW  03
00B96:  BTFSS  FD8.0
00B98:  BRA    0D06
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B9A:  CLRF   x02
00B9C:  MOVF   x02,W
00B9E:  SUBLW  06
00BA0:  BNC   0BF0
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00BA2:  CLRF   x42
00BA4:  MOVFF  701,741
00BA8:  CLRF   x44
00BAA:  MOVLW  B5
00BAC:  MOVWF  x43
00BAE:  MOVLB  0
00BB0:  RCALL  08AC
00BB2:  MOVFF  02,704
00BB6:  MOVFF  01,703
00BBA:  MOVLW  06
00BBC:  MOVLB  7
00BBE:  ADDWF  x03,F
00BC0:  MOVLW  00
00BC2:  ADDWFC x04,F
00BC4:  CLRF   x42
00BC6:  MOVFF  702,741
00BCA:  CLRF   x44
00BCC:  MOVLW  19
00BCE:  MOVWF  x43
00BD0:  MOVLB  0
00BD2:  RCALL  08AC
00BD4:  MOVF   01,W
00BD6:  MOVLB  7
00BD8:  ADDWF  x03,F
00BDA:  MOVF   02,W
00BDC:  ADDWFC x04,F
00BDE:  MOVLW  EB
00BE0:  ADDWF  x03,W
00BE2:  MOVWF  FE9
00BE4:  MOVLW  01
00BE6:  ADDWFC x04,W
00BE8:  MOVWF  FEA
00BEA:  CLRF   FEF
00BEC:  INCF   x02,F
00BEE:  BRA    0B9C
....................       }
....................       SERcmd[recNum].t = 0;
00BF0:  CLRF   x42
00BF2:  MOVFF  701,741
00BF6:  CLRF   x44
00BF8:  MOVLW  B5
00BFA:  MOVWF  x43
00BFC:  MOVLB  0
00BFE:  RCALL  08AC
00C00:  MOVFF  01,703
00C04:  MOVLW  05
00C06:  MOVLB  7
00C08:  ADDWF  01,W
00C0A:  MOVWF  01
00C0C:  MOVLW  00
00C0E:  ADDWFC 02,W
00C10:  MOVWF  03
00C12:  MOVF   01,W
00C14:  ADDLW  EB
00C16:  MOVWF  FE9
00C18:  MOVLW  01
00C1A:  ADDWFC 03,W
00C1C:  MOVWF  FEA
00C1E:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C20:  CLRF   x42
00C22:  MOVFF  701,741
00C26:  CLRF   x44
00C28:  MOVLW  B5
00C2A:  MOVWF  x43
00C2C:  MOVLB  0
00C2E:  RCALL  08AC
00C30:  MOVFF  01,703
00C34:  MOVLW  01
00C36:  MOVLB  7
00C38:  ADDWF  01,W
00C3A:  MOVWF  01
00C3C:  MOVLW  00
00C3E:  ADDWFC 02,W
00C40:  MOVWF  03
00C42:  MOVF   01,W
00C44:  ADDLW  EB
00C46:  MOVWF  FE9
00C48:  MOVLW  01
00C4A:  ADDWFC 03,W
00C4C:  MOVWF  FEA
00C4E:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C50:  CLRF   x42
00C52:  MOVFF  701,741
00C56:  CLRF   x44
00C58:  MOVLW  B5
00C5A:  MOVWF  x43
00C5C:  MOVLB  0
00C5E:  RCALL  08AC
00C60:  MOVFF  01,703
00C64:  MOVLW  02
00C66:  MOVLB  7
00C68:  ADDWF  01,W
00C6A:  MOVWF  01
00C6C:  MOVLW  00
00C6E:  ADDWFC 02,W
00C70:  MOVWF  03
00C72:  MOVF   01,W
00C74:  ADDLW  EB
00C76:  MOVWF  FE9
00C78:  MOVLW  01
00C7A:  ADDWFC 03,W
00C7C:  MOVWF  FEA
00C7E:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C80:  CLRF   x42
00C82:  MOVFF  701,741
00C86:  CLRF   x44
00C88:  MOVLW  B5
00C8A:  MOVWF  x43
00C8C:  MOVLB  0
00C8E:  RCALL  08AC
00C90:  MOVFF  01,703
00C94:  MOVLW  03
00C96:  MOVLB  7
00C98:  ADDWF  01,W
00C9A:  MOVWF  01
00C9C:  MOVLW  00
00C9E:  ADDWFC 02,W
00CA0:  MOVWF  03
00CA2:  MOVF   01,W
00CA4:  ADDLW  EB
00CA6:  MOVWF  FE9
00CA8:  MOVLW  01
00CAA:  ADDWFC 03,W
00CAC:  MOVWF  FEA
00CAE:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00CB0:  CLRF   x42
00CB2:  MOVFF  701,741
00CB6:  CLRF   x44
00CB8:  MOVLW  B5
00CBA:  MOVWF  x43
00CBC:  MOVLB  0
00CBE:  RCALL  08AC
00CC0:  MOVFF  01,703
00CC4:  MOVLW  04
00CC6:  MOVLB  7
00CC8:  ADDWF  01,W
00CCA:  MOVWF  01
00CCC:  MOVLW  00
00CCE:  ADDWFC 02,W
00CD0:  MOVWF  03
00CD2:  MOVF   01,W
00CD4:  ADDLW  EB
00CD6:  MOVWF  FE9
00CD8:  MOVLW  01
00CDA:  ADDWFC 03,W
00CDC:  MOVWF  FEA
00CDE:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CE0:  CLRF   x42
00CE2:  MOVFF  701,741
00CE6:  CLRF   x44
00CE8:  MOVLW  B5
00CEA:  MOVWF  x43
00CEC:  MOVLB  0
00CEE:  RCALL  08AC
00CF0:  MOVLW  EB
00CF2:  MOVLB  7
00CF4:  ADDWF  01,W
00CF6:  MOVWF  FE9
00CF8:  MOVLW  01
00CFA:  ADDWFC 02,W
00CFC:  MOVWF  FEA
00CFE:  BCF    FEF.0
....................       retData[0] = '\0';
00D00:  MOVLB  4
00D02:  CLRF   xC1
00D04:  MOVLB  7
....................    }
00D06:  MOVLB  0
00D08:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05A4A:  MOVLB  7
05A4C:  CLRF   x42
05A4E:  MOVFF  4BF,741
05A52:  CLRF   x44
05A54:  MOVLW  B5
05A56:  MOVWF  x43
05A58:  MOVLB  0
05A5A:  CALL   08AC
05A5E:  MOVFF  02,702
05A62:  MOVFF  01,701
05A66:  MOVLW  EB
05A68:  MOVLB  7
05A6A:  ADDWF  01,W
05A6C:  MOVWF  FE9
05A6E:  MOVLW  01
05A70:  ADDWFC 02,W
05A72:  MOVWF  FEA
05A74:  BTFSC  FEF.0
05A76:  BRA    5A98
....................    {
....................       if (SRI == SWI) return FALSE;
05A78:  MOVLB  4
05A7A:  MOVF   xC0,W
05A7C:  SUBWF  xBF,W
05A7E:  BNZ   5A86
05A80:  MOVLW  00
05A82:  MOVWF  01
05A84:  BRA    5A9E
....................       SRI +=1;
05A86:  MOVLW  01
05A88:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05A8A:  MOVF   xBF,W
05A8C:  SUBLW  03
05A8E:  BC    5A92
05A90:  CLRF   xBF
05A92:  MOVLB  0
05A94:  BRA    5A4A
05A96:  MOVLB  7
....................    }
....................    return TRUE;
05A98:  MOVLW  01
05A9A:  MOVWF  01
05A9C:  MOVLB  4
05A9E:  MOVLB  0
05AA0:  GOTO   A1F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
0503A:  MOVLW  01
0503C:  MOVLB  4
0503E:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
05040:  MOVF   xC0,W
05042:  SUBLW  03
05044:  BC    5048
05046:  CLRF   xC0
05048:  MOVLB  0
0504A:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... //!#use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
.................... #use rs232(ICD, stream=ICD_STREAM)
*
059D2:  MOVFF  FF2,03
059D6:  BCF    FF2.7
059D8:  MOVLW  04
059DA:  MOVWF  F88
059DC:  BCF    F83.7
059DE:  MOVLW  08
059E0:  MOVWF  01
059E2:  BRA    59E4
059E4:  NOP   
059E6:  BSF    01.7
059E8:  BRA    5A0A
059EA:  BCF    01.7
059EC:  MOVLB  6
059EE:  RRCF   xFD,F
059F0:  MOVLB  0
059F2:  BTFSC  FD8.0
059F4:  BSF    F83.7
059F6:  BTFSS  FD8.0
059F8:  BCF    F83.7
059FA:  BSF    01.6
059FC:  BRA    5A0A
059FE:  BCF    01.6
05A00:  DECFSZ 01,F
05A02:  BRA    59EC
05A04:  BRA    5A06
05A06:  NOP   
05A08:  BSF    F83.7
05A0A:  MOVLW  84
05A0C:  MOVWF  FE9
05A0E:  DECFSZ FE9,F
05A10:  BRA    5A0E
05A12:  BRA    5A14
05A14:  NOP   
05A16:  BTFSC  01.7
05A18:  BRA    59EA
05A1A:  BTFSC  01.6
05A1C:  BRA    59FE
05A1E:  BTFSC  03.7
05A20:  BSF    FF2.7
05A22:  RETURN 0
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, UART1, stream=SERIAL, ERRORS)
*
000EE:  MOVLB  E
000F0:  BTFSS  xC8.5
000F2:  BRA    00F0
000F4:  MOVFF  F9C,563
000F8:  MOVLB  5
000FA:  MOVFF  F98,01
000FE:  BTFSS  x63.1
00100:  BRA    0106
00102:  BCF    F9C.4
00104:  BSF    F9C.4
00106:  MOVLB  0
00108:  GOTO   0148 (RETURN)
.................... //!#use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* printBuffer){
....................     output_high(TX_ENABLE);
*
0A18C:  MOVLW  93
0A18E:  MOVWF  F89
0A190:  BSF    F84.5
....................     delay_us(500);
0A192:  MOVLW  02
0A194:  MOVLB  7
0A196:  MOVWF  x03
0A198:  CLRF   19
0A19A:  BTFSC  FF2.7
0A19C:  BSF    19.7
0A19E:  BCF    FF2.7
0A1A0:  MOVLW  FA
0A1A2:  MOVWF  x72
0A1A4:  MOVLB  0
0A1A6:  CALL   00CA
0A1AA:  BTFSC  19.7
0A1AC:  BSF    FF2.7
0A1AE:  MOVLB  7
0A1B0:  DECFSZ x03,F
0A1B2:  BRA    A198
....................     
....................     fprintf(SERIAL, "%s", printBuffer);
0A1B4:  MOVFF  702,FEA
0A1B8:  MOVFF  701,FE9
0A1BC:  MOVLB  0
0A1BE:  CALL   504C
....................     delay_us(500);
0A1C2:  MOVLW  02
0A1C4:  MOVLB  7
0A1C6:  MOVWF  x03
0A1C8:  CLRF   19
0A1CA:  BTFSC  FF2.7
0A1CC:  BSF    19.7
0A1CE:  BCF    FF2.7
0A1D0:  MOVLW  FA
0A1D2:  MOVWF  x72
0A1D4:  MOVLB  0
0A1D6:  CALL   00CA
0A1DA:  BTFSC  19.7
0A1DC:  BSF    FF2.7
0A1DE:  MOVLB  7
0A1E0:  DECFSZ x03,F
0A1E2:  BRA    A1C8
....................     
....................     output_low(TX_ENABLE);
0A1E4:  MOVLW  93
0A1E6:  MOVWF  F89
0A1E8:  BCF    F84.5
0A1EA:  MOVLB  0
0A1EC:  GOTO   A30C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
0010C:  MOVLB  0
.................... {
.................... //!    fprintf(ICD_STREAM, "FOO\n");
....................     output_high(TX_ENABLE);
0010E:  MOVLW  93
00110:  MOVWF  F89
00112:  BSF    F84.5
....................     delay_us(500);
00114:  MOVLW  02
00116:  MOVLB  7
00118:  MOVWF  x71
0011A:  MOVLW  FA
0011C:  MOVWF  x72
0011E:  MOVLB  0
00120:  RCALL  00CA
00122:  MOVLB  7
00124:  DECFSZ x71,F
00126:  BRA    011A
....................     while (kbhit())
00128:  BTFSC  F8D.6
0012A:  BRA    016A
....................     {
.................... //!       UART_BUFFER[UART_WR_PTR]=getch();
....................        UART_BUFFER[UART_WR_PTR]=fgetc(SERIAL);
0012C:  CLRF   03
0012E:  MOVLB  5
00130:  MOVF   x61,W
00132:  ADDLW  25
00134:  MOVWF  FE9
00136:  MOVLW  05
00138:  ADDWFC 03,W
0013A:  MOVWF  FEA
0013C:  MOVFF  FEA,774
00140:  MOVFF  FE9,773
00144:  MOVLB  0
00146:  BRA    00EE
00148:  MOVFF  774,FEA
0014C:  MOVFF  773,FE9
00150:  MOVFF  01,FEF
....................        UART_WR_PTR +=1;
00154:  MOVLW  01
00156:  MOVLB  5
00158:  ADDWF  x61,F
....................        if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0015A:  MOVF   x61,W
0015C:  SUBLW  3B
0015E:  BC    0162
00160:  CLRF   x61
....................        BYTES_AVAILABLE=TRUE;
00162:  MOVLB  1
00164:  BSF    x63.1
00166:  MOVLB  7
00168:  BRA    0128
....................     }
....................     output_low(TX_ENABLE);
0016A:  MOVLW  93
0016C:  MOVWF  F89
0016E:  BCF    F84.5
00170:  MOVLB  E
00172:  BCF    xC8.5
00174:  MOVLB  0
00176:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05002:  CLRF   03
05004:  MOVLB  5
05006:  MOVF   x62,W
05008:  ADDLW  25
0500A:  MOVWF  FE9
0500C:  MOVLW  05
0500E:  ADDWFC 03,W
05010:  MOVWF  FEA
05012:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05016:  MOVLW  01
05018:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
0501A:  MOVF   x62,W
0501C:  SUBLW  3B
0501E:  BC    5022
05020:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05022:  MOVF   x61,W
05024:  SUBWF  x62,W
05026:  BNZ   502E
05028:  MOVLB  1
0502A:  BCF    x63.1
0502C:  MOVLB  5
....................    return data;
0502E:  MOVLB  6
05030:  MOVFF  6FC,01
05034:  MOVLB  0
05036:  GOTO   50B8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05076:  MOVLB  1
05078:  BTFSS  x63.1
0507A:  BRA    5588
0507C:  MOVLB  7
0507E:  CLRF   x42
05080:  MOVFF  4C0,741
05084:  CLRF   x44
05086:  MOVLW  B5
05088:  MOVWF  x43
0508A:  MOVLB  0
0508C:  CALL   08AC
05090:  MOVFF  02,6FD
05094:  MOVFF  01,6FC
05098:  MOVLW  EB
0509A:  MOVLB  6
0509C:  ADDWF  01,W
0509E:  MOVWF  01
050A0:  MOVLW  01
050A2:  ADDWFC 02,W
050A4:  MOVWF  03
050A6:  MOVFF  01,FE9
050AA:  MOVWF  FEA
050AC:  BTFSS  FEF.0
050AE:  BRA    50B4
050B0:  MOVLB  1
050B2:  BRA    5588
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
050B4:  MOVLB  0
050B6:  BRA    5002
050B8:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
050BC:  MOVLB  6
050BE:  MOVF   xFB,W
050C0:  SUBLW  0D
050C2:  BZ    50CA
050C4:  MOVF   xFB,W
050C6:  SUBLW  20
050C8:  BNZ   50CC
....................       {
....................       }
050CA:  BRA    5582
....................       else if (rxChar == UART_SOT_CHAR)
050CC:  MOVF   xFB,W
050CE:  SUBLW  7E
050D0:  BNZ   5114
....................       {
....................          resetSERcmd(SWI);
050D2:  MOVFF  4C0,701
050D6:  MOVLB  0
050D8:  CALL   0B90
....................          SERcmd[SWI].t = rxChar;
050DC:  MOVLB  7
050DE:  CLRF   x42
050E0:  MOVFF  4C0,741
050E4:  CLRF   x44
050E6:  MOVLW  B5
050E8:  MOVWF  x43
050EA:  MOVLB  0
050EC:  CALL   08AC
050F0:  MOVFF  01,6FC
050F4:  MOVLW  05
050F6:  MOVLB  6
050F8:  ADDWF  01,W
050FA:  MOVWF  01
050FC:  MOVLW  00
050FE:  ADDWFC 02,W
05100:  MOVWF  03
05102:  MOVF   01,W
05104:  ADDLW  EB
05106:  MOVWF  FE9
05108:  MOVLW  01
0510A:  ADDWFC 03,W
0510C:  MOVWF  FEA
0510E:  MOVFF  6FB,FEF
....................       }
05112:  BRA    5582
....................       else if (rxChar >= oneByteCmdTestValue)
05114:  MOVF   xFB,W
05116:  SUBLW  7F
05118:  BC    5186
....................       {
....................          resetSERcmd(SWI);
0511A:  MOVFF  4C0,701
0511E:  MOVLB  0
05120:  CALL   0B90
....................          SERcmd[SWI].t = rxChar;
05124:  MOVLB  7
05126:  CLRF   x42
05128:  MOVFF  4C0,741
0512C:  CLRF   x44
0512E:  MOVLW  B5
05130:  MOVWF  x43
05132:  MOVLB  0
05134:  CALL   08AC
05138:  MOVFF  01,6FC
0513C:  MOVLW  05
0513E:  MOVLB  6
05140:  ADDWF  01,W
05142:  MOVWF  01
05144:  MOVLW  00
05146:  ADDWFC 02,W
05148:  MOVWF  03
0514A:  MOVF   01,W
0514C:  ADDLW  EB
0514E:  MOVWF  FE9
05150:  MOVLW  01
05152:  ADDWFC 03,W
05154:  MOVWF  FEA
05156:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
0515A:  MOVLB  7
0515C:  CLRF   x42
0515E:  MOVFF  4C0,741
05162:  CLRF   x44
05164:  MOVLW  B5
05166:  MOVWF  x43
05168:  MOVLB  0
0516A:  CALL   08AC
0516E:  MOVLW  EB
05170:  MOVLB  6
05172:  ADDWF  01,W
05174:  MOVWF  FE9
05176:  MOVLW  01
05178:  ADDWFC 02,W
0517A:  MOVWF  FEA
0517C:  BSF    FEF.0
....................          setNextSERWriteIndex();
0517E:  MOVLB  0
05180:  RCALL  503A
....................       }
05182:  BRA    5580
05184:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05186:  MOVF   xFB,W
05188:  SUBLW  0A
0518A:  BTFSS  FD8.2
0518C:  BRA    529A
....................       {
....................          SERcmd[SWI].full = TRUE;
0518E:  MOVLB  7
05190:  CLRF   x42
05192:  MOVFF  4C0,741
05196:  CLRF   x44
05198:  MOVLW  B5
0519A:  MOVWF  x43
0519C:  MOVLB  0
0519E:  CALL   08AC
051A2:  MOVLW  EB
051A4:  MOVLB  6
051A6:  ADDWF  01,W
051A8:  MOVWF  FE9
051AA:  MOVLW  01
051AC:  ADDWFC 02,W
051AE:  MOVWF  FEA
051B0:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
051B2:  MOVLB  7
051B4:  CLRF   x42
051B6:  MOVFF  4C0,741
051BA:  CLRF   x44
051BC:  MOVLW  B5
051BE:  MOVWF  x43
051C0:  MOVLB  0
051C2:  CALL   08AC
051C6:  MOVFF  01,6FC
051CA:  MOVLW  04
051CC:  ADDWF  01,W
051CE:  MOVWF  01
051D0:  MOVLW  00
051D2:  ADDWFC 02,W
051D4:  MOVWF  03
051D6:  MOVF   01,W
051D8:  ADDLW  EB
051DA:  MOVWF  01
051DC:  MOVLW  01
051DE:  ADDWFC 03,F
051E0:  MOVFF  01,6FC
051E4:  MOVFF  03,6FD
051E8:  MOVLB  7
051EA:  CLRF   x42
051EC:  MOVFF  4C0,741
051F0:  CLRF   x44
051F2:  MOVLW  B5
051F4:  MOVWF  x43
051F6:  MOVLB  0
051F8:  CALL   08AC
051FC:  MOVFF  01,6FE
05200:  MOVLW  02
05202:  MOVLB  6
05204:  ADDWF  01,W
05206:  MOVWF  01
05208:  MOVLW  00
0520A:  ADDWFC 02,W
0520C:  MOVWF  03
0520E:  MOVF   01,W
05210:  ADDLW  EB
05212:  MOVWF  FE9
05214:  MOVLW  01
05216:  ADDWFC 03,W
05218:  MOVWF  FEA
0521A:  MOVFF  FEF,6FE
0521E:  MOVFF  6FD,FEA
05222:  MOVFF  6FC,FE9
05226:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
0522A:  MOVLB  7
0522C:  CLRF   x42
0522E:  MOVFF  4C0,741
05232:  CLRF   x44
05234:  MOVLW  B5
05236:  MOVWF  x43
05238:  MOVLB  0
0523A:  CALL   08AC
0523E:  MOVFF  01,6FC
05242:  MOVLW  01
05244:  MOVLB  6
05246:  ADDWF  01,W
05248:  MOVWF  01
0524A:  MOVLW  00
0524C:  ADDWFC 02,W
0524E:  MOVWF  03
05250:  MOVF   01,W
05252:  ADDLW  EB
05254:  MOVWF  FE9
05256:  MOVLW  01
05258:  ADDWFC 03,W
0525A:  MOVWF  FEA
0525C:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
0525E:  MOVLB  7
05260:  CLRF   x42
05262:  MOVFF  4C0,741
05266:  CLRF   x44
05268:  MOVLW  B5
0526A:  MOVWF  x43
0526C:  MOVLB  0
0526E:  CALL   08AC
05272:  MOVFF  01,6FC
05276:  MOVLW  02
05278:  MOVLB  6
0527A:  ADDWF  01,W
0527C:  MOVWF  01
0527E:  MOVLW  00
05280:  ADDWFC 02,W
05282:  MOVWF  03
05284:  MOVF   01,W
05286:  ADDLW  EB
05288:  MOVWF  FE9
0528A:  MOVLW  01
0528C:  ADDWFC 03,W
0528E:  MOVWF  FEA
05290:  CLRF   FEF
....................          setNextSERWriteIndex();
05292:  MOVLB  0
05294:  RCALL  503A
....................       }
05296:  BRA    5580
05298:  MOVLB  6
....................       else if (rxChar == delimiter)
0529A:  MOVF   xFB,W
0529C:  SUBLW  2C
0529E:  BNZ   5362
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052A0:  MOVLB  7
052A2:  CLRF   x42
052A4:  MOVFF  4C0,741
052A8:  CLRF   x44
052AA:  MOVLW  B5
052AC:  MOVWF  x43
052AE:  MOVLB  0
052B0:  CALL   08AC
052B4:  MOVFF  02,6FD
052B8:  MOVFF  01,6FC
052BC:  MOVLW  02
052BE:  MOVLB  6
052C0:  ADDWF  01,W
052C2:  MOVWF  01
052C4:  MOVLW  00
052C6:  ADDWFC 02,W
052C8:  MOVWF  03
052CA:  MOVF   01,W
052CC:  ADDLW  EB
052CE:  MOVWF  FE9
052D0:  MOVLW  01
052D2:  ADDWFC 03,W
052D4:  MOVWF  FEA
052D6:  MOVF   FEF,W
052D8:  SUBLW  05
052DA:  BNC   534A
....................          {
....................             SERcmd[SWI].paramIndex +=1;
052DC:  MOVLB  7
052DE:  CLRF   x42
052E0:  MOVFF  4C0,741
052E4:  CLRF   x44
052E6:  MOVLW  B5
052E8:  MOVWF  x43
052EA:  MOVLB  0
052EC:  CALL   08AC
052F0:  MOVFF  01,6FC
052F4:  MOVLW  02
052F6:  MOVLB  6
052F8:  ADDWF  01,W
052FA:  MOVWF  01
052FC:  MOVLW  00
052FE:  ADDWFC 02,W
05300:  MOVWF  03
05302:  MOVF   01,W
05304:  ADDLW  EB
05306:  MOVWF  FE9
05308:  MOVLW  01
0530A:  ADDWFC 03,W
0530C:  MOVWF  FEA
0530E:  MOVLW  01
05310:  ADDWF  FEF,W
05312:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05314:  MOVLB  7
05316:  CLRF   x42
05318:  MOVFF  4C0,741
0531C:  CLRF   x44
0531E:  MOVLW  B5
05320:  MOVWF  x43
05322:  MOVLB  0
05324:  CALL   08AC
05328:  MOVFF  01,6FC
0532C:  MOVLW  01
0532E:  MOVLB  6
05330:  ADDWF  01,W
05332:  MOVWF  01
05334:  MOVLW  00
05336:  ADDWFC 02,W
05338:  MOVWF  03
0533A:  MOVF   01,W
0533C:  ADDLW  EB
0533E:  MOVWF  FE9
05340:  MOVLW  01
05342:  ADDWFC 03,W
05344:  MOVWF  FEA
05346:  CLRF   FEF
....................          }
05348:  BRA    5360
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
0534A:  MOVFF  4C0,701
0534E:  MOVLB  0
05350:  CALL   0B90
....................             fprintf(SERIAL, retData);
05354:  MOVLW  04
05356:  MOVWF  FEA
05358:  MOVLW  C1
0535A:  MOVWF  FE9
0535C:  RCALL  504C
0535E:  MOVLB  6
....................          }
....................       }
05360:  BRA    5582
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05362:  MOVLB  7
05364:  CLRF   x42
05366:  MOVFF  4C0,741
0536A:  CLRF   x44
0536C:  MOVLW  B5
0536E:  MOVWF  x43
05370:  MOVLB  0
05372:  CALL   08AC
05376:  MOVFF  02,6FD
0537A:  MOVFF  01,6FC
0537E:  MOVLW  01
05380:  MOVLB  6
05382:  ADDWF  01,W
05384:  MOVWF  01
05386:  MOVLW  00
05388:  ADDWFC 02,W
0538A:  MOVWF  03
0538C:  MOVF   01,W
0538E:  ADDLW  EB
05390:  MOVWF  FE9
05392:  MOVLW  01
05394:  ADDWFC 03,W
05396:  MOVWF  FEA
05398:  MOVF   FEF,W
0539A:  SUBLW  18
0539C:  BTFSS  FD8.0
0539E:  BRA    556C
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053A0:  MOVLB  7
053A2:  CLRF   x42
053A4:  MOVFF  4C0,741
053A8:  CLRF   x44
053AA:  MOVLW  B5
053AC:  MOVWF  x43
053AE:  MOVLB  0
053B0:  CALL   08AC
053B4:  MOVFF  02,6FD
053B8:  MOVFF  01,6FC
053BC:  MOVLW  06
053BE:  MOVLB  6
053C0:  ADDWF  xFC,F
053C2:  MOVLW  00
053C4:  ADDWFC xFD,F
053C6:  MOVLB  7
053C8:  CLRF   x42
053CA:  MOVFF  4C0,741
053CE:  CLRF   x44
053D0:  MOVLW  B5
053D2:  MOVWF  x43
053D4:  MOVLB  0
053D6:  CALL   08AC
053DA:  MOVFF  02,6FF
053DE:  MOVFF  01,6FE
053E2:  MOVLW  02
053E4:  ADDWF  01,W
053E6:  MOVWF  01
053E8:  MOVLW  00
053EA:  ADDWFC 02,W
053EC:  MOVWF  03
053EE:  MOVF   01,W
053F0:  ADDLW  EB
053F2:  MOVWF  FE9
053F4:  MOVLW  01
053F6:  ADDWFC 03,W
053F8:  MOVWF  FEA
053FA:  MOVLB  7
053FC:  CLRF   x42
053FE:  MOVFF  FEF,741
05402:  CLRF   x44
05404:  MOVLW  19
05406:  MOVWF  x43
05408:  MOVLB  0
0540A:  CALL   08AC
0540E:  MOVFF  02,03
05412:  MOVF   01,W
05414:  MOVLB  6
05416:  ADDWF  xFC,F
05418:  MOVF   02,W
0541A:  ADDWFC xFD,F
0541C:  MOVLB  7
0541E:  CLRF   x42
05420:  MOVFF  4C0,741
05424:  CLRF   x44
05426:  MOVLW  B5
05428:  MOVWF  x43
0542A:  MOVLB  0
0542C:  CALL   08AC
05430:  MOVFF  01,6FE
05434:  MOVLW  01
05436:  MOVLB  6
05438:  ADDWF  01,W
0543A:  MOVWF  01
0543C:  MOVLW  00
0543E:  ADDWFC 02,W
05440:  MOVWF  03
05442:  MOVF   01,W
05444:  ADDLW  EB
05446:  MOVWF  FE9
05448:  MOVLW  01
0544A:  ADDWFC 03,W
0544C:  MOVWF  FEA
0544E:  MOVF   FEF,W
05450:  ADDWF  xFC,W
05452:  MOVWF  01
05454:  MOVLW  00
05456:  ADDWFC xFD,W
05458:  MOVWF  03
0545A:  MOVF   01,W
0545C:  ADDLW  EB
0545E:  MOVWF  FE9
05460:  MOVLW  01
05462:  ADDWFC 03,W
05464:  MOVWF  FEA
05466:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
0546A:  MOVLB  7
0546C:  CLRF   x42
0546E:  MOVFF  4C0,741
05472:  CLRF   x44
05474:  MOVLW  B5
05476:  MOVWF  x43
05478:  MOVLB  0
0547A:  CALL   08AC
0547E:  MOVFF  01,6FC
05482:  MOVLW  01
05484:  MOVLB  6
05486:  ADDWF  01,W
05488:  MOVWF  01
0548A:  MOVLW  00
0548C:  ADDWFC 02,W
0548E:  MOVWF  03
05490:  MOVF   01,W
05492:  ADDLW  EB
05494:  MOVWF  FE9
05496:  MOVLW  01
05498:  ADDWFC 03,W
0549A:  MOVWF  FEA
0549C:  MOVLW  01
0549E:  ADDWF  FEF,W
054A0:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054A2:  MOVLB  7
054A4:  CLRF   x42
054A6:  MOVFF  4C0,741
054AA:  CLRF   x44
054AC:  MOVLW  B5
054AE:  MOVWF  x43
054B0:  MOVLB  0
054B2:  CALL   08AC
054B6:  MOVFF  02,6FD
054BA:  MOVFF  01,6FC
054BE:  MOVLW  06
054C0:  MOVLB  6
054C2:  ADDWF  xFC,F
054C4:  MOVLW  00
054C6:  ADDWFC xFD,F
054C8:  MOVLB  7
054CA:  CLRF   x42
054CC:  MOVFF  4C0,741
054D0:  CLRF   x44
054D2:  MOVLW  B5
054D4:  MOVWF  x43
054D6:  MOVLB  0
054D8:  CALL   08AC
054DC:  MOVFF  02,6FF
054E0:  MOVFF  01,6FE
054E4:  MOVLW  02
054E6:  ADDWF  01,W
054E8:  MOVWF  01
054EA:  MOVLW  00
054EC:  ADDWFC 02,W
054EE:  MOVWF  03
054F0:  MOVF   01,W
054F2:  ADDLW  EB
054F4:  MOVWF  FE9
054F6:  MOVLW  01
054F8:  ADDWFC 03,W
054FA:  MOVWF  FEA
054FC:  MOVLB  7
054FE:  CLRF   x42
05500:  MOVFF  FEF,741
05504:  CLRF   x44
05506:  MOVLW  19
05508:  MOVWF  x43
0550A:  MOVLB  0
0550C:  CALL   08AC
05510:  MOVFF  02,03
05514:  MOVF   01,W
05516:  MOVLB  6
05518:  ADDWF  xFC,F
0551A:  MOVF   02,W
0551C:  ADDWFC xFD,F
0551E:  MOVLB  7
05520:  CLRF   x42
05522:  MOVFF  4C0,741
05526:  CLRF   x44
05528:  MOVLW  B5
0552A:  MOVWF  x43
0552C:  MOVLB  0
0552E:  CALL   08AC
05532:  MOVFF  01,6FE
05536:  MOVLW  01
05538:  MOVLB  6
0553A:  ADDWF  01,W
0553C:  MOVWF  01
0553E:  MOVLW  00
05540:  ADDWFC 02,W
05542:  MOVWF  03
05544:  MOVF   01,W
05546:  ADDLW  EB
05548:  MOVWF  FE9
0554A:  MOVLW  01
0554C:  ADDWFC 03,W
0554E:  MOVWF  FEA
05550:  MOVF   FEF,W
05552:  ADDWF  xFC,W
05554:  MOVWF  01
05556:  MOVLW  00
05558:  ADDWFC xFD,W
0555A:  MOVWF  03
0555C:  MOVF   01,W
0555E:  ADDLW  EB
05560:  MOVWF  FE9
05562:  MOVLW  01
05564:  ADDWFC 03,W
05566:  MOVWF  FEA
05568:  CLRF   FEF
....................          }
0556A:  BRA    5582
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
0556C:  MOVFF  4C0,701
05570:  MOVLB  0
05572:  CALL   0B90
....................             fprintf(SERIAL, retData);
05576:  MOVLW  04
05578:  MOVWF  FEA
0557A:  MOVLW  C1
0557C:  MOVWF  FE9
0557E:  RCALL  504C
05580:  MOVLB  6
....................          }
....................       }
05582:  MOVLB  0
05584:  BRA    5076
05586:  MOVLB  1
....................    }          
05588:  MOVLB  0
0558A:  GOTO   A776 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00D0A:  MOVLB  6
00D0C:  CLRF   xFB
00D0E:  MOVF   xFB,W
00D10:  SUBLW  03
00D12:  BNC   0D22
....................    {
....................       resetSERcmd(i);
00D14:  MOVFF  6FB,701
00D18:  MOVLB  0
00D1A:  RCALL  0B90
00D1C:  MOVLB  6
00D1E:  INCF   xFB,F
00D20:  BRA    0D0E
....................    }
....................    enable_interrupts(INT_RDA);
00D22:  MOVLB  E
00D24:  BSF    xC0.5
00D26:  MOVLB  0
00D28:  GOTO   A73A (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D2C:  MOVLB  E
00D2E:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D30:  MOVLW  01
00D32:  MOVWF  FD1
00D34:  MOVLW  07
00D36:  MOVWF  FCE
00D38:  CLRF   FCF
00D3A:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D3C:  MOVLB  1
00D3E:  CLRF   x75
00D40:  CLRF   x74
00D42:  CLRF   x73
00D44:  CLRF   x72
....................    timeoutReg1 = 0;
00D46:  CLRF   x79
00D48:  CLRF   x78
00D4A:  CLRF   x77
00D4C:  CLRF   x76
....................    timeoutReg2 = 0;
00D4E:  CLRF   x7D
00D50:  CLRF   x7C
00D52:  CLRF   x7B
00D54:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D56:  MOVLB  E
00D58:  BSF    xC1.0
00D5A:  MOVLB  0
00D5C:  GOTO   A73E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0029E:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
002A0:  MOVLW  0B
002A2:  MOVWF  FCD
002A4:  MOVLW  DB
002A6:  MOVWF  FCC
002A8:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
002AA:  MOVLB  1
002AC:  MOVF   x75,F
002AE:  BNZ   02BE
002B0:  MOVF   x74,F
002B2:  BNZ   02BE
002B4:  MOVF   x73,F
002B6:  BNZ   02BE
002B8:  MOVF   x72,W
002BA:  SUBLW  0A
002BC:  BC    02CC
002BE:  MOVLW  0A
002C0:  SUBWF  x72,F
002C2:  MOVLW  00
002C4:  SUBWFB x73,F
002C6:  SUBWFB x74,F
002C8:  SUBWFB x75,F
002CA:  BRA    02D4
002CC:  CLRF   x75
002CE:  CLRF   x74
002D0:  CLRF   x73
002D2:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
002D4:  MOVF   x79,F
002D6:  BNZ   02E6
002D8:  MOVF   x78,F
002DA:  BNZ   02E6
002DC:  MOVF   x77,F
002DE:  BNZ   02E6
002E0:  MOVF   x76,W
002E2:  SUBLW  0A
002E4:  BC    02F4
002E6:  MOVLW  0A
002E8:  SUBWF  x76,F
002EA:  MOVLW  00
002EC:  SUBWFB x77,F
002EE:  SUBWFB x78,F
002F0:  SUBWFB x79,F
002F2:  BRA    02FC
002F4:  CLRF   x79
002F6:  CLRF   x78
002F8:  CLRF   x77
002FA:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002FC:  MOVF   x7D,F
002FE:  BNZ   030E
00300:  MOVF   x7C,F
00302:  BNZ   030E
00304:  MOVF   x7B,F
00306:  BNZ   030E
00308:  MOVF   x7A,W
0030A:  SUBLW  0A
0030C:  BC    031C
0030E:  MOVLW  0A
00310:  SUBWF  x7A,F
00312:  MOVLW  00
00314:  SUBWFB x7B,F
00316:  SUBWFB x7C,F
00318:  SUBWFB x7D,F
0031A:  BRA    0324
0031C:  CLRF   x7D
0031E:  CLRF   x7C
00320:  CLRF   x7B
00322:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
00324:  MOVF   x7E,F
00326:  BNZ   032C
00328:  MOVF   x7F,F
0032A:  BZ    0368
....................    {
....................       timeCounter+=10;
0032C:  MOVLW  0A
0032E:  MOVLB  5
00330:  ADDWF  x66,F
00332:  MOVLW  00
00334:  ADDWFC x67,F
00336:  ADDWFC x68,F
00338:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
0033A:  MOVF   x69,F
0033C:  BNZ   0358
0033E:  MOVF   x68,F
00340:  BNZ   0358
00342:  MOVLB  1
00344:  MOVF   x7F,W
00346:  MOVLB  5
00348:  SUBWF  x67,W
0034A:  BNC   0366
0034C:  BNZ   0358
0034E:  MOVLB  1
00350:  MOVF   x7E,W
00352:  MOVLB  5
00354:  SUBWF  x66,W
00356:  BNC   0366
....................       {
....................          sensor_monitor_interrupt_task();
00358:  MOVLB  0
0035A:  BRA    0202
....................          timeCounter = 0;
0035C:  MOVLB  5
0035E:  CLRF   x69
00360:  CLRF   x68
00362:  CLRF   x67
00364:  CLRF   x66
00366:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00368:  MOVLB  E
0036A:  BCF    xC9.0
0036C:  MOVLB  0
0036E:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", version);
*
05B9A:  MOVLW  04
05B9C:  MOVLB  7
05B9E:  MOVWF  x42
05BA0:  MOVLW  C1
05BA2:  MOVWF  x41
05BA4:  MOVLB  0
05BA6:  RCALL  558E
05BA8:  MOVFF  02,03
05BAC:  MOVF   01,W
05BAE:  ADDLW  C1
05BB0:  MOVLB  7
05BB2:  MOVWF  x0B
05BB4:  MOVLW  04
05BB6:  ADDWFC 02,W
05BB8:  MOVWF  x0C
05BBA:  MOVFF  FE8,565
05BBE:  MOVFF  70B,564
05BC2:  MOVLW  72
05BC4:  MOVWF  FF6
05BC6:  MOVLW  03
05BC8:  MOVWF  FF7
05BCA:  MOVLB  0
05BCC:  RCALL  5B7A
05BCE:  MOVLW  2C
05BD0:  MOVLB  7
05BD2:  MOVWF  x50
05BD4:  MOVLB  0
05BD6:  RCALL  55C6
....................     return SUCCESS;
05BD8:  MOVLW  00
05BDA:  MOVWF  01
05BDC:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", serialID);
05BDE:  MOVLW  04
05BE0:  MOVLB  7
05BE2:  MOVWF  x42
05BE4:  MOVLW  C1
05BE6:  MOVWF  x41
05BE8:  MOVLB  0
05BEA:  RCALL  558E
05BEC:  MOVFF  02,03
05BF0:  MOVF   01,W
05BF2:  ADDLW  C1
05BF4:  MOVLB  7
05BF6:  MOVWF  x0B
05BF8:  MOVLW  04
05BFA:  ADDWFC 02,W
05BFC:  MOVWF  x0C
05BFE:  MOVFF  FE8,565
05C02:  MOVFF  70B,564
05C06:  MOVLW  7C
05C08:  MOVWF  FF6
05C0A:  MOVLW  03
05C0C:  MOVWF  FF7
05C0E:  MOVLB  0
05C10:  RCALL  5B7A
05C12:  MOVLW  2C
05C14:  MOVLB  7
05C16:  MOVWF  x50
05C18:  MOVLB  0
05C1A:  RCALL  55C6
....................     return SUCCESS;
05C1C:  MOVLW  00
05C1E:  MOVWF  01
05C20:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................    
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0612E:  MOVLB  7
06130:  CLRF   x42
06132:  MOVFF  690,741
06136:  CLRF   x44
06138:  MOVLW  B5
0613A:  MOVWF  x43
0613C:  MOVLB  0
0613E:  CALL   08AC
06142:  MOVFF  02,70D
06146:  MOVFF  01,70C
0614A:  MOVLW  06
0614C:  MOVLB  7
0614E:  ADDWF  x0C,F
06150:  MOVLW  00
06152:  ADDWFC x0D,F
06154:  MOVLW  32
06156:  ADDWF  x0C,W
06158:  MOVWF  01
0615A:  MOVLW  00
0615C:  ADDWFC x0D,W
0615E:  MOVWF  03
06160:  MOVF   01,W
06162:  ADDLW  EB
06164:  MOVWF  01
06166:  MOVLW  01
06168:  ADDWFC 03,F
0616A:  MOVFF  01,70C
0616E:  MOVFF  03,70D
06172:  MOVFF  03,734
06176:  MOVFF  01,733
0617A:  MOVLB  0
0617C:  RCALL  5C22
0617E:  MOVF   01,F
06180:  BNZ   618A
06182:  MOVLW  02
06184:  MOVWF  01
06186:  BRA    62D8
06188:  BRA    61E6
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0618A:  MOVLB  7
0618C:  CLRF   x42
0618E:  MOVFF  690,741
06192:  CLRF   x44
06194:  MOVLW  B5
06196:  MOVWF  x43
06198:  MOVLB  0
0619A:  CALL   08AC
0619E:  MOVFF  02,70D
061A2:  MOVFF  01,70C
061A6:  MOVLW  06
061A8:  MOVLB  7
061AA:  ADDWF  x0C,F
061AC:  MOVLW  00
061AE:  ADDWFC x0D,F
061B0:  MOVLW  32
061B2:  ADDWF  x0C,W
061B4:  MOVWF  01
061B6:  MOVLW  00
061B8:  ADDWFC x0D,W
061BA:  MOVWF  03
061BC:  MOVF   01,W
061BE:  ADDLW  EB
061C0:  MOVWF  01
061C2:  MOVLW  01
061C4:  ADDWFC 03,F
061C6:  MOVFF  01,70C
061CA:  MOVFF  03,70D
061CE:  MOVFF  03,734
061D2:  MOVFF  01,733
061D6:  CLRF   x36
061D8:  CLRF   x35
061DA:  MOVLW  0A
061DC:  MOVWF  x37
061DE:  MOVLB  0
061E0:  RCALL  5D12
061E2:  MOVFF  01,70B
....................    
....................     /*** GET CHANNEL MAP ***************/ 
....................     if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
061E6:  MOVLW  01
061E8:  MOVLB  7
061EA:  SUBWF  x0B,W
061EC:  MOVWF  x0D
061EE:  CLRF   x0F
061F0:  MOVLW  70
061F2:  MOVWF  x0E
061F4:  MOVLB  0
061F6:  CALL   460A
061FA:  BTFSC  01.0
061FC:  BRA    625A
061FE:  MOVLW  04
06200:  MOVLB  7
06202:  MOVWF  x42
06204:  MOVLW  C1
06206:  MOVWF  x41
06208:  MOVLB  0
0620A:  CALL   558E
0620E:  MOVFF  02,03
06212:  MOVF   01,W
06214:  ADDLW  C1
06216:  MOVLB  7
06218:  MOVWF  x0C
0621A:  MOVLW  04
0621C:  ADDWFC 02,W
0621E:  MOVWF  x0D
06220:  MOVFF  FE8,565
06224:  MOVFF  70C,564
06228:  MOVFF  70B,734
0622C:  MOVLW  18
0622E:  MOVWF  x35
06230:  MOVLB  0
06232:  RCALL  6066
06234:  MOVLW  2C
06236:  MOVLB  7
06238:  MOVWF  x50
0623A:  MOVLB  0
0623C:  CALL   55C6
06240:  MOVLW  58
06242:  MOVLB  7
06244:  MOVWF  x50
06246:  MOVLB  0
06248:  CALL   55C6
0624C:  MOVLW  2C
0624E:  MOVLB  7
06250:  MOVWF  x50
06252:  MOVLB  0
06254:  CALL   55C6
06258:  BRA    62D4
....................     else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
0625A:  MOVLW  01
0625C:  MOVLB  7
0625E:  SUBWF  x0B,W
06260:  MOVWF  x0D
06262:  CLRF   x0F
06264:  MOVLW  70
06266:  MOVWF  x0E
06268:  MOVLB  0
0626A:  CALL   460A
0626E:  BTFSS  01.0
06270:  BRA    62CE
06272:  MOVLW  04
06274:  MOVLB  7
06276:  MOVWF  x42
06278:  MOVLW  C1
0627A:  MOVWF  x41
0627C:  MOVLB  0
0627E:  CALL   558E
06282:  MOVFF  02,03
06286:  MOVF   01,W
06288:  ADDLW  C1
0628A:  MOVLB  7
0628C:  MOVWF  x0C
0628E:  MOVLW  04
06290:  ADDWFC 02,W
06292:  MOVWF  x0D
06294:  MOVFF  FE8,565
06298:  MOVFF  70C,564
0629C:  MOVFF  70B,734
062A0:  MOVLW  18
062A2:  MOVWF  x35
062A4:  MOVLB  0
062A6:  RCALL  6066
062A8:  MOVLW  2C
062AA:  MOVLB  7
062AC:  MOVWF  x50
062AE:  MOVLB  0
062B0:  CALL   55C6
062B4:  MOVLW  59
062B6:  MOVLB  7
062B8:  MOVWF  x50
062BA:  MOVLB  0
062BC:  CALL   55C6
062C0:  MOVLW  2C
062C2:  MOVLB  7
062C4:  MOVWF  x50
062C6:  MOVLB  0
062C8:  CALL   55C6
062CC:  BRA    62D4
....................     else return INV_PARAM;
062CE:  MOVLW  02
062D0:  MOVWF  01
062D2:  BRA    62D8
....................    
....................     return SUCCESS;
062D4:  MOVLW  00
062D6:  MOVWF  01
062D8:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0631C:  MOVLB  7
0631E:  CLRF   x42
06320:  MOVFF  690,741
06324:  CLRF   x44
06326:  MOVLW  B5
06328:  MOVWF  x43
0632A:  MOVLB  0
0632C:  CALL   08AC
06330:  MOVFF  02,70E
06334:  MOVFF  01,70D
06338:  MOVLW  06
0633A:  MOVLB  7
0633C:  ADDWF  x0D,F
0633E:  MOVLW  00
06340:  ADDWFC x0E,F
06342:  MOVLW  32
06344:  ADDWF  x0D,W
06346:  MOVWF  01
06348:  MOVLW  00
0634A:  ADDWFC x0E,W
0634C:  MOVWF  03
0634E:  MOVF   01,W
06350:  ADDLW  EB
06352:  MOVWF  01
06354:  MOVLW  01
06356:  ADDWFC 03,F
06358:  MOVFF  01,70D
0635C:  MOVFF  03,70E
06360:  MOVFF  03,734
06364:  MOVFF  01,733
06368:  MOVLB  0
0636A:  RCALL  5C22
0636C:  MOVF   01,F
0636E:  BNZ   6378
06370:  MOVLW  02
06372:  MOVWF  01
06374:  BRA    64C8
06376:  BRA    63D4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06378:  MOVLB  7
0637A:  CLRF   x42
0637C:  MOVFF  690,741
06380:  CLRF   x44
06382:  MOVLW  B5
06384:  MOVWF  x43
06386:  MOVLB  0
06388:  CALL   08AC
0638C:  MOVFF  02,70E
06390:  MOVFF  01,70D
06394:  MOVLW  06
06396:  MOVLB  7
06398:  ADDWF  x0D,F
0639A:  MOVLW  00
0639C:  ADDWFC x0E,F
0639E:  MOVLW  32
063A0:  ADDWF  x0D,W
063A2:  MOVWF  01
063A4:  MOVLW  00
063A6:  ADDWFC x0E,W
063A8:  MOVWF  03
063AA:  MOVF   01,W
063AC:  ADDLW  EB
063AE:  MOVWF  01
063B0:  MOVLW  01
063B2:  ADDWFC 03,F
063B4:  MOVFF  01,70D
063B8:  MOVFF  03,70E
063BC:  MOVFF  03,734
063C0:  MOVFF  01,733
063C4:  CLRF   x36
063C6:  CLRF   x35
063C8:  MOVLW  0A
063CA:  MOVWF  x37
063CC:  MOVLB  0
063CE:  RCALL  5D12
063D0:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
063D4:  MOVLB  7
063D6:  CLRF   x42
063D8:  MOVFF  690,741
063DC:  CLRF   x44
063DE:  MOVLW  B5
063E0:  MOVWF  x43
063E2:  MOVLB  0
063E4:  CALL   08AC
063E8:  MOVFF  02,70E
063EC:  MOVFF  01,70D
063F0:  MOVLW  06
063F2:  MOVLB  7
063F4:  ADDWF  x0D,F
063F6:  MOVLW  00
063F8:  ADDWFC x0E,F
063FA:  MOVLW  4B
063FC:  ADDWF  x0D,W
063FE:  MOVWF  01
06400:  MOVLW  00
06402:  ADDWFC x0E,W
06404:  MOVWF  03
06406:  MOVF   01,W
06408:  ADDLW  EB
0640A:  MOVWF  01
0640C:  MOVLW  01
0640E:  ADDWFC 03,F
06410:  MOVFF  01,70D
06414:  MOVFF  03,70E
06418:  MOVFF  03,742
0641C:  MOVFF  01,741
06420:  MOVLB  0
06422:  CALL   558E
06426:  MOVFF  02,03
0642A:  MOVF   01,W
0642C:  SUBLW  01
0642E:  BNZ   6434
06430:  MOVF   03,F
06432:  BZ    643C
06434:  MOVLW  02
06436:  MOVWF  01
06438:  BRA    64C8
0643A:  BRA    647C
....................    else arg2 = SERcmd[rec].p[3][0];
0643C:  MOVLB  7
0643E:  CLRF   x42
06440:  MOVFF  690,741
06444:  CLRF   x44
06446:  MOVLW  B5
06448:  MOVWF  x43
0644A:  MOVLB  0
0644C:  CALL   08AC
06450:  MOVFF  02,70E
06454:  MOVFF  01,70D
06458:  MOVLW  06
0645A:  MOVLB  7
0645C:  ADDWF  x0D,F
0645E:  MOVLW  00
06460:  ADDWFC x0E,F
06462:  MOVLW  4B
06464:  ADDWF  x0D,F
06466:  MOVLW  00
06468:  ADDWFC x0E,F
0646A:  MOVLW  EB
0646C:  ADDWF  x0D,W
0646E:  MOVWF  FE9
06470:  MOVLW  01
06472:  ADDWFC x0E,W
06474:  MOVWF  FEA
06476:  MOVFF  FEF,70C
0647A:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
0647C:  MOVLB  7
0647E:  MOVF   x0C,W
06480:  SUBLW  58
06482:  BNZ   649C
06484:  MOVLW  01
06486:  SUBWF  x0B,W
06488:  MOVWF  x0D
0648A:  MOVWF  x22
0648C:  CLRF   x23
0648E:  CLRF   x25
06490:  MOVLW  70
06492:  MOVWF  x24
06494:  MOVLB  0
06496:  RCALL  62DA
06498:  BRA    64C4
0649A:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
0649C:  MOVF   x0C,W
0649E:  SUBLW  59
064A0:  BNZ   64BC
064A2:  MOVLW  01
064A4:  SUBWF  x0B,W
064A6:  MOVWF  x0D
064A8:  MOVWF  x22
064AA:  MOVLW  01
064AC:  MOVWF  x23
064AE:  CLRF   x25
064B0:  MOVLW  70
064B2:  MOVWF  x24
064B4:  MOVLB  0
064B6:  RCALL  62DA
064B8:  BRA    64C4
064BA:  MOVLB  7
....................    else return INV_PARAM;
064BC:  MOVLW  02
064BE:  MOVWF  01
064C0:  MOVLB  0
064C2:  BRA    64C8
....................    
....................    return SUCCESS;
064C4:  MOVLW  00
064C6:  MOVWF  01
064C8:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
064CA:  MOVLB  7
064CC:  CLRF   x42
064CE:  MOVFF  690,741
064D2:  CLRF   x44
064D4:  MOVLW  B5
064D6:  MOVWF  x43
064D8:  MOVLB  0
064DA:  CALL   08AC
064DE:  MOVFF  02,70D
064E2:  MOVFF  01,70C
064E6:  MOVLW  06
064E8:  MOVLB  7
064EA:  ADDWF  x0C,F
064EC:  MOVLW  00
064EE:  ADDWFC x0D,F
064F0:  MOVLW  32
064F2:  ADDWF  x0C,W
064F4:  MOVWF  01
064F6:  MOVLW  00
064F8:  ADDWFC x0D,W
064FA:  MOVWF  03
064FC:  MOVF   01,W
064FE:  ADDLW  EB
06500:  MOVWF  01
06502:  MOVLW  01
06504:  ADDWFC 03,F
06506:  MOVFF  01,70C
0650A:  MOVFF  03,70D
0650E:  MOVFF  03,734
06512:  MOVFF  01,733
06516:  MOVLB  0
06518:  CALL   5C22
0651C:  MOVF   01,F
0651E:  BNZ   6528
06520:  MOVLW  02
06522:  MOVWF  01
06524:  BRA    6658
06526:  BRA    6586
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06528:  MOVLB  7
0652A:  CLRF   x42
0652C:  MOVFF  690,741
06530:  CLRF   x44
06532:  MOVLW  B5
06534:  MOVWF  x43
06536:  MOVLB  0
06538:  CALL   08AC
0653C:  MOVFF  02,70D
06540:  MOVFF  01,70C
06544:  MOVLW  06
06546:  MOVLB  7
06548:  ADDWF  x0C,F
0654A:  MOVLW  00
0654C:  ADDWFC x0D,F
0654E:  MOVLW  32
06550:  ADDWF  x0C,W
06552:  MOVWF  01
06554:  MOVLW  00
06556:  ADDWFC x0D,W
06558:  MOVWF  03
0655A:  MOVF   01,W
0655C:  ADDLW  EB
0655E:  MOVWF  01
06560:  MOVLW  01
06562:  ADDWFC 03,F
06564:  MOVFF  01,70C
06568:  MOVFF  03,70D
0656C:  MOVFF  03,734
06570:  MOVFF  01,733
06574:  CLRF   x36
06576:  CLRF   x35
06578:  MOVLW  0A
0657A:  MOVWF  x37
0657C:  MOVLB  0
0657E:  CALL   5D12
06582:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06586:  MOVLW  01
06588:  MOVLB  7
0658A:  SUBWF  x0B,W
0658C:  MOVWF  x0D
0658E:  CLRF   x0F
06590:  MOVLW  71
06592:  MOVWF  x0E
06594:  MOVLB  0
06596:  CALL   460A
0659A:  BTFSC  01.0
0659C:  BRA    65EA
0659E:  MOVLW  04
065A0:  MOVLB  7
065A2:  MOVWF  x42
065A4:  MOVLW  C1
065A6:  MOVWF  x41
065A8:  MOVLB  0
065AA:  CALL   558E
065AE:  MOVFF  02,03
065B2:  MOVF   01,W
065B4:  ADDLW  C1
065B6:  MOVLB  7
065B8:  MOVWF  x0C
065BA:  MOVLW  04
065BC:  ADDWFC 02,W
065BE:  MOVWF  x0D
065C0:  MOVFF  FE8,565
065C4:  MOVFF  70C,564
065C8:  MOVFF  70B,734
065CC:  MOVLW  18
065CE:  MOVWF  x35
065D0:  MOVLB  0
065D2:  RCALL  6066
065D4:  MOVLW  84
065D6:  MOVWF  FF6
065D8:  MOVLW  03
065DA:  MOVWF  FF7
065DC:  MOVLW  08
065DE:  MOVLB  7
065E0:  MOVWF  x0F
065E2:  MOVLB  0
065E4:  CALL   55E6
065E8:  BRA    6654
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
065EA:  MOVLW  01
065EC:  MOVLB  7
065EE:  SUBWF  x0B,W
065F0:  MOVWF  x0D
065F2:  CLRF   x0F
065F4:  MOVLW  71
065F6:  MOVWF  x0E
065F8:  MOVLB  0
065FA:  CALL   460A
065FE:  BTFSS  01.0
06600:  BRA    664E
06602:  MOVLW  04
06604:  MOVLB  7
06606:  MOVWF  x42
06608:  MOVLW  C1
0660A:  MOVWF  x41
0660C:  MOVLB  0
0660E:  CALL   558E
06612:  MOVFF  02,03
06616:  MOVF   01,W
06618:  ADDLW  C1
0661A:  MOVLB  7
0661C:  MOVWF  x0C
0661E:  MOVLW  04
06620:  ADDWFC 02,W
06622:  MOVWF  x0D
06624:  MOVFF  FE8,565
06628:  MOVFF  70C,564
0662C:  MOVFF  70B,734
06630:  MOVLW  18
06632:  MOVWF  x35
06634:  MOVLB  0
06636:  RCALL  6066
06638:  MOVLW  90
0663A:  MOVWF  FF6
0663C:  MOVLW  03
0663E:  MOVWF  FF7
06640:  MOVLW  08
06642:  MOVLB  7
06644:  MOVWF  x0F
06646:  MOVLB  0
06648:  CALL   55E6
0664C:  BRA    6654
....................    else return INV_PARAM;
0664E:  MOVLW  02
06650:  MOVWF  01
06652:  BRA    6658
....................    
....................    return SUCCESS;
06654:  MOVLW  00
06656:  MOVWF  01
06658:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
0665A:  MOVLW  4D
0665C:  MOVLB  7
0665E:  MOVWF  x10
06660:  MOVLW  41
06662:  MOVWF  x11
06664:  MOVLW  4E
06666:  MOVWF  x12
06668:  MOVLW  55
0666A:  MOVWF  x13
0666C:  MOVLW  41
0666E:  MOVWF  x14
06670:  MOVLW  4C
06672:  MOVWF  x15
06674:  CLRF   x16
06676:  MOVLW  07
06678:  MOVWF  x0F
0667A:  MOVLW  10
0667C:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
0667E:  MOVLW  4D
06680:  MOVWF  x19
06682:  MOVLW  41
06684:  MOVWF  x1A
06686:  MOVLW  47
06688:  MOVWF  x1B
0668A:  MOVLW  53
0668C:  MOVWF  x1C
0668E:  MOVLW  4E
06690:  MOVWF  x1D
06692:  MOVLW  53
06694:  MOVWF  x1E
06696:  CLRF   x1F
06698:  MOVLW  07
0669A:  MOVWF  x18
0669C:  MOVLW  19
0669E:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
066A0:  CLRF   x42
066A2:  MOVFF  690,741
066A6:  CLRF   x44
066A8:  MOVLW  B5
066AA:  MOVWF  x43
066AC:  MOVLB  0
066AE:  CALL   08AC
066B2:  MOVFF  02,721
066B6:  MOVFF  01,720
066BA:  MOVLW  06
066BC:  MOVLB  7
066BE:  ADDWF  x20,F
066C0:  MOVLW  00
066C2:  ADDWFC x21,F
066C4:  MOVLW  32
066C6:  ADDWF  x20,W
066C8:  MOVWF  01
066CA:  MOVLW  00
066CC:  ADDWFC x21,W
066CE:  MOVWF  03
066D0:  MOVF   01,W
066D2:  ADDLW  EB
066D4:  MOVWF  01
066D6:  MOVLW  01
066D8:  ADDWFC 03,F
066DA:  MOVFF  01,720
066DE:  MOVFF  03,721
066E2:  MOVFF  03,734
066E6:  MOVFF  01,733
066EA:  MOVLB  0
066EC:  CALL   5C22
066F0:  MOVF   01,F
066F2:  BNZ   66FC
066F4:  MOVLW  02
066F6:  MOVWF  01
066F8:  BRA    6872
066FA:  BRA    675A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
066FC:  MOVLB  7
066FE:  CLRF   x42
06700:  MOVFF  690,741
06704:  CLRF   x44
06706:  MOVLW  B5
06708:  MOVWF  x43
0670A:  MOVLB  0
0670C:  CALL   08AC
06710:  MOVFF  02,721
06714:  MOVFF  01,720
06718:  MOVLW  06
0671A:  MOVLB  7
0671C:  ADDWF  x20,F
0671E:  MOVLW  00
06720:  ADDWFC x21,F
06722:  MOVLW  32
06724:  ADDWF  x20,W
06726:  MOVWF  01
06728:  MOVLW  00
0672A:  ADDWFC x21,W
0672C:  MOVWF  03
0672E:  MOVF   01,W
06730:  ADDLW  EB
06732:  MOVWF  01
06734:  MOVLW  01
06736:  ADDWFC 03,F
06738:  MOVFF  01,720
0673C:  MOVFF  03,721
06740:  MOVFF  03,734
06744:  MOVFF  01,733
06748:  CLRF   x36
0674A:  CLRF   x35
0674C:  MOVLW  0A
0674E:  MOVWF  x37
06750:  MOVLB  0
06752:  CALL   5D12
06756:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
0675A:  MOVLB  7
0675C:  CLRF   x42
0675E:  MOVFF  690,741
06762:  CLRF   x44
06764:  MOVLW  B5
06766:  MOVWF  x43
06768:  MOVLB  0
0676A:  CALL   08AC
0676E:  MOVFF  02,721
06772:  MOVFF  01,720
06776:  MOVLW  06
06778:  MOVLB  7
0677A:  ADDWF  x20,F
0677C:  MOVLW  00
0677E:  ADDWFC x21,F
06780:  MOVLW  4B
06782:  ADDWF  x20,W
06784:  MOVWF  01
06786:  MOVLW  00
06788:  ADDWFC x21,W
0678A:  MOVWF  03
0678C:  MOVF   01,W
0678E:  ADDLW  EB
06790:  MOVWF  01
06792:  MOVLW  01
06794:  ADDWFC 03,F
06796:  MOVFF  01,720
0679A:  MOVFF  03,721
0679E:  MOVFF  03,742
067A2:  MOVFF  01,741
067A6:  MOVLB  0
067A8:  CALL   558E
067AC:  MOVFF  02,03
067B0:  MOVF   01,W
067B2:  BNZ   67C0
067B4:  MOVF   03,F
067B6:  BNZ   67C0
067B8:  MOVLW  02
067BA:  MOVWF  01
067BC:  BRA    6872
067BE:  BRA    6806
....................    else arg2 = SERcmd[rec].p[3];
067C0:  MOVLB  7
067C2:  CLRF   x42
067C4:  MOVFF  690,741
067C8:  CLRF   x44
067CA:  MOVLW  B5
067CC:  MOVWF  x43
067CE:  MOVLB  0
067D0:  CALL   08AC
067D4:  MOVFF  02,721
067D8:  MOVFF  01,720
067DC:  MOVLW  06
067DE:  MOVLB  7
067E0:  ADDWF  x20,F
067E2:  MOVLW  00
067E4:  ADDWFC x21,F
067E6:  MOVLW  4B
067E8:  ADDWF  x20,W
067EA:  MOVWF  01
067EC:  MOVLW  00
067EE:  ADDWFC x21,W
067F0:  MOVWF  03
067F2:  MOVF   01,W
067F4:  ADDLW  EB
067F6:  MOVWF  01
067F8:  MOVLW  01
067FA:  ADDWFC 03,F
067FC:  MOVFF  01,70C
06800:  MOVFF  03,70D
06804:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06806:  MOVFF  70F,742
0680A:  MOVFF  70E,741
0680E:  MOVFF  70D,744
06812:  MOVFF  70C,743
06816:  CALL   5B02
0681A:  MOVF   01,F
0681C:  BNZ   6836
0681E:  MOVLW  01
06820:  MOVLB  7
06822:  SUBWF  x0B,W
06824:  MOVWF  x20
06826:  MOVWF  x22
06828:  CLRF   x23
0682A:  CLRF   x25
0682C:  MOVLW  71
0682E:  MOVWF  x24
06830:  MOVLB  0
06832:  RCALL  62DA
06834:  BRA    686E
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06836:  MOVFF  718,742
0683A:  MOVFF  717,741
0683E:  MOVFF  70D,744
06842:  MOVFF  70C,743
06846:  CALL   5B02
0684A:  MOVF   01,F
0684C:  BNZ   6868
0684E:  MOVLW  01
06850:  MOVLB  7
06852:  SUBWF  x0B,W
06854:  MOVWF  x20
06856:  MOVWF  x22
06858:  MOVLW  01
0685A:  MOVWF  x23
0685C:  CLRF   x25
0685E:  MOVLW  71
06860:  MOVWF  x24
06862:  MOVLB  0
06864:  RCALL  62DA
06866:  BRA    686E
....................    else return INV_PARAM;
06868:  MOVLW  02
0686A:  MOVWF  01
0686C:  BRA    6872
....................    
....................    return SUCCESS;
0686E:  MOVLW  00
06870:  MOVWF  01
06872:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06874:  MOVLB  7
06876:  CLRF   x42
06878:  MOVFF  690,741
0687C:  CLRF   x44
0687E:  MOVLW  B5
06880:  MOVWF  x43
06882:  MOVLB  0
06884:  CALL   08AC
06888:  MOVFF  02,70E
0688C:  MOVFF  01,70D
06890:  MOVLW  06
06892:  MOVLB  7
06894:  ADDWF  x0D,F
06896:  MOVLW  00
06898:  ADDWFC x0E,F
0689A:  MOVLW  32
0689C:  ADDWF  x0D,W
0689E:  MOVWF  01
068A0:  MOVLW  00
068A2:  ADDWFC x0E,W
068A4:  MOVWF  03
068A6:  MOVF   01,W
068A8:  ADDLW  EB
068AA:  MOVWF  01
068AC:  MOVLW  01
068AE:  ADDWFC 03,F
068B0:  MOVFF  01,70D
068B4:  MOVFF  03,70E
068B8:  MOVFF  03,734
068BC:  MOVFF  01,733
068C0:  MOVLB  0
068C2:  CALL   5C22
068C6:  MOVF   01,F
068C8:  BNZ   68D2
068CA:  MOVLW  02
068CC:  MOVWF  01
068CE:  BRA    6D34
068D0:  BRA    6930
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
068D2:  MOVLB  7
068D4:  CLRF   x42
068D6:  MOVFF  690,741
068DA:  CLRF   x44
068DC:  MOVLW  B5
068DE:  MOVWF  x43
068E0:  MOVLB  0
068E2:  CALL   08AC
068E6:  MOVFF  02,70E
068EA:  MOVFF  01,70D
068EE:  MOVLW  06
068F0:  MOVLB  7
068F2:  ADDWF  x0D,F
068F4:  MOVLW  00
068F6:  ADDWFC x0E,F
068F8:  MOVLW  32
068FA:  ADDWF  x0D,W
068FC:  MOVWF  01
068FE:  MOVLW  00
06900:  ADDWFC x0E,W
06902:  MOVWF  03
06904:  MOVF   01,W
06906:  ADDLW  EB
06908:  MOVWF  01
0690A:  MOVLW  01
0690C:  ADDWFC 03,F
0690E:  MOVFF  01,70D
06912:  MOVFF  03,70E
06916:  MOVFF  03,734
0691A:  MOVFF  01,733
0691E:  CLRF   x36
06920:  CLRF   x35
06922:  MOVLW  0A
06924:  MOVWF  x37
06926:  MOVLB  0
06928:  CALL   5D12
0692C:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06930:  MOVLB  7
06932:  CLRF   x42
06934:  MOVFF  690,741
06938:  CLRF   x44
0693A:  MOVLW  B5
0693C:  MOVWF  x43
0693E:  MOVLB  0
06940:  CALL   08AC
06944:  MOVFF  02,70E
06948:  MOVFF  01,70D
0694C:  MOVLW  06
0694E:  MOVLB  7
06950:  ADDWF  x0D,F
06952:  MOVLW  00
06954:  ADDWFC x0E,F
06956:  MOVLW  4B
06958:  ADDWF  x0D,W
0695A:  MOVWF  01
0695C:  MOVLW  00
0695E:  ADDWFC x0E,W
06960:  MOVWF  03
06962:  MOVF   01,W
06964:  ADDLW  EB
06966:  MOVWF  01
06968:  MOVLW  01
0696A:  ADDWFC 03,F
0696C:  MOVFF  01,70D
06970:  MOVFF  03,70E
06974:  MOVFF  03,742
06978:  MOVFF  01,741
0697C:  MOVLB  0
0697E:  CALL   558E
06982:  MOVFF  02,03
06986:  MOVF   01,W
06988:  SUBLW  01
0698A:  BNZ   6990
0698C:  MOVF   03,F
0698E:  BZ    6998
06990:  MOVLW  02
06992:  MOVWF  01
06994:  BRA    6D34
06996:  BRA    69D8
....................    else arg2 = SERcmd[rec].p[3][0];
06998:  MOVLB  7
0699A:  CLRF   x42
0699C:  MOVFF  690,741
069A0:  CLRF   x44
069A2:  MOVLW  B5
069A4:  MOVWF  x43
069A6:  MOVLB  0
069A8:  CALL   08AC
069AC:  MOVFF  02,70E
069B0:  MOVFF  01,70D
069B4:  MOVLW  06
069B6:  MOVLB  7
069B8:  ADDWF  x0D,F
069BA:  MOVLW  00
069BC:  ADDWFC x0E,F
069BE:  MOVLW  4B
069C0:  ADDWF  x0D,F
069C2:  MOVLW  00
069C4:  ADDWFC x0E,F
069C6:  MOVLW  EB
069C8:  ADDWF  x0D,W
069CA:  MOVWF  FE9
069CC:  MOVLW  01
069CE:  ADDWFC x0E,W
069D0:  MOVWF  FEA
069D2:  MOVFF  FEF,70C
069D6:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
069D8:  MOVLB  7
069DA:  MOVF   x0C,W
069DC:  SUBLW  50
069DE:  BNZ   6A7A
069E0:  MOVLW  04
069E2:  MOVWF  x42
069E4:  MOVLW  C1
069E6:  MOVWF  x41
069E8:  MOVLB  0
069EA:  CALL   558E
069EE:  MOVFF  02,03
069F2:  MOVF   01,W
069F4:  ADDLW  C1
069F6:  MOVLB  7
069F8:  MOVWF  x0D
069FA:  MOVLW  04
069FC:  ADDWFC 02,W
069FE:  MOVWF  x0E
06A00:  MOVLW  01
06A02:  SUBWF  x0B,W
06A04:  MULLW  28
06A06:  MOVF   FF3,W
06A08:  CLRF   x10
06A0A:  MOVWF  x0F
06A0C:  MOVLW  20
06A0E:  ADDWF  x0F,W
06A10:  MOVWF  FE9
06A12:  MOVLW  00
06A14:  ADDWFC x10,W
06A16:  MOVWF  FEA
06A18:  MOVFF  FEF,711
06A1C:  MOVFF  FEC,712
06A20:  MOVFF  FEC,713
06A24:  MOVFF  FEC,714
06A28:  MOVFF  70E,565
06A2C:  MOVFF  70D,564
06A30:  MOVFF  70B,734
06A34:  MOVLW  18
06A36:  MOVWF  x35
06A38:  MOVLB  0
06A3A:  CALL   6066
06A3E:  MOVLW  2C
06A40:  MOVLB  7
06A42:  MOVWF  x50
06A44:  MOVLB  0
06A46:  CALL   55C6
06A4A:  MOVLW  89
06A4C:  MOVWF  FE9
06A4E:  MOVFF  714,746
06A52:  MOVFF  713,745
06A56:  MOVFF  712,744
06A5A:  MOVFF  711,743
06A5E:  MOVLW  02
06A60:  MOVLB  7
06A62:  MOVWF  x47
06A64:  MOVLB  0
06A66:  CALL   5764
06A6A:  MOVLW  2C
06A6C:  MOVLB  7
06A6E:  MOVWF  x50
06A70:  MOVLB  0
06A72:  CALL   55C6
06A76:  BRA    6D30
06A78:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06A7A:  MOVF   x0C,W
06A7C:  SUBLW  49
06A7E:  BNZ   6B22
06A80:  MOVLW  04
06A82:  MOVWF  x42
06A84:  MOVLW  C1
06A86:  MOVWF  x41
06A88:  MOVLB  0
06A8A:  CALL   558E
06A8E:  MOVF   01,W
06A90:  ADDLW  C1
06A92:  MOVLB  7
06A94:  MOVWF  x0D
06A96:  MOVLW  04
06A98:  ADDWFC 02,W
06A9A:  MOVWF  x0E
06A9C:  MOVLW  01
06A9E:  SUBWF  x0B,W
06AA0:  MULLW  28
06AA2:  MOVF   FF3,W
06AA4:  CLRF   x10
06AA6:  MOVWF  x0F
06AA8:  MOVLW  04
06AAA:  ADDWF  x0F,W
06AAC:  MOVWF  01
06AAE:  MOVLW  00
06AB0:  ADDWFC x10,W
06AB2:  MOVWF  03
06AB4:  MOVF   01,W
06AB6:  ADDLW  20
06AB8:  MOVWF  FE9
06ABA:  MOVLW  00
06ABC:  ADDWFC 03,W
06ABE:  MOVWF  FEA
06AC0:  MOVFF  FEF,70F
06AC4:  MOVFF  FEC,710
06AC8:  MOVFF  FEC,711
06ACC:  MOVFF  FEC,712
06AD0:  MOVFF  70E,565
06AD4:  MOVFF  70D,564
06AD8:  MOVFF  70B,734
06ADC:  MOVLW  18
06ADE:  MOVWF  x35
06AE0:  MOVLB  0
06AE2:  CALL   6066
06AE6:  MOVLW  2C
06AE8:  MOVLB  7
06AEA:  MOVWF  x50
06AEC:  MOVLB  0
06AEE:  CALL   55C6
06AF2:  MOVLW  89
06AF4:  MOVWF  FE9
06AF6:  MOVFF  712,746
06AFA:  MOVFF  711,745
06AFE:  MOVFF  710,744
06B02:  MOVFF  70F,743
06B06:  MOVLW  02
06B08:  MOVLB  7
06B0A:  MOVWF  x47
06B0C:  MOVLB  0
06B0E:  CALL   5764
06B12:  MOVLW  2C
06B14:  MOVLB  7
06B16:  MOVWF  x50
06B18:  MOVLB  0
06B1A:  CALL   55C6
06B1E:  BRA    6D30
06B20:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06B22:  MOVF   x0C,W
06B24:  SUBLW  44
06B26:  BNZ   6BCA
06B28:  MOVLW  04
06B2A:  MOVWF  x42
06B2C:  MOVLW  C1
06B2E:  MOVWF  x41
06B30:  MOVLB  0
06B32:  CALL   558E
06B36:  MOVF   01,W
06B38:  ADDLW  C1
06B3A:  MOVLB  7
06B3C:  MOVWF  x0D
06B3E:  MOVLW  04
06B40:  ADDWFC 02,W
06B42:  MOVWF  x0E
06B44:  MOVLW  01
06B46:  SUBWF  x0B,W
06B48:  MULLW  28
06B4A:  MOVF   FF3,W
06B4C:  CLRF   x10
06B4E:  MOVWF  x0F
06B50:  MOVLW  08
06B52:  ADDWF  x0F,W
06B54:  MOVWF  01
06B56:  MOVLW  00
06B58:  ADDWFC x10,W
06B5A:  MOVWF  03
06B5C:  MOVF   01,W
06B5E:  ADDLW  20
06B60:  MOVWF  FE9
06B62:  MOVLW  00
06B64:  ADDWFC 03,W
06B66:  MOVWF  FEA
06B68:  MOVFF  FEF,70F
06B6C:  MOVFF  FEC,710
06B70:  MOVFF  FEC,711
06B74:  MOVFF  FEC,712
06B78:  MOVFF  70E,565
06B7C:  MOVFF  70D,564
06B80:  MOVFF  70B,734
06B84:  MOVLW  18
06B86:  MOVWF  x35
06B88:  MOVLB  0
06B8A:  CALL   6066
06B8E:  MOVLW  2C
06B90:  MOVLB  7
06B92:  MOVWF  x50
06B94:  MOVLB  0
06B96:  CALL   55C6
06B9A:  MOVLW  89
06B9C:  MOVWF  FE9
06B9E:  MOVFF  712,746
06BA2:  MOVFF  711,745
06BA6:  MOVFF  710,744
06BAA:  MOVFF  70F,743
06BAE:  MOVLW  02
06BB0:  MOVLB  7
06BB2:  MOVWF  x47
06BB4:  MOVLB  0
06BB6:  CALL   5764
06BBA:  MOVLW  2C
06BBC:  MOVLB  7
06BBE:  MOVWF  x50
06BC0:  MOVLB  0
06BC2:  CALL   55C6
06BC6:  BRA    6D30
06BC8:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06BCA:  MOVF   x0C,W
06BCC:  SUBLW  41
06BCE:  BTFSS  FD8.2
06BD0:  BRA    6D28
06BD2:  MOVLW  04
06BD4:  MOVWF  x42
06BD6:  MOVLW  C1
06BD8:  MOVWF  x41
06BDA:  MOVLB  0
06BDC:  CALL   558E
06BE0:  MOVF   01,W
06BE2:  ADDLW  C1
06BE4:  MOVLB  7
06BE6:  MOVWF  x0D
06BE8:  MOVLW  04
06BEA:  ADDWFC 02,W
06BEC:  MOVWF  x0E
06BEE:  MOVLW  01
06BF0:  SUBWF  x0B,W
06BF2:  MULLW  28
06BF4:  MOVF   FF3,W
06BF6:  CLRF   x10
06BF8:  MOVWF  x0F
06BFA:  MOVLW  20
06BFC:  ADDWF  x0F,W
06BFE:  MOVWF  FE9
06C00:  MOVLW  00
06C02:  ADDWFC x10,W
06C04:  MOVWF  FEA
06C06:  MOVFF  FEF,711
06C0A:  MOVFF  FEC,712
06C0E:  MOVFF  FEC,713
06C12:  MOVFF  FEC,714
06C16:  MOVLW  01
06C18:  SUBWF  x0B,W
06C1A:  MULLW  28
06C1C:  MOVF   FF3,W
06C1E:  CLRF   x16
06C20:  MOVWF  x15
06C22:  MOVLW  04
06C24:  ADDWF  x15,W
06C26:  MOVWF  01
06C28:  MOVLW  00
06C2A:  ADDWFC x16,W
06C2C:  MOVWF  03
06C2E:  MOVF   01,W
06C30:  ADDLW  20
06C32:  MOVWF  FE9
06C34:  MOVLW  00
06C36:  ADDWFC 03,W
06C38:  MOVWF  FEA
06C3A:  MOVFF  FEF,715
06C3E:  MOVFF  FEC,716
06C42:  MOVFF  FEC,717
06C46:  MOVFF  FEC,718
06C4A:  MOVLW  01
06C4C:  SUBWF  x0B,W
06C4E:  MULLW  28
06C50:  MOVF   FF3,W
06C52:  CLRF   x1A
06C54:  MOVWF  x19
06C56:  MOVLW  08
06C58:  ADDWF  x19,W
06C5A:  MOVWF  01
06C5C:  MOVLW  00
06C5E:  ADDWFC x1A,W
06C60:  MOVWF  03
06C62:  MOVF   01,W
06C64:  ADDLW  20
06C66:  MOVWF  FE9
06C68:  MOVLW  00
06C6A:  ADDWFC 03,W
06C6C:  MOVWF  FEA
06C6E:  MOVFF  FEF,719
06C72:  MOVFF  FEC,71A
06C76:  MOVFF  FEC,71B
06C7A:  MOVFF  FEC,71C
06C7E:  MOVFF  70E,565
06C82:  MOVFF  70D,564
06C86:  MOVFF  70B,734
06C8A:  MOVLW  18
06C8C:  MOVWF  x35
06C8E:  MOVLB  0
06C90:  CALL   6066
06C94:  MOVLW  2C
06C96:  MOVLB  7
06C98:  MOVWF  x50
06C9A:  MOVLB  0
06C9C:  CALL   55C6
06CA0:  MOVLW  89
06CA2:  MOVWF  FE9
06CA4:  MOVFF  714,746
06CA8:  MOVFF  713,745
06CAC:  MOVFF  712,744
06CB0:  MOVFF  711,743
06CB4:  MOVLW  02
06CB6:  MOVLB  7
06CB8:  MOVWF  x47
06CBA:  MOVLB  0
06CBC:  CALL   5764
06CC0:  MOVLW  2C
06CC2:  MOVLB  7
06CC4:  MOVWF  x50
06CC6:  MOVLB  0
06CC8:  CALL   55C6
06CCC:  MOVLW  89
06CCE:  MOVWF  FE9
06CD0:  MOVFF  718,746
06CD4:  MOVFF  717,745
06CD8:  MOVFF  716,744
06CDC:  MOVFF  715,743
06CE0:  MOVLW  02
06CE2:  MOVLB  7
06CE4:  MOVWF  x47
06CE6:  MOVLB  0
06CE8:  CALL   5764
06CEC:  MOVLW  2C
06CEE:  MOVLB  7
06CF0:  MOVWF  x50
06CF2:  MOVLB  0
06CF4:  CALL   55C6
06CF8:  MOVLW  89
06CFA:  MOVWF  FE9
06CFC:  MOVFF  71C,746
06D00:  MOVFF  71B,745
06D04:  MOVFF  71A,744
06D08:  MOVFF  719,743
06D0C:  MOVLW  02
06D0E:  MOVLB  7
06D10:  MOVWF  x47
06D12:  MOVLB  0
06D14:  CALL   5764
06D18:  MOVLW  2C
06D1A:  MOVLB  7
06D1C:  MOVWF  x50
06D1E:  MOVLB  0
06D20:  CALL   55C6
06D24:  BRA    6D30
06D26:  MOVLB  7
....................    else return INV_PARAM;
06D28:  MOVLW  02
06D2A:  MOVWF  01
06D2C:  MOVLB  0
06D2E:  BRA    6D34
....................    
....................    return SUCCESS;
06D30:  MOVLW  00
06D32:  MOVWF  01
06D34:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
07052:  MOVLB  7
07054:  CLRF   x42
07056:  MOVFF  690,741
0705A:  CLRF   x44
0705C:  MOVLW  B5
0705E:  MOVWF  x43
07060:  MOVLB  0
07062:  CALL   08AC
07066:  MOVFF  02,712
0706A:  MOVFF  01,711
0706E:  MOVLW  06
07070:  MOVLB  7
07072:  ADDWF  x11,F
07074:  MOVLW  00
07076:  ADDWFC x12,F
07078:  MOVLW  32
0707A:  ADDWF  x11,W
0707C:  MOVWF  01
0707E:  MOVLW  00
07080:  ADDWFC x12,W
07082:  MOVWF  03
07084:  MOVF   01,W
07086:  ADDLW  EB
07088:  MOVWF  01
0708A:  MOVLW  01
0708C:  ADDWFC 03,F
0708E:  MOVFF  01,711
07092:  MOVFF  03,712
07096:  MOVFF  03,734
0709A:  MOVFF  01,733
0709E:  MOVLB  0
070A0:  CALL   5C22
070A4:  MOVF   01,F
070A6:  BNZ   70B0
070A8:  MOVLW  02
070AA:  MOVWF  01
070AC:  BRA    7330
070AE:  BRA    710E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
070B0:  MOVLB  7
070B2:  CLRF   x42
070B4:  MOVFF  690,741
070B8:  CLRF   x44
070BA:  MOVLW  B5
070BC:  MOVWF  x43
070BE:  MOVLB  0
070C0:  CALL   08AC
070C4:  MOVFF  02,712
070C8:  MOVFF  01,711
070CC:  MOVLW  06
070CE:  MOVLB  7
070D0:  ADDWF  x11,F
070D2:  MOVLW  00
070D4:  ADDWFC x12,F
070D6:  MOVLW  32
070D8:  ADDWF  x11,W
070DA:  MOVWF  01
070DC:  MOVLW  00
070DE:  ADDWFC x12,W
070E0:  MOVWF  03
070E2:  MOVF   01,W
070E4:  ADDLW  EB
070E6:  MOVWF  01
070E8:  MOVLW  01
070EA:  ADDWFC 03,F
070EC:  MOVFF  01,711
070F0:  MOVFF  03,712
070F4:  MOVFF  03,734
070F8:  MOVFF  01,733
070FC:  CLRF   x36
070FE:  CLRF   x35
07100:  MOVLW  0A
07102:  MOVWF  x37
07104:  MOVLB  0
07106:  CALL   5D12
0710A:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0710E:  MOVLB  7
07110:  CLRF   x42
07112:  MOVFF  690,741
07116:  CLRF   x44
07118:  MOVLW  B5
0711A:  MOVWF  x43
0711C:  MOVLB  0
0711E:  CALL   08AC
07122:  MOVFF  02,712
07126:  MOVFF  01,711
0712A:  MOVLW  06
0712C:  MOVLB  7
0712E:  ADDWF  x11,F
07130:  MOVLW  00
07132:  ADDWFC x12,F
07134:  MOVLW  4B
07136:  ADDWF  x11,W
07138:  MOVWF  01
0713A:  MOVLW  00
0713C:  ADDWFC x12,W
0713E:  MOVWF  03
07140:  MOVF   01,W
07142:  ADDLW  EB
07144:  MOVWF  01
07146:  MOVLW  01
07148:  ADDWFC 03,F
0714A:  MOVFF  01,711
0714E:  MOVFF  03,712
07152:  MOVFF  03,742
07156:  MOVFF  01,741
0715A:  MOVLB  0
0715C:  CALL   558E
07160:  MOVFF  02,03
07164:  MOVF   01,W
07166:  SUBLW  01
07168:  BNZ   716E
0716A:  MOVF   03,F
0716C:  BZ    7176
0716E:  MOVLW  02
07170:  MOVWF  01
07172:  BRA    7330
07174:  BRA    71B6
....................    else arg2 = SERcmd[rec].p[3][0];
07176:  MOVLB  7
07178:  CLRF   x42
0717A:  MOVFF  690,741
0717E:  CLRF   x44
07180:  MOVLW  B5
07182:  MOVWF  x43
07184:  MOVLB  0
07186:  CALL   08AC
0718A:  MOVFF  02,712
0718E:  MOVFF  01,711
07192:  MOVLW  06
07194:  MOVLB  7
07196:  ADDWF  x11,F
07198:  MOVLW  00
0719A:  ADDWFC x12,F
0719C:  MOVLW  4B
0719E:  ADDWF  x11,F
071A0:  MOVLW  00
071A2:  ADDWFC x12,F
071A4:  MOVLW  EB
071A6:  ADDWF  x11,W
071A8:  MOVWF  FE9
071AA:  MOVLW  01
071AC:  ADDWFC x12,W
071AE:  MOVWF  FEA
071B0:  MOVFF  FEF,70C
071B4:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
071B6:  MOVLB  7
071B8:  CLRF   x42
071BA:  MOVFF  690,741
071BE:  CLRF   x44
071C0:  MOVLW  B5
071C2:  MOVWF  x43
071C4:  MOVLB  0
071C6:  CALL   08AC
071CA:  MOVFF  02,712
071CE:  MOVFF  01,711
071D2:  MOVLW  06
071D4:  MOVLB  7
071D6:  ADDWF  x11,F
071D8:  MOVLW  00
071DA:  ADDWFC x12,F
071DC:  MOVLW  64
071DE:  ADDWF  x11,W
071E0:  MOVWF  01
071E2:  MOVLW  00
071E4:  ADDWFC x12,W
071E6:  MOVWF  03
071E8:  MOVF   01,W
071EA:  ADDLW  EB
071EC:  MOVWF  01
071EE:  MOVLW  01
071F0:  ADDWFC 03,F
071F2:  MOVFF  01,711
071F6:  MOVFF  03,712
071FA:  MOVFF  03,715
071FE:  MOVFF  01,714
07202:  MOVLB  0
07204:  RCALL  6D36
07206:  MOVF   01,F
07208:  BNZ   7212
0720A:  MOVLW  02
0720C:  MOVWF  01
0720E:  BRA    7330
07210:  BRA    7276
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07212:  MOVLB  7
07214:  CLRF   x42
07216:  MOVFF  690,741
0721A:  CLRF   x44
0721C:  MOVLW  B5
0721E:  MOVWF  x43
07220:  MOVLB  0
07222:  CALL   08AC
07226:  MOVFF  02,712
0722A:  MOVFF  01,711
0722E:  MOVLW  06
07230:  MOVLB  7
07232:  ADDWF  x11,F
07234:  MOVLW  00
07236:  ADDWFC x12,F
07238:  MOVLW  64
0723A:  ADDWF  x11,W
0723C:  MOVWF  01
0723E:  MOVLW  00
07240:  ADDWFC x12,W
07242:  MOVWF  03
07244:  MOVF   01,W
07246:  ADDLW  EB
07248:  MOVWF  01
0724A:  MOVLW  01
0724C:  ADDWFC 03,F
0724E:  MOVFF  01,711
07252:  MOVFF  03,712
07256:  MOVFF  03,715
0725A:  MOVFF  01,714
0725E:  CLRF   x17
07260:  CLRF   x16
07262:  MOVLB  0
07264:  RCALL  6DF8
07266:  MOVFF  03,710
0726A:  MOVFF  02,70F
0726E:  MOVFF  01,70E
07272:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07276:  MOVLB  7
07278:  MOVF   x0C,W
0727A:  SUBLW  50
0727C:  BNZ   72A8
0727E:  MOVLW  01
07280:  SUBWF  x0B,W
07282:  MULLW  28
07284:  MOVF   FF3,W
07286:  CLRF   x12
07288:  MOVWF  x11
0728A:  MOVLW  20
0728C:  ADDWF  x11,W
0728E:  MOVWF  FE9
07290:  MOVLW  00
07292:  ADDWFC x12,W
07294:  MOVWF  FEA
07296:  MOVFF  70D,FEF
0729A:  MOVFF  70E,FEC
0729E:  MOVFF  70F,FEC
072A2:  MOVFF  710,FEC
072A6:  BRA    732A
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
072A8:  MOVF   x0C,W
072AA:  SUBLW  49
072AC:  BNZ   72E4
072AE:  MOVLW  01
072B0:  SUBWF  x0B,W
072B2:  MULLW  28
072B4:  MOVF   FF3,W
072B6:  CLRF   x12
072B8:  MOVWF  x11
072BA:  MOVLW  04
072BC:  ADDWF  x11,W
072BE:  MOVWF  01
072C0:  MOVLW  00
072C2:  ADDWFC x12,W
072C4:  MOVWF  03
072C6:  MOVF   01,W
072C8:  ADDLW  20
072CA:  MOVWF  FE9
072CC:  MOVLW  00
072CE:  ADDWFC 03,W
072D0:  MOVWF  FEA
072D2:  MOVFF  70D,FEF
072D6:  MOVFF  70E,FEC
072DA:  MOVFF  70F,FEC
072DE:  MOVFF  710,FEC
072E2:  BRA    732A
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
072E4:  MOVF   x0C,W
072E6:  SUBLW  44
072E8:  BNZ   7320
072EA:  MOVLW  01
072EC:  SUBWF  x0B,W
072EE:  MULLW  28
072F0:  MOVF   FF3,W
072F2:  CLRF   x12
072F4:  MOVWF  x11
072F6:  MOVLW  08
072F8:  ADDWF  x11,W
072FA:  MOVWF  01
072FC:  MOVLW  00
072FE:  ADDWFC x12,W
07300:  MOVWF  03
07302:  MOVF   01,W
07304:  ADDLW  20
07306:  MOVWF  FE9
07308:  MOVLW  00
0730A:  ADDWFC 03,W
0730C:  MOVWF  FEA
0730E:  MOVFF  70D,FEF
07312:  MOVFF  70E,FEC
07316:  MOVFF  70F,FEC
0731A:  MOVFF  710,FEC
0731E:  BRA    732A
....................    else return INV_PARAM;
07320:  MOVLW  02
07322:  MOVWF  01
07324:  MOVLB  0
07326:  BRA    7330
07328:  MOVLB  7
....................    
....................    return SUCCESS;
0732A:  MOVLW  00
0732C:  MOVWF  01
0732E:  MOVLB  0
07330:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07332:  MOVLB  7
07334:  CLRF   x42
07336:  MOVFF  690,741
0733A:  CLRF   x44
0733C:  MOVLW  B5
0733E:  MOVWF  x43
07340:  MOVLB  0
07342:  CALL   08AC
07346:  MOVFF  02,70D
0734A:  MOVFF  01,70C
0734E:  MOVLW  06
07350:  MOVLB  7
07352:  ADDWF  x0C,F
07354:  MOVLW  00
07356:  ADDWFC x0D,F
07358:  MOVLW  32
0735A:  ADDWF  x0C,W
0735C:  MOVWF  01
0735E:  MOVLW  00
07360:  ADDWFC x0D,W
07362:  MOVWF  03
07364:  MOVF   01,W
07366:  ADDLW  EB
07368:  MOVWF  01
0736A:  MOVLW  01
0736C:  ADDWFC 03,F
0736E:  MOVFF  01,70C
07372:  MOVFF  03,70D
07376:  MOVFF  03,734
0737A:  MOVFF  01,733
0737E:  MOVLB  0
07380:  CALL   5C22
07384:  MOVF   01,F
07386:  BNZ   7390
07388:  MOVLW  02
0738A:  MOVWF  01
0738C:  BRA    7492
0738E:  BRA    73EE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07390:  MOVLB  7
07392:  CLRF   x42
07394:  MOVFF  690,741
07398:  CLRF   x44
0739A:  MOVLW  B5
0739C:  MOVWF  x43
0739E:  MOVLB  0
073A0:  CALL   08AC
073A4:  MOVFF  02,70D
073A8:  MOVFF  01,70C
073AC:  MOVLW  06
073AE:  MOVLB  7
073B0:  ADDWF  x0C,F
073B2:  MOVLW  00
073B4:  ADDWFC x0D,F
073B6:  MOVLW  32
073B8:  ADDWF  x0C,W
073BA:  MOVWF  01
073BC:  MOVLW  00
073BE:  ADDWFC x0D,W
073C0:  MOVWF  03
073C2:  MOVF   01,W
073C4:  ADDLW  EB
073C6:  MOVWF  01
073C8:  MOVLW  01
073CA:  ADDWFC 03,F
073CC:  MOVFF  01,70C
073D0:  MOVFF  03,70D
073D4:  MOVFF  03,734
073D8:  MOVFF  01,733
073DC:  CLRF   x36
073DE:  CLRF   x35
073E0:  MOVLW  0A
073E2:  MOVWF  x37
073E4:  MOVLB  0
073E6:  CALL   5D12
073EA:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
073EE:  MOVLW  04
073F0:  MOVLB  7
073F2:  MOVWF  x42
073F4:  MOVLW  C1
073F6:  MOVWF  x41
073F8:  MOVLB  0
073FA:  CALL   558E
073FE:  MOVF   01,W
07400:  ADDLW  C1
07402:  MOVLB  7
07404:  MOVWF  x0C
07406:  MOVLW  04
07408:  ADDWFC 02,W
0740A:  MOVWF  x0D
0740C:  MOVLW  01
0740E:  SUBWF  x0B,W
07410:  MULLW  28
07412:  MOVF   FF3,W
07414:  CLRF   x0F
07416:  MOVWF  x0E
07418:  MOVLW  0C
0741A:  ADDWF  x0E,W
0741C:  MOVWF  01
0741E:  MOVLW  00
07420:  ADDWFC x0F,W
07422:  MOVWF  03
07424:  MOVF   01,W
07426:  ADDLW  20
07428:  MOVWF  FE9
0742A:  MOVLW  00
0742C:  ADDWFC 03,W
0742E:  MOVWF  FEA
07430:  MOVFF  FEF,70E
07434:  MOVFF  FEC,70F
07438:  MOVFF  FEC,710
0743C:  MOVFF  FEC,711
07440:  MOVFF  70D,565
07444:  MOVFF  70C,564
07448:  MOVFF  70B,734
0744C:  MOVLW  18
0744E:  MOVWF  x35
07450:  MOVLB  0
07452:  CALL   6066
07456:  MOVLW  2C
07458:  MOVLB  7
0745A:  MOVWF  x50
0745C:  MOVLB  0
0745E:  CALL   55C6
07462:  MOVLW  89
07464:  MOVWF  FE9
07466:  MOVFF  711,746
0746A:  MOVFF  710,745
0746E:  MOVFF  70F,744
07472:  MOVFF  70E,743
07476:  MOVLW  02
07478:  MOVLB  7
0747A:  MOVWF  x47
0747C:  MOVLB  0
0747E:  CALL   5764
07482:  MOVLW  2C
07484:  MOVLB  7
07486:  MOVWF  x50
07488:  MOVLB  0
0748A:  CALL   55C6
....................    return SUCCESS;
0748E:  MOVLW  00
07490:  MOVWF  01
07492:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07494:  MOVLB  7
07496:  CLRF   x42
07498:  MOVFF  690,741
0749C:  CLRF   x44
0749E:  MOVLW  B5
074A0:  MOVWF  x43
074A2:  MOVLB  0
074A4:  CALL   08AC
074A8:  MOVFF  02,711
074AC:  MOVFF  01,710
074B0:  MOVLW  06
074B2:  MOVLB  7
074B4:  ADDWF  x10,F
074B6:  MOVLW  00
074B8:  ADDWFC x11,F
074BA:  MOVLW  32
074BC:  ADDWF  x10,W
074BE:  MOVWF  01
074C0:  MOVLW  00
074C2:  ADDWFC x11,W
074C4:  MOVWF  03
074C6:  MOVF   01,W
074C8:  ADDLW  EB
074CA:  MOVWF  01
074CC:  MOVLW  01
074CE:  ADDWFC 03,F
074D0:  MOVFF  01,710
074D4:  MOVFF  03,711
074D8:  MOVFF  03,734
074DC:  MOVFF  01,733
074E0:  MOVLB  0
074E2:  CALL   5C22
074E6:  MOVF   01,F
074E8:  BNZ   74F2
074EA:  MOVLW  02
074EC:  MOVWF  01
074EE:  BRA    7650
074F0:  BRA    7550
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
074F2:  MOVLB  7
074F4:  CLRF   x42
074F6:  MOVFF  690,741
074FA:  CLRF   x44
074FC:  MOVLW  B5
074FE:  MOVWF  x43
07500:  MOVLB  0
07502:  CALL   08AC
07506:  MOVFF  02,711
0750A:  MOVFF  01,710
0750E:  MOVLW  06
07510:  MOVLB  7
07512:  ADDWF  x10,F
07514:  MOVLW  00
07516:  ADDWFC x11,F
07518:  MOVLW  32
0751A:  ADDWF  x10,W
0751C:  MOVWF  01
0751E:  MOVLW  00
07520:  ADDWFC x11,W
07522:  MOVWF  03
07524:  MOVF   01,W
07526:  ADDLW  EB
07528:  MOVWF  01
0752A:  MOVLW  01
0752C:  ADDWFC 03,F
0752E:  MOVFF  01,710
07532:  MOVFF  03,711
07536:  MOVFF  03,734
0753A:  MOVFF  01,733
0753E:  CLRF   x36
07540:  CLRF   x35
07542:  MOVLW  0A
07544:  MOVWF  x37
07546:  MOVLB  0
07548:  CALL   5D12
0754C:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07550:  MOVLB  7
07552:  CLRF   x42
07554:  MOVFF  690,741
07558:  CLRF   x44
0755A:  MOVLW  B5
0755C:  MOVWF  x43
0755E:  MOVLB  0
07560:  CALL   08AC
07564:  MOVFF  02,711
07568:  MOVFF  01,710
0756C:  MOVLW  06
0756E:  MOVLB  7
07570:  ADDWF  x10,F
07572:  MOVLW  00
07574:  ADDWFC x11,F
07576:  MOVLW  4B
07578:  ADDWF  x10,W
0757A:  MOVWF  01
0757C:  MOVLW  00
0757E:  ADDWFC x11,W
07580:  MOVWF  03
07582:  MOVF   01,W
07584:  ADDLW  EB
07586:  MOVWF  01
07588:  MOVLW  01
0758A:  ADDWFC 03,F
0758C:  MOVFF  01,710
07590:  MOVFF  03,711
07594:  MOVFF  03,715
07598:  MOVFF  01,714
0759C:  MOVLB  0
0759E:  CALL   6D36
075A2:  MOVF   01,F
075A4:  BNZ   75AE
075A6:  MOVLW  02
075A8:  MOVWF  01
075AA:  BRA    7650
075AC:  BRA    7614
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
075AE:  MOVLB  7
075B0:  CLRF   x42
075B2:  MOVFF  690,741
075B6:  CLRF   x44
075B8:  MOVLW  B5
075BA:  MOVWF  x43
075BC:  MOVLB  0
075BE:  CALL   08AC
075C2:  MOVFF  02,711
075C6:  MOVFF  01,710
075CA:  MOVLW  06
075CC:  MOVLB  7
075CE:  ADDWF  x10,F
075D0:  MOVLW  00
075D2:  ADDWFC x11,F
075D4:  MOVLW  4B
075D6:  ADDWF  x10,W
075D8:  MOVWF  01
075DA:  MOVLW  00
075DC:  ADDWFC x11,W
075DE:  MOVWF  03
075E0:  MOVF   01,W
075E2:  ADDLW  EB
075E4:  MOVWF  01
075E6:  MOVLW  01
075E8:  ADDWFC 03,F
075EA:  MOVFF  01,710
075EE:  MOVFF  03,711
075F2:  MOVFF  03,715
075F6:  MOVFF  01,714
075FA:  CLRF   x17
075FC:  CLRF   x16
075FE:  MOVLB  0
07600:  CALL   6DF8
07604:  MOVFF  03,70F
07608:  MOVFF  02,70E
0760C:  MOVFF  01,70D
07610:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07614:  MOVLW  01
07616:  MOVLB  7
07618:  SUBWF  x0B,W
0761A:  MULLW  28
0761C:  MOVF   FF3,W
0761E:  CLRF   x11
07620:  MOVWF  x10
07622:  MOVLW  0C
07624:  ADDWF  x10,W
07626:  MOVWF  01
07628:  MOVLW  00
0762A:  ADDWFC x11,W
0762C:  MOVWF  03
0762E:  MOVF   01,W
07630:  ADDLW  20
07632:  MOVWF  FE9
07634:  MOVLW  00
07636:  ADDWFC 03,W
07638:  MOVWF  FEA
0763A:  MOVFF  70C,FEF
0763E:  MOVFF  70D,FEC
07642:  MOVFF  70E,FEC
07646:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
0764A:  MOVLW  00
0764C:  MOVWF  01
0764E:  MOVLB  0
07650:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07652:  MOVLB  7
07654:  CLRF   x42
07656:  MOVFF  690,741
0765A:  CLRF   x44
0765C:  MOVLW  B5
0765E:  MOVWF  x43
07660:  MOVLB  0
07662:  CALL   08AC
07666:  MOVFF  02,70D
0766A:  MOVFF  01,70C
0766E:  MOVLW  06
07670:  MOVLB  7
07672:  ADDWF  x0C,F
07674:  MOVLW  00
07676:  ADDWFC x0D,F
07678:  MOVLW  32
0767A:  ADDWF  x0C,W
0767C:  MOVWF  01
0767E:  MOVLW  00
07680:  ADDWFC x0D,W
07682:  MOVWF  03
07684:  MOVF   01,W
07686:  ADDLW  EB
07688:  MOVWF  01
0768A:  MOVLW  01
0768C:  ADDWFC 03,F
0768E:  MOVFF  01,70C
07692:  MOVFF  03,70D
07696:  MOVFF  03,734
0769A:  MOVFF  01,733
0769E:  MOVLB  0
076A0:  CALL   5C22
076A4:  MOVF   01,F
076A6:  BNZ   76B0
076A8:  MOVLW  02
076AA:  MOVWF  01
076AC:  BRA    7A06
076AE:  BRA    770E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
076B0:  MOVLB  7
076B2:  CLRF   x42
076B4:  MOVFF  690,741
076B8:  CLRF   x44
076BA:  MOVLW  B5
076BC:  MOVWF  x43
076BE:  MOVLB  0
076C0:  CALL   08AC
076C4:  MOVFF  02,70D
076C8:  MOVFF  01,70C
076CC:  MOVLW  06
076CE:  MOVLB  7
076D0:  ADDWF  x0C,F
076D2:  MOVLW  00
076D4:  ADDWFC x0D,F
076D6:  MOVLW  32
076D8:  ADDWF  x0C,W
076DA:  MOVWF  01
076DC:  MOVLW  00
076DE:  ADDWFC x0D,W
076E0:  MOVWF  03
076E2:  MOVF   01,W
076E4:  ADDLW  EB
076E6:  MOVWF  01
076E8:  MOVLW  01
076EA:  ADDWFC 03,F
076EC:  MOVFF  01,70C
076F0:  MOVFF  03,70D
076F4:  MOVFF  03,734
076F8:  MOVFF  01,733
076FC:  CLRF   x36
076FE:  CLRF   x35
07700:  MOVLW  0A
07702:  MOVWF  x37
07704:  MOVLB  0
07706:  CALL   5D12
0770A:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
0770E:  MOVLW  04
07710:  MOVLB  7
07712:  MOVWF  x42
07714:  MOVLW  C1
07716:  MOVWF  x41
07718:  MOVLB  0
0771A:  CALL   558E
0771E:  MOVFF  02,03
07722:  MOVF   01,W
07724:  ADDLW  C1
07726:  MOVLB  7
07728:  MOVWF  x0C
0772A:  MOVLW  04
0772C:  ADDWFC 02,W
0772E:  MOVWF  x0D
07730:  MOVFF  FE8,565
07734:  MOVFF  70C,564
07738:  MOVFF  70B,734
0773C:  MOVLW  18
0773E:  MOVWF  x35
07740:  MOVLB  0
07742:  CALL   6066
07746:  MOVLW  2C
07748:  MOVLB  7
0774A:  MOVWF  x50
0774C:  MOVLB  0
0774E:  CALL   55C6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07752:  MOVLW  04
07754:  MOVLB  7
07756:  MOVWF  x42
07758:  MOVLW  C1
0775A:  MOVWF  x41
0775C:  MOVLB  0
0775E:  CALL   558E
07762:  MOVFF  02,03
07766:  MOVF   01,W
07768:  ADDLW  C1
0776A:  MOVLB  7
0776C:  MOVWF  x0C
0776E:  MOVLW  04
07770:  ADDWFC 02,W
07772:  MOVWF  x0D
07774:  MOVLW  01
07776:  SUBWF  x0B,W
07778:  MULLW  18
0777A:  MOVF   FF3,W
0777C:  CLRF   x0F
0777E:  MOVWF  x0E
07780:  MOVLW  92
07782:  ADDWF  x0E,W
07784:  MOVWF  FE9
07786:  MOVLW  00
07788:  ADDWFC x0F,W
0778A:  MOVWF  FEA
0778C:  MOVFF  FEF,743
07790:  MOVFF  FEC,744
07794:  MOVFF  FEC,745
07798:  MOVFF  FEC,746
0779C:  MOVFF  70D,565
077A0:  MOVFF  70C,564
077A4:  MOVLW  89
077A6:  MOVWF  FE9
077A8:  MOVLW  02
077AA:  MOVWF  x47
077AC:  MOVLB  0
077AE:  CALL   5764
077B2:  MOVLW  2C
077B4:  MOVLB  7
077B6:  MOVWF  x50
077B8:  MOVLB  0
077BA:  CALL   55C6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
077BE:  MOVLW  04
077C0:  MOVLB  7
077C2:  MOVWF  x42
077C4:  MOVLW  C1
077C6:  MOVWF  x41
077C8:  MOVLB  0
077CA:  CALL   558E
077CE:  MOVF   01,W
077D0:  ADDLW  C1
077D2:  MOVLB  7
077D4:  MOVWF  x0C
077D6:  MOVLW  04
077D8:  ADDWFC 02,W
077DA:  MOVWF  x0D
077DC:  MOVLW  01
077DE:  SUBWF  x0B,W
077E0:  MULLW  18
077E2:  MOVF   FF3,W
077E4:  CLRF   x0F
077E6:  MOVWF  x0E
077E8:  MOVLW  04
077EA:  ADDWF  x0E,W
077EC:  MOVWF  01
077EE:  MOVLW  00
077F0:  ADDWFC x0F,W
077F2:  MOVWF  03
077F4:  MOVF   01,W
077F6:  ADDLW  92
077F8:  MOVWF  FE9
077FA:  MOVLW  00
077FC:  ADDWFC 03,W
077FE:  MOVWF  FEA
07800:  MOVFF  FEF,743
07804:  MOVFF  FEC,744
07808:  MOVFF  FEC,745
0780C:  MOVFF  FEC,746
07810:  MOVFF  70D,565
07814:  MOVFF  70C,564
07818:  MOVLW  89
0781A:  MOVWF  FE9
0781C:  MOVLW  02
0781E:  MOVWF  x47
07820:  MOVLB  0
07822:  CALL   5764
07826:  MOVLW  2C
07828:  MOVLB  7
0782A:  MOVWF  x50
0782C:  MOVLB  0
0782E:  CALL   55C6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07832:  MOVLW  04
07834:  MOVLB  7
07836:  MOVWF  x42
07838:  MOVLW  C1
0783A:  MOVWF  x41
0783C:  MOVLB  0
0783E:  CALL   558E
07842:  MOVF   01,W
07844:  ADDLW  C1
07846:  MOVLB  7
07848:  MOVWF  x0C
0784A:  MOVLW  04
0784C:  ADDWFC 02,W
0784E:  MOVWF  x0D
07850:  MOVLW  01
07852:  SUBWF  x0B,W
07854:  MULLW  18
07856:  MOVF   FF3,W
07858:  CLRF   x0F
0785A:  MOVWF  x0E
0785C:  MOVLW  08
0785E:  ADDWF  x0E,W
07860:  MOVWF  01
07862:  MOVLW  00
07864:  ADDWFC x0F,W
07866:  MOVWF  03
07868:  MOVF   01,W
0786A:  ADDLW  92
0786C:  MOVWF  FE9
0786E:  MOVLW  00
07870:  ADDWFC 03,W
07872:  MOVWF  FEA
07874:  MOVFF  FEF,743
07878:  MOVFF  FEC,744
0787C:  MOVFF  FEC,745
07880:  MOVFF  FEC,746
07884:  MOVFF  70D,565
07888:  MOVFF  70C,564
0788C:  MOVLW  89
0788E:  MOVWF  FE9
07890:  MOVLW  02
07892:  MOVWF  x47
07894:  MOVLB  0
07896:  CALL   5764
0789A:  MOVLW  2C
0789C:  MOVLB  7
0789E:  MOVWF  x50
078A0:  MOVLB  0
078A2:  CALL   55C6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
078A6:  MOVLW  04
078A8:  MOVLB  7
078AA:  MOVWF  x42
078AC:  MOVLW  C1
078AE:  MOVWF  x41
078B0:  MOVLB  0
078B2:  CALL   558E
078B6:  MOVF   01,W
078B8:  ADDLW  C1
078BA:  MOVLB  7
078BC:  MOVWF  x0C
078BE:  MOVLW  04
078C0:  ADDWFC 02,W
078C2:  MOVWF  x0D
078C4:  MOVLW  01
078C6:  SUBWF  x0B,W
078C8:  MULLW  18
078CA:  MOVF   FF3,W
078CC:  CLRF   x0F
078CE:  MOVWF  x0E
078D0:  MOVLW  0C
078D2:  ADDWF  x0E,W
078D4:  MOVWF  01
078D6:  MOVLW  00
078D8:  ADDWFC x0F,W
078DA:  MOVWF  03
078DC:  MOVF   01,W
078DE:  ADDLW  92
078E0:  MOVWF  FE9
078E2:  MOVLW  00
078E4:  ADDWFC 03,W
078E6:  MOVWF  FEA
078E8:  MOVFF  FEF,743
078EC:  MOVFF  FEC,744
078F0:  MOVFF  FEC,745
078F4:  MOVFF  FEC,746
078F8:  MOVFF  70D,565
078FC:  MOVFF  70C,564
07900:  MOVLW  89
07902:  MOVWF  FE9
07904:  MOVLW  02
07906:  MOVWF  x47
07908:  MOVLB  0
0790A:  CALL   5764
0790E:  MOVLW  2C
07910:  MOVLB  7
07912:  MOVWF  x50
07914:  MOVLB  0
07916:  CALL   55C6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
0791A:  MOVLW  04
0791C:  MOVLB  7
0791E:  MOVWF  x42
07920:  MOVLW  C1
07922:  MOVWF  x41
07924:  MOVLB  0
07926:  CALL   558E
0792A:  MOVF   01,W
0792C:  ADDLW  C1
0792E:  MOVLB  7
07930:  MOVWF  x0C
07932:  MOVLW  04
07934:  ADDWFC 02,W
07936:  MOVWF  x0D
07938:  MOVLW  01
0793A:  SUBWF  x0B,W
0793C:  MULLW  18
0793E:  MOVF   FF3,W
07940:  CLRF   x0F
07942:  MOVWF  x0E
07944:  MOVLW  10
07946:  ADDWF  x0E,W
07948:  MOVWF  01
0794A:  MOVLW  00
0794C:  ADDWFC x0F,W
0794E:  MOVWF  03
07950:  MOVF   01,W
07952:  ADDLW  92
07954:  MOVWF  FE9
07956:  MOVLW  00
07958:  ADDWFC 03,W
0795A:  MOVWF  FEA
0795C:  MOVFF  FEF,743
07960:  MOVFF  FEC,744
07964:  MOVFF  FEC,745
07968:  MOVFF  FEC,746
0796C:  MOVFF  70D,565
07970:  MOVFF  70C,564
07974:  MOVLW  89
07976:  MOVWF  FE9
07978:  MOVLW  02
0797A:  MOVWF  x47
0797C:  MOVLB  0
0797E:  CALL   5764
07982:  MOVLW  2C
07984:  MOVLB  7
07986:  MOVWF  x50
07988:  MOVLB  0
0798A:  CALL   55C6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
0798E:  MOVLW  04
07990:  MOVLB  7
07992:  MOVWF  x42
07994:  MOVLW  C1
07996:  MOVWF  x41
07998:  MOVLB  0
0799A:  CALL   558E
0799E:  MOVF   01,W
079A0:  ADDLW  C1
079A2:  MOVLB  7
079A4:  MOVWF  x0C
079A6:  MOVLW  04
079A8:  ADDWFC 02,W
079AA:  MOVWF  x0D
079AC:  MOVLW  01
079AE:  SUBWF  x0B,W
079B0:  MULLW  18
079B2:  MOVF   FF3,W
079B4:  CLRF   x0F
079B6:  MOVWF  x0E
079B8:  MOVLW  14
079BA:  ADDWF  x0E,W
079BC:  MOVWF  01
079BE:  MOVLW  00
079C0:  ADDWFC x0F,W
079C2:  MOVWF  03
079C4:  MOVF   01,W
079C6:  ADDLW  92
079C8:  MOVWF  FE9
079CA:  MOVLW  00
079CC:  ADDWFC 03,W
079CE:  MOVWF  FEA
079D0:  MOVFF  FEF,743
079D4:  MOVFF  FEC,744
079D8:  MOVFF  FEC,745
079DC:  MOVFF  FEC,746
079E0:  MOVFF  70D,565
079E4:  MOVFF  70C,564
079E8:  MOVLW  89
079EA:  MOVWF  FE9
079EC:  MOVLW  02
079EE:  MOVWF  x47
079F0:  MOVLB  0
079F2:  CALL   5764
079F6:  MOVLW  2C
079F8:  MOVLB  7
079FA:  MOVWF  x50
079FC:  MOVLB  0
079FE:  CALL   55C6
....................    
....................    return SUCCESS;
07A02:  MOVLW  00
07A04:  MOVWF  01
07A06:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07A08:  MOVLB  7
07A0A:  CLRF   x42
07A0C:  MOVFF  690,741
07A10:  CLRF   x44
07A12:  MOVLW  B5
07A14:  MOVWF  x43
07A16:  MOVLB  0
07A18:  CALL   08AC
07A1C:  MOVFF  02,70E
07A20:  MOVFF  01,70D
07A24:  MOVLW  06
07A26:  MOVLB  7
07A28:  ADDWF  x0D,F
07A2A:  MOVLW  00
07A2C:  ADDWFC x0E,F
07A2E:  MOVLW  32
07A30:  ADDWF  x0D,W
07A32:  MOVWF  01
07A34:  MOVLW  00
07A36:  ADDWFC x0E,W
07A38:  MOVWF  03
07A3A:  MOVF   01,W
07A3C:  ADDLW  EB
07A3E:  MOVWF  01
07A40:  MOVLW  01
07A42:  ADDWFC 03,F
07A44:  MOVFF  01,70D
07A48:  MOVFF  03,70E
07A4C:  MOVFF  03,734
07A50:  MOVFF  01,733
07A54:  MOVLB  0
07A56:  CALL   5C22
07A5A:  MOVF   01,F
07A5C:  BNZ   7A66
07A5E:  MOVLW  02
07A60:  MOVWF  01
07A62:  BRA    7F62
07A64:  BRA    7AC4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07A66:  MOVLB  7
07A68:  CLRF   x42
07A6A:  MOVFF  690,741
07A6E:  CLRF   x44
07A70:  MOVLW  B5
07A72:  MOVWF  x43
07A74:  MOVLB  0
07A76:  CALL   08AC
07A7A:  MOVFF  02,70E
07A7E:  MOVFF  01,70D
07A82:  MOVLW  06
07A84:  MOVLB  7
07A86:  ADDWF  x0D,F
07A88:  MOVLW  00
07A8A:  ADDWFC x0E,F
07A8C:  MOVLW  32
07A8E:  ADDWF  x0D,W
07A90:  MOVWF  01
07A92:  MOVLW  00
07A94:  ADDWFC x0E,W
07A96:  MOVWF  03
07A98:  MOVF   01,W
07A9A:  ADDLW  EB
07A9C:  MOVWF  01
07A9E:  MOVLW  01
07AA0:  ADDWFC 03,F
07AA2:  MOVFF  01,70D
07AA6:  MOVFF  03,70E
07AAA:  MOVFF  03,734
07AAE:  MOVFF  01,733
07AB2:  CLRF   x36
07AB4:  CLRF   x35
07AB6:  MOVLW  0A
07AB8:  MOVWF  x37
07ABA:  MOVLB  0
07ABC:  CALL   5D12
07AC0:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07AC4:  MOVLB  7
07AC6:  CLRF   x42
07AC8:  MOVFF  690,741
07ACC:  CLRF   x44
07ACE:  MOVLW  B5
07AD0:  MOVWF  x43
07AD2:  MOVLB  0
07AD4:  CALL   08AC
07AD8:  MOVFF  02,70E
07ADC:  MOVFF  01,70D
07AE0:  MOVLW  06
07AE2:  MOVLB  7
07AE4:  ADDWF  x0D,F
07AE6:  MOVLW  00
07AE8:  ADDWFC x0E,F
07AEA:  MOVLW  4B
07AEC:  ADDWF  x0D,W
07AEE:  MOVWF  01
07AF0:  MOVLW  00
07AF2:  ADDWFC x0E,W
07AF4:  MOVWF  03
07AF6:  MOVF   01,W
07AF8:  ADDLW  EB
07AFA:  MOVWF  01
07AFC:  MOVLW  01
07AFE:  ADDWFC 03,F
07B00:  MOVFF  01,70D
07B04:  MOVFF  03,70E
07B08:  MOVFF  03,742
07B0C:  MOVFF  01,741
07B10:  MOVLB  0
07B12:  CALL   558E
07B16:  MOVFF  02,03
07B1A:  MOVF   01,W
07B1C:  SUBLW  01
07B1E:  BNZ   7B24
07B20:  MOVF   03,F
07B22:  BZ    7B2C
07B24:  MOVLW  02
07B26:  MOVWF  01
07B28:  BRA    7F62
07B2A:  BRA    7B6C
....................    else arg2 = SERcmd[rec].p[3][0];
07B2C:  MOVLB  7
07B2E:  CLRF   x42
07B30:  MOVFF  690,741
07B34:  CLRF   x44
07B36:  MOVLW  B5
07B38:  MOVWF  x43
07B3A:  MOVLB  0
07B3C:  CALL   08AC
07B40:  MOVFF  02,70E
07B44:  MOVFF  01,70D
07B48:  MOVLW  06
07B4A:  MOVLB  7
07B4C:  ADDWF  x0D,F
07B4E:  MOVLW  00
07B50:  ADDWFC x0E,F
07B52:  MOVLW  4B
07B54:  ADDWF  x0D,F
07B56:  MOVLW  00
07B58:  ADDWFC x0E,F
07B5A:  MOVLW  EB
07B5C:  ADDWF  x0D,W
07B5E:  MOVWF  FE9
07B60:  MOVLW  01
07B62:  ADDWFC x0E,W
07B64:  MOVWF  FEA
07B66:  MOVFF  FEF,70C
07B6A:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07B6C:  MOVLB  7
07B6E:  MOVF   x0C,W
07B70:  SUBLW  30
07B72:  BNZ   7C0E
07B74:  MOVLW  04
07B76:  MOVWF  x42
07B78:  MOVLW  C1
07B7A:  MOVWF  x41
07B7C:  MOVLB  0
07B7E:  CALL   558E
07B82:  MOVFF  02,03
07B86:  MOVF   01,W
07B88:  ADDLW  C1
07B8A:  MOVLB  7
07B8C:  MOVWF  x0D
07B8E:  MOVLW  04
07B90:  ADDWFC 02,W
07B92:  MOVWF  x0E
07B94:  MOVLW  01
07B96:  SUBWF  x0B,W
07B98:  MULLW  18
07B9A:  MOVF   FF3,W
07B9C:  CLRF   x10
07B9E:  MOVWF  x0F
07BA0:  MOVLW  92
07BA2:  ADDWF  x0F,W
07BA4:  MOVWF  FE9
07BA6:  MOVLW  00
07BA8:  ADDWFC x10,W
07BAA:  MOVWF  FEA
07BAC:  MOVFF  FEF,711
07BB0:  MOVFF  FEC,712
07BB4:  MOVFF  FEC,713
07BB8:  MOVFF  FEC,714
07BBC:  MOVFF  70E,565
07BC0:  MOVFF  70D,564
07BC4:  MOVFF  70B,734
07BC8:  MOVLW  18
07BCA:  MOVWF  x35
07BCC:  MOVLB  0
07BCE:  CALL   6066
07BD2:  MOVLW  2C
07BD4:  MOVLB  7
07BD6:  MOVWF  x50
07BD8:  MOVLB  0
07BDA:  CALL   55C6
07BDE:  MOVLW  89
07BE0:  MOVWF  FE9
07BE2:  MOVFF  714,746
07BE6:  MOVFF  713,745
07BEA:  MOVFF  712,744
07BEE:  MOVFF  711,743
07BF2:  MOVLW  02
07BF4:  MOVLB  7
07BF6:  MOVWF  x47
07BF8:  MOVLB  0
07BFA:  CALL   5764
07BFE:  MOVLW  2C
07C00:  MOVLB  7
07C02:  MOVWF  x50
07C04:  MOVLB  0
07C06:  CALL   55C6
07C0A:  BRA    7F5E
07C0C:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07C0E:  MOVF   x0C,W
07C10:  SUBLW  31
07C12:  BNZ   7CB6
07C14:  MOVLW  04
07C16:  MOVWF  x42
07C18:  MOVLW  C1
07C1A:  MOVWF  x41
07C1C:  MOVLB  0
07C1E:  CALL   558E
07C22:  MOVF   01,W
07C24:  ADDLW  C1
07C26:  MOVLB  7
07C28:  MOVWF  x0D
07C2A:  MOVLW  04
07C2C:  ADDWFC 02,W
07C2E:  MOVWF  x0E
07C30:  MOVLW  01
07C32:  SUBWF  x0B,W
07C34:  MULLW  18
07C36:  MOVF   FF3,W
07C38:  CLRF   x10
07C3A:  MOVWF  x0F
07C3C:  MOVLW  04
07C3E:  ADDWF  x0F,W
07C40:  MOVWF  01
07C42:  MOVLW  00
07C44:  ADDWFC x10,W
07C46:  MOVWF  03
07C48:  MOVF   01,W
07C4A:  ADDLW  92
07C4C:  MOVWF  FE9
07C4E:  MOVLW  00
07C50:  ADDWFC 03,W
07C52:  MOVWF  FEA
07C54:  MOVFF  FEF,70F
07C58:  MOVFF  FEC,710
07C5C:  MOVFF  FEC,711
07C60:  MOVFF  FEC,712
07C64:  MOVFF  70E,565
07C68:  MOVFF  70D,564
07C6C:  MOVFF  70B,734
07C70:  MOVLW  18
07C72:  MOVWF  x35
07C74:  MOVLB  0
07C76:  CALL   6066
07C7A:  MOVLW  2C
07C7C:  MOVLB  7
07C7E:  MOVWF  x50
07C80:  MOVLB  0
07C82:  CALL   55C6
07C86:  MOVLW  89
07C88:  MOVWF  FE9
07C8A:  MOVFF  712,746
07C8E:  MOVFF  711,745
07C92:  MOVFF  710,744
07C96:  MOVFF  70F,743
07C9A:  MOVLW  02
07C9C:  MOVLB  7
07C9E:  MOVWF  x47
07CA0:  MOVLB  0
07CA2:  CALL   5764
07CA6:  MOVLW  2C
07CA8:  MOVLB  7
07CAA:  MOVWF  x50
07CAC:  MOVLB  0
07CAE:  CALL   55C6
07CB2:  BRA    7F5E
07CB4:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07CB6:  MOVF   x0C,W
07CB8:  SUBLW  32
07CBA:  BNZ   7D5E
07CBC:  MOVLW  04
07CBE:  MOVWF  x42
07CC0:  MOVLW  C1
07CC2:  MOVWF  x41
07CC4:  MOVLB  0
07CC6:  CALL   558E
07CCA:  MOVF   01,W
07CCC:  ADDLW  C1
07CCE:  MOVLB  7
07CD0:  MOVWF  x0D
07CD2:  MOVLW  04
07CD4:  ADDWFC 02,W
07CD6:  MOVWF  x0E
07CD8:  MOVLW  01
07CDA:  SUBWF  x0B,W
07CDC:  MULLW  18
07CDE:  MOVF   FF3,W
07CE0:  CLRF   x10
07CE2:  MOVWF  x0F
07CE4:  MOVLW  08
07CE6:  ADDWF  x0F,W
07CE8:  MOVWF  01
07CEA:  MOVLW  00
07CEC:  ADDWFC x10,W
07CEE:  MOVWF  03
07CF0:  MOVF   01,W
07CF2:  ADDLW  92
07CF4:  MOVWF  FE9
07CF6:  MOVLW  00
07CF8:  ADDWFC 03,W
07CFA:  MOVWF  FEA
07CFC:  MOVFF  FEF,70F
07D00:  MOVFF  FEC,710
07D04:  MOVFF  FEC,711
07D08:  MOVFF  FEC,712
07D0C:  MOVFF  70E,565
07D10:  MOVFF  70D,564
07D14:  MOVFF  70B,734
07D18:  MOVLW  18
07D1A:  MOVWF  x35
07D1C:  MOVLB  0
07D1E:  CALL   6066
07D22:  MOVLW  2C
07D24:  MOVLB  7
07D26:  MOVWF  x50
07D28:  MOVLB  0
07D2A:  CALL   55C6
07D2E:  MOVLW  89
07D30:  MOVWF  FE9
07D32:  MOVFF  712,746
07D36:  MOVFF  711,745
07D3A:  MOVFF  710,744
07D3E:  MOVFF  70F,743
07D42:  MOVLW  02
07D44:  MOVLB  7
07D46:  MOVWF  x47
07D48:  MOVLB  0
07D4A:  CALL   5764
07D4E:  MOVLW  2C
07D50:  MOVLB  7
07D52:  MOVWF  x50
07D54:  MOVLB  0
07D56:  CALL   55C6
07D5A:  BRA    7F5E
07D5C:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07D5E:  MOVF   x0C,W
07D60:  SUBLW  33
07D62:  BNZ   7E06
07D64:  MOVLW  04
07D66:  MOVWF  x42
07D68:  MOVLW  C1
07D6A:  MOVWF  x41
07D6C:  MOVLB  0
07D6E:  CALL   558E
07D72:  MOVF   01,W
07D74:  ADDLW  C1
07D76:  MOVLB  7
07D78:  MOVWF  x0D
07D7A:  MOVLW  04
07D7C:  ADDWFC 02,W
07D7E:  MOVWF  x0E
07D80:  MOVLW  01
07D82:  SUBWF  x0B,W
07D84:  MULLW  18
07D86:  MOVF   FF3,W
07D88:  CLRF   x10
07D8A:  MOVWF  x0F
07D8C:  MOVLW  0C
07D8E:  ADDWF  x0F,W
07D90:  MOVWF  01
07D92:  MOVLW  00
07D94:  ADDWFC x10,W
07D96:  MOVWF  03
07D98:  MOVF   01,W
07D9A:  ADDLW  92
07D9C:  MOVWF  FE9
07D9E:  MOVLW  00
07DA0:  ADDWFC 03,W
07DA2:  MOVWF  FEA
07DA4:  MOVFF  FEF,70F
07DA8:  MOVFF  FEC,710
07DAC:  MOVFF  FEC,711
07DB0:  MOVFF  FEC,712
07DB4:  MOVFF  70E,565
07DB8:  MOVFF  70D,564
07DBC:  MOVFF  70B,734
07DC0:  MOVLW  18
07DC2:  MOVWF  x35
07DC4:  MOVLB  0
07DC6:  CALL   6066
07DCA:  MOVLW  2C
07DCC:  MOVLB  7
07DCE:  MOVWF  x50
07DD0:  MOVLB  0
07DD2:  CALL   55C6
07DD6:  MOVLW  89
07DD8:  MOVWF  FE9
07DDA:  MOVFF  712,746
07DDE:  MOVFF  711,745
07DE2:  MOVFF  710,744
07DE6:  MOVFF  70F,743
07DEA:  MOVLW  02
07DEC:  MOVLB  7
07DEE:  MOVWF  x47
07DF0:  MOVLB  0
07DF2:  CALL   5764
07DF6:  MOVLW  2C
07DF8:  MOVLB  7
07DFA:  MOVWF  x50
07DFC:  MOVLB  0
07DFE:  CALL   55C6
07E02:  BRA    7F5E
07E04:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07E06:  MOVF   x0C,W
07E08:  SUBLW  34
07E0A:  BNZ   7EAE
07E0C:  MOVLW  04
07E0E:  MOVWF  x42
07E10:  MOVLW  C1
07E12:  MOVWF  x41
07E14:  MOVLB  0
07E16:  CALL   558E
07E1A:  MOVF   01,W
07E1C:  ADDLW  C1
07E1E:  MOVLB  7
07E20:  MOVWF  x0D
07E22:  MOVLW  04
07E24:  ADDWFC 02,W
07E26:  MOVWF  x0E
07E28:  MOVLW  01
07E2A:  SUBWF  x0B,W
07E2C:  MULLW  18
07E2E:  MOVF   FF3,W
07E30:  CLRF   x10
07E32:  MOVWF  x0F
07E34:  MOVLW  10
07E36:  ADDWF  x0F,W
07E38:  MOVWF  01
07E3A:  MOVLW  00
07E3C:  ADDWFC x10,W
07E3E:  MOVWF  03
07E40:  MOVF   01,W
07E42:  ADDLW  92
07E44:  MOVWF  FE9
07E46:  MOVLW  00
07E48:  ADDWFC 03,W
07E4A:  MOVWF  FEA
07E4C:  MOVFF  FEF,70F
07E50:  MOVFF  FEC,710
07E54:  MOVFF  FEC,711
07E58:  MOVFF  FEC,712
07E5C:  MOVFF  70E,565
07E60:  MOVFF  70D,564
07E64:  MOVFF  70B,734
07E68:  MOVLW  18
07E6A:  MOVWF  x35
07E6C:  MOVLB  0
07E6E:  CALL   6066
07E72:  MOVLW  2C
07E74:  MOVLB  7
07E76:  MOVWF  x50
07E78:  MOVLB  0
07E7A:  CALL   55C6
07E7E:  MOVLW  89
07E80:  MOVWF  FE9
07E82:  MOVFF  712,746
07E86:  MOVFF  711,745
07E8A:  MOVFF  710,744
07E8E:  MOVFF  70F,743
07E92:  MOVLW  02
07E94:  MOVLB  7
07E96:  MOVWF  x47
07E98:  MOVLB  0
07E9A:  CALL   5764
07E9E:  MOVLW  2C
07EA0:  MOVLB  7
07EA2:  MOVWF  x50
07EA4:  MOVLB  0
07EA6:  CALL   55C6
07EAA:  BRA    7F5E
07EAC:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07EAE:  MOVF   x0C,W
07EB0:  SUBLW  35
07EB2:  BNZ   7F56
07EB4:  MOVLW  04
07EB6:  MOVWF  x42
07EB8:  MOVLW  C1
07EBA:  MOVWF  x41
07EBC:  MOVLB  0
07EBE:  CALL   558E
07EC2:  MOVF   01,W
07EC4:  ADDLW  C1
07EC6:  MOVLB  7
07EC8:  MOVWF  x0D
07ECA:  MOVLW  04
07ECC:  ADDWFC 02,W
07ECE:  MOVWF  x0E
07ED0:  MOVLW  01
07ED2:  SUBWF  x0B,W
07ED4:  MULLW  18
07ED6:  MOVF   FF3,W
07ED8:  CLRF   x10
07EDA:  MOVWF  x0F
07EDC:  MOVLW  14
07EDE:  ADDWF  x0F,W
07EE0:  MOVWF  01
07EE2:  MOVLW  00
07EE4:  ADDWFC x10,W
07EE6:  MOVWF  03
07EE8:  MOVF   01,W
07EEA:  ADDLW  92
07EEC:  MOVWF  FE9
07EEE:  MOVLW  00
07EF0:  ADDWFC 03,W
07EF2:  MOVWF  FEA
07EF4:  MOVFF  FEF,70F
07EF8:  MOVFF  FEC,710
07EFC:  MOVFF  FEC,711
07F00:  MOVFF  FEC,712
07F04:  MOVFF  70E,565
07F08:  MOVFF  70D,564
07F0C:  MOVFF  70B,734
07F10:  MOVLW  18
07F12:  MOVWF  x35
07F14:  MOVLB  0
07F16:  CALL   6066
07F1A:  MOVLW  2C
07F1C:  MOVLB  7
07F1E:  MOVWF  x50
07F20:  MOVLB  0
07F22:  CALL   55C6
07F26:  MOVLW  89
07F28:  MOVWF  FE9
07F2A:  MOVFF  712,746
07F2E:  MOVFF  711,745
07F32:  MOVFF  710,744
07F36:  MOVFF  70F,743
07F3A:  MOVLW  02
07F3C:  MOVLB  7
07F3E:  MOVWF  x47
07F40:  MOVLB  0
07F42:  CALL   5764
07F46:  MOVLW  2C
07F48:  MOVLB  7
07F4A:  MOVWF  x50
07F4C:  MOVLB  0
07F4E:  CALL   55C6
07F52:  BRA    7F5E
07F54:  MOVLB  7
....................    else return INV_PARAM;
07F56:  MOVLW  02
07F58:  MOVWF  01
07F5A:  MOVLB  0
07F5C:  BRA    7F62
....................    
....................    return SUCCESS;
07F5E:  MOVLW  00
07F60:  MOVWF  01
07F62:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07F64:  MOVLB  7
07F66:  CLRF   x42
07F68:  MOVFF  690,741
07F6C:  CLRF   x44
07F6E:  MOVLW  B5
07F70:  MOVWF  x43
07F72:  MOVLB  0
07F74:  CALL   08AC
07F78:  MOVFF  02,712
07F7C:  MOVFF  01,711
07F80:  MOVLW  06
07F82:  MOVLB  7
07F84:  ADDWF  x11,F
07F86:  MOVLW  00
07F88:  ADDWFC x12,F
07F8A:  MOVLW  32
07F8C:  ADDWF  x11,W
07F8E:  MOVWF  01
07F90:  MOVLW  00
07F92:  ADDWFC x12,W
07F94:  MOVWF  03
07F96:  MOVF   01,W
07F98:  ADDLW  EB
07F9A:  MOVWF  01
07F9C:  MOVLW  01
07F9E:  ADDWFC 03,F
07FA0:  MOVFF  01,711
07FA4:  MOVFF  03,712
07FA8:  MOVFF  03,734
07FAC:  MOVFF  01,733
07FB0:  MOVLB  0
07FB2:  CALL   5C22
07FB6:  MOVF   01,F
07FB8:  BNZ   7FC2
07FBA:  MOVLW  02
07FBC:  MOVWF  01
07FBE:  BRA    82FA
07FC0:  BRA    8020
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07FC2:  MOVLB  7
07FC4:  CLRF   x42
07FC6:  MOVFF  690,741
07FCA:  CLRF   x44
07FCC:  MOVLW  B5
07FCE:  MOVWF  x43
07FD0:  MOVLB  0
07FD2:  CALL   08AC
07FD6:  MOVFF  02,712
07FDA:  MOVFF  01,711
07FDE:  MOVLW  06
07FE0:  MOVLB  7
07FE2:  ADDWF  x11,F
07FE4:  MOVLW  00
07FE6:  ADDWFC x12,F
07FE8:  MOVLW  32
07FEA:  ADDWF  x11,W
07FEC:  MOVWF  01
07FEE:  MOVLW  00
07FF0:  ADDWFC x12,W
07FF2:  MOVWF  03
07FF4:  MOVF   01,W
07FF6:  ADDLW  EB
07FF8:  MOVWF  01
07FFA:  MOVLW  01
07FFC:  ADDWFC 03,F
07FFE:  MOVFF  01,711
08002:  MOVFF  03,712
08006:  MOVFF  03,734
0800A:  MOVFF  01,733
0800E:  CLRF   x36
08010:  CLRF   x35
08012:  MOVLW  0A
08014:  MOVWF  x37
08016:  MOVLB  0
08018:  CALL   5D12
0801C:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08020:  MOVLB  7
08022:  CLRF   x42
08024:  MOVFF  690,741
08028:  CLRF   x44
0802A:  MOVLW  B5
0802C:  MOVWF  x43
0802E:  MOVLB  0
08030:  CALL   08AC
08034:  MOVFF  02,712
08038:  MOVFF  01,711
0803C:  MOVLW  06
0803E:  MOVLB  7
08040:  ADDWF  x11,F
08042:  MOVLW  00
08044:  ADDWFC x12,F
08046:  MOVLW  4B
08048:  ADDWF  x11,W
0804A:  MOVWF  01
0804C:  MOVLW  00
0804E:  ADDWFC x12,W
08050:  MOVWF  03
08052:  MOVF   01,W
08054:  ADDLW  EB
08056:  MOVWF  01
08058:  MOVLW  01
0805A:  ADDWFC 03,F
0805C:  MOVFF  01,711
08060:  MOVFF  03,712
08064:  MOVFF  03,742
08068:  MOVFF  01,741
0806C:  MOVLB  0
0806E:  CALL   558E
08072:  MOVFF  02,03
08076:  MOVF   01,W
08078:  SUBLW  01
0807A:  BNZ   8080
0807C:  MOVF   03,F
0807E:  BZ    8088
08080:  MOVLW  02
08082:  MOVWF  01
08084:  BRA    82FA
08086:  BRA    80C8
....................    else arg2 = SERcmd[rec].p[3][0];
08088:  MOVLB  7
0808A:  CLRF   x42
0808C:  MOVFF  690,741
08090:  CLRF   x44
08092:  MOVLW  B5
08094:  MOVWF  x43
08096:  MOVLB  0
08098:  CALL   08AC
0809C:  MOVFF  02,712
080A0:  MOVFF  01,711
080A4:  MOVLW  06
080A6:  MOVLB  7
080A8:  ADDWF  x11,F
080AA:  MOVLW  00
080AC:  ADDWFC x12,F
080AE:  MOVLW  4B
080B0:  ADDWF  x11,F
080B2:  MOVLW  00
080B4:  ADDWFC x12,F
080B6:  MOVLW  EB
080B8:  ADDWF  x11,W
080BA:  MOVWF  FE9
080BC:  MOVLW  01
080BE:  ADDWFC x12,W
080C0:  MOVWF  FEA
080C2:  MOVFF  FEF,70C
080C6:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
080C8:  MOVLB  7
080CA:  CLRF   x42
080CC:  MOVFF  690,741
080D0:  CLRF   x44
080D2:  MOVLW  B5
080D4:  MOVWF  x43
080D6:  MOVLB  0
080D8:  CALL   08AC
080DC:  MOVFF  02,712
080E0:  MOVFF  01,711
080E4:  MOVLW  06
080E6:  MOVLB  7
080E8:  ADDWF  x11,F
080EA:  MOVLW  00
080EC:  ADDWFC x12,F
080EE:  MOVLW  64
080F0:  ADDWF  x11,W
080F2:  MOVWF  01
080F4:  MOVLW  00
080F6:  ADDWFC x12,W
080F8:  MOVWF  03
080FA:  MOVF   01,W
080FC:  ADDLW  EB
080FE:  MOVWF  01
08100:  MOVLW  01
08102:  ADDWFC 03,F
08104:  MOVFF  01,711
08108:  MOVFF  03,712
0810C:  MOVFF  03,715
08110:  MOVFF  01,714
08114:  MOVLB  0
08116:  CALL   6D36
0811A:  MOVF   01,F
0811C:  BNZ   8126
0811E:  MOVLW  02
08120:  MOVWF  01
08122:  BRA    82FA
08124:  BRA    818C
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08126:  MOVLB  7
08128:  CLRF   x42
0812A:  MOVFF  690,741
0812E:  CLRF   x44
08130:  MOVLW  B5
08132:  MOVWF  x43
08134:  MOVLB  0
08136:  CALL   08AC
0813A:  MOVFF  02,712
0813E:  MOVFF  01,711
08142:  MOVLW  06
08144:  MOVLB  7
08146:  ADDWF  x11,F
08148:  MOVLW  00
0814A:  ADDWFC x12,F
0814C:  MOVLW  64
0814E:  ADDWF  x11,W
08150:  MOVWF  01
08152:  MOVLW  00
08154:  ADDWFC x12,W
08156:  MOVWF  03
08158:  MOVF   01,W
0815A:  ADDLW  EB
0815C:  MOVWF  01
0815E:  MOVLW  01
08160:  ADDWFC 03,F
08162:  MOVFF  01,711
08166:  MOVFF  03,712
0816A:  MOVFF  03,715
0816E:  MOVFF  01,714
08172:  CLRF   x17
08174:  CLRF   x16
08176:  MOVLB  0
08178:  CALL   6DF8
0817C:  MOVFF  03,710
08180:  MOVFF  02,70F
08184:  MOVFF  01,70E
08188:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
0818C:  MOVLB  7
0818E:  MOVF   x0C,W
08190:  SUBLW  30
08192:  BNZ   81BE
08194:  MOVLW  01
08196:  SUBWF  x0B,W
08198:  MULLW  18
0819A:  MOVF   FF3,W
0819C:  CLRF   x12
0819E:  MOVWF  x11
081A0:  MOVLW  92
081A2:  ADDWF  x11,W
081A4:  MOVWF  FE9
081A6:  MOVLW  00
081A8:  ADDWFC x12,W
081AA:  MOVWF  FEA
081AC:  MOVFF  70D,FEF
081B0:  MOVFF  70E,FEC
081B4:  MOVFF  70F,FEC
081B8:  MOVFF  710,FEC
081BC:  BRA    82F4
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
081BE:  MOVF   x0C,W
081C0:  SUBLW  31
081C2:  BNZ   81FA
081C4:  MOVLW  01
081C6:  SUBWF  x0B,W
081C8:  MULLW  18
081CA:  MOVF   FF3,W
081CC:  CLRF   x12
081CE:  MOVWF  x11
081D0:  MOVLW  04
081D2:  ADDWF  x11,W
081D4:  MOVWF  01
081D6:  MOVLW  00
081D8:  ADDWFC x12,W
081DA:  MOVWF  03
081DC:  MOVF   01,W
081DE:  ADDLW  92
081E0:  MOVWF  FE9
081E2:  MOVLW  00
081E4:  ADDWFC 03,W
081E6:  MOVWF  FEA
081E8:  MOVFF  70D,FEF
081EC:  MOVFF  70E,FEC
081F0:  MOVFF  70F,FEC
081F4:  MOVFF  710,FEC
081F8:  BRA    82F4
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
081FA:  MOVF   x0C,W
081FC:  SUBLW  32
081FE:  BNZ   8236
08200:  MOVLW  01
08202:  SUBWF  x0B,W
08204:  MULLW  18
08206:  MOVF   FF3,W
08208:  CLRF   x12
0820A:  MOVWF  x11
0820C:  MOVLW  08
0820E:  ADDWF  x11,W
08210:  MOVWF  01
08212:  MOVLW  00
08214:  ADDWFC x12,W
08216:  MOVWF  03
08218:  MOVF   01,W
0821A:  ADDLW  92
0821C:  MOVWF  FE9
0821E:  MOVLW  00
08220:  ADDWFC 03,W
08222:  MOVWF  FEA
08224:  MOVFF  70D,FEF
08228:  MOVFF  70E,FEC
0822C:  MOVFF  70F,FEC
08230:  MOVFF  710,FEC
08234:  BRA    82F4
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08236:  MOVF   x0C,W
08238:  SUBLW  33
0823A:  BNZ   8272
0823C:  MOVLW  01
0823E:  SUBWF  x0B,W
08240:  MULLW  18
08242:  MOVF   FF3,W
08244:  CLRF   x12
08246:  MOVWF  x11
08248:  MOVLW  0C
0824A:  ADDWF  x11,W
0824C:  MOVWF  01
0824E:  MOVLW  00
08250:  ADDWFC x12,W
08252:  MOVWF  03
08254:  MOVF   01,W
08256:  ADDLW  92
08258:  MOVWF  FE9
0825A:  MOVLW  00
0825C:  ADDWFC 03,W
0825E:  MOVWF  FEA
08260:  MOVFF  70D,FEF
08264:  MOVFF  70E,FEC
08268:  MOVFF  70F,FEC
0826C:  MOVFF  710,FEC
08270:  BRA    82F4
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08272:  MOVF   x0C,W
08274:  SUBLW  34
08276:  BNZ   82AE
08278:  MOVLW  01
0827A:  SUBWF  x0B,W
0827C:  MULLW  18
0827E:  MOVF   FF3,W
08280:  CLRF   x12
08282:  MOVWF  x11
08284:  MOVLW  10
08286:  ADDWF  x11,W
08288:  MOVWF  01
0828A:  MOVLW  00
0828C:  ADDWFC x12,W
0828E:  MOVWF  03
08290:  MOVF   01,W
08292:  ADDLW  92
08294:  MOVWF  FE9
08296:  MOVLW  00
08298:  ADDWFC 03,W
0829A:  MOVWF  FEA
0829C:  MOVFF  70D,FEF
082A0:  MOVFF  70E,FEC
082A4:  MOVFF  70F,FEC
082A8:  MOVFF  710,FEC
082AC:  BRA    82F4
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
082AE:  MOVF   x0C,W
082B0:  SUBLW  35
082B2:  BNZ   82EA
082B4:  MOVLW  01
082B6:  SUBWF  x0B,W
082B8:  MULLW  18
082BA:  MOVF   FF3,W
082BC:  CLRF   x12
082BE:  MOVWF  x11
082C0:  MOVLW  14
082C2:  ADDWF  x11,W
082C4:  MOVWF  01
082C6:  MOVLW  00
082C8:  ADDWFC x12,W
082CA:  MOVWF  03
082CC:  MOVF   01,W
082CE:  ADDLW  92
082D0:  MOVWF  FE9
082D2:  MOVLW  00
082D4:  ADDWFC 03,W
082D6:  MOVWF  FEA
082D8:  MOVFF  70D,FEF
082DC:  MOVFF  70E,FEC
082E0:  MOVFF  70F,FEC
082E4:  MOVFF  710,FEC
082E8:  BRA    82F4
....................    else return INV_PARAM;
082EA:  MOVLW  02
082EC:  MOVWF  01
082EE:  MOVLB  0
082F0:  BRA    82FA
082F2:  MOVLB  7
....................    
....................    return SUCCESS;
082F4:  MOVLW  00
082F6:  MOVWF  01
082F8:  MOVLB  0
082FA:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
082FC:  MOVLW  4E
082FE:  MOVLB  7
08300:  MOVWF  x0F
08302:  MOVLW  31
08304:  MOVWF  x10
08306:  MOVLW  35
08308:  MOVWF  x11
0830A:  CLRF   x12
0830C:  MOVLW  07
0830E:  MOVWF  x0E
08310:  MOVLW  0F
08312:  MOVWF  x0D
....................    char *s_200 = "200";
08314:  MOVLW  32
08316:  MOVWF  x15
08318:  MOVLW  30
0831A:  MOVWF  x16
0831C:  MOVWF  x17
0831E:  CLRF   x18
08320:  MOVLW  07
08322:  MOVWF  x14
08324:  MOVLW  15
08326:  MOVWF  x13
....................    char *s_5V6 = "5V6";
08328:  MOVLW  35
0832A:  MOVWF  x1B
0832C:  MOVLW  56
0832E:  MOVWF  x1C
08330:  MOVLW  36
08332:  MOVWF  x1D
08334:  CLRF   x1E
08336:  MOVLW  07
08338:  MOVWF  x1A
0833A:  MOVLW  1B
0833C:  MOVWF  x19
....................    char *s_5VA = "5VA";
0833E:  MOVLW  35
08340:  MOVWF  x21
08342:  MOVLW  56
08344:  MOVWF  x22
08346:  MOVLW  41
08348:  MOVWF  x23
0834A:  CLRF   x24
0834C:  MOVLW  07
0834E:  MOVWF  x20
08350:  MOVLW  21
08352:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08354:  MOVLW  33
08356:  MOVWF  x27
08358:  MOVLW  56
0835A:  MOVWF  x28
0835C:  MOVLW  36
0835E:  MOVWF  x29
08360:  MOVLW  58
08362:  MOVWF  x2A
08364:  CLRF   x2B
08366:  MOVLW  07
08368:  MOVWF  x26
0836A:  MOVLW  27
0836C:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
0836E:  MOVLW  33
08370:  MOVWF  x2E
08372:  MOVLW  56
08374:  MOVWF  x2F
08376:  MOVLW  33
08378:  MOVWF  x30
0837A:  MOVLW  41
0837C:  MOVWF  x31
0837E:  CLRF   x32
08380:  MOVLW  07
08382:  MOVWF  x2D
08384:  MOVLW  2E
08386:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
08388:  MOVLW  33
0838A:  MOVWF  x35
0838C:  MOVLW  56
0838E:  MOVWF  x36
08390:  MOVLW  33
08392:  MOVWF  x37
08394:  MOVLW  44
08396:  MOVWF  x38
08398:  CLRF   x39
0839A:  MOVLW  07
0839C:  MOVWF  x34
0839E:  MOVLW  35
083A0:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
083A2:  CLRF   x42
083A4:  MOVFF  690,741
083A8:  CLRF   x44
083AA:  MOVLW  B5
083AC:  MOVWF  x43
083AE:  MOVLB  0
083B0:  CALL   08AC
083B4:  MOVFF  02,73B
083B8:  MOVFF  01,73A
083BC:  MOVLW  06
083BE:  MOVLB  7
083C0:  ADDWF  x3A,F
083C2:  MOVLW  00
083C4:  ADDWFC x3B,F
083C6:  MOVLW  32
083C8:  ADDWF  x3A,W
083CA:  MOVWF  01
083CC:  MOVLW  00
083CE:  ADDWFC x3B,W
083D0:  MOVWF  03
083D2:  MOVF   01,W
083D4:  ADDLW  EB
083D6:  MOVWF  01
083D8:  MOVLW  01
083DA:  ADDWFC 03,F
083DC:  MOVFF  01,70B
083E0:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
083E4:  MOVFF  70E,742
083E8:  MOVFF  70D,741
083EC:  MOVFF  70C,744
083F0:  MOVFF  70B,743
083F4:  MOVLB  0
083F6:  CALL   5B02
083FA:  MOVF   01,F
083FC:  BNZ   8480
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
083FE:  MOVLW  04
08400:  MOVLB  7
08402:  MOVWF  x42
08404:  MOVLW  C1
08406:  MOVWF  x41
08408:  MOVLB  0
0840A:  CALL   558E
0840E:  MOVFF  02,03
08412:  MOVF   01,W
08414:  ADDLW  C1
08416:  MOVLB  7
08418:  MOVWF  x3A
0841A:  MOVLW  04
0841C:  ADDWFC 02,W
0841E:  MOVWF  x3B
08420:  MOVFF  FE8,565
08424:  MOVFF  73A,564
08428:  MOVLW  89
0842A:  MOVWF  FE9
0842C:  MOVFF  C5,746
08430:  MOVFF  C4,745
08434:  MOVFF  C3,744
08438:  MOVFF  C2,743
0843C:  MOVLW  02
0843E:  MOVWF  x47
08440:  MOVLB  0
08442:  CALL   5764
08446:  MOVLW  2C
08448:  MOVLB  7
0844A:  MOVWF  x50
0844C:  MOVLB  0
0844E:  CALL   55C6
08452:  MOVLW  89
08454:  MOVWF  FE9
08456:  MOVFF  C9,746
0845A:  MOVFF  C8,745
0845E:  MOVFF  C7,744
08462:  MOVFF  C6,743
08466:  MOVLW  02
08468:  MOVLB  7
0846A:  MOVWF  x47
0846C:  MOVLB  0
0846E:  CALL   5764
08472:  MOVLW  2C
08474:  MOVLB  7
08476:  MOVWF  x50
08478:  MOVLB  0
0847A:  CALL   55C6
....................    }
0847E:  BRA    8822
....................    else if (0 == strcmp(s_200, arg1)) {
08480:  MOVFF  714,742
08484:  MOVFF  713,741
08488:  MOVFF  70C,744
0848C:  MOVFF  70B,743
08490:  CALL   5B02
08494:  MOVF   01,F
08496:  BNZ   851A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08498:  MOVLW  04
0849A:  MOVLB  7
0849C:  MOVWF  x42
0849E:  MOVLW  C1
084A0:  MOVWF  x41
084A2:  MOVLB  0
084A4:  CALL   558E
084A8:  MOVFF  02,03
084AC:  MOVF   01,W
084AE:  ADDLW  C1
084B0:  MOVLB  7
084B2:  MOVWF  x3A
084B4:  MOVLW  04
084B6:  ADDWFC 02,W
084B8:  MOVWF  x3B
084BA:  MOVFF  FE8,565
084BE:  MOVFF  73A,564
084C2:  MOVLW  89
084C4:  MOVWF  FE9
084C6:  MOVFF  CD,746
084CA:  MOVFF  CC,745
084CE:  MOVFF  CB,744
084D2:  MOVFF  CA,743
084D6:  MOVLW  02
084D8:  MOVWF  x47
084DA:  MOVLB  0
084DC:  CALL   5764
084E0:  MOVLW  2C
084E2:  MOVLB  7
084E4:  MOVWF  x50
084E6:  MOVLB  0
084E8:  CALL   55C6
084EC:  MOVLW  89
084EE:  MOVWF  FE9
084F0:  MOVFF  D1,746
084F4:  MOVFF  D0,745
084F8:  MOVFF  CF,744
084FC:  MOVFF  CE,743
08500:  MOVLW  02
08502:  MOVLB  7
08504:  MOVWF  x47
08506:  MOVLB  0
08508:  CALL   5764
0850C:  MOVLW  2C
0850E:  MOVLB  7
08510:  MOVWF  x50
08512:  MOVLB  0
08514:  CALL   55C6
....................    }
08518:  BRA    8822
....................    else if (0 == strcmp(s_5V6, arg1)) {
0851A:  MOVFF  71A,742
0851E:  MOVFF  719,741
08522:  MOVFF  70C,744
08526:  MOVFF  70B,743
0852A:  CALL   5B02
0852E:  MOVF   01,F
08530:  BNZ   85B4
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08532:  MOVLW  04
08534:  MOVLB  7
08536:  MOVWF  x42
08538:  MOVLW  C1
0853A:  MOVWF  x41
0853C:  MOVLB  0
0853E:  CALL   558E
08542:  MOVFF  02,03
08546:  MOVF   01,W
08548:  ADDLW  C1
0854A:  MOVLB  7
0854C:  MOVWF  x3A
0854E:  MOVLW  04
08550:  ADDWFC 02,W
08552:  MOVWF  x3B
08554:  MOVFF  FE8,565
08558:  MOVFF  73A,564
0855C:  MOVLW  89
0855E:  MOVWF  FE9
08560:  MOVFF  D5,746
08564:  MOVFF  D4,745
08568:  MOVFF  D3,744
0856C:  MOVFF  D2,743
08570:  MOVLW  02
08572:  MOVWF  x47
08574:  MOVLB  0
08576:  CALL   5764
0857A:  MOVLW  2C
0857C:  MOVLB  7
0857E:  MOVWF  x50
08580:  MOVLB  0
08582:  CALL   55C6
08586:  MOVLW  89
08588:  MOVWF  FE9
0858A:  MOVFF  D9,746
0858E:  MOVFF  D8,745
08592:  MOVFF  D7,744
08596:  MOVFF  D6,743
0859A:  MOVLW  02
0859C:  MOVLB  7
0859E:  MOVWF  x47
085A0:  MOVLB  0
085A2:  CALL   5764
085A6:  MOVLW  2C
085A8:  MOVLB  7
085AA:  MOVWF  x50
085AC:  MOVLB  0
085AE:  CALL   55C6
....................    }
085B2:  BRA    8822
....................    else if (0 == strcmp(s_5VA, arg1)) {
085B4:  MOVFF  720,742
085B8:  MOVFF  71F,741
085BC:  MOVFF  70C,744
085C0:  MOVFF  70B,743
085C4:  CALL   5B02
085C8:  MOVF   01,F
085CA:  BNZ   864E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
085CC:  MOVLW  04
085CE:  MOVLB  7
085D0:  MOVWF  x42
085D2:  MOVLW  C1
085D4:  MOVWF  x41
085D6:  MOVLB  0
085D8:  CALL   558E
085DC:  MOVFF  02,03
085E0:  MOVF   01,W
085E2:  ADDLW  C1
085E4:  MOVLB  7
085E6:  MOVWF  x3A
085E8:  MOVLW  04
085EA:  ADDWFC 02,W
085EC:  MOVWF  x3B
085EE:  MOVFF  FE8,565
085F2:  MOVFF  73A,564
085F6:  MOVLW  89
085F8:  MOVWF  FE9
085FA:  MOVFF  DD,746
085FE:  MOVFF  DC,745
08602:  MOVFF  DB,744
08606:  MOVFF  DA,743
0860A:  MOVLW  02
0860C:  MOVWF  x47
0860E:  MOVLB  0
08610:  CALL   5764
08614:  MOVLW  2C
08616:  MOVLB  7
08618:  MOVWF  x50
0861A:  MOVLB  0
0861C:  CALL   55C6
08620:  MOVLW  89
08622:  MOVWF  FE9
08624:  MOVFF  E1,746
08628:  MOVFF  E0,745
0862C:  MOVFF  DF,744
08630:  MOVFF  DE,743
08634:  MOVLW  02
08636:  MOVLB  7
08638:  MOVWF  x47
0863A:  MOVLB  0
0863C:  CALL   5764
08640:  MOVLW  2C
08642:  MOVLB  7
08644:  MOVWF  x50
08646:  MOVLB  0
08648:  CALL   55C6
....................    }
0864C:  BRA    8822
....................    else if (0 == strcmp(s_3V6X, arg1)) {
0864E:  MOVFF  726,742
08652:  MOVFF  725,741
08656:  MOVFF  70C,744
0865A:  MOVFF  70B,743
0865E:  CALL   5B02
08662:  MOVF   01,F
08664:  BNZ   86E8
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08666:  MOVLW  04
08668:  MOVLB  7
0866A:  MOVWF  x42
0866C:  MOVLW  C1
0866E:  MOVWF  x41
08670:  MOVLB  0
08672:  CALL   558E
08676:  MOVFF  02,03
0867A:  MOVF   01,W
0867C:  ADDLW  C1
0867E:  MOVLB  7
08680:  MOVWF  x3A
08682:  MOVLW  04
08684:  ADDWFC 02,W
08686:  MOVWF  x3B
08688:  MOVFF  FE8,565
0868C:  MOVFF  73A,564
08690:  MOVLW  89
08692:  MOVWF  FE9
08694:  MOVFF  E5,746
08698:  MOVFF  E4,745
0869C:  MOVFF  E3,744
086A0:  MOVFF  E2,743
086A4:  MOVLW  02
086A6:  MOVWF  x47
086A8:  MOVLB  0
086AA:  CALL   5764
086AE:  MOVLW  2C
086B0:  MOVLB  7
086B2:  MOVWF  x50
086B4:  MOVLB  0
086B6:  CALL   55C6
086BA:  MOVLW  89
086BC:  MOVWF  FE9
086BE:  MOVFF  E9,746
086C2:  MOVFF  E8,745
086C6:  MOVFF  E7,744
086CA:  MOVFF  E6,743
086CE:  MOVLW  02
086D0:  MOVLB  7
086D2:  MOVWF  x47
086D4:  MOVLB  0
086D6:  CALL   5764
086DA:  MOVLW  2C
086DC:  MOVLB  7
086DE:  MOVWF  x50
086E0:  MOVLB  0
086E2:  CALL   55C6
....................    }
086E6:  BRA    8822
....................    else if (0 == strcmp(s_3V3A, arg1)) {
086E8:  MOVFF  72D,742
086EC:  MOVFF  72C,741
086F0:  MOVFF  70C,744
086F4:  MOVFF  70B,743
086F8:  CALL   5B02
086FC:  MOVF   01,F
086FE:  BNZ   8782
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08700:  MOVLW  04
08702:  MOVLB  7
08704:  MOVWF  x42
08706:  MOVLW  C1
08708:  MOVWF  x41
0870A:  MOVLB  0
0870C:  CALL   558E
08710:  MOVFF  02,03
08714:  MOVF   01,W
08716:  ADDLW  C1
08718:  MOVLB  7
0871A:  MOVWF  x3A
0871C:  MOVLW  04
0871E:  ADDWFC 02,W
08720:  MOVWF  x3B
08722:  MOVFF  FE8,565
08726:  MOVFF  73A,564
0872A:  MOVLW  89
0872C:  MOVWF  FE9
0872E:  MOVFF  ED,746
08732:  MOVFF  EC,745
08736:  MOVFF  EB,744
0873A:  MOVFF  EA,743
0873E:  MOVLW  02
08740:  MOVWF  x47
08742:  MOVLB  0
08744:  CALL   5764
08748:  MOVLW  2C
0874A:  MOVLB  7
0874C:  MOVWF  x50
0874E:  MOVLB  0
08750:  CALL   55C6
08754:  MOVLW  89
08756:  MOVWF  FE9
08758:  MOVFF  F1,746
0875C:  MOVFF  F0,745
08760:  MOVFF  EF,744
08764:  MOVFF  EE,743
08768:  MOVLW  02
0876A:  MOVLB  7
0876C:  MOVWF  x47
0876E:  MOVLB  0
08770:  CALL   5764
08774:  MOVLW  2C
08776:  MOVLB  7
08778:  MOVWF  x50
0877A:  MOVLB  0
0877C:  CALL   55C6
....................    }
08780:  BRA    8822
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08782:  MOVFF  734,742
08786:  MOVFF  733,741
0878A:  MOVFF  70C,744
0878E:  MOVFF  70B,743
08792:  CALL   5B02
08796:  MOVF   01,F
08798:  BNZ   881C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
0879A:  MOVLW  04
0879C:  MOVLB  7
0879E:  MOVWF  x42
087A0:  MOVLW  C1
087A2:  MOVWF  x41
087A4:  MOVLB  0
087A6:  CALL   558E
087AA:  MOVFF  02,03
087AE:  MOVF   01,W
087B0:  ADDLW  C1
087B2:  MOVLB  7
087B4:  MOVWF  x3A
087B6:  MOVLW  04
087B8:  ADDWFC 02,W
087BA:  MOVWF  x3B
087BC:  MOVFF  FE8,565
087C0:  MOVFF  73A,564
087C4:  MOVLW  89
087C6:  MOVWF  FE9
087C8:  MOVFF  F5,746
087CC:  MOVFF  F4,745
087D0:  MOVFF  F3,744
087D4:  MOVFF  F2,743
087D8:  MOVLW  02
087DA:  MOVWF  x47
087DC:  MOVLB  0
087DE:  CALL   5764
087E2:  MOVLW  2C
087E4:  MOVLB  7
087E6:  MOVWF  x50
087E8:  MOVLB  0
087EA:  CALL   55C6
087EE:  MOVLW  89
087F0:  MOVWF  FE9
087F2:  MOVFF  F9,746
087F6:  MOVFF  F8,745
087FA:  MOVFF  F7,744
087FE:  MOVFF  F6,743
08802:  MOVLW  02
08804:  MOVLB  7
08806:  MOVWF  x47
08808:  MOVLB  0
0880A:  CALL   5764
0880E:  MOVLW  2C
08810:  MOVLB  7
08812:  MOVWF  x50
08814:  MOVLB  0
08816:  CALL   55C6
....................    }
0881A:  BRA    8822
....................    else return INV_PARAM;
0881C:  MOVLW  02
0881E:  MOVWF  01
08820:  BRA    8826
....................    
....................    return SUCCESS;
08822:  MOVLW  00
08824:  MOVWF  01
08826:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
08828:  MOVLW  00
0882A:  MOVWF  01
0882C:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0882E:  MOVLW  4E
08830:  MOVLB  7
08832:  MOVWF  x0F
08834:  MOVLW  31
08836:  MOVWF  x10
08838:  MOVLW  35
0883A:  MOVWF  x11
0883C:  CLRF   x12
0883E:  MOVLW  07
08840:  MOVWF  x0E
08842:  MOVLW  0F
08844:  MOVWF  x0D
....................    char *s_200 = "200";
08846:  MOVLW  32
08848:  MOVWF  x15
0884A:  MOVLW  30
0884C:  MOVWF  x16
0884E:  MOVWF  x17
08850:  CLRF   x18
08852:  MOVLW  07
08854:  MOVWF  x14
08856:  MOVLW  15
08858:  MOVWF  x13
....................    char *s_5V6 = "5V6";
0885A:  MOVLW  35
0885C:  MOVWF  x1B
0885E:  MOVLW  56
08860:  MOVWF  x1C
08862:  MOVLW  36
08864:  MOVWF  x1D
08866:  CLRF   x1E
08868:  MOVLW  07
0886A:  MOVWF  x1A
0886C:  MOVLW  1B
0886E:  MOVWF  x19
....................    char *s_5VA = "5VA";
08870:  MOVLW  35
08872:  MOVWF  x21
08874:  MOVLW  56
08876:  MOVWF  x22
08878:  MOVLW  41
0887A:  MOVWF  x23
0887C:  CLRF   x24
0887E:  MOVLW  07
08880:  MOVWF  x20
08882:  MOVLW  21
08884:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08886:  MOVLW  33
08888:  MOVWF  x27
0888A:  MOVLW  56
0888C:  MOVWF  x28
0888E:  MOVLW  36
08890:  MOVWF  x29
08892:  MOVLW  58
08894:  MOVWF  x2A
08896:  CLRF   x2B
08898:  MOVLW  07
0889A:  MOVWF  x26
0889C:  MOVLW  27
0889E:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
088A0:  MOVLW  33
088A2:  MOVWF  x2E
088A4:  MOVLW  56
088A6:  MOVWF  x2F
088A8:  MOVLW  33
088AA:  MOVWF  x30
088AC:  MOVLW  41
088AE:  MOVWF  x31
088B0:  CLRF   x32
088B2:  MOVLW  07
088B4:  MOVWF  x2D
088B6:  MOVLW  2E
088B8:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
088BA:  MOVLW  33
088BC:  MOVWF  x35
088BE:  MOVLW  56
088C0:  MOVWF  x36
088C2:  MOVLW  33
088C4:  MOVWF  x37
088C6:  MOVLW  44
088C8:  MOVWF  x38
088CA:  CLRF   x39
088CC:  MOVLW  07
088CE:  MOVWF  x34
088D0:  MOVLW  35
088D2:  MOVWF  x33
....................    char *s_all = "all";
088D4:  MOVLW  61
088D6:  MOVWF  x3C
088D8:  MOVLW  6C
088DA:  MOVWF  x3D
088DC:  MOVWF  x3E
088DE:  CLRF   x3F
088E0:  MOVLW  07
088E2:  MOVWF  x3B
088E4:  MOVLW  3C
088E6:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
088E8:  CLRF   x42
088EA:  MOVFF  690,741
088EE:  CLRF   x44
088F0:  MOVLW  B5
088F2:  MOVWF  x43
088F4:  MOVLB  0
088F6:  CALL   08AC
088FA:  MOVFF  02,741
088FE:  MOVFF  01,740
08902:  MOVLW  06
08904:  MOVLB  7
08906:  ADDWF  x40,F
08908:  MOVLW  00
0890A:  ADDWFC x41,F
0890C:  MOVLW  32
0890E:  ADDWF  x40,W
08910:  MOVWF  01
08912:  MOVLW  00
08914:  ADDWFC x41,W
08916:  MOVWF  03
08918:  MOVF   01,W
0891A:  ADDLW  EB
0891C:  MOVWF  01
0891E:  MOVLW  01
08920:  ADDWFC 03,F
08922:  MOVFF  01,70B
08926:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0892A:  MOVFF  70E,742
0892E:  MOVFF  70D,741
08932:  MOVFF  70C,744
08936:  MOVFF  70B,743
0893A:  MOVLB  0
0893C:  CALL   5B02
08940:  MOVF   01,F
08942:  BNZ   899A
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08944:  MOVLW  04
08946:  MOVLB  7
08948:  MOVWF  x42
0894A:  MOVLW  C1
0894C:  MOVWF  x41
0894E:  MOVLB  0
08950:  CALL   558E
08954:  MOVFF  02,03
08958:  MOVF   01,W
0895A:  ADDLW  C1
0895C:  MOVLB  7
0895E:  MOVWF  x40
08960:  MOVLW  04
08962:  ADDWFC 02,W
08964:  MOVWF  x41
08966:  MOVFF  FE8,565
0896A:  MOVFF  740,564
0896E:  MOVLW  89
08970:  MOVWF  FE9
08972:  MOVFF  FE,746
08976:  MOVFF  FD,745
0897A:  MOVFF  FC,744
0897E:  MOVFF  FB,743
08982:  MOVLW  02
08984:  MOVWF  x47
08986:  MOVLB  0
08988:  CALL   5764
0898C:  MOVLW  2C
0898E:  MOVLB  7
08990:  MOVWF  x50
08992:  MOVLB  0
08994:  CALL   55C6
....................    }
08998:  BRA    8E9C
....................    else if (0 == strcmp(s_200, arg1)) {
0899A:  MOVFF  714,742
0899E:  MOVFF  713,741
089A2:  MOVFF  70C,744
089A6:  MOVFF  70B,743
089AA:  CALL   5B02
089AE:  MOVF   01,F
089B0:  BNZ   8A08
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
089B2:  MOVLW  04
089B4:  MOVLB  7
089B6:  MOVWF  x42
089B8:  MOVLW  C1
089BA:  MOVWF  x41
089BC:  MOVLB  0
089BE:  CALL   558E
089C2:  MOVFF  02,03
089C6:  MOVF   01,W
089C8:  ADDLW  C1
089CA:  MOVLB  7
089CC:  MOVWF  x40
089CE:  MOVLW  04
089D0:  ADDWFC 02,W
089D2:  MOVWF  x41
089D4:  MOVFF  FE8,565
089D8:  MOVFF  740,564
089DC:  MOVLW  89
089DE:  MOVWF  FE9
089E0:  MOVFF  102,746
089E4:  MOVFF  101,745
089E8:  MOVFF  100,744
089EC:  MOVFF  FF,743
089F0:  MOVLW  01
089F2:  MOVWF  x47
089F4:  MOVLB  0
089F6:  CALL   5764
089FA:  MOVLW  2C
089FC:  MOVLB  7
089FE:  MOVWF  x50
08A00:  MOVLB  0
08A02:  CALL   55C6
....................    }
08A06:  BRA    8E9C
....................    else if (0 == strcmp(s_5V6, arg1)) {
08A08:  MOVFF  71A,742
08A0C:  MOVFF  719,741
08A10:  MOVFF  70C,744
08A14:  MOVFF  70B,743
08A18:  CALL   5B02
08A1C:  MOVF   01,F
08A1E:  BNZ   8A76
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08A20:  MOVLW  04
08A22:  MOVLB  7
08A24:  MOVWF  x42
08A26:  MOVLW  C1
08A28:  MOVWF  x41
08A2A:  MOVLB  0
08A2C:  CALL   558E
08A30:  MOVFF  02,03
08A34:  MOVF   01,W
08A36:  ADDLW  C1
08A38:  MOVLB  7
08A3A:  MOVWF  x40
08A3C:  MOVLW  04
08A3E:  ADDWFC 02,W
08A40:  MOVWF  x41
08A42:  MOVFF  FE8,565
08A46:  MOVFF  740,564
08A4A:  MOVLW  89
08A4C:  MOVWF  FE9
08A4E:  MOVFF  106,746
08A52:  MOVFF  105,745
08A56:  MOVFF  104,744
08A5A:  MOVFF  103,743
08A5E:  MOVLW  03
08A60:  MOVWF  x47
08A62:  MOVLB  0
08A64:  CALL   5764
08A68:  MOVLW  2C
08A6A:  MOVLB  7
08A6C:  MOVWF  x50
08A6E:  MOVLB  0
08A70:  CALL   55C6
....................    }
08A74:  BRA    8E9C
....................    else if (0 == strcmp(s_5VA, arg1)) {
08A76:  MOVFF  720,742
08A7A:  MOVFF  71F,741
08A7E:  MOVFF  70C,744
08A82:  MOVFF  70B,743
08A86:  CALL   5B02
08A8A:  MOVF   01,F
08A8C:  BNZ   8AE4
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08A8E:  MOVLW  04
08A90:  MOVLB  7
08A92:  MOVWF  x42
08A94:  MOVLW  C1
08A96:  MOVWF  x41
08A98:  MOVLB  0
08A9A:  CALL   558E
08A9E:  MOVFF  02,03
08AA2:  MOVF   01,W
08AA4:  ADDLW  C1
08AA6:  MOVLB  7
08AA8:  MOVWF  x40
08AAA:  MOVLW  04
08AAC:  ADDWFC 02,W
08AAE:  MOVWF  x41
08AB0:  MOVFF  FE8,565
08AB4:  MOVFF  740,564
08AB8:  MOVLW  89
08ABA:  MOVWF  FE9
08ABC:  MOVFF  10A,746
08AC0:  MOVFF  109,745
08AC4:  MOVFF  108,744
08AC8:  MOVFF  107,743
08ACC:  MOVLW  03
08ACE:  MOVWF  x47
08AD0:  MOVLB  0
08AD2:  CALL   5764
08AD6:  MOVLW  2C
08AD8:  MOVLB  7
08ADA:  MOVWF  x50
08ADC:  MOVLB  0
08ADE:  CALL   55C6
....................    }
08AE2:  BRA    8E9C
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08AE4:  MOVFF  726,742
08AE8:  MOVFF  725,741
08AEC:  MOVFF  70C,744
08AF0:  MOVFF  70B,743
08AF4:  CALL   5B02
08AF8:  MOVF   01,F
08AFA:  BNZ   8B52
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08AFC:  MOVLW  04
08AFE:  MOVLB  7
08B00:  MOVWF  x42
08B02:  MOVLW  C1
08B04:  MOVWF  x41
08B06:  MOVLB  0
08B08:  CALL   558E
08B0C:  MOVFF  02,03
08B10:  MOVF   01,W
08B12:  ADDLW  C1
08B14:  MOVLB  7
08B16:  MOVWF  x40
08B18:  MOVLW  04
08B1A:  ADDWFC 02,W
08B1C:  MOVWF  x41
08B1E:  MOVFF  FE8,565
08B22:  MOVFF  740,564
08B26:  MOVLW  89
08B28:  MOVWF  FE9
08B2A:  MOVFF  10E,746
08B2E:  MOVFF  10D,745
08B32:  MOVFF  10C,744
08B36:  MOVFF  10B,743
08B3A:  MOVLW  03
08B3C:  MOVWF  x47
08B3E:  MOVLB  0
08B40:  CALL   5764
08B44:  MOVLW  2C
08B46:  MOVLB  7
08B48:  MOVWF  x50
08B4A:  MOVLB  0
08B4C:  CALL   55C6
....................    }
08B50:  BRA    8E9C
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08B52:  MOVFF  72D,742
08B56:  MOVFF  72C,741
08B5A:  MOVFF  70C,744
08B5E:  MOVFF  70B,743
08B62:  CALL   5B02
08B66:  MOVF   01,F
08B68:  BNZ   8BC0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08B6A:  MOVLW  04
08B6C:  MOVLB  7
08B6E:  MOVWF  x42
08B70:  MOVLW  C1
08B72:  MOVWF  x41
08B74:  MOVLB  0
08B76:  CALL   558E
08B7A:  MOVFF  02,03
08B7E:  MOVF   01,W
08B80:  ADDLW  C1
08B82:  MOVLB  7
08B84:  MOVWF  x40
08B86:  MOVLW  04
08B88:  ADDWFC 02,W
08B8A:  MOVWF  x41
08B8C:  MOVFF  FE8,565
08B90:  MOVFF  740,564
08B94:  MOVLW  89
08B96:  MOVWF  FE9
08B98:  MOVFF  112,746
08B9C:  MOVFF  111,745
08BA0:  MOVFF  110,744
08BA4:  MOVFF  10F,743
08BA8:  MOVLW  03
08BAA:  MOVWF  x47
08BAC:  MOVLB  0
08BAE:  CALL   5764
08BB2:  MOVLW  2C
08BB4:  MOVLB  7
08BB6:  MOVWF  x50
08BB8:  MOVLB  0
08BBA:  CALL   55C6
....................    }
08BBE:  BRA    8E9C
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08BC0:  MOVFF  734,742
08BC4:  MOVFF  733,741
08BC8:  MOVFF  70C,744
08BCC:  MOVFF  70B,743
08BD0:  CALL   5B02
08BD4:  MOVF   01,F
08BD6:  BNZ   8C2E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08BD8:  MOVLW  04
08BDA:  MOVLB  7
08BDC:  MOVWF  x42
08BDE:  MOVLW  C1
08BE0:  MOVWF  x41
08BE2:  MOVLB  0
08BE4:  CALL   558E
08BE8:  MOVFF  02,03
08BEC:  MOVF   01,W
08BEE:  ADDLW  C1
08BF0:  MOVLB  7
08BF2:  MOVWF  x40
08BF4:  MOVLW  04
08BF6:  ADDWFC 02,W
08BF8:  MOVWF  x41
08BFA:  MOVFF  FE8,565
08BFE:  MOVFF  740,564
08C02:  MOVLW  89
08C04:  MOVWF  FE9
08C06:  MOVFF  116,746
08C0A:  MOVFF  115,745
08C0E:  MOVFF  114,744
08C12:  MOVFF  113,743
08C16:  MOVLW  03
08C18:  MOVWF  x47
08C1A:  MOVLB  0
08C1C:  CALL   5764
08C20:  MOVLW  2C
08C22:  MOVLB  7
08C24:  MOVWF  x50
08C26:  MOVLB  0
08C28:  CALL   55C6
....................    }
08C2C:  BRA    8E9C
....................    else if (0 == strcmp(s_all, arg1)) {
08C2E:  MOVFF  73B,742
08C32:  MOVFF  73A,741
08C36:  MOVFF  70C,744
08C3A:  MOVFF  70B,743
08C3E:  CALL   5B02
08C42:  MOVF   01,F
08C44:  BTFSS  FD8.2
08C46:  BRA    8E96
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08C48:  MOVLW  04
08C4A:  MOVLB  7
08C4C:  MOVWF  x42
08C4E:  MOVLW  C1
08C50:  MOVWF  x41
08C52:  MOVLB  0
08C54:  CALL   558E
08C58:  MOVFF  02,03
08C5C:  MOVF   01,W
08C5E:  ADDLW  C1
08C60:  MOVLB  7
08C62:  MOVWF  x40
08C64:  MOVLW  04
08C66:  ADDWFC 02,W
08C68:  MOVWF  x41
08C6A:  MOVFF  FE8,565
08C6E:  MOVFF  740,564
08C72:  MOVLW  89
08C74:  MOVWF  FE9
08C76:  MOVFF  FE,746
08C7A:  MOVFF  FD,745
08C7E:  MOVFF  FC,744
08C82:  MOVFF  FB,743
08C86:  MOVLW  02
08C88:  MOVWF  x47
08C8A:  MOVLB  0
08C8C:  CALL   5764
08C90:  MOVLW  2C
08C92:  MOVLB  7
08C94:  MOVWF  x50
08C96:  MOVLB  0
08C98:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08C9C:  MOVLW  04
08C9E:  MOVLB  7
08CA0:  MOVWF  x42
08CA2:  MOVLW  C1
08CA4:  MOVWF  x41
08CA6:  MOVLB  0
08CA8:  CALL   558E
08CAC:  MOVFF  02,03
08CB0:  MOVF   01,W
08CB2:  ADDLW  C1
08CB4:  MOVLB  7
08CB6:  MOVWF  x40
08CB8:  MOVLW  04
08CBA:  ADDWFC 02,W
08CBC:  MOVWF  x41
08CBE:  MOVFF  FE8,565
08CC2:  MOVFF  740,564
08CC6:  MOVLW  89
08CC8:  MOVWF  FE9
08CCA:  MOVFF  102,746
08CCE:  MOVFF  101,745
08CD2:  MOVFF  100,744
08CD6:  MOVFF  FF,743
08CDA:  MOVLW  01
08CDC:  MOVWF  x47
08CDE:  MOVLB  0
08CE0:  CALL   5764
08CE4:  MOVLW  2C
08CE6:  MOVLB  7
08CE8:  MOVWF  x50
08CEA:  MOVLB  0
08CEC:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08CF0:  MOVLW  04
08CF2:  MOVLB  7
08CF4:  MOVWF  x42
08CF6:  MOVLW  C1
08CF8:  MOVWF  x41
08CFA:  MOVLB  0
08CFC:  CALL   558E
08D00:  MOVFF  02,03
08D04:  MOVF   01,W
08D06:  ADDLW  C1
08D08:  MOVLB  7
08D0A:  MOVWF  x40
08D0C:  MOVLW  04
08D0E:  ADDWFC 02,W
08D10:  MOVWF  x41
08D12:  MOVFF  FE8,565
08D16:  MOVFF  740,564
08D1A:  MOVLW  89
08D1C:  MOVWF  FE9
08D1E:  MOVFF  106,746
08D22:  MOVFF  105,745
08D26:  MOVFF  104,744
08D2A:  MOVFF  103,743
08D2E:  MOVLW  03
08D30:  MOVWF  x47
08D32:  MOVLB  0
08D34:  CALL   5764
08D38:  MOVLW  2C
08D3A:  MOVLB  7
08D3C:  MOVWF  x50
08D3E:  MOVLB  0
08D40:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08D44:  MOVLW  04
08D46:  MOVLB  7
08D48:  MOVWF  x42
08D4A:  MOVLW  C1
08D4C:  MOVWF  x41
08D4E:  MOVLB  0
08D50:  CALL   558E
08D54:  MOVFF  02,03
08D58:  MOVF   01,W
08D5A:  ADDLW  C1
08D5C:  MOVLB  7
08D5E:  MOVWF  x40
08D60:  MOVLW  04
08D62:  ADDWFC 02,W
08D64:  MOVWF  x41
08D66:  MOVFF  FE8,565
08D6A:  MOVFF  740,564
08D6E:  MOVLW  89
08D70:  MOVWF  FE9
08D72:  MOVFF  10A,746
08D76:  MOVFF  109,745
08D7A:  MOVFF  108,744
08D7E:  MOVFF  107,743
08D82:  MOVLW  03
08D84:  MOVWF  x47
08D86:  MOVLB  0
08D88:  CALL   5764
08D8C:  MOVLW  2C
08D8E:  MOVLB  7
08D90:  MOVWF  x50
08D92:  MOVLB  0
08D94:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08D98:  MOVLW  04
08D9A:  MOVLB  7
08D9C:  MOVWF  x42
08D9E:  MOVLW  C1
08DA0:  MOVWF  x41
08DA2:  MOVLB  0
08DA4:  CALL   558E
08DA8:  MOVFF  02,03
08DAC:  MOVF   01,W
08DAE:  ADDLW  C1
08DB0:  MOVLB  7
08DB2:  MOVWF  x40
08DB4:  MOVLW  04
08DB6:  ADDWFC 02,W
08DB8:  MOVWF  x41
08DBA:  MOVFF  FE8,565
08DBE:  MOVFF  740,564
08DC2:  MOVLW  89
08DC4:  MOVWF  FE9
08DC6:  MOVFF  10E,746
08DCA:  MOVFF  10D,745
08DCE:  MOVFF  10C,744
08DD2:  MOVFF  10B,743
08DD6:  MOVLW  03
08DD8:  MOVWF  x47
08DDA:  MOVLB  0
08DDC:  CALL   5764
08DE0:  MOVLW  2C
08DE2:  MOVLB  7
08DE4:  MOVWF  x50
08DE6:  MOVLB  0
08DE8:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08DEC:  MOVLW  04
08DEE:  MOVLB  7
08DF0:  MOVWF  x42
08DF2:  MOVLW  C1
08DF4:  MOVWF  x41
08DF6:  MOVLB  0
08DF8:  CALL   558E
08DFC:  MOVFF  02,03
08E00:  MOVF   01,W
08E02:  ADDLW  C1
08E04:  MOVLB  7
08E06:  MOVWF  x40
08E08:  MOVLW  04
08E0A:  ADDWFC 02,W
08E0C:  MOVWF  x41
08E0E:  MOVFF  FE8,565
08E12:  MOVFF  740,564
08E16:  MOVLW  89
08E18:  MOVWF  FE9
08E1A:  MOVFF  112,746
08E1E:  MOVFF  111,745
08E22:  MOVFF  110,744
08E26:  MOVFF  10F,743
08E2A:  MOVLW  03
08E2C:  MOVWF  x47
08E2E:  MOVLB  0
08E30:  CALL   5764
08E34:  MOVLW  2C
08E36:  MOVLB  7
08E38:  MOVWF  x50
08E3A:  MOVLB  0
08E3C:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08E40:  MOVLW  04
08E42:  MOVLB  7
08E44:  MOVWF  x42
08E46:  MOVLW  C1
08E48:  MOVWF  x41
08E4A:  MOVLB  0
08E4C:  CALL   558E
08E50:  MOVFF  02,03
08E54:  MOVF   01,W
08E56:  ADDLW  C1
08E58:  MOVLB  7
08E5A:  MOVWF  x40
08E5C:  MOVLW  04
08E5E:  ADDWFC 02,W
08E60:  MOVWF  x41
08E62:  MOVFF  FE8,565
08E66:  MOVFF  740,564
08E6A:  MOVLW  89
08E6C:  MOVWF  FE9
08E6E:  MOVFF  116,746
08E72:  MOVFF  115,745
08E76:  MOVFF  114,744
08E7A:  MOVFF  113,743
08E7E:  MOVLW  03
08E80:  MOVWF  x47
08E82:  MOVLB  0
08E84:  CALL   5764
08E88:  MOVLW  2C
08E8A:  MOVLB  7
08E8C:  MOVWF  x50
08E8E:  MOVLB  0
08E90:  CALL   55C6
....................    }
08E94:  BRA    8E9C
....................    else return INV_PARAM;
08E96:  MOVLW  02
08E98:  MOVWF  01
08E9A:  BRA    8EA0
....................    
....................    return SUCCESS;
08E9C:  MOVLW  00
08E9E:  MOVWF  01
08EA0:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08EA2:  MOVLW  50
08EA4:  MOVLB  7
08EA6:  MOVWF  x10
08EA8:  MOVLW  56
08EAA:  MOVWF  x11
08EAC:  CLRF   x12
08EAE:  MOVLW  07
08EB0:  MOVWF  x0F
08EB2:  MOVLW  10
08EB4:  MOVWF  x0E
....................    char *s_CV = "CV";
08EB6:  MOVLW  43
08EB8:  MOVWF  x15
08EBA:  MOVLW  56
08EBC:  MOVWF  x16
08EBE:  CLRF   x17
08EC0:  MOVLW  07
08EC2:  MOVWF  x14
08EC4:  MOVLW  15
08EC6:  MOVWF  x13
....................    char *s_PVold = "PVold";
08EC8:  MOVLW  50
08ECA:  MOVWF  x1A
08ECC:  MOVLW  56
08ECE:  MOVWF  x1B
08ED0:  MOVLW  6F
08ED2:  MOVWF  x1C
08ED4:  MOVLW  6C
08ED6:  MOVWF  x1D
08ED8:  MOVLW  64
08EDA:  MOVWF  x1E
08EDC:  CLRF   x1F
08EDE:  MOVLW  07
08EE0:  MOVWF  x19
08EE2:  MOVLW  1A
08EE4:  MOVWF  x18
....................    char *s_I = "I";
08EE6:  MOVLW  49
08EE8:  MOVWF  x22
08EEA:  CLRF   x23
08EEC:  MOVLW  07
08EEE:  MOVWF  x21
08EF0:  MOVLW  22
08EF2:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08EF4:  CLRF   x42
08EF6:  MOVFF  690,741
08EFA:  CLRF   x44
08EFC:  MOVLW  B5
08EFE:  MOVWF  x43
08F00:  MOVLB  0
08F02:  CALL   08AC
08F06:  MOVFF  02,725
08F0A:  MOVFF  01,724
08F0E:  MOVLW  06
08F10:  MOVLB  7
08F12:  ADDWF  x24,F
08F14:  MOVLW  00
08F16:  ADDWFC x25,F
08F18:  MOVLW  32
08F1A:  ADDWF  x24,W
08F1C:  MOVWF  01
08F1E:  MOVLW  00
08F20:  ADDWFC x25,W
08F22:  MOVWF  03
08F24:  MOVF   01,W
08F26:  ADDLW  EB
08F28:  MOVWF  01
08F2A:  MOVLW  01
08F2C:  ADDWFC 03,F
08F2E:  MOVFF  01,724
08F32:  MOVFF  03,725
08F36:  MOVFF  03,734
08F3A:  MOVFF  01,733
08F3E:  MOVLB  0
08F40:  CALL   5C22
08F44:  MOVF   01,F
08F46:  BNZ   8F50
08F48:  MOVLW  02
08F4A:  MOVWF  01
08F4C:  BRA    92E6
08F4E:  BRA    8FAE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08F50:  MOVLB  7
08F52:  CLRF   x42
08F54:  MOVFF  690,741
08F58:  CLRF   x44
08F5A:  MOVLW  B5
08F5C:  MOVWF  x43
08F5E:  MOVLB  0
08F60:  CALL   08AC
08F64:  MOVFF  02,725
08F68:  MOVFF  01,724
08F6C:  MOVLW  06
08F6E:  MOVLB  7
08F70:  ADDWF  x24,F
08F72:  MOVLW  00
08F74:  ADDWFC x25,F
08F76:  MOVLW  32
08F78:  ADDWF  x24,W
08F7A:  MOVWF  01
08F7C:  MOVLW  00
08F7E:  ADDWFC x25,W
08F80:  MOVWF  03
08F82:  MOVF   01,W
08F84:  ADDLW  EB
08F86:  MOVWF  01
08F88:  MOVLW  01
08F8A:  ADDWFC 03,F
08F8C:  MOVFF  01,724
08F90:  MOVFF  03,725
08F94:  MOVFF  03,734
08F98:  MOVFF  01,733
08F9C:  CLRF   x36
08F9E:  CLRF   x35
08FA0:  MOVLW  0A
08FA2:  MOVWF  x37
08FA4:  MOVLB  0
08FA6:  CALL   5D12
08FAA:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
08FAE:  MOVLB  7
08FB0:  CLRF   x42
08FB2:  MOVFF  690,741
08FB6:  CLRF   x44
08FB8:  MOVLW  B5
08FBA:  MOVWF  x43
08FBC:  MOVLB  0
08FBE:  CALL   08AC
08FC2:  MOVFF  02,725
08FC6:  MOVFF  01,724
08FCA:  MOVLW  06
08FCC:  MOVLB  7
08FCE:  ADDWF  x24,F
08FD0:  MOVLW  00
08FD2:  ADDWFC x25,F
08FD4:  MOVLW  4B
08FD6:  ADDWF  x24,W
08FD8:  MOVWF  01
08FDA:  MOVLW  00
08FDC:  ADDWFC x25,W
08FDE:  MOVWF  03
08FE0:  MOVF   01,W
08FE2:  ADDLW  EB
08FE4:  MOVWF  01
08FE6:  MOVLW  01
08FE8:  ADDWFC 03,F
08FEA:  MOVFF  01,70C
08FEE:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08FF2:  MOVFF  70F,742
08FF6:  MOVFF  70E,741
08FFA:  MOVFF  70D,744
08FFE:  MOVFF  70C,743
09002:  MOVLB  0
09004:  CALL   5B02
09008:  MOVF   01,F
0900A:  BNZ   90AE
0900C:  MOVLW  04
0900E:  MOVLB  7
09010:  MOVWF  x42
09012:  MOVLW  C1
09014:  MOVWF  x41
09016:  MOVLB  0
09018:  CALL   558E
0901C:  MOVF   01,W
0901E:  ADDLW  C1
09020:  MOVLB  7
09022:  MOVWF  x24
09024:  MOVLW  04
09026:  ADDWFC 02,W
09028:  MOVWF  x25
0902A:  MOVLW  01
0902C:  SUBWF  x0B,W
0902E:  MULLW  28
09030:  MOVF   FF3,W
09032:  CLRF   x27
09034:  MOVWF  x26
09036:  MOVLW  10
09038:  ADDWF  x26,W
0903A:  MOVWF  01
0903C:  MOVLW  00
0903E:  ADDWFC x27,W
09040:  MOVWF  03
09042:  MOVF   01,W
09044:  ADDLW  20
09046:  MOVWF  FE9
09048:  MOVLW  00
0904A:  ADDWFC 03,W
0904C:  MOVWF  FEA
0904E:  MOVFF  FEF,726
09052:  MOVFF  FEC,727
09056:  MOVFF  FEC,728
0905A:  MOVFF  FEC,729
0905E:  MOVFF  725,565
09062:  MOVFF  724,564
09066:  MOVFF  70B,734
0906A:  MOVLW  18
0906C:  MOVWF  x35
0906E:  MOVLB  0
09070:  CALL   6066
09074:  MOVLW  2C
09076:  MOVLB  7
09078:  MOVWF  x50
0907A:  MOVLB  0
0907C:  CALL   55C6
09080:  MOVLW  89
09082:  MOVWF  FE9
09084:  MOVFF  729,746
09088:  MOVFF  728,745
0908C:  MOVFF  727,744
09090:  MOVFF  726,743
09094:  MOVLW  02
09096:  MOVLB  7
09098:  MOVWF  x47
0909A:  MOVLB  0
0909C:  CALL   5764
090A0:  MOVLW  2C
090A2:  MOVLB  7
090A4:  MOVWF  x50
090A6:  MOVLB  0
090A8:  CALL   55C6
090AC:  BRA    92E2
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
090AE:  MOVFF  714,742
090B2:  MOVFF  713,741
090B6:  MOVFF  70D,744
090BA:  MOVFF  70C,743
090BE:  CALL   5B02
090C2:  MOVF   01,F
090C4:  BNZ   9168
090C6:  MOVLW  04
090C8:  MOVLB  7
090CA:  MOVWF  x42
090CC:  MOVLW  C1
090CE:  MOVWF  x41
090D0:  MOVLB  0
090D2:  CALL   558E
090D6:  MOVF   01,W
090D8:  ADDLW  C1
090DA:  MOVLB  7
090DC:  MOVWF  x24
090DE:  MOVLW  04
090E0:  ADDWFC 02,W
090E2:  MOVWF  x25
090E4:  MOVLW  01
090E6:  SUBWF  x0B,W
090E8:  MULLW  28
090EA:  MOVF   FF3,W
090EC:  CLRF   x27
090EE:  MOVWF  x26
090F0:  MOVLW  18
090F2:  ADDWF  x26,W
090F4:  MOVWF  01
090F6:  MOVLW  00
090F8:  ADDWFC x27,W
090FA:  MOVWF  03
090FC:  MOVF   01,W
090FE:  ADDLW  20
09100:  MOVWF  FE9
09102:  MOVLW  00
09104:  ADDWFC 03,W
09106:  MOVWF  FEA
09108:  MOVFF  FEF,726
0910C:  MOVFF  FEC,727
09110:  MOVFF  FEC,728
09114:  MOVFF  FEC,729
09118:  MOVFF  725,565
0911C:  MOVFF  724,564
09120:  MOVFF  70B,734
09124:  MOVLW  18
09126:  MOVWF  x35
09128:  MOVLB  0
0912A:  CALL   6066
0912E:  MOVLW  2C
09130:  MOVLB  7
09132:  MOVWF  x50
09134:  MOVLB  0
09136:  CALL   55C6
0913A:  MOVLW  89
0913C:  MOVWF  FE9
0913E:  MOVFF  729,746
09142:  MOVFF  728,745
09146:  MOVFF  727,744
0914A:  MOVFF  726,743
0914E:  MOVLW  02
09150:  MOVLB  7
09152:  MOVWF  x47
09154:  MOVLB  0
09156:  CALL   5764
0915A:  MOVLW  2C
0915C:  MOVLB  7
0915E:  MOVWF  x50
09160:  MOVLB  0
09162:  CALL   55C6
09166:  BRA    92E2
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09168:  MOVFF  719,742
0916C:  MOVFF  718,741
09170:  MOVFF  70D,744
09174:  MOVFF  70C,743
09178:  CALL   5B02
0917C:  MOVF   01,F
0917E:  BNZ   9222
09180:  MOVLW  04
09182:  MOVLB  7
09184:  MOVWF  x42
09186:  MOVLW  C1
09188:  MOVWF  x41
0918A:  MOVLB  0
0918C:  CALL   558E
09190:  MOVF   01,W
09192:  ADDLW  C1
09194:  MOVLB  7
09196:  MOVWF  x24
09198:  MOVLW  04
0919A:  ADDWFC 02,W
0919C:  MOVWF  x25
0919E:  MOVLW  01
091A0:  SUBWF  x0B,W
091A2:  MULLW  28
091A4:  MOVF   FF3,W
091A6:  CLRF   x27
091A8:  MOVWF  x26
091AA:  MOVLW  14
091AC:  ADDWF  x26,W
091AE:  MOVWF  01
091B0:  MOVLW  00
091B2:  ADDWFC x27,W
091B4:  MOVWF  03
091B6:  MOVF   01,W
091B8:  ADDLW  20
091BA:  MOVWF  FE9
091BC:  MOVLW  00
091BE:  ADDWFC 03,W
091C0:  MOVWF  FEA
091C2:  MOVFF  FEF,726
091C6:  MOVFF  FEC,727
091CA:  MOVFF  FEC,728
091CE:  MOVFF  FEC,729
091D2:  MOVFF  725,565
091D6:  MOVFF  724,564
091DA:  MOVFF  70B,734
091DE:  MOVLW  18
091E0:  MOVWF  x35
091E2:  MOVLB  0
091E4:  CALL   6066
091E8:  MOVLW  2C
091EA:  MOVLB  7
091EC:  MOVWF  x50
091EE:  MOVLB  0
091F0:  CALL   55C6
091F4:  MOVLW  89
091F6:  MOVWF  FE9
091F8:  MOVFF  729,746
091FC:  MOVFF  728,745
09200:  MOVFF  727,744
09204:  MOVFF  726,743
09208:  MOVLW  02
0920A:  MOVLB  7
0920C:  MOVWF  x47
0920E:  MOVLB  0
09210:  CALL   5764
09214:  MOVLW  2C
09216:  MOVLB  7
09218:  MOVWF  x50
0921A:  MOVLB  0
0921C:  CALL   55C6
09220:  BRA    92E2
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09222:  MOVFF  721,742
09226:  MOVFF  720,741
0922A:  MOVFF  70D,744
0922E:  MOVFF  70C,743
09232:  CALL   5B02
09236:  MOVF   01,F
09238:  BNZ   92DC
0923A:  MOVLW  04
0923C:  MOVLB  7
0923E:  MOVWF  x42
09240:  MOVLW  C1
09242:  MOVWF  x41
09244:  MOVLB  0
09246:  CALL   558E
0924A:  MOVF   01,W
0924C:  ADDLW  C1
0924E:  MOVLB  7
09250:  MOVWF  x24
09252:  MOVLW  04
09254:  ADDWFC 02,W
09256:  MOVWF  x25
09258:  MOVLW  01
0925A:  SUBWF  x0B,W
0925C:  MULLW  28
0925E:  MOVF   FF3,W
09260:  CLRF   x27
09262:  MOVWF  x26
09264:  MOVLW  1C
09266:  ADDWF  x26,W
09268:  MOVWF  01
0926A:  MOVLW  00
0926C:  ADDWFC x27,W
0926E:  MOVWF  03
09270:  MOVF   01,W
09272:  ADDLW  20
09274:  MOVWF  FE9
09276:  MOVLW  00
09278:  ADDWFC 03,W
0927A:  MOVWF  FEA
0927C:  MOVFF  FEF,726
09280:  MOVFF  FEC,727
09284:  MOVFF  FEC,728
09288:  MOVFF  FEC,729
0928C:  MOVFF  725,565
09290:  MOVFF  724,564
09294:  MOVFF  70B,734
09298:  MOVLW  18
0929A:  MOVWF  x35
0929C:  MOVLB  0
0929E:  CALL   6066
092A2:  MOVLW  2C
092A4:  MOVLB  7
092A6:  MOVWF  x50
092A8:  MOVLB  0
092AA:  CALL   55C6
092AE:  MOVLW  89
092B0:  MOVWF  FE9
092B2:  MOVFF  729,746
092B6:  MOVFF  728,745
092BA:  MOVFF  727,744
092BE:  MOVFF  726,743
092C2:  MOVLW  02
092C4:  MOVLB  7
092C6:  MOVWF  x47
092C8:  MOVLB  0
092CA:  CALL   5764
092CE:  MOVLW  2C
092D0:  MOVLB  7
092D2:  MOVWF  x50
092D4:  MOVLB  0
092D6:  CALL   55C6
092DA:  BRA    92E2
....................    else return INV_PARAM;
092DC:  MOVLW  02
092DE:  MOVWF  01
092E0:  BRA    92E6
....................    
....................    return SUCCESS;
092E2:  MOVLW  00
092E4:  MOVWF  01
092E6:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09406:  MOVLW  72
09408:  MOVLB  7
0940A:  MOVWF  x10
0940C:  MOVLW  61
0940E:  MOVWF  x11
09410:  MOVLW  77
09412:  MOVWF  x12
09414:  CLRF   x13
09416:  MOVLW  07
09418:  MOVWF  x0F
0941A:  MOVLW  10
0941C:  MOVWF  x0E
....................    char *s_calibrated = "calib";
0941E:  MOVLW  63
09420:  MOVWF  x16
09422:  MOVLW  61
09424:  MOVWF  x17
09426:  MOVLW  6C
09428:  MOVWF  x18
0942A:  MOVLW  69
0942C:  MOVWF  x19
0942E:  MOVLW  62
09430:  MOVWF  x1A
09432:  CLRF   x1B
09434:  MOVLW  07
09436:  MOVWF  x15
09438:  MOVLW  16
0943A:  MOVWF  x14
....................    char *s_p0 = "p0";
0943C:  MOVLW  70
0943E:  MOVWF  x1E
09440:  MOVLW  30
09442:  MOVWF  x1F
09444:  CLRF   x20
09446:  MOVLW  07
09448:  MOVWF  x1D
0944A:  MOVLW  1E
0944C:  MOVWF  x1C
....................    char *s_poles = "poles";
0944E:  MOVLW  70
09450:  MOVWF  x23
09452:  MOVLW  6F
09454:  MOVWF  x24
09456:  MOVLW  6C
09458:  MOVWF  x25
0945A:  MOVLW  65
0945C:  MOVWF  x26
0945E:  MOVLW  73
09460:  MOVWF  x27
09462:  CLRF   x28
09464:  MOVLW  07
09466:  MOVWF  x22
09468:  MOVLW  23
0946A:  MOVWF  x21
....................    char *s_real = "real";
0946C:  MOVLW  72
0946E:  MOVWF  x2B
09470:  MOVLW  65
09472:  MOVWF  x2C
09474:  MOVLW  61
09476:  MOVWF  x2D
09478:  MOVLW  6C
0947A:  MOVWF  x2E
0947C:  CLRF   x2F
0947E:  MOVLW  07
09480:  MOVWF  x2A
09482:  MOVLW  2B
09484:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09486:  CLRF   x42
09488:  MOVFF  690,741
0948C:  CLRF   x44
0948E:  MOVLW  B5
09490:  MOVWF  x43
09492:  MOVLB  0
09494:  CALL   08AC
09498:  MOVFF  02,731
0949C:  MOVFF  01,730
094A0:  MOVLW  06
094A2:  MOVLB  7
094A4:  ADDWF  x30,F
094A6:  MOVLW  00
094A8:  ADDWFC x31,F
094AA:  MOVLW  32
094AC:  ADDWF  x30,W
094AE:  MOVWF  01
094B0:  MOVLW  00
094B2:  ADDWFC x31,W
094B4:  MOVWF  03
094B6:  MOVF   01,W
094B8:  ADDLW  EB
094BA:  MOVWF  01
094BC:  MOVLW  01
094BE:  ADDWFC 03,F
094C0:  MOVFF  01,730
094C4:  MOVFF  03,731
094C8:  MOVFF  03,734
094CC:  MOVFF  01,733
094D0:  MOVLB  0
094D2:  CALL   5C22
094D6:  MOVF   01,F
094D8:  BNZ   94E2
094DA:  MOVLW  02
094DC:  MOVWF  01
094DE:  BRA    9B26
094E0:  BRA    9540
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094E2:  MOVLB  7
094E4:  CLRF   x42
094E6:  MOVFF  690,741
094EA:  CLRF   x44
094EC:  MOVLW  B5
094EE:  MOVWF  x43
094F0:  MOVLB  0
094F2:  CALL   08AC
094F6:  MOVFF  02,731
094FA:  MOVFF  01,730
094FE:  MOVLW  06
09500:  MOVLB  7
09502:  ADDWF  x30,F
09504:  MOVLW  00
09506:  ADDWFC x31,F
09508:  MOVLW  32
0950A:  ADDWF  x30,W
0950C:  MOVWF  01
0950E:  MOVLW  00
09510:  ADDWFC x31,W
09512:  MOVWF  03
09514:  MOVF   01,W
09516:  ADDLW  EB
09518:  MOVWF  01
0951A:  MOVLW  01
0951C:  ADDWFC 03,F
0951E:  MOVFF  01,730
09522:  MOVFF  03,731
09526:  MOVFF  03,734
0952A:  MOVFF  01,733
0952E:  CLRF   x36
09530:  CLRF   x35
09532:  MOVLW  0A
09534:  MOVWF  x37
09536:  MOVLB  0
09538:  CALL   5D12
0953C:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
09540:  MOVLB  7
09542:  CLRF   x42
09544:  MOVFF  690,741
09548:  CLRF   x44
0954A:  MOVLW  B5
0954C:  MOVWF  x43
0954E:  MOVLB  0
09550:  CALL   08AC
09554:  MOVFF  02,731
09558:  MOVFF  01,730
0955C:  MOVLW  06
0955E:  MOVLB  7
09560:  ADDWF  x30,F
09562:  MOVLW  00
09564:  ADDWFC x31,F
09566:  MOVLW  4B
09568:  ADDWF  x30,W
0956A:  MOVWF  01
0956C:  MOVLW  00
0956E:  ADDWFC x31,W
09570:  MOVWF  03
09572:  MOVF   01,W
09574:  ADDLW  EB
09576:  MOVWF  01
09578:  MOVLW  01
0957A:  ADDWFC 03,F
0957C:  MOVFF  01,70C
09580:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09584:  MOVFF  70F,742
09588:  MOVFF  70E,741
0958C:  MOVFF  70D,744
09590:  MOVFF  70C,743
09594:  MOVLB  0
09596:  CALL   5B02
0959A:  MOVF   01,F
0959C:  BTFSS  FD8.2
0959E:  BRA    971A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
095A0:  MOVLW  04
095A2:  MOVLB  7
095A4:  MOVWF  x42
095A6:  MOVLW  C1
095A8:  MOVWF  x41
095AA:  MOVLB  0
095AC:  CALL   558E
095B0:  MOVFF  02,03
095B4:  MOVF   01,W
095B6:  ADDLW  C1
095B8:  MOVLB  7
095BA:  MOVWF  x30
095BC:  MOVLW  04
095BE:  ADDWFC 02,W
095C0:  MOVWF  x31
095C2:  MOVFF  FE8,565
095C6:  MOVFF  730,564
095CA:  MOVFF  70B,734
095CE:  MOVLW  18
095D0:  MOVWF  x35
095D2:  MOVLB  0
095D4:  CALL   6066
095D8:  MOVLW  2C
095DA:  MOVLB  7
095DC:  MOVWF  x50
095DE:  MOVLB  0
095E0:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
095E4:  MOVLW  04
095E6:  MOVLB  7
095E8:  MOVWF  x42
095EA:  MOVLW  C1
095EC:  MOVWF  x41
095EE:  MOVLB  0
095F0:  CALL   558E
095F4:  MOVFF  02,03
095F8:  MOVF   01,W
095FA:  ADDLW  C1
095FC:  MOVLB  7
095FE:  MOVWF  x30
09600:  MOVLW  04
09602:  ADDWFC 02,W
09604:  MOVWF  x31
09606:  MOVLW  01
09608:  SUBWF  x0B,W
0960A:  MULLW  26
0960C:  MOVF   FF3,W
0960E:  CLRF   x33
09610:  MOVWF  x32
09612:  MOVLW  17
09614:  ADDWF  x32,W
09616:  MOVWF  FE9
09618:  MOVLW  01
0961A:  ADDWFC x33,W
0961C:  MOVWF  FEA
0961E:  MOVFF  FEF,750
09622:  MOVFF  FEC,01
09626:  MOVFF  FEC,02
0962A:  MOVFF  FEC,03
0962E:  MOVFF  03,753
09632:  MOVFF  02,752
09636:  MOVFF  01,751
0963A:  MOVLB  0
0963C:  CALL   568E
09640:  MOVFF  03,737
09644:  MOVFF  02,736
09648:  MOVFF  01,735
0964C:  MOVFF  00,734
09650:  MOVFF  731,565
09654:  MOVFF  730,564
09658:  MOVLW  41
0965A:  MOVWF  FE9
0965C:  MOVFF  03,73C
09660:  MOVFF  02,73B
09664:  MOVFF  01,73A
09668:  MOVFF  00,739
0966C:  RCALL  92E8
0966E:  MOVLW  2C
09670:  MOVLB  7
09672:  MOVWF  x50
09674:  MOVLB  0
09676:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0967A:  MOVLW  04
0967C:  MOVLB  7
0967E:  MOVWF  x42
09680:  MOVLW  C1
09682:  MOVWF  x41
09684:  MOVLB  0
09686:  CALL   558E
0968A:  MOVF   01,W
0968C:  ADDLW  C1
0968E:  MOVLB  7
09690:  MOVWF  x30
09692:  MOVLW  04
09694:  ADDWFC 02,W
09696:  MOVWF  x31
09698:  MOVLW  01
0969A:  SUBWF  x0B,W
0969C:  MULLW  26
0969E:  MOVF   FF3,W
096A0:  CLRF   x33
096A2:  MOVWF  x32
096A4:  MOVLW  04
096A6:  ADDWF  x32,W
096A8:  MOVWF  01
096AA:  MOVLW  00
096AC:  ADDWFC x33,W
096AE:  MOVWF  03
096B0:  MOVF   01,W
096B2:  ADDLW  17
096B4:  MOVWF  FE9
096B6:  MOVLW  01
096B8:  ADDWFC 03,W
096BA:  MOVWF  FEA
096BC:  MOVFF  FEF,750
096C0:  MOVFF  FEC,01
096C4:  MOVFF  FEC,02
096C8:  MOVFF  FEC,03
096CC:  MOVFF  03,753
096D0:  MOVFF  02,752
096D4:  MOVFF  01,751
096D8:  MOVLB  0
096DA:  CALL   568E
096DE:  MOVFF  03,735
096E2:  MOVFF  02,734
096E6:  MOVFF  01,733
096EA:  MOVFF  00,732
096EE:  MOVFF  731,565
096F2:  MOVFF  730,564
096F6:  MOVLW  41
096F8:  MOVWF  FE9
096FA:  MOVFF  03,73C
096FE:  MOVFF  02,73B
09702:  MOVFF  01,73A
09706:  MOVFF  00,739
0970A:  RCALL  92E8
0970C:  MOVLW  2C
0970E:  MOVLB  7
09710:  MOVWF  x50
09712:  MOVLB  0
09714:  CALL   55C6
....................    }
09718:  BRA    9B22
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0971A:  MOVFF  715,742
0971E:  MOVFF  714,741
09722:  MOVFF  70D,744
09726:  MOVFF  70C,743
0972A:  CALL   5B02
0972E:  MOVF   01,F
09730:  BTFSS  FD8.2
09732:  BRA    98B6
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09734:  MOVLW  04
09736:  MOVLB  7
09738:  MOVWF  x42
0973A:  MOVLW  C1
0973C:  MOVWF  x41
0973E:  MOVLB  0
09740:  CALL   558E
09744:  MOVFF  02,03
09748:  MOVF   01,W
0974A:  ADDLW  C1
0974C:  MOVLB  7
0974E:  MOVWF  x30
09750:  MOVLW  04
09752:  ADDWFC 02,W
09754:  MOVWF  x31
09756:  MOVFF  FE8,565
0975A:  MOVFF  730,564
0975E:  MOVFF  70B,734
09762:  MOVLW  18
09764:  MOVWF  x35
09766:  MOVLB  0
09768:  CALL   6066
0976C:  MOVLW  2C
0976E:  MOVLB  7
09770:  MOVWF  x50
09772:  MOVLB  0
09774:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09778:  MOVLW  04
0977A:  MOVLB  7
0977C:  MOVWF  x42
0977E:  MOVLW  C1
09780:  MOVWF  x41
09782:  MOVLB  0
09784:  CALL   558E
09788:  MOVF   01,W
0978A:  ADDLW  C1
0978C:  MOVLB  7
0978E:  MOVWF  x30
09790:  MOVLW  04
09792:  ADDWFC 02,W
09794:  MOVWF  x31
09796:  MOVLW  01
09798:  SUBWF  x0B,W
0979A:  MULLW  26
0979C:  MOVF   FF3,W
0979E:  CLRF   x33
097A0:  MOVWF  x32
097A2:  MOVLW  08
097A4:  ADDWF  x32,W
097A6:  MOVWF  01
097A8:  MOVLW  00
097AA:  ADDWFC x33,W
097AC:  MOVWF  03
097AE:  MOVF   01,W
097B0:  ADDLW  17
097B2:  MOVWF  FE9
097B4:  MOVLW  01
097B6:  ADDWFC 03,W
097B8:  MOVWF  FEA
097BA:  MOVFF  FEF,750
097BE:  MOVFF  FEC,01
097C2:  MOVFF  FEC,02
097C6:  MOVFF  FEC,03
097CA:  MOVFF  03,753
097CE:  MOVFF  02,752
097D2:  MOVFF  01,751
097D6:  MOVLB  0
097D8:  CALL   568E
097DC:  MOVFF  03,735
097E0:  MOVFF  02,734
097E4:  MOVFF  01,733
097E8:  MOVFF  00,732
097EC:  MOVFF  731,565
097F0:  MOVFF  730,564
097F4:  MOVLW  41
097F6:  MOVWF  FE9
097F8:  MOVFF  03,73C
097FC:  MOVFF  02,73B
09800:  MOVFF  01,73A
09804:  MOVFF  00,739
09808:  RCALL  92E8
0980A:  MOVLW  2C
0980C:  MOVLB  7
0980E:  MOVWF  x50
09810:  MOVLB  0
09812:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09816:  MOVLW  04
09818:  MOVLB  7
0981A:  MOVWF  x42
0981C:  MOVLW  C1
0981E:  MOVWF  x41
09820:  MOVLB  0
09822:  CALL   558E
09826:  MOVF   01,W
09828:  ADDLW  C1
0982A:  MOVLB  7
0982C:  MOVWF  x30
0982E:  MOVLW  04
09830:  ADDWFC 02,W
09832:  MOVWF  x31
09834:  MOVLW  01
09836:  SUBWF  x0B,W
09838:  MULLW  26
0983A:  MOVF   FF3,W
0983C:  CLRF   x33
0983E:  MOVWF  x32
09840:  MOVLW  0C
09842:  ADDWF  x32,W
09844:  MOVWF  01
09846:  MOVLW  00
09848:  ADDWFC x33,W
0984A:  MOVWF  03
0984C:  MOVF   01,W
0984E:  ADDLW  17
09850:  MOVWF  FE9
09852:  MOVLW  01
09854:  ADDWFC 03,W
09856:  MOVWF  FEA
09858:  MOVFF  FEF,750
0985C:  MOVFF  FEC,01
09860:  MOVFF  FEC,02
09864:  MOVFF  FEC,03
09868:  MOVFF  03,753
0986C:  MOVFF  02,752
09870:  MOVFF  01,751
09874:  MOVLB  0
09876:  CALL   568E
0987A:  MOVFF  03,735
0987E:  MOVFF  02,734
09882:  MOVFF  01,733
09886:  MOVFF  00,732
0988A:  MOVFF  731,565
0988E:  MOVFF  730,564
09892:  MOVLW  41
09894:  MOVWF  FE9
09896:  MOVFF  03,73C
0989A:  MOVFF  02,73B
0989E:  MOVFF  01,73A
098A2:  MOVFF  00,739
098A6:  RCALL  92E8
098A8:  MOVLW  2C
098AA:  MOVLB  7
098AC:  MOVWF  x50
098AE:  MOVLB  0
098B0:  CALL   55C6
....................    }
098B4:  BRA    9B22
....................    else if (0 == strcmp(s_p0, arg2)) {
098B6:  MOVFF  71D,742
098BA:  MOVFF  71C,741
098BE:  MOVFF  70D,744
098C2:  MOVFF  70C,743
098C6:  CALL   5B02
098CA:  MOVF   01,F
098CC:  BNZ   9988
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098CE:  MOVLW  04
098D0:  MOVLB  7
098D2:  MOVWF  x42
098D4:  MOVLW  C1
098D6:  MOVWF  x41
098D8:  MOVLB  0
098DA:  CALL   558E
098DE:  MOVFF  02,03
098E2:  MOVF   01,W
098E4:  ADDLW  C1
098E6:  MOVLB  7
098E8:  MOVWF  x30
098EA:  MOVLW  04
098EC:  ADDWFC 02,W
098EE:  MOVWF  x31
098F0:  MOVFF  FE8,565
098F4:  MOVFF  730,564
098F8:  MOVFF  70B,734
098FC:  MOVLW  18
098FE:  MOVWF  x35
09900:  MOVLB  0
09902:  CALL   6066
09906:  MOVLW  2C
09908:  MOVLB  7
0990A:  MOVWF  x50
0990C:  MOVLB  0
0990E:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09912:  MOVLW  04
09914:  MOVLB  7
09916:  MOVWF  x42
09918:  MOVLW  C1
0991A:  MOVWF  x41
0991C:  MOVLB  0
0991E:  CALL   558E
09922:  MOVF   01,W
09924:  ADDLW  C1
09926:  MOVLB  7
09928:  MOVWF  x30
0992A:  MOVLW  04
0992C:  ADDWFC 02,W
0992E:  MOVWF  x31
09930:  MOVLW  01
09932:  SUBWF  x0B,W
09934:  MULLW  26
09936:  MOVF   FF3,W
09938:  CLRF   x33
0993A:  MOVWF  x32
0993C:  MOVLW  18
0993E:  ADDWF  x32,W
09940:  MOVWF  01
09942:  MOVLW  00
09944:  ADDWFC x33,W
09946:  MOVWF  03
09948:  MOVF   01,W
0994A:  ADDLW  17
0994C:  MOVWF  FE9
0994E:  MOVLW  01
09950:  ADDWFC 03,W
09952:  MOVWF  FEA
09954:  MOVFF  FEF,743
09958:  MOVFF  FEC,744
0995C:  MOVFF  FEC,745
09960:  MOVFF  FEC,746
09964:  MOVFF  731,565
09968:  MOVFF  730,564
0996C:  MOVLW  89
0996E:  MOVWF  FE9
09970:  MOVLW  02
09972:  MOVWF  x47
09974:  MOVLB  0
09976:  CALL   5764
0997A:  MOVLW  2C
0997C:  MOVLB  7
0997E:  MOVWF  x50
09980:  MOVLB  0
09982:  CALL   55C6
....................    }
09986:  BRA    9B22
....................    else if (0 == strcmp(s_poles, arg2)) {
09988:  MOVFF  722,742
0998C:  MOVFF  721,741
09990:  MOVFF  70D,744
09994:  MOVFF  70C,743
09998:  CALL   5B02
0999C:  MOVF   01,F
0999E:  BNZ   9A4A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
099A0:  MOVLW  04
099A2:  MOVLB  7
099A4:  MOVWF  x42
099A6:  MOVLW  C1
099A8:  MOVWF  x41
099AA:  MOVLB  0
099AC:  CALL   558E
099B0:  MOVFF  02,03
099B4:  MOVF   01,W
099B6:  ADDLW  C1
099B8:  MOVLB  7
099BA:  MOVWF  x30
099BC:  MOVLW  04
099BE:  ADDWFC 02,W
099C0:  MOVWF  x31
099C2:  MOVFF  FE8,565
099C6:  MOVFF  730,564
099CA:  MOVFF  70B,734
099CE:  MOVLW  18
099D0:  MOVWF  x35
099D2:  MOVLB  0
099D4:  CALL   6066
099D8:  MOVLW  2C
099DA:  MOVLB  7
099DC:  MOVWF  x50
099DE:  MOVLB  0
099E0:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
099E4:  MOVLW  04
099E6:  MOVLB  7
099E8:  MOVWF  x42
099EA:  MOVLW  C1
099EC:  MOVWF  x41
099EE:  MOVLB  0
099F0:  CALL   558E
099F4:  MOVF   01,W
099F6:  ADDLW  C1
099F8:  MOVLB  7
099FA:  MOVWF  x30
099FC:  MOVLW  04
099FE:  ADDWFC 02,W
09A00:  MOVWF  x31
09A02:  MOVLW  01
09A04:  SUBWF  x0B,W
09A06:  MULLW  26
09A08:  MOVF   FF3,W
09A0A:  CLRF   x33
09A0C:  MOVWF  x32
09A0E:  MOVLW  1C
09A10:  ADDWF  x32,W
09A12:  MOVWF  01
09A14:  MOVLW  00
09A16:  ADDWFC x33,W
09A18:  MOVWF  03
09A1A:  MOVF   01,W
09A1C:  ADDLW  17
09A1E:  MOVWF  FE9
09A20:  MOVLW  01
09A22:  ADDWFC 03,W
09A24:  MOVWF  FEA
09A26:  MOVFF  FEF,734
09A2A:  MOVFF  731,565
09A2E:  MOVFF  730,564
09A32:  MOVLW  18
09A34:  MOVWF  x35
09A36:  MOVLB  0
09A38:  CALL   6066
09A3C:  MOVLW  2C
09A3E:  MOVLB  7
09A40:  MOVWF  x50
09A42:  MOVLB  0
09A44:  CALL   55C6
....................    }
09A48:  BRA    9B22
....................    else if (0 == strcmp(s_real, arg2)) {
09A4A:  MOVFF  72A,742
09A4E:  MOVFF  729,741
09A52:  MOVFF  70D,744
09A56:  MOVFF  70C,743
09A5A:  CALL   5B02
09A5E:  MOVF   01,F
09A60:  BNZ   9B1C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A62:  MOVLW  04
09A64:  MOVLB  7
09A66:  MOVWF  x42
09A68:  MOVLW  C1
09A6A:  MOVWF  x41
09A6C:  MOVLB  0
09A6E:  CALL   558E
09A72:  MOVFF  02,03
09A76:  MOVF   01,W
09A78:  ADDLW  C1
09A7A:  MOVLB  7
09A7C:  MOVWF  x30
09A7E:  MOVLW  04
09A80:  ADDWFC 02,W
09A82:  MOVWF  x31
09A84:  MOVFF  FE8,565
09A88:  MOVFF  730,564
09A8C:  MOVFF  70B,734
09A90:  MOVLW  18
09A92:  MOVWF  x35
09A94:  MOVLB  0
09A96:  CALL   6066
09A9A:  MOVLW  2C
09A9C:  MOVLB  7
09A9E:  MOVWF  x50
09AA0:  MOVLB  0
09AA2:  CALL   55C6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09AA6:  MOVLW  04
09AA8:  MOVLB  7
09AAA:  MOVWF  x42
09AAC:  MOVLW  C1
09AAE:  MOVWF  x41
09AB0:  MOVLB  0
09AB2:  CALL   558E
09AB6:  MOVF   01,W
09AB8:  ADDLW  C1
09ABA:  MOVLB  7
09ABC:  MOVWF  x30
09ABE:  MOVLW  04
09AC0:  ADDWFC 02,W
09AC2:  MOVWF  x31
09AC4:  MOVLW  01
09AC6:  SUBWF  x0B,W
09AC8:  MULLW  26
09ACA:  MOVF   FF3,W
09ACC:  CLRF   x33
09ACE:  MOVWF  x32
09AD0:  MOVLW  1D
09AD2:  ADDWF  x32,W
09AD4:  MOVWF  01
09AD6:  MOVLW  00
09AD8:  ADDWFC x33,W
09ADA:  MOVWF  03
09ADC:  MOVF   01,W
09ADE:  ADDLW  17
09AE0:  MOVWF  FE9
09AE2:  MOVLW  01
09AE4:  ADDWFC 03,W
09AE6:  MOVWF  FEA
09AE8:  MOVFF  FEF,743
09AEC:  MOVFF  FEC,744
09AF0:  MOVFF  FEC,745
09AF4:  MOVFF  FEC,746
09AF8:  MOVFF  731,565
09AFC:  MOVFF  730,564
09B00:  MOVLW  89
09B02:  MOVWF  FE9
09B04:  MOVLW  02
09B06:  MOVWF  x47
09B08:  MOVLB  0
09B0A:  CALL   5764
09B0E:  MOVLW  2C
09B10:  MOVLB  7
09B12:  MOVWF  x50
09B14:  MOVLB  0
09B16:  CALL   55C6
....................    }
09B1A:  BRA    9B22
....................    else return INV_PARAM;
09B1C:  MOVLW  02
09B1E:  MOVWF  01
09B20:  BRA    9B26
....................    
....................    return SUCCESS;
09B22:  MOVLW  00
09B24:  MOVWF  01
09B26:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09B28:  MOVLB  7
09B2A:  CLRF   x42
09B2C:  MOVFF  690,741
09B30:  CLRF   x44
09B32:  MOVLW  B5
09B34:  MOVWF  x43
09B36:  MOVLB  0
09B38:  CALL   08AC
09B3C:  MOVFF  02,70D
09B40:  MOVFF  01,70C
09B44:  MOVLW  06
09B46:  MOVLB  7
09B48:  ADDWF  x0C,F
09B4A:  MOVLW  00
09B4C:  ADDWFC x0D,F
09B4E:  MOVLW  32
09B50:  ADDWF  x0C,W
09B52:  MOVWF  01
09B54:  MOVLW  00
09B56:  ADDWFC x0D,W
09B58:  MOVWF  03
09B5A:  MOVF   01,W
09B5C:  ADDLW  EB
09B5E:  MOVWF  01
09B60:  MOVLW  01
09B62:  ADDWFC 03,F
09B64:  MOVFF  01,70C
09B68:  MOVFF  03,70D
09B6C:  MOVFF  03,734
09B70:  MOVFF  01,733
09B74:  MOVLB  0
09B76:  CALL   5C22
09B7A:  MOVF   01,F
09B7C:  BNZ   9B86
09B7E:  MOVLW  02
09B80:  MOVWF  01
09B82:  BRA    9C88
09B84:  BRA    9BE4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B86:  MOVLB  7
09B88:  CLRF   x42
09B8A:  MOVFF  690,741
09B8E:  CLRF   x44
09B90:  MOVLW  B5
09B92:  MOVWF  x43
09B94:  MOVLB  0
09B96:  CALL   08AC
09B9A:  MOVFF  02,70D
09B9E:  MOVFF  01,70C
09BA2:  MOVLW  06
09BA4:  MOVLB  7
09BA6:  ADDWF  x0C,F
09BA8:  MOVLW  00
09BAA:  ADDWFC x0D,F
09BAC:  MOVLW  32
09BAE:  ADDWF  x0C,W
09BB0:  MOVWF  01
09BB2:  MOVLW  00
09BB4:  ADDWFC x0D,W
09BB6:  MOVWF  03
09BB8:  MOVF   01,W
09BBA:  ADDLW  EB
09BBC:  MOVWF  01
09BBE:  MOVLW  01
09BC0:  ADDWFC 03,F
09BC2:  MOVFF  01,70C
09BC6:  MOVFF  03,70D
09BCA:  MOVFF  03,734
09BCE:  MOVFF  01,733
09BD2:  CLRF   x36
09BD4:  CLRF   x35
09BD6:  MOVLW  0A
09BD8:  MOVWF  x37
09BDA:  MOVLB  0
09BDC:  CALL   5D12
09BE0:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
09BE4:  MOVLW  04
09BE6:  MOVLB  7
09BE8:  MOVWF  x42
09BEA:  MOVLW  C1
09BEC:  MOVWF  x41
09BEE:  MOVLB  0
09BF0:  CALL   558E
09BF4:  MOVF   01,W
09BF6:  ADDLW  C1
09BF8:  MOVLB  7
09BFA:  MOVWF  x0C
09BFC:  MOVLW  04
09BFE:  ADDWFC 02,W
09C00:  MOVWF  x0D
09C02:  MOVLW  01
09C04:  SUBWF  x0B,W
09C06:  MULLW  07
09C08:  MOVF   FF3,W
09C0A:  CLRF   x0F
09C0C:  MOVWF  x0E
09C0E:  MOVLW  03
09C10:  ADDWF  x0E,W
09C12:  MOVWF  01
09C14:  MOVLW  00
09C16:  ADDWFC x0F,W
09C18:  MOVWF  03
09C1A:  MOVF   01,W
09C1C:  ADDLW  64
09C1E:  MOVWF  FE9
09C20:  MOVLW  01
09C22:  ADDWFC 03,W
09C24:  MOVWF  FEA
09C26:  MOVFF  FEF,70E
09C2A:  MOVFF  FEC,70F
09C2E:  MOVFF  FEC,710
09C32:  MOVFF  FEC,711
09C36:  MOVFF  70D,565
09C3A:  MOVFF  70C,564
09C3E:  MOVFF  70B,734
09C42:  MOVLW  18
09C44:  MOVWF  x35
09C46:  MOVLB  0
09C48:  CALL   6066
09C4C:  MOVLW  2C
09C4E:  MOVLB  7
09C50:  MOVWF  x50
09C52:  MOVLB  0
09C54:  CALL   55C6
09C58:  MOVLW  89
09C5A:  MOVWF  FE9
09C5C:  MOVFF  711,746
09C60:  MOVFF  710,745
09C64:  MOVFF  70F,744
09C68:  MOVFF  70E,743
09C6C:  MOVLW  02
09C6E:  MOVLB  7
09C70:  MOVWF  x47
09C72:  MOVLB  0
09C74:  CALL   5764
09C78:  MOVLW  2C
09C7A:  MOVLB  7
09C7C:  MOVWF  x50
09C7E:  MOVLB  0
09C80:  CALL   55C6
....................    
....................    return SUCCESS;
09C84:  MOVLW  00
09C86:  MOVWF  01
09C88:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C8A:  MOVLB  7
09C8C:  CLRF   x42
09C8E:  MOVFF  690,741
09C92:  CLRF   x44
09C94:  MOVLW  B5
09C96:  MOVWF  x43
09C98:  MOVLB  0
09C9A:  CALL   08AC
09C9E:  MOVFF  02,711
09CA2:  MOVFF  01,710
09CA6:  MOVLW  06
09CA8:  MOVLB  7
09CAA:  ADDWF  x10,F
09CAC:  MOVLW  00
09CAE:  ADDWFC x11,F
09CB0:  MOVLW  32
09CB2:  ADDWF  x10,W
09CB4:  MOVWF  01
09CB6:  MOVLW  00
09CB8:  ADDWFC x11,W
09CBA:  MOVWF  03
09CBC:  MOVF   01,W
09CBE:  ADDLW  EB
09CC0:  MOVWF  01
09CC2:  MOVLW  01
09CC4:  ADDWFC 03,F
09CC6:  MOVFF  01,710
09CCA:  MOVFF  03,711
09CCE:  MOVFF  03,734
09CD2:  MOVFF  01,733
09CD6:  MOVLB  0
09CD8:  CALL   5C22
09CDC:  MOVF   01,F
09CDE:  BNZ   9CE8
09CE0:  MOVLW  02
09CE2:  MOVWF  01
09CE4:  BRA    9EFA
09CE6:  BRA    9D46
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CE8:  MOVLB  7
09CEA:  CLRF   x42
09CEC:  MOVFF  690,741
09CF0:  CLRF   x44
09CF2:  MOVLW  B5
09CF4:  MOVWF  x43
09CF6:  MOVLB  0
09CF8:  CALL   08AC
09CFC:  MOVFF  02,711
09D00:  MOVFF  01,710
09D04:  MOVLW  06
09D06:  MOVLB  7
09D08:  ADDWF  x10,F
09D0A:  MOVLW  00
09D0C:  ADDWFC x11,F
09D0E:  MOVLW  32
09D10:  ADDWF  x10,W
09D12:  MOVWF  01
09D14:  MOVLW  00
09D16:  ADDWFC x11,W
09D18:  MOVWF  03
09D1A:  MOVF   01,W
09D1C:  ADDLW  EB
09D1E:  MOVWF  01
09D20:  MOVLW  01
09D22:  ADDWFC 03,F
09D24:  MOVFF  01,710
09D28:  MOVFF  03,711
09D2C:  MOVFF  03,734
09D30:  MOVFF  01,733
09D34:  CLRF   x36
09D36:  CLRF   x35
09D38:  MOVLW  0A
09D3A:  MOVWF  x37
09D3C:  MOVLB  0
09D3E:  CALL   5D12
09D42:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09D46:  MOVLB  7
09D48:  CLRF   x42
09D4A:  MOVFF  690,741
09D4E:  CLRF   x44
09D50:  MOVLW  B5
09D52:  MOVWF  x43
09D54:  MOVLB  0
09D56:  CALL   08AC
09D5A:  MOVFF  02,711
09D5E:  MOVFF  01,710
09D62:  MOVLW  06
09D64:  MOVLB  7
09D66:  ADDWF  x10,F
09D68:  MOVLW  00
09D6A:  ADDWFC x11,F
09D6C:  MOVLW  4B
09D6E:  ADDWF  x10,W
09D70:  MOVWF  01
09D72:  MOVLW  00
09D74:  ADDWFC x11,W
09D76:  MOVWF  03
09D78:  MOVF   01,W
09D7A:  ADDLW  EB
09D7C:  MOVWF  01
09D7E:  MOVLW  01
09D80:  ADDWFC 03,F
09D82:  MOVFF  01,710
09D86:  MOVFF  03,711
09D8A:  MOVFF  03,715
09D8E:  MOVFF  01,714
09D92:  MOVLB  0
09D94:  CALL   6D36
09D98:  MOVF   01,F
09D9A:  BNZ   9DA4
09D9C:  MOVLW  02
09D9E:  MOVWF  01
09DA0:  BRA    9EFA
09DA2:  BRA    9E0A
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09DA4:  MOVLB  7
09DA6:  CLRF   x42
09DA8:  MOVFF  690,741
09DAC:  CLRF   x44
09DAE:  MOVLW  B5
09DB0:  MOVWF  x43
09DB2:  MOVLB  0
09DB4:  CALL   08AC
09DB8:  MOVFF  02,711
09DBC:  MOVFF  01,710
09DC0:  MOVLW  06
09DC2:  MOVLB  7
09DC4:  ADDWF  x10,F
09DC6:  MOVLW  00
09DC8:  ADDWFC x11,F
09DCA:  MOVLW  4B
09DCC:  ADDWF  x10,W
09DCE:  MOVWF  01
09DD0:  MOVLW  00
09DD2:  ADDWFC x11,W
09DD4:  MOVWF  03
09DD6:  MOVF   01,W
09DD8:  ADDLW  EB
09DDA:  MOVWF  01
09DDC:  MOVLW  01
09DDE:  ADDWFC 03,F
09DE0:  MOVFF  01,710
09DE4:  MOVFF  03,711
09DE8:  MOVFF  03,715
09DEC:  MOVFF  01,714
09DF0:  CLRF   x17
09DF2:  CLRF   x16
09DF4:  MOVLB  0
09DF6:  CALL   6DF8
09DFA:  MOVFF  03,70F
09DFE:  MOVFF  02,70E
09E02:  MOVFF  01,70D
09E06:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09E0A:  MOVLB  7
09E0C:  CLRF   x49
09E0E:  CLRF   x48
09E10:  MOVLW  7C
09E12:  MOVWF  x47
09E14:  MOVLW  84
09E16:  MOVWF  x46
09E18:  MOVFF  70F,74D
09E1C:  MOVFF  70E,74C
09E20:  MOVFF  70D,74B
09E24:  MOVFF  70C,74A
09E28:  MOVLB  0
09E2A:  CALL   1D22
09E2E:  BNC   9E64
09E30:  MOVLW  01
09E32:  MOVLB  7
09E34:  SUBWF  x0B,W
09E36:  MULLW  07
09E38:  MOVF   FF3,W
09E3A:  CLRF   x11
09E3C:  MOVWF  x10
09E3E:  MOVLW  03
09E40:  ADDWF  x10,W
09E42:  MOVWF  01
09E44:  MOVLW  00
09E46:  ADDWFC x11,W
09E48:  MOVWF  03
09E4A:  MOVF   01,W
09E4C:  ADDLW  64
09E4E:  MOVWF  FE9
09E50:  MOVLW  01
09E52:  ADDWFC 03,W
09E54:  MOVWF  FEA
09E56:  MOVLW  84
09E58:  MOVWF  FEF
09E5A:  MOVLW  7C
09E5C:  MOVWF  FEC
09E5E:  CLRF   FEC
09E60:  CLRF   FEC
09E62:  BRA    9EF4
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09E64:  MOVFF  70F,749
09E68:  MOVFF  70E,748
09E6C:  MOVFF  70D,747
09E70:  MOVFF  70C,746
09E74:  MOVLB  7
09E76:  CLRF   x4D
09E78:  CLRF   x4C
09E7A:  MOVLW  C0
09E7C:  MOVWF  x4B
09E7E:  MOVLW  82
09E80:  MOVWF  x4A
09E82:  MOVLB  0
09E84:  CALL   1D22
09E88:  BNC   9EBE
09E8A:  MOVLW  01
09E8C:  MOVLB  7
09E8E:  SUBWF  x0B,W
09E90:  MULLW  07
09E92:  MOVF   FF3,W
09E94:  CLRF   x11
09E96:  MOVWF  x10
09E98:  MOVLW  03
09E9A:  ADDWF  x10,W
09E9C:  MOVWF  01
09E9E:  MOVLW  00
09EA0:  ADDWFC x11,W
09EA2:  MOVWF  03
09EA4:  MOVF   01,W
09EA6:  ADDLW  64
09EA8:  MOVWF  FE9
09EAA:  MOVLW  01
09EAC:  ADDWFC 03,W
09EAE:  MOVWF  FEA
09EB0:  MOVLW  82
09EB2:  MOVWF  FEF
09EB4:  MOVLW  C0
09EB6:  MOVWF  FEC
09EB8:  CLRF   FEC
09EBA:  CLRF   FEC
09EBC:  BRA    9EF4
....................    else dacVals[arg1-1].opPcnt = arg2;
09EBE:  MOVLW  01
09EC0:  MOVLB  7
09EC2:  SUBWF  x0B,W
09EC4:  MULLW  07
09EC6:  MOVF   FF3,W
09EC8:  CLRF   x11
09ECA:  MOVWF  x10
09ECC:  MOVLW  03
09ECE:  ADDWF  x10,W
09ED0:  MOVWF  01
09ED2:  MOVLW  00
09ED4:  ADDWFC x11,W
09ED6:  MOVWF  03
09ED8:  MOVF   01,W
09EDA:  ADDLW  64
09EDC:  MOVWF  FE9
09EDE:  MOVLW  01
09EE0:  ADDWFC 03,W
09EE2:  MOVWF  FEA
09EE4:  MOVFF  70C,FEF
09EE8:  MOVFF  70D,FEC
09EEC:  MOVFF  70E,FEC
09EF0:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
09EF4:  MOVLW  00
09EF6:  MOVWF  01
09EF8:  MOVLB  0
09EFA:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09EFC:  MOVLB  1
09EFE:  BSF    x63.0
....................    return SUCCESS;
09F00:  MOVLW  00
09F02:  MOVWF  01
09F04:  MOVLB  0
09F06:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09F08:  MOVLB  1
09F0A:  BCF    x63.0
....................    return SUCCESS;
09F0C:  MOVLW  00
09F0E:  MOVWF  01
09F10:  MOVLB  0
09F12:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09F14:  MOVLB  7
09F16:  CLRF   x42
09F18:  MOVFF  690,741
09F1C:  CLRF   x44
09F1E:  MOVLW  B5
09F20:  MOVWF  x43
09F22:  MOVLB  0
09F24:  CALL   08AC
09F28:  MOVFF  02,70D
09F2C:  MOVFF  01,70C
09F30:  MOVLW  06
09F32:  MOVLB  7
09F34:  ADDWF  x0C,F
09F36:  MOVLW  00
09F38:  ADDWFC x0D,F
09F3A:  MOVLW  32
09F3C:  ADDWF  x0C,W
09F3E:  MOVWF  01
09F40:  MOVLW  00
09F42:  ADDWFC x0D,W
09F44:  MOVWF  03
09F46:  MOVF   01,W
09F48:  ADDLW  EB
09F4A:  MOVWF  01
09F4C:  MOVLW  01
09F4E:  ADDWFC 03,F
09F50:  MOVFF  01,70C
09F54:  MOVFF  03,70D
09F58:  MOVFF  03,734
09F5C:  MOVFF  01,733
09F60:  MOVLB  0
09F62:  CALL   5C22
09F66:  MOVF   01,F
09F68:  BNZ   9F72
09F6A:  MOVLW  02
09F6C:  MOVWF  01
09F6E:  BRA    9FFE
09F70:  BRA    9FD0
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09F72:  MOVLB  7
09F74:  CLRF   x42
09F76:  MOVFF  690,741
09F7A:  CLRF   x44
09F7C:  MOVLW  B5
09F7E:  MOVWF  x43
09F80:  MOVLB  0
09F82:  CALL   08AC
09F86:  MOVFF  02,70D
09F8A:  MOVFF  01,70C
09F8E:  MOVLW  06
09F90:  MOVLB  7
09F92:  ADDWF  x0C,F
09F94:  MOVLW  00
09F96:  ADDWFC x0D,F
09F98:  MOVLW  32
09F9A:  ADDWF  x0C,W
09F9C:  MOVWF  01
09F9E:  MOVLW  00
09FA0:  ADDWFC x0D,W
09FA2:  MOVWF  03
09FA4:  MOVF   01,W
09FA6:  ADDLW  EB
09FA8:  MOVWF  01
09FAA:  MOVLW  01
09FAC:  ADDWFC 03,F
09FAE:  MOVFF  01,70C
09FB2:  MOVFF  03,70D
09FB6:  MOVFF  03,734
09FBA:  MOVFF  01,733
09FBE:  CLRF   x36
09FC0:  CLRF   x35
09FC2:  MOVLW  0A
09FC4:  MOVWF  x37
09FC6:  MOVLB  0
09FC8:  CALL   5D12
09FCC:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09FD0:  MOVLW  01
09FD2:  MOVLB  7
09FD4:  SUBWF  x0B,W
09FD6:  MULLW  26
09FD8:  MOVF   FF3,W
09FDA:  CLRF   x0D
09FDC:  MOVWF  x0C
09FDE:  MOVLW  25
09FE0:  ADDWF  x0C,W
09FE2:  MOVWF  01
09FE4:  MOVLW  00
09FE6:  ADDWFC x0D,W
09FE8:  MOVWF  03
09FEA:  MOVF   01,W
09FEC:  ADDLW  17
09FEE:  MOVWF  FE9
09FF0:  MOVLW  01
09FF2:  ADDWFC 03,W
09FF4:  MOVWF  FEA
09FF6:  BSF    FEF.0
....................     
....................     return SUCCESS;
09FF8:  MOVLW  00
09FFA:  MOVWF  01
09FFC:  MOVLB  0
09FFE:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A000:  MOVLW  01
0A002:  MOVWF  01
0A004:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06D36:  MOVLB  7
06D38:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06D3A:  CLRF   x17
06D3C:  MOVFF  715,742
06D40:  MOVFF  714,741
06D44:  MOVLB  0
06D46:  CALL   558E
06D4A:  MOVFF  02,03
06D4E:  MOVF   01,W
06D50:  MOVF   03,F
06D52:  BNZ   6D5E
06D54:  MOVF   01,W
06D56:  MOVLB  7
06D58:  SUBWF  x17,W
06D5A:  BC    6DF0
06D5C:  MOVLB  0
....................       if (!isdigit(arg[i])){
06D5E:  MOVLB  7
06D60:  MOVF   x17,W
06D62:  ADDWF  x14,W
06D64:  MOVWF  FE9
06D66:  MOVLW  00
06D68:  ADDWFC x15,W
06D6A:  MOVWF  FEA
06D6C:  MOVFF  FEF,718
06D70:  MOVF   x18,W
06D72:  SUBLW  2F
06D74:  BC    6D7C
06D76:  MOVF   x18,W
06D78:  SUBLW  39
06D7A:  BC    6DE8
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06D7C:  MOVF   x17,W
06D7E:  ADDWF  x14,W
06D80:  MOVWF  FE9
06D82:  MOVLW  00
06D84:  ADDWFC x15,W
06D86:  MOVWF  FEA
06D88:  MOVF   FEF,W
06D8A:  SUBLW  2D
06D8C:  BZ    6DB8
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06D8E:  MOVF   x17,W
06D90:  ADDWF  x14,W
06D92:  MOVWF  FE9
06D94:  MOVLW  00
06D96:  ADDWFC x15,W
06D98:  MOVWF  FEA
06D9A:  MOVF   FEF,W
06D9C:  SUBLW  2E
06D9E:  BZ    6DA8
06DA0:  MOVLW  00
06DA2:  MOVWF  01
06DA4:  BRA    6DF4
06DA6:  BRA    6DB6
....................             else if  (decimal) return FALSE;
06DA8:  BTFSS  x16.0
06DAA:  BRA    6DB4
06DAC:  MOVLW  00
06DAE:  MOVWF  01
06DB0:  BRA    6DF4
06DB2:  BRA    6DB6
....................             else decimal = TRUE;
06DB4:  BSF    x16.0
....................          }
06DB6:  BRA    6DE8
....................          else if (0 != i) return FALSE;
06DB8:  MOVF   x17,F
06DBA:  BZ    6DC4
06DBC:  MOVLW  00
06DBE:  MOVWF  01
06DC0:  BRA    6DF4
06DC2:  BRA    6DE8
....................          else if (1 == strlen(arg)) return FALSE;
06DC4:  MOVFF  715,742
06DC8:  MOVFF  714,741
06DCC:  MOVLB  0
06DCE:  CALL   558E
06DD2:  MOVFF  02,03
06DD6:  MOVF   01,W
06DD8:  SUBLW  01
06DDA:  BNZ   6DEA
06DDC:  MOVF   03,F
06DDE:  BNZ   6DEA
06DE0:  MOVLW  00
06DE2:  MOVWF  01
06DE4:  MOVLB  7
06DE6:  BRA    6DF4
06DE8:  MOVLB  0
....................       }
06DEA:  MOVLB  7
06DEC:  INCF   x17,F
06DEE:  BRA    6D3C
....................    }
....................    return TRUE;
06DF0:  MOVLW  01
06DF2:  MOVWF  01
06DF4:  MOVLB  0
06DF6:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05C22:  MOVFF  734,742
05C26:  MOVFF  733,741
05C2A:  RCALL  558E
05C2C:  MOVFF  02,03
05C30:  MOVF   01,W
05C32:  SUBLW  01
05C34:  BNZ   5C3A
05C36:  MOVF   03,F
05C38:  BZ    5C42
05C3A:  MOVLW  00
05C3C:  MOVWF  01
05C3E:  BRA    5C70
05C40:  BRA    5C68
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05C42:  MOVLB  7
05C44:  MOVFF  733,FE9
05C48:  MOVFF  734,FEA
05C4C:  MOVF   FEF,W
05C4E:  SUBLW  31
05C50:  BZ    5C6A
05C52:  MOVFF  733,FE9
05C56:  MOVFF  734,FEA
05C5A:  MOVF   FEF,W
05C5C:  SUBLW  32
05C5E:  BZ    5C6A
05C60:  MOVLW  00
05C62:  MOVWF  01
05C64:  MOVLB  0
05C66:  BRA    5C70
05C68:  MOVLB  7
....................     return TRUE;
05C6A:  MOVLW  01
05C6C:  MOVWF  01
05C6E:  MOVLB  0
05C70:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05AC8:  MOVLB  7
05ACA:  MOVF   x0A,W
05ACC:  SUBLW  2F
05ACE:  BC    5AE0
05AD0:  MOVF   x0A,W
05AD2:  SUBLW  39
05AD4:  BNC   5AE0
05AD6:  MOVLW  30
05AD8:  SUBWF  x0A,W
05ADA:  MOVWF  01
05ADC:  BRA    5AFC
05ADE:  BRA    5AFC
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05AE0:  MOVF   x0A,W
05AE2:  SUBLW  40
05AE4:  BC    5AF8
05AE6:  MOVF   x0A,W
05AE8:  SUBLW  46
05AEA:  BNC   5AF8
05AEC:  MOVLW  41
05AEE:  SUBWF  x0A,W
05AF0:  ADDLW  0A
05AF2:  MOVWF  01
05AF4:  BRA    5AFC
05AF6:  BRA    5AFC
....................    else return 0xFF;
05AF8:  MOVLW  FF
05AFA:  MOVWF  01
05AFC:  MOVLB  0
05AFE:  GOTO   A0AA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A006:  MOVLB  7
0A008:  CLRF   x42
0A00A:  MOVFF  701,741
0A00E:  CLRF   x44
0A010:  MOVLW  B5
0A012:  MOVWF  x43
0A014:  MOVLB  0
0A016:  CALL   08AC
0A01A:  MOVFF  02,70A
0A01E:  MOVFF  01,709
0A022:  MOVLW  06
0A024:  MOVLB  7
0A026:  ADDWF  x09,F
0A028:  MOVLW  00
0A02A:  ADDWFC x0A,F
0A02C:  MOVLW  EB
0A02E:  ADDWF  x09,W
0A030:  MOVWF  01
0A032:  MOVLW  01
0A034:  ADDWFC x0A,W
0A036:  MOVWF  03
0A038:  MOVFF  01,702
0A03C:  MOVWF  x03
0A03E:  CLRF   x42
0A040:  MOVFF  701,741
0A044:  CLRF   x44
0A046:  MOVLW  B5
0A048:  MOVWF  x43
0A04A:  MOVLB  0
0A04C:  CALL   08AC
0A050:  MOVFF  02,70C
0A054:  MOVFF  01,70B
0A058:  MOVLW  06
0A05A:  MOVLB  7
0A05C:  ADDWF  x0B,F
0A05E:  MOVLW  00
0A060:  ADDWFC x0C,F
0A062:  MOVLW  19
0A064:  ADDWF  x0B,W
0A066:  MOVWF  01
0A068:  MOVLW  00
0A06A:  ADDWFC x0C,W
0A06C:  MOVWF  03
0A06E:  MOVF   01,W
0A070:  ADDLW  EB
0A072:  MOVWF  01
0A074:  MOVLW  01
0A076:  ADDWFC 03,F
0A078:  MOVFF  01,704
0A07C:  MOVFF  03,705
0A080:  CLRF   x06
0A082:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A084:  MOVFF  702,FE9
0A088:  MOVFF  703,FEA
0A08C:  MOVF   FEF,W
0A08E:  SUBLW  44
0A090:  BTFSS  FD8.2
0A092:  BRA    A182
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A094:  MOVLW  01
0A096:  ADDWF  x02,W
0A098:  MOVWF  FE9
0A09A:  MOVLW  00
0A09C:  ADDWFC x03,W
0A09E:  MOVWF  FEA
0A0A0:  MOVFF  FEF,70A
0A0A4:  MOVLB  0
0A0A6:  GOTO   5AC8
0A0AA:  MOVFF  01,709
0A0AE:  MOVLB  7
0A0B0:  MOVF   x06,W
0A0B2:  ANDLW  0F
0A0B4:  SUBWF  01,W
0A0B6:  BNZ   A17A
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A0B8:  MOVF   x07,W
0A0BA:  MULLW  04
0A0BC:  MOVF   FF3,W
0A0BE:  CLRF   x0A
0A0C0:  MOVWF  x09
0A0C2:  MOVLW  6A
0A0C4:  ADDWF  x09,W
0A0C6:  MOVWF  FE9
0A0C8:  MOVLW  05
0A0CA:  ADDWFC x0A,W
0A0CC:  MOVWF  FEA
0A0CE:  MOVFF  FEC,742
0A0D2:  MOVF   FED,F
0A0D4:  MOVFF  FEF,741
0A0D8:  MOVLB  0
0A0DA:  CALL   558E
0A0DE:  MOVFF  02,03
0A0E2:  MOVF   01,W
0A0E4:  BNZ   A0EA
0A0E6:  MOVF   03,F
0A0E8:  BZ    A170
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A0EA:  MOVLB  7
0A0EC:  MOVF   x07,W
0A0EE:  MULLW  04
0A0F0:  MOVF   FF3,W
0A0F2:  CLRF   x0A
0A0F4:  MOVWF  x09
0A0F6:  MOVLW  6A
0A0F8:  ADDWF  x09,W
0A0FA:  MOVWF  FE9
0A0FC:  MOVLW  05
0A0FE:  ADDWFC x0A,W
0A100:  MOVWF  FEA
0A102:  MOVFF  FEC,744
0A106:  MOVF   FED,F
0A108:  MOVFF  FEF,743
0A10C:  MOVFF  705,742
0A110:  MOVFF  704,741
0A114:  MOVLB  0
0A116:  CALL   5B02
0A11A:  MOVF   01,F
0A11C:  BNZ   A168
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A11E:  MOVLB  7
0A120:  MOVF   x07,W
0A122:  MULLW  04
0A124:  MOVF   FF3,W
0A126:  CLRF   x0A
0A128:  MOVWF  x09
0A12A:  MOVLW  02
0A12C:  ADDWF  x09,W
0A12E:  MOVWF  01
0A130:  MOVLW  00
0A132:  ADDWFC x0A,W
0A134:  MOVWF  03
0A136:  MOVF   01,W
0A138:  ADDLW  6A
0A13A:  MOVWF  01
0A13C:  MOVLW  05
0A13E:  ADDWFC 03,F
0A140:  MOVFF  01,709
0A144:  MOVFF  03,70A
0A148:  MOVFF  03,FEA
0A14C:  MOVFF  01,FE9
0A150:  MOVFF  701,690
0A154:  MOVLB  0
0A156:  CALL   00BC
0A15A:  MOVFF  01,708
....................                return return_code;
0A15E:  MOVLB  7
0A160:  MOVFF  708,01
0A164:  BRA    A186
0A166:  MOVLB  0
....................             }
....................             i++;
0A168:  MOVLB  7
0A16A:  INCF   x07,F
0A16C:  BRA    A0B8
0A16E:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A170:  MOVLW  01
0A172:  MOVWF  01
0A174:  MOVLB  7
0A176:  BRA    A186
....................       } else return 254; // NOT THIS ADDRESS
0A178:  BRA    A180
0A17A:  MOVLW  FE
0A17C:  MOVWF  01
0A17E:  BRA    A186
....................    } else return 255; // NOT THIS DEVICE TYPE
0A180:  BRA    A186
0A182:  MOVLW  FF
0A184:  MOVWF  01
0A186:  MOVLB  0
0A188:  GOTO   A28C (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A1F0:  GOTO   5A4A
0A1F4:  MOVF   01,F
0A1F6:  BTFSC  FD8.2
0A1F8:  BRA    A316
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A1FA:  MOVLW  04
0A1FC:  MOVLB  7
0A1FE:  MOVWF  x42
0A200:  MOVLW  C1
0A202:  MOVWF  x41
0A204:  MOVLB  0
0A206:  CALL   558E
0A20A:  MOVFF  02,03
0A20E:  MOVF   01,W
0A210:  ADDLW  C1
0A212:  MOVLB  7
0A214:  MOVWF  x00
0A216:  MOVLW  04
0A218:  ADDWFC 02,W
0A21A:  MOVWF  x01
0A21C:  CLRF   x42
0A21E:  MOVFF  4BF,741
0A222:  CLRF   x44
0A224:  MOVLW  B5
0A226:  MOVWF  x43
0A228:  MOVLB  0
0A22A:  CALL   08AC
0A22E:  MOVFF  02,703
0A232:  MOVFF  01,702
0A236:  MOVLW  06
0A238:  MOVLB  7
0A23A:  ADDWF  x02,F
0A23C:  MOVLW  00
0A23E:  ADDWFC x03,F
0A240:  MOVLW  EB
0A242:  ADDWF  x02,W
0A244:  MOVWF  01
0A246:  MOVLW  01
0A248:  ADDWFC x03,W
0A24A:  MOVWF  03
0A24C:  MOVFF  01,704
0A250:  MOVWF  x05
0A252:  MOVFF  701,565
0A256:  MOVFF  700,564
0A25A:  MOVLW  24
0A25C:  MOVWF  x50
0A25E:  MOVLB  0
0A260:  CALL   55C6
0A264:  MOVFF  565,FEA
0A268:  MOVFF  564,FE9
0A26C:  CLRF   FEF
0A26E:  MOVFF  705,FEA
0A272:  MOVFF  704,FE9
0A276:  CALL   5AA4
0A27A:  MOVLW  2C
0A27C:  MOVLB  7
0A27E:  MOVWF  x50
0A280:  MOVLB  0
0A282:  CALL   55C6
....................       
....................       return_code = command_parser(SRI);
0A286:  MOVFF  4BF,701
0A28A:  BRA    A006
0A28C:  MOVFF  01,6FB
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A290:  MOVLW  04
0A292:  MOVLB  7
0A294:  MOVWF  x42
0A296:  MOVLW  C1
0A298:  MOVWF  x41
0A29A:  MOVLB  0
0A29C:  CALL   558E
0A2A0:  MOVF   01,W
0A2A2:  ADDLW  C1
0A2A4:  MOVLB  7
0A2A6:  MOVWF  x00
0A2A8:  MOVLW  04
0A2AA:  ADDWFC 02,W
0A2AC:  MOVWF  x01
0A2AE:  MOVLB  6
0A2B0:  MOVF   xFB,W
0A2B2:  MULLW  03
0A2B4:  MOVF   FF3,W
0A2B6:  MOVLB  7
0A2B8:  CLRF   x03
0A2BA:  MOVWF  x02
0A2BC:  MOVLW  01
0A2BE:  ADDWF  x02,W
0A2C0:  MOVWF  01
0A2C2:  MOVLW  00
0A2C4:  ADDWFC x03,W
0A2C6:  MOVWF  03
0A2C8:  MOVF   01,W
0A2CA:  ADDLW  5C
0A2CC:  MOVWF  FE9
0A2CE:  MOVLW  06
0A2D0:  ADDWFC 03,W
0A2D2:  MOVWF  FEA
0A2D4:  MOVFF  FEC,703
0A2D8:  MOVF   FED,F
0A2DA:  MOVFF  FEF,702
0A2DE:  MOVFF  701,565
0A2E2:  MOVFF  700,564
0A2E6:  MOVFF  565,FEA
0A2EA:  MOVFF  564,FE9
0A2EE:  CLRF   FEF
0A2F0:  MOVFF  703,FEA
0A2F4:  MOVFF  702,FE9
0A2F8:  MOVLB  0
0A2FA:  CALL   5AA4
....................       serial_out(retData);
0A2FE:  MOVLW  04
0A300:  MOVLB  7
0A302:  MOVWF  x02
0A304:  MOVLW  C1
0A306:  MOVWF  x01
0A308:  MOVLB  0
0A30A:  BRA    A18C
....................       resetSERcmd(SRI);
0A30C:  MOVFF  4BF,701
0A310:  CALL   0B90
0A314:  BRA    A1F0
....................    }
0A316:  GOTO   AAEC (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A31A:  CLRF   FF8
0A31C:  BCF    FF2.5
0A31E:  BSF    07.7
0A320:  MOVLB  E
0A322:  MOVLW  55
0A324:  MOVWF  x9B
0A326:  MOVLW  AA
0A328:  MOVWF  x9B
0A32A:  BCF    x9B.0
0A32C:  MOVLW  17
0A32E:  MOVWF  xB0
0A330:  MOVLW  13
0A332:  MOVWF  xB2
0A334:  MOVLW  09
0A336:  MOVWF  x8A
0A338:  MOVLW  0A
0A33A:  MOVWF  x8B
0A33C:  MOVLW  11
0A33E:  MOVWF  xEB
0A340:  MOVLW  12
0A342:  MOVWF  xED
0A344:  MOVLW  10
0A346:  MOVWF  xF4
0A348:  MOVLW  0F
0A34A:  MOVWF  xF5
0A34C:  MOVLW  09
0A34E:  MOVWF  xF8
0A350:  MOVLW  55
0A352:  MOVWF  x9B
0A354:  MOVLW  AA
0A356:  MOVWF  x9B
0A358:  BSF    x9B.0
0A35A:  CLRF   xD8
0A35C:  CLRF   xD5
0A35E:  CLRF   xD7
0A360:  MOVLW  08
0A362:  MOVWF  xD9
0A364:  MOVLW  60
0A366:  MOVWF  xD3
0A368:  MOVLW  AA
0A36A:  MOVLB  0
0A36C:  MOVWF  xFA
0A36E:  MOVLB  1
0A370:  BCF    x63.0
0A372:  CLRF   x75
0A374:  CLRF   x74
0A376:  CLRF   x73
0A378:  CLRF   x72
0A37A:  CLRF   x79
0A37C:  CLRF   x78
0A37E:  CLRF   x77
0A380:  CLRF   x76
0A382:  CLRF   x7D
0A384:  CLRF   x7C
0A386:  CLRF   x7B
0A388:  CLRF   x7A
0A38A:  CLRF   x7F
0A38C:  CLRF   x7E
0A38E:  MOVLB  E
0A390:  BCF    x91.5
0A392:  MOVLW  00
0A394:  MOVWF  x90
0A396:  MOVLW  03
0A398:  MOVWF  x8E
0A39A:  MOVLW  2A
0A39C:  MOVWF  x91
0A39E:  MOVLW  04
0A3A0:  MOVWF  F88
0A3A2:  MOVWF  F88
0A3A4:  MOVWF  F88
0A3A6:  MOVLB  1
0A3A8:  CLRF   xD0
0A3AA:  CLRF   xD1
0A3AC:  CLRF   xD2
0A3AE:  CLRF   xD3
0A3B0:  BCF    F95.5
0A3B2:  MOVLW  40
0A3B4:  MOVWF  F94
0A3B6:  MOVLW  9F
0A3B8:  MOVWF  F92
0A3BA:  MOVLW  3A
0A3BC:  MOVWF  F95
0A3BE:  MOVLW  93
0A3C0:  MOVWF  F89
0A3C2:  MOVWF  F89
0A3C4:  MOVLB  4
0A3C6:  CLRF   xBF
0A3C8:  CLRF   xC0
0A3CA:  MOVLB  5
0A3CC:  CLRF   x61
0A3CE:  CLRF   x62
0A3D0:  MOVLB  1
0A3D2:  BCF    x63.1
0A3D4:  MOVLW  04
0A3D6:  MOVWF  F88
0A3D8:  BSF    F83.7
0A3DA:  MOVLW  12
0A3DC:  MOVWF  03
0A3DE:  MOVLW  FA
0A3E0:  MOVLB  7
0A3E2:  MOVWF  x01
0A3E4:  MOVLB  0
0A3E6:  CALL   03D6
0A3EA:  DECFSZ 03,F
0A3EC:  BRA    A3F0
0A3EE:  BRA    A3F4
0A3F0:  MOVLB  1
0A3F2:  BRA    A3DE
0A3F4:  MOVLB  5
0A3F6:  CLRF   x63
0A3F8:  BSF    F9E.3
0A3FA:  MOVLW  7C
0A3FC:  MOVWF  F9A
0A3FE:  MOVLW  00
0A400:  MOVWF  F9B
0A402:  MOVLW  A6
0A404:  MOVWF  F9D
0A406:  MOVLW  90
0A408:  MOVWF  F9C
0A40A:  CLRF   x65
0A40C:  CLRF   x64
0A40E:  CLRF   x69
0A410:  CLRF   x68
0A412:  CLRF   x67
0A414:  CLRF   x66
0A416:  MOVLB  F
0A418:  CLRF   x0C
0A41A:  CLRF   x14
0A41C:  CLRF   x1C
0A41E:  CLRF   x21
0A420:  CLRF   x29
0A422:  CLRF   x35
0A424:  CLRF   x36
0A426:  CLRF   x37
0A428:  CLRF   x34
0A42A:  CLRF   x31
0A42C:  CLRF   x32
0A42E:  CLRF   x33
0A430:  CLRF   x30
0A432:  MOVLW  5B
0A434:  MOVLB  5
0A436:  MOVWF  x6D
0A438:  MOVLW  9A
0A43A:  MOVWF  x6C
0A43C:  MOVLW  5B
0A43E:  MOVWF  x71
0A440:  MOVLW  DE
0A442:  MOVWF  x70
0A444:  MOVLW  61
0A446:  MOVWF  x75
0A448:  MOVLW  2E
0A44A:  MOVWF  x74
0A44C:  MOVLW  63
0A44E:  MOVWF  x79
0A450:  MOVLW  1C
0A452:  MOVWF  x78
0A454:  MOVLW  64
0A456:  MOVWF  x7D
0A458:  MOVLW  CA
0A45A:  MOVWF  x7C
0A45C:  MOVLW  66
0A45E:  MOVWF  x81
0A460:  MOVLW  5A
0A462:  MOVWF  x80
0A464:  MOVLW  68
0A466:  MOVWF  x85
0A468:  MOVLW  74
0A46A:  MOVWF  x84
0A46C:  MOVLW  70
0A46E:  MOVWF  x89
0A470:  MOVLW  52
0A472:  MOVWF  x88
0A474:  MOVLW  73
0A476:  MOVWF  x8D
0A478:  MOVLW  32
0A47A:  MOVWF  x8C
0A47C:  MOVLW  74
0A47E:  MOVWF  x91
0A480:  MOVLW  94
0A482:  MOVWF  x90
0A484:  MOVLW  76
0A486:  MOVWF  x95
0A488:  MOVLW  52
0A48A:  MOVWF  x94
0A48C:  MOVLW  7A
0A48E:  MOVWF  x99
0A490:  MOVLW  08
0A492:  MOVWF  x98
0A494:  MOVLW  7F
0A496:  MOVWF  x9D
0A498:  MOVLW  64
0A49A:  MOVWF  x9C
0A49C:  MOVLW  82
0A49E:  MOVWF  xA1
0A4A0:  MOVLW  FC
0A4A2:  MOVWF  xA0
0A4A4:  MOVLW  88
0A4A6:  MOVWF  xA5
0A4A8:  MOVLW  28
0A4AA:  MOVWF  xA4
0A4AC:  MOVLW  88
0A4AE:  MOVWF  xA9
0A4B0:  MOVLW  2E
0A4B2:  MOVWF  xA8
0A4B4:  MOVLW  8E
0A4B6:  MOVWF  xAD
0A4B8:  MOVLW  A2
0A4BA:  MOVWF  xAC
0A4BC:  MOVLW  94
0A4BE:  MOVWF  xB1
0A4C0:  MOVLW  06
0A4C2:  MOVWF  xB0
0A4C4:  MOVLW  9B
0A4C6:  MOVWF  xB5
0A4C8:  MOVLW  28
0A4CA:  MOVWF  xB4
0A4CC:  MOVLW  9C
0A4CE:  MOVWF  xB9
0A4D0:  MOVLW  8A
0A4D2:  MOVWF  xB8
0A4D4:  MOVLW  9E
0A4D6:  MOVWF  xBD
0A4D8:  MOVLW  FC
0A4DA:  MOVWF  xBC
0A4DC:  MOVLW  9F
0A4DE:  MOVWF  xC1
0A4E0:  MOVLW  08
0A4E2:  MOVWF  xC0
0A4E4:  MOVLW  9F
0A4E6:  MOVWF  xC5
0A4E8:  MOVLW  14
0A4EA:  MOVWF  xC4
0A4EC:  MOVLW  A0
0A4EE:  MOVWF  xC9
0A4F0:  MOVLW  00
0A4F2:  MOVWF  xC8
0A4F4:  BRA    A6D4
0A4F6:  DATA 02,00
0A4F8:  DATA 1A,00
0A4FA:  DATA 00,0C
0A4FC:  DATA 00,20
0A4FE:  DATA 78,23
0A500:  DATA D7,0A
0A502:  DATA 7D,19
0A504:  DATA 99,9A
0A506:  DATA 7B,4C
0A508:  DATA CC,CD
0A50A:  DATA 1C,C0
0A50C:  DATA 00,0C
0A50E:  DATA 80,78
0A510:  DATA 23,D7
0A512:  DATA 0A,7D
0A514:  DATA 19,99
0A516:  DATA 9A,7B
0A518:  DATA 4C,CC
0A51A:  DATA CD,1C
0A51C:  DATA C0,00
0A51E:  DATA 01,80
0A520:  DATA 02,09
0A522:  DATA C0,00
0A524:  DATA 05,80
0A526:  DATA 7F,00
0A528:  DATA 00,00
0A52A:  DATA 7F,0B
0A52C:  DATA C0,00
0A52E:  DATA 05,80
0A530:  DATA 7F,00
0A532:  DATA 00,00
0A534:  DATA 7F,07
0A536:  DATA C0,00
0A538:  DATA 01,80
0A53A:  DATA 7F,17
0A53C:  DATA C0,00
0A53E:  DATA 01,80
0A540:  DATA 7F,17
0A542:  DATA C0,00
0A544:  DATA 04,80
0A546:  DATA 79,B7
0A548:  DATA F3,BD
0A54A:  DATA 04,C0
0A54C:  DATA 00,04
0A54E:  DATA 80,7C
0A550:  DATA 59,DF
0A552:  DATA 4E,04
0A554:  DATA C0,00
0A556:  DATA 04,80
0A558:  DATA 78,0A
0A55A:  DATA 28,88
0A55C:  DATA 04,C0
0A55E:  DATA 00,04
0A560:  DATA 80,78
0A562:  DATA 05,EA
0A564:  DATA 16,04
0A566:  DATA C0,00
0A568:  DATA 04,80
0A56A:  DATA 78,1E
0A56C:  DATA 33,D7
0A56E:  DATA 04,C0
0A570:  DATA 00,04
0A572:  DATA 80,77
0A574:  DATA 68,7B
0A576:  DATA BB,04
0A578:  DATA C0,00
0A57A:  DATA 04,80
0A57C:  DATA 77,68
0A57E:  DATA 0D,C6
0A580:  DATA 68,40
0A582:  DATA FB,00
0A584:  DATA 0E,41
0A586:  DATA 64,00
0A588:  DATA 17,41
0A58A:  DATA D4,00
0A58C:  DATA 3C,45
0A58E:  DATA 25,00
0A590:  DATA 02,05
0A592:  DATA 6A,CA
0A594:  DATA 05,02
0A596:  DATA 05,6E
0A598:  DATA CD,05
0A59A:  DATA 02,05
0A59C:  DATA 72,D0
0A59E:  DATA 05,02
0A5A0:  DATA 05,76
0A5A2:  DATA D7,05
0A5A4:  DATA 02,05
0A5A6:  DATA 7A,DE
0A5A8:  DATA 05,02
0A5AA:  DATA 05,7E
0A5AC:  DATA E6,05
0A5AE:  DATA 02,05
0A5B0:  DATA 82,EE
0A5B2:  DATA 05,02
0A5B4:  DATA 05,86
0A5B6:  DATA F3,05
0A5B8:  DATA 02,05
0A5BA:  DATA 8A,F8
0A5BC:  DATA 05,02
0A5BE:  DATA 05,8E
0A5C0:  DATA FC,05
0A5C2:  DATA 02,05
0A5C4:  DATA 92,00
0A5C6:  DATA 06,02
0A5C8:  DATA 05,96
0A5CA:  DATA 07,06
0A5CC:  DATA 02,05
0A5CE:  DATA 9A,0D
0A5D0:  DATA 06,02
0A5D2:  DATA 05,9E
0A5D4:  DATA 13,06
0A5D6:  DATA 02,05
0A5D8:  DATA A2,19
0A5DA:  DATA 06,02
0A5DC:  DATA 05,A6
0A5DE:  DATA 1F,06
0A5E0:  DATA 02,05
0A5E2:  DATA AA,24
0A5E4:  DATA 06,02
0A5E6:  DATA 05,AE
0A5E8:  DATA 2D,06
0A5EA:  DATA 02,05
0A5EC:  DATA B2,35
0A5EE:  DATA 06,02
0A5F0:  DATA 05,B6
0A5F2:  DATA 3C,06
0A5F4:  DATA 02,05
0A5F6:  DATA BA,43
0A5F8:  DATA 06,02
0A5FA:  DATA 05,BE
0A5FC:  DATA 4B,06
0A5FE:  DATA 02,05
0A600:  DATA C2,54
0A602:  DATA 06,02
0A604:  DATA 05,C6
0A606:  DATA 5A,06
0A608:  DATA 8F,05
0A60A:  DATA CA,67
0A60C:  DATA 72,00
0A60E:  DATA 67,73
0A610:  DATA 00,67
0A612:  DATA 43,68
0A614:  DATA 4D,61
0A616:  DATA 70,00
0A618:  DATA 73,43
0A61A:  DATA 68,4D
0A61C:  DATA 61,70
0A61E:  DATA 00,67
0A620:  DATA 43,68
0A622:  DATA 4D,6F
0A624:  DATA 64,65
0A626:  DATA 00,73
0A628:  DATA 43,68
0A62A:  DATA 4D,6F
0A62C:  DATA 64,65
0A62E:  DATA 00,67
0A630:  DATA 50,49
0A632:  DATA 44,00
0A634:  DATA 73,50
0A636:  DATA 49,44
0A638:  DATA 00,67
0A63A:  DATA 53,50
0A63C:  DATA 00,73
0A63E:  DATA 53,50
0A640:  DATA 00,67
0A642:  DATA 53,43
0A644:  DATA 61,6C
0A646:  DATA 73,00
0A648:  DATA 67,53
0A64A:  DATA 43,61
0A64C:  DATA 6C,00
0A64E:  DATA 73,53
0A650:  DATA 43,61
0A652:  DATA 6C,00
0A654:  DATA 67,4D
0A656:  DATA 43,61
0A658:  DATA 6C,00
0A65A:  DATA 73,4D
0A65C:  DATA 43,61
0A65E:  DATA 6C,00
0A660:  DATA 67,4D
0A662:  DATA 6F,6E
0A664:  DATA 00,67
0A666:  DATA 50,49
0A668:  DATA 44,64
0A66A:  DATA 61,74
0A66C:  DATA 61,00
0A66E:  DATA 67,49
0A670:  DATA 50,64
0A672:  DATA 61,74
0A674:  DATA 61,00
0A676:  DATA 67,4D
0A678:  DATA 61,6E
0A67A:  DATA 4F,50
0A67C:  DATA 00,73
0A67E:  DATA 4D,61
0A680:  DATA 6E,4F
0A682:  DATA 50,00
0A684:  DATA 73,46
0A686:  DATA 69,6C
0A688:  DATA 74,4F
0A68A:  DATA 6E,00
0A68C:  DATA 73,46
0A68E:  DATA 69,6C
0A690:  DATA 74,4F
0A692:  DATA 66,66
0A694:  DATA 00,73
0A696:  DATA 48,6F
0A698:  DATA 6D,65
0A69A:  DATA 04,C0
0A69C:  DATA 00,33
0A69E:  DATA 80,65
0A6A0:  DATA 06,01
0A6A2:  DATA 6D,06
0A6A4:  DATA 02,7D
0A6A6:  DATA 06,53
0A6A8:  DATA 55,43
0A6AA:  DATA 43,45
0A6AC:  DATA 53,53
0A6AE:  DATA 00,49
0A6B0:  DATA 4E,56
0A6B2:  DATA 41,4C
0A6B4:  DATA 49,44
0A6B6:  DATA 20,43
0A6B8:  DATA 4F,4D
0A6BA:  DATA 4D,41
0A6BC:  DATA 4E,44
0A6BE:  DATA 00,49
0A6C0:  DATA 4E,56
0A6C2:  DATA 41,4C
0A6C4:  DATA 49,44
0A6C6:  DATA 20,50
0A6C8:  DATA 41,52
0A6CA:  DATA 41,4D
0A6CC:  DATA 45,54
0A6CE:  DATA 45,52
0A6D0:  DATA 00,00
0A6D2:  DATA 00,00
0A6D4:  MOVLW  00
0A6D6:  MOVWF  FF8
0A6D8:  MOVLW  A4
0A6DA:  MOVWF  FF7
0A6DC:  MOVLW  F6
0A6DE:  MOVWF  FF6
0A6E0:  TBLRD*+
0A6E2:  MOVF   FF5,W
0A6E4:  MOVWF  00
0A6E6:  XORLW  00
0A6E8:  BZ    A710
0A6EA:  TBLRD*+
0A6EC:  MOVF   FF5,W
0A6EE:  MOVWF  01
0A6F0:  BTFSC  FE8.7
0A6F2:  BRA    A6FE
0A6F4:  ANDLW  3F
0A6F6:  MOVWF  FEA
0A6F8:  TBLRD*+
0A6FA:  MOVFF  FF5,FE9
0A6FE:  BTFSC  01.6
0A700:  TBLRD*+
0A702:  BTFSS  01.6
0A704:  TBLRD*+
0A706:  MOVFF  FF5,FEE
0A70A:  DCFSNZ 00,F
0A70C:  BRA    A6E0
0A70E:  BRA    A702
0A710:  CLRF   FF8
0A712:  MOVLW  03
0A714:  MOVLB  6
0A716:  MOVWF  x92
0A718:  MOVLW  E8
0A71A:  MOVWF  x91
0A71C:  CLRF   x94
0A71E:  CLRF   x93
0A720:  CLRF   x96
0A722:  CLRF   x95
.................... {
....................     int16 loopDelay = 1000;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A724:  MOVLB  0
0A726:  GOTO   0400
....................     params_init();                // load parameters
0A72A:  GOTO   069C
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A72E:  GOTO   0AD2
....................     control_init();               // initialize the output control DACs
0A732:  GOTO   0B6A
....................     serial_init();                // setup the serial port
0A736:  GOTO   0D0A
....................     event_timer_init();
0A73A:  GOTO   0D2C
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A73E:  MOVLW  C0
0A740:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A742:  MOVLB  6
0A744:  CLRF   x97
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A746:  MOVLB  0
0A748:  GOTO   1104
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A74C:  GOTO   4454
....................       
....................         if (controlCounter >= 2){
0A750:  MOVLB  6
0A752:  MOVF   x94,F
0A754:  BNZ   A75C
0A756:  MOVF   x93,W
0A758:  SUBLW  01
0A75A:  BC    A76A
....................             control_task();
0A75C:  MOVLB  0
0A75E:  GOTO   4FCC
....................             controlCounter = 0;
0A762:  MOVLB  6
0A764:  CLRF   x94
0A766:  CLRF   x93
....................         }else controlCounter++;
0A768:  BRA    A770
0A76A:  INCF   x93,F
0A76C:  BTFSC  FD8.2
0A76E:  INCF   x94,F
....................       
....................         serial_task();             
0A770:  MOVLB  0
0A772:  GOTO   5076
....................       
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A776:  MOVLW  06
0A778:  MOVLB  7
0A77A:  MOVWF  x42
0A77C:  MOVLW  97
0A77E:  MOVWF  x41
0A780:  MOVLB  0
0A782:  CALL   558E
0A786:  MOVF   01,W
0A788:  ADDLW  97
0A78A:  MOVLB  6
0A78C:  MOVWF  xFB
0A78E:  MOVLW  06
0A790:  ADDWFC 02,W
0A792:  MOVWF  xFC
0A794:  MOVLW  01
0A796:  ADDWF  x8F,W
0A798:  MOVWF  xFD
0A79A:  MOVF   x8F,W
0A79C:  MULLW  26
0A79E:  MOVF   FF3,W
0A7A0:  CLRF   xFF
0A7A2:  MOVWF  xFE
0A7A4:  MOVLW  08
0A7A6:  ADDWF  xFE,W
0A7A8:  MOVWF  01
0A7AA:  MOVLW  00
0A7AC:  ADDWFC xFF,W
0A7AE:  MOVWF  03
0A7B0:  MOVF   01,W
0A7B2:  ADDLW  17
0A7B4:  MOVWF  FE9
0A7B6:  MOVLW  01
0A7B8:  ADDWFC 03,W
0A7BA:  MOVWF  FEA
0A7BC:  MOVFF  FEF,6FE
0A7C0:  MOVFF  FEC,6FF
0A7C4:  MOVFF  FEC,700
0A7C8:  MOVFF  FEC,701
0A7CC:  MOVF   x8F,W
0A7CE:  MULLW  26
0A7D0:  MOVF   FF3,W
0A7D2:  MOVLB  7
0A7D4:  CLRF   x03
0A7D6:  MOVWF  x02
0A7D8:  MOVLW  0C
0A7DA:  ADDWF  x02,W
0A7DC:  MOVWF  01
0A7DE:  MOVLW  00
0A7E0:  ADDWFC x03,W
0A7E2:  MOVWF  03
0A7E4:  MOVF   01,W
0A7E6:  ADDLW  17
0A7E8:  MOVWF  FE9
0A7EA:  MOVLW  01
0A7EC:  ADDWFC 03,W
0A7EE:  MOVWF  FEA
0A7F0:  MOVFF  FEF,702
0A7F4:  MOVFF  FEC,703
0A7F8:  MOVFF  FEC,704
0A7FC:  MOVFF  FEC,705
0A800:  MOVFF  6FC,565
0A804:  MOVFF  6FB,564
0A808:  MOVLW  9A
0A80A:  MOVWF  FF6
0A80C:  MOVLW  03
0A80E:  MOVWF  FF7
0A810:  MOVLW  04
0A812:  MOVWF  x0F
0A814:  MOVLB  0
0A816:  CALL   55E6
0A81A:  MOVFF  6FD,706
0A81E:  MOVLW  1B
0A820:  MOVLB  7
0A822:  MOVWF  x07
0A824:  MOVLB  0
0A826:  CALL   560E
0A82A:  MOVLW  2C
0A82C:  MOVLB  7
0A82E:  MOVWF  x50
0A830:  MOVLB  0
0A832:  CALL   55C6
0A836:  MOVLW  89
0A838:  MOVWF  FE9
0A83A:  MOVFF  701,746
0A83E:  MOVFF  700,745
0A842:  MOVFF  6FF,744
0A846:  MOVFF  6FE,743
0A84A:  MOVLB  7
0A84C:  CLRF   x47
0A84E:  MOVLB  0
0A850:  CALL   5764
0A854:  MOVLW  2C
0A856:  MOVLB  7
0A858:  MOVWF  x50
0A85A:  MOVLB  0
0A85C:  CALL   55C6
0A860:  MOVLW  89
0A862:  MOVWF  FE9
0A864:  MOVFF  705,746
0A868:  MOVFF  704,745
0A86C:  MOVFF  703,744
0A870:  MOVFF  702,743
0A874:  MOVLB  7
0A876:  CLRF   x47
0A878:  MOVLB  0
0A87A:  CALL   5764
0A87E:  MOVLW  3B
0A880:  MOVLB  7
0A882:  MOVWF  x50
0A884:  MOVLB  0
0A886:  CALL   55C6
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
0A88A:  MOVLW  06
0A88C:  MOVLB  7
0A88E:  MOVWF  x42
0A890:  MOVLW  97
0A892:  MOVWF  x41
0A894:  MOVLB  0
0A896:  CALL   558E
0A89A:  MOVF   01,W
0A89C:  ADDLW  97
0A89E:  MOVLB  6
0A8A0:  MOVWF  xFB
0A8A2:  MOVLW  06
0A8A4:  ADDWFC 02,W
0A8A6:  MOVWF  xFC
0A8A8:  MOVLW  01
0A8AA:  ADDWF  x8F,W
0A8AC:  MOVWF  xFD
0A8AE:  MOVF   x8F,W
0A8B0:  MULLW  26
0A8B2:  MOVF   FF3,W
0A8B4:  CLRF   xFF
0A8B6:  MOVWF  xFE
0A8B8:  MOVLW  1D
0A8BA:  ADDWF  xFE,W
0A8BC:  MOVWF  01
0A8BE:  MOVLW  00
0A8C0:  ADDWFC xFF,W
0A8C2:  MOVWF  03
0A8C4:  MOVF   01,W
0A8C6:  ADDLW  17
0A8C8:  MOVWF  FE9
0A8CA:  MOVLW  01
0A8CC:  ADDWFC 03,W
0A8CE:  MOVWF  FEA
0A8D0:  MOVFF  FEF,6FE
0A8D4:  MOVFF  FEC,6FF
0A8D8:  MOVFF  FEC,700
0A8DC:  MOVFF  FEC,701
0A8E0:  MOVFF  6FC,565
0A8E4:  MOVFF  6FB,564
0A8E8:  MOVLW  AC
0A8EA:  MOVWF  FF6
0A8EC:  MOVLW  03
0A8EE:  MOVWF  FF7
0A8F0:  MOVLW  04
0A8F2:  MOVLB  7
0A8F4:  MOVWF  x0F
0A8F6:  MOVLB  0
0A8F8:  CALL   55E6
0A8FC:  MOVFF  6FD,706
0A900:  MOVLW  1B
0A902:  MOVLB  7
0A904:  MOVWF  x07
0A906:  MOVLB  0
0A908:  CALL   560E
0A90C:  MOVLW  2C
0A90E:  MOVLB  7
0A910:  MOVWF  x50
0A912:  MOVLB  0
0A914:  CALL   55C6
0A918:  MOVLW  89
0A91A:  MOVWF  FE9
0A91C:  MOVFF  701,746
0A920:  MOVFF  700,745
0A924:  MOVFF  6FF,744
0A928:  MOVFF  6FE,743
0A92C:  MOVLW  03
0A92E:  MOVLB  7
0A930:  MOVWF  x47
0A932:  MOVLB  0
0A934:  CALL   5764
0A938:  MOVLW  3B
0A93A:  MOVLB  7
0A93C:  MOVWF  x50
0A93E:  MOVLB  0
0A940:  CALL   55C6
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A944:  MOVLB  6
0A946:  MOVF   x8F,W
0A948:  MULLW  07
0A94A:  MOVF   FF3,W
0A94C:  CLRF   xFC
0A94E:  MOVWF  xFB
0A950:  MOVLW  64
0A952:  ADDWF  xFB,W
0A954:  MOVWF  FE9
0A956:  MOVLW  01
0A958:  ADDWFC xFC,W
0A95A:  MOVWF  FEA
0A95C:  BTFSS  FEF.0
0A95E:  BRA    AA0E
0A960:  MOVLW  06
0A962:  MOVLB  7
0A964:  MOVWF  x42
0A966:  MOVLW  97
0A968:  MOVWF  x41
0A96A:  MOVLB  0
0A96C:  CALL   558E
0A970:  MOVF   01,W
0A972:  ADDLW  97
0A974:  MOVLB  6
0A976:  MOVWF  xFB
0A978:  MOVLW  06
0A97A:  ADDWFC 02,W
0A97C:  MOVWF  xFC
0A97E:  MOVLW  01
0A980:  ADDWF  x8F,W
0A982:  MOVWF  xFD
0A984:  MOVF   x8F,W
0A986:  MULLW  07
0A988:  MOVF   FF3,W
0A98A:  CLRF   xFF
0A98C:  MOVWF  xFE
0A98E:  MOVLW  01
0A990:  ADDWF  xFE,W
0A992:  MOVWF  01
0A994:  MOVLW  00
0A996:  ADDWFC xFF,W
0A998:  MOVWF  03
0A99A:  MOVF   01,W
0A99C:  ADDLW  64
0A99E:  MOVWF  FE9
0A9A0:  MOVLW  01
0A9A2:  ADDWFC 03,W
0A9A4:  MOVWF  FEA
0A9A6:  MOVFF  FEC,6FF
0A9AA:  MOVF   FED,F
0A9AC:  MOVFF  FEF,6FE
0A9B0:  MOVFF  6FC,565
0A9B4:  MOVFF  6FB,564
0A9B8:  MOVLW  BA
0A9BA:  MOVWF  FF6
0A9BC:  MOVLW  03
0A9BE:  MOVWF  FF7
0A9C0:  MOVLW  04
0A9C2:  MOVLB  7
0A9C4:  MOVWF  x0F
0A9C6:  MOVLB  0
0A9C8:  CALL   55E6
0A9CC:  MOVFF  6FD,706
0A9D0:  MOVLW  1B
0A9D2:  MOVLB  7
0A9D4:  MOVWF  x07
0A9D6:  MOVLB  0
0A9D8:  CALL   560E
0A9DC:  MOVLW  C0
0A9DE:  MOVWF  FF6
0A9E0:  MOVLW  03
0A9E2:  MOVWF  FF7
0A9E4:  MOVLW  03
0A9E6:  MOVLB  7
0A9E8:  MOVWF  x0F
0A9EA:  MOVLB  0
0A9EC:  CALL   55E6
0A9F0:  MOVLW  10
0A9F2:  MOVWF  FE9
0A9F4:  MOVFF  6FF,701
0A9F8:  MOVFF  6FE,700
0A9FC:  CALL   590C
0AA00:  MOVLW  3B
0AA02:  MOVLB  7
0AA04:  MOVWF  x50
0AA06:  MOVLB  0
0AA08:  CALL   55C6
0AA0C:  BRA    AABA
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0AA0E:  MOVLW  06
0AA10:  MOVLB  7
0AA12:  MOVWF  x42
0AA14:  MOVLW  97
0AA16:  MOVWF  x41
0AA18:  MOVLB  0
0AA1A:  CALL   558E
0AA1E:  MOVF   01,W
0AA20:  ADDLW  97
0AA22:  MOVLB  6
0AA24:  MOVWF  xFB
0AA26:  MOVLW  06
0AA28:  ADDWFC 02,W
0AA2A:  MOVWF  xFC
0AA2C:  MOVLW  01
0AA2E:  ADDWF  x8F,W
0AA30:  MOVWF  xFD
0AA32:  MOVF   x8F,W
0AA34:  MULLW  07
0AA36:  MOVF   FF3,W
0AA38:  CLRF   xFF
0AA3A:  MOVWF  xFE
0AA3C:  MOVLW  01
0AA3E:  ADDWF  xFE,W
0AA40:  MOVWF  01
0AA42:  MOVLW  00
0AA44:  ADDWFC xFF,W
0AA46:  MOVWF  03
0AA48:  MOVF   01,W
0AA4A:  ADDLW  64
0AA4C:  MOVWF  FE9
0AA4E:  MOVLW  01
0AA50:  ADDWFC 03,W
0AA52:  MOVWF  FEA
0AA54:  MOVFF  FEC,6FF
0AA58:  MOVF   FED,F
0AA5A:  MOVFF  FEF,6FE
0AA5E:  MOVFF  6FC,565
0AA62:  MOVFF  6FB,564
0AA66:  MOVLW  C8
0AA68:  MOVWF  FF6
0AA6A:  MOVLW  03
0AA6C:  MOVWF  FF7
0AA6E:  MOVLW  04
0AA70:  MOVLB  7
0AA72:  MOVWF  x0F
0AA74:  MOVLB  0
0AA76:  CALL   55E6
0AA7A:  MOVFF  6FD,706
0AA7E:  MOVLW  1B
0AA80:  MOVLB  7
0AA82:  MOVWF  x07
0AA84:  MOVLB  0
0AA86:  CALL   560E
0AA8A:  MOVLW  CE
0AA8C:  MOVWF  FF6
0AA8E:  MOVLW  03
0AA90:  MOVWF  FF7
0AA92:  MOVLW  03
0AA94:  MOVLB  7
0AA96:  MOVWF  x0F
0AA98:  MOVLB  0
0AA9A:  CALL   55E6
0AA9E:  MOVLW  10
0AAA0:  MOVWF  FE9
0AAA2:  MOVFF  6FF,701
0AAA6:  MOVFF  6FE,700
0AAAA:  CALL   590C
0AAAE:  MOVLW  3B
0AAB0:  MOVLB  7
0AAB2:  MOVWF  x50
0AAB4:  MOVLB  0
0AAB6:  CALL   55C6
....................             ch = !ch;
0AABA:  MOVLB  6
0AABC:  MOVF   x8F,F
0AABE:  BTFSC  FD8.2
0AAC0:  BRA    AAC6
0AAC2:  MOVLW  00
0AAC4:  BRA    AAC8
0AAC6:  MOVLW  01
0AAC8:  MOVWF  x8F
....................             debugCounter = 0;
0AACA:  CLRF   x96
0AACC:  CLRF   x95
....................         }else debugCounter++;
....................         fprintf(ICD_STREAM, "%s\n", pBuff);
0AACE:  MOVLW  06
0AAD0:  MOVWF  FEA
0AAD2:  MOVLW  97
0AAD4:  MOVWF  FE9
0AAD6:  MOVLB  0
0AAD8:  GOTO   5A24
0AADC:  MOVLW  0A
0AADE:  MOVLB  6
0AAE0:  MOVWF  xFD
0AAE2:  MOVLB  0
0AAE4:  CALL   59D2
....................         #endif
....................       
....................         command_handler_task();    //execute commands
0AAE8:  GOTO   A1F0
....................       
....................         delay_ms(loopDelay);
0AAEC:  MOVFF  692,6FB
0AAF0:  MOVLB  6
0AAF2:  INCF   xFB,F
0AAF4:  DECF   xFB,F
0AAF6:  BTFSC  FD8.2
0AAF8:  BRA    AB08
0AAFA:  MOVLB  7
0AAFC:  SETF   x01
0AAFE:  MOVLB  0
0AB00:  CALL   03D6
0AB04:  MOVLB  6
0AB06:  BRA    AAF4
0AB08:  MOVFF  691,701
0AB0C:  MOVLB  0
0AB0E:  CALL   03D6
0AB12:  BRA    A742
....................     }
.................... }
0AB14:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
