CCS PCH C Compiler, Version 5.109, 62303               01-Aug-25 18:08

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   25000 bytes (38%)
                           Largest free fragment is 40534
               RAM used:   1514 (42%) at main() level
                           1628 (45%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 30

*
00000:  NOP   
00002:  GOTO   5CD8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0240
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00314:  DATA 32,30
00316:  DATA 32,35
00318:  DATA 30,35
0031A:  DATA 32,32
0031C:  DATA 00,00
0031E:  DATA 30,30
00320:  DATA 30,30
00322:  DATA 00,00
00324:  DATA 4D,41
00326:  DATA 4E,55
00328:  DATA 41,4C
0032A:  DATA 2C,00
0032C:  DATA 4D,41
0032E:  DATA 47,53
00330:  DATA 4E,53
00332:  DATA 2C,00
*
0065C:  ADDWF  FE8,W
0065E:  CLRF   FF7
00660:  RLCF   FF7,F
00662:  ADDLW  77
00664:  MOVWF  FF6
00666:  MOVLW  06
00668:  ADDWFC FF7,F
0066A:  TBLRD*-
0066C:  MOVF   FF5,W
0066E:  MOVWF  FFA
00670:  TBLRD*
00672:  MOVF   FF5,W
00674:  MOVWF  FF9
00676:  DATA 24,06
00678:  DATA 2E,06
0067A:  DATA 38,06
0067C:  DATA 42,06
*
00852:  MOVLB  6
00854:  MOVF   x2A,W
00856:  MULWF  x2C
00858:  MOVFF  FF3,01
0085C:  MOVFF  FF4,00
00860:  MULWF  x2D
00862:  MOVF   FF3,W
00864:  ADDWF  00,F
00866:  MOVF   x2B,W
00868:  MULWF  x2C
0086A:  MOVF   FF3,W
0086C:  ADDWFC 00,W
0086E:  MOVWF  02
00870:  MOVLB  0
00872:  RETURN 0
*
00A20:  MOVLW  8E
00A22:  MOVWF  00
00A24:  MOVFF  614,01
00A28:  MOVFF  613,02
00A2C:  CLRF   03
00A2E:  MOVF   01,F
00A30:  BNZ   0A44
00A32:  MOVFF  02,01
00A36:  CLRF   02
00A38:  MOVLW  08
00A3A:  SUBWF  00,F
00A3C:  MOVF   01,F
00A3E:  BNZ   0A44
00A40:  CLRF   00
00A42:  BRA    0A54
00A44:  BCF    FD8.0
00A46:  BTFSC  01.7
00A48:  BRA    0A52
00A4A:  RLCF   02,F
00A4C:  RLCF   01,F
00A4E:  DECF   00,F
00A50:  BRA    0A44
00A52:  BCF    01.7
00A54:  RETURN 0
00A56:  MOVLB  6
00A58:  MOVF   x2D,W
00A5A:  BTFSC  FD8.2
00A5C:  BRA    0B40
00A5E:  MOVWF  00
00A60:  MOVF   x31,W
00A62:  BTFSC  FD8.2
00A64:  BRA    0B40
00A66:  ADDWF  00,F
00A68:  BNC   0A72
00A6A:  MOVLW  81
00A6C:  ADDWF  00,F
00A6E:  BC    0B40
00A70:  BRA    0A7A
00A72:  MOVLW  7F
00A74:  SUBWF  00,F
00A76:  BNC   0B40
00A78:  BZ    0B40
00A7A:  MOVFF  62E,635
00A7E:  MOVF   x32,W
00A80:  XORWF  x35,F
00A82:  BSF    x2E.7
00A84:  BSF    x32.7
00A86:  MOVF   x30,W
00A88:  MULWF  x34
00A8A:  MOVFF  FF4,637
00A8E:  MOVF   x2F,W
00A90:  MULWF  x33
00A92:  MOVFF  FF4,03
00A96:  MOVFF  FF3,636
00A9A:  MULWF  x34
00A9C:  MOVF   FF3,W
00A9E:  ADDWF  x37,F
00AA0:  MOVF   FF4,W
00AA2:  ADDWFC x36,F
00AA4:  MOVLW  00
00AA6:  ADDWFC 03,F
00AA8:  MOVF   x30,W
00AAA:  MULWF  x33
00AAC:  MOVF   FF3,W
00AAE:  ADDWF  x37,F
00AB0:  MOVF   FF4,W
00AB2:  ADDWFC x36,F
00AB4:  MOVLW  00
00AB6:  CLRF   02
00AB8:  ADDWFC 03,F
00ABA:  ADDWFC 02,F
00ABC:  MOVF   x2E,W
00ABE:  MULWF  x34
00AC0:  MOVF   FF3,W
00AC2:  ADDWF  x36,F
00AC4:  MOVF   FF4,W
00AC6:  ADDWFC 03,F
00AC8:  MOVLW  00
00ACA:  ADDWFC 02,F
00ACC:  MOVF   x2E,W
00ACE:  MULWF  x33
00AD0:  MOVF   FF3,W
00AD2:  ADDWF  03,F
00AD4:  MOVF   FF4,W
00AD6:  ADDWFC 02,F
00AD8:  MOVLW  00
00ADA:  CLRF   01
00ADC:  ADDWFC 01,F
00ADE:  MOVF   x30,W
00AE0:  MULWF  x32
00AE2:  MOVF   FF3,W
00AE4:  ADDWF  x36,F
00AE6:  MOVF   FF4,W
00AE8:  ADDWFC 03,F
00AEA:  MOVLW  00
00AEC:  ADDWFC 02,F
00AEE:  ADDWFC 01,F
00AF0:  MOVF   x2F,W
00AF2:  MULWF  x32
00AF4:  MOVF   FF3,W
00AF6:  ADDWF  03,F
00AF8:  MOVF   FF4,W
00AFA:  ADDWFC 02,F
00AFC:  MOVLW  00
00AFE:  ADDWFC 01,F
00B00:  MOVF   x2E,W
00B02:  MULWF  x32
00B04:  MOVF   FF3,W
00B06:  ADDWF  02,F
00B08:  MOVF   FF4,W
00B0A:  ADDWFC 01,F
00B0C:  INCF   00,F
00B0E:  BTFSC  01.7
00B10:  BRA    0B1C
00B12:  RLCF   x36,F
00B14:  RLCF   03,F
00B16:  RLCF   02,F
00B18:  RLCF   01,F
00B1A:  DECF   00,F
00B1C:  MOVLW  00
00B1E:  BTFSS  x36.7
00B20:  BRA    0B36
00B22:  INCF   03,F
00B24:  ADDWFC 02,F
00B26:  ADDWFC 01,F
00B28:  MOVF   01,W
00B2A:  BNZ   0B36
00B2C:  MOVF   02,W
00B2E:  BNZ   0B36
00B30:  MOVF   03,W
00B32:  BNZ   0B36
00B34:  INCF   00,F
00B36:  BTFSC  x35.7
00B38:  BSF    01.7
00B3A:  BTFSS  x35.7
00B3C:  BCF    01.7
00B3E:  BRA    0B48
00B40:  CLRF   00
00B42:  CLRF   01
00B44:  CLRF   02
00B46:  CLRF   03
00B48:  MOVLB  0
00B4A:  RETURN 0
00B4C:  MOVLW  80
00B4E:  BTFSS  FD8.1
00B50:  BRA    0B56
00B52:  MOVLB  6
00B54:  XORWF  x18,F
00B56:  MOVLB  6
00B58:  CLRF   x1D
00B5A:  CLRF   x1E
00B5C:  MOVFF  614,61C
00B60:  MOVF   x18,W
00B62:  XORWF  x1C,F
00B64:  MOVF   x13,W
00B66:  BTFSC  FD8.2
00B68:  BRA    0D28
00B6A:  MOVWF  x1B
00B6C:  MOVWF  00
00B6E:  MOVF   x17,W
00B70:  BTFSC  FD8.2
00B72:  BRA    0D3A
00B74:  SUBWF  x1B,F
00B76:  BTFSC  FD8.2
00B78:  BRA    0C80
00B7A:  BNC   0BF8
00B7C:  MOVFF  618,621
00B80:  BSF    x21.7
00B82:  MOVFF  619,620
00B86:  MOVFF  61A,61F
00B8A:  CLRF   x1E
00B8C:  BCF    FD8.0
00B8E:  RRCF   x21,F
00B90:  RRCF   x20,F
00B92:  RRCF   x1F,F
00B94:  RRCF   x1E,F
00B96:  DECFSZ x1B,F
00B98:  BRA    0B8A
00B9A:  BTFSS  x1C.7
00B9C:  BRA    0BA4
00B9E:  BSF    x1D.0
00BA0:  BRA    0D62
00BA2:  BCF    x1D.0
00BA4:  BCF    x1B.0
00BA6:  BSF    x1D.4
00BA8:  MOVLW  06
00BAA:  MOVWF  FEA
00BAC:  MOVLW  16
00BAE:  MOVWF  FE9
00BB0:  BRA    0D88
00BB2:  BCF    x1D.4
00BB4:  BTFSC  x1C.7
00BB6:  BRA    0BCC
00BB8:  BTFSS  x1B.0
00BBA:  BRA    0BE2
00BBC:  RRCF   x21,F
00BBE:  RRCF   x20,F
00BC0:  RRCF   x1F,F
00BC2:  RRCF   x1E,F
00BC4:  INCF   00,F
00BC6:  BTFSC  FD8.2
00BC8:  BRA    0D58
00BCA:  BRA    0BE2
00BCC:  BTFSC  x21.7
00BCE:  BRA    0BE8
00BD0:  BCF    FD8.0
00BD2:  RLCF   x1E,F
00BD4:  RLCF   x1F,F
00BD6:  RLCF   x20,F
00BD8:  RLCF   x21,F
00BDA:  DECF   00,F
00BDC:  BTFSC  FD8.2
00BDE:  BRA    0D58
00BE0:  BRA    0BCC
00BE2:  BSF    x1D.6
00BE4:  BRA    0CC0
00BE6:  BCF    x1D.6
00BE8:  MOVFF  614,61C
00BEC:  BTFSS  x14.7
00BEE:  BRA    0BF4
00BF0:  BSF    x21.7
00BF2:  BRA    0D4A
00BF4:  BCF    x21.7
00BF6:  BRA    0D4A
00BF8:  MOVFF  617,61B
00BFC:  MOVFF  617,00
00C00:  MOVF   x13,W
00C02:  SUBWF  x1B,F
00C04:  MOVFF  614,621
00C08:  BSF    x21.7
00C0A:  MOVFF  615,620
00C0E:  MOVFF  616,61F
00C12:  CLRF   x1E
00C14:  BCF    FD8.0
00C16:  RRCF   x21,F
00C18:  RRCF   x20,F
00C1A:  RRCF   x1F,F
00C1C:  RRCF   x1E,F
00C1E:  DECFSZ x1B,F
00C20:  BRA    0C12
00C22:  BTFSS  x1C.7
00C24:  BRA    0C2C
00C26:  BSF    x1D.1
00C28:  BRA    0D62
00C2A:  BCF    x1D.1
00C2C:  BCF    x1B.0
00C2E:  BSF    x1D.5
00C30:  MOVLW  06
00C32:  MOVWF  FEA
00C34:  MOVLW  1A
00C36:  MOVWF  FE9
00C38:  BRA    0D88
00C3A:  BCF    x1D.5
00C3C:  BTFSC  x1C.7
00C3E:  BRA    0C54
00C40:  BTFSS  x1B.0
00C42:  BRA    0C6A
00C44:  RRCF   x21,F
00C46:  RRCF   x20,F
00C48:  RRCF   x1F,F
00C4A:  RRCF   x1E,F
00C4C:  INCF   00,F
00C4E:  BTFSC  FD8.2
00C50:  BRA    0D58
00C52:  BRA    0C6A
00C54:  BTFSC  x21.7
00C56:  BRA    0C70
00C58:  BCF    FD8.0
00C5A:  RLCF   x1E,F
00C5C:  RLCF   x1F,F
00C5E:  RLCF   x20,F
00C60:  RLCF   x21,F
00C62:  DECF   00,F
00C64:  BTFSC  FD8.2
00C66:  BRA    0D58
00C68:  BRA    0C54
00C6A:  BSF    x1D.7
00C6C:  BRA    0CC0
00C6E:  BCF    x1D.7
00C70:  MOVFF  618,61C
00C74:  BTFSS  x18.7
00C76:  BRA    0C7C
00C78:  BSF    x21.7
00C7A:  BRA    0D4A
00C7C:  BCF    x21.7
00C7E:  BRA    0D4A
00C80:  MOVFF  618,621
00C84:  BSF    x21.7
00C86:  MOVFF  619,620
00C8A:  MOVFF  61A,61F
00C8E:  BTFSS  x1C.7
00C90:  BRA    0C9A
00C92:  BCF    x21.7
00C94:  BSF    x1D.2
00C96:  BRA    0D62
00C98:  BCF    x1D.2
00C9A:  CLRF   x1E
00C9C:  BCF    x1B.0
00C9E:  MOVLW  06
00CA0:  MOVWF  FEA
00CA2:  MOVLW  16
00CA4:  MOVWF  FE9
00CA6:  BRA    0D88
00CA8:  BTFSC  x1C.7
00CAA:  BRA    0CE4
00CAC:  MOVFF  614,61C
00CB0:  BTFSS  x1B.0
00CB2:  BRA    0CC0
00CB4:  RRCF   x21,F
00CB6:  RRCF   x20,F
00CB8:  RRCF   x1F,F
00CBA:  RRCF   x1E,F
00CBC:  INCF   00,F
00CBE:  BZ    0D58
00CC0:  BTFSS  x1E.7
00CC2:  BRA    0CDA
00CC4:  INCF   x1F,F
00CC6:  BNZ   0CDA
00CC8:  INCF   x20,F
00CCA:  BNZ   0CDA
00CCC:  INCF   x21,F
00CCE:  BNZ   0CDA
00CD0:  RRCF   x21,F
00CD2:  RRCF   x20,F
00CD4:  RRCF   x1F,F
00CD6:  INCF   00,F
00CD8:  BZ    0D58
00CDA:  BTFSC  x1D.6
00CDC:  BRA    0BE6
00CDE:  BTFSC  x1D.7
00CE0:  BRA    0C6E
00CE2:  BRA    0D1C
00CE4:  MOVLW  80
00CE6:  XORWF  x21,F
00CE8:  BTFSS  x21.7
00CEA:  BRA    0CF4
00CEC:  BRA    0D62
00CEE:  MOVFF  618,61C
00CF2:  BRA    0D08
00CF4:  MOVFF  614,61C
00CF8:  MOVF   x21,F
00CFA:  BNZ   0D08
00CFC:  MOVF   x20,F
00CFE:  BNZ   0D08
00D00:  MOVF   x1F,F
00D02:  BNZ   0D08
00D04:  CLRF   00
00D06:  BRA    0D4A
00D08:  BTFSC  x21.7
00D0A:  BRA    0D1C
00D0C:  BCF    FD8.0
00D0E:  RLCF   x1E,F
00D10:  RLCF   x1F,F
00D12:  RLCF   x20,F
00D14:  RLCF   x21,F
00D16:  DECFSZ 00,F
00D18:  BRA    0D08
00D1A:  BRA    0D58
00D1C:  BTFSS  x1C.7
00D1E:  BRA    0D24
00D20:  BSF    x21.7
00D22:  BRA    0D4A
00D24:  BCF    x21.7
00D26:  BRA    0D4A
00D28:  MOVFF  617,00
00D2C:  MOVFF  618,621
00D30:  MOVFF  619,620
00D34:  MOVFF  61A,61F
00D38:  BRA    0D4A
00D3A:  MOVFF  613,00
00D3E:  MOVFF  614,621
00D42:  MOVFF  615,620
00D46:  MOVFF  616,61F
00D4A:  MOVFF  621,01
00D4E:  MOVFF  620,02
00D52:  MOVFF  61F,03
00D56:  BRA    0DC0
00D58:  CLRF   00
00D5A:  CLRF   01
00D5C:  CLRF   02
00D5E:  CLRF   03
00D60:  BRA    0DC0
00D62:  CLRF   x1E
00D64:  COMF   x1F,F
00D66:  COMF   x20,F
00D68:  COMF   x21,F
00D6A:  COMF   x1E,F
00D6C:  INCF   x1E,F
00D6E:  BNZ   0D7A
00D70:  INCF   x1F,F
00D72:  BNZ   0D7A
00D74:  INCF   x20,F
00D76:  BNZ   0D7A
00D78:  INCF   x21,F
00D7A:  BTFSC  x1D.0
00D7C:  BRA    0BA2
00D7E:  BTFSC  x1D.1
00D80:  BRA    0C2A
00D82:  BTFSC  x1D.2
00D84:  BRA    0C98
00D86:  BRA    0CEE
00D88:  MOVF   FEF,W
00D8A:  ADDWF  x1F,F
00D8C:  BNC   0D98
00D8E:  INCF   x20,F
00D90:  BNZ   0D98
00D92:  INCF   x21,F
00D94:  BTFSC  FD8.2
00D96:  BSF    x1B.0
00D98:  MOVF   FED,F
00D9A:  MOVF   FEF,W
00D9C:  ADDWF  x20,F
00D9E:  BNC   0DA6
00DA0:  INCF   x21,F
00DA2:  BTFSC  FD8.2
00DA4:  BSF    x1B.0
00DA6:  MOVF   FED,F
00DA8:  MOVF   FEF,W
00DAA:  BTFSC  FEF.7
00DAC:  BRA    0DB0
00DAE:  XORLW  80
00DB0:  ADDWF  x21,F
00DB2:  BTFSC  FD8.0
00DB4:  BSF    x1B.0
00DB6:  BTFSC  x1D.4
00DB8:  BRA    0BB2
00DBA:  BTFSC  x1D.5
00DBC:  BRA    0C3A
00DBE:  BRA    0CA8
00DC0:  MOVLB  0
00DC2:  RETURN 0
*
012DA:  MOVLB  5
012DC:  MOVF   xF6,W
012DE:  ANDLW  07
012E0:  MOVWF  00
012E2:  RRCF   xF6,W
012E4:  MOVWF  01
012E6:  RRCF   01,F
012E8:  RRCF   01,F
012EA:  MOVLW  1F
012EC:  ANDWF  01,F
012EE:  MOVF   01,W
012F0:  ADDWF  xF7,W
012F2:  MOVWF  FE9
012F4:  MOVLW  00
012F6:  ADDWFC xF8,W
012F8:  MOVWF  FEA
012FA:  MOVFF  FEF,01
012FE:  INCF   00,F
01300:  BRA    1304
01302:  RRCF   01,F
01304:  DECFSZ 00,F
01306:  BRA    1302
01308:  MOVLW  01
0130A:  ANDWF  01,F
0130C:  MOVLB  0
0130E:  RETURN 0
01310:  MOVFF  5F1,5F8
01314:  MOVLB  5
01316:  MOVF   xF5,W
01318:  XORWF  xF8,F
0131A:  BTFSS  xF8.7
0131C:  BRA    1328
0131E:  BCF    FD8.2
01320:  BCF    FD8.0
01322:  BTFSC  xF1.7
01324:  BSF    FD8.0
01326:  BRA    1386
01328:  MOVFF  5F1,5F8
0132C:  MOVFF  5F4,5F9
01330:  MOVF   xF0,W
01332:  SUBWF  xF9,F
01334:  BZ    1342
01336:  BTFSS  xF8.7
01338:  BRA    1386
0133A:  MOVF   FD8,W
0133C:  XORLW  01
0133E:  MOVWF  FD8
01340:  BRA    1386
01342:  MOVFF  5F5,5F9
01346:  MOVF   xF1,W
01348:  SUBWF  xF9,F
0134A:  BZ    1358
0134C:  BTFSS  xF8.7
0134E:  BRA    1386
01350:  MOVF   FD8,W
01352:  XORLW  01
01354:  MOVWF  FD8
01356:  BRA    1386
01358:  MOVFF  5F6,5F9
0135C:  MOVF   xF2,W
0135E:  SUBWF  xF9,F
01360:  BZ    136E
01362:  BTFSS  xF8.7
01364:  BRA    1386
01366:  MOVF   FD8,W
01368:  XORLW  01
0136A:  MOVWF  FD8
0136C:  BRA    1386
0136E:  MOVFF  5F7,5F9
01372:  MOVF   xF3,W
01374:  SUBWF  xF9,F
01376:  BZ    1384
01378:  BTFSS  xF8.7
0137A:  BRA    1386
0137C:  MOVF   FD8,W
0137E:  XORLW  01
01380:  MOVWF  FD8
01382:  BRA    1386
01384:  BCF    FD8.0
01386:  MOVLB  0
01388:  RETURN 0
*
013E6:  MOVLW  8E
013E8:  MOVWF  00
013EA:  MOVLB  5
013EC:  MOVF   xFB,W
013EE:  SUBWF  00,F
013F0:  MOVFF  5FC,02
013F4:  MOVFF  5FD,01
013F8:  BSF    02.7
013FA:  MOVF   00,F
013FC:  BZ    1410
013FE:  BCF    FD8.0
01400:  MOVF   02,F
01402:  BNZ   1408
01404:  MOVF   01,F
01406:  BZ    1410
01408:  RRCF   02,F
0140A:  RRCF   01,F
0140C:  DECFSZ 00,F
0140E:  BRA    13FE
01410:  BTFSS  xFC.7
01412:  BRA    141E
01414:  COMF   01,F
01416:  COMF   02,F
01418:  INCF   01,F
0141A:  BTFSC  FD8.2
0141C:  INCF   02,F
0141E:  MOVLB  0
01420:  RETURN 0
*
01726:  MOVF   FEF,F
01728:  BZ    1748
0172A:  MOVFF  FEA,5EF
0172E:  MOVFF  FE9,5EE
01732:  MOVFF  FEF,5F5
01736:  RCALL  16FE
01738:  MOVFF  5EF,FEA
0173C:  MOVFF  5EE,FE9
01740:  INCF   FE9,F
01742:  BTFSC  FD8.2
01744:  INCF   FEA,F
01746:  BRA    1726
01748:  RETURN 0
*
01CDA:  BTFSC  FD8.1
01CDC:  BRA    1CE6
01CDE:  MOVLW  06
01CE0:  MOVWF  FEA
01CE2:  MOVLW  36
01CE4:  MOVWF  FE9
01CE6:  CLRF   00
01CE8:  CLRF   01
01CEA:  CLRF   02
01CEC:  CLRF   03
01CEE:  MOVLB  6
01CF0:  CLRF   x36
01CF2:  CLRF   x37
01CF4:  CLRF   x38
01CF6:  CLRF   x39
01CF8:  MOVF   x35,W
01CFA:  IORWF  x34,W
01CFC:  IORWF  x33,W
01CFE:  IORWF  x32,W
01D00:  BZ    1D5A
01D02:  MOVLW  20
01D04:  MOVWF  x3A
01D06:  BCF    FD8.0
01D08:  RLCF   x2E,F
01D0A:  RLCF   x2F,F
01D0C:  RLCF   x30,F
01D0E:  RLCF   x31,F
01D10:  RLCF   x36,F
01D12:  RLCF   x37,F
01D14:  RLCF   x38,F
01D16:  RLCF   x39,F
01D18:  MOVF   x35,W
01D1A:  SUBWF  x39,W
01D1C:  BNZ   1D2E
01D1E:  MOVF   x34,W
01D20:  SUBWF  x38,W
01D22:  BNZ   1D2E
01D24:  MOVF   x33,W
01D26:  SUBWF  x37,W
01D28:  BNZ   1D2E
01D2A:  MOVF   x32,W
01D2C:  SUBWF  x36,W
01D2E:  BNC   1D4E
01D30:  MOVF   x32,W
01D32:  SUBWF  x36,F
01D34:  MOVF   x33,W
01D36:  BTFSS  FD8.0
01D38:  INCFSZ x33,W
01D3A:  SUBWF  x37,F
01D3C:  MOVF   x34,W
01D3E:  BTFSS  FD8.0
01D40:  INCFSZ x34,W
01D42:  SUBWF  x38,F
01D44:  MOVF   x35,W
01D46:  BTFSS  FD8.0
01D48:  INCFSZ x35,W
01D4A:  SUBWF  x39,F
01D4C:  BSF    FD8.0
01D4E:  RLCF   00,F
01D50:  RLCF   01,F
01D52:  RLCF   02,F
01D54:  RLCF   03,F
01D56:  DECFSZ x3A,F
01D58:  BRA    1D06
01D5A:  MOVFF  636,FEF
01D5E:  MOVFF  637,FEC
01D62:  MOVFF  638,FEC
01D66:  MOVFF  639,FEC
01D6A:  MOVLB  0
01D6C:  RETURN 0
01D6E:  MOVF   FE9,W
01D70:  MOVLB  5
01D72:  MOVWF  xED
01D74:  BTFSS  xEC.7
01D76:  BRA    1D92
01D78:  DECF   xED,F
01D7A:  BSF    xED.5
01D7C:  COMF   xE9,F
01D7E:  COMF   xEA,F
01D80:  COMF   xEB,F
01D82:  COMF   xEC,F
01D84:  INCF   xE9,F
01D86:  BTFSC  FD8.2
01D88:  INCF   xEA,F
01D8A:  BTFSC  FD8.2
01D8C:  INCF   xEB,F
01D8E:  BTFSC  FD8.2
01D90:  INCF   xEC,F
01D92:  MOVLW  3B
01D94:  MOVWF  xF4
01D96:  MOVLW  9A
01D98:  MOVWF  xF3
01D9A:  MOVLW  CA
01D9C:  MOVWF  xF2
01D9E:  CLRF   xF1
01DA0:  MOVLW  0A
01DA2:  MOVWF  xEF
01DA4:  BSF    FD8.1
01DA6:  MOVLW  05
01DA8:  MOVWF  FEA
01DAA:  MOVLW  E9
01DAC:  MOVWF  FE9
01DAE:  MOVFF  5EC,631
01DB2:  MOVFF  5EB,630
01DB6:  MOVFF  5EA,62F
01DBA:  MOVFF  5E9,62E
01DBE:  MOVFF  5F4,635
01DC2:  MOVFF  5F3,634
01DC6:  MOVFF  5F2,633
01DCA:  MOVFF  5F1,632
01DCE:  MOVLB  0
01DD0:  RCALL  1CDA
01DD2:  MOVF   01,W
01DD4:  MOVF   00,F
01DD6:  BNZ   1DFE
01DD8:  MOVLB  5
01DDA:  MOVF   xEF,W
01DDC:  XORLW  01
01DDE:  BTFSS  FD8.2
01DE0:  BRA    1DE6
01DE2:  MOVLB  0
01DE4:  BRA    1DFE
01DE6:  MOVF   xED,W
01DE8:  BZ    1E04
01DEA:  ANDLW  0F
01DEC:  SUBWF  xEF,W
01DEE:  BZ    1DF2
01DF0:  BC    1E48
01DF2:  BTFSC  xED.7
01DF4:  BRA    1E48
01DF6:  BTFSC  xED.6
01DF8:  BRA    1E04
01DFA:  MOVLW  20
01DFC:  BRA    1E3C
01DFE:  MOVLW  20
01E00:  MOVLB  5
01E02:  ANDWF  xED,F
01E04:  BTFSS  xED.5
01E06:  BRA    1E1E
01E08:  BCF    xED.5
01E0A:  MOVFF  00,5ED
01E0E:  MOVLW  2D
01E10:  MOVWF  xF5
01E12:  MOVLB  0
01E14:  RCALL  16FE
01E16:  MOVLB  5
01E18:  MOVFF  5ED,00
01E1C:  CLRF   xED
01E1E:  MOVLW  30
01E20:  BTFSS  xED.5
01E22:  BRA    1E3C
01E24:  BCF    xED.5
01E26:  MOVFF  00,5ED
01E2A:  MOVLW  2D
01E2C:  MOVWF  xF5
01E2E:  MOVLB  0
01E30:  RCALL  16FE
01E32:  MOVLB  5
01E34:  MOVFF  5ED,00
01E38:  CLRF   xED
01E3A:  MOVLW  30
01E3C:  ADDWF  00,F
01E3E:  MOVFF  00,5F5
01E42:  MOVLB  0
01E44:  RCALL  16FE
01E46:  MOVLB  5
01E48:  BCF    FD8.1
01E4A:  MOVFF  5F4,631
01E4E:  MOVFF  5F3,630
01E52:  MOVFF  5F2,62F
01E56:  MOVFF  5F1,62E
01E5A:  MOVLB  6
01E5C:  CLRF   x35
01E5E:  CLRF   x34
01E60:  CLRF   x33
01E62:  MOVLW  0A
01E64:  MOVWF  x32
01E66:  MOVLB  0
01E68:  RCALL  1CDA
01E6A:  MOVFF  03,5F4
01E6E:  MOVFF  02,5F3
01E72:  MOVFF  01,5F2
01E76:  MOVFF  00,5F1
01E7A:  MOVLB  5
01E7C:  DECFSZ xEF,F
01E7E:  BRA    1DA4
01E80:  MOVLB  0
01E82:  RETURN 0
*
01FC8:  MOVFF  4D0,FEA
01FCC:  MOVFF  4CF,FE9
01FD0:  MOVFF  635,FEF
01FD4:  INCF   FE9,F
01FD6:  BTFSC  FD8.2
01FD8:  INCF   FEA,F
01FDA:  CLRF   FEF
01FDC:  MOVLB  4
01FDE:  INCF   xCF,F
01FE0:  BTFSC  FD8.2
01FE2:  INCF   xD0,F
01FE4:  MOVLB  0
01FE6:  RETURN 0
01FE8:  TBLRD*+
01FEA:  MOVF   FF5,F
01FEC:  BZ    2006
01FEE:  MOVFF  FF6,5F8
01FF2:  MOVFF  FF7,5F9
01FF6:  MOVFF  FF5,635
01FFA:  RCALL  1FC8
01FFC:  MOVFF  5F8,FF6
02000:  MOVFF  5F9,FF7
02004:  BRA    1FE8
02006:  RETURN 0
*
0212A:  MOVLB  6
0212C:  MOVF   x51,W
0212E:  XORWF  x53,W
02130:  ANDLW  80
02132:  MOVWF  x55
02134:  BTFSS  x51.7
02136:  BRA    2142
02138:  COMF   x50,F
0213A:  COMF   x51,F
0213C:  INCF   x50,F
0213E:  BTFSC  FD8.2
02140:  INCF   x51,F
02142:  BTFSS  x53.7
02144:  BRA    2150
02146:  COMF   x52,F
02148:  COMF   x53,F
0214A:  INCF   x52,F
0214C:  BTFSC  FD8.2
0214E:  INCF   x53,F
02150:  MOVF   x50,W
02152:  MULWF  x52
02154:  MOVFF  FF3,01
02158:  MOVFF  FF4,00
0215C:  MULWF  x53
0215E:  MOVF   FF3,W
02160:  ADDWF  00,F
02162:  MOVF   x51,W
02164:  MULWF  x52
02166:  MOVF   FF3,W
02168:  ADDWFC 00,W
0216A:  MOVWF  02
0216C:  BTFSS  x55.7
0216E:  BRA    217A
02170:  COMF   01,F
02172:  COMF   02,F
02174:  INCF   01,F
02176:  BTFSC  FD8.2
02178:  INCF   02,F
0217A:  MOVLB  0
0217C:  GOTO   2410 (RETURN)
*
02646:  MOVLB  6
02648:  MOVF   x0B,W
0264A:  ANDLW  07
0264C:  MOVWF  00
0264E:  RRCF   x0B,W
02650:  MOVWF  01
02652:  RRCF   01,F
02654:  RRCF   01,F
02656:  MOVLW  1F
02658:  ANDWF  01,F
0265A:  MOVF   01,W
0265C:  ADDWF  x0D,W
0265E:  MOVWF  FE9
02660:  MOVLW  00
02662:  ADDWFC x0E,W
02664:  MOVWF  FEA
02666:  CLRF   01
02668:  INCF   01,F
0266A:  INCF   00,F
0266C:  BRA    2670
0266E:  RLCF   01,F
02670:  DECFSZ 00,F
02672:  BRA    266E
02674:  MOVF   x0C,F
02676:  BZ    267E
02678:  MOVF   01,W
0267A:  IORWF  FEF,F
0267C:  BRA    2684
0267E:  COMF   01,F
02680:  MOVF   01,W
02682:  ANDWF  FEF,F
02684:  MOVLB  0
02686:  RETURN 0
*
02BCA:  MOVLB  6
02BCC:  MOVF   x2D,W
02BCE:  SUBLW  B6
02BD0:  MOVWF  x2D
02BD2:  CLRF   03
02BD4:  MOVFF  62E,631
02BD8:  BSF    x2E.7
02BDA:  BCF    FD8.0
02BDC:  RRCF   x2E,F
02BDE:  RRCF   x2F,F
02BE0:  RRCF   x30,F
02BE2:  RRCF   03,F
02BE4:  RRCF   02,F
02BE6:  RRCF   01,F
02BE8:  RRCF   00,F
02BEA:  DECFSZ x2D,F
02BEC:  BRA    2BDA
02BEE:  BTFSS  x31.7
02BF0:  BRA    2C08
02BF2:  COMF   00,F
02BF4:  COMF   01,F
02BF6:  COMF   02,F
02BF8:  COMF   03,F
02BFA:  INCF   00,F
02BFC:  BTFSC  FD8.2
02BFE:  INCF   01,F
02C00:  BTFSC  FD8.2
02C02:  INCF   02,F
02C04:  BTFSC  FD8.2
02C06:  INCF   03,F
02C08:  MOVLB  0
02C0A:  RETURN 0
02C0C:  MOVF   FE9,W
02C0E:  MOVLB  6
02C10:  MOVWF  x25
02C12:  MOVF   x24,W
02C14:  MOVWF  x27
02C16:  BZ    2C50
02C18:  MOVFF  623,630
02C1C:  MOVFF  622,62F
02C20:  MOVFF  621,62E
02C24:  MOVFF  620,62D
02C28:  CLRF   x34
02C2A:  CLRF   x33
02C2C:  MOVLW  20
02C2E:  MOVWF  x32
02C30:  MOVLW  82
02C32:  MOVWF  x31
02C34:  MOVLB  0
02C36:  CALL   0A56
02C3A:  MOVFF  03,623
02C3E:  MOVFF  02,622
02C42:  MOVFF  01,621
02C46:  MOVFF  00,620
02C4A:  MOVLB  6
02C4C:  DECFSZ x27,F
02C4E:  BRA    2C18
02C50:  MOVFF  623,630
02C54:  MOVFF  622,62F
02C58:  MOVFF  621,62E
02C5C:  MOVFF  620,62D
02C60:  MOVLB  0
02C62:  RCALL  2BCA
02C64:  MOVFF  03,623
02C68:  MOVFF  02,622
02C6C:  MOVFF  01,621
02C70:  MOVFF  00,620
02C74:  MOVLB  6
02C76:  BTFSS  x23.7
02C78:  BRA    2C94
02C7A:  DECF   x25,F
02C7C:  BSF    x25.5
02C7E:  COMF   x20,F
02C80:  COMF   x21,F
02C82:  COMF   x22,F
02C84:  COMF   x23,F
02C86:  INCF   x20,F
02C88:  BTFSC  FD8.2
02C8A:  INCF   x21,F
02C8C:  BTFSC  FD8.2
02C8E:  INCF   x22,F
02C90:  BTFSC  FD8.2
02C92:  INCF   x23,F
02C94:  MOVLW  3B
02C96:  MOVWF  x2C
02C98:  MOVLW  9A
02C9A:  MOVWF  x2B
02C9C:  MOVLW  CA
02C9E:  MOVWF  x2A
02CA0:  CLRF   x29
02CA2:  MOVLW  0A
02CA4:  MOVWF  x27
02CA6:  MOVF   x24,W
02CA8:  BTFSC  FD8.2
02CAA:  INCF   x25,F
02CAC:  BSF    FD8.1
02CAE:  MOVLW  06
02CB0:  MOVWF  FEA
02CB2:  MOVLW  20
02CB4:  MOVWF  FE9
02CB6:  MOVFF  623,631
02CBA:  MOVFF  622,630
02CBE:  MOVFF  621,62F
02CC2:  MOVFF  620,62E
02CC6:  MOVFF  62C,635
02CCA:  MOVFF  62B,634
02CCE:  MOVFF  62A,633
02CD2:  MOVFF  629,632
02CD6:  MOVLB  0
02CD8:  CALL   1CDA
02CDC:  MOVF   01,W
02CDE:  MOVF   00,F
02CE0:  BNZ   2D08
02CE2:  MOVLB  6
02CE4:  INCF   x24,W
02CE6:  SUBWF  x27,W
02CE8:  BTFSS  FD8.2
02CEA:  BRA    2CF0
02CEC:  MOVLB  0
02CEE:  BRA    2D08
02CF0:  MOVF   x25,W
02CF2:  BZ    2D0E
02CF4:  ANDLW  0F
02CF6:  SUBWF  x27,W
02CF8:  BZ    2CFC
02CFA:  BC    2D84
02CFC:  BTFSC  x25.7
02CFE:  BRA    2D84
02D00:  BTFSC  x25.6
02D02:  BRA    2D0E
02D04:  MOVLW  20
02D06:  BRA    2D76
02D08:  MOVLW  20
02D0A:  MOVLB  6
02D0C:  ANDWF  x25,F
02D0E:  BTFSS  x25.5
02D10:  BRA    2D30
02D12:  BCF    x25.5
02D14:  MOVF   x24,W
02D16:  BTFSS  FD8.2
02D18:  DECF   x25,F
02D1A:  MOVF   00,W
02D1C:  MOVWF  x25
02D1E:  MOVLW  2D
02D20:  MOVWF  x35
02D22:  MOVLB  0
02D24:  CALL   1FC8
02D28:  MOVLB  6
02D2A:  MOVF   x25,W
02D2C:  MOVWF  00
02D2E:  CLRF   x25
02D30:  MOVF   x24,W
02D32:  SUBWF  x27,W
02D34:  BNZ   2D50
02D36:  MOVF   00,W
02D38:  MOVWF  x25
02D3A:  MOVLW  2E
02D3C:  MOVWF  x35
02D3E:  MOVLB  0
02D40:  CALL   1FC8
02D44:  MOVLB  6
02D46:  MOVF   x25,W
02D48:  MOVWF  00
02D4A:  MOVLW  20
02D4C:  ANDWF  x25,F
02D4E:  MOVLW  00
02D50:  MOVLW  30
02D52:  BTFSS  x25.5
02D54:  BRA    2D76
02D56:  BCF    x25.5
02D58:  MOVF   x24,W
02D5A:  BTFSS  FD8.2
02D5C:  DECF   x25,F
02D5E:  MOVF   00,W
02D60:  MOVWF  x25
02D62:  MOVLW  2D
02D64:  MOVWF  x35
02D66:  MOVLB  0
02D68:  CALL   1FC8
02D6C:  MOVLB  6
02D6E:  MOVF   x25,W
02D70:  MOVWF  00
02D72:  CLRF   x25
02D74:  MOVLW  30
02D76:  ADDWF  00,F
02D78:  MOVFF  00,635
02D7C:  MOVLB  0
02D7E:  CALL   1FC8
02D82:  MOVLB  6
02D84:  BCF    FD8.1
02D86:  MOVFF  62C,631
02D8A:  MOVFF  62B,630
02D8E:  MOVFF  62A,62F
02D92:  MOVFF  629,62E
02D96:  CLRF   x35
02D98:  CLRF   x34
02D9A:  CLRF   x33
02D9C:  MOVLW  0A
02D9E:  MOVWF  x32
02DA0:  MOVLB  0
02DA2:  CALL   1CDA
02DA6:  MOVFF  03,62C
02DAA:  MOVFF  02,62B
02DAE:  MOVFF  01,62A
02DB2:  MOVFF  00,629
02DB6:  MOVLB  6
02DB8:  DECFSZ x27,F
02DBA:  BRA    2CAC
02DBC:  MOVLB  0
02DBE:  RETURN 0
*
030A8:  MOVLB  6
030AA:  MOVF   x13,W
030AC:  BTFSC  FD8.2
030AE:  BRA    31FA
030B0:  MOVWF  x1F
030B2:  MOVF   x17,W
030B4:  BTFSC  FD8.2
030B6:  BRA    31FA
030B8:  SUBWF  x1F,F
030BA:  BNC   30C6
030BC:  MOVLW  7F
030BE:  ADDWF  x1F,F
030C0:  BTFSC  FD8.0
030C2:  BRA    31FA
030C4:  BRA    30D2
030C6:  MOVLW  81
030C8:  SUBWF  x1F,F
030CA:  BTFSS  FD8.0
030CC:  BRA    31FA
030CE:  BTFSC  FD8.2
030D0:  BRA    31FA
030D2:  MOVFF  61F,00
030D6:  CLRF   01
030D8:  CLRF   02
030DA:  CLRF   03
030DC:  CLRF   x1E
030DE:  MOVFF  614,61D
030E2:  BSF    x1D.7
030E4:  MOVFF  615,61C
030E8:  MOVFF  616,61B
030EC:  MOVLW  19
030EE:  MOVWF  x1F
030F0:  MOVF   x1A,W
030F2:  SUBWF  x1B,F
030F4:  BC    3110
030F6:  MOVLW  01
030F8:  SUBWF  x1C,F
030FA:  BC    3110
030FC:  SUBWF  x1D,F
030FE:  BC    3110
03100:  SUBWF  x1E,F
03102:  BC    3110
03104:  INCF   x1E,F
03106:  INCF   x1D,F
03108:  INCF   x1C,F
0310A:  MOVF   x1A,W
0310C:  ADDWF  x1B,F
0310E:  BRA    3160
03110:  MOVF   x19,W
03112:  SUBWF  x1C,F
03114:  BC    313A
03116:  MOVLW  01
03118:  SUBWF  x1D,F
0311A:  BC    313A
0311C:  SUBWF  x1E,F
0311E:  BC    313A
03120:  INCF   x1E,F
03122:  INCF   x1D,F
03124:  MOVF   x19,W
03126:  ADDWF  x1C,F
03128:  MOVF   x1A,W
0312A:  ADDWF  x1B,F
0312C:  BNC   3160
0312E:  INCF   x1C,F
03130:  BNZ   3160
03132:  INCF   x1D,F
03134:  BNZ   3160
03136:  INCF   x1E,F
03138:  BRA    3160
0313A:  MOVF   x18,W
0313C:  IORLW  80
0313E:  SUBWF  x1D,F
03140:  BC    315E
03142:  MOVLW  01
03144:  SUBWF  x1E,F
03146:  BC    315E
03148:  INCF   x1E,F
0314A:  MOVF   x18,W
0314C:  IORLW  80
0314E:  ADDWF  x1D,F
03150:  MOVF   x19,W
03152:  ADDWF  x1C,F
03154:  BNC   3128
03156:  INCF   x1D,F
03158:  BNZ   3128
0315A:  INCF   x1E,F
0315C:  BRA    3128
0315E:  BSF    03.0
03160:  DECFSZ x1F,F
03162:  BRA    3166
03164:  BRA    317C
03166:  BCF    FD8.0
03168:  RLCF   x1B,F
0316A:  RLCF   x1C,F
0316C:  RLCF   x1D,F
0316E:  RLCF   x1E,F
03170:  BCF    FD8.0
03172:  RLCF   03,F
03174:  RLCF   02,F
03176:  RLCF   01,F
03178:  RLCF   x20,F
0317A:  BRA    30F0
0317C:  BTFSS  x20.0
0317E:  BRA    318C
03180:  BCF    FD8.0
03182:  RRCF   01,F
03184:  RRCF   02,F
03186:  RRCF   03,F
03188:  RRCF   x20,F
0318A:  BRA    3190
0318C:  DECF   00,F
0318E:  BZ    31FA
03190:  BTFSC  x20.7
03192:  BRA    31D0
03194:  BCF    FD8.0
03196:  RLCF   x1B,F
03198:  RLCF   x1C,F
0319A:  RLCF   x1D,F
0319C:  RLCF   x1E,F
0319E:  MOVF   x1A,W
031A0:  SUBWF  x1B,F
031A2:  BC    31B2
031A4:  MOVLW  01
031A6:  SUBWF  x1C,F
031A8:  BC    31B2
031AA:  SUBWF  x1D,F
031AC:  BC    31B2
031AE:  SUBWF  x1E,F
031B0:  BNC   31E6
031B2:  MOVF   x19,W
031B4:  SUBWF  x1C,F
031B6:  BC    31C2
031B8:  MOVLW  01
031BA:  SUBWF  x1D,F
031BC:  BC    31C2
031BE:  SUBWF  x1E,F
031C0:  BNC   31E6
031C2:  MOVF   x18,W
031C4:  IORLW  80
031C6:  SUBWF  x1D,F
031C8:  BC    31D0
031CA:  MOVLW  01
031CC:  SUBWF  x1E,F
031CE:  BNC   31E6
031D0:  INCF   03,F
031D2:  BNZ   31E6
031D4:  INCF   02,F
031D6:  BNZ   31E6
031D8:  INCF   01,F
031DA:  BNZ   31E6
031DC:  INCF   00,F
031DE:  BZ    31FA
031E0:  RRCF   01,F
031E2:  RRCF   02,F
031E4:  RRCF   03,F
031E6:  MOVFF  614,61F
031EA:  MOVF   x18,W
031EC:  XORWF  x1F,F
031EE:  BTFSS  x1F.7
031F0:  BRA    31F6
031F2:  BSF    01.7
031F4:  BRA    3202
031F6:  BCF    01.7
031F8:  BRA    3202
031FA:  CLRF   00
031FC:  CLRF   01
031FE:  CLRF   02
03200:  CLRF   03
03202:  MOVLB  0
03204:  GOTO   3316 (RETURN)
*
04758:  MOVFF  FEA,634
0475C:  MOVFF  FE9,633
04760:  MOVLB  6
04762:  BTFSS  x2D.7
04764:  BRA    4776
04766:  BSF    x33.7
04768:  BTFSS  x33.4
0476A:  INCF   x33,F
0476C:  COMF   x2C,F
0476E:  COMF   x2D,F
04770:  INCF   x2C,F
04772:  BTFSC  FD8.2
04774:  INCF   x2D,F
04776:  SWAPF  x2D,W
04778:  IORLW  F0
0477A:  MOVWF  x2F
0477C:  ADDWF  x2F,F
0477E:  ADDLW  E2
04780:  MOVWF  x30
04782:  ADDLW  32
04784:  MOVWF  x32
04786:  MOVF   x2D,W
04788:  ANDLW  0F
0478A:  ADDWF  x30,F
0478C:  ADDWF  x30,F
0478E:  ADDWF  x32,F
04790:  ADDLW  E9
04792:  MOVWF  x31
04794:  ADDWF  x31,F
04796:  ADDWF  x31,F
04798:  SWAPF  x2C,W
0479A:  ANDLW  0F
0479C:  ADDWF  x31,F
0479E:  ADDWF  x32,F
047A0:  RLCF   x31,F
047A2:  RLCF   x32,F
047A4:  COMF   x32,F
047A6:  RLCF   x32,F
047A8:  MOVF   x2C,W
047AA:  ANDLW  0F
047AC:  ADDWF  x32,F
047AE:  RLCF   x2F,F
047B0:  MOVLW  07
047B2:  MOVWF  x2E
047B4:  MOVLW  0A
047B6:  DECF   x31,F
047B8:  ADDWF  x32,F
047BA:  BNC   47B6
047BC:  DECF   x30,F
047BE:  ADDWF  x31,F
047C0:  BNC   47BC
047C2:  DECF   x2F,F
047C4:  ADDWF  x30,F
047C6:  BNC   47C2
047C8:  DECF   x2E,F
047CA:  ADDWF  x2F,F
047CC:  BNC   47C8
047CE:  MOVLW  06
047D0:  MOVWF  FEA
047D2:  MOVLW  2E
047D4:  MOVWF  FE9
047D6:  MOVLW  07
047D8:  ANDWF  x33,W
047DA:  BCF    x33.6
047DC:  MOVF   FED,F
047DE:  ANDWF  x33,W
047E0:  BNZ   47F0
047E2:  BTFSC  x33.4
047E4:  MOVF   FEE,F
047E6:  BTFSC  x33.4
047E8:  BRA    47F0
047EA:  MOVLW  20
047EC:  MOVWF  00
047EE:  BRA    4832
047F0:  ADDWF  FE9,F
047F2:  MOVLW  00
047F4:  ADDWFC FEA,F
047F6:  MOVF   FE9,W
047F8:  SUBLW  32
047FA:  BNZ   4804
047FC:  MOVF   FEA,W
047FE:  SUBLW  06
04800:  BNZ   4804
04802:  BSF    x33.6
04804:  MOVF   FEF,W
04806:  MOVWF  00
04808:  BNZ   481A
0480A:  BTFSC  x33.6
0480C:  BRA    481A
0480E:  BTFSC  x33.4
04810:  BRA    484E
04812:  BTFSC  x33.3
04814:  BRA    481A
04816:  MOVLW  20
04818:  BRA    4830
0481A:  BTFSS  x33.7
0481C:  BRA    482A
0481E:  MOVLW  2D
04820:  MOVWF  00
04822:  MOVF   FED,W
04824:  BCF    x33.6
04826:  BCF    x33.7
04828:  BRA    4832
0482A:  BSF    x33.3
0482C:  BCF    x33.4
0482E:  MOVLW  30
04830:  ADDWF  00,F
04832:  MOVFF  FEA,62D
04836:  MOVFF  FE9,62C
0483A:  MOVFF  00,635
0483E:  MOVLB  0
04840:  CALL   1FC8
04844:  MOVFF  62D,FEA
04848:  MOVFF  62C,FE9
0484C:  MOVLB  6
0484E:  MOVF   FEE,W
04850:  BTFSS  x33.6
04852:  BRA    47F6
04854:  MOVLB  0
04856:  RETURN 0
*
04E16:  MOVLB  6
04E18:  MOVF   x24,W
04E1A:  CLRF   01
04E1C:  SUBWF  x23,W
04E1E:  BC    4E26
04E20:  MOVFF  623,00
04E24:  BRA    4E3E
04E26:  CLRF   00
04E28:  MOVLW  08
04E2A:  MOVWF  x25
04E2C:  RLCF   x23,F
04E2E:  RLCF   00,F
04E30:  MOVF   x24,W
04E32:  SUBWF  00,W
04E34:  BTFSC  FD8.0
04E36:  MOVWF  00
04E38:  RLCF   01,F
04E3A:  DECFSZ x25,F
04E3C:  BRA    4E2C
04E3E:  MOVLB  0
04E40:  RETURN 0
04E42:  MOVLW  20
04E44:  MOVLB  6
04E46:  BTFSS  x1E.4
04E48:  MOVLW  30
04E4A:  MOVWF  x1F
04E4C:  MOVFF  61D,00
04E50:  BTFSS  00.7
04E52:  BRA    4E64
04E54:  COMF   00,F
04E56:  INCF   00,F
04E58:  MOVFF  00,61D
04E5C:  MOVLW  2D
04E5E:  MOVWF  x1F
04E60:  BSF    x1E.7
04E62:  BSF    x1E.0
04E64:  MOVF   01,W
04E66:  MOVFF  61D,623
04E6A:  MOVLW  64
04E6C:  MOVWF  x24
04E6E:  MOVLB  0
04E70:  RCALL  4E16
04E72:  MOVFF  00,61D
04E76:  MOVLW  30
04E78:  ADDWF  01,W
04E7A:  MOVLB  6
04E7C:  MOVWF  x20
04E7E:  MOVFF  61D,623
04E82:  MOVLW  0A
04E84:  MOVWF  x24
04E86:  MOVLB  0
04E88:  RCALL  4E16
04E8A:  MOVLW  30
04E8C:  ADDWF  00,W
04E8E:  MOVLB  6
04E90:  MOVWF  x22
04E92:  MOVLW  30
04E94:  ADDWF  01,W
04E96:  MOVWF  x21
04E98:  MOVFF  61F,00
04E9C:  MOVLW  30
04E9E:  SUBWF  x20,W
04EA0:  BZ    4EAA
04EA2:  BSF    x1E.1
04EA4:  BTFSC  x1E.7
04EA6:  BSF    x1E.2
04EA8:  BRA    4ECE
04EAA:  MOVFF  61F,620
04EAE:  MOVLW  20
04EB0:  MOVWF  x1F
04EB2:  MOVLW  30
04EB4:  SUBWF  x21,W
04EB6:  BZ    4EC0
04EB8:  BSF    x1E.0
04EBA:  BTFSC  x1E.7
04EBC:  BSF    x1E.1
04EBE:  BRA    4ECE
04EC0:  BTFSS  FD8.2
04EC2:  BSF    x1E.0
04EC4:  BNZ   4ECE
04EC6:  MOVFF  620,621
04ECA:  MOVLW  20
04ECC:  MOVWF  x20
04ECE:  BTFSC  x1E.2
04ED0:  BRA    4EDC
04ED2:  BTFSC  x1E.1
04ED4:  BRA    4EE6
04ED6:  BTFSC  x1E.0
04ED8:  BRA    4EF0
04EDA:  BRA    4EFA
04EDC:  MOVFF  61F,635
04EE0:  MOVLB  0
04EE2:  CALL   1FC8
04EE6:  MOVFF  620,635
04EEA:  MOVLB  0
04EEC:  CALL   1FC8
04EF0:  MOVFF  621,635
04EF4:  MOVLB  0
04EF6:  CALL   1FC8
04EFA:  MOVFF  622,635
04EFE:  MOVLB  0
04F00:  CALL   1FC8
04F04:  RETURN 0
04F06:  MOVF   FE9,W
04F08:  MOVLB  6
04F0A:  MOVWF  x26
04F0C:  BTFSS  x25.7
04F0E:  BRA    4F2A
04F10:  DECF   x26,F
04F12:  BSF    x26.5
04F14:  COMF   x22,F
04F16:  COMF   x23,F
04F18:  COMF   x24,F
04F1A:  COMF   x25,F
04F1C:  INCF   x22,F
04F1E:  BTFSC  FD8.2
04F20:  INCF   x23,F
04F22:  BTFSC  FD8.2
04F24:  INCF   x24,F
04F26:  BTFSC  FD8.2
04F28:  INCF   x25,F
04F2A:  MOVLW  3B
04F2C:  MOVWF  x2D
04F2E:  MOVLW  9A
04F30:  MOVWF  x2C
04F32:  MOVLW  CA
04F34:  MOVWF  x2B
04F36:  CLRF   x2A
04F38:  MOVLW  0A
04F3A:  MOVWF  x28
04F3C:  BSF    FD8.1
04F3E:  MOVLW  06
04F40:  MOVWF  FEA
04F42:  MOVLW  22
04F44:  MOVWF  FE9
04F46:  MOVFF  625,631
04F4A:  MOVFF  624,630
04F4E:  MOVFF  623,62F
04F52:  MOVFF  622,62E
04F56:  MOVFF  62D,635
04F5A:  MOVFF  62C,634
04F5E:  MOVFF  62B,633
04F62:  MOVFF  62A,632
04F66:  MOVLB  0
04F68:  CALL   1CDA
04F6C:  MOVF   01,W
04F6E:  MOVF   00,F
04F70:  BNZ   4F98
04F72:  MOVLB  6
04F74:  MOVF   x28,W
04F76:  XORLW  01
04F78:  BTFSS  FD8.2
04F7A:  BRA    4F80
04F7C:  MOVLB  0
04F7E:  BRA    4F98
04F80:  MOVF   x26,W
04F82:  BZ    4F9E
04F84:  ANDLW  0F
04F86:  SUBWF  x28,W
04F88:  BZ    4F8C
04F8A:  BC    4FE8
04F8C:  BTFSC  x26.7
04F8E:  BRA    4FE8
04F90:  BTFSC  x26.6
04F92:  BRA    4F9E
04F94:  MOVLW  20
04F96:  BRA    4FDA
04F98:  MOVLW  20
04F9A:  MOVLB  6
04F9C:  ANDWF  x26,F
04F9E:  BTFSS  x26.5
04FA0:  BRA    4FBA
04FA2:  BCF    x26.5
04FA4:  MOVFF  00,626
04FA8:  MOVLW  2D
04FAA:  MOVWF  x35
04FAC:  MOVLB  0
04FAE:  CALL   1FC8
04FB2:  MOVLB  6
04FB4:  MOVFF  626,00
04FB8:  CLRF   x26
04FBA:  MOVLW  30
04FBC:  BTFSS  x26.5
04FBE:  BRA    4FDA
04FC0:  BCF    x26.5
04FC2:  MOVFF  00,626
04FC6:  MOVLW  2D
04FC8:  MOVWF  x35
04FCA:  MOVLB  0
04FCC:  CALL   1FC8
04FD0:  MOVLB  6
04FD2:  MOVFF  626,00
04FD6:  CLRF   x26
04FD8:  MOVLW  30
04FDA:  ADDWF  00,F
04FDC:  MOVFF  00,635
04FE0:  MOVLB  0
04FE2:  CALL   1FC8
04FE6:  MOVLB  6
04FE8:  BCF    FD8.1
04FEA:  MOVFF  62D,631
04FEE:  MOVFF  62C,630
04FF2:  MOVFF  62B,62F
04FF6:  MOVFF  62A,62E
04FFA:  CLRF   x35
04FFC:  CLRF   x34
04FFE:  CLRF   x33
05000:  MOVLW  0A
05002:  MOVWF  x32
05004:  MOVLB  0
05006:  CALL   1CDA
0500A:  MOVFF  03,62D
0500E:  MOVFF  02,62C
05012:  MOVFF  01,62B
05016:  MOVFF  00,62A
0501A:  MOVLB  6
0501C:  DECFSZ x28,F
0501E:  BRA    4F3C
05020:  MOVLB  0
05022:  RETURN 0
*
05BCC:  MOVF   FEF,F
05BCE:  BZ    5BF0
05BD0:  MOVFF  FEA,5EF
05BD4:  MOVFF  FE9,5EE
05BD8:  MOVFF  FEF,635
05BDC:  CALL   1FC8
05BE0:  MOVFF  5EF,FEA
05BE4:  MOVFF  5EE,FE9
05BE8:  INCF   FE9,F
05BEA:  BTFSC  FD8.2
05BEC:  INCF   FEA,F
05BEE:  BRA    5BCC
05BF0:  GOTO   5C6E (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003CA:  MOVLW  05
003CC:  MOVWF  FEA
003CE:  MOVLW  EE
003D0:  MOVWF  FE9
003D2:  MOVF   FEF,W
003D4:  BZ    03F2
003D6:  MOVLW  14
003D8:  MOVWF  01
003DA:  CLRF   00
003DC:  DECFSZ 00,F
003DE:  BRA    03DC
003E0:  DECFSZ 01,F
003E2:  BRA    03DA
003E4:  MOVLW  BF
003E6:  MOVWF  00
003E8:  DECFSZ 00,F
003EA:  BRA    03E8
003EC:  BRA    03EE
003EE:  DECFSZ FEF,F
003F0:  BRA    03D6
003F2:  RETURN 0
*
00694:  MOVLW  01
00696:  MOVLB  5
00698:  SUBWF  xF4,F
0069A:  BNC   06B4
0069C:  MOVLW  05
0069E:  MOVWF  FEA
006A0:  MOVLW  F4
006A2:  MOVWF  FE9
006A4:  MOVF   FEF,W
006A6:  BZ    06B4
006A8:  MOVLW  04
006AA:  MOVWF  00
006AC:  DECFSZ 00,F
006AE:  BRA    06AC
006B0:  DECFSZ FEF,F
006B2:  BRA    06A8
006B4:  MOVLB  0
006B6:  GOTO   06FC (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20250522" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00334:  MOVLW  CF
00336:  MOVWF  F87
00338:  CLRF   F82
....................    output_b(portB_reset);
0033A:  MOVLW  C4
0033C:  MOVWF  F88
0033E:  CLRF   F83
....................    output_c(portC_reset);
00340:  MOVLW  93
00342:  MOVWF  F89
00344:  CLRF   F84
....................    output_d(portD_reset);
00346:  MOVLW  1F
00348:  MOVWF  F8A
0034A:  CLRF   F85
....................    output_e(portE_reset);
0034C:  BCF    F8B.0
0034E:  BCF    F8B.1
00350:  BCF    F8B.2
00352:  BCF    F8B.3
00354:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00356:  MOVLB  F
00358:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0035A:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0035C:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
0035E:  SETF   x20
....................    port_e_pullups(portE_pullups);
00360:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00362:  MOVLW  40
00364:  MOVWF  x0C
00366:  CLRF   x14
00368:  MOVLW  03
0036A:  MOVWF  x1C
0036C:  MOVLW  0F
0036E:  MOVWF  x21
00370:  CLRF   x29
00372:  MOVLB  0
00374:  GOTO   6038 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
01F50:  MOVFF  62B,FEA
01F54:  MOVLB  6
01F56:  MOVFF  62A,FE9
01F5A:  MOVFF  FEF,62E
01F5E:  MOVFF  62D,FEA
01F62:  MOVFF  62C,FE9
01F66:  MOVF   FEF,W
01F68:  SUBWF  x2E,W
01F6A:  BNZ   1F9A
....................       if (*s1 == '\0')
01F6C:  MOVFF  62B,03
01F70:  MOVFF  62A,FE9
01F74:  MOVFF  03,FEA
01F78:  MOVF   FEF,F
01F7A:  BNZ   1F82
....................          return(0);
01F7C:  MOVLW  00
01F7E:  MOVWF  01
01F80:  BRA    1FC4
01F82:  MOVFF  62B,03
01F86:  MOVF   x2A,W
01F88:  INCF   x2A,F
01F8A:  BTFSC  FD8.2
01F8C:  INCF   x2B,F
01F8E:  INCF   x2C,F
01F90:  BTFSC  FD8.2
01F92:  INCF   x2D,F
01F94:  MOVLB  0
01F96:  BRA    1F50
01F98:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
01F9A:  MOVFF  62B,03
01F9E:  MOVFF  62A,FE9
01FA2:  MOVFF  03,FEA
01FA6:  MOVFF  FEF,62E
01FAA:  MOVFF  62D,03
01FAE:  MOVFF  62C,FE9
01FB2:  MOVFF  03,FEA
01FB6:  MOVF   FEF,W
01FB8:  SUBWF  x2E,W
01FBA:  BC    1FC0
01FBC:  MOVLW  FF
01FBE:  BRA    1FC2
01FC0:  MOVLW  01
01FC2:  MOVWF  01
01FC4:  MOVLB  0
01FC6:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
020E0:  MOVFF  651,654
....................    for(su=s;0<n;++su,--n)
020E4:  MOVFF  650,656
020E8:  MOVFF  64F,655
020EC:  MOVLB  6
020EE:  MOVF   x53,F
020F0:  BNZ   20F8
020F2:  MOVF   x52,W
020F4:  SUBLW  00
020F6:  BC    2120
....................       if(*su==uc)
020F8:  MOVFF  656,FEA
020FC:  MOVFF  655,FE9
02100:  MOVF   x54,W
02102:  SUBWF  FEF,W
02104:  BNZ   2110
....................       return su;
02106:  MOVFF  655,01
0210A:  MOVFF  656,02
0210E:  BRA    2126
02110:  INCF   x55,F
02112:  BTFSC  FD8.2
02114:  INCF   x56,F
02116:  MOVF   x52,W
02118:  BTFSC  FD8.2
0211A:  DECF   x53,F
0211C:  DECF   x52,F
0211E:  BRA    20EE
....................    return NULL;
02120:  MOVLW  00
02122:  MOVWF  01
02124:  MOVWF  02
02126:  MOVLB  0
02128:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
01F18:  MOVFF  62B,62D
01F1C:  MOVFF  62A,62C
01F20:  MOVFF  62D,FEA
01F24:  MOVLB  6
01F26:  MOVFF  62C,FE9
01F2A:  MOVF   FEF,F
01F2C:  BZ    1F3A
01F2E:  INCF   x2C,F
01F30:  BTFSC  FD8.2
01F32:  INCF   x2D,F
01F34:  MOVLB  0
01F36:  BRA    1F20
01F38:  MOVLB  6
....................    return(sc - s);
01F3A:  MOVF   x2A,W
01F3C:  SUBWF  x2C,W
01F3E:  MOVWF  00
01F40:  MOVF   x2B,W
01F42:  SUBWFB x2D,W
01F44:  MOVWF  03
01F46:  MOVFF  00,01
01F4A:  MOVWF  02
01F4C:  MOVLB  0
01F4E:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
03208:  MOVLB  6
0320A:  CLRF   x04
0320C:  CLRF   x03
0320E:  CLRF   x02
03210:  MOVLW  7F
03212:  MOVWF  x01
03214:  CLRF   x08
03216:  CLRF   x07
03218:  CLRF   x06
0321A:  CLRF   x05
0321C:  BSF    x09.0
0321E:  BCF    x09.1
03220:  BCF    x09.2
03222:  CLRF   x0B
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
03224:  MOVLB  5
03226:  MOVF   xFD,W
03228:  IORWF  xFE,W
0322A:  BNZ   3236
....................       return 0;
0322C:  CLRF   00
0322E:  CLRF   01
03230:  CLRF   02
03232:  CLRF   03
03234:  BRA    3478
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
03236:  MOVLB  6
03238:  MOVF   x0B,W
0323A:  INCF   x0B,F
0323C:  MOVLB  5
0323E:  ADDWF  xFD,W
03240:  MOVWF  FE9
03242:  MOVLW  00
03244:  ADDWFC xFE,W
03246:  MOVWF  FEA
03248:  MOVFF  FEF,60A
0324C:  MOVLB  6
0324E:  MOVF   x0A,F
03250:  BTFSC  FD8.2
03252:  BRA    33EC
....................    {
....................       if (skip && !isspace(c))
03254:  BTFSS  x09.0
03256:  BRA    3276
03258:  MOVF   x0A,W
0325A:  SUBLW  20
0325C:  BZ    3276
....................       {
....................          skip = 0;
0325E:  BCF    x09.0
....................          if (c == '+')
03260:  MOVF   x0A,W
03262:  SUBLW  2B
03264:  BNZ   326C
....................          {
....................             sign = 0;
03266:  BCF    x09.1
....................             continue;
03268:  BRA    33D0
....................          }            
0326A:  BRA    3276
....................          else if (c == '-')
0326C:  MOVF   x0A,W
0326E:  SUBLW  2D
03270:  BNZ   3276
....................          {
....................             sign = 1;
03272:  BSF    x09.1
....................             continue;
03274:  BRA    33D0
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
03276:  BTFSC  x09.0
03278:  BRA    3288
0327A:  MOVF   x0A,W
0327C:  SUBLW  2E
0327E:  BNZ   3288
03280:  BTFSC  x09.2
03282:  BRA    3288
....................          point = 1;
03284:  BSF    x09.2
03286:  BRA    33D0
....................       else if (!skip && isdigit(c))
03288:  BTFSC  x09.0
0328A:  BRA    33CA
0328C:  MOVF   x0A,W
0328E:  SUBLW  2F
03290:  BTFSC  FD8.0
03292:  BRA    33CA
03294:  MOVF   x0A,W
03296:  SUBLW  39
03298:  BTFSS  FD8.0
0329A:  BRA    33CA
....................       {
....................          c -= '0';
0329C:  MOVLW  30
0329E:  SUBWF  x0A,F
....................          if (point)
032A0:  BTFSS  x09.2
032A2:  BRA    3350
....................          {
....................             pow10 = pow10 * 10.0;
032A4:  MOVFF  604,630
032A8:  MOVFF  603,62F
032AC:  MOVFF  602,62E
032B0:  MOVFF  601,62D
032B4:  CLRF   x34
032B6:  CLRF   x33
032B8:  MOVLW  20
032BA:  MOVWF  x32
032BC:  MOVLW  82
032BE:  MOVWF  x31
032C0:  MOVLB  0
032C2:  CALL   0A56
032C6:  MOVFF  03,604
032CA:  MOVFF  02,603
032CE:  MOVFF  01,602
032D2:  MOVFF  00,601
....................             result += (float)c / pow10;   
032D6:  MOVLB  6
032D8:  CLRF   x14
032DA:  MOVFF  60A,613
032DE:  MOVLB  0
032E0:  CALL   0A20
032E4:  MOVFF  03,60F
032E8:  MOVFF  02,60E
032EC:  MOVFF  01,60D
032F0:  MOVFF  00,60C
032F4:  MOVFF  03,616
032F8:  MOVFF  02,615
032FC:  MOVFF  01,614
03300:  MOVFF  00,613
03304:  MOVFF  604,61A
03308:  MOVFF  603,619
0330C:  MOVFF  602,618
03310:  MOVFF  601,617
03314:  BRA    30A8
03316:  BCF    FD8.1
03318:  MOVFF  608,616
0331C:  MOVFF  607,615
03320:  MOVFF  606,614
03324:  MOVFF  605,613
03328:  MOVFF  03,61A
0332C:  MOVFF  02,619
03330:  MOVFF  01,618
03334:  MOVFF  00,617
03338:  CALL   0B4C
0333C:  MOVFF  03,608
03340:  MOVFF  02,607
03344:  MOVFF  01,606
03348:  MOVFF  00,605
....................          }
0334C:  BRA    33C6
0334E:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
03350:  CLRF   x30
03352:  CLRF   x2F
03354:  MOVLW  20
03356:  MOVWF  x2E
03358:  MOVLW  82
0335A:  MOVWF  x2D
0335C:  MOVFF  608,634
03360:  MOVFF  607,633
03364:  MOVFF  606,632
03368:  MOVFF  605,631
0336C:  MOVLB  0
0336E:  CALL   0A56
03372:  MOVFF  03,60F
03376:  MOVFF  02,60E
0337A:  MOVFF  01,60D
0337E:  MOVFF  00,60C
03382:  MOVLB  6
03384:  CLRF   x14
03386:  MOVFF  60A,613
0338A:  MOVLB  0
0338C:  CALL   0A20
03390:  BCF    FD8.1
03392:  MOVFF  60F,616
03396:  MOVFF  60E,615
0339A:  MOVFF  60D,614
0339E:  MOVFF  60C,613
033A2:  MOVFF  03,61A
033A6:  MOVFF  02,619
033AA:  MOVFF  01,618
033AE:  MOVFF  00,617
033B2:  CALL   0B4C
033B6:  MOVFF  03,608
033BA:  MOVFF  02,607
033BE:  MOVFF  01,606
033C2:  MOVFF  00,605
....................          }
....................       }
033C6:  BRA    33D2
033C8:  MOVLB  6
....................       else if (!skip)
033CA:  BTFSC  x09.0
033CC:  BRA    33D0
....................          break;
033CE:  BRA    33EC
033D0:  MOVLB  0
033D2:  MOVLB  6
033D4:  MOVF   x0B,W
033D6:  INCF   x0B,F
033D8:  MOVLB  5
033DA:  ADDWF  xFD,W
033DC:  MOVWF  FE9
033DE:  MOVLW  00
033E0:  ADDWFC xFE,W
033E2:  MOVWF  FEA
033E4:  MOVFF  FEF,60A
033E8:  BRA    324C
033EA:  MOVLB  6
....................    }
.................... 
....................    if (sign)
033EC:  BTFSS  x09.1
033EE:  BRA    3424
....................       result = -1*result;
033F0:  CLRF   x30
033F2:  CLRF   x2F
033F4:  MOVLW  80
033F6:  MOVWF  x2E
033F8:  MOVLW  7F
033FA:  MOVWF  x2D
033FC:  MOVFF  608,634
03400:  MOVFF  607,633
03404:  MOVFF  606,632
03408:  MOVFF  605,631
0340C:  MOVLB  0
0340E:  CALL   0A56
03412:  MOVFF  03,608
03416:  MOVFF  02,607
0341A:  MOVFF  01,606
0341E:  MOVFF  00,605
03422:  MOVLB  6
....................       
....................    if(endptr)
03424:  MOVLB  5
03426:  MOVF   xFF,W
03428:  MOVLB  6
0342A:  IORWF  x00,W
0342C:  BZ    3466
....................    {
....................       if (ptr) {
0342E:  MOVF   x0B,F
03430:  BZ    3450
....................          ptr--;
03432:  DECF   x0B,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
03434:  MOVFF  600,FEA
03438:  MOVFF  5FF,FE9
0343C:  MOVLB  6
0343E:  MOVF   x0B,W
03440:  MOVLB  5
03442:  ADDWF  xFD,W
03444:  MOVWF  FEF
03446:  MOVLW  00
03448:  ADDWFC xFE,W
0344A:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0344C:  BRA    3464
0344E:  MOVLB  6
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
03450:  MOVFF  600,FEA
03454:  MOVLB  5
03456:  MOVFF  5FF,FE9
0345A:  MOVFF  5FE,FEC
0345E:  MOVF   FED,F
03460:  MOVFF  5FD,FEF
03464:  MOVLB  6
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
03466:  MOVFF  605,00
0346A:  MOVFF  606,01
0346E:  MOVFF  607,02
03472:  MOVFF  608,03
03476:  MOVLB  5
03478:  MOVLB  0
0347A:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
02180:  MOVLB  6
02182:  CLRF   x28
02184:  CLRF   x27
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
02186:  MOVLW  30
02188:  MOVWF  x2A
0218A:  MOVLW  31
0218C:  MOVWF  x2B
0218E:  MOVLW  32
02190:  MOVWF  x2C
02192:  MOVLW  33
02194:  MOVWF  x2D
02196:  MOVLW  34
02198:  MOVWF  x2E
0219A:  MOVLW  35
0219C:  MOVWF  x2F
0219E:  MOVLW  36
021A0:  MOVWF  x30
021A2:  MOVLW  37
021A4:  MOVWF  x31
021A6:  MOVLW  38
021A8:  MOVWF  x32
021AA:  MOVLW  39
021AC:  MOVWF  x33
021AE:  MOVLW  61
021B0:  MOVWF  x34
021B2:  MOVLW  62
021B4:  MOVWF  x35
021B6:  MOVLW  63
021B8:  MOVWF  x36
021BA:  MOVLW  64
021BC:  MOVWF  x37
021BE:  MOVLW  65
021C0:  MOVWF  x38
021C2:  MOVLW  66
021C4:  MOVWF  x39
021C6:  MOVLW  67
021C8:  MOVWF  x3A
021CA:  MOVLW  68
021CC:  MOVWF  x3B
021CE:  MOVLW  69
021D0:  MOVWF  x3C
021D2:  MOVLW  6A
021D4:  MOVWF  x3D
021D6:  MOVLW  6B
021D8:  MOVWF  x3E
021DA:  MOVLW  6C
021DC:  MOVWF  x3F
021DE:  MOVLW  6D
021E0:  MOVWF  x40
021E2:  MOVLW  6E
021E4:  MOVWF  x41
021E6:  MOVLW  6F
021E8:  MOVWF  x42
021EA:  MOVLW  70
021EC:  MOVWF  x43
021EE:  MOVLW  71
021F0:  MOVWF  x44
021F2:  MOVLW  73
021F4:  MOVWF  x45
021F6:  MOVLW  74
021F8:  MOVWF  x46
021FA:  MOVLW  75
021FC:  MOVWF  x47
021FE:  MOVLW  76
02200:  MOVWF  x48
02202:  MOVLW  77
02204:  MOVWF  x49
02206:  MOVLW  78
02208:  MOVWF  x4A
0220A:  MOVLW  79
0220C:  MOVWF  x4B
0220E:  MOVLW  7A
02210:  MOVWF  x4C
02212:  CLRF   x4D
....................    for(sc=s;isspace(*sc);++sc);
02214:  MOVFF  61D,622
02218:  MOVFF  61C,621
0221C:  MOVFF  622,FEA
02220:  MOVFF  621,FE9
02224:  MOVF   FEF,W
02226:  SUBLW  20
02228:  BNZ   2232
0222A:  INCF   x21,F
0222C:  BTFSC  FD8.2
0222E:  INCF   x22,F
02230:  BRA    221C
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
02232:  MOVFF  622,03
02236:  MOVFF  621,FE9
0223A:  MOVFF  03,FEA
0223E:  MOVF   FEF,W
02240:  SUBLW  2D
02242:  BZ    2252
02244:  MOVFF  622,FEA
02248:  MOVFF  621,FE9
0224C:  MOVF   FEF,W
0224E:  SUBLW  2B
02250:  BNZ   2264
02252:  MOVFF  622,FEA
02256:  MOVF   x21,W
02258:  INCF   x21,F
0225A:  BTFSC  FD8.2
0225C:  INCF   x22,F
0225E:  MOVWF  FE9
02260:  MOVF   FEF,W
02262:  BRA    2266
02264:  MOVLW  2B
02266:  MOVWF  x29
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
02268:  MOVF   x29,W
0226A:  SUBLW  2D
0226C:  BZ    2282
0226E:  BTFSC  x20.7
02270:  BRA    2282
02272:  DECFSZ x20,W
02274:  BRA    2278
02276:  BRA    2282
02278:  BTFSC  x20.7
0227A:  BRA    2286
0227C:  MOVF   x20,W
0227E:  SUBLW  24
02280:  BC    2286
....................    goto StrtoulGO;
02282:  BRA    248E
02284:  BRA    237E
.................... 
....................    else if (base)
02286:  MOVF   x20,F
02288:  BZ    2316
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
0228A:  MOVF   x20,W
0228C:  SUBLW  10
0228E:  BNZ   22CA
02290:  MOVFF  622,FEA
02294:  MOVFF  621,FE9
02298:  MOVF   FEF,W
0229A:  SUBLW  30
0229C:  BNZ   22CA
0229E:  MOVLW  01
022A0:  ADDWF  x21,W
022A2:  MOVWF  FE9
022A4:  MOVLW  00
022A6:  ADDWFC x22,W
022A8:  MOVWF  FEA
022AA:  MOVF   FEF,W
022AC:  SUBLW  78
022AE:  BZ    22C2
022B0:  MOVLW  01
022B2:  ADDWF  x21,W
022B4:  MOVWF  FE9
022B6:  MOVLW  00
022B8:  ADDWFC x22,W
022BA:  MOVWF  FEA
022BC:  MOVF   FEF,W
022BE:  SUBLW  58
022C0:  BNZ   22CA
....................          sc+=2;
022C2:  MOVLW  02
022C4:  ADDWF  x21,F
022C6:  MOVLW  00
022C8:  ADDWFC x22,F
....................       if(base==8 && *sc =='0')
022CA:  MOVF   x20,W
022CC:  SUBLW  08
022CE:  BNZ   22E6
022D0:  MOVFF  622,FEA
022D4:  MOVFF  621,FE9
022D8:  MOVF   FEF,W
022DA:  SUBLW  30
022DC:  BNZ   22E6
....................          sc+=1;
022DE:  MOVLW  01
022E0:  ADDWF  x21,F
022E2:  MOVLW  00
022E4:  ADDWFC x22,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
022E6:  MOVF   x20,W
022E8:  SUBLW  02
022EA:  BNZ   2314
022EC:  MOVFF  622,FEA
022F0:  MOVFF  621,FE9
022F4:  MOVF   FEF,W
022F6:  SUBLW  30
022F8:  BNZ   2314
022FA:  MOVLW  01
022FC:  ADDWF  x21,W
022FE:  MOVWF  FE9
02300:  MOVLW  00
02302:  ADDWFC x22,W
02304:  MOVWF  FEA
02306:  MOVF   FEF,W
02308:  SUBLW  62
0230A:  BNZ   2314
....................          sc+=2;
0230C:  MOVLW  02
0230E:  ADDWF  x21,F
02310:  MOVLW  00
02312:  ADDWFC x22,F
.................... 
....................    }
02314:  BRA    237E
....................    else if(*sc!='0') // base is 0, find base
02316:  MOVFF  622,FEA
0231A:  MOVFF  621,FE9
0231E:  MOVF   FEF,W
02320:  SUBLW  30
02322:  BZ    232A
....................       base=10;
02324:  MOVLW  0A
02326:  MOVWF  x20
02328:  BRA    237E
....................    else if (sc[1]=='x' || sc[1]=='X')
0232A:  MOVLW  01
0232C:  ADDWF  x21,W
0232E:  MOVWF  FE9
02330:  MOVLW  00
02332:  ADDWFC x22,W
02334:  MOVWF  FEA
02336:  MOVF   FEF,W
02338:  SUBLW  78
0233A:  BZ    234E
0233C:  MOVLW  01
0233E:  ADDWF  x21,W
02340:  MOVWF  FE9
02342:  MOVLW  00
02344:  ADDWFC x22,W
02346:  MOVWF  FEA
02348:  MOVF   FEF,W
0234A:  SUBLW  58
0234C:  BNZ   235C
....................       base =16,sc+=2;
0234E:  MOVLW  10
02350:  MOVWF  x20
02352:  MOVLW  02
02354:  ADDWF  x21,F
02356:  MOVLW  00
02358:  ADDWFC x22,F
0235A:  BRA    237E
....................    else if(sc[1]=='b')
0235C:  MOVLW  01
0235E:  ADDWF  x21,W
02360:  MOVWF  FE9
02362:  MOVLW  00
02364:  ADDWFC x22,W
02366:  MOVWF  FEA
02368:  MOVF   FEF,W
0236A:  SUBLW  62
0236C:  BNZ   237A
....................       base=2,sc+=2;
0236E:  MOVLW  02
02370:  MOVWF  x20
02372:  ADDWF  x21,F
02374:  MOVLW  00
02376:  ADDWFC x22,F
02378:  BRA    237E
....................    else
....................       base=8;
0237A:  MOVLW  08
0237C:  MOVWF  x20
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0237E:  MOVFF  622,624
02382:  MOVFF  621,623
02386:  MOVFF  622,FEA
0238A:  MOVFF  621,FE9
0238E:  MOVF   FEF,W
02390:  SUBLW  30
02392:  BNZ   239C
02394:  INCF   x21,F
02396:  BTFSC  FD8.2
02398:  INCF   x22,F
0239A:  BRA    2386
....................    sd=memchr(digits,tolower(*sc),base);
0239C:  MOVFF  622,03
023A0:  MOVFF  621,FE9
023A4:  MOVFF  03,FEA
023A8:  MOVFF  FEF,64E
023AC:  MOVF   x4E,W
023AE:  SUBLW  40
023B0:  BC    23BE
023B2:  MOVF   x4E,W
023B4:  SUBLW  5A
023B6:  BNC   23BE
023B8:  MOVF   x4E,W
023BA:  IORLW  20
023BC:  BRA    23C0
023BE:  MOVF   x4E,W
023C0:  MOVWF  x4E
023C2:  MOVLW  06
023C4:  MOVWF  x50
023C6:  MOVLW  2A
023C8:  MOVWF  x4F
023CA:  MOVFF  64E,651
023CE:  CLRF   x53
023D0:  MOVFF  620,652
023D4:  BTFSC  x52.7
023D6:  DECF   x53,F
023D8:  MOVLB  0
023DA:  RCALL  20E0
023DC:  MOVFF  02,626
023E0:  MOVFF  01,625
....................    for(; sd!=0; )
023E4:  MOVLB  6
023E6:  MOVF   x25,F
023E8:  BNZ   23EE
023EA:  MOVF   x26,F
023EC:  BZ    2482
....................    {
....................       x=x*base+(int16)(sd-digits);
023EE:  CLRF   03
023F0:  MOVF   x20,W
023F2:  MOVWF  00
023F4:  BTFSC  FE8.7
023F6:  DECF   03,F
023F8:  MOVWF  x4E
023FA:  MOVFF  03,64F
023FE:  MOVFF  628,651
02402:  MOVFF  627,650
02406:  MOVFF  03,653
0240A:  MOVWF  x52
0240C:  MOVLB  0
0240E:  BRA    212A
02410:  MOVFF  01,64E
02414:  MOVLW  2A
02416:  MOVLB  6
02418:  SUBWF  x25,W
0241A:  MOVWF  00
0241C:  MOVLW  06
0241E:  SUBWFB x26,W
02420:  MOVWF  03
02422:  MOVF   00,W
02424:  ADDWF  01,W
02426:  MOVWF  01
02428:  MOVF   02,W
0242A:  ADDWFC 03,F
0242C:  MOVFF  01,627
02430:  MOVFF  03,628
....................       ++sc;
02434:  INCF   x21,F
02436:  BTFSC  FD8.2
02438:  INCF   x22,F
....................       sd=memchr(digits,tolower(*sc),base);
0243A:  MOVFF  622,FEA
0243E:  MOVFF  621,FE9
02442:  MOVFF  FEF,64E
02446:  MOVF   x4E,W
02448:  SUBLW  40
0244A:  BC    2458
0244C:  MOVF   x4E,W
0244E:  SUBLW  5A
02450:  BNC   2458
02452:  MOVF   x4E,W
02454:  IORLW  20
02456:  BRA    245A
02458:  MOVF   x4E,W
0245A:  MOVWF  x4E
0245C:  MOVLW  06
0245E:  MOVWF  x50
02460:  MOVLW  2A
02462:  MOVWF  x4F
02464:  MOVFF  64E,651
02468:  CLRF   x53
0246A:  MOVFF  620,652
0246E:  BTFSC  x52.7
02470:  DECF   x53,F
02472:  MOVLB  0
02474:  RCALL  20E0
02476:  MOVFF  02,626
0247A:  MOVFF  01,625
0247E:  BRA    23E4
02480:  MOVLB  6
....................    }
....................    if(s1==sc)
02482:  MOVF   x21,W
02484:  SUBWF  x23,W
02486:  BNZ   24B0
02488:  MOVF   x22,W
0248A:  SUBWF  x24,W
0248C:  BNZ   24B0
....................    {
....................    StrtoulGO:
....................       if (endptr)
0248E:  MOVLB  6
02490:  MOVF   x1E,W
02492:  IORWF  x1F,W
02494:  BZ    24A8
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
02496:  MOVFF  61F,FEA
0249A:  MOVFF  61E,FE9
0249E:  MOVFF  61D,FEC
024A2:  MOVF   FED,F
024A4:  MOVFF  61C,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
024A8:  MOVLW  00
024AA:  MOVWF  01
024AC:  MOVWF  02
024AE:  BRA    24D0
....................    }
....................    if (endptr)
024B0:  MOVF   x1E,W
024B2:  IORWF  x1F,W
024B4:  BZ    24C8
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
024B6:  MOVFF  61F,FEA
024BA:  MOVFF  61E,FE9
024BE:  MOVFF  622,FEC
024C2:  MOVF   FED,F
024C4:  MOVFF  621,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
024C8:  MOVFF  627,01
024CC:  MOVFF  628,02
024D0:  MOVLB  0
024D2:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // mid-pole position in microns
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003F4:  MOVLB  5
003F6:  CLRF   xEE
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003F8:  CLRF   xEE
003FA:  MOVF   xED,W
003FC:  SUBWF  xEE,W
003FE:  BC    0456
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00400:  MOVF   xEE,W
00402:  ADDWF  xEB,W
00404:  MOVWF  xEF
00406:  MOVLW  00
00408:  ADDWFC xEC,W
0040A:  MOVWF  xF0
0040C:  MOVF   xEE,W
0040E:  ADDWF  xE9,W
00410:  MOVWF  01
00412:  MOVLW  00
00414:  ADDWFC xEA,W
00416:  MOVWF  03
00418:  MOVF   01,W
0041A:  MOVWF  FE9
0041C:  MOVFF  03,FEA
00420:  MOVFF  FEF,5F1
00424:  BSF    F7F.7
00426:  MOVF   FF2,W
00428:  MOVWF  00
0042A:  BCF    FF2.7
0042C:  MOVFF  5F0,F7A
00430:  MOVFF  5EF,F79
00434:  MOVLW  31
00436:  MOVWF  F7B
00438:  MOVFF  5F1,F7C
0043C:  MOVLB  F
0043E:  MOVLW  55
00440:  MOVWF  F81
00442:  MOVLW  AA
00444:  MOVWF  F81
00446:  BSF    F80.4
00448:  BTFSC  F80.4
0044A:  BRA    0448
0044C:  MOVF   00,W
0044E:  IORWF  FF2,F
00450:  MOVLB  5
00452:  INCF   xEE,F
00454:  BRA    03FA
....................    }
00456:  MOVLB  0
00458:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00378:  MOVLB  5
0037A:  CLRF   xEE
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0037C:  CLRF   xEE
0037E:  MOVF   xED,W
00380:  SUBWF  xEE,W
00382:  BC    03C6
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00384:  MOVF   xEE,W
00386:  ADDWF  xE9,W
00388:  MOVWF  01
0038A:  MOVLW  00
0038C:  ADDWFC xEA,W
0038E:  MOVWF  03
00390:  MOVF   01,W
00392:  MOVWF  FE9
00394:  MOVFF  03,FEA
00398:  MOVF   xEE,W
0039A:  ADDWF  xEB,W
0039C:  MOVWF  xF1
0039E:  MOVLW  00
003A0:  ADDWFC xEC,W
003A2:  MOVWF  xF2
003A4:  BSF    F7F.7
003A6:  MOVFF  FF2,5F3
003AA:  BCF    FF2.7
003AC:  MOVFF  5F2,F7A
003B0:  MOVFF  5F1,F79
003B4:  MOVLW  31
003B6:  MOVWF  F7B
003B8:  BSF    F80.0
003BA:  MOVF   F7C,W
003BC:  BTFSC  xF3.7
003BE:  BSF    FF2.7
003C0:  MOVWF  FEF
003C2:  INCF   xEE,F
003C4:  BRA    037E
....................    }
003C6:  MOVLB  0
003C8:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0045A:  MOVLB  5
0045C:  CLRF   xEA
0045E:  MOVLW  20
00460:  MOVWF  xE9
00462:  CLRF   xEC
00464:  CLRF   xEB
00466:  MOVLW  80
00468:  MOVWF  xED
0046A:  MOVLB  0
0046C:  RCALL  03F4
....................    delay_ms(1);
0046E:  MOVLW  01
00470:  MOVLB  5
00472:  MOVWF  xEE
00474:  MOVLB  0
00476:  RCALL  03CA
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
00478:  MOVLB  5
0047A:  CLRF   xEA
0047C:  MOVLW  60
0047E:  MOVWF  xE9
00480:  CLRF   xEC
00482:  MOVLW  80
00484:  MOVWF  xEB
00486:  MOVLW  02
00488:  MOVWF  xED
0048A:  MOVLB  0
0048C:  RCALL  03F4
....................    delay_ms(1);
0048E:  MOVLW  01
00490:  MOVLB  5
00492:  MOVWF  xEE
00494:  MOVLB  0
00496:  RCALL  03CA
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00498:  MOVLB  5
0049A:  CLRF   xEA
0049C:  MOVLW  61
0049E:  MOVWF  xE9
004A0:  CLRF   xEC
004A2:  MOVLW  90
004A4:  MOVWF  xEB
004A6:  MOVLW  02
004A8:  MOVWF  xED
004AA:  MOVLB  0
004AC:  RCALL  03F4
....................    delay_ms(1);
004AE:  MOVLW  01
004B0:  MOVLB  5
004B2:  MOVWF  xEE
004B4:  MOVLB  0
004B6:  RCALL  03CA
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
004B8:  MOVLB  5
004BA:  CLRF   xEA
004BC:  MOVLW  62
004BE:  MOVWF  xE9
004C0:  CLRF   xEC
004C2:  MOVLW  A0
004C4:  MOVWF  xEB
004C6:  MOVLW  20
004C8:  MOVWF  xED
004CA:  MOVLB  0
004CC:  RCALL  03F4
....................    delay_ms(1);
004CE:  MOVLW  01
004D0:  MOVLB  5
004D2:  MOVWF  xEE
004D4:  MOVLB  0
004D6:  RCALL  03CA
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004D8:  MOVLB  5
004DA:  CLRF   xEA
004DC:  MOVLW  82
004DE:  MOVWF  xE9
004E0:  CLRF   xEC
004E2:  MOVLW  C0
004E4:  MOVWF  xEB
004E6:  MOVLW  30
004E8:  MOVWF  xED
004EA:  MOVLB  0
004EC:  RCALL  03F4
....................    delay_ms(1);
004EE:  MOVLW  01
004F0:  MOVLB  5
004F2:  MOVWF  xEE
004F4:  MOVLB  0
004F6:  RCALL  03CA
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
004F8:  MOVLB  5
004FA:  CLRF   xEA
004FC:  MOVLW  B2
004FE:  MOVWF  xE9
00500:  CLRF   xEC
00502:  MOVLW  F0
00504:  MOVWF  xEB
00506:  MOVLW  38
00508:  MOVWF  xED
0050A:  MOVLB  0
0050C:  RCALL  03F4
....................    delay_ms(1);
0050E:  MOVLW  01
00510:  MOVLB  5
00512:  MOVWF  xEE
00514:  MOVLB  0
00516:  RCALL  03CA
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00518:  MOVLB  5
0051A:  CLRF   xEA
0051C:  MOVLW  F2
0051E:  MOVWF  xE9
00520:  MOVLW  01
00522:  MOVWF  xEC
00524:  MOVLW  40
00526:  MOVWF  xEB
00528:  MOVLW  01
0052A:  MOVWF  xED
0052C:  MOVLB  0
0052E:  RCALL  03F4
....................    delay_ms(1);
00530:  MOVLW  01
00532:  MOVLB  5
00534:  MOVWF  xEE
00536:  MOVLB  0
00538:  RCALL  03CA
0053A:  GOTO   060A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
0053E:  MOVLB  5
00540:  CLRF   xEA
00542:  MOVLW  20
00544:  MOVWF  xE9
00546:  CLRF   xEC
00548:  CLRF   xEB
0054A:  MOVLW  80
0054C:  MOVWF  xED
0054E:  MOVLB  0
00550:  RCALL  0378
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00552:  MOVLB  5
00554:  CLRF   xEA
00556:  MOVLW  60
00558:  MOVWF  xE9
0055A:  CLRF   xEC
0055C:  MOVLW  80
0055E:  MOVWF  xEB
00560:  MOVLW  02
00562:  MOVWF  xED
00564:  MOVLB  0
00566:  RCALL  0378
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00568:  MOVLB  5
0056A:  CLRF   xEA
0056C:  MOVLW  61
0056E:  MOVWF  xE9
00570:  CLRF   xEC
00572:  MOVLW  90
00574:  MOVWF  xEB
00576:  MOVLW  02
00578:  MOVWF  xED
0057A:  MOVLB  0
0057C:  RCALL  0378
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0057E:  MOVLB  5
00580:  CLRF   xEA
00582:  MOVLW  62
00584:  MOVWF  xE9
00586:  CLRF   xEC
00588:  MOVLW  A0
0058A:  MOVWF  xEB
0058C:  MOVLW  20
0058E:  MOVWF  xED
00590:  MOVLB  0
00592:  RCALL  0378
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00594:  MOVLB  5
00596:  CLRF   xEA
00598:  MOVLW  82
0059A:  MOVWF  xE9
0059C:  CLRF   xEC
0059E:  MOVLW  C0
005A0:  MOVWF  xEB
005A2:  MOVLW  30
005A4:  MOVWF  xED
005A6:  MOVLB  0
005A8:  RCALL  0378
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005AA:  MOVLB  5
005AC:  CLRF   xEA
005AE:  MOVLW  B2
005B0:  MOVWF  xE9
005B2:  CLRF   xEC
005B4:  MOVLW  F0
005B6:  MOVWF  xEB
005B8:  MOVLW  38
005BA:  MOVWF  xED
005BC:  MOVLB  0
005BE:  RCALL  0378
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005C0:  MOVLB  5
005C2:  CLRF   xEA
005C4:  MOVLW  F2
005C6:  MOVWF  xE9
005C8:  MOVLW  01
005CA:  MOVWF  xEC
005CC:  MOVLW  40
005CE:  MOVWF  xEB
005D0:  MOVLW  01
005D2:  MOVWF  xED
005D4:  MOVLB  0
005D6:  RCALL  0378
005D8:  GOTO   060E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005DC:  MOVLB  5
005DE:  CLRF   xEA
005E0:  MOVLW  F2
005E2:  MOVWF  xE9
005E4:  MOVLW  01
005E6:  MOVWF  xEC
005E8:  MOVLW  40
005EA:  MOVWF  xEB
005EC:  MOVLW  01
005EE:  MOVWF  xED
005F0:  MOVLB  0
005F2:  RCALL  0378
....................    delay_ms(1);
005F4:  MOVLW  01
005F6:  MOVLB  5
005F8:  MOVWF  xEE
005FA:  MOVLB  0
005FC:  RCALL  03CA
....................    if (paramsValid != isValid)
005FE:  MOVF   xF2,W
00600:  SUBLW  AA
00602:  BZ    060C
....................    {
....................       paramsValid = isValid;
00604:  MOVLW  AA
00606:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00608:  BRA    045A
....................    }
0060A:  BRA    060E
....................    else
....................    {
....................       params_load_from_ee();
0060C:  BRA    053E
....................    }
0060E:  GOTO   603C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // mid-pole position in microns
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g16|PGAenabled // 0x38//
.................... #define reg1config DRn20|MDnormal|CMsingle|TSDisable|BCSoff //0x00
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
0014A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00612:  RCALL  0136
....................    switch(ch)
00614:  MOVLB  5
00616:  MOVF   xF9,W
00618:  ADDLW  FC
0061A:  BC    064E
0061C:  ADDLW  04
0061E:  MOVLB  0
00620:  GOTO   065C
....................    {
....................       case 0:
....................          output_low(_CS0);
00624:  MOVLW  1F
00626:  MOVWF  F8A
00628:  BCF    F85.5
....................       break; 
0062A:  MOVLB  5
0062C:  BRA    064E
....................       case 1:
....................          output_low(_CS1);
0062E:  MOVLW  1F
00630:  MOVWF  F8A
00632:  BCF    F85.6
....................       break;   
00634:  MOVLB  5
00636:  BRA    064E
....................       case 2:
....................          output_low(_CS2);
00638:  MOVLW  1F
0063A:  MOVWF  F8A
0063C:  BCF    F85.7
....................       break;
0063E:  MOVLB  5
00640:  BRA    064E
....................       case 3:
....................          output_low(_CS3);
00642:  MOVLW  C4
00644:  MOVWF  F88
00646:  BCF    F83.0
....................       break;              
00648:  MOVLB  5
0064A:  BRA    064E
0064C:  MOVLB  5
....................    }
....................    delay_us(20);
0064E:  MOVLW  6A
00650:  MOVWF  00
00652:  DECFSZ 00,F
00654:  BRA    0652
00656:  NOP   
00658:  MOVLB  0
0065A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0014C:  RCALL  0136
....................    switch(block)
0014E:  MOVLB  6
00150:  MOVF   x5B,W
00152:  XORLW  00
00154:  MOVLB  0
00156:  BZ    015E
00158:  XORLW  01
0015A:  BZ    016A
0015C:  BRA    0176
....................    {
....................       case 0:
....................          output_low(_CS0);
0015E:  MOVLW  1F
00160:  MOVWF  F8A
00162:  BCF    F85.5
....................          output_low(_CS1);
00164:  MOVWF  F8A
00166:  BCF    F85.6
....................       break; 
00168:  BRA    0176
....................       case 1:         
....................          output_low(_CS2);
0016A:  MOVLW  1F
0016C:  MOVWF  F8A
0016E:  BCF    F85.7
....................          output_low(_CS3);
00170:  MOVLW  C4
00172:  MOVWF  F88
00174:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(20);
00176:  MOVLW  6A
00178:  MOVWF  00
0017A:  DECFSZ 00,F
0017C:  BRA    017A
0017E:  NOP   
00180:  GOTO   018A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0067E:  MOVFF  5F7,5F9
00682:  RCALL  0612
....................    spi_write2(command);
00684:  MOVLB  E
00686:  MOVF   x8D,W
00688:  MOVFF  5F8,E8D
0068C:  RRCF   x90,W
0068E:  BNC   068C
00690:  MOVLB  0
00692:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
00184:  MOVFF  659,65B
00188:  BRA    014C
....................    spi_write2(command);
0018A:  MOVLB  E
0018C:  MOVF   x8D,W
0018E:  MOVFF  65A,E8D
00192:  RRCF   x90,W
00194:  BNC   0192
00196:  MOVLB  0
00198:  GOTO   01AA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
01C62:  MOVFF  5EE,5F9
01C66:  CALL   0612
....................    spi_read2(command);
01C6A:  MOVLB  E
01C6C:  MOVF   x8D,W
01C6E:  MOVFF  5EF,E8D
01C72:  RRCF   x90,W
01C74:  BNC   1C72
01C76:  MOVLB  0
01C78:  GOTO   1C8A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
006BA:  MOVLB  5
006BC:  MOVF   xF4,W
006BE:  IORLW  40
006C0:  MOVWF  xF6
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
006C2:  MOVFF  5F3,5F7
006C6:  MOVFF  5F6,5F8
006CA:  MOVLB  0
006CC:  RCALL  067E
....................    spi_write2(data);
006CE:  MOVLB  E
006D0:  MOVF   x8D,W
006D2:  MOVFF  5F5,E8D
006D6:  RRCF   x90,W
006D8:  BNC   06D6
....................    ads_deselect_all();
006DA:  MOVLB  0
006DC:  RCALL  0136
006DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
0019C:  MOVFF  658,659
001A0:  MOVLW  08
001A2:  MOVLB  6
001A4:  MOVWF  x5A
001A6:  MOVLB  0
001A8:  BRA    0184
....................    delay_us(20);
001AA:  MOVLW  6A
001AC:  MOVWF  00
001AE:  DECFSZ 00,F
001B0:  BRA    01AE
001B2:  NOP   
....................    ads_deselect_all();
001B4:  RCALL  0136
001B6:  GOTO   01EE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
01C7C:  MOVFF  5E9,5EE
01C80:  MOVLW  10
01C82:  MOVLB  5
01C84:  MOVWF  xEF
01C86:  MOVLB  0
01C88:  BRA    1C62
....................    data.dBytes[3] = 0;
01C8A:  MOVLB  5
01C8C:  CLRF   xED
....................    data.dBytes[2] = spi_read2(0);
01C8E:  MOVLB  E
01C90:  MOVF   x8D,W
01C92:  CLRF   x8D
01C94:  RRCF   x90,W
01C96:  BNC   1C94
01C98:  MOVFF  E8D,5EC
....................    data.dBytes[1] = spi_read2(0);
01C9C:  MOVF   x8D,W
01C9E:  CLRF   x8D
01CA0:  RRCF   x90,W
01CA2:  BNC   1CA0
01CA4:  MOVFF  E8D,5EB
....................    data.dBytes[0] = spi_read2(0);
01CA8:  MOVF   x8D,W
01CAA:  CLRF   x8D
01CAC:  RRCF   x90,W
01CAE:  BNC   1CAC
01CB0:  MOVFF  E8D,5EA
....................    
....................    ads_write_command(ch, ADSstart);
01CB4:  MOVFF  5E9,5F7
01CB8:  MOVLW  08
01CBA:  MOVLB  5
01CBC:  MOVWF  xF8
01CBE:  MOVLB  0
01CC0:  CALL   067E
....................    ads_deselect_all();
01CC4:  CALL   0136
....................    return data.dWord;
01CC8:  MOVFF  5EA,00
01CCC:  MOVFF  5EB,01
01CD0:  MOVFF  5EC,02
01CD4:  MOVFF  5ED,03
01CD8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
006E0:  MOVFF  5EE,5F7
006E4:  MOVLW  06
006E6:  MOVLB  5
006E8:  MOVWF  xF8
006EA:  MOVLB  0
006EC:  RCALL  067E
....................    delay_us(300);                    
006EE:  MOVLW  02
006F0:  MOVLB  5
006F2:  MOVWF  xF3
006F4:  MOVLW  96
006F6:  MOVWF  xF4
006F8:  MOVLB  0
006FA:  BRA    0694
006FC:  MOVLB  5
006FE:  DECFSZ xF3,F
00700:  BRA    06F4
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00702:  MOVFF  5EE,5F3
00706:  CLRF   xF4
00708:  MOVFF  5EF,5F5
0070C:  MOVLB  0
0070E:  RCALL  06BA
....................    ads_write_reg(ch, reg1, rc1);
00710:  MOVFF  5EE,5F3
00714:  MOVLW  04
00716:  MOVLB  5
00718:  MOVWF  xF4
0071A:  MOVFF  5F0,5F5
0071E:  MOVLB  0
00720:  RCALL  06BA
....................    ads_write_reg(ch, reg2, rc2);
00722:  MOVFF  5EE,5F3
00726:  MOVLW  08
00728:  MOVLB  5
0072A:  MOVWF  xF4
0072C:  MOVFF  5F1,5F5
00730:  MOVLB  0
00732:  RCALL  06BA
....................    ads_write_reg(ch, reg3, rc3);  
00734:  MOVFF  5EE,5F3
00738:  MOVLW  0C
0073A:  MOVLB  5
0073C:  MOVWF  xF4
0073E:  MOVFF  5F2,5F5
00742:  MOVLB  0
00744:  RCALL  06BA
00746:  GOTO   0780 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... //!#define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... // adc settings for magnetoresistive sensors
.................... //!#define reg0cfg IPp1n2|g16|PGAenabled                   // 0x3A
.................... //!#define reg1cfg DRn20|MDturbo|CMsingle|TSDisable|BCSoff // 0x00
.................... //!#define reg2cfg REFinternal|FIR60|PSWopen|Ioff          // 0x30
.................... //!#define reg3cfg I1disabled|I2disabled|drdyPin           // 0x00
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
.................... } smData[2] = 
.................... {
....................    {false, false},
....................    {false, false}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00DC4:  MOVLB  F
00DC6:  BTFSC  x5B.0
00DC8:  BRA    12D4
....................    {
....................       switch (state)
00DCA:  MOVLB  1
00DCC:  MOVF   x51,W
00DCE:  XORLW  00
00DD0:  MOVLB  0
00DD2:  BZ    0DF2
00DD4:  XORLW  01
00DD6:  BZ    0EA4
00DD8:  XORLW  03
00DDA:  BTFSC  FD8.2
00DDC:  BRA    0F56
00DDE:  XORLW  01
00DE0:  BTFSC  FD8.2
00DE2:  BRA    1008
00DE4:  XORLW  07
00DE6:  BTFSC  FD8.2
00DE8:  BRA    10BA
00DEA:  XORLW  01
00DEC:  BTFSC  FD8.2
00DEE:  BRA    116C
00DF0:  BRA    1220
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00DF2:  MOVLB  F
00DF4:  BTFSC  x5B.0
00DF6:  BRA    0DF4
00DF8:  MOVFF  F5F,02
00DFC:  MOVFF  F5E,01
00E00:  MOVFF  02,5EA
00E04:  MOVFF  01,5E9
00E08:  MOVFF  02,614
00E0C:  MOVFF  01,613
00E10:  MOVLB  0
00E12:  RCALL  0A20
00E14:  MOVFF  03,630
00E18:  MOVFF  02,62F
00E1C:  MOVFF  01,62E
00E20:  MOVFF  00,62D
00E24:  MOVFF  B9,634
00E28:  MOVFF  B8,633
00E2C:  MOVFF  B7,632
00E30:  MOVFF  B6,631
00E34:  RCALL  0A56
00E36:  MOVFF  03,5EC
00E3A:  MOVFF  02,5EB
00E3E:  MOVFF  01,5EA
00E42:  MOVFF  00,5E9
00E46:  BCF    FD8.1
00E48:  MOVFF  03,616
00E4C:  MOVFF  02,615
00E50:  MOVFF  01,614
00E54:  MOVFF  00,613
00E58:  MOVFF  B5,61A
00E5C:  MOVFF  B4,619
00E60:  MOVFF  B3,618
00E64:  MOVFF  B2,617
00E68:  RCALL  0B4C
00E6A:  MOVFF  03,F6
00E6E:  MOVFF  02,F5
00E72:  MOVFF  01,F4
00E76:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00E7A:  MOVLB  F
00E7C:  MOVF   x5A,W
00E7E:  ANDLW  3F
00E80:  MOVWF  01
00E82:  MOVLW  10
00E84:  MOVWF  x5A
00E86:  BTFSS  x5B.7
00E88:  BRA    0E98
00E8A:  MOVF   01,W
00E8C:  SUBLW  10
00E8E:  BZ    0E98
00E90:  BSF    x5B.0
00E92:  NOP   
00E94:  BTFSC  x5B.0
00E96:  BRA    0E94
....................             read_adc(ADC_START_ONLY);
00E98:  BSF    x5B.0
00E9A:  NOP   
....................             state = 1;
00E9C:  MOVLW  01
00E9E:  MOVLB  1
00EA0:  MOVWF  x51
....................          break;
00EA2:  BRA    12D2
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00EA4:  MOVLB  F
00EA6:  BTFSC  x5B.0
00EA8:  BRA    0EA6
00EAA:  MOVFF  F5F,02
00EAE:  MOVFF  F5E,01
00EB2:  MOVFF  02,5EA
00EB6:  MOVFF  01,5E9
00EBA:  MOVFF  02,614
00EBE:  MOVFF  01,613
00EC2:  MOVLB  0
00EC4:  RCALL  0A20
00EC6:  MOVFF  03,630
00ECA:  MOVFF  02,62F
00ECE:  MOVFF  01,62E
00ED2:  MOVFF  00,62D
00ED6:  MOVFF  C1,634
00EDA:  MOVFF  C0,633
00EDE:  MOVFF  BF,632
00EE2:  MOVFF  BE,631
00EE6:  RCALL  0A56
00EE8:  MOVFF  03,5EC
00EEC:  MOVFF  02,5EB
00EF0:  MOVFF  01,5EA
00EF4:  MOVFF  00,5E9
00EF8:  BCF    FD8.1
00EFA:  MOVFF  03,616
00EFE:  MOVFF  02,615
00F02:  MOVFF  01,614
00F06:  MOVFF  00,613
00F0A:  MOVFF  BD,61A
00F0E:  MOVFF  BC,619
00F12:  MOVFF  BB,618
00F16:  MOVFF  BA,617
00F1A:  RCALL  0B4C
00F1C:  MOVFF  03,FA
00F20:  MOVFF  02,F9
00F24:  MOVFF  01,F8
00F28:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00F2C:  MOVLB  F
00F2E:  MOVF   x5A,W
00F30:  ANDLW  3F
00F32:  MOVWF  01
00F34:  MOVLW  18
00F36:  MOVWF  x5A
00F38:  BTFSS  x5B.7
00F3A:  BRA    0F4A
00F3C:  MOVF   01,W
00F3E:  SUBLW  18
00F40:  BZ    0F4A
00F42:  BSF    x5B.0
00F44:  NOP   
00F46:  BTFSC  x5B.0
00F48:  BRA    0F46
....................             read_adc(ADC_START_ONLY);
00F4A:  BSF    x5B.0
00F4C:  NOP   
....................             state = 2;
00F4E:  MOVLW  02
00F50:  MOVLB  1
00F52:  MOVWF  x51
....................          break;
00F54:  BRA    12D2
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00F56:  MOVLB  F
00F58:  BTFSC  x5B.0
00F5A:  BRA    0F58
00F5C:  MOVFF  F5F,02
00F60:  MOVFF  F5E,01
00F64:  MOVFF  02,5EA
00F68:  MOVFF  01,5E9
00F6C:  MOVFF  02,614
00F70:  MOVFF  01,613
00F74:  MOVLB  0
00F76:  RCALL  0A20
00F78:  MOVFF  03,630
00F7C:  MOVFF  02,62F
00F80:  MOVFF  01,62E
00F84:  MOVFF  00,62D
00F88:  MOVFF  C9,634
00F8C:  MOVFF  C8,633
00F90:  MOVFF  C7,632
00F94:  MOVFF  C6,631
00F98:  RCALL  0A56
00F9A:  MOVFF  03,5EC
00F9E:  MOVFF  02,5EB
00FA2:  MOVFF  01,5EA
00FA6:  MOVFF  00,5E9
00FAA:  BCF    FD8.1
00FAC:  MOVFF  03,616
00FB0:  MOVFF  02,615
00FB4:  MOVFF  01,614
00FB8:  MOVFF  00,613
00FBC:  MOVFF  C5,61A
00FC0:  MOVFF  C4,619
00FC4:  MOVFF  C3,618
00FC8:  MOVFF  C2,617
00FCC:  RCALL  0B4C
00FCE:  MOVFF  03,FE
00FD2:  MOVFF  02,FD
00FD6:  MOVFF  01,FC
00FDA:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
00FDE:  MOVLB  F
00FE0:  MOVF   x5A,W
00FE2:  ANDLW  3F
00FE4:  MOVWF  01
00FE6:  MOVLW  19
00FE8:  MOVWF  x5A
00FEA:  BTFSS  x5B.7
00FEC:  BRA    0FFC
00FEE:  MOVF   01,W
00FF0:  SUBLW  19
00FF2:  BZ    0FFC
00FF4:  BSF    x5B.0
00FF6:  NOP   
00FF8:  BTFSC  x5B.0
00FFA:  BRA    0FF8
....................             read_adc(ADC_START_ONLY);
00FFC:  BSF    x5B.0
00FFE:  NOP   
....................             state = 3;
01000:  MOVLW  03
01002:  MOVLB  1
01004:  MOVWF  x51
....................          break;
01006:  BRA    12D2
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01008:  MOVLB  F
0100A:  BTFSC  x5B.0
0100C:  BRA    100A
0100E:  MOVFF  F5F,02
01012:  MOVFF  F5E,01
01016:  MOVFF  02,5EA
0101A:  MOVFF  01,5E9
0101E:  MOVFF  02,614
01022:  MOVFF  01,613
01026:  MOVLB  0
01028:  RCALL  0A20
0102A:  MOVFF  03,630
0102E:  MOVFF  02,62F
01032:  MOVFF  01,62E
01036:  MOVFF  00,62D
0103A:  MOVFF  D1,634
0103E:  MOVFF  D0,633
01042:  MOVFF  CF,632
01046:  MOVFF  CE,631
0104A:  RCALL  0A56
0104C:  MOVFF  03,5EC
01050:  MOVFF  02,5EB
01054:  MOVFF  01,5EA
01058:  MOVFF  00,5E9
0105C:  BCF    FD8.1
0105E:  MOVFF  03,616
01062:  MOVFF  02,615
01066:  MOVFF  01,614
0106A:  MOVFF  00,613
0106E:  MOVFF  CD,61A
01072:  MOVFF  CC,619
01076:  MOVFF  CB,618
0107A:  MOVFF  CA,617
0107E:  RCALL  0B4C
01080:  MOVFF  03,102
01084:  MOVFF  02,101
01088:  MOVFF  01,100
0108C:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01090:  MOVLB  F
01092:  MOVF   x5A,W
01094:  ANDLW  3F
01096:  MOVWF  01
01098:  MOVLW  11
0109A:  MOVWF  x5A
0109C:  BTFSS  x5B.7
0109E:  BRA    10AE
010A0:  MOVF   01,W
010A2:  SUBLW  11
010A4:  BZ    10AE
010A6:  BSF    x5B.0
010A8:  NOP   
010AA:  BTFSC  x5B.0
010AC:  BRA    10AA
....................             read_adc(ADC_START_ONLY);
010AE:  BSF    x5B.0
010B0:  NOP   
....................             state = 4;
010B2:  MOVLW  04
010B4:  MOVLB  1
010B6:  MOVWF  x51
....................          break;
010B8:  BRA    12D2
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
010BA:  MOVLB  F
010BC:  BTFSC  x5B.0
010BE:  BRA    10BC
010C0:  MOVFF  F5F,02
010C4:  MOVFF  F5E,01
010C8:  MOVFF  02,5EA
010CC:  MOVFF  01,5E9
010D0:  MOVFF  02,614
010D4:  MOVFF  01,613
010D8:  MOVLB  0
010DA:  RCALL  0A20
010DC:  MOVFF  03,630
010E0:  MOVFF  02,62F
010E4:  MOVFF  01,62E
010E8:  MOVFF  00,62D
010EC:  MOVFF  D9,634
010F0:  MOVFF  D8,633
010F4:  MOVFF  D7,632
010F8:  MOVFF  D6,631
010FC:  RCALL  0A56
010FE:  MOVFF  03,5EC
01102:  MOVFF  02,5EB
01106:  MOVFF  01,5EA
0110A:  MOVFF  00,5E9
0110E:  BCF    FD8.1
01110:  MOVFF  03,616
01114:  MOVFF  02,615
01118:  MOVFF  01,614
0111C:  MOVFF  00,613
01120:  MOVFF  D5,61A
01124:  MOVFF  D4,619
01128:  MOVFF  D3,618
0112C:  MOVFF  D2,617
01130:  RCALL  0B4C
01132:  MOVFF  03,106
01136:  MOVFF  02,105
0113A:  MOVFF  01,104
0113E:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01142:  MOVLB  F
01144:  MOVF   x5A,W
01146:  ANDLW  3F
01148:  MOVWF  01
0114A:  MOVLW  1B
0114C:  MOVWF  x5A
0114E:  BTFSS  x5B.7
01150:  BRA    1160
01152:  MOVF   01,W
01154:  SUBLW  1B
01156:  BZ    1160
01158:  BSF    x5B.0
0115A:  NOP   
0115C:  BTFSC  x5B.0
0115E:  BRA    115C
....................             read_adc(ADC_START_ONLY);
01160:  BSF    x5B.0
01162:  NOP   
....................             state = 5;
01164:  MOVLW  05
01166:  MOVLB  1
01168:  MOVWF  x51
....................          break;
0116A:  BRA    12D2
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
0116C:  MOVLB  F
0116E:  BTFSC  x5B.0
01170:  BRA    116E
01172:  MOVFF  F5F,02
01176:  MOVFF  F5E,01
0117A:  MOVFF  02,5EA
0117E:  MOVFF  01,5E9
01182:  MOVFF  02,614
01186:  MOVFF  01,613
0118A:  MOVLB  0
0118C:  RCALL  0A20
0118E:  MOVFF  03,630
01192:  MOVFF  02,62F
01196:  MOVFF  01,62E
0119A:  MOVFF  00,62D
0119E:  MOVFF  E1,634
011A2:  MOVFF  E0,633
011A6:  MOVFF  DF,632
011AA:  MOVFF  DE,631
011AE:  RCALL  0A56
011B0:  MOVFF  03,5EC
011B4:  MOVFF  02,5EB
011B8:  MOVFF  01,5EA
011BC:  MOVFF  00,5E9
011C0:  BCF    FD8.1
011C2:  MOVFF  03,616
011C6:  MOVFF  02,615
011CA:  MOVFF  01,614
011CE:  MOVFF  00,613
011D2:  MOVFF  DD,61A
011D6:  MOVFF  DC,619
011DA:  MOVFF  DB,618
011DE:  MOVFF  DA,617
011E2:  RCALL  0B4C
011E4:  MOVFF  03,10A
011E8:  MOVFF  02,109
011EC:  MOVFF  01,108
011F0:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
011F4:  MOVLB  F
011F6:  MOVF   x5A,W
011F8:  ANDLW  3F
011FA:  MOVWF  01
011FC:  MOVLW  1A
011FE:  MOVWF  x5A
01200:  BTFSS  x5B.7
01202:  BRA    1212
01204:  MOVF   01,W
01206:  SUBLW  1A
01208:  BZ    1212
0120A:  BSF    x5B.0
0120C:  NOP   
0120E:  BTFSC  x5B.0
01210:  BRA    120E
....................             read_adc(ADC_START_ONLY);
01212:  BSF    x5B.0
01214:  NOP   
....................             state = 6;
01216:  MOVLW  06
01218:  MOVLB  1
0121A:  MOVWF  x51
....................          break;
0121C:  BRA    12D2
0121E:  MOVLB  0
....................          
....................          default:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01220:  MOVLB  F
01222:  BTFSC  x5B.0
01224:  BRA    1222
01226:  MOVFF  F5F,02
0122A:  MOVFF  F5E,01
0122E:  MOVFF  02,5EA
01232:  MOVFF  01,5E9
01236:  MOVFF  02,614
0123A:  MOVFF  01,613
0123E:  MOVLB  0
01240:  CALL   0A20
01244:  MOVFF  03,630
01248:  MOVFF  02,62F
0124C:  MOVFF  01,62E
01250:  MOVFF  00,62D
01254:  MOVFF  E9,634
01258:  MOVFF  E8,633
0125C:  MOVFF  E7,632
01260:  MOVFF  E6,631
01264:  CALL   0A56
01268:  MOVFF  03,5EC
0126C:  MOVFF  02,5EB
01270:  MOVFF  01,5EA
01274:  MOVFF  00,5E9
01278:  BCF    FD8.1
0127A:  MOVFF  03,616
0127E:  MOVFF  02,615
01282:  MOVFF  01,614
01286:  MOVFF  00,613
0128A:  MOVFF  E5,61A
0128E:  MOVFF  E4,619
01292:  MOVFF  E3,618
01296:  MOVFF  E2,617
0129A:  RCALL  0B4C
0129C:  MOVFF  03,10E
012A0:  MOVFF  02,10D
012A4:  MOVFF  01,10C
012A8:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
012AC:  MOVLB  F
012AE:  MOVF   x5A,W
012B0:  ANDLW  3F
012B2:  MOVWF  01
012B4:  MOVLW  06
012B6:  MOVWF  x5A
012B8:  BTFSS  x5B.7
012BA:  BRA    12CA
012BC:  MOVF   01,W
012BE:  SUBLW  06
012C0:  BZ    12CA
012C2:  BSF    x5B.0
012C4:  NOP   
012C6:  BTFSC  x5B.0
012C8:  BRA    12C6
....................             read_adc(ADC_START_ONLY);
012CA:  BSF    x5B.0
012CC:  NOP   
....................             state = 0;
012CE:  MOVLB  1
012D0:  CLRF   x51
....................          break;   
012D2:  MOVLB  F
....................       }
....................    }
012D4:  MOVLB  0
012D6:  GOTO   6056 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
....................    float pTmp = 0;
....................    float polePitch = magPP;
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
....................    pTmp = adcVals[ch].p0 + ( polePitch * adcVals[ch].npoles );
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
....................    
....................    PID[ch].PVold = PID[ch].PV;
....................    PID[ch].PV = adcVals[ch].pReal;
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001BA:  MOVLB  6
001BC:  CLRF   x59
001BE:  MOVFF  152,658
001C2:  MOVLW  4F
001C4:  ADDWF  x58,W
001C6:  MOVWF  FE9
001C8:  MOVLW  01
001CA:  ADDWFC x59,W
001CC:  MOVWF  FEA
001CE:  BTFSC  FEF.1
001D0:  BRA    023A
....................    {
....................       smData[ch].adcBusy = true;
001D2:  CLRF   x59
001D4:  MOVFF  152,658
001D8:  MOVLW  4F
001DA:  ADDWF  x58,W
001DC:  MOVWF  FE9
001DE:  MOVLW  01
001E0:  ADDWFC x59,W
001E2:  MOVWF  FEA
001E4:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001E6:  MOVFF  152,658
001EA:  MOVLB  0
001EC:  BRA    019C
....................       ch = !ch;
001EE:  MOVLB  1
001F0:  MOVF   x52,F
001F2:  BZ    01F8
001F4:  MOVLW  00
001F6:  BRA    01FA
001F8:  MOVLW  01
001FA:  MOVWF  x52
....................       
....................       smData[!ch].dataReady = true;
001FC:  MOVF   x52,F
001FE:  BZ    0204
00200:  MOVLW  00
00202:  BRA    0206
00204:  MOVLW  01
00206:  MOVLB  6
00208:  CLRF   x59
0020A:  MOVWF  x58
0020C:  MOVLW  4F
0020E:  ADDWF  x58,W
00210:  MOVWF  FE9
00212:  MOVLW  01
00214:  ADDWFC x59,W
00216:  MOVWF  FEA
00218:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
0021A:  MOVLB  1
0021C:  MOVF   x52,F
0021E:  BZ    0224
00220:  MOVLW  00
00222:  BRA    0226
00224:  MOVLW  01
00226:  MOVLB  6
00228:  CLRF   x59
0022A:  MOVWF  x58
0022C:  MOVLW  4F
0022E:  ADDWF  x58,W
00230:  MOVWF  FE9
00232:  MOVLW  01
00234:  ADDWFC x59,W
00236:  MOVWF  FEA
00238:  BCF    FEF.1
....................    }
0023A:  MOVLB  0
0023C:  GOTO   02FE (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinRaw = 0;
....................    signed int32 cosRaw = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
....................       smData[ch].adcBusy = true;
....................       
....................       sinRaw = ads_read_data(ch*2);
....................       cosRaw = ads_read_data(ch*2+1);      
....................       
....................       sensor_process_data(ch, sinRaw, cosRaw);
....................       ch = !ch;
....................       
....................       smData[!ch].dataReady = false;
....................       smData[!ch].adcBusy = false;
....................    }
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0074A:  MOVLB  5
0074C:  CLRF   xE9
0074E:  CLRF   xEA
00750:  CLRF   xEB
00752:  CLRF   xEC
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
00754:  CLRF   xED
00756:  MOVF   xED,W
00758:  SUBLW  03
0075A:  BNC   0790
....................    {
....................       rc0=reg0config;
0075C:  MOVLW  38
0075E:  MOVWF  xE9
....................       rc1=reg1config;
00760:  CLRF   xEA
....................       rc2=reg2config;
00762:  MOVLW  30
00764:  MOVWF  xEB
....................       rc3=reg3config;
00766:  CLRF   xEC
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00768:  MOVFF  5ED,5EE
0076C:  MOVFF  5E9,5EF
00770:  MOVFF  5EA,5F0
00774:  MOVFF  5EB,5F1
00778:  MOVFF  5EC,5F2
0077C:  MOVLB  0
0077E:  BRA    06E0
....................       delay_ms(1);
00780:  MOVLW  01
00782:  MOVLB  5
00784:  MOVWF  xEE
00786:  MOVLB  0
00788:  RCALL  03CA
0078A:  MOVLB  5
0078C:  INCF   xED,F
0078E:  BRA    0756
....................    }   
00790:  MOVLB  0
00792:  GOTO   07F6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00796:  MOVLW  00
00798:  MOVLB  F
0079A:  MOVWF  x53
0079C:  MOVLW  40
0079E:  MOVWF  x0C
007A0:  MOVLW  00
007A2:  MOVWF  x14
007A4:  MOVLW  03
007A6:  MOVWF  x1C
007A8:  MOVLW  0F
007AA:  MOVWF  x21
007AC:  MOVLW  00
007AE:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
007B0:  MOVLW  08
007B2:  MOVWF  x55
007B4:  CLRF   x56
007B6:  CLRF   x52
007B8:  SETF   x57
007BA:  CLRF   F61
007BC:  MOVLW  94
007BE:  MOVWF  x5B
....................    output_high(EN_EXC);
007C0:  MOVLW  E8
007C2:  MOVWF  F8B
007C4:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
007C6:  MOVF   x5A,W
007C8:  ANDLW  3F
007CA:  MOVWF  01
007CC:  MOVLW  06
007CE:  MOVWF  x5A
007D0:  BTFSS  x5B.7
007D2:  BRA    07E2
007D4:  MOVF   01,W
007D6:  SUBLW  06
007D8:  BZ    07E2
007DA:  BSF    x5B.0
007DC:  NOP   
007DE:  BTFSC  x5B.0
007E0:  BRA    07DE
....................    delay_ms(10);
007E2:  MOVLW  0A
007E4:  MOVLB  5
007E6:  MOVWF  xEE
007E8:  MOVLB  0
007EA:  RCALL  03CA
....................    read_adc(ADC_START_ONLY);
007EC:  MOVLB  F
007EE:  BSF    x5B.0
007F0:  NOP   
....................    setup_external_ADCs();
007F2:  MOVLB  0
007F4:  BRA    074A
....................    intTimeoutReg = sensorSampleRate;
007F6:  MOVLB  1
007F8:  CLRF   x4E
007FA:  MOVLW  32
007FC:  MOVWF  x4D
007FE:  MOVLB  0
00800:  GOTO   6040 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // mid-pole position in microns
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=0, STREAM=SPI_ctrl)
00804:  CLRF   03
00806:  MOVF   F91,W
00808:  MOVFF  5EE,F91
0080C:  RRCF   F94,W
0080E:  BNC   080C
00810:  MOVF   F91,W
00812:  MOVWF  02
00814:  MOVFF  5ED,F91
00818:  RRCF   F94,W
0081A:  BNC   0818
0081C:  MOVF   F91,W
0081E:  MOVWF  01
00820:  MOVFF  5EC,F91
00824:  RRCF   F94,W
00826:  BNC   0824
00828:  MOVFF  F91,00
0082C:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
0138A:  MOVLB  5
0138C:  MOVF   xED,F
0138E:  BZ    13BA
....................       if (chMap[0] == ch) output_low(INV_HVX);
01390:  MOVLW  00
01392:  MOVLB  0
01394:  BTFSC  x60.0
01396:  MOVLW  01
01398:  MOVLB  5
0139A:  SUBWF  xEC,W
0139C:  BNZ   13A4
0139E:  MOVLW  C4
013A0:  MOVWF  F88
013A2:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
013A4:  MOVLW  00
013A6:  MOVLB  0
013A8:  BTFSC  x60.1
013AA:  MOVLW  01
013AC:  MOVLB  5
013AE:  SUBWF  xEC,W
013B0:  BNZ   13B8
013B2:  MOVLW  C4
013B4:  MOVWF  F88
013B6:  BCF    F83.5
....................    }
013B8:  BRA    13E2
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
013BA:  MOVLW  00
013BC:  MOVLB  0
013BE:  BTFSC  x60.0
013C0:  MOVLW  01
013C2:  MOVLB  5
013C4:  SUBWF  xEC,W
013C6:  BNZ   13CE
013C8:  MOVLW  C4
013CA:  MOVWF  F88
013CC:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
013CE:  MOVLW  00
013D0:  MOVLB  0
013D2:  BTFSC  x60.1
013D4:  MOVLW  01
013D6:  MOVLB  5
013D8:  SUBWF  xEC,W
013DA:  BNZ   13E2
013DC:  MOVLW  C4
013DE:  MOVWF  F88
013E0:  BSF    F83.5
....................    }
013E2:  MOVLB  0
013E4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
01422:  MOVLB  5
01424:  CLRF   xEB
01426:  CLRF   xEA
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
01428:  MOVFF  5E9,5F6
0142C:  CLRF   xF8
0142E:  MOVLW  61
01430:  MOVWF  xF7
01432:  MOVLB  0
01434:  RCALL  12DA
01436:  MOVF   01,F
01438:  BNZ   1502
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
0143A:  MOVLB  5
0143C:  MOVF   xE9,W
0143E:  MULLW  04
01440:  MOVF   FF3,W
01442:  CLRF   03
01444:  ADDLW  EA
01446:  MOVWF  FE9
01448:  MOVLW  00
0144A:  ADDWFC 03,W
0144C:  MOVWF  FEA
0144E:  MOVFF  FEF,5F0
01452:  MOVFF  FEC,5F1
01456:  MOVFF  FEC,5F2
0145A:  MOVFF  FEC,5F3
0145E:  CLRF   xF7
01460:  CLRF   xF6
01462:  CLRF   xF5
01464:  CLRF   xF4
01466:  MOVLB  0
01468:  RCALL  1310
0146A:  BNC   147C
0146C:  MOVFF  5E9,5EC
01470:  MOVLW  01
01472:  MOVLB  5
01474:  MOVWF  xED
01476:  MOVLB  0
01478:  RCALL  138A
0147A:  BRA    1488
....................       else                             invert_voltage(ch, FALSE);
0147C:  MOVFF  5E9,5EC
01480:  MOVLB  5
01482:  CLRF   xED
01484:  MOVLB  0
01486:  RCALL  138A
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
01488:  MOVLB  5
0148A:  MOVF   xE9,W
0148C:  MULLW  04
0148E:  MOVF   FF3,W
01490:  CLRF   03
01492:  ADDLW  EA
01494:  MOVWF  FE9
01496:  MOVLW  00
01498:  ADDWFC 03,W
0149A:  MOVWF  FEA
0149C:  MOVFF  FEF,00
014A0:  MOVFF  FEC,01
014A4:  MOVFF  FEC,02
014A8:  MOVFF  FEC,03
014AC:  BCF    01.7
014AE:  MOVFF  03,5EF
014B2:  MOVFF  02,5EE
014B6:  MOVFF  01,5ED
014BA:  MOVFF  00,5EC
014BE:  MOVFF  03,630
014C2:  MOVFF  02,62F
014C6:  MOVFF  01,62E
014CA:  MOVFF  00,62D
014CE:  MOVLW  66
014D0:  MOVLB  6
014D2:  MOVWF  x34
014D4:  MOVLW  D6
014D6:  MOVWF  x33
014D8:  MOVLW  23
014DA:  MOVWF  x32
014DC:  MOVLW  88
014DE:  MOVWF  x31
014E0:  MOVLB  0
014E2:  CALL   0A56
014E6:  MOVFF  03,5FE
014EA:  MOVFF  02,5FD
014EE:  MOVFF  01,5FC
014F2:  MOVFF  00,5FB
014F6:  RCALL  13E6
014F8:  MOVFF  02,5EB
014FC:  MOVFF  01,5EA
....................    }
01500:  BRA    15E8
....................    else {
....................       if ( PID[(int)ch].CV < 0) invert_voltage(ch, TRUE); 
01502:  MOVLB  5
01504:  MOVF   xE9,W
01506:  MULLW  20
01508:  MOVF   FF3,W
0150A:  CLRF   xED
0150C:  MOVWF  xEC
0150E:  MOVLW  18
01510:  ADDWF  xEC,W
01512:  MOVWF  01
01514:  MOVLW  00
01516:  ADDWFC xED,W
01518:  MOVWF  03
0151A:  MOVF   01,W
0151C:  ADDLW  20
0151E:  MOVWF  FE9
01520:  MOVLW  00
01522:  ADDWFC 03,W
01524:  MOVWF  FEA
01526:  MOVFF  FEF,5F0
0152A:  MOVFF  FEC,5F1
0152E:  MOVFF  FEC,5F2
01532:  MOVFF  FEC,5F3
01536:  CLRF   xF7
01538:  CLRF   xF6
0153A:  CLRF   xF5
0153C:  CLRF   xF4
0153E:  MOVLB  0
01540:  RCALL  1310
01542:  BNC   1554
01544:  MOVFF  5E9,5EC
01548:  MOVLW  01
0154A:  MOVLB  5
0154C:  MOVWF  xED
0154E:  MOVLB  0
01550:  RCALL  138A
01552:  BRA    1560
....................       else                      invert_voltage(ch, FALSE);
01554:  MOVFF  5E9,5EC
01558:  MOVLB  5
0155A:  CLRF   xED
0155C:  MOVLB  0
0155E:  RCALL  138A
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
01560:  MOVLB  5
01562:  MOVF   xE9,W
01564:  MULLW  20
01566:  MOVF   FF3,W
01568:  CLRF   xED
0156A:  MOVWF  xEC
0156C:  MOVLW  18
0156E:  ADDWF  xEC,W
01570:  MOVWF  01
01572:  MOVLW  00
01574:  ADDWFC xED,W
01576:  MOVWF  03
01578:  MOVF   01,W
0157A:  ADDLW  20
0157C:  MOVWF  FE9
0157E:  MOVLW  00
01580:  ADDWFC 03,W
01582:  MOVWF  FEA
01584:  MOVFF  FEF,00
01588:  MOVFF  FEC,01
0158C:  MOVFF  FEC,02
01590:  MOVFF  FEC,03
01594:  BCF    01.7
01596:  MOVFF  03,5EF
0159A:  MOVFF  02,5EE
0159E:  MOVFF  01,5ED
015A2:  MOVFF  00,5EC
015A6:  MOVFF  03,630
015AA:  MOVFF  02,62F
015AE:  MOVFF  01,62E
015B2:  MOVFF  00,62D
015B6:  MOVLW  66
015B8:  MOVLB  6
015BA:  MOVWF  x34
015BC:  MOVLW  D6
015BE:  MOVWF  x33
015C0:  MOVLW  23
015C2:  MOVWF  x32
015C4:  MOVLW  88
015C6:  MOVWF  x31
015C8:  MOVLB  0
015CA:  CALL   0A56
015CE:  MOVFF  03,5FE
015D2:  MOVFF  02,5FD
015D6:  MOVFF  01,5FC
015DA:  MOVFF  00,5FB
015DE:  RCALL  13E6
015E0:  MOVFF  02,5EB
015E4:  MOVFF  01,5EA
....................    }
....................       
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
015E8:  MOVLW  00
015EA:  BTFSC  x60.0
015EC:  MOVLW  01
015EE:  MOVLB  5
015F0:  SUBWF  xE9,W
015F2:  BNZ   15FA
015F4:  MOVLW  E8
015F6:  MOVWF  F8B
015F8:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
015FA:  MOVLW  00
015FC:  MOVLB  0
015FE:  BTFSC  x60.1
01600:  MOVLW  01
01602:  MOVLB  5
01604:  SUBWF  xE9,W
01606:  BNZ   160E
01608:  MOVLW  E8
0160A:  MOVWF  F8B
0160C:  BSF    F86.1
....................    
....................    delay_ms(1);
0160E:  MOVLW  01
01610:  MOVWF  xEE
01612:  MOVLB  0
01614:  CALL   03CA
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
01618:  MOVLW  00
0161A:  BTFSC  x60.0
0161C:  MOVLW  01
0161E:  MOVLB  5
01620:  SUBWF  xE9,W
01622:  BNZ   162A
01624:  MOVLW  E8
01626:  MOVWF  F8B
01628:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
0162A:  MOVLW  00
0162C:  MOVLB  0
0162E:  BTFSC  x60.1
01630:  MOVLW  01
01632:  MOVLB  5
01634:  SUBWF  xE9,W
01636:  BNZ   163E
01638:  MOVLW  E8
0163A:  MOVWF  F8B
0163C:  BCF    F86.1
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
0163E:  CLRF   xEF
01640:  CLRF   xEE
01642:  MOVFF  5EB,5ED
01646:  MOVFF  5EA,5EC
0164A:  MOVLB  0
0164C:  CALL   0804
....................    
....................    delay_ms(1);
01650:  MOVLW  01
01652:  MOVLB  5
01654:  MOVWF  xEE
01656:  MOVLB  0
01658:  CALL   03CA
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
0165C:  MOVLW  00
0165E:  BTFSC  x60.0
01660:  MOVLW  01
01662:  MOVLB  5
01664:  SUBWF  xE9,W
01666:  BNZ   166E
01668:  MOVLW  E8
0166A:  MOVWF  F8B
0166C:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
0166E:  MOVLW  00
01670:  MOVLB  0
01672:  BTFSC  x60.1
01674:  MOVLW  01
01676:  MOVLB  5
01678:  SUBWF  xE9,W
0167A:  BNZ   1682
0167C:  MOVLW  E8
0167E:  MOVWF  F8B
01680:  BSF    F86.1
01682:  MOVLB  0
01684:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
01686:  MOVLB  1
01688:  MOVF   x54,W
0168A:  XORLW  00
0168C:  MOVLB  0
0168E:  BZ    1692
01690:  BRA    16A4
....................    {
....................       case 0:       
....................          set_nanoDAC_outputs(chX);
01692:  MOVLB  5
01694:  CLRF   xE9
01696:  MOVLB  0
01698:  RCALL  1422
....................          state = 1;
0169A:  MOVLW  01
0169C:  MOVLB  1
0169E:  MOVWF  x54
....................       break;
016A0:  BRA    16B2
016A2:  MOVLB  0
....................       default:
....................          set_nanoDAC_outputs(chY);
016A4:  MOVLW  01
016A6:  MOVLB  5
016A8:  MOVWF  xE9
016AA:  MOVLB  0
016AC:  RCALL  1422
....................          state = 0;
016AE:  MOVLB  1
016B0:  CLRF   x54
....................       break;
....................    }
016B2:  MOVLB  0
016B4:  GOTO   605A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
0082E:  MOVLB  5
00830:  CLRF   xEF
00832:  CLRF   xEE
00834:  CLRF   xED
00836:  CLRF   xEC
00838:  MOVLB  0
0083A:  RCALL  0804
....................    output_low(_SYNC_X);
0083C:  MOVLW  E8
0083E:  MOVWF  F8B
00840:  BCF    F86.2
....................    output_low(_SYNC_Y);
00842:  MOVWF  F8B
00844:  BCF    F86.1
....................    output_high(_SYNC_X);
00846:  MOVWF  F8B
00848:  BSF    F86.2
....................    output_high(_SYNC_Y);
0084A:  MOVWF  F8B
0084C:  BSF    F86.1
0084E:  GOTO   6044 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
00874:  MOVLB  5
00876:  MOVF   xEA,W
00878:  SUBLW  03
0087A:  BTFSS  FD8.0
0087C:  BRA    09FA
....................    {
....................       for (int i = 0; i <numParam; i ++)
0087E:  CLRF   xEB
00880:  MOVF   xEB,W
00882:  SUBLW  06
00884:  BNC   08D8
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00886:  MOVLB  6
00888:  CLRF   x2B
0088A:  MOVFF  5EA,62A
0088E:  CLRF   x2D
00890:  MOVLW  B5
00892:  MOVWF  x2C
00894:  MOVLB  0
00896:  RCALL  0852
00898:  MOVFF  02,5ED
0089C:  MOVFF  01,5EC
008A0:  MOVLW  06
008A2:  MOVLB  5
008A4:  ADDWF  xEC,F
008A6:  MOVLW  00
008A8:  ADDWFC xED,F
008AA:  MOVLB  6
008AC:  CLRF   x2B
008AE:  MOVFF  5EB,62A
008B2:  CLRF   x2D
008B4:  MOVLW  19
008B6:  MOVWF  x2C
008B8:  MOVLB  0
008BA:  RCALL  0852
008BC:  MOVF   01,W
008BE:  MOVLB  5
008C0:  ADDWF  xEC,F
008C2:  MOVF   02,W
008C4:  ADDWFC xED,F
008C6:  MOVLW  55
008C8:  ADDWF  xEC,W
008CA:  MOVWF  FE9
008CC:  MOVLW  01
008CE:  ADDWFC xED,W
008D0:  MOVWF  FEA
008D2:  CLRF   FEF
008D4:  INCF   xEB,F
008D6:  BRA    0880
....................       }
....................       SERcmd[recNum].t = 0;
008D8:  MOVLB  6
008DA:  CLRF   x2B
008DC:  MOVFF  5EA,62A
008E0:  CLRF   x2D
008E2:  MOVLW  B5
008E4:  MOVWF  x2C
008E6:  MOVLB  0
008E8:  RCALL  0852
008EA:  MOVFF  01,5EC
008EE:  MOVLW  05
008F0:  MOVLB  5
008F2:  ADDWF  01,W
008F4:  MOVWF  01
008F6:  MOVLW  00
008F8:  ADDWFC 02,W
008FA:  MOVWF  03
008FC:  MOVF   01,W
008FE:  ADDLW  55
00900:  MOVWF  FE9
00902:  MOVLW  01
00904:  ADDWFC 03,W
00906:  MOVWF  FEA
00908:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
0090A:  MOVLB  6
0090C:  CLRF   x2B
0090E:  MOVFF  5EA,62A
00912:  CLRF   x2D
00914:  MOVLW  B5
00916:  MOVWF  x2C
00918:  MOVLB  0
0091A:  RCALL  0852
0091C:  MOVFF  01,5EC
00920:  MOVLW  01
00922:  MOVLB  5
00924:  ADDWF  01,W
00926:  MOVWF  01
00928:  MOVLW  00
0092A:  ADDWFC 02,W
0092C:  MOVWF  03
0092E:  MOVF   01,W
00930:  ADDLW  55
00932:  MOVWF  FE9
00934:  MOVLW  01
00936:  ADDWFC 03,W
00938:  MOVWF  FEA
0093A:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
0093C:  MOVLB  6
0093E:  CLRF   x2B
00940:  MOVFF  5EA,62A
00944:  CLRF   x2D
00946:  MOVLW  B5
00948:  MOVWF  x2C
0094A:  MOVLB  0
0094C:  RCALL  0852
0094E:  MOVFF  01,5EC
00952:  MOVLW  02
00954:  MOVLB  5
00956:  ADDWF  01,W
00958:  MOVWF  01
0095A:  MOVLW  00
0095C:  ADDWFC 02,W
0095E:  MOVWF  03
00960:  MOVF   01,W
00962:  ADDLW  55
00964:  MOVWF  FE9
00966:  MOVLW  01
00968:  ADDWFC 03,W
0096A:  MOVWF  FEA
0096C:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
0096E:  MOVLB  6
00970:  CLRF   x2B
00972:  MOVFF  5EA,62A
00976:  CLRF   x2D
00978:  MOVLW  B5
0097A:  MOVWF  x2C
0097C:  MOVLB  0
0097E:  RCALL  0852
00980:  MOVFF  01,5EC
00984:  MOVLW  03
00986:  MOVLB  5
00988:  ADDWF  01,W
0098A:  MOVWF  01
0098C:  MOVLW  00
0098E:  ADDWFC 02,W
00990:  MOVWF  03
00992:  MOVF   01,W
00994:  ADDLW  55
00996:  MOVWF  FE9
00998:  MOVLW  01
0099A:  ADDWFC 03,W
0099C:  MOVWF  FEA
0099E:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
009A0:  MOVLB  6
009A2:  CLRF   x2B
009A4:  MOVFF  5EA,62A
009A8:  CLRF   x2D
009AA:  MOVLW  B5
009AC:  MOVWF  x2C
009AE:  MOVLB  0
009B0:  RCALL  0852
009B2:  MOVFF  01,5EC
009B6:  MOVLW  04
009B8:  MOVLB  5
009BA:  ADDWF  01,W
009BC:  MOVWF  01
009BE:  MOVLW  00
009C0:  ADDWFC 02,W
009C2:  MOVWF  03
009C4:  MOVF   01,W
009C6:  ADDLW  55
009C8:  MOVWF  FE9
009CA:  MOVLW  01
009CC:  ADDWFC 03,W
009CE:  MOVWF  FEA
009D0:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
009D2:  MOVLB  6
009D4:  CLRF   x2B
009D6:  MOVFF  5EA,62A
009DA:  CLRF   x2D
009DC:  MOVLW  B5
009DE:  MOVWF  x2C
009E0:  MOVLB  0
009E2:  RCALL  0852
009E4:  MOVLW  55
009E6:  MOVLB  5
009E8:  ADDWF  01,W
009EA:  MOVWF  FE9
009EC:  MOVLW  01
009EE:  ADDWFC 02,W
009F0:  MOVWF  FEA
009F2:  BCF    FEF.0
....................       retData[0] = '\0';
009F4:  MOVLB  4
009F6:  CLRF   x2B
009F8:  MOVLB  5
....................    }
009FA:  MOVLB  0
009FC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
01E84:  MOVLB  6
01E86:  CLRF   x2B
01E88:  MOVFF  429,62A
01E8C:  CLRF   x2D
01E8E:  MOVLW  B5
01E90:  MOVWF  x2C
01E92:  MOVLB  0
01E94:  CALL   0852
01E98:  MOVFF  02,5EB
01E9C:  MOVFF  01,5EA
01EA0:  MOVLW  55
01EA2:  MOVLB  5
01EA4:  ADDWF  01,W
01EA6:  MOVWF  FE9
01EA8:  MOVLW  01
01EAA:  ADDWFC 02,W
01EAC:  MOVWF  FEA
01EAE:  BTFSC  FEF.0
01EB0:  BRA    1ED2
....................    {
....................       if (SRI == SWI) return FALSE;
01EB2:  MOVLB  4
01EB4:  MOVF   x2A,W
01EB6:  SUBWF  x29,W
01EB8:  BNZ   1EC0
01EBA:  MOVLW  00
01EBC:  MOVWF  01
01EBE:  BRA    1ED8
....................       SRI +=1;
01EC0:  MOVLW  01
01EC2:  ADDWF  x29,F
....................       if (SRI >= numRecords) SRI=0;
01EC4:  MOVF   x29,W
01EC6:  SUBLW  03
01EC8:  BC    1ECC
01ECA:  CLRF   x29
01ECC:  MOVLB  0
01ECE:  BRA    1E84
01ED0:  MOVLB  5
....................    }
....................    return TRUE;
01ED2:  MOVLW  01
01ED4:  MOVWF  01
01ED6:  MOVLB  4
01ED8:  MOVLB  0
01EDA:  GOTO   5BF8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
016EC:  MOVLW  01
016EE:  MOVLB  4
016F0:  ADDWF  x2A,F
....................    if (SWI >= numRecords) SWI=0;
016F2:  MOVF   x2A,W
016F4:  SUBLW  03
016F6:  BC    16FA
016F8:  CLRF   x2A
016FA:  MOVLB  0
016FC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4CE
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xCE.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
016FE:  MOVLW  93
01700:  MOVWF  F89
01702:  BSF    F84.5
01704:  MOVLB  E
01706:  BTFSS  xC8.4
01708:  BRA    1706
0170A:  MOVLW  93
0170C:  MOVWF  F89
0170E:  BSF    F84.5
01710:  MOVLB  5
01712:  MOVFF  5F5,F99
01716:  NOP   
01718:  BTFSS  F9D.1
0171A:  BRA    1718
0171C:  MOVLW  93
0171E:  MOVWF  F89
01720:  BCF    F84.5
01722:  MOVLB  0
01724:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xCB,W
000F6:  ADDLW  8F
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,65B
00104:  MOVFF  FE9,65A
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  65B,FEA
00110:  MOVFF  65A,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xCB,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xCB,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xCB
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xCD.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
016B8:  CLRF   03
016BA:  MOVLB  4
016BC:  MOVF   xCC,W
016BE:  ADDLW  8F
016C0:  MOVWF  FE9
016C2:  MOVLW  04
016C4:  ADDWFC 03,W
016C6:  MOVWF  FEA
016C8:  MOVFF  FEF,5EA
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
016CC:  MOVLW  01
016CE:  ADDWF  xCC,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
016D0:  MOVF   xCC,W
016D2:  SUBLW  3B
016D4:  BC    16D8
016D6:  CLRF   xCC
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
016D8:  MOVF   xCB,W
016DA:  SUBWF  xCC,W
016DC:  BNZ   16E0
016DE:  BCF    xCD.0
....................    return data;
016E0:  MOVLB  5
016E2:  MOVFF  5EA,01
016E6:  MOVLB  0
016E8:  GOTO   178C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
0174A:  MOVLB  4
0174C:  BTFSS  xCD.0
0174E:  BRA    1C5C
01750:  MOVLB  6
01752:  CLRF   x2B
01754:  MOVFF  42A,62A
01758:  CLRF   x2D
0175A:  MOVLW  B5
0175C:  MOVWF  x2C
0175E:  MOVLB  0
01760:  CALL   0852
01764:  MOVFF  02,5EB
01768:  MOVFF  01,5EA
0176C:  MOVLW  55
0176E:  MOVLB  5
01770:  ADDWF  01,W
01772:  MOVWF  01
01774:  MOVLW  01
01776:  ADDWFC 02,W
01778:  MOVWF  03
0177A:  MOVFF  01,FE9
0177E:  MOVWF  FEA
01780:  BTFSS  FEF.0
01782:  BRA    1788
01784:  MOVLB  4
01786:  BRA    1C5C
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
01788:  MOVLB  0
0178A:  BRA    16B8
0178C:  MOVFF  01,5E9
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
01790:  MOVLB  5
01792:  MOVF   xE9,W
01794:  SUBLW  0D
01796:  BZ    179E
01798:  MOVF   xE9,W
0179A:  SUBLW  20
0179C:  BNZ   17A0
....................       {
....................       }
0179E:  BRA    1C56
....................       else if (rxChar == UART_SOT_CHAR)
017A0:  MOVF   xE9,W
017A2:  SUBLW  7E
017A4:  BNZ   17E8
....................       {
....................          resetSERcmd(SWI);
017A6:  MOVFF  42A,5EA
017AA:  MOVLB  0
017AC:  CALL   0874
....................          SERcmd[SWI].t = rxChar;
017B0:  MOVLB  6
017B2:  CLRF   x2B
017B4:  MOVFF  42A,62A
017B8:  CLRF   x2D
017BA:  MOVLW  B5
017BC:  MOVWF  x2C
017BE:  MOVLB  0
017C0:  CALL   0852
017C4:  MOVFF  01,5EA
017C8:  MOVLW  05
017CA:  MOVLB  5
017CC:  ADDWF  01,W
017CE:  MOVWF  01
017D0:  MOVLW  00
017D2:  ADDWFC 02,W
017D4:  MOVWF  03
017D6:  MOVF   01,W
017D8:  ADDLW  55
017DA:  MOVWF  FE9
017DC:  MOVLW  01
017DE:  ADDWFC 03,W
017E0:  MOVWF  FEA
017E2:  MOVFF  5E9,FEF
....................       }
017E6:  BRA    1C56
....................       else if (rxChar >= oneByteCmdTestValue)
017E8:  MOVF   xE9,W
017EA:  SUBLW  7F
017EC:  BC    185A
....................       {
....................          resetSERcmd(SWI);
017EE:  MOVFF  42A,5EA
017F2:  MOVLB  0
017F4:  CALL   0874
....................          SERcmd[SWI].t = rxChar;
017F8:  MOVLB  6
017FA:  CLRF   x2B
017FC:  MOVFF  42A,62A
01800:  CLRF   x2D
01802:  MOVLW  B5
01804:  MOVWF  x2C
01806:  MOVLB  0
01808:  CALL   0852
0180C:  MOVFF  01,5EA
01810:  MOVLW  05
01812:  MOVLB  5
01814:  ADDWF  01,W
01816:  MOVWF  01
01818:  MOVLW  00
0181A:  ADDWFC 02,W
0181C:  MOVWF  03
0181E:  MOVF   01,W
01820:  ADDLW  55
01822:  MOVWF  FE9
01824:  MOVLW  01
01826:  ADDWFC 03,W
01828:  MOVWF  FEA
0182A:  MOVFF  5E9,FEF
....................          SERcmd[SWI].full = TRUE;
0182E:  MOVLB  6
01830:  CLRF   x2B
01832:  MOVFF  42A,62A
01836:  CLRF   x2D
01838:  MOVLW  B5
0183A:  MOVWF  x2C
0183C:  MOVLB  0
0183E:  CALL   0852
01842:  MOVLW  55
01844:  MOVLB  5
01846:  ADDWF  01,W
01848:  MOVWF  FE9
0184A:  MOVLW  01
0184C:  ADDWFC 02,W
0184E:  MOVWF  FEA
01850:  BSF    FEF.0
....................          setNextSERWriteIndex();
01852:  MOVLB  0
01854:  RCALL  16EC
....................       }
01856:  BRA    1C54
01858:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
0185A:  MOVF   xE9,W
0185C:  SUBLW  0A
0185E:  BTFSS  FD8.2
01860:  BRA    196E
....................       {
....................          SERcmd[SWI].full = TRUE;
01862:  MOVLB  6
01864:  CLRF   x2B
01866:  MOVFF  42A,62A
0186A:  CLRF   x2D
0186C:  MOVLW  B5
0186E:  MOVWF  x2C
01870:  MOVLB  0
01872:  CALL   0852
01876:  MOVLW  55
01878:  MOVLB  5
0187A:  ADDWF  01,W
0187C:  MOVWF  FE9
0187E:  MOVLW  01
01880:  ADDWFC 02,W
01882:  MOVWF  FEA
01884:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
01886:  MOVLB  6
01888:  CLRF   x2B
0188A:  MOVFF  42A,62A
0188E:  CLRF   x2D
01890:  MOVLW  B5
01892:  MOVWF  x2C
01894:  MOVLB  0
01896:  CALL   0852
0189A:  MOVFF  01,5EA
0189E:  MOVLW  04
018A0:  ADDWF  01,W
018A2:  MOVWF  01
018A4:  MOVLW  00
018A6:  ADDWFC 02,W
018A8:  MOVWF  03
018AA:  MOVF   01,W
018AC:  ADDLW  55
018AE:  MOVWF  01
018B0:  MOVLW  01
018B2:  ADDWFC 03,F
018B4:  MOVFF  01,5EA
018B8:  MOVFF  03,5EB
018BC:  MOVLB  6
018BE:  CLRF   x2B
018C0:  MOVFF  42A,62A
018C4:  CLRF   x2D
018C6:  MOVLW  B5
018C8:  MOVWF  x2C
018CA:  MOVLB  0
018CC:  CALL   0852
018D0:  MOVFF  01,5EC
018D4:  MOVLW  02
018D6:  MOVLB  5
018D8:  ADDWF  01,W
018DA:  MOVWF  01
018DC:  MOVLW  00
018DE:  ADDWFC 02,W
018E0:  MOVWF  03
018E2:  MOVF   01,W
018E4:  ADDLW  55
018E6:  MOVWF  FE9
018E8:  MOVLW  01
018EA:  ADDWFC 03,W
018EC:  MOVWF  FEA
018EE:  MOVFF  FEF,5EC
018F2:  MOVFF  5EB,FEA
018F6:  MOVFF  5EA,FE9
018FA:  MOVFF  5EC,FEF
....................          SERcmd[SWI].chrIndex = 0;
018FE:  MOVLB  6
01900:  CLRF   x2B
01902:  MOVFF  42A,62A
01906:  CLRF   x2D
01908:  MOVLW  B5
0190A:  MOVWF  x2C
0190C:  MOVLB  0
0190E:  CALL   0852
01912:  MOVFF  01,5EA
01916:  MOVLW  01
01918:  MOVLB  5
0191A:  ADDWF  01,W
0191C:  MOVWF  01
0191E:  MOVLW  00
01920:  ADDWFC 02,W
01922:  MOVWF  03
01924:  MOVF   01,W
01926:  ADDLW  55
01928:  MOVWF  FE9
0192A:  MOVLW  01
0192C:  ADDWFC 03,W
0192E:  MOVWF  FEA
01930:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
01932:  MOVLB  6
01934:  CLRF   x2B
01936:  MOVFF  42A,62A
0193A:  CLRF   x2D
0193C:  MOVLW  B5
0193E:  MOVWF  x2C
01940:  MOVLB  0
01942:  CALL   0852
01946:  MOVFF  01,5EA
0194A:  MOVLW  02
0194C:  MOVLB  5
0194E:  ADDWF  01,W
01950:  MOVWF  01
01952:  MOVLW  00
01954:  ADDWFC 02,W
01956:  MOVWF  03
01958:  MOVF   01,W
0195A:  ADDLW  55
0195C:  MOVWF  FE9
0195E:  MOVLW  01
01960:  ADDWFC 03,W
01962:  MOVWF  FEA
01964:  CLRF   FEF
....................          setNextSERWriteIndex();
01966:  MOVLB  0
01968:  RCALL  16EC
....................       }
0196A:  BRA    1C54
0196C:  MOVLB  5
....................       else if (rxChar == delimiter)
0196E:  MOVF   xE9,W
01970:  SUBLW  2C
01972:  BNZ   1A36
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
01974:  MOVLB  6
01976:  CLRF   x2B
01978:  MOVFF  42A,62A
0197C:  CLRF   x2D
0197E:  MOVLW  B5
01980:  MOVWF  x2C
01982:  MOVLB  0
01984:  CALL   0852
01988:  MOVFF  02,5EB
0198C:  MOVFF  01,5EA
01990:  MOVLW  02
01992:  MOVLB  5
01994:  ADDWF  01,W
01996:  MOVWF  01
01998:  MOVLW  00
0199A:  ADDWFC 02,W
0199C:  MOVWF  03
0199E:  MOVF   01,W
019A0:  ADDLW  55
019A2:  MOVWF  FE9
019A4:  MOVLW  01
019A6:  ADDWFC 03,W
019A8:  MOVWF  FEA
019AA:  MOVF   FEF,W
019AC:  SUBLW  05
019AE:  BNC   1A1E
....................          {
....................             SERcmd[SWI].paramIndex +=1;
019B0:  MOVLB  6
019B2:  CLRF   x2B
019B4:  MOVFF  42A,62A
019B8:  CLRF   x2D
019BA:  MOVLW  B5
019BC:  MOVWF  x2C
019BE:  MOVLB  0
019C0:  CALL   0852
019C4:  MOVFF  01,5EA
019C8:  MOVLW  02
019CA:  MOVLB  5
019CC:  ADDWF  01,W
019CE:  MOVWF  01
019D0:  MOVLW  00
019D2:  ADDWFC 02,W
019D4:  MOVWF  03
019D6:  MOVF   01,W
019D8:  ADDLW  55
019DA:  MOVWF  FE9
019DC:  MOVLW  01
019DE:  ADDWFC 03,W
019E0:  MOVWF  FEA
019E2:  MOVLW  01
019E4:  ADDWF  FEF,W
019E6:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
019E8:  MOVLB  6
019EA:  CLRF   x2B
019EC:  MOVFF  42A,62A
019F0:  CLRF   x2D
019F2:  MOVLW  B5
019F4:  MOVWF  x2C
019F6:  MOVLB  0
019F8:  CALL   0852
019FC:  MOVFF  01,5EA
01A00:  MOVLW  01
01A02:  MOVLB  5
01A04:  ADDWF  01,W
01A06:  MOVWF  01
01A08:  MOVLW  00
01A0A:  ADDWFC 02,W
01A0C:  MOVWF  03
01A0E:  MOVF   01,W
01A10:  ADDLW  55
01A12:  MOVWF  FE9
01A14:  MOVLW  01
01A16:  ADDWFC 03,W
01A18:  MOVWF  FEA
01A1A:  CLRF   FEF
....................          }
01A1C:  BRA    1A34
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
01A1E:  MOVFF  42A,5EA
01A22:  MOVLB  0
01A24:  CALL   0874
....................             fprintf(SERIAL, retData);
01A28:  MOVLW  04
01A2A:  MOVWF  FEA
01A2C:  MOVLW  2B
01A2E:  MOVWF  FE9
01A30:  RCALL  1726
01A32:  MOVLB  5
....................          }
....................       }
01A34:  BRA    1C56
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
01A36:  MOVLB  6
01A38:  CLRF   x2B
01A3A:  MOVFF  42A,62A
01A3E:  CLRF   x2D
01A40:  MOVLW  B5
01A42:  MOVWF  x2C
01A44:  MOVLB  0
01A46:  CALL   0852
01A4A:  MOVFF  02,5EB
01A4E:  MOVFF  01,5EA
01A52:  MOVLW  01
01A54:  MOVLB  5
01A56:  ADDWF  01,W
01A58:  MOVWF  01
01A5A:  MOVLW  00
01A5C:  ADDWFC 02,W
01A5E:  MOVWF  03
01A60:  MOVF   01,W
01A62:  ADDLW  55
01A64:  MOVWF  FE9
01A66:  MOVLW  01
01A68:  ADDWFC 03,W
01A6A:  MOVWF  FEA
01A6C:  MOVF   FEF,W
01A6E:  SUBLW  18
01A70:  BTFSS  FD8.0
01A72:  BRA    1C40
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
01A74:  MOVLB  6
01A76:  CLRF   x2B
01A78:  MOVFF  42A,62A
01A7C:  CLRF   x2D
01A7E:  MOVLW  B5
01A80:  MOVWF  x2C
01A82:  MOVLB  0
01A84:  CALL   0852
01A88:  MOVFF  02,5EB
01A8C:  MOVFF  01,5EA
01A90:  MOVLW  06
01A92:  MOVLB  5
01A94:  ADDWF  xEA,F
01A96:  MOVLW  00
01A98:  ADDWFC xEB,F
01A9A:  MOVLB  6
01A9C:  CLRF   x2B
01A9E:  MOVFF  42A,62A
01AA2:  CLRF   x2D
01AA4:  MOVLW  B5
01AA6:  MOVWF  x2C
01AA8:  MOVLB  0
01AAA:  CALL   0852
01AAE:  MOVFF  02,5ED
01AB2:  MOVFF  01,5EC
01AB6:  MOVLW  02
01AB8:  ADDWF  01,W
01ABA:  MOVWF  01
01ABC:  MOVLW  00
01ABE:  ADDWFC 02,W
01AC0:  MOVWF  03
01AC2:  MOVF   01,W
01AC4:  ADDLW  55
01AC6:  MOVWF  FE9
01AC8:  MOVLW  01
01ACA:  ADDWFC 03,W
01ACC:  MOVWF  FEA
01ACE:  MOVLB  6
01AD0:  CLRF   x2B
01AD2:  MOVFF  FEF,62A
01AD6:  CLRF   x2D
01AD8:  MOVLW  19
01ADA:  MOVWF  x2C
01ADC:  MOVLB  0
01ADE:  CALL   0852
01AE2:  MOVFF  02,03
01AE6:  MOVF   01,W
01AE8:  MOVLB  5
01AEA:  ADDWF  xEA,F
01AEC:  MOVF   02,W
01AEE:  ADDWFC xEB,F
01AF0:  MOVLB  6
01AF2:  CLRF   x2B
01AF4:  MOVFF  42A,62A
01AF8:  CLRF   x2D
01AFA:  MOVLW  B5
01AFC:  MOVWF  x2C
01AFE:  MOVLB  0
01B00:  CALL   0852
01B04:  MOVFF  01,5EC
01B08:  MOVLW  01
01B0A:  MOVLB  5
01B0C:  ADDWF  01,W
01B0E:  MOVWF  01
01B10:  MOVLW  00
01B12:  ADDWFC 02,W
01B14:  MOVWF  03
01B16:  MOVF   01,W
01B18:  ADDLW  55
01B1A:  MOVWF  FE9
01B1C:  MOVLW  01
01B1E:  ADDWFC 03,W
01B20:  MOVWF  FEA
01B22:  MOVF   FEF,W
01B24:  ADDWF  xEA,W
01B26:  MOVWF  01
01B28:  MOVLW  00
01B2A:  ADDWFC xEB,W
01B2C:  MOVWF  03
01B2E:  MOVF   01,W
01B30:  ADDLW  55
01B32:  MOVWF  FE9
01B34:  MOVLW  01
01B36:  ADDWFC 03,W
01B38:  MOVWF  FEA
01B3A:  MOVFF  5E9,FEF
....................             SERcmd[SWI].chrIndex += 1;
01B3E:  MOVLB  6
01B40:  CLRF   x2B
01B42:  MOVFF  42A,62A
01B46:  CLRF   x2D
01B48:  MOVLW  B5
01B4A:  MOVWF  x2C
01B4C:  MOVLB  0
01B4E:  CALL   0852
01B52:  MOVFF  01,5EA
01B56:  MOVLW  01
01B58:  MOVLB  5
01B5A:  ADDWF  01,W
01B5C:  MOVWF  01
01B5E:  MOVLW  00
01B60:  ADDWFC 02,W
01B62:  MOVWF  03
01B64:  MOVF   01,W
01B66:  ADDLW  55
01B68:  MOVWF  FE9
01B6A:  MOVLW  01
01B6C:  ADDWFC 03,W
01B6E:  MOVWF  FEA
01B70:  MOVLW  01
01B72:  ADDWF  FEF,W
01B74:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
01B76:  MOVLB  6
01B78:  CLRF   x2B
01B7A:  MOVFF  42A,62A
01B7E:  CLRF   x2D
01B80:  MOVLW  B5
01B82:  MOVWF  x2C
01B84:  MOVLB  0
01B86:  CALL   0852
01B8A:  MOVFF  02,5EB
01B8E:  MOVFF  01,5EA
01B92:  MOVLW  06
01B94:  MOVLB  5
01B96:  ADDWF  xEA,F
01B98:  MOVLW  00
01B9A:  ADDWFC xEB,F
01B9C:  MOVLB  6
01B9E:  CLRF   x2B
01BA0:  MOVFF  42A,62A
01BA4:  CLRF   x2D
01BA6:  MOVLW  B5
01BA8:  MOVWF  x2C
01BAA:  MOVLB  0
01BAC:  CALL   0852
01BB0:  MOVFF  02,5ED
01BB4:  MOVFF  01,5EC
01BB8:  MOVLW  02
01BBA:  ADDWF  01,W
01BBC:  MOVWF  01
01BBE:  MOVLW  00
01BC0:  ADDWFC 02,W
01BC2:  MOVWF  03
01BC4:  MOVF   01,W
01BC6:  ADDLW  55
01BC8:  MOVWF  FE9
01BCA:  MOVLW  01
01BCC:  ADDWFC 03,W
01BCE:  MOVWF  FEA
01BD0:  MOVLB  6
01BD2:  CLRF   x2B
01BD4:  MOVFF  FEF,62A
01BD8:  CLRF   x2D
01BDA:  MOVLW  19
01BDC:  MOVWF  x2C
01BDE:  MOVLB  0
01BE0:  CALL   0852
01BE4:  MOVFF  02,03
01BE8:  MOVF   01,W
01BEA:  MOVLB  5
01BEC:  ADDWF  xEA,F
01BEE:  MOVF   02,W
01BF0:  ADDWFC xEB,F
01BF2:  MOVLB  6
01BF4:  CLRF   x2B
01BF6:  MOVFF  42A,62A
01BFA:  CLRF   x2D
01BFC:  MOVLW  B5
01BFE:  MOVWF  x2C
01C00:  MOVLB  0
01C02:  CALL   0852
01C06:  MOVFF  01,5EC
01C0A:  MOVLW  01
01C0C:  MOVLB  5
01C0E:  ADDWF  01,W
01C10:  MOVWF  01
01C12:  MOVLW  00
01C14:  ADDWFC 02,W
01C16:  MOVWF  03
01C18:  MOVF   01,W
01C1A:  ADDLW  55
01C1C:  MOVWF  FE9
01C1E:  MOVLW  01
01C20:  ADDWFC 03,W
01C22:  MOVWF  FEA
01C24:  MOVF   FEF,W
01C26:  ADDWF  xEA,W
01C28:  MOVWF  01
01C2A:  MOVLW  00
01C2C:  ADDWFC xEB,W
01C2E:  MOVWF  03
01C30:  MOVF   01,W
01C32:  ADDLW  55
01C34:  MOVWF  FE9
01C36:  MOVLW  01
01C38:  ADDWFC 03,W
01C3A:  MOVWF  FEA
01C3C:  CLRF   FEF
....................          }
01C3E:  BRA    1C56
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
01C40:  MOVFF  42A,5EA
01C44:  MOVLB  0
01C46:  CALL   0874
....................             fprintf(SERIAL, retData);
01C4A:  MOVLW  04
01C4C:  MOVWF  FEA
01C4E:  MOVLW  2B
01C50:  MOVWF  FE9
01C52:  RCALL  1726
01C54:  MOVLB  5
....................          }
....................       }
01C56:  MOVLB  0
01C58:  BRA    174A
01C5A:  MOVLB  4
....................    }          
01C5C:  MOVLB  0
01C5E:  GOTO   605E (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
009FE:  MOVLB  5
00A00:  CLRF   xE9
00A02:  MOVF   xE9,W
00A04:  SUBLW  03
00A06:  BNC   0A16
....................    {
....................       resetSERcmd(i);
00A08:  MOVFF  5E9,5EA
00A0C:  MOVLB  0
00A0E:  RCALL  0874
00A10:  MOVLB  5
00A12:  INCF   xE9,F
00A14:  BRA    0A02
....................    }
....................    enable_interrupts(INT_RDA);
00A16:  MOVLB  E
00A18:  BSF    xC0.5
00A1A:  MOVLB  0
00A1C:  GOTO   604E (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // mid-pole position in microns
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;   // error = set value - measured
....................    PID[ch].I += (err * PID[ch].kI);       // integral value 
....................    float P = err * PID[ch].kP;            // proportional value
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold); // derivative value
....................    PID[ch].CV = P + PID[ch].I + D;        // new control variable
....................    if (PID[ch].CV > 100) 
....................    {
....................       PID[ch].CV = 100;// limit output to 100%
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (adcVals[ch].pReal != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // mid-pole position in microns
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
....................    timeoutReg0 = 0;  // clear all the timers
....................    timeoutReg1 = 0;
....................    timeoutReg2 = 0;
....................    intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00240:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00242:  MOVLW  0B
00244:  MOVWF  FCD
00246:  MOVLW  DB
00248:  MOVWF  FCC
0024A:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0024C:  MOVLB  1
0024E:  MOVF   x44,F
00250:  BNZ   0260
00252:  MOVF   x43,F
00254:  BNZ   0260
00256:  MOVF   x42,F
00258:  BNZ   0260
0025A:  MOVF   x41,W
0025C:  SUBLW  0A
0025E:  BC    026E
00260:  MOVLW  0A
00262:  SUBWF  x41,F
00264:  MOVLW  00
00266:  SUBWFB x42,F
00268:  SUBWFB x43,F
0026A:  SUBWFB x44,F
0026C:  BRA    0276
0026E:  CLRF   x44
00270:  CLRF   x43
00272:  CLRF   x42
00274:  CLRF   x41
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00276:  MOVF   x48,F
00278:  BNZ   0288
0027A:  MOVF   x47,F
0027C:  BNZ   0288
0027E:  MOVF   x46,F
00280:  BNZ   0288
00282:  MOVF   x45,W
00284:  SUBLW  0A
00286:  BC    0296
00288:  MOVLW  0A
0028A:  SUBWF  x45,F
0028C:  MOVLW  00
0028E:  SUBWFB x46,F
00290:  SUBWFB x47,F
00292:  SUBWFB x48,F
00294:  BRA    029E
00296:  CLRF   x48
00298:  CLRF   x47
0029A:  CLRF   x46
0029C:  CLRF   x45
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
0029E:  MOVF   x4C,F
002A0:  BNZ   02B0
002A2:  MOVF   x4B,F
002A4:  BNZ   02B0
002A6:  MOVF   x4A,F
002A8:  BNZ   02B0
002AA:  MOVF   x49,W
002AC:  SUBLW  0A
002AE:  BC    02BE
002B0:  MOVLW  0A
002B2:  SUBWF  x49,F
002B4:  MOVLW  00
002B6:  SUBWFB x4A,F
002B8:  SUBWFB x4B,F
002BA:  SUBWFB x4C,F
002BC:  BRA    02C6
002BE:  CLRF   x4C
002C0:  CLRF   x4B
002C2:  CLRF   x4A
002C4:  CLRF   x49
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002C6:  MOVF   x4D,F
002C8:  BNZ   02CE
002CA:  MOVF   x4E,F
002CC:  BZ    030A
....................    {
....................       timeCounter+=10;
002CE:  MOVLW  0A
002D0:  MOVLB  4
002D2:  ADDWF  xD2,F
002D4:  MOVLW  00
002D6:  ADDWFC xD3,F
002D8:  ADDWFC xD4,F
002DA:  ADDWFC xD5,F
....................       if (timeCounter >= intTimeoutReg)
002DC:  MOVF   xD5,F
002DE:  BNZ   02FA
002E0:  MOVF   xD4,F
002E2:  BNZ   02FA
002E4:  MOVLB  1
002E6:  MOVF   x4E,W
002E8:  MOVLB  4
002EA:  SUBWF  xD3,W
002EC:  BNC   0308
002EE:  BNZ   02FA
002F0:  MOVLB  1
002F2:  MOVF   x4D,W
002F4:  MOVLB  4
002F6:  SUBWF  xD2,W
002F8:  BNC   0308
....................       {
....................          sensor_monitor_interrupt_task();
002FA:  MOVLB  0
002FC:  BRA    01BA
....................          timeCounter = 0;
002FE:  MOVLB  4
00300:  CLRF   xD5
00302:  CLRF   xD4
00304:  CLRF   xD3
00306:  CLRF   xD2
00308:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // mid-pole position in microns
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
0030A:  MOVLB  E
0030C:  BCF    xC9.0
0030E:  MOVLB  0
00310:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
02008:  MOVLW  04
0200A:  MOVLB  6
0200C:  MOVWF  x2B
0200E:  MOVLW  2B
02010:  MOVWF  x2A
02012:  MOVLB  0
02014:  RCALL  1F18
02016:  MOVFF  02,03
0201A:  MOVF   01,W
0201C:  ADDLW  2B
0201E:  MOVLB  5
02020:  MOVWF  xF4
02022:  MOVLW  04
02024:  ADDWFC 02,W
02026:  MOVWF  xF5
02028:  MOVFF  FE8,4D0
0202C:  MOVFF  5F4,4CF
02030:  MOVLW  14
02032:  MOVWF  FF6
02034:  MOVLW  03
02036:  MOVWF  FF7
02038:  MOVLB  0
0203A:  RCALL  1FE8
0203C:  MOVLW  2C
0203E:  MOVLB  6
02040:  MOVWF  x35
02042:  MOVLB  0
02044:  RCALL  1FC8
....................    return SUCCESS;
02046:  MOVLW  00
02048:  MOVWF  01
0204A:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
0204C:  MOVLW  04
0204E:  MOVLB  6
02050:  MOVWF  x2B
02052:  MOVLW  2B
02054:  MOVWF  x2A
02056:  MOVLB  0
02058:  RCALL  1F18
0205A:  MOVFF  02,03
0205E:  MOVF   01,W
02060:  ADDLW  2B
02062:  MOVLB  5
02064:  MOVWF  xF4
02066:  MOVLW  04
02068:  ADDWFC 02,W
0206A:  MOVWF  xF5
0206C:  MOVFF  FE8,4D0
02070:  MOVFF  5F4,4CF
02074:  MOVLW  1E
02076:  MOVWF  FF6
02078:  MOVLW  03
0207A:  MOVWF  FF7
0207C:  MOVLB  0
0207E:  RCALL  1FE8
02080:  MOVLW  2C
02082:  MOVLB  6
02084:  MOVWF  x35
02086:  MOVLB  0
02088:  RCALL  1FC8
....................    return SUCCESS;
0208A:  MOVLW  00
0208C:  MOVWF  01
0208E:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
024D4:  MOVLB  6
024D6:  CLRF   x2B
024D8:  MOVFF  5D8,62A
024DC:  CLRF   x2D
024DE:  MOVLW  B5
024E0:  MOVWF  x2C
024E2:  MOVLB  0
024E4:  CALL   0852
024E8:  MOVFF  02,5F6
024EC:  MOVFF  01,5F5
024F0:  MOVLW  06
024F2:  MOVLB  5
024F4:  ADDWF  xF5,F
024F6:  MOVLW  00
024F8:  ADDWFC xF6,F
024FA:  MOVLW  32
024FC:  ADDWF  xF5,W
024FE:  MOVWF  01
02500:  MOVLW  00
02502:  ADDWFC xF6,W
02504:  MOVWF  03
02506:  MOVF   01,W
02508:  ADDLW  55
0250A:  MOVWF  01
0250C:  MOVLW  01
0250E:  ADDWFC 03,F
02510:  MOVFF  01,5F5
02514:  MOVFF  03,5F6
02518:  MOVFF  03,61D
0251C:  MOVFF  01,61C
02520:  MOVLB  0
02522:  RCALL  2090
02524:  MOVF   01,F
02526:  BNZ   2530
02528:  MOVLW  02
0252A:  MOVWF  01
0252C:  BRA    2644
0252E:  BRA    258E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
02530:  MOVLB  6
02532:  CLRF   x2B
02534:  MOVFF  5D8,62A
02538:  CLRF   x2D
0253A:  MOVLW  B5
0253C:  MOVWF  x2C
0253E:  MOVLB  0
02540:  CALL   0852
02544:  MOVFF  02,5F6
02548:  MOVFF  01,5F5
0254C:  MOVLW  06
0254E:  MOVLB  5
02550:  ADDWF  xF5,F
02552:  MOVLW  00
02554:  ADDWFC xF6,F
02556:  MOVLW  32
02558:  ADDWF  xF5,W
0255A:  MOVWF  01
0255C:  MOVLW  00
0255E:  ADDWFC xF6,W
02560:  MOVWF  03
02562:  MOVF   01,W
02564:  ADDLW  55
02566:  MOVWF  01
02568:  MOVLW  01
0256A:  ADDWFC 03,F
0256C:  MOVFF  01,5F5
02570:  MOVFF  03,5F6
02574:  MOVFF  03,61D
02578:  MOVFF  01,61C
0257C:  MOVLB  6
0257E:  CLRF   x1F
02580:  CLRF   x1E
02582:  MOVLW  0A
02584:  MOVWF  x20
02586:  MOVLB  0
02588:  RCALL  2180
0258A:  MOVFF  01,5F4
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'X');
0258E:  MOVLW  01
02590:  MOVLB  5
02592:  SUBWF  xF4,W
02594:  MOVWF  xF6
02596:  CLRF   xF8
02598:  MOVLW  60
0259A:  MOVWF  xF7
0259C:  MOVLB  0
0259E:  CALL   12DA
025A2:  BTFSC  01.0
025A4:  BRA    25E4
025A6:  MOVLW  04
025A8:  MOVLB  6
025AA:  MOVWF  x2B
025AC:  MOVLW  2B
025AE:  MOVWF  x2A
025B0:  MOVLB  0
025B2:  RCALL  1F18
025B4:  MOVFF  02,03
025B8:  MOVF   01,W
025BA:  ADDLW  2B
025BC:  MOVLB  5
025BE:  MOVWF  xF5
025C0:  MOVLW  04
025C2:  ADDWFC 02,W
025C4:  MOVWF  xF6
025C6:  MOVFF  FE8,4D0
025CA:  MOVFF  5F5,4CF
025CE:  MOVLW  58
025D0:  MOVLB  6
025D2:  MOVWF  x35
025D4:  MOVLB  0
025D6:  RCALL  1FC8
025D8:  MOVLW  2C
025DA:  MOVLB  6
025DC:  MOVWF  x35
025DE:  MOVLB  0
025E0:  RCALL  1FC8
025E2:  BRA    2640
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'Y');
025E4:  MOVLW  01
025E6:  MOVLB  5
025E8:  SUBWF  xF4,W
025EA:  MOVWF  xF6
025EC:  CLRF   xF8
025EE:  MOVLW  60
025F0:  MOVWF  xF7
025F2:  MOVLB  0
025F4:  CALL   12DA
025F8:  BTFSS  01.0
025FA:  BRA    263A
025FC:  MOVLW  04
025FE:  MOVLB  6
02600:  MOVWF  x2B
02602:  MOVLW  2B
02604:  MOVWF  x2A
02606:  MOVLB  0
02608:  RCALL  1F18
0260A:  MOVFF  02,03
0260E:  MOVF   01,W
02610:  ADDLW  2B
02612:  MOVLB  5
02614:  MOVWF  xF5
02616:  MOVLW  04
02618:  ADDWFC 02,W
0261A:  MOVWF  xF6
0261C:  MOVFF  FE8,4D0
02620:  MOVFF  5F5,4CF
02624:  MOVLW  59
02626:  MOVLB  6
02628:  MOVWF  x35
0262A:  MOVLB  0
0262C:  RCALL  1FC8
0262E:  MOVLW  2C
02630:  MOVLB  6
02632:  MOVWF  x35
02634:  MOVLB  0
02636:  RCALL  1FC8
02638:  BRA    2640
....................    else return INV_PARAM;
0263A:  MOVLW  02
0263C:  MOVWF  01
0263E:  BRA    2644
....................    
....................    return SUCCESS;
02640:  MOVLW  00
02642:  MOVWF  01
02644:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
02688:  MOVLB  6
0268A:  CLRF   x2B
0268C:  MOVFF  5D8,62A
02690:  CLRF   x2D
02692:  MOVLW  B5
02694:  MOVWF  x2C
02696:  MOVLB  0
02698:  CALL   0852
0269C:  MOVFF  02,5F7
026A0:  MOVFF  01,5F6
026A4:  MOVLW  06
026A6:  MOVLB  5
026A8:  ADDWF  xF6,F
026AA:  MOVLW  00
026AC:  ADDWFC xF7,F
026AE:  MOVLW  32
026B0:  ADDWF  xF6,W
026B2:  MOVWF  01
026B4:  MOVLW  00
026B6:  ADDWFC xF7,W
026B8:  MOVWF  03
026BA:  MOVF   01,W
026BC:  ADDLW  55
026BE:  MOVWF  01
026C0:  MOVLW  01
026C2:  ADDWFC 03,F
026C4:  MOVFF  01,5F6
026C8:  MOVFF  03,5F7
026CC:  MOVFF  03,61D
026D0:  MOVFF  01,61C
026D4:  MOVLB  0
026D6:  RCALL  2090
026D8:  MOVF   01,F
026DA:  BNZ   26E4
026DC:  MOVLW  02
026DE:  MOVWF  01
026E0:  BRA    283E
026E2:  BRA    2742
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
026E4:  MOVLB  6
026E6:  CLRF   x2B
026E8:  MOVFF  5D8,62A
026EC:  CLRF   x2D
026EE:  MOVLW  B5
026F0:  MOVWF  x2C
026F2:  MOVLB  0
026F4:  CALL   0852
026F8:  MOVFF  02,5F7
026FC:  MOVFF  01,5F6
02700:  MOVLW  06
02702:  MOVLB  5
02704:  ADDWF  xF6,F
02706:  MOVLW  00
02708:  ADDWFC xF7,F
0270A:  MOVLW  32
0270C:  ADDWF  xF6,W
0270E:  MOVWF  01
02710:  MOVLW  00
02712:  ADDWFC xF7,W
02714:  MOVWF  03
02716:  MOVF   01,W
02718:  ADDLW  55
0271A:  MOVWF  01
0271C:  MOVLW  01
0271E:  ADDWFC 03,F
02720:  MOVFF  01,5F6
02724:  MOVFF  03,5F7
02728:  MOVFF  03,61D
0272C:  MOVFF  01,61C
02730:  MOVLB  6
02732:  CLRF   x1F
02734:  CLRF   x1E
02736:  MOVLW  0A
02738:  MOVWF  x20
0273A:  MOVLB  0
0273C:  RCALL  2180
0273E:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
02742:  MOVLB  6
02744:  CLRF   x2B
02746:  MOVFF  5D8,62A
0274A:  CLRF   x2D
0274C:  MOVLW  B5
0274E:  MOVWF  x2C
02750:  MOVLB  0
02752:  CALL   0852
02756:  MOVFF  02,5F7
0275A:  MOVFF  01,5F6
0275E:  MOVLW  06
02760:  MOVLB  5
02762:  ADDWF  xF6,F
02764:  MOVLW  00
02766:  ADDWFC xF7,F
02768:  MOVLW  4B
0276A:  ADDWF  xF6,W
0276C:  MOVWF  01
0276E:  MOVLW  00
02770:  ADDWFC xF7,W
02772:  MOVWF  03
02774:  MOVF   01,W
02776:  ADDLW  55
02778:  MOVWF  01
0277A:  MOVLW  01
0277C:  ADDWFC 03,F
0277E:  MOVFF  01,5F6
02782:  MOVFF  03,5F7
02786:  MOVFF  03,62B
0278A:  MOVFF  01,62A
0278E:  MOVLB  0
02790:  CALL   1F18
02794:  MOVFF  02,03
02798:  MOVF   01,W
0279A:  SUBLW  01
0279C:  BNZ   27A2
0279E:  MOVF   03,F
027A0:  BZ    27AA
027A2:  MOVLW  02
027A4:  MOVWF  01
027A6:  BRA    283E
027A8:  BRA    27EA
....................    else arg2 = SERcmd[rec].p[3][0];
027AA:  MOVLB  6
027AC:  CLRF   x2B
027AE:  MOVFF  5D8,62A
027B2:  CLRF   x2D
027B4:  MOVLW  B5
027B6:  MOVWF  x2C
027B8:  MOVLB  0
027BA:  CALL   0852
027BE:  MOVFF  02,5F7
027C2:  MOVFF  01,5F6
027C6:  MOVLW  06
027C8:  MOVLB  5
027CA:  ADDWF  xF6,F
027CC:  MOVLW  00
027CE:  ADDWFC xF7,F
027D0:  MOVLW  4B
027D2:  ADDWF  xF6,F
027D4:  MOVLW  00
027D6:  ADDWFC xF7,F
027D8:  MOVLW  55
027DA:  ADDWF  xF6,W
027DC:  MOVWF  FE9
027DE:  MOVLW  01
027E0:  ADDWFC xF7,W
027E2:  MOVWF  FEA
027E4:  MOVFF  FEF,5F5
027E8:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
027EA:  MOVLB  5
027EC:  MOVF   xF5,W
027EE:  SUBLW  58
027F0:  BNZ   280E
027F2:  MOVLW  01
027F4:  SUBWF  xF4,W
027F6:  MOVWF  xF6
027F8:  MOVFF  FE8,60B
027FC:  MOVLB  6
027FE:  CLRF   x0C
02800:  CLRF   x0E
02802:  MOVLW  60
02804:  MOVWF  x0D
02806:  MOVLB  0
02808:  RCALL  2646
0280A:  BRA    283A
0280C:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
0280E:  MOVF   xF5,W
02810:  SUBLW  59
02812:  BNZ   2832
02814:  MOVLW  01
02816:  SUBWF  xF4,W
02818:  MOVWF  xF6
0281A:  MOVFF  FE8,60B
0281E:  MOVLW  01
02820:  MOVLB  6
02822:  MOVWF  x0C
02824:  CLRF   x0E
02826:  MOVLW  60
02828:  MOVWF  x0D
0282A:  MOVLB  0
0282C:  RCALL  2646
0282E:  BRA    283A
02830:  MOVLB  5
....................    else return INV_PARAM;
02832:  MOVLW  02
02834:  MOVWF  01
02836:  MOVLB  0
02838:  BRA    283E
....................    
....................    return SUCCESS;
0283A:  MOVLW  00
0283C:  MOVWF  01
0283E:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
02840:  MOVLB  6
02842:  CLRF   x2B
02844:  MOVFF  5D8,62A
02848:  CLRF   x2D
0284A:  MOVLW  B5
0284C:  MOVWF  x2C
0284E:  MOVLB  0
02850:  CALL   0852
02854:  MOVFF  02,5F6
02858:  MOVFF  01,5F5
0285C:  MOVLW  06
0285E:  MOVLB  5
02860:  ADDWF  xF5,F
02862:  MOVLW  00
02864:  ADDWFC xF6,F
02866:  MOVLW  32
02868:  ADDWF  xF5,W
0286A:  MOVWF  01
0286C:  MOVLW  00
0286E:  ADDWFC xF6,W
02870:  MOVWF  03
02872:  MOVF   01,W
02874:  ADDLW  55
02876:  MOVWF  01
02878:  MOVLW  01
0287A:  ADDWFC 03,F
0287C:  MOVFF  01,5F5
02880:  MOVFF  03,5F6
02884:  MOVFF  03,61D
02888:  MOVFF  01,61C
0288C:  MOVLB  0
0288E:  RCALL  2090
02890:  MOVF   01,F
02892:  BNZ   289C
02894:  MOVLW  02
02896:  MOVWF  01
02898:  BRA    29A8
0289A:  BRA    28FA
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0289C:  MOVLB  6
0289E:  CLRF   x2B
028A0:  MOVFF  5D8,62A
028A4:  CLRF   x2D
028A6:  MOVLW  B5
028A8:  MOVWF  x2C
028AA:  MOVLB  0
028AC:  CALL   0852
028B0:  MOVFF  02,5F6
028B4:  MOVFF  01,5F5
028B8:  MOVLW  06
028BA:  MOVLB  5
028BC:  ADDWF  xF5,F
028BE:  MOVLW  00
028C0:  ADDWFC xF6,F
028C2:  MOVLW  32
028C4:  ADDWF  xF5,W
028C6:  MOVWF  01
028C8:  MOVLW  00
028CA:  ADDWFC xF6,W
028CC:  MOVWF  03
028CE:  MOVF   01,W
028D0:  ADDLW  55
028D2:  MOVWF  01
028D4:  MOVLW  01
028D6:  ADDWFC 03,F
028D8:  MOVFF  01,5F5
028DC:  MOVFF  03,5F6
028E0:  MOVFF  03,61D
028E4:  MOVFF  01,61C
028E8:  MOVLB  6
028EA:  CLRF   x1F
028EC:  CLRF   x1E
028EE:  MOVLW  0A
028F0:  MOVWF  x20
028F2:  MOVLB  0
028F4:  RCALL  2180
028F6:  MOVFF  01,5F4
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MANUAL,");
028FA:  MOVLW  01
028FC:  MOVLB  5
028FE:  SUBWF  xF4,W
02900:  MOVWF  xF6
02902:  CLRF   xF8
02904:  MOVLW  61
02906:  MOVWF  xF7
02908:  MOVLB  0
0290A:  CALL   12DA
0290E:  BTFSC  01.0
02910:  BRA    294C
02912:  MOVLW  04
02914:  MOVLB  6
02916:  MOVWF  x2B
02918:  MOVLW  2B
0291A:  MOVWF  x2A
0291C:  MOVLB  0
0291E:  CALL   1F18
02922:  MOVFF  02,03
02926:  MOVF   01,W
02928:  ADDLW  2B
0292A:  MOVLB  5
0292C:  MOVWF  xF5
0292E:  MOVLW  04
02930:  ADDWFC 02,W
02932:  MOVWF  xF6
02934:  MOVFF  FE8,4D0
02938:  MOVFF  5F5,4CF
0293C:  MOVLW  24
0293E:  MOVWF  FF6
02940:  MOVLW  03
02942:  MOVWF  FF7
02944:  MOVLB  0
02946:  CALL   1FE8
0294A:  BRA    29A4
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MAGSNS,");
0294C:  MOVLW  01
0294E:  MOVLB  5
02950:  SUBWF  xF4,W
02952:  MOVWF  xF6
02954:  CLRF   xF8
02956:  MOVLW  61
02958:  MOVWF  xF7
0295A:  MOVLB  0
0295C:  CALL   12DA
02960:  BTFSS  01.0
02962:  BRA    299E
02964:  MOVLW  04
02966:  MOVLB  6
02968:  MOVWF  x2B
0296A:  MOVLW  2B
0296C:  MOVWF  x2A
0296E:  MOVLB  0
02970:  CALL   1F18
02974:  MOVFF  02,03
02978:  MOVF   01,W
0297A:  ADDLW  2B
0297C:  MOVLB  5
0297E:  MOVWF  xF5
02980:  MOVLW  04
02982:  ADDWFC 02,W
02984:  MOVWF  xF6
02986:  MOVFF  FE8,4D0
0298A:  MOVFF  5F5,4CF
0298E:  MOVLW  2C
02990:  MOVWF  FF6
02992:  MOVLW  03
02994:  MOVWF  FF7
02996:  MOVLB  0
02998:  CALL   1FE8
0299C:  BRA    29A4
....................    else return INV_PARAM;
0299E:  MOVLW  02
029A0:  MOVWF  01
029A2:  BRA    29A8
....................    
....................    return SUCCESS;
029A4:  MOVLW  00
029A6:  MOVWF  01
029A8:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
029AA:  MOVLW  4D
029AC:  MOVLB  5
029AE:  MOVWF  xF9
029B0:  MOVLW  41
029B2:  MOVWF  xFA
029B4:  MOVLW  4E
029B6:  MOVWF  xFB
029B8:  MOVLW  55
029BA:  MOVWF  xFC
029BC:  MOVLW  41
029BE:  MOVWF  xFD
029C0:  MOVLW  4C
029C2:  MOVWF  xFE
029C4:  CLRF   xFF
029C6:  MOVLW  05
029C8:  MOVWF  xF8
029CA:  MOVLW  F9
029CC:  MOVWF  xF7
....................    char *s_magsns = "MAGSNS";
029CE:  MOVLW  4D
029D0:  MOVLB  6
029D2:  MOVWF  x02
029D4:  MOVLW  41
029D6:  MOVWF  x03
029D8:  MOVLW  47
029DA:  MOVWF  x04
029DC:  MOVLW  53
029DE:  MOVWF  x05
029E0:  MOVLW  4E
029E2:  MOVWF  x06
029E4:  MOVLW  53
029E6:  MOVWF  x07
029E8:  CLRF   x08
029EA:  MOVLW  06
029EC:  MOVWF  x01
029EE:  MOVLW  02
029F0:  MOVWF  x00
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
029F2:  CLRF   x2B
029F4:  MOVFF  5D8,62A
029F8:  CLRF   x2D
029FA:  MOVLW  B5
029FC:  MOVWF  x2C
029FE:  MOVLB  0
02A00:  CALL   0852
02A04:  MOVFF  02,60A
02A08:  MOVFF  01,609
02A0C:  MOVLW  06
02A0E:  MOVLB  6
02A10:  ADDWF  x09,F
02A12:  MOVLW  00
02A14:  ADDWFC x0A,F
02A16:  MOVLW  32
02A18:  ADDWF  x09,W
02A1A:  MOVWF  01
02A1C:  MOVLW  00
02A1E:  ADDWFC x0A,W
02A20:  MOVWF  03
02A22:  MOVF   01,W
02A24:  ADDLW  55
02A26:  MOVWF  01
02A28:  MOVLW  01
02A2A:  ADDWFC 03,F
02A2C:  MOVFF  01,609
02A30:  MOVFF  03,60A
02A34:  MOVFF  03,61D
02A38:  MOVFF  01,61C
02A3C:  MOVLB  0
02A3E:  CALL   2090
02A42:  MOVF   01,F
02A44:  BNZ   2A4E
02A46:  MOVLW  02
02A48:  MOVWF  01
02A4A:  BRA    2BC8
02A4C:  BRA    2AAC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
02A4E:  MOVLB  6
02A50:  CLRF   x2B
02A52:  MOVFF  5D8,62A
02A56:  CLRF   x2D
02A58:  MOVLW  B5
02A5A:  MOVWF  x2C
02A5C:  MOVLB  0
02A5E:  CALL   0852
02A62:  MOVFF  02,60A
02A66:  MOVFF  01,609
02A6A:  MOVLW  06
02A6C:  MOVLB  6
02A6E:  ADDWF  x09,F
02A70:  MOVLW  00
02A72:  ADDWFC x0A,F
02A74:  MOVLW  32
02A76:  ADDWF  x09,W
02A78:  MOVWF  01
02A7A:  MOVLW  00
02A7C:  ADDWFC x0A,W
02A7E:  MOVWF  03
02A80:  MOVF   01,W
02A82:  ADDLW  55
02A84:  MOVWF  01
02A86:  MOVLW  01
02A88:  ADDWFC 03,F
02A8A:  MOVFF  01,609
02A8E:  MOVFF  03,60A
02A92:  MOVFF  03,61D
02A96:  MOVFF  01,61C
02A9A:  CLRF   x1F
02A9C:  CLRF   x1E
02A9E:  MOVLW  0A
02AA0:  MOVWF  x20
02AA2:  MOVLB  0
02AA4:  CALL   2180
02AA8:  MOVFF  01,5F4
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
02AAC:  MOVLB  6
02AAE:  CLRF   x2B
02AB0:  MOVFF  5D8,62A
02AB4:  CLRF   x2D
02AB6:  MOVLW  B5
02AB8:  MOVWF  x2C
02ABA:  MOVLB  0
02ABC:  CALL   0852
02AC0:  MOVFF  02,60A
02AC4:  MOVFF  01,609
02AC8:  MOVLW  06
02ACA:  MOVLB  6
02ACC:  ADDWF  x09,F
02ACE:  MOVLW  00
02AD0:  ADDWFC x0A,F
02AD2:  MOVLW  4B
02AD4:  ADDWF  x09,W
02AD6:  MOVWF  01
02AD8:  MOVLW  00
02ADA:  ADDWFC x0A,W
02ADC:  MOVWF  03
02ADE:  MOVF   01,W
02AE0:  ADDLW  55
02AE2:  MOVWF  01
02AE4:  MOVLW  01
02AE6:  ADDWFC 03,F
02AE8:  MOVFF  01,609
02AEC:  MOVFF  03,60A
02AF0:  MOVFF  03,62B
02AF4:  MOVFF  01,62A
02AF8:  MOVLB  0
02AFA:  CALL   1F18
02AFE:  MOVFF  02,03
02B02:  MOVF   01,W
02B04:  BNZ   2B12
02B06:  MOVF   03,F
02B08:  BNZ   2B12
02B0A:  MOVLW  02
02B0C:  MOVWF  01
02B0E:  BRA    2BC8
02B10:  BRA    2B58
....................    else arg2 = SERcmd[rec].p[3];
02B12:  MOVLB  6
02B14:  CLRF   x2B
02B16:  MOVFF  5D8,62A
02B1A:  CLRF   x2D
02B1C:  MOVLW  B5
02B1E:  MOVWF  x2C
02B20:  MOVLB  0
02B22:  CALL   0852
02B26:  MOVFF  02,60A
02B2A:  MOVFF  01,609
02B2E:  MOVLW  06
02B30:  MOVLB  6
02B32:  ADDWF  x09,F
02B34:  MOVLW  00
02B36:  ADDWFC x0A,F
02B38:  MOVLW  4B
02B3A:  ADDWF  x09,W
02B3C:  MOVWF  01
02B3E:  MOVLW  00
02B40:  ADDWFC x0A,W
02B42:  MOVWF  03
02B44:  MOVF   01,W
02B46:  ADDLW  55
02B48:  MOVWF  01
02B4A:  MOVLW  01
02B4C:  ADDWFC 03,F
02B4E:  MOVFF  01,5F5
02B52:  MOVFF  03,5F6
02B56:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
02B58:  MOVFF  5F8,62B
02B5C:  MOVFF  5F7,62A
02B60:  MOVFF  5F6,62D
02B64:  MOVFF  5F5,62C
02B68:  CALL   1F50
02B6C:  MOVF   01,F
02B6E:  BNZ   2B8A
02B70:  MOVLW  01
02B72:  MOVLB  5
02B74:  SUBWF  xF4,W
02B76:  MOVLB  6
02B78:  MOVWF  x09
02B7A:  MOVWF  x0B
02B7C:  CLRF   x0C
02B7E:  CLRF   x0E
02B80:  MOVLW  61
02B82:  MOVWF  x0D
02B84:  MOVLB  0
02B86:  RCALL  2646
02B88:  BRA    2BC4
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
02B8A:  MOVFF  601,62B
02B8E:  MOVFF  600,62A
02B92:  MOVFF  5F6,62D
02B96:  MOVFF  5F5,62C
02B9A:  CALL   1F50
02B9E:  MOVF   01,F
02BA0:  BNZ   2BBE
02BA2:  MOVLW  01
02BA4:  MOVLB  5
02BA6:  SUBWF  xF4,W
02BA8:  MOVLB  6
02BAA:  MOVWF  x09
02BAC:  MOVWF  x0B
02BAE:  MOVLW  01
02BB0:  MOVWF  x0C
02BB2:  CLRF   x0E
02BB4:  MOVLW  61
02BB6:  MOVWF  x0D
02BB8:  MOVLB  0
02BBA:  RCALL  2646
02BBC:  BRA    2BC4
....................    else return INV_PARAM;
02BBE:  MOVLW  02
02BC0:  MOVWF  01
02BC2:  BRA    2BC8
....................    
....................    return SUCCESS;
02BC4:  MOVLW  00
02BC6:  MOVWF  01
02BC8:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
02DC0:  MOVLB  6
02DC2:  CLRF   x2B
02DC4:  MOVFF  5D8,62A
02DC8:  CLRF   x2D
02DCA:  MOVLW  B5
02DCC:  MOVWF  x2C
02DCE:  MOVLB  0
02DD0:  CALL   0852
02DD4:  MOVFF  02,5F7
02DD8:  MOVFF  01,5F6
02DDC:  MOVLW  06
02DDE:  MOVLB  5
02DE0:  ADDWF  xF6,F
02DE2:  MOVLW  00
02DE4:  ADDWFC xF7,F
02DE6:  MOVLW  32
02DE8:  ADDWF  xF6,W
02DEA:  MOVWF  01
02DEC:  MOVLW  00
02DEE:  ADDWFC xF7,W
02DF0:  MOVWF  03
02DF2:  MOVF   01,W
02DF4:  ADDLW  55
02DF6:  MOVWF  01
02DF8:  MOVLW  01
02DFA:  ADDWFC 03,F
02DFC:  MOVFF  01,5F6
02E00:  MOVFF  03,5F7
02E04:  MOVFF  03,61D
02E08:  MOVFF  01,61C
02E0C:  MOVLB  0
02E0E:  CALL   2090
02E12:  MOVF   01,F
02E14:  BNZ   2E1E
02E16:  MOVLW  02
02E18:  MOVWF  01
02E1A:  BRA    30A6
02E1C:  BRA    2E7E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
02E1E:  MOVLB  6
02E20:  CLRF   x2B
02E22:  MOVFF  5D8,62A
02E26:  CLRF   x2D
02E28:  MOVLW  B5
02E2A:  MOVWF  x2C
02E2C:  MOVLB  0
02E2E:  CALL   0852
02E32:  MOVFF  02,5F7
02E36:  MOVFF  01,5F6
02E3A:  MOVLW  06
02E3C:  MOVLB  5
02E3E:  ADDWF  xF6,F
02E40:  MOVLW  00
02E42:  ADDWFC xF7,F
02E44:  MOVLW  32
02E46:  ADDWF  xF6,W
02E48:  MOVWF  01
02E4A:  MOVLW  00
02E4C:  ADDWFC xF7,W
02E4E:  MOVWF  03
02E50:  MOVF   01,W
02E52:  ADDLW  55
02E54:  MOVWF  01
02E56:  MOVLW  01
02E58:  ADDWFC 03,F
02E5A:  MOVFF  01,5F6
02E5E:  MOVFF  03,5F7
02E62:  MOVFF  03,61D
02E66:  MOVFF  01,61C
02E6A:  MOVLB  6
02E6C:  CLRF   x1F
02E6E:  CLRF   x1E
02E70:  MOVLW  0A
02E72:  MOVWF  x20
02E74:  MOVLB  0
02E76:  CALL   2180
02E7A:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
02E7E:  MOVLB  6
02E80:  CLRF   x2B
02E82:  MOVFF  5D8,62A
02E86:  CLRF   x2D
02E88:  MOVLW  B5
02E8A:  MOVWF  x2C
02E8C:  MOVLB  0
02E8E:  CALL   0852
02E92:  MOVFF  02,5F7
02E96:  MOVFF  01,5F6
02E9A:  MOVLW  06
02E9C:  MOVLB  5
02E9E:  ADDWF  xF6,F
02EA0:  MOVLW  00
02EA2:  ADDWFC xF7,F
02EA4:  MOVLW  4B
02EA6:  ADDWF  xF6,W
02EA8:  MOVWF  01
02EAA:  MOVLW  00
02EAC:  ADDWFC xF7,W
02EAE:  MOVWF  03
02EB0:  MOVF   01,W
02EB2:  ADDLW  55
02EB4:  MOVWF  01
02EB6:  MOVLW  01
02EB8:  ADDWFC 03,F
02EBA:  MOVFF  01,5F6
02EBE:  MOVFF  03,5F7
02EC2:  MOVFF  03,62B
02EC6:  MOVFF  01,62A
02ECA:  MOVLB  0
02ECC:  CALL   1F18
02ED0:  MOVFF  02,03
02ED4:  MOVF   01,W
02ED6:  SUBLW  01
02ED8:  BNZ   2EDE
02EDA:  MOVF   03,F
02EDC:  BZ    2EE6
02EDE:  MOVLW  02
02EE0:  MOVWF  01
02EE2:  BRA    30A6
02EE4:  BRA    2F26
....................    else arg2 = SERcmd[rec].p[3][0];
02EE6:  MOVLB  6
02EE8:  CLRF   x2B
02EEA:  MOVFF  5D8,62A
02EEE:  CLRF   x2D
02EF0:  MOVLW  B5
02EF2:  MOVWF  x2C
02EF4:  MOVLB  0
02EF6:  CALL   0852
02EFA:  MOVFF  02,5F7
02EFE:  MOVFF  01,5F6
02F02:  MOVLW  06
02F04:  MOVLB  5
02F06:  ADDWF  xF6,F
02F08:  MOVLW  00
02F0A:  ADDWFC xF7,F
02F0C:  MOVLW  4B
02F0E:  ADDWF  xF6,F
02F10:  MOVLW  00
02F12:  ADDWFC xF7,F
02F14:  MOVLW  55
02F16:  ADDWF  xF6,W
02F18:  MOVWF  FE9
02F1A:  MOVLW  01
02F1C:  ADDWFC xF7,W
02F1E:  MOVWF  FEA
02F20:  MOVFF  FEF,5F5
02F24:  MOVLB  0
....................    
....................    /*** GET P, I, or D VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kP);
02F26:  MOVLB  5
02F28:  MOVF   xF5,W
02F2A:  SUBLW  50
02F2C:  BNZ   2F9E
02F2E:  MOVLW  04
02F30:  MOVLB  6
02F32:  MOVWF  x2B
02F34:  MOVLW  2B
02F36:  MOVWF  x2A
02F38:  MOVLB  0
02F3A:  CALL   1F18
02F3E:  MOVFF  02,03
02F42:  MOVF   01,W
02F44:  ADDLW  2B
02F46:  MOVLB  5
02F48:  MOVWF  xF6
02F4A:  MOVLW  04
02F4C:  ADDWFC 02,W
02F4E:  MOVWF  xF7
02F50:  MOVLW  01
02F52:  SUBWF  xF4,W
02F54:  MULLW  20
02F56:  MOVF   FF3,W
02F58:  CLRF   xF9
02F5A:  MOVWF  xF8
02F5C:  MOVLW  20
02F5E:  ADDWF  xF8,W
02F60:  MOVWF  FE9
02F62:  MOVLW  00
02F64:  ADDWFC xF9,W
02F66:  MOVWF  FEA
02F68:  MOVFF  FEF,620
02F6C:  MOVFF  FEC,621
02F70:  MOVFF  FEC,622
02F74:  MOVFF  FEC,623
02F78:  MOVFF  5F7,4D0
02F7C:  MOVFF  5F6,4CF
02F80:  MOVLW  89
02F82:  MOVWF  FE9
02F84:  MOVLW  02
02F86:  MOVLB  6
02F88:  MOVWF  x24
02F8A:  MOVLB  0
02F8C:  RCALL  2C0C
02F8E:  MOVLW  2C
02F90:  MOVLB  6
02F92:  MOVWF  x35
02F94:  MOVLB  0
02F96:  CALL   1FC8
02F9A:  BRA    30A2
02F9C:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kI);
02F9E:  MOVF   xF5,W
02FA0:  SUBLW  49
02FA2:  BNZ   301C
02FA4:  MOVLW  04
02FA6:  MOVLB  6
02FA8:  MOVWF  x2B
02FAA:  MOVLW  2B
02FAC:  MOVWF  x2A
02FAE:  MOVLB  0
02FB0:  CALL   1F18
02FB4:  MOVF   01,W
02FB6:  ADDLW  2B
02FB8:  MOVLB  5
02FBA:  MOVWF  xF6
02FBC:  MOVLW  04
02FBE:  ADDWFC 02,W
02FC0:  MOVWF  xF7
02FC2:  MOVLW  01
02FC4:  SUBWF  xF4,W
02FC6:  MULLW  20
02FC8:  MOVF   FF3,W
02FCA:  CLRF   xF9
02FCC:  MOVWF  xF8
02FCE:  MOVLW  04
02FD0:  ADDWF  xF8,W
02FD2:  MOVWF  01
02FD4:  MOVLW  00
02FD6:  ADDWFC xF9,W
02FD8:  MOVWF  03
02FDA:  MOVF   01,W
02FDC:  ADDLW  20
02FDE:  MOVWF  FE9
02FE0:  MOVLW  00
02FE2:  ADDWFC 03,W
02FE4:  MOVWF  FEA
02FE6:  MOVFF  FEF,620
02FEA:  MOVFF  FEC,621
02FEE:  MOVFF  FEC,622
02FF2:  MOVFF  FEC,623
02FF6:  MOVFF  5F7,4D0
02FFA:  MOVFF  5F6,4CF
02FFE:  MOVLW  89
03000:  MOVWF  FE9
03002:  MOVLW  02
03004:  MOVLB  6
03006:  MOVWF  x24
03008:  MOVLB  0
0300A:  RCALL  2C0C
0300C:  MOVLW  2C
0300E:  MOVLB  6
03010:  MOVWF  x35
03012:  MOVLB  0
03014:  CALL   1FC8
03018:  BRA    30A2
0301A:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kD);
0301C:  MOVF   xF5,W
0301E:  SUBLW  44
03020:  BNZ   309A
03022:  MOVLW  04
03024:  MOVLB  6
03026:  MOVWF  x2B
03028:  MOVLW  2B
0302A:  MOVWF  x2A
0302C:  MOVLB  0
0302E:  CALL   1F18
03032:  MOVF   01,W
03034:  ADDLW  2B
03036:  MOVLB  5
03038:  MOVWF  xF6
0303A:  MOVLW  04
0303C:  ADDWFC 02,W
0303E:  MOVWF  xF7
03040:  MOVLW  01
03042:  SUBWF  xF4,W
03044:  MULLW  20
03046:  MOVF   FF3,W
03048:  CLRF   xF9
0304A:  MOVWF  xF8
0304C:  MOVLW  08
0304E:  ADDWF  xF8,W
03050:  MOVWF  01
03052:  MOVLW  00
03054:  ADDWFC xF9,W
03056:  MOVWF  03
03058:  MOVF   01,W
0305A:  ADDLW  20
0305C:  MOVWF  FE9
0305E:  MOVLW  00
03060:  ADDWFC 03,W
03062:  MOVWF  FEA
03064:  MOVFF  FEF,620
03068:  MOVFF  FEC,621
0306C:  MOVFF  FEC,622
03070:  MOVFF  FEC,623
03074:  MOVFF  5F7,4D0
03078:  MOVFF  5F6,4CF
0307C:  MOVLW  89
0307E:  MOVWF  FE9
03080:  MOVLW  02
03082:  MOVLB  6
03084:  MOVWF  x24
03086:  MOVLB  0
03088:  RCALL  2C0C
0308A:  MOVLW  2C
0308C:  MOVLB  6
0308E:  MOVWF  x35
03090:  MOVLB  0
03092:  CALL   1FC8
03096:  BRA    30A2
03098:  MOVLB  5
....................    else return INV_PARAM;
0309A:  MOVLW  02
0309C:  MOVWF  01
0309E:  MOVLB  0
030A0:  BRA    30A6
....................    
....................    return SUCCESS;
030A2:  MOVLW  00
030A4:  MOVWF  01
030A6:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
03550:  MOVLB  6
03552:  CLRF   x2B
03554:  MOVFF  5D8,62A
03558:  CLRF   x2D
0355A:  MOVLW  B5
0355C:  MOVWF  x2C
0355E:  MOVLB  0
03560:  CALL   0852
03564:  MOVFF  02,5FB
03568:  MOVFF  01,5FA
0356C:  MOVLW  06
0356E:  MOVLB  5
03570:  ADDWF  xFA,F
03572:  MOVLW  00
03574:  ADDWFC xFB,F
03576:  MOVLW  32
03578:  ADDWF  xFA,W
0357A:  MOVWF  01
0357C:  MOVLW  00
0357E:  ADDWFC xFB,W
03580:  MOVWF  03
03582:  MOVF   01,W
03584:  ADDLW  55
03586:  MOVWF  01
03588:  MOVLW  01
0358A:  ADDWFC 03,F
0358C:  MOVFF  01,5FA
03590:  MOVFF  03,5FB
03594:  MOVFF  03,61D
03598:  MOVFF  01,61C
0359C:  MOVLB  0
0359E:  CALL   2090
035A2:  MOVF   01,F
035A4:  BNZ   35AE
035A6:  MOVLW  02
035A8:  MOVWF  01
035AA:  BRA    3862
035AC:  BRA    360E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
035AE:  MOVLB  6
035B0:  CLRF   x2B
035B2:  MOVFF  5D8,62A
035B6:  CLRF   x2D
035B8:  MOVLW  B5
035BA:  MOVWF  x2C
035BC:  MOVLB  0
035BE:  CALL   0852
035C2:  MOVFF  02,5FB
035C6:  MOVFF  01,5FA
035CA:  MOVLW  06
035CC:  MOVLB  5
035CE:  ADDWF  xFA,F
035D0:  MOVLW  00
035D2:  ADDWFC xFB,F
035D4:  MOVLW  32
035D6:  ADDWF  xFA,W
035D8:  MOVWF  01
035DA:  MOVLW  00
035DC:  ADDWFC xFB,W
035DE:  MOVWF  03
035E0:  MOVF   01,W
035E2:  ADDLW  55
035E4:  MOVWF  01
035E6:  MOVLW  01
035E8:  ADDWFC 03,F
035EA:  MOVFF  01,5FA
035EE:  MOVFF  03,5FB
035F2:  MOVFF  03,61D
035F6:  MOVFF  01,61C
035FA:  MOVLB  6
035FC:  CLRF   x1F
035FE:  CLRF   x1E
03600:  MOVLW  0A
03602:  MOVWF  x20
03604:  MOVLB  0
03606:  CALL   2180
0360A:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0360E:  MOVLB  6
03610:  CLRF   x2B
03612:  MOVFF  5D8,62A
03616:  CLRF   x2D
03618:  MOVLW  B5
0361A:  MOVWF  x2C
0361C:  MOVLB  0
0361E:  CALL   0852
03622:  MOVFF  02,5FB
03626:  MOVFF  01,5FA
0362A:  MOVLW  06
0362C:  MOVLB  5
0362E:  ADDWF  xFA,F
03630:  MOVLW  00
03632:  ADDWFC xFB,F
03634:  MOVLW  4B
03636:  ADDWF  xFA,W
03638:  MOVWF  01
0363A:  MOVLW  00
0363C:  ADDWFC xFB,W
0363E:  MOVWF  03
03640:  MOVF   01,W
03642:  ADDLW  55
03644:  MOVWF  01
03646:  MOVLW  01
03648:  ADDWFC 03,F
0364A:  MOVFF  01,5FA
0364E:  MOVFF  03,5FB
03652:  MOVFF  03,62B
03656:  MOVFF  01,62A
0365A:  MOVLB  0
0365C:  CALL   1F18
03660:  MOVFF  02,03
03664:  MOVF   01,W
03666:  SUBLW  01
03668:  BNZ   366E
0366A:  MOVF   03,F
0366C:  BZ    3676
0366E:  MOVLW  02
03670:  MOVWF  01
03672:  BRA    3862
03674:  BRA    36B6
....................    else arg2 = SERcmd[rec].p[3][0];
03676:  MOVLB  6
03678:  CLRF   x2B
0367A:  MOVFF  5D8,62A
0367E:  CLRF   x2D
03680:  MOVLW  B5
03682:  MOVWF  x2C
03684:  MOVLB  0
03686:  CALL   0852
0368A:  MOVFF  02,5FB
0368E:  MOVFF  01,5FA
03692:  MOVLW  06
03694:  MOVLB  5
03696:  ADDWF  xFA,F
03698:  MOVLW  00
0369A:  ADDWFC xFB,F
0369C:  MOVLW  4B
0369E:  ADDWF  xFA,F
036A0:  MOVLW  00
036A2:  ADDWFC xFB,F
036A4:  MOVLW  55
036A6:  ADDWF  xFA,W
036A8:  MOVWF  FE9
036AA:  MOVLW  01
036AC:  ADDWFC xFB,W
036AE:  MOVWF  FEA
036B0:  MOVFF  FEF,5F5
036B4:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
036B6:  MOVLB  6
036B8:  CLRF   x2B
036BA:  MOVFF  5D8,62A
036BE:  CLRF   x2D
036C0:  MOVLW  B5
036C2:  MOVWF  x2C
036C4:  MOVLB  0
036C6:  CALL   0852
036CA:  MOVFF  02,5FB
036CE:  MOVFF  01,5FA
036D2:  MOVLW  06
036D4:  MOVLB  5
036D6:  ADDWF  xFA,F
036D8:  MOVLW  00
036DA:  ADDWFC xFB,F
036DC:  MOVLW  64
036DE:  ADDWF  xFA,W
036E0:  MOVWF  01
036E2:  MOVLW  00
036E4:  ADDWFC xFB,W
036E6:  MOVWF  03
036E8:  MOVF   01,W
036EA:  ADDLW  55
036EC:  MOVWF  01
036EE:  MOVLW  01
036F0:  ADDWFC 03,F
036F2:  MOVFF  01,5FA
036F6:  MOVFF  03,5FB
036FA:  MOVFF  03,5FE
036FE:  MOVFF  01,5FD
03702:  MOVLB  6
03704:  CLRF   x00
03706:  MOVLB  5
03708:  CLRF   xFF
0370A:  MOVLB  0
0370C:  RCALL  3208
0370E:  MOVFF  03,5FE
03712:  MOVFF  02,5FD
03716:  MOVFF  01,5FC
0371A:  MOVFF  00,5FB
0371E:  CALL   13E6
03722:  MOVFF  02,5FB
03726:  MOVFF  01,5FA
0372A:  MOVFF  02,5FE
0372E:  MOVFF  01,5FD
03732:  RCALL  347C
03734:  MOVF   01,F
03736:  BNZ   3740
03738:  MOVLW  02
0373A:  MOVWF  01
0373C:  BRA    3862
0373E:  BRA    37A8
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
03740:  MOVLB  6
03742:  CLRF   x2B
03744:  MOVFF  5D8,62A
03748:  CLRF   x2D
0374A:  MOVLW  B5
0374C:  MOVWF  x2C
0374E:  MOVLB  0
03750:  CALL   0852
03754:  MOVFF  02,5FB
03758:  MOVFF  01,5FA
0375C:  MOVLW  06
0375E:  MOVLB  5
03760:  ADDWF  xFA,F
03762:  MOVLW  00
03764:  ADDWFC xFB,F
03766:  MOVLW  64
03768:  ADDWF  xFA,W
0376A:  MOVWF  01
0376C:  MOVLW  00
0376E:  ADDWFC xFB,W
03770:  MOVWF  03
03772:  MOVF   01,W
03774:  ADDLW  55
03776:  MOVWF  01
03778:  MOVLW  01
0377A:  ADDWFC 03,F
0377C:  MOVFF  01,5FA
03780:  MOVFF  03,5FB
03784:  MOVFF  03,5FE
03788:  MOVFF  01,5FD
0378C:  MOVLB  6
0378E:  CLRF   x00
03790:  MOVLB  5
03792:  CLRF   xFF
03794:  MOVLB  0
03796:  RCALL  3208
03798:  MOVFF  03,5F9
0379C:  MOVFF  02,5F8
037A0:  MOVFF  01,5F7
037A4:  MOVFF  00,5F6
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
037A8:  MOVLB  5
037AA:  MOVF   xF5,W
037AC:  SUBLW  50
037AE:  BNZ   37DA
037B0:  MOVLW  01
037B2:  SUBWF  xF4,W
037B4:  MULLW  20
037B6:  MOVF   FF3,W
037B8:  CLRF   xFB
037BA:  MOVWF  xFA
037BC:  MOVLW  20
037BE:  ADDWF  xFA,W
037C0:  MOVWF  FE9
037C2:  MOVLW  00
037C4:  ADDWFC xFB,W
037C6:  MOVWF  FEA
037C8:  MOVFF  5F6,FEF
037CC:  MOVFF  5F7,FEC
037D0:  MOVFF  5F8,FEC
037D4:  MOVFF  5F9,FEC
037D8:  BRA    385C
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
037DA:  MOVF   xF5,W
037DC:  SUBLW  49
037DE:  BNZ   3816
037E0:  MOVLW  01
037E2:  SUBWF  xF4,W
037E4:  MULLW  20
037E6:  MOVF   FF3,W
037E8:  CLRF   xFB
037EA:  MOVWF  xFA
037EC:  MOVLW  04
037EE:  ADDWF  xFA,W
037F0:  MOVWF  01
037F2:  MOVLW  00
037F4:  ADDWFC xFB,W
037F6:  MOVWF  03
037F8:  MOVF   01,W
037FA:  ADDLW  20
037FC:  MOVWF  FE9
037FE:  MOVLW  00
03800:  ADDWFC 03,W
03802:  MOVWF  FEA
03804:  MOVFF  5F6,FEF
03808:  MOVFF  5F7,FEC
0380C:  MOVFF  5F8,FEC
03810:  MOVFF  5F9,FEC
03814:  BRA    385C
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
03816:  MOVF   xF5,W
03818:  SUBLW  44
0381A:  BNZ   3852
0381C:  MOVLW  01
0381E:  SUBWF  xF4,W
03820:  MULLW  20
03822:  MOVF   FF3,W
03824:  CLRF   xFB
03826:  MOVWF  xFA
03828:  MOVLW  08
0382A:  ADDWF  xFA,W
0382C:  MOVWF  01
0382E:  MOVLW  00
03830:  ADDWFC xFB,W
03832:  MOVWF  03
03834:  MOVF   01,W
03836:  ADDLW  20
03838:  MOVWF  FE9
0383A:  MOVLW  00
0383C:  ADDWFC 03,W
0383E:  MOVWF  FEA
03840:  MOVFF  5F6,FEF
03844:  MOVFF  5F7,FEC
03848:  MOVFF  5F8,FEC
0384C:  MOVFF  5F9,FEC
03850:  BRA    385C
....................    else return INV_PARAM;
03852:  MOVLW  02
03854:  MOVWF  01
03856:  MOVLB  0
03858:  BRA    3862
0385A:  MOVLB  5
....................    
....................    return SUCCESS;
0385C:  MOVLW  00
0385E:  MOVWF  01
03860:  MOVLB  0
03862:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
03864:  MOVLB  6
03866:  CLRF   x2B
03868:  MOVFF  5D8,62A
0386C:  CLRF   x2D
0386E:  MOVLW  B5
03870:  MOVWF  x2C
03872:  MOVLB  0
03874:  CALL   0852
03878:  MOVFF  02,5F6
0387C:  MOVFF  01,5F5
03880:  MOVLW  06
03882:  MOVLB  5
03884:  ADDWF  xF5,F
03886:  MOVLW  00
03888:  ADDWFC xF6,F
0388A:  MOVLW  32
0388C:  ADDWF  xF5,W
0388E:  MOVWF  01
03890:  MOVLW  00
03892:  ADDWFC xF6,W
03894:  MOVWF  03
03896:  MOVF   01,W
03898:  ADDLW  55
0389A:  MOVWF  01
0389C:  MOVLW  01
0389E:  ADDWFC 03,F
038A0:  MOVFF  01,5F5
038A4:  MOVFF  03,5F6
038A8:  MOVFF  03,61D
038AC:  MOVFF  01,61C
038B0:  MOVLB  0
038B2:  CALL   2090
038B6:  MOVF   01,F
038B8:  BNZ   38C2
038BA:  MOVLW  02
038BC:  MOVWF  01
038BE:  BRA    399C
038C0:  BRA    3922
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
038C2:  MOVLB  6
038C4:  CLRF   x2B
038C6:  MOVFF  5D8,62A
038CA:  CLRF   x2D
038CC:  MOVLW  B5
038CE:  MOVWF  x2C
038D0:  MOVLB  0
038D2:  CALL   0852
038D6:  MOVFF  02,5F6
038DA:  MOVFF  01,5F5
038DE:  MOVLW  06
038E0:  MOVLB  5
038E2:  ADDWF  xF5,F
038E4:  MOVLW  00
038E6:  ADDWFC xF6,F
038E8:  MOVLW  32
038EA:  ADDWF  xF5,W
038EC:  MOVWF  01
038EE:  MOVLW  00
038F0:  ADDWFC xF6,W
038F2:  MOVWF  03
038F4:  MOVF   01,W
038F6:  ADDLW  55
038F8:  MOVWF  01
038FA:  MOVLW  01
038FC:  ADDWFC 03,F
038FE:  MOVFF  01,5F5
03902:  MOVFF  03,5F6
03906:  MOVFF  03,61D
0390A:  MOVFF  01,61C
0390E:  MOVLB  6
03910:  CLRF   x1F
03912:  CLRF   x1E
03914:  MOVLW  0A
03916:  MOVWF  x20
03918:  MOVLB  0
0391A:  CALL   2180
0391E:  MOVFF  01,5F4
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%f,", PID[arg1-1].SP);
03922:  MOVLW  04
03924:  MOVLB  6
03926:  MOVWF  x2B
03928:  MOVLW  2B
0392A:  MOVWF  x2A
0392C:  MOVLB  0
0392E:  CALL   1F18
03932:  MOVF   01,W
03934:  ADDLW  2B
03936:  MOVLB  5
03938:  MOVWF  xF5
0393A:  MOVLW  04
0393C:  ADDWFC 02,W
0393E:  MOVWF  xF6
03940:  MOVLW  01
03942:  SUBWF  xF4,W
03944:  MULLW  20
03946:  MOVF   FF3,W
03948:  CLRF   xF8
0394A:  MOVWF  xF7
0394C:  MOVLW  0C
0394E:  ADDWF  xF7,W
03950:  MOVWF  01
03952:  MOVLW  00
03954:  ADDWFC xF8,W
03956:  MOVWF  03
03958:  MOVF   01,W
0395A:  ADDLW  20
0395C:  MOVWF  FE9
0395E:  MOVLW  00
03960:  ADDWFC 03,W
03962:  MOVWF  FEA
03964:  MOVFF  FEF,620
03968:  MOVFF  FEC,621
0396C:  MOVFF  FEC,622
03970:  MOVFF  FEC,623
03974:  MOVFF  5F6,4D0
03978:  MOVFF  5F5,4CF
0397C:  MOVLW  89
0397E:  MOVWF  FE9
03980:  MOVLW  02
03982:  MOVLB  6
03984:  MOVWF  x24
03986:  MOVLB  0
03988:  CALL   2C0C
0398C:  MOVLW  2C
0398E:  MOVLB  6
03990:  MOVWF  x35
03992:  MOVLB  0
03994:  CALL   1FC8
....................    return SUCCESS;
03998:  MOVLW  00
0399A:  MOVWF  01
0399C:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0399E:  MOVLB  6
039A0:  CLRF   x2B
039A2:  MOVFF  5D8,62A
039A6:  CLRF   x2D
039A8:  MOVLW  B5
039AA:  MOVWF  x2C
039AC:  MOVLB  0
039AE:  CALL   0852
039B2:  MOVFF  02,5FA
039B6:  MOVFF  01,5F9
039BA:  MOVLW  06
039BC:  MOVLB  5
039BE:  ADDWF  xF9,F
039C0:  MOVLW  00
039C2:  ADDWFC xFA,F
039C4:  MOVLW  32
039C6:  ADDWF  xF9,W
039C8:  MOVWF  01
039CA:  MOVLW  00
039CC:  ADDWFC xFA,W
039CE:  MOVWF  03
039D0:  MOVF   01,W
039D2:  ADDLW  55
039D4:  MOVWF  01
039D6:  MOVLW  01
039D8:  ADDWFC 03,F
039DA:  MOVFF  01,5F9
039DE:  MOVFF  03,5FA
039E2:  MOVFF  03,61D
039E6:  MOVFF  01,61C
039EA:  MOVLB  0
039EC:  CALL   2090
039F0:  MOVF   01,F
039F2:  BNZ   39FC
039F4:  MOVLW  02
039F6:  MOVWF  01
039F8:  BRA    3B8E
039FA:  BRA    3A5C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
039FC:  MOVLB  6
039FE:  CLRF   x2B
03A00:  MOVFF  5D8,62A
03A04:  CLRF   x2D
03A06:  MOVLW  B5
03A08:  MOVWF  x2C
03A0A:  MOVLB  0
03A0C:  CALL   0852
03A10:  MOVFF  02,5FA
03A14:  MOVFF  01,5F9
03A18:  MOVLW  06
03A1A:  MOVLB  5
03A1C:  ADDWF  xF9,F
03A1E:  MOVLW  00
03A20:  ADDWFC xFA,F
03A22:  MOVLW  32
03A24:  ADDWF  xF9,W
03A26:  MOVWF  01
03A28:  MOVLW  00
03A2A:  ADDWFC xFA,W
03A2C:  MOVWF  03
03A2E:  MOVF   01,W
03A30:  ADDLW  55
03A32:  MOVWF  01
03A34:  MOVLW  01
03A36:  ADDWFC 03,F
03A38:  MOVFF  01,5F9
03A3C:  MOVFF  03,5FA
03A40:  MOVFF  03,61D
03A44:  MOVFF  01,61C
03A48:  MOVLB  6
03A4A:  CLRF   x1F
03A4C:  CLRF   x1E
03A4E:  MOVLW  0A
03A50:  MOVWF  x20
03A52:  MOVLB  0
03A54:  CALL   2180
03A58:  MOVFF  01,5F4
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
03A5C:  MOVLB  6
03A5E:  CLRF   x2B
03A60:  MOVFF  5D8,62A
03A64:  CLRF   x2D
03A66:  MOVLW  B5
03A68:  MOVWF  x2C
03A6A:  MOVLB  0
03A6C:  CALL   0852
03A70:  MOVFF  02,5FA
03A74:  MOVFF  01,5F9
03A78:  MOVLW  06
03A7A:  MOVLB  5
03A7C:  ADDWF  xF9,F
03A7E:  MOVLW  00
03A80:  ADDWFC xFA,F
03A82:  MOVLW  4B
03A84:  ADDWF  xF9,W
03A86:  MOVWF  01
03A88:  MOVLW  00
03A8A:  ADDWFC xFA,W
03A8C:  MOVWF  03
03A8E:  MOVF   01,W
03A90:  ADDLW  55
03A92:  MOVWF  01
03A94:  MOVLW  01
03A96:  ADDWFC 03,F
03A98:  MOVFF  01,5F9
03A9C:  MOVFF  03,5FA
03AA0:  MOVFF  03,5FE
03AA4:  MOVFF  01,5FD
03AA8:  MOVLB  6
03AAA:  CLRF   x00
03AAC:  MOVLB  5
03AAE:  CLRF   xFF
03AB0:  MOVLB  0
03AB2:  CALL   3208
03AB6:  MOVFF  03,5FE
03ABA:  MOVFF  02,5FD
03ABE:  MOVFF  01,5FC
03AC2:  MOVFF  00,5FB
03AC6:  CALL   13E6
03ACA:  MOVFF  02,5FA
03ACE:  MOVFF  01,5F9
03AD2:  MOVFF  02,5FE
03AD6:  MOVFF  01,5FD
03ADA:  RCALL  347C
03ADC:  MOVF   01,F
03ADE:  BNZ   3AE8
03AE0:  MOVLW  02
03AE2:  MOVWF  01
03AE4:  BRA    3B8E
03AE6:  BRA    3B52
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
03AE8:  MOVLB  6
03AEA:  CLRF   x2B
03AEC:  MOVFF  5D8,62A
03AF0:  CLRF   x2D
03AF2:  MOVLW  B5
03AF4:  MOVWF  x2C
03AF6:  MOVLB  0
03AF8:  CALL   0852
03AFC:  MOVFF  02,5FA
03B00:  MOVFF  01,5F9
03B04:  MOVLW  06
03B06:  MOVLB  5
03B08:  ADDWF  xF9,F
03B0A:  MOVLW  00
03B0C:  ADDWFC xFA,F
03B0E:  MOVLW  4B
03B10:  ADDWF  xF9,W
03B12:  MOVWF  01
03B14:  MOVLW  00
03B16:  ADDWFC xFA,W
03B18:  MOVWF  03
03B1A:  MOVF   01,W
03B1C:  ADDLW  55
03B1E:  MOVWF  01
03B20:  MOVLW  01
03B22:  ADDWFC 03,F
03B24:  MOVFF  01,5F9
03B28:  MOVFF  03,5FA
03B2C:  MOVFF  03,5FE
03B30:  MOVFF  01,5FD
03B34:  MOVLB  6
03B36:  CLRF   x00
03B38:  MOVLB  5
03B3A:  CLRF   xFF
03B3C:  MOVLB  0
03B3E:  CALL   3208
03B42:  MOVFF  03,5F8
03B46:  MOVFF  02,5F7
03B4A:  MOVFF  01,5F6
03B4E:  MOVFF  00,5F5
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
03B52:  MOVLW  01
03B54:  MOVLB  5
03B56:  SUBWF  xF4,W
03B58:  MULLW  20
03B5A:  MOVF   FF3,W
03B5C:  CLRF   xFA
03B5E:  MOVWF  xF9
03B60:  MOVLW  0C
03B62:  ADDWF  xF9,W
03B64:  MOVWF  01
03B66:  MOVLW  00
03B68:  ADDWFC xFA,W
03B6A:  MOVWF  03
03B6C:  MOVF   01,W
03B6E:  ADDLW  20
03B70:  MOVWF  FE9
03B72:  MOVLW  00
03B74:  ADDWFC 03,W
03B76:  MOVWF  FEA
03B78:  MOVFF  5F5,FEF
03B7C:  MOVFF  5F6,FEC
03B80:  MOVFF  5F7,FEC
03B84:  MOVFF  5F8,FEC
....................    
....................    return SUCCESS;
03B88:  MOVLW  00
03B8A:  MOVWF  01
03B8C:  MOVLB  0
03B8E:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
03B90:  MOVLB  6
03B92:  CLRF   x2B
03B94:  MOVFF  5D8,62A
03B98:  CLRF   x2D
03B9A:  MOVLW  B5
03B9C:  MOVWF  x2C
03B9E:  MOVLB  0
03BA0:  CALL   0852
03BA4:  MOVFF  02,5F6
03BA8:  MOVFF  01,5F5
03BAC:  MOVLW  06
03BAE:  MOVLB  5
03BB0:  ADDWF  xF5,F
03BB2:  MOVLW  00
03BB4:  ADDWFC xF6,F
03BB6:  MOVLW  32
03BB8:  ADDWF  xF5,W
03BBA:  MOVWF  01
03BBC:  MOVLW  00
03BBE:  ADDWFC xF6,W
03BC0:  MOVWF  03
03BC2:  MOVF   01,W
03BC4:  ADDLW  55
03BC6:  MOVWF  01
03BC8:  MOVLW  01
03BCA:  ADDWFC 03,F
03BCC:  MOVFF  01,5F5
03BD0:  MOVFF  03,5F6
03BD4:  MOVFF  03,61D
03BD8:  MOVFF  01,61C
03BDC:  MOVLB  0
03BDE:  CALL   2090
03BE2:  MOVF   01,F
03BE4:  BNZ   3BEE
03BE6:  MOVLW  02
03BE8:  MOVWF  01
03BEA:  BRA    3F0E
03BEC:  BRA    3C4E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
03BEE:  MOVLB  6
03BF0:  CLRF   x2B
03BF2:  MOVFF  5D8,62A
03BF6:  CLRF   x2D
03BF8:  MOVLW  B5
03BFA:  MOVWF  x2C
03BFC:  MOVLB  0
03BFE:  CALL   0852
03C02:  MOVFF  02,5F6
03C06:  MOVFF  01,5F5
03C0A:  MOVLW  06
03C0C:  MOVLB  5
03C0E:  ADDWF  xF5,F
03C10:  MOVLW  00
03C12:  ADDWFC xF6,F
03C14:  MOVLW  32
03C16:  ADDWF  xF5,W
03C18:  MOVWF  01
03C1A:  MOVLW  00
03C1C:  ADDWFC xF6,W
03C1E:  MOVWF  03
03C20:  MOVF   01,W
03C22:  ADDLW  55
03C24:  MOVWF  01
03C26:  MOVLW  01
03C28:  ADDWFC 03,F
03C2A:  MOVFF  01,5F5
03C2E:  MOVFF  03,5F6
03C32:  MOVFF  03,61D
03C36:  MOVFF  01,61C
03C3A:  MOVLB  6
03C3C:  CLRF   x1F
03C3E:  CLRF   x1E
03C40:  MOVLW  0A
03C42:  MOVWF  x20
03C44:  MOVLB  0
03C46:  CALL   2180
03C4A:  MOVFF  01,5F4
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
03C4E:  MOVLW  04
03C50:  MOVLB  6
03C52:  MOVWF  x2B
03C54:  MOVLW  2B
03C56:  MOVWF  x2A
03C58:  MOVLB  0
03C5A:  CALL   1F18
03C5E:  MOVFF  02,03
03C62:  MOVF   01,W
03C64:  ADDLW  2B
03C66:  MOVLB  5
03C68:  MOVWF  xF5
03C6A:  MOVLW  04
03C6C:  ADDWFC 02,W
03C6E:  MOVWF  xF6
03C70:  MOVLW  01
03C72:  SUBWF  xF4,W
03C74:  MULLW  18
03C76:  MOVF   FF3,W
03C78:  CLRF   xF8
03C7A:  MOVWF  xF7
03C7C:  MOVLW  82
03C7E:  ADDWF  xF7,W
03C80:  MOVWF  FE9
03C82:  MOVLW  00
03C84:  ADDWFC xF8,W
03C86:  MOVWF  FEA
03C88:  MOVFF  FEF,620
03C8C:  MOVFF  FEC,621
03C90:  MOVFF  FEC,622
03C94:  MOVFF  FEC,623
03C98:  MOVFF  5F6,4D0
03C9C:  MOVFF  5F5,4CF
03CA0:  MOVLW  89
03CA2:  MOVWF  FE9
03CA4:  MOVLW  02
03CA6:  MOVLB  6
03CA8:  MOVWF  x24
03CAA:  MOVLB  0
03CAC:  CALL   2C0C
03CB0:  MOVLW  2C
03CB2:  MOVLB  6
03CB4:  MOVWF  x35
03CB6:  MOVLB  0
03CB8:  CALL   1FC8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
03CBC:  MOVLW  04
03CBE:  MOVLB  6
03CC0:  MOVWF  x2B
03CC2:  MOVLW  2B
03CC4:  MOVWF  x2A
03CC6:  MOVLB  0
03CC8:  CALL   1F18
03CCC:  MOVF   01,W
03CCE:  ADDLW  2B
03CD0:  MOVLB  5
03CD2:  MOVWF  xF5
03CD4:  MOVLW  04
03CD6:  ADDWFC 02,W
03CD8:  MOVWF  xF6
03CDA:  MOVLW  01
03CDC:  SUBWF  xF4,W
03CDE:  MULLW  18
03CE0:  MOVF   FF3,W
03CE2:  CLRF   xF8
03CE4:  MOVWF  xF7
03CE6:  MOVLW  04
03CE8:  ADDWF  xF7,W
03CEA:  MOVWF  01
03CEC:  MOVLW  00
03CEE:  ADDWFC xF8,W
03CF0:  MOVWF  03
03CF2:  MOVF   01,W
03CF4:  ADDLW  82
03CF6:  MOVWF  FE9
03CF8:  MOVLW  00
03CFA:  ADDWFC 03,W
03CFC:  MOVWF  FEA
03CFE:  MOVFF  FEF,620
03D02:  MOVFF  FEC,621
03D06:  MOVFF  FEC,622
03D0A:  MOVFF  FEC,623
03D0E:  MOVFF  5F6,4D0
03D12:  MOVFF  5F5,4CF
03D16:  MOVLW  89
03D18:  MOVWF  FE9
03D1A:  MOVLW  02
03D1C:  MOVLB  6
03D1E:  MOVWF  x24
03D20:  MOVLB  0
03D22:  CALL   2C0C
03D26:  MOVLW  2C
03D28:  MOVLB  6
03D2A:  MOVWF  x35
03D2C:  MOVLB  0
03D2E:  CALL   1FC8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
03D32:  MOVLW  04
03D34:  MOVLB  6
03D36:  MOVWF  x2B
03D38:  MOVLW  2B
03D3A:  MOVWF  x2A
03D3C:  MOVLB  0
03D3E:  CALL   1F18
03D42:  MOVF   01,W
03D44:  ADDLW  2B
03D46:  MOVLB  5
03D48:  MOVWF  xF5
03D4A:  MOVLW  04
03D4C:  ADDWFC 02,W
03D4E:  MOVWF  xF6
03D50:  MOVLW  01
03D52:  SUBWF  xF4,W
03D54:  MULLW  18
03D56:  MOVF   FF3,W
03D58:  CLRF   xF8
03D5A:  MOVWF  xF7
03D5C:  MOVLW  08
03D5E:  ADDWF  xF7,W
03D60:  MOVWF  01
03D62:  MOVLW  00
03D64:  ADDWFC xF8,W
03D66:  MOVWF  03
03D68:  MOVF   01,W
03D6A:  ADDLW  82
03D6C:  MOVWF  FE9
03D6E:  MOVLW  00
03D70:  ADDWFC 03,W
03D72:  MOVWF  FEA
03D74:  MOVFF  FEF,620
03D78:  MOVFF  FEC,621
03D7C:  MOVFF  FEC,622
03D80:  MOVFF  FEC,623
03D84:  MOVFF  5F6,4D0
03D88:  MOVFF  5F5,4CF
03D8C:  MOVLW  89
03D8E:  MOVWF  FE9
03D90:  MOVLW  02
03D92:  MOVLB  6
03D94:  MOVWF  x24
03D96:  MOVLB  0
03D98:  CALL   2C0C
03D9C:  MOVLW  2C
03D9E:  MOVLB  6
03DA0:  MOVWF  x35
03DA2:  MOVLB  0
03DA4:  CALL   1FC8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
03DA8:  MOVLW  04
03DAA:  MOVLB  6
03DAC:  MOVWF  x2B
03DAE:  MOVLW  2B
03DB0:  MOVWF  x2A
03DB2:  MOVLB  0
03DB4:  CALL   1F18
03DB8:  MOVF   01,W
03DBA:  ADDLW  2B
03DBC:  MOVLB  5
03DBE:  MOVWF  xF5
03DC0:  MOVLW  04
03DC2:  ADDWFC 02,W
03DC4:  MOVWF  xF6
03DC6:  MOVLW  01
03DC8:  SUBWF  xF4,W
03DCA:  MULLW  18
03DCC:  MOVF   FF3,W
03DCE:  CLRF   xF8
03DD0:  MOVWF  xF7
03DD2:  MOVLW  0C
03DD4:  ADDWF  xF7,W
03DD6:  MOVWF  01
03DD8:  MOVLW  00
03DDA:  ADDWFC xF8,W
03DDC:  MOVWF  03
03DDE:  MOVF   01,W
03DE0:  ADDLW  82
03DE2:  MOVWF  FE9
03DE4:  MOVLW  00
03DE6:  ADDWFC 03,W
03DE8:  MOVWF  FEA
03DEA:  MOVFF  FEF,620
03DEE:  MOVFF  FEC,621
03DF2:  MOVFF  FEC,622
03DF6:  MOVFF  FEC,623
03DFA:  MOVFF  5F6,4D0
03DFE:  MOVFF  5F5,4CF
03E02:  MOVLW  89
03E04:  MOVWF  FE9
03E06:  MOVLW  02
03E08:  MOVLB  6
03E0A:  MOVWF  x24
03E0C:  MOVLB  0
03E0E:  CALL   2C0C
03E12:  MOVLW  2C
03E14:  MOVLB  6
03E16:  MOVWF  x35
03E18:  MOVLB  0
03E1A:  CALL   1FC8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
03E1E:  MOVLW  04
03E20:  MOVLB  6
03E22:  MOVWF  x2B
03E24:  MOVLW  2B
03E26:  MOVWF  x2A
03E28:  MOVLB  0
03E2A:  CALL   1F18
03E2E:  MOVF   01,W
03E30:  ADDLW  2B
03E32:  MOVLB  5
03E34:  MOVWF  xF5
03E36:  MOVLW  04
03E38:  ADDWFC 02,W
03E3A:  MOVWF  xF6
03E3C:  MOVLW  01
03E3E:  SUBWF  xF4,W
03E40:  MULLW  18
03E42:  MOVF   FF3,W
03E44:  CLRF   xF8
03E46:  MOVWF  xF7
03E48:  MOVLW  10
03E4A:  ADDWF  xF7,W
03E4C:  MOVWF  01
03E4E:  MOVLW  00
03E50:  ADDWFC xF8,W
03E52:  MOVWF  03
03E54:  MOVF   01,W
03E56:  ADDLW  82
03E58:  MOVWF  FE9
03E5A:  MOVLW  00
03E5C:  ADDWFC 03,W
03E5E:  MOVWF  FEA
03E60:  MOVFF  FEF,620
03E64:  MOVFF  FEC,621
03E68:  MOVFF  FEC,622
03E6C:  MOVFF  FEC,623
03E70:  MOVFF  5F6,4D0
03E74:  MOVFF  5F5,4CF
03E78:  MOVLW  89
03E7A:  MOVWF  FE9
03E7C:  MOVLW  02
03E7E:  MOVLB  6
03E80:  MOVWF  x24
03E82:  MOVLB  0
03E84:  CALL   2C0C
03E88:  MOVLW  2C
03E8A:  MOVLB  6
03E8C:  MOVWF  x35
03E8E:  MOVLB  0
03E90:  CALL   1FC8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
03E94:  MOVLW  04
03E96:  MOVLB  6
03E98:  MOVWF  x2B
03E9A:  MOVLW  2B
03E9C:  MOVWF  x2A
03E9E:  MOVLB  0
03EA0:  CALL   1F18
03EA4:  MOVF   01,W
03EA6:  ADDLW  2B
03EA8:  MOVLB  5
03EAA:  MOVWF  xF5
03EAC:  MOVLW  04
03EAE:  ADDWFC 02,W
03EB0:  MOVWF  xF6
03EB2:  MOVLW  01
03EB4:  SUBWF  xF4,W
03EB6:  MULLW  18
03EB8:  MOVF   FF3,W
03EBA:  CLRF   xF8
03EBC:  MOVWF  xF7
03EBE:  MOVLW  14
03EC0:  ADDWF  xF7,W
03EC2:  MOVWF  01
03EC4:  MOVLW  00
03EC6:  ADDWFC xF8,W
03EC8:  MOVWF  03
03ECA:  MOVF   01,W
03ECC:  ADDLW  82
03ECE:  MOVWF  FE9
03ED0:  MOVLW  00
03ED2:  ADDWFC 03,W
03ED4:  MOVWF  FEA
03ED6:  MOVFF  FEF,620
03EDA:  MOVFF  FEC,621
03EDE:  MOVFF  FEC,622
03EE2:  MOVFF  FEC,623
03EE6:  MOVFF  5F6,4D0
03EEA:  MOVFF  5F5,4CF
03EEE:  MOVLW  89
03EF0:  MOVWF  FE9
03EF2:  MOVLW  02
03EF4:  MOVLB  6
03EF6:  MOVWF  x24
03EF8:  MOVLB  0
03EFA:  CALL   2C0C
03EFE:  MOVLW  2C
03F00:  MOVLB  6
03F02:  MOVWF  x35
03F04:  MOVLB  0
03F06:  CALL   1FC8
....................    
....................    return SUCCESS;
03F0A:  MOVLW  00
03F0C:  MOVWF  01
03F0E:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
03F10:  MOVLB  6
03F12:  CLRF   x2B
03F14:  MOVFF  5D8,62A
03F18:  CLRF   x2D
03F1A:  MOVLW  B5
03F1C:  MOVWF  x2C
03F1E:  MOVLB  0
03F20:  CALL   0852
03F24:  MOVFF  02,5F7
03F28:  MOVFF  01,5F6
03F2C:  MOVLW  06
03F2E:  MOVLB  5
03F30:  ADDWF  xF6,F
03F32:  MOVLW  00
03F34:  ADDWFC xF7,F
03F36:  MOVLW  32
03F38:  ADDWF  xF6,W
03F3A:  MOVWF  01
03F3C:  MOVLW  00
03F3E:  ADDWFC xF7,W
03F40:  MOVWF  03
03F42:  MOVF   01,W
03F44:  ADDLW  55
03F46:  MOVWF  01
03F48:  MOVLW  01
03F4A:  ADDWFC 03,F
03F4C:  MOVFF  01,5F6
03F50:  MOVFF  03,5F7
03F54:  MOVFF  03,61D
03F58:  MOVFF  01,61C
03F5C:  MOVLB  0
03F5E:  CALL   2090
03F62:  MOVF   01,F
03F64:  BNZ   3F6E
03F66:  MOVLW  02
03F68:  MOVWF  01
03F6A:  BRA    437C
03F6C:  BRA    3FCE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
03F6E:  MOVLB  6
03F70:  CLRF   x2B
03F72:  MOVFF  5D8,62A
03F76:  CLRF   x2D
03F78:  MOVLW  B5
03F7A:  MOVWF  x2C
03F7C:  MOVLB  0
03F7E:  CALL   0852
03F82:  MOVFF  02,5F7
03F86:  MOVFF  01,5F6
03F8A:  MOVLW  06
03F8C:  MOVLB  5
03F8E:  ADDWF  xF6,F
03F90:  MOVLW  00
03F92:  ADDWFC xF7,F
03F94:  MOVLW  32
03F96:  ADDWF  xF6,W
03F98:  MOVWF  01
03F9A:  MOVLW  00
03F9C:  ADDWFC xF7,W
03F9E:  MOVWF  03
03FA0:  MOVF   01,W
03FA2:  ADDLW  55
03FA4:  MOVWF  01
03FA6:  MOVLW  01
03FA8:  ADDWFC 03,F
03FAA:  MOVFF  01,5F6
03FAE:  MOVFF  03,5F7
03FB2:  MOVFF  03,61D
03FB6:  MOVFF  01,61C
03FBA:  MOVLB  6
03FBC:  CLRF   x1F
03FBE:  CLRF   x1E
03FC0:  MOVLW  0A
03FC2:  MOVWF  x20
03FC4:  MOVLB  0
03FC6:  CALL   2180
03FCA:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
03FCE:  MOVLB  6
03FD0:  CLRF   x2B
03FD2:  MOVFF  5D8,62A
03FD6:  CLRF   x2D
03FD8:  MOVLW  B5
03FDA:  MOVWF  x2C
03FDC:  MOVLB  0
03FDE:  CALL   0852
03FE2:  MOVFF  02,5F7
03FE6:  MOVFF  01,5F6
03FEA:  MOVLW  06
03FEC:  MOVLB  5
03FEE:  ADDWF  xF6,F
03FF0:  MOVLW  00
03FF2:  ADDWFC xF7,F
03FF4:  MOVLW  4B
03FF6:  ADDWF  xF6,W
03FF8:  MOVWF  01
03FFA:  MOVLW  00
03FFC:  ADDWFC xF7,W
03FFE:  MOVWF  03
04000:  MOVF   01,W
04002:  ADDLW  55
04004:  MOVWF  01
04006:  MOVLW  01
04008:  ADDWFC 03,F
0400A:  MOVFF  01,5F6
0400E:  MOVFF  03,5F7
04012:  MOVFF  03,62B
04016:  MOVFF  01,62A
0401A:  MOVLB  0
0401C:  CALL   1F18
04020:  MOVFF  02,03
04024:  MOVF   01,W
04026:  SUBLW  01
04028:  BNZ   402E
0402A:  MOVF   03,F
0402C:  BZ    4036
0402E:  MOVLW  02
04030:  MOVWF  01
04032:  BRA    437C
04034:  BRA    4076
....................    else arg2 = SERcmd[rec].p[3][0];
04036:  MOVLB  6
04038:  CLRF   x2B
0403A:  MOVFF  5D8,62A
0403E:  CLRF   x2D
04040:  MOVLW  B5
04042:  MOVWF  x2C
04044:  MOVLB  0
04046:  CALL   0852
0404A:  MOVFF  02,5F7
0404E:  MOVFF  01,5F6
04052:  MOVLW  06
04054:  MOVLB  5
04056:  ADDWF  xF6,F
04058:  MOVLW  00
0405A:  ADDWFC xF7,F
0405C:  MOVLW  4B
0405E:  ADDWF  xF6,F
04060:  MOVLW  00
04062:  ADDWFC xF7,F
04064:  MOVLW  55
04066:  ADDWF  xF6,W
04068:  MOVWF  FE9
0406A:  MOVLW  01
0406C:  ADDWFC xF7,W
0406E:  MOVWF  FEA
04070:  MOVFF  FEF,5F5
04074:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
04076:  MOVLB  5
04078:  MOVF   xF5,W
0407A:  SUBLW  30
0407C:  BNZ   40F0
0407E:  MOVLW  04
04080:  MOVLB  6
04082:  MOVWF  x2B
04084:  MOVLW  2B
04086:  MOVWF  x2A
04088:  MOVLB  0
0408A:  CALL   1F18
0408E:  MOVFF  02,03
04092:  MOVF   01,W
04094:  ADDLW  2B
04096:  MOVLB  5
04098:  MOVWF  xF6
0409A:  MOVLW  04
0409C:  ADDWFC 02,W
0409E:  MOVWF  xF7
040A0:  MOVLW  01
040A2:  SUBWF  xF4,W
040A4:  MULLW  18
040A6:  MOVF   FF3,W
040A8:  CLRF   xF9
040AA:  MOVWF  xF8
040AC:  MOVLW  82
040AE:  ADDWF  xF8,W
040B0:  MOVWF  FE9
040B2:  MOVLW  00
040B4:  ADDWFC xF9,W
040B6:  MOVWF  FEA
040B8:  MOVFF  FEF,620
040BC:  MOVFF  FEC,621
040C0:  MOVFF  FEC,622
040C4:  MOVFF  FEC,623
040C8:  MOVFF  5F7,4D0
040CC:  MOVFF  5F6,4CF
040D0:  MOVLW  89
040D2:  MOVWF  FE9
040D4:  MOVLW  02
040D6:  MOVLB  6
040D8:  MOVWF  x24
040DA:  MOVLB  0
040DC:  CALL   2C0C
040E0:  MOVLW  2C
040E2:  MOVLB  6
040E4:  MOVWF  x35
040E6:  MOVLB  0
040E8:  CALL   1FC8
040EC:  BRA    4378
040EE:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
040F0:  MOVF   xF5,W
040F2:  SUBLW  31
040F4:  BNZ   4170
040F6:  MOVLW  04
040F8:  MOVLB  6
040FA:  MOVWF  x2B
040FC:  MOVLW  2B
040FE:  MOVWF  x2A
04100:  MOVLB  0
04102:  CALL   1F18
04106:  MOVF   01,W
04108:  ADDLW  2B
0410A:  MOVLB  5
0410C:  MOVWF  xF6
0410E:  MOVLW  04
04110:  ADDWFC 02,W
04112:  MOVWF  xF7
04114:  MOVLW  01
04116:  SUBWF  xF4,W
04118:  MULLW  18
0411A:  MOVF   FF3,W
0411C:  CLRF   xF9
0411E:  MOVWF  xF8
04120:  MOVLW  04
04122:  ADDWF  xF8,W
04124:  MOVWF  01
04126:  MOVLW  00
04128:  ADDWFC xF9,W
0412A:  MOVWF  03
0412C:  MOVF   01,W
0412E:  ADDLW  82
04130:  MOVWF  FE9
04132:  MOVLW  00
04134:  ADDWFC 03,W
04136:  MOVWF  FEA
04138:  MOVFF  FEF,620
0413C:  MOVFF  FEC,621
04140:  MOVFF  FEC,622
04144:  MOVFF  FEC,623
04148:  MOVFF  5F7,4D0
0414C:  MOVFF  5F6,4CF
04150:  MOVLW  89
04152:  MOVWF  FE9
04154:  MOVLW  02
04156:  MOVLB  6
04158:  MOVWF  x24
0415A:  MOVLB  0
0415C:  CALL   2C0C
04160:  MOVLW  2C
04162:  MOVLB  6
04164:  MOVWF  x35
04166:  MOVLB  0
04168:  CALL   1FC8
0416C:  BRA    4378
0416E:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
04170:  MOVF   xF5,W
04172:  SUBLW  32
04174:  BNZ   41F0
04176:  MOVLW  04
04178:  MOVLB  6
0417A:  MOVWF  x2B
0417C:  MOVLW  2B
0417E:  MOVWF  x2A
04180:  MOVLB  0
04182:  CALL   1F18
04186:  MOVF   01,W
04188:  ADDLW  2B
0418A:  MOVLB  5
0418C:  MOVWF  xF6
0418E:  MOVLW  04
04190:  ADDWFC 02,W
04192:  MOVWF  xF7
04194:  MOVLW  01
04196:  SUBWF  xF4,W
04198:  MULLW  18
0419A:  MOVF   FF3,W
0419C:  CLRF   xF9
0419E:  MOVWF  xF8
041A0:  MOVLW  08
041A2:  ADDWF  xF8,W
041A4:  MOVWF  01
041A6:  MOVLW  00
041A8:  ADDWFC xF9,W
041AA:  MOVWF  03
041AC:  MOVF   01,W
041AE:  ADDLW  82
041B0:  MOVWF  FE9
041B2:  MOVLW  00
041B4:  ADDWFC 03,W
041B6:  MOVWF  FEA
041B8:  MOVFF  FEF,620
041BC:  MOVFF  FEC,621
041C0:  MOVFF  FEC,622
041C4:  MOVFF  FEC,623
041C8:  MOVFF  5F7,4D0
041CC:  MOVFF  5F6,4CF
041D0:  MOVLW  89
041D2:  MOVWF  FE9
041D4:  MOVLW  02
041D6:  MOVLB  6
041D8:  MOVWF  x24
041DA:  MOVLB  0
041DC:  CALL   2C0C
041E0:  MOVLW  2C
041E2:  MOVLB  6
041E4:  MOVWF  x35
041E6:  MOVLB  0
041E8:  CALL   1FC8
041EC:  BRA    4378
041EE:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
041F0:  MOVF   xF5,W
041F2:  SUBLW  33
041F4:  BNZ   4270
041F6:  MOVLW  04
041F8:  MOVLB  6
041FA:  MOVWF  x2B
041FC:  MOVLW  2B
041FE:  MOVWF  x2A
04200:  MOVLB  0
04202:  CALL   1F18
04206:  MOVF   01,W
04208:  ADDLW  2B
0420A:  MOVLB  5
0420C:  MOVWF  xF6
0420E:  MOVLW  04
04210:  ADDWFC 02,W
04212:  MOVWF  xF7
04214:  MOVLW  01
04216:  SUBWF  xF4,W
04218:  MULLW  18
0421A:  MOVF   FF3,W
0421C:  CLRF   xF9
0421E:  MOVWF  xF8
04220:  MOVLW  0C
04222:  ADDWF  xF8,W
04224:  MOVWF  01
04226:  MOVLW  00
04228:  ADDWFC xF9,W
0422A:  MOVWF  03
0422C:  MOVF   01,W
0422E:  ADDLW  82
04230:  MOVWF  FE9
04232:  MOVLW  00
04234:  ADDWFC 03,W
04236:  MOVWF  FEA
04238:  MOVFF  FEF,620
0423C:  MOVFF  FEC,621
04240:  MOVFF  FEC,622
04244:  MOVFF  FEC,623
04248:  MOVFF  5F7,4D0
0424C:  MOVFF  5F6,4CF
04250:  MOVLW  89
04252:  MOVWF  FE9
04254:  MOVLW  02
04256:  MOVLB  6
04258:  MOVWF  x24
0425A:  MOVLB  0
0425C:  CALL   2C0C
04260:  MOVLW  2C
04262:  MOVLB  6
04264:  MOVWF  x35
04266:  MOVLB  0
04268:  CALL   1FC8
0426C:  BRA    4378
0426E:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
04270:  MOVF   xF5,W
04272:  SUBLW  34
04274:  BNZ   42F0
04276:  MOVLW  04
04278:  MOVLB  6
0427A:  MOVWF  x2B
0427C:  MOVLW  2B
0427E:  MOVWF  x2A
04280:  MOVLB  0
04282:  CALL   1F18
04286:  MOVF   01,W
04288:  ADDLW  2B
0428A:  MOVLB  5
0428C:  MOVWF  xF6
0428E:  MOVLW  04
04290:  ADDWFC 02,W
04292:  MOVWF  xF7
04294:  MOVLW  01
04296:  SUBWF  xF4,W
04298:  MULLW  18
0429A:  MOVF   FF3,W
0429C:  CLRF   xF9
0429E:  MOVWF  xF8
042A0:  MOVLW  10
042A2:  ADDWF  xF8,W
042A4:  MOVWF  01
042A6:  MOVLW  00
042A8:  ADDWFC xF9,W
042AA:  MOVWF  03
042AC:  MOVF   01,W
042AE:  ADDLW  82
042B0:  MOVWF  FE9
042B2:  MOVLW  00
042B4:  ADDWFC 03,W
042B6:  MOVWF  FEA
042B8:  MOVFF  FEF,620
042BC:  MOVFF  FEC,621
042C0:  MOVFF  FEC,622
042C4:  MOVFF  FEC,623
042C8:  MOVFF  5F7,4D0
042CC:  MOVFF  5F6,4CF
042D0:  MOVLW  89
042D2:  MOVWF  FE9
042D4:  MOVLW  02
042D6:  MOVLB  6
042D8:  MOVWF  x24
042DA:  MOVLB  0
042DC:  CALL   2C0C
042E0:  MOVLW  2C
042E2:  MOVLB  6
042E4:  MOVWF  x35
042E6:  MOVLB  0
042E8:  CALL   1FC8
042EC:  BRA    4378
042EE:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
042F0:  MOVF   xF5,W
042F2:  SUBLW  35
042F4:  BNZ   4370
042F6:  MOVLW  04
042F8:  MOVLB  6
042FA:  MOVWF  x2B
042FC:  MOVLW  2B
042FE:  MOVWF  x2A
04300:  MOVLB  0
04302:  CALL   1F18
04306:  MOVF   01,W
04308:  ADDLW  2B
0430A:  MOVLB  5
0430C:  MOVWF  xF6
0430E:  MOVLW  04
04310:  ADDWFC 02,W
04312:  MOVWF  xF7
04314:  MOVLW  01
04316:  SUBWF  xF4,W
04318:  MULLW  18
0431A:  MOVF   FF3,W
0431C:  CLRF   xF9
0431E:  MOVWF  xF8
04320:  MOVLW  14
04322:  ADDWF  xF8,W
04324:  MOVWF  01
04326:  MOVLW  00
04328:  ADDWFC xF9,W
0432A:  MOVWF  03
0432C:  MOVF   01,W
0432E:  ADDLW  82
04330:  MOVWF  FE9
04332:  MOVLW  00
04334:  ADDWFC 03,W
04336:  MOVWF  FEA
04338:  MOVFF  FEF,620
0433C:  MOVFF  FEC,621
04340:  MOVFF  FEC,622
04344:  MOVFF  FEC,623
04348:  MOVFF  5F7,4D0
0434C:  MOVFF  5F6,4CF
04350:  MOVLW  89
04352:  MOVWF  FE9
04354:  MOVLW  02
04356:  MOVLB  6
04358:  MOVWF  x24
0435A:  MOVLB  0
0435C:  CALL   2C0C
04360:  MOVLW  2C
04362:  MOVLB  6
04364:  MOVWF  x35
04366:  MOVLB  0
04368:  CALL   1FC8
0436C:  BRA    4378
0436E:  MOVLB  5
....................    else return INV_PARAM;
04370:  MOVLW  02
04372:  MOVWF  01
04374:  MOVLB  0
04376:  BRA    437C
....................    
....................    return SUCCESS;
04378:  MOVLW  00
0437A:  MOVWF  01
0437C:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0437E:  MOVLB  6
04380:  CLRF   x2B
04382:  MOVFF  5D8,62A
04386:  CLRF   x2D
04388:  MOVLW  B5
0438A:  MOVWF  x2C
0438C:  MOVLB  0
0438E:  CALL   0852
04392:  MOVFF  02,5FB
04396:  MOVFF  01,5FA
0439A:  MOVLW  06
0439C:  MOVLB  5
0439E:  ADDWF  xFA,F
043A0:  MOVLW  00
043A2:  ADDWFC xFB,F
043A4:  MOVLW  32
043A6:  ADDWF  xFA,W
043A8:  MOVWF  01
043AA:  MOVLW  00
043AC:  ADDWFC xFB,W
043AE:  MOVWF  03
043B0:  MOVF   01,W
043B2:  ADDLW  55
043B4:  MOVWF  01
043B6:  MOVLW  01
043B8:  ADDWFC 03,F
043BA:  MOVFF  01,5FA
043BE:  MOVFF  03,5FB
043C2:  MOVFF  03,61D
043C6:  MOVFF  01,61C
043CA:  MOVLB  0
043CC:  CALL   2090
043D0:  MOVF   01,F
043D2:  BNZ   43DC
043D4:  MOVLW  02
043D6:  MOVWF  01
043D8:  BRA    474A
043DA:  BRA    443C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
043DC:  MOVLB  6
043DE:  CLRF   x2B
043E0:  MOVFF  5D8,62A
043E4:  CLRF   x2D
043E6:  MOVLW  B5
043E8:  MOVWF  x2C
043EA:  MOVLB  0
043EC:  CALL   0852
043F0:  MOVFF  02,5FB
043F4:  MOVFF  01,5FA
043F8:  MOVLW  06
043FA:  MOVLB  5
043FC:  ADDWF  xFA,F
043FE:  MOVLW  00
04400:  ADDWFC xFB,F
04402:  MOVLW  32
04404:  ADDWF  xFA,W
04406:  MOVWF  01
04408:  MOVLW  00
0440A:  ADDWFC xFB,W
0440C:  MOVWF  03
0440E:  MOVF   01,W
04410:  ADDLW  55
04412:  MOVWF  01
04414:  MOVLW  01
04416:  ADDWFC 03,F
04418:  MOVFF  01,5FA
0441C:  MOVFF  03,5FB
04420:  MOVFF  03,61D
04424:  MOVFF  01,61C
04428:  MOVLB  6
0442A:  CLRF   x1F
0442C:  CLRF   x1E
0442E:  MOVLW  0A
04430:  MOVWF  x20
04432:  MOVLB  0
04434:  CALL   2180
04438:  MOVFF  01,5F4
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0443C:  MOVLB  6
0443E:  CLRF   x2B
04440:  MOVFF  5D8,62A
04444:  CLRF   x2D
04446:  MOVLW  B5
04448:  MOVWF  x2C
0444A:  MOVLB  0
0444C:  CALL   0852
04450:  MOVFF  02,5FB
04454:  MOVFF  01,5FA
04458:  MOVLW  06
0445A:  MOVLB  5
0445C:  ADDWF  xFA,F
0445E:  MOVLW  00
04460:  ADDWFC xFB,F
04462:  MOVLW  4B
04464:  ADDWF  xFA,W
04466:  MOVWF  01
04468:  MOVLW  00
0446A:  ADDWFC xFB,W
0446C:  MOVWF  03
0446E:  MOVF   01,W
04470:  ADDLW  55
04472:  MOVWF  01
04474:  MOVLW  01
04476:  ADDWFC 03,F
04478:  MOVFF  01,5FA
0447C:  MOVFF  03,5FB
04480:  MOVFF  03,62B
04484:  MOVFF  01,62A
04488:  MOVLB  0
0448A:  CALL   1F18
0448E:  MOVFF  02,03
04492:  MOVF   01,W
04494:  SUBLW  01
04496:  BNZ   449C
04498:  MOVF   03,F
0449A:  BZ    44A4
0449C:  MOVLW  02
0449E:  MOVWF  01
044A0:  BRA    474A
044A2:  BRA    44E4
....................    else arg2 = SERcmd[rec].p[3][0];
044A4:  MOVLB  6
044A6:  CLRF   x2B
044A8:  MOVFF  5D8,62A
044AC:  CLRF   x2D
044AE:  MOVLW  B5
044B0:  MOVWF  x2C
044B2:  MOVLB  0
044B4:  CALL   0852
044B8:  MOVFF  02,5FB
044BC:  MOVFF  01,5FA
044C0:  MOVLW  06
044C2:  MOVLB  5
044C4:  ADDWF  xFA,F
044C6:  MOVLW  00
044C8:  ADDWFC xFB,F
044CA:  MOVLW  4B
044CC:  ADDWF  xFA,F
044CE:  MOVLW  00
044D0:  ADDWFC xFB,F
044D2:  MOVLW  55
044D4:  ADDWF  xFA,W
044D6:  MOVWF  FE9
044D8:  MOVLW  01
044DA:  ADDWFC xFB,W
044DC:  MOVWF  FEA
044DE:  MOVFF  FEF,5F5
044E2:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
044E4:  MOVLB  6
044E6:  CLRF   x2B
044E8:  MOVFF  5D8,62A
044EC:  CLRF   x2D
044EE:  MOVLW  B5
044F0:  MOVWF  x2C
044F2:  MOVLB  0
044F4:  CALL   0852
044F8:  MOVFF  02,5FB
044FC:  MOVFF  01,5FA
04500:  MOVLW  06
04502:  MOVLB  5
04504:  ADDWF  xFA,F
04506:  MOVLW  00
04508:  ADDWFC xFB,F
0450A:  MOVLW  64
0450C:  ADDWF  xFA,W
0450E:  MOVWF  01
04510:  MOVLW  00
04512:  ADDWFC xFB,W
04514:  MOVWF  03
04516:  MOVF   01,W
04518:  ADDLW  55
0451A:  MOVWF  01
0451C:  MOVLW  01
0451E:  ADDWFC 03,F
04520:  MOVFF  01,5FA
04524:  MOVFF  03,5FB
04528:  MOVFF  03,5FE
0452C:  MOVFF  01,5FD
04530:  MOVLB  6
04532:  CLRF   x00
04534:  MOVLB  5
04536:  CLRF   xFF
04538:  MOVLB  0
0453A:  CALL   3208
0453E:  MOVFF  03,5FE
04542:  MOVFF  02,5FD
04546:  MOVFF  01,5FC
0454A:  MOVFF  00,5FB
0454E:  CALL   13E6
04552:  MOVFF  02,5FB
04556:  MOVFF  01,5FA
0455A:  MOVFF  02,5FE
0455E:  MOVFF  01,5FD
04562:  CALL   347C
04566:  MOVF   01,F
04568:  BNZ   4572
0456A:  MOVLW  02
0456C:  MOVWF  01
0456E:  BRA    474A
04570:  BRA    45DC
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
04572:  MOVLB  6
04574:  CLRF   x2B
04576:  MOVFF  5D8,62A
0457A:  CLRF   x2D
0457C:  MOVLW  B5
0457E:  MOVWF  x2C
04580:  MOVLB  0
04582:  CALL   0852
04586:  MOVFF  02,5FB
0458A:  MOVFF  01,5FA
0458E:  MOVLW  06
04590:  MOVLB  5
04592:  ADDWF  xFA,F
04594:  MOVLW  00
04596:  ADDWFC xFB,F
04598:  MOVLW  64
0459A:  ADDWF  xFA,W
0459C:  MOVWF  01
0459E:  MOVLW  00
045A0:  ADDWFC xFB,W
045A2:  MOVWF  03
045A4:  MOVF   01,W
045A6:  ADDLW  55
045A8:  MOVWF  01
045AA:  MOVLW  01
045AC:  ADDWFC 03,F
045AE:  MOVFF  01,5FA
045B2:  MOVFF  03,5FB
045B6:  MOVFF  03,5FE
045BA:  MOVFF  01,5FD
045BE:  MOVLB  6
045C0:  CLRF   x00
045C2:  MOVLB  5
045C4:  CLRF   xFF
045C6:  MOVLB  0
045C8:  CALL   3208
045CC:  MOVFF  03,5F9
045D0:  MOVFF  02,5F8
045D4:  MOVFF  01,5F7
045D8:  MOVFF  00,5F6
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
045DC:  MOVLB  5
045DE:  MOVF   xF5,W
045E0:  SUBLW  30
045E2:  BNZ   460E
045E4:  MOVLW  01
045E6:  SUBWF  xF4,W
045E8:  MULLW  18
045EA:  MOVF   FF3,W
045EC:  CLRF   xFB
045EE:  MOVWF  xFA
045F0:  MOVLW  82
045F2:  ADDWF  xFA,W
045F4:  MOVWF  FE9
045F6:  MOVLW  00
045F8:  ADDWFC xFB,W
045FA:  MOVWF  FEA
045FC:  MOVFF  5F6,FEF
04600:  MOVFF  5F7,FEC
04604:  MOVFF  5F8,FEC
04608:  MOVFF  5F9,FEC
0460C:  BRA    4744
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
0460E:  MOVF   xF5,W
04610:  SUBLW  31
04612:  BNZ   464A
04614:  MOVLW  01
04616:  SUBWF  xF4,W
04618:  MULLW  18
0461A:  MOVF   FF3,W
0461C:  CLRF   xFB
0461E:  MOVWF  xFA
04620:  MOVLW  04
04622:  ADDWF  xFA,W
04624:  MOVWF  01
04626:  MOVLW  00
04628:  ADDWFC xFB,W
0462A:  MOVWF  03
0462C:  MOVF   01,W
0462E:  ADDLW  82
04630:  MOVWF  FE9
04632:  MOVLW  00
04634:  ADDWFC 03,W
04636:  MOVWF  FEA
04638:  MOVFF  5F6,FEF
0463C:  MOVFF  5F7,FEC
04640:  MOVFF  5F8,FEC
04644:  MOVFF  5F9,FEC
04648:  BRA    4744
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
0464A:  MOVF   xF5,W
0464C:  SUBLW  32
0464E:  BNZ   4686
04650:  MOVLW  01
04652:  SUBWF  xF4,W
04654:  MULLW  18
04656:  MOVF   FF3,W
04658:  CLRF   xFB
0465A:  MOVWF  xFA
0465C:  MOVLW  08
0465E:  ADDWF  xFA,W
04660:  MOVWF  01
04662:  MOVLW  00
04664:  ADDWFC xFB,W
04666:  MOVWF  03
04668:  MOVF   01,W
0466A:  ADDLW  82
0466C:  MOVWF  FE9
0466E:  MOVLW  00
04670:  ADDWFC 03,W
04672:  MOVWF  FEA
04674:  MOVFF  5F6,FEF
04678:  MOVFF  5F7,FEC
0467C:  MOVFF  5F8,FEC
04680:  MOVFF  5F9,FEC
04684:  BRA    4744
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
04686:  MOVF   xF5,W
04688:  SUBLW  33
0468A:  BNZ   46C2
0468C:  MOVLW  01
0468E:  SUBWF  xF4,W
04690:  MULLW  18
04692:  MOVF   FF3,W
04694:  CLRF   xFB
04696:  MOVWF  xFA
04698:  MOVLW  0C
0469A:  ADDWF  xFA,W
0469C:  MOVWF  01
0469E:  MOVLW  00
046A0:  ADDWFC xFB,W
046A2:  MOVWF  03
046A4:  MOVF   01,W
046A6:  ADDLW  82
046A8:  MOVWF  FE9
046AA:  MOVLW  00
046AC:  ADDWFC 03,W
046AE:  MOVWF  FEA
046B0:  MOVFF  5F6,FEF
046B4:  MOVFF  5F7,FEC
046B8:  MOVFF  5F8,FEC
046BC:  MOVFF  5F9,FEC
046C0:  BRA    4744
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
046C2:  MOVF   xF5,W
046C4:  SUBLW  34
046C6:  BNZ   46FE
046C8:  MOVLW  01
046CA:  SUBWF  xF4,W
046CC:  MULLW  18
046CE:  MOVF   FF3,W
046D0:  CLRF   xFB
046D2:  MOVWF  xFA
046D4:  MOVLW  10
046D6:  ADDWF  xFA,W
046D8:  MOVWF  01
046DA:  MOVLW  00
046DC:  ADDWFC xFB,W
046DE:  MOVWF  03
046E0:  MOVF   01,W
046E2:  ADDLW  82
046E4:  MOVWF  FE9
046E6:  MOVLW  00
046E8:  ADDWFC 03,W
046EA:  MOVWF  FEA
046EC:  MOVFF  5F6,FEF
046F0:  MOVFF  5F7,FEC
046F4:  MOVFF  5F8,FEC
046F8:  MOVFF  5F9,FEC
046FC:  BRA    4744
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
046FE:  MOVF   xF5,W
04700:  SUBLW  35
04702:  BNZ   473A
04704:  MOVLW  01
04706:  SUBWF  xF4,W
04708:  MULLW  18
0470A:  MOVF   FF3,W
0470C:  CLRF   xFB
0470E:  MOVWF  xFA
04710:  MOVLW  14
04712:  ADDWF  xFA,W
04714:  MOVWF  01
04716:  MOVLW  00
04718:  ADDWFC xFB,W
0471A:  MOVWF  03
0471C:  MOVF   01,W
0471E:  ADDLW  82
04720:  MOVWF  FE9
04722:  MOVLW  00
04724:  ADDWFC 03,W
04726:  MOVWF  FEA
04728:  MOVFF  5F6,FEF
0472C:  MOVFF  5F7,FEC
04730:  MOVFF  5F8,FEC
04734:  MOVFF  5F9,FEC
04738:  BRA    4744
....................    else return INV_PARAM;
0473A:  MOVLW  02
0473C:  MOVWF  01
0473E:  MOVLB  0
04740:  BRA    474A
04742:  MOVLB  5
....................    
....................    return SUCCESS;
04744:  MOVLW  00
04746:  MOVWF  01
04748:  MOVLB  0
0474A:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    
....................    return SUCCESS;
0474C:  MOVLW  00
0474E:  MOVWF  01
04750:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
04752:  MOVLW  00
04754:  MOVWF  01
04756:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
*
04858:  MOVLW  4E
0485A:  MOVLB  5
0485C:  MOVWF  xF8
0485E:  MOVLW  31
04860:  MOVWF  xF9
04862:  MOVLW  35
04864:  MOVWF  xFA
04866:  CLRF   xFB
04868:  MOVLW  05
0486A:  MOVWF  xF7
0486C:  MOVLW  F8
0486E:  MOVWF  xF6
....................    char *s_200 = "200";
04870:  MOVLW  32
04872:  MOVWF  xFE
04874:  MOVLW  30
04876:  MOVWF  xFF
04878:  MOVLB  6
0487A:  MOVWF  x00
0487C:  CLRF   x01
0487E:  MOVLW  05
04880:  MOVLB  5
04882:  MOVWF  xFD
04884:  MOVLW  FE
04886:  MOVWF  xFC
....................    char *s_5V6 = "5V6";
04888:  MOVLW  35
0488A:  MOVLB  6
0488C:  MOVWF  x04
0488E:  MOVLW  56
04890:  MOVWF  x05
04892:  MOVLW  36
04894:  MOVWF  x06
04896:  CLRF   x07
04898:  MOVLW  06
0489A:  MOVWF  x03
0489C:  MOVLW  04
0489E:  MOVWF  x02
....................    char *s_5VA = "5VA";
048A0:  MOVLW  35
048A2:  MOVWF  x0A
048A4:  MOVLW  56
048A6:  MOVWF  x0B
048A8:  MOVLW  41
048AA:  MOVWF  x0C
048AC:  CLRF   x0D
048AE:  MOVLW  06
048B0:  MOVWF  x09
048B2:  MOVLW  0A
048B4:  MOVWF  x08
....................    char *s_3V6X = "3V6X";
048B6:  MOVLW  33
048B8:  MOVWF  x10
048BA:  MOVLW  56
048BC:  MOVWF  x11
048BE:  MOVLW  36
048C0:  MOVWF  x12
048C2:  MOVLW  58
048C4:  MOVWF  x13
048C6:  CLRF   x14
048C8:  MOVLW  06
048CA:  MOVWF  x0F
048CC:  MOVLW  10
048CE:  MOVWF  x0E
....................    char *s_3V3A = "3V3A";
048D0:  MOVLW  33
048D2:  MOVWF  x17
048D4:  MOVLW  56
048D6:  MOVWF  x18
048D8:  MOVLW  33
048DA:  MOVWF  x19
048DC:  MOVLW  41
048DE:  MOVWF  x1A
048E0:  CLRF   x1B
048E2:  MOVLW  06
048E4:  MOVWF  x16
048E6:  MOVLW  17
048E8:  MOVWF  x15
....................    char *s_3V3D = "3V3D";
048EA:  MOVLW  33
048EC:  MOVWF  x1E
048EE:  MOVLW  56
048F0:  MOVWF  x1F
048F2:  MOVLW  33
048F4:  MOVWF  x20
048F6:  MOVLW  44
048F8:  MOVWF  x21
048FA:  CLRF   x22
048FC:  MOVLW  06
048FE:  MOVWF  x1D
04900:  MOVLW  1E
04902:  MOVWF  x1C
....................    char *s_all = "all";
04904:  MOVLW  61
04906:  MOVWF  x25
04908:  MOVLW  6C
0490A:  MOVWF  x26
0490C:  MOVWF  x27
0490E:  CLRF   x28
04910:  MOVLW  06
04912:  MOVWF  x24
04914:  MOVLW  25
04916:  MOVWF  x23
....................    
....................    arg1 = SERcmd[rec].p[2];
04918:  CLRF   x2B
0491A:  MOVFF  5D8,62A
0491E:  CLRF   x2D
04920:  MOVLW  B5
04922:  MOVWF  x2C
04924:  MOVLB  0
04926:  CALL   0852
0492A:  MOVFF  02,62A
0492E:  MOVFF  01,629
04932:  MOVLW  06
04934:  MOVLB  6
04936:  ADDWF  x29,F
04938:  MOVLW  00
0493A:  ADDWFC x2A,F
0493C:  MOVLW  32
0493E:  ADDWF  x29,W
04940:  MOVWF  01
04942:  MOVLW  00
04944:  ADDWFC x2A,W
04946:  MOVWF  03
04948:  MOVF   01,W
0494A:  ADDLW  55
0494C:  MOVWF  01
0494E:  MOVLW  01
04950:  ADDWFC 03,F
04952:  MOVFF  01,5F4
04956:  MOVLB  5
04958:  MOVFF  03,5F5
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0495C:  MOVFF  5F7,62B
04960:  MOVFF  5F6,62A
04964:  MOVFF  5F5,62D
04968:  MOVFF  5F4,62C
0496C:  MOVLB  0
0496E:  CALL   1F50
04972:  MOVF   01,F
04974:  BNZ   49BE
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.vN15);
04976:  MOVLW  04
04978:  MOVLB  6
0497A:  MOVWF  x2B
0497C:  MOVLW  2B
0497E:  MOVWF  x2A
04980:  MOVLB  0
04982:  CALL   1F18
04986:  MOVFF  02,03
0498A:  MOVF   01,W
0498C:  ADDLW  2B
0498E:  MOVLB  6
04990:  MOVWF  x29
04992:  MOVLW  04
04994:  ADDWFC 02,W
04996:  MOVWF  x2A
04998:  MOVFF  FE8,4D0
0499C:  MOVFF  629,4CF
049A0:  MOVLW  10
049A2:  MOVWF  FE9
049A4:  MOVFF  F4,62D
049A8:  MOVFF  F3,62C
049AC:  MOVLB  0
049AE:  RCALL  4758
049B0:  MOVLW  2C
049B2:  MOVLB  6
049B4:  MOVWF  x35
049B6:  MOVLB  0
049B8:  CALL   1FC8
....................    }
049BC:  BRA    4E0A
....................    else if (0 == strcmp(s_200, arg1)) {
049BE:  MOVFF  5FD,62B
049C2:  MOVFF  5FC,62A
049C6:  MOVFF  5F5,62D
049CA:  MOVFF  5F4,62C
049CE:  CALL   1F50
049D2:  MOVF   01,F
049D4:  BNZ   4A1E
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v200);
049D6:  MOVLW  04
049D8:  MOVLB  6
049DA:  MOVWF  x2B
049DC:  MOVLW  2B
049DE:  MOVWF  x2A
049E0:  MOVLB  0
049E2:  CALL   1F18
049E6:  MOVFF  02,03
049EA:  MOVF   01,W
049EC:  ADDLW  2B
049EE:  MOVLB  6
049F0:  MOVWF  x29
049F2:  MOVLW  04
049F4:  ADDWFC 02,W
049F6:  MOVWF  x2A
049F8:  MOVFF  FE8,4D0
049FC:  MOVFF  629,4CF
04A00:  MOVLW  10
04A02:  MOVWF  FE9
04A04:  MOVFF  F8,62D
04A08:  MOVFF  F7,62C
04A0C:  MOVLB  0
04A0E:  RCALL  4758
04A10:  MOVLW  2C
04A12:  MOVLB  6
04A14:  MOVWF  x35
04A16:  MOVLB  0
04A18:  CALL   1FC8
....................    }
04A1C:  BRA    4E0A
....................    else if (0 == strcmp(s_5V6, arg1)) {
04A1E:  MOVFF  603,62B
04A22:  MOVFF  602,62A
04A26:  MOVFF  5F5,62D
04A2A:  MOVFF  5F4,62C
04A2E:  CALL   1F50
04A32:  MOVF   01,F
04A34:  BNZ   4A7E
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v5V6);
04A36:  MOVLW  04
04A38:  MOVLB  6
04A3A:  MOVWF  x2B
04A3C:  MOVLW  2B
04A3E:  MOVWF  x2A
04A40:  MOVLB  0
04A42:  CALL   1F18
04A46:  MOVFF  02,03
04A4A:  MOVF   01,W
04A4C:  ADDLW  2B
04A4E:  MOVLB  6
04A50:  MOVWF  x29
04A52:  MOVLW  04
04A54:  ADDWFC 02,W
04A56:  MOVWF  x2A
04A58:  MOVFF  FE8,4D0
04A5C:  MOVFF  629,4CF
04A60:  MOVLW  10
04A62:  MOVWF  FE9
04A64:  MOVFF  FC,62D
04A68:  MOVFF  FB,62C
04A6C:  MOVLB  0
04A6E:  RCALL  4758
04A70:  MOVLW  2C
04A72:  MOVLB  6
04A74:  MOVWF  x35
04A76:  MOVLB  0
04A78:  CALL   1FC8
....................    }
04A7C:  BRA    4E0A
....................    else if (0 == strcmp(s_5VA, arg1)) {
04A7E:  MOVFF  609,62B
04A82:  MOVFF  608,62A
04A86:  MOVFF  5F5,62D
04A8A:  MOVFF  5F4,62C
04A8E:  CALL   1F50
04A92:  MOVF   01,F
04A94:  BNZ   4ADE
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v5VA);
04A96:  MOVLW  04
04A98:  MOVLB  6
04A9A:  MOVWF  x2B
04A9C:  MOVLW  2B
04A9E:  MOVWF  x2A
04AA0:  MOVLB  0
04AA2:  CALL   1F18
04AA6:  MOVFF  02,03
04AAA:  MOVF   01,W
04AAC:  ADDLW  2B
04AAE:  MOVLB  6
04AB0:  MOVWF  x29
04AB2:  MOVLW  04
04AB4:  ADDWFC 02,W
04AB6:  MOVWF  x2A
04AB8:  MOVFF  FE8,4D0
04ABC:  MOVFF  629,4CF
04AC0:  MOVLW  10
04AC2:  MOVWF  FE9
04AC4:  MOVFF  100,62D
04AC8:  MOVFF  FF,62C
04ACC:  MOVLB  0
04ACE:  RCALL  4758
04AD0:  MOVLW  2C
04AD2:  MOVLB  6
04AD4:  MOVWF  x35
04AD6:  MOVLB  0
04AD8:  CALL   1FC8
....................    }
04ADC:  BRA    4E0A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
04ADE:  MOVFF  60F,62B
04AE2:  MOVFF  60E,62A
04AE6:  MOVFF  5F5,62D
04AEA:  MOVFF  5F4,62C
04AEE:  CALL   1F50
04AF2:  MOVF   01,F
04AF4:  BNZ   4B3E
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v3V6X);
04AF6:  MOVLW  04
04AF8:  MOVLB  6
04AFA:  MOVWF  x2B
04AFC:  MOVLW  2B
04AFE:  MOVWF  x2A
04B00:  MOVLB  0
04B02:  CALL   1F18
04B06:  MOVFF  02,03
04B0A:  MOVF   01,W
04B0C:  ADDLW  2B
04B0E:  MOVLB  6
04B10:  MOVWF  x29
04B12:  MOVLW  04
04B14:  ADDWFC 02,W
04B16:  MOVWF  x2A
04B18:  MOVFF  FE8,4D0
04B1C:  MOVFF  629,4CF
04B20:  MOVLW  10
04B22:  MOVWF  FE9
04B24:  MOVFF  104,62D
04B28:  MOVFF  103,62C
04B2C:  MOVLB  0
04B2E:  RCALL  4758
04B30:  MOVLW  2C
04B32:  MOVLB  6
04B34:  MOVWF  x35
04B36:  MOVLB  0
04B38:  CALL   1FC8
....................    }
04B3C:  BRA    4E0A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
04B3E:  MOVFF  616,62B
04B42:  MOVFF  615,62A
04B46:  MOVFF  5F5,62D
04B4A:  MOVFF  5F4,62C
04B4E:  CALL   1F50
04B52:  MOVF   01,F
04B54:  BNZ   4B9E
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v3V3A);
04B56:  MOVLW  04
04B58:  MOVLB  6
04B5A:  MOVWF  x2B
04B5C:  MOVLW  2B
04B5E:  MOVWF  x2A
04B60:  MOVLB  0
04B62:  CALL   1F18
04B66:  MOVFF  02,03
04B6A:  MOVF   01,W
04B6C:  ADDLW  2B
04B6E:  MOVLB  6
04B70:  MOVWF  x29
04B72:  MOVLW  04
04B74:  ADDWFC 02,W
04B76:  MOVWF  x2A
04B78:  MOVFF  FE8,4D0
04B7C:  MOVFF  629,4CF
04B80:  MOVLW  10
04B82:  MOVWF  FE9
04B84:  MOVFF  108,62D
04B88:  MOVFF  107,62C
04B8C:  MOVLB  0
04B8E:  RCALL  4758
04B90:  MOVLW  2C
04B92:  MOVLB  6
04B94:  MOVWF  x35
04B96:  MOVLB  0
04B98:  CALL   1FC8
....................    }
04B9C:  BRA    4E0A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
04B9E:  MOVFF  61D,62B
04BA2:  MOVFF  61C,62A
04BA6:  MOVFF  5F5,62D
04BAA:  MOVFF  5F4,62C
04BAE:  CALL   1F50
04BB2:  MOVF   01,F
04BB4:  BNZ   4BFE
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v3V3D);
04BB6:  MOVLW  04
04BB8:  MOVLB  6
04BBA:  MOVWF  x2B
04BBC:  MOVLW  2B
04BBE:  MOVWF  x2A
04BC0:  MOVLB  0
04BC2:  CALL   1F18
04BC6:  MOVFF  02,03
04BCA:  MOVF   01,W
04BCC:  ADDLW  2B
04BCE:  MOVLB  6
04BD0:  MOVWF  x29
04BD2:  MOVLW  04
04BD4:  ADDWFC 02,W
04BD6:  MOVWF  x2A
04BD8:  MOVFF  FE8,4D0
04BDC:  MOVFF  629,4CF
04BE0:  MOVLW  10
04BE2:  MOVWF  FE9
04BE4:  MOVFF  10C,62D
04BE8:  MOVFF  10B,62C
04BEC:  MOVLB  0
04BEE:  RCALL  4758
04BF0:  MOVLW  2C
04BF2:  MOVLB  6
04BF4:  MOVWF  x35
04BF6:  MOVLB  0
04BF8:  CALL   1FC8
....................    }
04BFC:  BRA    4E0A
....................    else if (0 == strcmp(s_all, arg1)) {
04BFE:  MOVFF  624,62B
04C02:  MOVFF  623,62A
04C06:  MOVFF  5F5,62D
04C0A:  MOVFF  5F4,62C
04C0E:  CALL   1F50
04C12:  MOVF   01,F
04C14:  BTFSS  FD8.2
04C16:  BRA    4E04
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.vN15);
04C18:  MOVLW  04
04C1A:  MOVLB  6
04C1C:  MOVWF  x2B
04C1E:  MOVLW  2B
04C20:  MOVWF  x2A
04C22:  MOVLB  0
04C24:  CALL   1F18
04C28:  MOVFF  02,03
04C2C:  MOVF   01,W
04C2E:  ADDLW  2B
04C30:  MOVLB  6
04C32:  MOVWF  x29
04C34:  MOVLW  04
04C36:  ADDWFC 02,W
04C38:  MOVWF  x2A
04C3A:  MOVFF  FE8,4D0
04C3E:  MOVFF  629,4CF
04C42:  MOVLW  10
04C44:  MOVWF  FE9
04C46:  MOVFF  F4,62D
04C4A:  MOVFF  F3,62C
04C4E:  MOVLB  0
04C50:  RCALL  4758
04C52:  MOVLW  2C
04C54:  MOVLB  6
04C56:  MOVWF  x35
04C58:  MOVLB  0
04C5A:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v200);
04C5E:  MOVLW  04
04C60:  MOVLB  6
04C62:  MOVWF  x2B
04C64:  MOVLW  2B
04C66:  MOVWF  x2A
04C68:  MOVLB  0
04C6A:  CALL   1F18
04C6E:  MOVFF  02,03
04C72:  MOVF   01,W
04C74:  ADDLW  2B
04C76:  MOVLB  6
04C78:  MOVWF  x29
04C7A:  MOVLW  04
04C7C:  ADDWFC 02,W
04C7E:  MOVWF  x2A
04C80:  MOVFF  FE8,4D0
04C84:  MOVFF  629,4CF
04C88:  MOVLW  10
04C8A:  MOVWF  FE9
04C8C:  MOVFF  F8,62D
04C90:  MOVFF  F7,62C
04C94:  MOVLB  0
04C96:  RCALL  4758
04C98:  MOVLW  2C
04C9A:  MOVLB  6
04C9C:  MOVWF  x35
04C9E:  MOVLB  0
04CA0:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v5V6);
04CA4:  MOVLW  04
04CA6:  MOVLB  6
04CA8:  MOVWF  x2B
04CAA:  MOVLW  2B
04CAC:  MOVWF  x2A
04CAE:  MOVLB  0
04CB0:  CALL   1F18
04CB4:  MOVFF  02,03
04CB8:  MOVF   01,W
04CBA:  ADDLW  2B
04CBC:  MOVLB  6
04CBE:  MOVWF  x29
04CC0:  MOVLW  04
04CC2:  ADDWFC 02,W
04CC4:  MOVWF  x2A
04CC6:  MOVFF  FE8,4D0
04CCA:  MOVFF  629,4CF
04CCE:  MOVLW  10
04CD0:  MOVWF  FE9
04CD2:  MOVFF  FC,62D
04CD6:  MOVFF  FB,62C
04CDA:  MOVLB  0
04CDC:  RCALL  4758
04CDE:  MOVLW  2C
04CE0:  MOVLB  6
04CE2:  MOVWF  x35
04CE4:  MOVLB  0
04CE6:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v5VA);
04CEA:  MOVLW  04
04CEC:  MOVLB  6
04CEE:  MOVWF  x2B
04CF0:  MOVLW  2B
04CF2:  MOVWF  x2A
04CF4:  MOVLB  0
04CF6:  CALL   1F18
04CFA:  MOVFF  02,03
04CFE:  MOVF   01,W
04D00:  ADDLW  2B
04D02:  MOVLB  6
04D04:  MOVWF  x29
04D06:  MOVLW  04
04D08:  ADDWFC 02,W
04D0A:  MOVWF  x2A
04D0C:  MOVFF  FE8,4D0
04D10:  MOVFF  629,4CF
04D14:  MOVLW  10
04D16:  MOVWF  FE9
04D18:  MOVFF  100,62D
04D1C:  MOVFF  FF,62C
04D20:  MOVLB  0
04D22:  RCALL  4758
04D24:  MOVLW  2C
04D26:  MOVLB  6
04D28:  MOVWF  x35
04D2A:  MOVLB  0
04D2C:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v3V6X);
04D30:  MOVLW  04
04D32:  MOVLB  6
04D34:  MOVWF  x2B
04D36:  MOVLW  2B
04D38:  MOVWF  x2A
04D3A:  MOVLB  0
04D3C:  CALL   1F18
04D40:  MOVFF  02,03
04D44:  MOVF   01,W
04D46:  ADDLW  2B
04D48:  MOVLB  6
04D4A:  MOVWF  x29
04D4C:  MOVLW  04
04D4E:  ADDWFC 02,W
04D50:  MOVWF  x2A
04D52:  MOVFF  FE8,4D0
04D56:  MOVFF  629,4CF
04D5A:  MOVLW  10
04D5C:  MOVWF  FE9
04D5E:  MOVFF  104,62D
04D62:  MOVFF  103,62C
04D66:  MOVLB  0
04D68:  RCALL  4758
04D6A:  MOVLW  2C
04D6C:  MOVLB  6
04D6E:  MOVWF  x35
04D70:  MOVLB  0
04D72:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v3V3A);
04D76:  MOVLW  04
04D78:  MOVLB  6
04D7A:  MOVWF  x2B
04D7C:  MOVLW  2B
04D7E:  MOVWF  x2A
04D80:  MOVLB  0
04D82:  CALL   1F18
04D86:  MOVFF  02,03
04D8A:  MOVF   01,W
04D8C:  ADDLW  2B
04D8E:  MOVLB  6
04D90:  MOVWF  x29
04D92:  MOVLW  04
04D94:  ADDWFC 02,W
04D96:  MOVWF  x2A
04D98:  MOVFF  FE8,4D0
04D9C:  MOVFF  629,4CF
04DA0:  MOVLW  10
04DA2:  MOVWF  FE9
04DA4:  MOVFF  108,62D
04DA8:  MOVFF  107,62C
04DAC:  MOVLB  0
04DAE:  RCALL  4758
04DB0:  MOVLW  2C
04DB2:  MOVLB  6
04DB4:  MOVWF  x35
04DB6:  MOVLB  0
04DB8:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", monitorVals.v3V3D);
04DBC:  MOVLW  04
04DBE:  MOVLB  6
04DC0:  MOVWF  x2B
04DC2:  MOVLW  2B
04DC4:  MOVWF  x2A
04DC6:  MOVLB  0
04DC8:  CALL   1F18
04DCC:  MOVFF  02,03
04DD0:  MOVF   01,W
04DD2:  ADDLW  2B
04DD4:  MOVLB  6
04DD6:  MOVWF  x29
04DD8:  MOVLW  04
04DDA:  ADDWFC 02,W
04DDC:  MOVWF  x2A
04DDE:  MOVFF  FE8,4D0
04DE2:  MOVFF  629,4CF
04DE6:  MOVLW  10
04DE8:  MOVWF  FE9
04DEA:  MOVFF  10C,62D
04DEE:  MOVFF  10B,62C
04DF2:  MOVLB  0
04DF4:  RCALL  4758
04DF6:  MOVLW  2C
04DF8:  MOVLB  6
04DFA:  MOVWF  x35
04DFC:  MOVLB  0
04DFE:  CALL   1FC8
....................    }
04E02:  BRA    4E0A
....................    else return INV_PARAM;
04E04:  MOVLW  02
04E06:  MOVWF  01
04E08:  BRA    4E0E
....................    
....................    return SUCCESS;
04E0A:  MOVLW  00
04E0C:  MOVWF  01
04E0E:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
04E10:  MOVLW  00
04E12:  MOVWF  01
04E14:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
05024:  MOVLW  72
05026:  MOVLB  5
05028:  MOVWF  xF9
0502A:  MOVLW  61
0502C:  MOVWF  xFA
0502E:  MOVLW  77
05030:  MOVWF  xFB
05032:  CLRF   xFC
05034:  MOVLW  05
05036:  MOVWF  xF8
05038:  MOVLW  F9
0503A:  MOVWF  xF7
....................    char *s_calibrated = "calib";
0503C:  MOVLW  63
0503E:  MOVWF  xFF
05040:  MOVLW  61
05042:  MOVLB  6
05044:  MOVWF  x00
05046:  MOVLW  6C
05048:  MOVWF  x01
0504A:  MOVLW  69
0504C:  MOVWF  x02
0504E:  MOVLW  62
05050:  MOVWF  x03
05052:  CLRF   x04
05054:  MOVLW  05
05056:  MOVLB  5
05058:  MOVWF  xFE
0505A:  SETF   xFD
....................    char *s_p0 = "p0";
0505C:  MOVLW  70
0505E:  MOVLB  6
05060:  MOVWF  x07
05062:  MOVLW  30
05064:  MOVWF  x08
05066:  CLRF   x09
05068:  MOVLW  06
0506A:  MOVWF  x06
0506C:  MOVLW  07
0506E:  MOVWF  x05
....................    char *s_poles = "poles";
05070:  MOVLW  70
05072:  MOVWF  x0C
05074:  MOVLW  6F
05076:  MOVWF  x0D
05078:  MOVLW  6C
0507A:  MOVWF  x0E
0507C:  MOVLW  65
0507E:  MOVWF  x0F
05080:  MOVLW  73
05082:  MOVWF  x10
05084:  CLRF   x11
05086:  MOVLW  06
05088:  MOVWF  x0B
0508A:  MOVLW  0C
0508C:  MOVWF  x0A
....................    char *s_real = "real";
0508E:  MOVLW  72
05090:  MOVWF  x14
05092:  MOVLW  65
05094:  MOVWF  x15
05096:  MOVLW  61
05098:  MOVWF  x16
0509A:  MOVLW  6C
0509C:  MOVWF  x17
0509E:  CLRF   x18
050A0:  MOVLW  06
050A2:  MOVWF  x13
050A4:  MOVLW  14
050A6:  MOVWF  x12
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
050A8:  CLRF   x2B
050AA:  MOVFF  5D8,62A
050AE:  CLRF   x2D
050B0:  MOVLW  B5
050B2:  MOVWF  x2C
050B4:  MOVLB  0
050B6:  CALL   0852
050BA:  MOVFF  02,61A
050BE:  MOVFF  01,619
050C2:  MOVLW  06
050C4:  MOVLB  6
050C6:  ADDWF  x19,F
050C8:  MOVLW  00
050CA:  ADDWFC x1A,F
050CC:  MOVLW  32
050CE:  ADDWF  x19,W
050D0:  MOVWF  01
050D2:  MOVLW  00
050D4:  ADDWFC x1A,W
050D6:  MOVWF  03
050D8:  MOVF   01,W
050DA:  ADDLW  55
050DC:  MOVWF  01
050DE:  MOVLW  01
050E0:  ADDWFC 03,F
050E2:  MOVFF  01,619
050E6:  MOVFF  03,61A
050EA:  MOVFF  03,61D
050EE:  MOVFF  01,61C
050F2:  MOVLB  0
050F4:  CALL   2090
050F8:  MOVF   01,F
050FA:  BNZ   5104
050FC:  MOVLW  02
050FE:  MOVWF  01
05100:  BRA    575E
05102:  BRA    5162
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05104:  MOVLB  6
05106:  CLRF   x2B
05108:  MOVFF  5D8,62A
0510C:  CLRF   x2D
0510E:  MOVLW  B5
05110:  MOVWF  x2C
05112:  MOVLB  0
05114:  CALL   0852
05118:  MOVFF  02,61A
0511C:  MOVFF  01,619
05120:  MOVLW  06
05122:  MOVLB  6
05124:  ADDWF  x19,F
05126:  MOVLW  00
05128:  ADDWFC x1A,F
0512A:  MOVLW  32
0512C:  ADDWF  x19,W
0512E:  MOVWF  01
05130:  MOVLW  00
05132:  ADDWFC x1A,W
05134:  MOVWF  03
05136:  MOVF   01,W
05138:  ADDLW  55
0513A:  MOVWF  01
0513C:  MOVLW  01
0513E:  ADDWFC 03,F
05140:  MOVFF  01,619
05144:  MOVFF  03,61A
05148:  MOVFF  03,61D
0514C:  MOVFF  01,61C
05150:  CLRF   x1F
05152:  CLRF   x1E
05154:  MOVLW  0A
05156:  MOVWF  x20
05158:  MOVLB  0
0515A:  CALL   2180
0515E:  MOVFF  01,5F4
....................    
....................    arg2 = SERcmd[rec].p[3];
05162:  MOVLB  6
05164:  CLRF   x2B
05166:  MOVFF  5D8,62A
0516A:  CLRF   x2D
0516C:  MOVLW  B5
0516E:  MOVWF  x2C
05170:  MOVLB  0
05172:  CALL   0852
05176:  MOVFF  02,61A
0517A:  MOVFF  01,619
0517E:  MOVLW  06
05180:  MOVLB  6
05182:  ADDWF  x19,F
05184:  MOVLW  00
05186:  ADDWFC x1A,F
05188:  MOVLW  4B
0518A:  ADDWF  x19,W
0518C:  MOVWF  01
0518E:  MOVLW  00
05190:  ADDWFC x1A,W
05192:  MOVWF  03
05194:  MOVF   01,W
05196:  ADDLW  55
05198:  MOVWF  01
0519A:  MOVLW  01
0519C:  ADDWFC 03,F
0519E:  MOVFF  01,5F5
051A2:  MOVLB  5
051A4:  MOVFF  03,5F6
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
051A8:  MOVFF  5F8,62B
051AC:  MOVFF  5F7,62A
051B0:  MOVFF  5F6,62D
051B4:  MOVFF  5F5,62C
051B8:  MOVLB  0
051BA:  CALL   1F50
051BE:  MOVF   01,F
051C0:  BTFSS  FD8.2
051C2:  BRA    5344
....................       sprintf(retData+strlen(retData), "%d,", arg1);
051C4:  MOVLW  04
051C6:  MOVLB  6
051C8:  MOVWF  x2B
051CA:  MOVLW  2B
051CC:  MOVWF  x2A
051CE:  MOVLB  0
051D0:  CALL   1F18
051D4:  MOVFF  02,03
051D8:  MOVF   01,W
051DA:  ADDLW  2B
051DC:  MOVLB  6
051DE:  MOVWF  x19
051E0:  MOVLW  04
051E2:  ADDWFC 02,W
051E4:  MOVWF  x1A
051E6:  MOVFF  FE8,4D0
051EA:  MOVFF  619,4CF
051EE:  MOVFF  5F4,61D
051F2:  MOVLW  18
051F4:  MOVWF  x1E
051F6:  MOVLB  0
051F8:  RCALL  4E42
051FA:  MOVLW  2C
051FC:  MOVLB  6
051FE:  MOVWF  x35
05200:  MOVLB  0
05202:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
05206:  MOVLW  04
05208:  MOVLB  6
0520A:  MOVWF  x2B
0520C:  MOVLW  2B
0520E:  MOVWF  x2A
05210:  MOVLB  0
05212:  CALL   1F18
05216:  MOVFF  02,03
0521A:  MOVF   01,W
0521C:  ADDLW  2B
0521E:  MOVLB  6
05220:  MOVWF  x19
05222:  MOVLW  04
05224:  ADDWFC 02,W
05226:  MOVWF  x1A
05228:  MOVLW  01
0522A:  MOVLB  5
0522C:  SUBWF  xF4,W
0522E:  MULLW  19
05230:  MOVF   FF3,W
05232:  MOVLB  6
05234:  CLRF   x1C
05236:  MOVWF  x1B
05238:  MOVLW  0F
0523A:  ADDWF  x1B,W
0523C:  MOVWF  FE9
0523E:  MOVLW  01
05240:  ADDWFC x1C,W
05242:  MOVWF  FEA
05244:  MOVFF  FEF,62D
05248:  MOVFF  FEC,01
0524C:  MOVFF  FEC,02
05250:  MOVFF  FEC,03
05254:  MOVFF  03,630
05258:  MOVFF  02,62F
0525C:  MOVFF  01,62E
05260:  MOVLB  0
05262:  CALL   2BCA
05266:  MOVFF  03,620
0526A:  MOVFF  02,61F
0526E:  MOVFF  01,61E
05272:  MOVFF  00,61D
05276:  MOVFF  61A,4D0
0527A:  MOVFF  619,4CF
0527E:  MOVLW  41
05280:  MOVWF  FE9
05282:  MOVFF  03,625
05286:  MOVFF  02,624
0528A:  MOVFF  01,623
0528E:  MOVFF  00,622
05292:  RCALL  4F06
05294:  MOVLW  2C
05296:  MOVLB  6
05298:  MOVWF  x35
0529A:  MOVLB  0
0529C:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
052A0:  MOVLW  04
052A2:  MOVLB  6
052A4:  MOVWF  x2B
052A6:  MOVLW  2B
052A8:  MOVWF  x2A
052AA:  MOVLB  0
052AC:  CALL   1F18
052B0:  MOVF   01,W
052B2:  ADDLW  2B
052B4:  MOVLB  6
052B6:  MOVWF  x19
052B8:  MOVLW  04
052BA:  ADDWFC 02,W
052BC:  MOVWF  x1A
052BE:  MOVLW  01
052C0:  MOVLB  5
052C2:  SUBWF  xF4,W
052C4:  MULLW  19
052C6:  MOVF   FF3,W
052C8:  MOVLB  6
052CA:  CLRF   x1C
052CC:  MOVWF  x1B
052CE:  MOVLW  04
052D0:  ADDWF  x1B,W
052D2:  MOVWF  01
052D4:  MOVLW  00
052D6:  ADDWFC x1C,W
052D8:  MOVWF  03
052DA:  MOVF   01,W
052DC:  ADDLW  0F
052DE:  MOVWF  FE9
052E0:  MOVLW  01
052E2:  ADDWFC 03,W
052E4:  MOVWF  FEA
052E6:  MOVFF  FEF,62D
052EA:  MOVFF  FEC,01
052EE:  MOVFF  FEC,02
052F2:  MOVFF  FEC,03
052F6:  MOVFF  03,630
052FA:  MOVFF  02,62F
052FE:  MOVFF  01,62E
05302:  MOVLB  0
05304:  CALL   2BCA
05308:  MOVFF  03,61E
0530C:  MOVFF  02,61D
05310:  MOVFF  01,61C
05314:  MOVFF  00,61B
05318:  MOVFF  61A,4D0
0531C:  MOVFF  619,4CF
05320:  MOVLW  41
05322:  MOVWF  FE9
05324:  MOVFF  03,625
05328:  MOVFF  02,624
0532C:  MOVFF  01,623
05330:  MOVFF  00,622
05334:  RCALL  4F06
05336:  MOVLW  2C
05338:  MOVLB  6
0533A:  MOVWF  x35
0533C:  MOVLB  0
0533E:  CALL   1FC8
....................    }
05342:  BRA    575A
....................    else if (0 == strcmp(s_calibrated, arg2)) {
05344:  MOVFF  5FE,62B
05348:  MOVFF  5FD,62A
0534C:  MOVFF  5F6,62D
05350:  MOVFF  5F5,62C
05354:  CALL   1F50
05358:  MOVF   01,F
0535A:  BTFSS  FD8.2
0535C:  BRA    54E6
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0535E:  MOVLW  04
05360:  MOVLB  6
05362:  MOVWF  x2B
05364:  MOVLW  2B
05366:  MOVWF  x2A
05368:  MOVLB  0
0536A:  CALL   1F18
0536E:  MOVFF  02,03
05372:  MOVF   01,W
05374:  ADDLW  2B
05376:  MOVLB  6
05378:  MOVWF  x19
0537A:  MOVLW  04
0537C:  ADDWFC 02,W
0537E:  MOVWF  x1A
05380:  MOVFF  FE8,4D0
05384:  MOVFF  619,4CF
05388:  MOVFF  5F4,61D
0538C:  MOVLW  18
0538E:  MOVWF  x1E
05390:  MOVLB  0
05392:  RCALL  4E42
05394:  MOVLW  2C
05396:  MOVLB  6
05398:  MOVWF  x35
0539A:  MOVLB  0
0539C:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
053A0:  MOVLW  04
053A2:  MOVLB  6
053A4:  MOVWF  x2B
053A6:  MOVLW  2B
053A8:  MOVWF  x2A
053AA:  MOVLB  0
053AC:  CALL   1F18
053B0:  MOVF   01,W
053B2:  ADDLW  2B
053B4:  MOVLB  6
053B6:  MOVWF  x19
053B8:  MOVLW  04
053BA:  ADDWFC 02,W
053BC:  MOVWF  x1A
053BE:  MOVLW  01
053C0:  MOVLB  5
053C2:  SUBWF  xF4,W
053C4:  MULLW  19
053C6:  MOVF   FF3,W
053C8:  MOVLB  6
053CA:  CLRF   x1C
053CC:  MOVWF  x1B
053CE:  MOVLW  08
053D0:  ADDWF  x1B,W
053D2:  MOVWF  01
053D4:  MOVLW  00
053D6:  ADDWFC x1C,W
053D8:  MOVWF  03
053DA:  MOVF   01,W
053DC:  ADDLW  0F
053DE:  MOVWF  FE9
053E0:  MOVLW  01
053E2:  ADDWFC 03,W
053E4:  MOVWF  FEA
053E6:  MOVFF  FEF,62D
053EA:  MOVFF  FEC,01
053EE:  MOVFF  FEC,02
053F2:  MOVFF  FEC,03
053F6:  MOVFF  03,630
053FA:  MOVFF  02,62F
053FE:  MOVFF  01,62E
05402:  MOVLB  0
05404:  CALL   2BCA
05408:  MOVFF  03,61E
0540C:  MOVFF  02,61D
05410:  MOVFF  01,61C
05414:  MOVFF  00,61B
05418:  MOVFF  61A,4D0
0541C:  MOVFF  619,4CF
05420:  MOVLW  41
05422:  MOVWF  FE9
05424:  MOVFF  03,625
05428:  MOVFF  02,624
0542C:  MOVFF  01,623
05430:  MOVFF  00,622
05434:  RCALL  4F06
05436:  MOVLW  2C
05438:  MOVLB  6
0543A:  MOVWF  x35
0543C:  MOVLB  0
0543E:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
05442:  MOVLW  04
05444:  MOVLB  6
05446:  MOVWF  x2B
05448:  MOVLW  2B
0544A:  MOVWF  x2A
0544C:  MOVLB  0
0544E:  CALL   1F18
05452:  MOVF   01,W
05454:  ADDLW  2B
05456:  MOVLB  6
05458:  MOVWF  x19
0545A:  MOVLW  04
0545C:  ADDWFC 02,W
0545E:  MOVWF  x1A
05460:  MOVLW  01
05462:  MOVLB  5
05464:  SUBWF  xF4,W
05466:  MULLW  19
05468:  MOVF   FF3,W
0546A:  MOVLB  6
0546C:  CLRF   x1C
0546E:  MOVWF  x1B
05470:  MOVLW  0C
05472:  ADDWF  x1B,W
05474:  MOVWF  01
05476:  MOVLW  00
05478:  ADDWFC x1C,W
0547A:  MOVWF  03
0547C:  MOVF   01,W
0547E:  ADDLW  0F
05480:  MOVWF  FE9
05482:  MOVLW  01
05484:  ADDWFC 03,W
05486:  MOVWF  FEA
05488:  MOVFF  FEF,62D
0548C:  MOVFF  FEC,01
05490:  MOVFF  FEC,02
05494:  MOVFF  FEC,03
05498:  MOVFF  03,630
0549C:  MOVFF  02,62F
054A0:  MOVFF  01,62E
054A4:  MOVLB  0
054A6:  CALL   2BCA
054AA:  MOVFF  03,61E
054AE:  MOVFF  02,61D
054B2:  MOVFF  01,61C
054B6:  MOVFF  00,61B
054BA:  MOVFF  61A,4D0
054BE:  MOVFF  619,4CF
054C2:  MOVLW  41
054C4:  MOVWF  FE9
054C6:  MOVFF  03,625
054CA:  MOVFF  02,624
054CE:  MOVFF  01,623
054D2:  MOVFF  00,622
054D6:  RCALL  4F06
054D8:  MOVLW  2C
054DA:  MOVLB  6
054DC:  MOVWF  x35
054DE:  MOVLB  0
054E0:  CALL   1FC8
....................    }
054E4:  BRA    575A
....................    else if (0 == strcmp(s_p0, arg2)) {
054E6:  MOVFF  606,62B
054EA:  MOVFF  605,62A
054EE:  MOVFF  5F6,62D
054F2:  MOVFF  5F5,62C
054F6:  CALL   1F50
054FA:  MOVF   01,F
054FC:  BNZ   55BA
....................       sprintf(retData+strlen(retData), "%d,", arg1);
054FE:  MOVLW  04
05500:  MOVLB  6
05502:  MOVWF  x2B
05504:  MOVLW  2B
05506:  MOVWF  x2A
05508:  MOVLB  0
0550A:  CALL   1F18
0550E:  MOVFF  02,03
05512:  MOVF   01,W
05514:  ADDLW  2B
05516:  MOVLB  6
05518:  MOVWF  x19
0551A:  MOVLW  04
0551C:  ADDWFC 02,W
0551E:  MOVWF  x1A
05520:  MOVFF  FE8,4D0
05524:  MOVFF  619,4CF
05528:  MOVFF  5F4,61D
0552C:  MOVLW  18
0552E:  MOVWF  x1E
05530:  MOVLB  0
05532:  RCALL  4E42
05534:  MOVLW  2C
05536:  MOVLB  6
05538:  MOVWF  x35
0553A:  MOVLB  0
0553C:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
05540:  MOVLW  04
05542:  MOVLB  6
05544:  MOVWF  x2B
05546:  MOVLW  2B
05548:  MOVWF  x2A
0554A:  MOVLB  0
0554C:  CALL   1F18
05550:  MOVF   01,W
05552:  ADDLW  2B
05554:  MOVLB  6
05556:  MOVWF  x19
05558:  MOVLW  04
0555A:  ADDWFC 02,W
0555C:  MOVWF  x1A
0555E:  MOVLW  01
05560:  MOVLB  5
05562:  SUBWF  xF4,W
05564:  MULLW  19
05566:  MOVF   FF3,W
05568:  MOVLB  6
0556A:  CLRF   x1C
0556C:  MOVWF  x1B
0556E:  MOVLW  10
05570:  ADDWF  x1B,W
05572:  MOVWF  01
05574:  MOVLW  00
05576:  ADDWFC x1C,W
05578:  MOVWF  03
0557A:  MOVF   01,W
0557C:  ADDLW  0F
0557E:  MOVWF  FE9
05580:  MOVLW  01
05582:  ADDWFC 03,W
05584:  MOVWF  FEA
05586:  MOVFF  FEF,620
0558A:  MOVFF  FEC,621
0558E:  MOVFF  FEC,622
05592:  MOVFF  FEC,623
05596:  MOVFF  61A,4D0
0559A:  MOVFF  619,4CF
0559E:  MOVLW  89
055A0:  MOVWF  FE9
055A2:  MOVLW  02
055A4:  MOVWF  x24
055A6:  MOVLB  0
055A8:  CALL   2C0C
055AC:  MOVLW  2C
055AE:  MOVLB  6
055B0:  MOVWF  x35
055B2:  MOVLB  0
055B4:  CALL   1FC8
....................    }
055B8:  BRA    575A
....................    else if (0 == strcmp(s_poles, arg2)) {
055BA:  MOVFF  60B,62B
055BE:  MOVFF  60A,62A
055C2:  MOVFF  5F6,62D
055C6:  MOVFF  5F5,62C
055CA:  CALL   1F50
055CE:  MOVF   01,F
055D0:  BNZ   567E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
055D2:  MOVLW  04
055D4:  MOVLB  6
055D6:  MOVWF  x2B
055D8:  MOVLW  2B
055DA:  MOVWF  x2A
055DC:  MOVLB  0
055DE:  CALL   1F18
055E2:  MOVFF  02,03
055E6:  MOVF   01,W
055E8:  ADDLW  2B
055EA:  MOVLB  6
055EC:  MOVWF  x19
055EE:  MOVLW  04
055F0:  ADDWFC 02,W
055F2:  MOVWF  x1A
055F4:  MOVFF  FE8,4D0
055F8:  MOVFF  619,4CF
055FC:  MOVFF  5F4,61D
05600:  MOVLW  18
05602:  MOVWF  x1E
05604:  MOVLB  0
05606:  RCALL  4E42
05608:  MOVLW  2C
0560A:  MOVLB  6
0560C:  MOVWF  x35
0560E:  MOVLB  0
05610:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
05614:  MOVLW  04
05616:  MOVLB  6
05618:  MOVWF  x2B
0561A:  MOVLW  2B
0561C:  MOVWF  x2A
0561E:  MOVLB  0
05620:  CALL   1F18
05624:  MOVF   01,W
05626:  ADDLW  2B
05628:  MOVLB  6
0562A:  MOVWF  x19
0562C:  MOVLW  04
0562E:  ADDWFC 02,W
05630:  MOVWF  x1A
05632:  MOVLW  01
05634:  MOVLB  5
05636:  SUBWF  xF4,W
05638:  MULLW  19
0563A:  MOVF   FF3,W
0563C:  MOVLB  6
0563E:  CLRF   x1C
05640:  MOVWF  x1B
05642:  MOVLW  14
05644:  ADDWF  x1B,W
05646:  MOVWF  01
05648:  MOVLW  00
0564A:  ADDWFC x1C,W
0564C:  MOVWF  03
0564E:  MOVF   01,W
05650:  ADDLW  0F
05652:  MOVWF  FE9
05654:  MOVLW  01
05656:  ADDWFC 03,W
05658:  MOVWF  FEA
0565A:  MOVFF  FEF,61D
0565E:  MOVFF  61A,4D0
05662:  MOVFF  619,4CF
05666:  MOVLW  18
05668:  MOVWF  x1E
0566A:  MOVLB  0
0566C:  CALL   4E42
05670:  MOVLW  2C
05672:  MOVLB  6
05674:  MOVWF  x35
05676:  MOVLB  0
05678:  CALL   1FC8
....................    }
0567C:  BRA    575A
....................    else if (0 == strcmp(s_real, arg2)) {
0567E:  MOVFF  613,62B
05682:  MOVFF  612,62A
05686:  MOVFF  5F6,62D
0568A:  MOVFF  5F5,62C
0568E:  CALL   1F50
05692:  MOVF   01,F
05694:  BNZ   5754
....................       sprintf(retData+strlen(retData), "%d,", arg1);
05696:  MOVLW  04
05698:  MOVLB  6
0569A:  MOVWF  x2B
0569C:  MOVLW  2B
0569E:  MOVWF  x2A
056A0:  MOVLB  0
056A2:  CALL   1F18
056A6:  MOVFF  02,03
056AA:  MOVF   01,W
056AC:  ADDLW  2B
056AE:  MOVLB  6
056B0:  MOVWF  x19
056B2:  MOVLW  04
056B4:  ADDWFC 02,W
056B6:  MOVWF  x1A
056B8:  MOVFF  FE8,4D0
056BC:  MOVFF  619,4CF
056C0:  MOVFF  5F4,61D
056C4:  MOVLW  18
056C6:  MOVWF  x1E
056C8:  MOVLB  0
056CA:  CALL   4E42
056CE:  MOVLW  2C
056D0:  MOVLB  6
056D2:  MOVWF  x35
056D4:  MOVLB  0
056D6:  CALL   1FC8
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
056DA:  MOVLW  04
056DC:  MOVLB  6
056DE:  MOVWF  x2B
056E0:  MOVLW  2B
056E2:  MOVWF  x2A
056E4:  MOVLB  0
056E6:  CALL   1F18
056EA:  MOVF   01,W
056EC:  ADDLW  2B
056EE:  MOVLB  6
056F0:  MOVWF  x19
056F2:  MOVLW  04
056F4:  ADDWFC 02,W
056F6:  MOVWF  x1A
056F8:  MOVLW  01
056FA:  MOVLB  5
056FC:  SUBWF  xF4,W
056FE:  MULLW  19
05700:  MOVF   FF3,W
05702:  MOVLB  6
05704:  CLRF   x1C
05706:  MOVWF  x1B
05708:  MOVLW  15
0570A:  ADDWF  x1B,W
0570C:  MOVWF  01
0570E:  MOVLW  00
05710:  ADDWFC x1C,W
05712:  MOVWF  03
05714:  MOVF   01,W
05716:  ADDLW  0F
05718:  MOVWF  FE9
0571A:  MOVLW  01
0571C:  ADDWFC 03,W
0571E:  MOVWF  FEA
05720:  MOVFF  FEF,620
05724:  MOVFF  FEC,621
05728:  MOVFF  FEC,622
0572C:  MOVFF  FEC,623
05730:  MOVFF  61A,4D0
05734:  MOVFF  619,4CF
05738:  MOVLW  89
0573A:  MOVWF  FE9
0573C:  MOVLW  02
0573E:  MOVWF  x24
05740:  MOVLB  0
05742:  CALL   2C0C
05746:  MOVLW  2C
05748:  MOVLB  6
0574A:  MOVWF  x35
0574C:  MOVLB  0
0574E:  CALL   1FC8
....................    }
05752:  BRA    575A
....................    else return INV_PARAM;
05754:  MOVLW  02
05756:  MOVWF  01
05758:  BRA    575E
....................    
....................    return SUCCESS;
0575A:  MOVLW  00
0575C:  MOVWF  01
0575E:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05760:  MOVLB  6
05762:  CLRF   x2B
05764:  MOVFF  5D8,62A
05768:  CLRF   x2D
0576A:  MOVLW  B5
0576C:  MOVWF  x2C
0576E:  MOVLB  0
05770:  CALL   0852
05774:  MOVFF  02,5F6
05778:  MOVFF  01,5F5
0577C:  MOVLW  06
0577E:  MOVLB  5
05780:  ADDWF  xF5,F
05782:  MOVLW  00
05784:  ADDWFC xF6,F
05786:  MOVLW  32
05788:  ADDWF  xF5,W
0578A:  MOVWF  01
0578C:  MOVLW  00
0578E:  ADDWFC xF6,W
05790:  MOVWF  03
05792:  MOVF   01,W
05794:  ADDLW  55
05796:  MOVWF  01
05798:  MOVLW  01
0579A:  ADDWFC 03,F
0579C:  MOVFF  01,5F5
057A0:  MOVFF  03,5F6
057A4:  MOVFF  03,61D
057A8:  MOVFF  01,61C
057AC:  MOVLB  0
057AE:  CALL   2090
057B2:  MOVF   01,F
057B4:  BNZ   57BE
057B6:  MOVLW  02
057B8:  MOVWF  01
057BA:  BRA    5888
057BC:  BRA    581E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
057BE:  MOVLB  6
057C0:  CLRF   x2B
057C2:  MOVFF  5D8,62A
057C6:  CLRF   x2D
057C8:  MOVLW  B5
057CA:  MOVWF  x2C
057CC:  MOVLB  0
057CE:  CALL   0852
057D2:  MOVFF  02,5F6
057D6:  MOVFF  01,5F5
057DA:  MOVLW  06
057DC:  MOVLB  5
057DE:  ADDWF  xF5,F
057E0:  MOVLW  00
057E2:  ADDWFC xF6,F
057E4:  MOVLW  32
057E6:  ADDWF  xF5,W
057E8:  MOVWF  01
057EA:  MOVLW  00
057EC:  ADDWFC xF6,W
057EE:  MOVWF  03
057F0:  MOVF   01,W
057F2:  ADDLW  55
057F4:  MOVWF  01
057F6:  MOVLW  01
057F8:  ADDWFC 03,F
057FA:  MOVFF  01,5F5
057FE:  MOVFF  03,5F6
05802:  MOVFF  03,61D
05806:  MOVFF  01,61C
0580A:  MOVLB  6
0580C:  CLRF   x1F
0580E:  CLRF   x1E
05810:  MOVLW  0A
05812:  MOVWF  x20
05814:  MOVLB  0
05816:  CALL   2180
0581A:  MOVFF  01,5F4
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%f,", manualOutputValues[arg1-1]);
0581E:  MOVLW  04
05820:  MOVLB  6
05822:  MOVWF  x2B
05824:  MOVLW  2B
05826:  MOVWF  x2A
05828:  MOVLB  0
0582A:  CALL   1F18
0582E:  MOVF   01,W
05830:  ADDLW  2B
05832:  MOVLB  5
05834:  MOVWF  xF5
05836:  MOVLW  04
05838:  ADDWFC 02,W
0583A:  MOVWF  xF6
0583C:  MOVLW  01
0583E:  SUBWF  xF4,W
05840:  MULLW  04
05842:  MOVF   FF3,W
05844:  CLRF   03
05846:  ADDLW  EA
05848:  MOVWF  FE9
0584A:  MOVLW  00
0584C:  ADDWFC 03,W
0584E:  MOVWF  FEA
05850:  MOVFF  FEF,620
05854:  MOVFF  FEC,621
05858:  MOVFF  FEC,622
0585C:  MOVFF  FEC,623
05860:  MOVFF  5F6,4D0
05864:  MOVFF  5F5,4CF
05868:  MOVLW  89
0586A:  MOVWF  FE9
0586C:  MOVLW  02
0586E:  MOVLB  6
05870:  MOVWF  x24
05872:  MOVLB  0
05874:  CALL   2C0C
05878:  MOVLW  2C
0587A:  MOVLB  6
0587C:  MOVWF  x35
0587E:  MOVLB  0
05880:  CALL   1FC8
....................    
....................    return SUCCESS;
05884:  MOVLW  00
05886:  MOVWF  01
05888:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0588A:  MOVLB  6
0588C:  CLRF   x2B
0588E:  MOVFF  5D8,62A
05892:  CLRF   x2D
05894:  MOVLW  B5
05896:  MOVWF  x2C
05898:  MOVLB  0
0589A:  CALL   0852
0589E:  MOVFF  02,5FA
058A2:  MOVFF  01,5F9
058A6:  MOVLW  06
058A8:  MOVLB  5
058AA:  ADDWF  xF9,F
058AC:  MOVLW  00
058AE:  ADDWFC xFA,F
058B0:  MOVLW  32
058B2:  ADDWF  xF9,W
058B4:  MOVWF  01
058B6:  MOVLW  00
058B8:  ADDWFC xFA,W
058BA:  MOVWF  03
058BC:  MOVF   01,W
058BE:  ADDLW  55
058C0:  MOVWF  01
058C2:  MOVLW  01
058C4:  ADDWFC 03,F
058C6:  MOVFF  01,5F9
058CA:  MOVFF  03,5FA
058CE:  MOVFF  03,61D
058D2:  MOVFF  01,61C
058D6:  MOVLB  0
058D8:  CALL   2090
058DC:  MOVF   01,F
058DE:  BNZ   58E8
058E0:  MOVLW  02
058E2:  MOVWF  01
058E4:  BRA    5A3C
058E6:  BRA    5948
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
058E8:  MOVLB  6
058EA:  CLRF   x2B
058EC:  MOVFF  5D8,62A
058F0:  CLRF   x2D
058F2:  MOVLW  B5
058F4:  MOVWF  x2C
058F6:  MOVLB  0
058F8:  CALL   0852
058FC:  MOVFF  02,5FA
05900:  MOVFF  01,5F9
05904:  MOVLW  06
05906:  MOVLB  5
05908:  ADDWF  xF9,F
0590A:  MOVLW  00
0590C:  ADDWFC xFA,F
0590E:  MOVLW  32
05910:  ADDWF  xF9,W
05912:  MOVWF  01
05914:  MOVLW  00
05916:  ADDWFC xFA,W
05918:  MOVWF  03
0591A:  MOVF   01,W
0591C:  ADDLW  55
0591E:  MOVWF  01
05920:  MOVLW  01
05922:  ADDWFC 03,F
05924:  MOVFF  01,5F9
05928:  MOVFF  03,5FA
0592C:  MOVFF  03,61D
05930:  MOVFF  01,61C
05934:  MOVLB  6
05936:  CLRF   x1F
05938:  CLRF   x1E
0593A:  MOVLW  0A
0593C:  MOVWF  x20
0593E:  MOVLB  0
05940:  CALL   2180
05944:  MOVFF  01,5F4
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
05948:  MOVLB  6
0594A:  CLRF   x2B
0594C:  MOVFF  5D8,62A
05950:  CLRF   x2D
05952:  MOVLW  B5
05954:  MOVWF  x2C
05956:  MOVLB  0
05958:  CALL   0852
0595C:  MOVFF  02,5FA
05960:  MOVFF  01,5F9
05964:  MOVLW  06
05966:  MOVLB  5
05968:  ADDWF  xF9,F
0596A:  MOVLW  00
0596C:  ADDWFC xFA,F
0596E:  MOVLW  4B
05970:  ADDWF  xF9,W
05972:  MOVWF  01
05974:  MOVLW  00
05976:  ADDWFC xFA,W
05978:  MOVWF  03
0597A:  MOVF   01,W
0597C:  ADDLW  55
0597E:  MOVWF  01
05980:  MOVLW  01
05982:  ADDWFC 03,F
05984:  MOVFF  01,5F9
05988:  MOVFF  03,5FA
0598C:  MOVFF  03,5FE
05990:  MOVFF  01,5FD
05994:  MOVLB  0
05996:  CALL   347C
0599A:  MOVF   01,F
0599C:  BNZ   59A6
0599E:  MOVLW  02
059A0:  MOVWF  01
059A2:  BRA    5A3C
059A4:  BRA    5A10
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
059A6:  MOVLB  6
059A8:  CLRF   x2B
059AA:  MOVFF  5D8,62A
059AE:  CLRF   x2D
059B0:  MOVLW  B5
059B2:  MOVWF  x2C
059B4:  MOVLB  0
059B6:  CALL   0852
059BA:  MOVFF  02,5FA
059BE:  MOVFF  01,5F9
059C2:  MOVLW  06
059C4:  MOVLB  5
059C6:  ADDWF  xF9,F
059C8:  MOVLW  00
059CA:  ADDWFC xFA,F
059CC:  MOVLW  4B
059CE:  ADDWF  xF9,W
059D0:  MOVWF  01
059D2:  MOVLW  00
059D4:  ADDWFC xFA,W
059D6:  MOVWF  03
059D8:  MOVF   01,W
059DA:  ADDLW  55
059DC:  MOVWF  01
059DE:  MOVLW  01
059E0:  ADDWFC 03,F
059E2:  MOVFF  01,5F9
059E6:  MOVFF  03,5FA
059EA:  MOVFF  03,5FE
059EE:  MOVFF  01,5FD
059F2:  MOVLB  6
059F4:  CLRF   x00
059F6:  MOVLB  5
059F8:  CLRF   xFF
059FA:  MOVLB  0
059FC:  CALL   3208
05A00:  MOVFF  03,5F8
05A04:  MOVFF  02,5F7
05A08:  MOVFF  01,5F6
05A0C:  MOVFF  00,5F5
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    manualOutputValues[arg1-1] = arg2;
05A10:  MOVLW  01
05A12:  MOVLB  5
05A14:  SUBWF  xF4,W
05A16:  MULLW  04
05A18:  MOVF   FF3,W
05A1A:  CLRF   03
05A1C:  ADDLW  EA
05A1E:  MOVWF  FE9
05A20:  MOVLW  00
05A22:  ADDWFC 03,W
05A24:  MOVWF  FEA
05A26:  MOVFF  5F5,FEF
05A2A:  MOVFF  5F6,FEC
05A2E:  MOVFF  5F7,FEC
05A32:  MOVFF  5F8,FEC
....................    
....................    return SUCCESS;
05A36:  MOVLW  00
05A38:  MOVWF  01
05A3A:  MOVLB  0
05A3C:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
05A3E:  MOVLW  01
05A40:  MOVWF  01
05A42:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
0347C:  MOVLB  5
0347E:  BCF    xFF.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
03480:  MOVLB  6
03482:  CLRF   x00
03484:  MOVFF  5FE,62B
03488:  MOVFF  5FD,62A
0348C:  MOVLB  0
0348E:  CALL   1F18
03492:  MOVFF  02,03
03496:  MOVF   01,W
03498:  MOVF   03,F
0349A:  BNZ   34A6
0349C:  MOVF   01,W
0349E:  MOVLB  6
034A0:  SUBWF  x00,W
034A2:  BC    3546
034A4:  MOVLB  0
....................       if (!isdigit(arg[i])){
034A6:  MOVLB  6
034A8:  MOVF   x00,W
034AA:  MOVLB  5
034AC:  ADDWF  xFD,W
034AE:  MOVWF  FE9
034B0:  MOVLW  00
034B2:  ADDWFC xFE,W
034B4:  MOVWF  FEA
034B6:  MOVFF  FEF,601
034BA:  MOVLB  6
034BC:  MOVF   x01,W
034BE:  SUBLW  2F
034C0:  BC    34C8
034C2:  MOVF   x01,W
034C4:  SUBLW  39
034C6:  BC    3542
....................          // Check for negative sign
....................          if ('-' != arg[i]){
034C8:  MOVF   x00,W
034CA:  MOVLB  5
034CC:  ADDWF  xFD,W
034CE:  MOVWF  FE9
034D0:  MOVLW  00
034D2:  ADDWFC xFE,W
034D4:  MOVWF  FEA
034D6:  MOVF   FEF,W
034D8:  SUBLW  2D
034DA:  BZ    350A
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
034DC:  MOVLB  6
034DE:  MOVF   x00,W
034E0:  MOVLB  5
034E2:  ADDWF  xFD,W
034E4:  MOVWF  FE9
034E6:  MOVLW  00
034E8:  ADDWFC xFE,W
034EA:  MOVWF  FEA
034EC:  MOVF   FEF,W
034EE:  SUBLW  2E
034F0:  BZ    34FA
034F2:  MOVLW  00
034F4:  MOVWF  01
034F6:  BRA    354C
034F8:  BRA    3508
....................             else if  (decimal) return FALSE;
034FA:  BTFSS  xFF.0
034FC:  BRA    3506
034FE:  MOVLW  00
03500:  MOVWF  01
03502:  BRA    354C
03504:  BRA    3508
....................             else decimal = TRUE;
03506:  BSF    xFF.0
....................          }
03508:  BRA    353E
....................          else if (0 != i) return FALSE;
0350A:  MOVLB  6
0350C:  MOVF   x00,F
0350E:  BZ    351A
03510:  MOVLW  00
03512:  MOVWF  01
03514:  MOVLB  5
03516:  BRA    354C
03518:  BRA    353E
....................          else if (1 == strlen(arg)) return FALSE;
0351A:  MOVFF  5FE,62B
0351E:  MOVFF  5FD,62A
03522:  MOVLB  0
03524:  CALL   1F18
03528:  MOVFF  02,03
0352C:  MOVF   01,W
0352E:  SUBLW  01
03530:  BNZ   3540
03532:  MOVF   03,F
03534:  BNZ   3540
03536:  MOVLW  00
03538:  MOVWF  01
0353A:  MOVLB  5
0353C:  BRA    354C
0353E:  MOVLB  0
03540:  MOVLB  6
....................       }
03542:  INCF   x00,F
03544:  BRA    3484
....................    }
....................    return TRUE;
03546:  MOVLW  01
03548:  MOVWF  01
0354A:  MOVLB  5
0354C:  MOVLB  0
0354E:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
02090:  MOVFF  61D,62B
02094:  MOVFF  61C,62A
02098:  RCALL  1F18
0209A:  MOVFF  02,03
0209E:  MOVF   01,W
020A0:  SUBLW  01
020A2:  BNZ   20A8
020A4:  MOVF   03,F
020A6:  BZ    20B0
020A8:  MOVLW  00
020AA:  MOVWF  01
020AC:  BRA    20DE
020AE:  BRA    20D6
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
020B0:  MOVLB  6
020B2:  MOVFF  61C,FE9
020B6:  MOVFF  61D,FEA
020BA:  MOVF   FEF,W
020BC:  SUBLW  31
020BE:  BZ    20D8
020C0:  MOVFF  61C,FE9
020C4:  MOVFF  61D,FEA
020C8:  MOVF   FEF,W
020CA:  SUBLW  32
020CC:  BZ    20D8
020CE:  MOVLW  00
020D0:  MOVWF  01
020D2:  MOVLB  0
020D4:  BRA    20DE
020D6:  MOVLB  6
....................     return TRUE;
020D8:  MOVLW  01
020DA:  MOVWF  01
020DC:  MOVLB  0
020DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
01EDE:  MOVLB  5
01EE0:  MOVF   xF3,W
01EE2:  SUBLW  2F
01EE4:  BC    1EF6
01EE6:  MOVF   xF3,W
01EE8:  SUBLW  39
01EEA:  BNC   1EF6
01EEC:  MOVLW  30
01EEE:  SUBWF  xF3,W
01EF0:  MOVWF  01
01EF2:  BRA    1F12
01EF4:  BRA    1F12
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
01EF6:  MOVF   xF3,W
01EF8:  SUBLW  40
01EFA:  BC    1F0E
01EFC:  MOVF   xF3,W
01EFE:  SUBLW  46
01F00:  BNC   1F0E
01F02:  MOVLW  41
01F04:  SUBWF  xF3,W
01F06:  ADDLW  0A
01F08:  MOVWF  01
01F0A:  BRA    1F12
01F0C:  BRA    1F12
....................    else return 0xFF;
01F0E:  MOVLW  FF
01F10:  MOVWF  01
01F12:  MOVLB  0
01F14:  GOTO   5AEA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
05A44:  MOVLB  6
05A46:  CLRF   x2B
05A48:  MOVFF  5EA,62A
05A4C:  CLRF   x2D
05A4E:  MOVLW  B5
05A50:  MOVWF  x2C
05A52:  MOVLB  0
05A54:  CALL   0852
05A58:  MOVFF  02,5F3
05A5C:  MOVFF  01,5F2
05A60:  MOVLW  06
05A62:  MOVLB  5
05A64:  ADDWF  xF2,F
05A66:  MOVLW  00
05A68:  ADDWFC xF3,F
05A6A:  MOVLW  55
05A6C:  ADDWF  xF2,W
05A6E:  MOVWF  01
05A70:  MOVLW  01
05A72:  ADDWFC xF3,W
05A74:  MOVWF  03
05A76:  MOVFF  01,5EB
05A7A:  MOVWF  xEC
05A7C:  MOVLB  6
05A7E:  CLRF   x2B
05A80:  MOVFF  5EA,62A
05A84:  CLRF   x2D
05A86:  MOVLW  B5
05A88:  MOVWF  x2C
05A8A:  MOVLB  0
05A8C:  CALL   0852
05A90:  MOVFF  02,5F5
05A94:  MOVFF  01,5F4
05A98:  MOVLW  06
05A9A:  MOVLB  5
05A9C:  ADDWF  xF4,F
05A9E:  MOVLW  00
05AA0:  ADDWFC xF5,F
05AA2:  MOVLW  19
05AA4:  ADDWF  xF4,W
05AA6:  MOVWF  01
05AA8:  MOVLW  00
05AAA:  ADDWFC xF5,W
05AAC:  MOVWF  03
05AAE:  MOVF   01,W
05AB0:  ADDLW  55
05AB2:  MOVWF  01
05AB4:  MOVLW  01
05AB6:  ADDWFC 03,F
05AB8:  MOVFF  01,5ED
05ABC:  MOVFF  03,5EE
05AC0:  CLRF   xEF
05AC2:  CLRF   xF0
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
05AC4:  MOVFF  5EB,FE9
05AC8:  MOVFF  5EC,FEA
05ACC:  MOVF   FEF,W
05ACE:  SUBLW  44
05AD0:  BTFSS  FD8.2
05AD2:  BRA    5BC2
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
05AD4:  MOVLW  01
05AD6:  ADDWF  xEB,W
05AD8:  MOVWF  FE9
05ADA:  MOVLW  00
05ADC:  ADDWFC xEC,W
05ADE:  MOVWF  FEA
05AE0:  MOVFF  FEF,5F3
05AE4:  MOVLB  0
05AE6:  GOTO   1EDE
05AEA:  MOVFF  01,5F2
05AEE:  MOVLB  5
05AF0:  MOVF   xEF,W
05AF2:  ANDLW  0F
05AF4:  SUBWF  01,W
05AF6:  BNZ   5BBA
....................          while (0 != strlen(cmd_list[i].cmd_name)){
05AF8:  MOVF   xF0,W
05AFA:  MULLW  04
05AFC:  MOVF   FF3,W
05AFE:  CLRF   xF3
05B00:  MOVWF  xF2
05B02:  MOVLW  D6
05B04:  ADDWF  xF2,W
05B06:  MOVWF  FE9
05B08:  MOVLW  04
05B0A:  ADDWFC xF3,W
05B0C:  MOVWF  FEA
05B0E:  MOVFF  FEC,62B
05B12:  MOVF   FED,F
05B14:  MOVFF  FEF,62A
05B18:  MOVLB  0
05B1A:  CALL   1F18
05B1E:  MOVFF  02,03
05B22:  MOVF   01,W
05B24:  BNZ   5B2A
05B26:  MOVF   03,F
05B28:  BZ    5BB0
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
05B2A:  MOVLB  5
05B2C:  MOVF   xF0,W
05B2E:  MULLW  04
05B30:  MOVF   FF3,W
05B32:  CLRF   xF3
05B34:  MOVWF  xF2
05B36:  MOVLW  D6
05B38:  ADDWF  xF2,W
05B3A:  MOVWF  FE9
05B3C:  MOVLW  04
05B3E:  ADDWFC xF3,W
05B40:  MOVWF  FEA
05B42:  MOVFF  FEC,62D
05B46:  MOVF   FED,F
05B48:  MOVFF  FEF,62C
05B4C:  MOVFF  5EE,62B
05B50:  MOVFF  5ED,62A
05B54:  MOVLB  0
05B56:  CALL   1F50
05B5A:  MOVF   01,F
05B5C:  BNZ   5BA8
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
05B5E:  MOVLB  5
05B60:  MOVF   xF0,W
05B62:  MULLW  04
05B64:  MOVF   FF3,W
05B66:  CLRF   xF3
05B68:  MOVWF  xF2
05B6A:  MOVLW  02
05B6C:  ADDWF  xF2,W
05B6E:  MOVWF  01
05B70:  MOVLW  00
05B72:  ADDWFC xF3,W
05B74:  MOVWF  03
05B76:  MOVF   01,W
05B78:  ADDLW  D6
05B7A:  MOVWF  01
05B7C:  MOVLW  04
05B7E:  ADDWFC 03,F
05B80:  MOVFF  01,5F2
05B84:  MOVFF  03,5F3
05B88:  MOVFF  03,FEA
05B8C:  MOVFF  01,FE9
05B90:  MOVFF  5EA,5D8
05B94:  MOVLB  0
05B96:  CALL   00BC
05B9A:  MOVFF  01,5F1
....................                return return_code;
05B9E:  MOVLB  5
05BA0:  MOVFF  5F1,01
05BA4:  BRA    5BC6
05BA6:  MOVLB  0
....................             }
....................             i++;
05BA8:  MOVLB  5
05BAA:  INCF   xF0,F
05BAC:  BRA    5AF8
05BAE:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
05BB0:  MOVLW  01
05BB2:  MOVWF  01
05BB4:  MOVLB  5
05BB6:  BRA    5BC6
....................       } else return 254; // NOT THIS ADDRESS
05BB8:  BRA    5BC0
05BBA:  MOVLW  FE
05BBC:  MOVWF  01
05BBE:  BRA    5BC6
....................    } else return 255; // NOT THIS DEVICE TYPE
05BC0:  BRA    5BC6
05BC2:  MOVLW  FF
05BC4:  MOVWF  01
05BC6:  MOVLB  0
05BC8:  GOTO   5C02 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
05BF4:  GOTO   1E84
05BF8:  MOVF   01,F
05BFA:  BZ    5CD4
....................    {
....................       int8 return_code = command_parser(SRI);
05BFC:  MOVFF  429,5EA
05C00:  BRA    5A44
05C02:  MOVFF  01,5E9
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
05C06:  MOVLW  04
05C08:  MOVLB  6
05C0A:  MOVWF  x2B
05C0C:  MOVLW  2B
05C0E:  MOVWF  x2A
05C10:  MOVLB  0
05C12:  CALL   1F18
05C16:  MOVF   01,W
05C18:  ADDLW  2B
05C1A:  MOVLB  5
05C1C:  MOVWF  xEA
05C1E:  MOVLW  04
05C20:  ADDWFC 02,W
05C22:  MOVWF  xEB
05C24:  MOVF   xE9,W
05C26:  MULLW  03
05C28:  MOVF   FF3,W
05C2A:  CLRF   xED
05C2C:  MOVWF  xEC
05C2E:  MOVLW  01
05C30:  ADDWF  xEC,W
05C32:  MOVWF  01
05C34:  MOVLW  00
05C36:  ADDWFC xED,W
05C38:  MOVWF  03
05C3A:  MOVF   01,W
05C3C:  ADDLW  A5
05C3E:  MOVWF  FE9
05C40:  MOVLW  05
05C42:  ADDWFC 03,W
05C44:  MOVWF  FEA
05C46:  MOVFF  FEC,5ED
05C4A:  MOVF   FED,F
05C4C:  MOVFF  FEF,5EC
05C50:  MOVFF  5EB,4D0
05C54:  MOVFF  5EA,4CF
05C58:  MOVFF  4D0,FEA
05C5C:  MOVFF  4CF,FE9
05C60:  CLRF   FEF
05C62:  MOVFF  5ED,FEA
05C66:  MOVFF  5EC,FE9
05C6A:  MOVLB  0
05C6C:  BRA    5BCC
....................       fprintf(SERIAL, "%s,%s", SERcmd[SRI].p[0], retData);
05C6E:  MOVLB  6
05C70:  CLRF   x2B
05C72:  MOVFF  429,62A
05C76:  CLRF   x2D
05C78:  MOVLW  B5
05C7A:  MOVWF  x2C
05C7C:  MOVLB  0
05C7E:  CALL   0852
05C82:  MOVFF  02,5EB
05C86:  MOVFF  01,5EA
05C8A:  MOVLW  06
05C8C:  MOVLB  5
05C8E:  ADDWF  xEA,F
05C90:  MOVLW  00
05C92:  ADDWFC xEB,F
05C94:  MOVLW  55
05C96:  ADDWF  xEA,W
05C98:  MOVWF  01
05C9A:  MOVLW  01
05C9C:  ADDWFC xEB,W
05C9E:  MOVWF  03
05CA0:  MOVFF  01,5EC
05CA4:  MOVWF  xED
05CA6:  MOVWF  FEA
05CA8:  MOVFF  01,FE9
05CAC:  MOVLB  0
05CAE:  CALL   1726
05CB2:  MOVLW  2C
05CB4:  MOVLB  5
05CB6:  MOVWF  xF5
05CB8:  MOVLB  0
05CBA:  CALL   16FE
05CBE:  MOVLW  04
05CC0:  MOVWF  FEA
05CC2:  MOVLW  2B
05CC4:  MOVWF  FE9
05CC6:  CALL   1726
....................       
....................       resetSERcmd(SRI);
05CCA:  MOVFF  429,5EA
05CCE:  CALL   0874
05CD2:  BRA    5BF4
....................    }
05CD4:  GOTO   618E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... void main()
05CD8:  CLRF   FF8
05CDA:  BCF    FF2.5
05CDC:  BSF    07.7
05CDE:  MOVLB  E
05CE0:  MOVLW  55
05CE2:  MOVWF  x9B
05CE4:  MOVLW  AA
05CE6:  MOVWF  x9B
05CE8:  BCF    x9B.0
05CEA:  MOVLW  17
05CEC:  MOVWF  xB0
05CEE:  MOVLW  13
05CF0:  MOVWF  xB2
05CF2:  MOVLW  09
05CF4:  MOVWF  x8A
05CF6:  MOVLW  0A
05CF8:  MOVWF  x8B
05CFA:  MOVLW  11
05CFC:  MOVWF  xEB
05CFE:  MOVLW  12
05D00:  MOVWF  xED
05D02:  MOVLW  10
05D04:  MOVWF  xF4
05D06:  MOVLW  0F
05D08:  MOVWF  xF5
05D0A:  MOVLW  09
05D0C:  MOVWF  xF8
05D0E:  MOVLW  55
05D10:  MOVWF  x9B
05D12:  MOVLW  AA
05D14:  MOVWF  x9B
05D16:  BSF    x9B.0
05D18:  CLRF   xD8
05D1A:  CLRF   xD5
05D1C:  CLRF   xD7
05D1E:  MOVLW  08
05D20:  MOVWF  xD9
05D22:  MOVLW  60
05D24:  MOVWF  xD3
05D26:  MOVLW  AA
05D28:  MOVLB  0
05D2A:  MOVWF  xF2
05D2C:  MOVLB  1
05D2E:  CLRF   x44
05D30:  CLRF   x43
05D32:  CLRF   x42
05D34:  CLRF   x41
05D36:  CLRF   x48
05D38:  CLRF   x47
05D3A:  CLRF   x46
05D3C:  CLRF   x45
05D3E:  CLRF   x4C
05D40:  CLRF   x4B
05D42:  CLRF   x4A
05D44:  CLRF   x49
05D46:  CLRF   x4E
05D48:  CLRF   x4D
05D4A:  MOVLB  E
05D4C:  BCF    x91.5
05D4E:  MOVLW  00
05D50:  MOVWF  x90
05D52:  MOVLW  0F
05D54:  MOVWF  x8E
05D56:  MOVLW  2A
05D58:  MOVWF  x91
05D5A:  MOVLW  C4
05D5C:  MOVWF  F88
05D5E:  MOVWF  F88
05D60:  MOVWF  F88
05D62:  BCF    F95.5
05D64:  MOVLW  40
05D66:  MOVWF  F94
05D68:  MOVLW  9F
05D6A:  MOVWF  F92
05D6C:  MOVLW  2A
05D6E:  MOVWF  F95
05D70:  MOVLW  93
05D72:  MOVWF  F89
05D74:  MOVWF  F89
05D76:  MOVLB  4
05D78:  CLRF   x29
05D7A:  CLRF   x2A
05D7C:  CLRF   xCB
05D7E:  CLRF   xCC
05D80:  BCF    xCD.0
05D82:  CLRF   xCE
05D84:  BSF    F9E.3
05D86:  MOVLW  7C
05D88:  MOVWF  F9A
05D8A:  MOVLW  00
05D8C:  MOVWF  F9B
05D8E:  MOVLW  A6
05D90:  MOVWF  F9D
05D92:  MOVLW  90
05D94:  MOVWF  F9C
05D96:  MOVLW  93
05D98:  MOVWF  F89
05D9A:  BCF    F84.5
05D9C:  CLRF   xD0
05D9E:  CLRF   xCF
05DA0:  CLRF   xD5
05DA2:  CLRF   xD4
05DA4:  CLRF   xD3
05DA6:  CLRF   xD2
05DA8:  MOVLB  F
05DAA:  CLRF   x0C
05DAC:  CLRF   x14
05DAE:  CLRF   x1C
05DB0:  CLRF   x21
05DB2:  CLRF   x29
05DB4:  CLRF   x35
05DB6:  CLRF   x36
05DB8:  CLRF   x37
05DBA:  CLRF   x34
05DBC:  CLRF   x31
05DBE:  CLRF   x32
05DC0:  CLRF   x33
05DC2:  CLRF   x30
05DC4:  MOVLW  20
05DC6:  MOVLB  4
05DC8:  MOVWF  xD9
05DCA:  MOVLW  08
05DCC:  MOVWF  xD8
05DCE:  MOVLW  20
05DD0:  MOVWF  xDD
05DD2:  MOVLW  4C
05DD4:  MOVWF  xDC
05DD6:  MOVLW  24
05DD8:  MOVWF  xE1
05DDA:  MOVLW  D4
05DDC:  MOVWF  xE0
05DDE:  MOVLW  26
05DE0:  MOVWF  xE5
05DE2:  MOVLW  88
05DE4:  MOVWF  xE4
05DE6:  MOVLW  28
05DE8:  MOVWF  xE9
05DEA:  MOVLW  40
05DEC:  MOVWF  xE8
05DEE:  MOVLW  29
05DF0:  MOVWF  xED
05DF2:  MOVLW  AA
05DF4:  MOVWF  xEC
05DF6:  MOVLW  2D
05DF8:  MOVWF  xF1
05DFA:  MOVLW  C0
05DFC:  MOVWF  xF0
05DFE:  MOVLW  35
05E00:  MOVWF  xF5
05E02:  MOVLW  50
05E04:  MOVWF  xF4
05E06:  MOVLW  38
05E08:  MOVWF  xF9
05E0A:  MOVLW  64
05E0C:  MOVWF  xF8
05E0E:  MOVLW  39
05E10:  MOVWF  xFD
05E12:  MOVLW  9E
05E14:  MOVWF  xFC
05E16:  MOVLW  3B
05E18:  MOVLB  5
05E1A:  MOVWF  x01
05E1C:  MOVLW  90
05E1E:  MOVWF  x00
05E20:  MOVLW  3F
05E22:  MOVWF  x05
05E24:  MOVLW  10
05E26:  MOVWF  x04
05E28:  MOVLW  43
05E2A:  MOVWF  x09
05E2C:  MOVLW  7E
05E2E:  MOVWF  x08
05E30:  MOVLW  47
05E32:  MOVWF  x0D
05E34:  MOVLW  4C
05E36:  MOVWF  x0C
05E38:  MOVLW  47
05E3A:  MOVWF  x11
05E3C:  MOVLW  52
05E3E:  MOVWF  x10
05E40:  MOVLW  48
05E42:  MOVWF  x15
05E44:  MOVLW  58
05E46:  MOVWF  x14
05E48:  MOVLW  4E
05E4A:  MOVWF  x19
05E4C:  MOVLW  10
05E4E:  MOVWF  x18
05E50:  MOVLW  50
05E52:  MOVWF  x1D
05E54:  MOVLW  24
05E56:  MOVWF  x1C
05E58:  MOVLW  57
05E5A:  MOVWF  x21
05E5C:  MOVLW  60
05E5E:  MOVWF  x20
05E60:  MOVLW  58
05E62:  MOVWF  x25
05E64:  MOVLW  8A
05E66:  MOVWF  x24
05E68:  MOVLW  5A
05E6A:  MOVWF  x29
05E6C:  MOVLW  3E
05E6E:  MOVWF  x28
05E70:  BRA    5FF4
05E72:  DATA 02,00
05E74:  DATA 1A,00
05E76:  DATA 00,01
05E78:  DATA 00,60
05E7A:  DATA 02,09
05E7C:  DATA C0,00
05E7E:  DATA 05,80
05E80:  DATA 7F,00
05E82:  DATA 00,00
05E84:  DATA 7F,0B
05E86:  DATA C0,00
05E88:  DATA 05,80
05E8A:  DATA 7F,00
05E8C:  DATA 00,00
05E8E:  DATA 7F,07
05E90:  DATA C0,00
05E92:  DATA 01,80
05E94:  DATA 7F,17
05E96:  DATA C0,00
05E98:  DATA 01,80
05E9A:  DATA 7F,17
05E9C:  DATA C0,00
05E9E:  DATA 01,80
05EA0:  DATA 7F,07
05EA2:  DATA C0,00
05EA4:  DATA 01,80
05EA6:  DATA 7F,07
05EA8:  DATA C0,00
05EAA:  DATA 01,80
05EAC:  DATA 7F,07
05EAE:  DATA C0,00
05EB0:  DATA 01,80
05EB2:  DATA 7F,07
05EB4:  DATA C0,00
05EB6:  DATA 01,80
05EB8:  DATA 7F,07
05EBA:  DATA C0,00
05EBC:  DATA 01,80
05EBE:  DATA 7F,07
05EC0:  DATA C0,00
05EC2:  DATA 01,80
05EC4:  DATA 7F,0B
05EC6:  DATA C0,00
05EC8:  DATA 32,41
05ECA:  DATA 0F,00
05ECC:  DATA 06,41
05ECE:  DATA 4F,00
05ED0:  DATA 3C,44
05ED2:  DATA 8F,00
05ED4:  DATA 01,04
05ED6:  DATA D1,00
05ED8:  DATA 02,04
05EDA:  DATA D6,2A
05EDC:  DATA 05,02
05EDE:  DATA 04,DA
05EE0:  DATA 2D,05
05EE2:  DATA 02,04
05EE4:  DATA DE,30
05EE6:  DATA 05,02
05EE8:  DATA 04,E2
05EEA:  DATA 37,05
05EEC:  DATA 02,04
05EEE:  DATA E6,3E
05EF0:  DATA 05,02
05EF2:  DATA 04,EA
05EF4:  DATA 46,05
05EF6:  DATA 02,04
05EF8:  DATA EE,4E
05EFA:  DATA 05,02
05EFC:  DATA 04,F2
05EFE:  DATA 53,05
05F00:  DATA 02,04
05F02:  DATA F6,58
05F04:  DATA 05,02
05F06:  DATA 04,FA
05F08:  DATA 5C,05
05F0A:  DATA 02,04
05F0C:  DATA FE,60
05F0E:  DATA 05,02
05F10:  DATA 05,02
05F12:  DATA 67,05
05F14:  DATA 02,05
05F16:  DATA 06,6D
05F18:  DATA 05,02
05F1A:  DATA 05,0A
05F1C:  DATA 73,05
05F1E:  DATA 02,05
05F20:  DATA 0E,79
05F22:  DATA 05,02
05F24:  DATA 05,12
05F26:  DATA 7F,05
05F28:  DATA 02,05
05F2A:  DATA 16,84
05F2C:  DATA 05,02
05F2E:  DATA 05,1A
05F30:  DATA 8D,05
05F32:  DATA 02,05
05F34:  DATA 1E,95
05F36:  DATA 05,02
05F38:  DATA 05,22
05F3A:  DATA 9C,05
05F3C:  DATA 02,05
05F3E:  DATA 26,A3
05F40:  DATA 05,78
05F42:  DATA 05,2A
05F44:  DATA 67,72
05F46:  DATA 00,67
05F48:  DATA 73,00
05F4A:  DATA 67,43
05F4C:  DATA 68,4D
05F4E:  DATA 61,70
05F50:  DATA 00,73
05F52:  DATA 43,68
05F54:  DATA 4D,61
05F56:  DATA 70,00
05F58:  DATA 67,43
05F5A:  DATA 68,4D
05F5C:  DATA 6F,64
05F5E:  DATA 65,00
05F60:  DATA 73,43
05F62:  DATA 68,4D
05F64:  DATA 6F,64
05F66:  DATA 65,00
05F68:  DATA 67,50
05F6A:  DATA 49,44
05F6C:  DATA 00,73
05F6E:  DATA 50,49
05F70:  DATA 44,00
05F72:  DATA 67,53
05F74:  DATA 50,00
05F76:  DATA 73,53
05F78:  DATA 50,00
05F7A:  DATA 67,53
05F7C:  DATA 43,61
05F7E:  DATA 6C,73
05F80:  DATA 00,67
05F82:  DATA 53,43
05F84:  DATA 61,6C
05F86:  DATA 00,73
05F88:  DATA 53,43
05F8A:  DATA 61,6C
05F8C:  DATA 00,67
05F8E:  DATA 4D,43
05F90:  DATA 61,6C
05F92:  DATA 00,73
05F94:  DATA 4D,43
05F96:  DATA 61,6C
05F98:  DATA 00,67
05F9A:  DATA 4D,6F
05F9C:  DATA 6E,00
05F9E:  DATA 67,50
05FA0:  DATA 49,44
05FA2:  DATA 64,61
05FA4:  DATA 74,61
05FA6:  DATA 00,67
05FA8:  DATA 49,50
05FAA:  DATA 64,61
05FAC:  DATA 74,61
05FAE:  DATA 00,67
05FB0:  DATA 4D,61
05FB2:  DATA 6E,4F
05FB4:  DATA 50,00
05FB6:  DATA 73,4D
05FB8:  DATA 61,6E
05FBA:  DATA 4F,50
05FBC:  DATA 04,C0
05FBE:  DATA 00,32
05FC0:  DATA 80,AE
05FC2:  DATA 05,01
05FC4:  DATA B6,05
05FC6:  DATA 02,C6
05FC8:  DATA 05,53
05FCA:  DATA 55,43
05FCC:  DATA 43,45
05FCE:  DATA 53,53
05FD0:  DATA 00,49
05FD2:  DATA 4E,56
05FD4:  DATA 41,4C
05FD6:  DATA 49,44
05FD8:  DATA 20,43
05FDA:  DATA 4F,4D
05FDC:  DATA 4D,41
05FDE:  DATA 4E,44
05FE0:  DATA 00,49
05FE2:  DATA 4E,56
05FE4:  DATA 41,4C
05FE6:  DATA 49,44
05FE8:  DATA 20,50
05FEA:  DATA 41,52
05FEC:  DATA 41,4D
05FEE:  DATA 45,54
05FF0:  DATA 45,52
05FF2:  DATA 00,00
05FF4:  MOVLW  00
05FF6:  MOVWF  FF8
05FF8:  MOVLW  5E
05FFA:  MOVWF  FF7
05FFC:  MOVLW  72
05FFE:  MOVWF  FF6
06000:  TBLRD*+
06002:  MOVF   FF5,W
06004:  MOVWF  00
06006:  XORLW  00
06008:  BZ    6030
0600A:  TBLRD*+
0600C:  MOVF   FF5,W
0600E:  MOVWF  01
06010:  BTFSC  FE8.7
06012:  BRA    601E
06014:  ANDLW  3F
06016:  MOVWF  FEA
06018:  TBLRD*+
0601A:  MOVFF  FF5,FE9
0601E:  BTFSC  01.6
06020:  TBLRD*+
06022:  BTFSS  01.6
06024:  TBLRD*+
06026:  MOVFF  FF5,FEE
0602A:  DCFSNZ 00,F
0602C:  BRA    6000
0602E:  BRA    6022
06030:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
06032:  MOVLB  0
06034:  GOTO   0334
....................    params_init();                // load parameters
06038:  GOTO   05DC
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0603C:  GOTO   0796
....................    control_init();               // initialize the output control DACs
06040:  GOTO   082E
....................    output_high(EN_EXC);
06044:  MOVLW  E8
06046:  MOVWF  F8B
06048:  BSF    F86.0
....................    serial_init();                // setup the serial port
0604A:  GOTO   09FE
.................... //!   event_timer_init();
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0604E:  MOVLW  C0
06050:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
06052:  GOTO   0DC4
.................... //!      sensor_monitor_task();     //get magnetoresistive sensor data
....................       control_task();            //output control
06056:  GOTO   1686
....................       serial_task();             //serial port 
0605A:  GOTO   174A
....................       
.................... //!      adcVals[0].sinRaw = ads_read_data(0);
.................... //!      adcVals[0].cosRaw = ads_read_data(1);
.................... //!      adcVals[1].sinRaw = ads_read_data(2);
.................... //!      adcVals[1].cosRaw = ads_read_data(3);
.................... //!      
.................... //!      signed int32 xs = adcVals[0].sinRaw;
.................... //!      signed int32 xc = adcVals[0].cosRaw;
.................... //!      
.................... //!      signed int32 ys = adcVals[1].sinRaw;
.................... //!      signed int32 yc = adcVals[1].cosRaw;
....................       
.................... //!      fprintf(SERIAL, "y= %Ld, %Ld | x= %Ld, %Ld\r\n", ys, yc, xs, xc);
....................       
....................       signed int32 xs = ads_read_data(0);
0605E:  MOVLB  5
06060:  CLRF   xE9
06062:  MOVLB  0
06064:  CALL   1C7C
06068:  MOVFF  03,5DC
0606C:  MOVFF  02,5DB
06070:  MOVFF  01,5DA
06074:  MOVFF  00,5D9
....................       fprintf(SERIAL, "%Ld\r\n", xs);
06078:  MOVLW  41
0607A:  MOVWF  FE9
0607C:  MOVFF  5DC,5EC
06080:  MOVFF  5DB,5EB
06084:  MOVFF  5DA,5EA
06088:  MOVFF  5D9,5E9
0608C:  CALL   1D6E
06090:  MOVLW  0D
06092:  MOVLB  5
06094:  MOVWF  xF5
06096:  MOVLB  0
06098:  CALL   16FE
0609C:  MOVLW  0A
0609E:  MOVLB  5
060A0:  MOVWF  xF5
060A2:  MOVLB  0
060A4:  CALL   16FE
....................       
....................       signed int32 xc = ads_read_data(1);
060A8:  MOVLW  01
060AA:  MOVLB  5
060AC:  MOVWF  xE9
060AE:  MOVLB  0
060B0:  CALL   1C7C
060B4:  MOVFF  03,5E0
060B8:  MOVFF  02,5DF
060BC:  MOVFF  01,5DE
060C0:  MOVFF  00,5DD
....................       fprintf(SERIAL, "%Ld\r\n", xc);
060C4:  MOVLW  41
060C6:  MOVWF  FE9
060C8:  MOVFF  5E0,5EC
060CC:  MOVFF  5DF,5EB
060D0:  MOVFF  5DE,5EA
060D4:  MOVFF  5DD,5E9
060D8:  CALL   1D6E
060DC:  MOVLW  0D
060DE:  MOVLB  5
060E0:  MOVWF  xF5
060E2:  MOVLB  0
060E4:  CALL   16FE
060E8:  MOVLW  0A
060EA:  MOVLB  5
060EC:  MOVWF  xF5
060EE:  MOVLB  0
060F0:  CALL   16FE
....................       
....................       signed int32 ys = ads_read_data(2);
060F4:  MOVLW  02
060F6:  MOVLB  5
060F8:  MOVWF  xE9
060FA:  MOVLB  0
060FC:  CALL   1C7C
06100:  MOVFF  03,5E4
06104:  MOVFF  02,5E3
06108:  MOVFF  01,5E2
0610C:  MOVFF  00,5E1
....................       fprintf(SERIAL, "%Ld\r\n", ys);
06110:  MOVLW  41
06112:  MOVWF  FE9
06114:  MOVFF  5E4,5EC
06118:  MOVFF  5E3,5EB
0611C:  MOVFF  5E2,5EA
06120:  MOVFF  5E1,5E9
06124:  CALL   1D6E
06128:  MOVLW  0D
0612A:  MOVLB  5
0612C:  MOVWF  xF5
0612E:  MOVLB  0
06130:  CALL   16FE
06134:  MOVLW  0A
06136:  MOVLB  5
06138:  MOVWF  xF5
0613A:  MOVLB  0
0613C:  CALL   16FE
....................       
....................       signed int32 yc = ads_read_data(3);
06140:  MOVLW  03
06142:  MOVLB  5
06144:  MOVWF  xE9
06146:  MOVLB  0
06148:  CALL   1C7C
0614C:  MOVFF  03,5E8
06150:  MOVFF  02,5E7
06154:  MOVFF  01,5E6
06158:  MOVFF  00,5E5
....................       fprintf(SERIAL, "%Ld\r\n", yc);
0615C:  MOVLW  41
0615E:  MOVWF  FE9
06160:  MOVFF  5E8,5EC
06164:  MOVFF  5E7,5EB
06168:  MOVFF  5E6,5EA
0616C:  MOVFF  5E5,5E9
06170:  CALL   1D6E
06174:  MOVLW  0D
06176:  MOVLB  5
06178:  MOVWF  xF5
0617A:  MOVLB  0
0617C:  CALL   16FE
06180:  MOVLW  0A
06182:  MOVLB  5
06184:  MOVWF  xF5
06186:  MOVLB  0
06188:  CALL   16FE
....................       
....................       command_handler_task();    //execute commands
0618C:  BRA    5BF4
....................       
....................       delay_ms(500);
0618E:  MOVLW  02
06190:  MOVLB  5
06192:  MOVWF  xE9
06194:  MOVLW  FA
06196:  MOVWF  xEE
06198:  MOVLB  0
0619A:  CALL   03CA
0619E:  MOVLB  5
061A0:  DECFSZ xE9,F
061A2:  BRA    6194
061A4:  MOVLB  0
061A6:  BRA    6052
....................    }
.................... }
061A8:  BRA    61A8

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: CF3F   MCLR NOPUT NOLPBOR NOBROWNOUT BORV19 ZCDDIS PPS1WAY NOSTVREN DEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
