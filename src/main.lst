CCS PCH C Compiler, Version 5.117, 2138               11-Dec-25 15:03

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43822 bytes (67%)
                           Largest free fragment is 21712
               RAM used:   1798 (50%) at main() level
                           1911 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A314
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   0120
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0292
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00366:  DATA 32,30
00368:  DATA 32,35
0036A:  DATA 31,32
0036C:  DATA 30,38
0036E:  DATA 00,00
00370:  DATA 30,30
00372:  DATA 30,30
00374:  DATA 00,00
00376:  DATA 25,64
00378:  DATA 2C,4D
0037A:  DATA 41,4E
0037C:  DATA 55,41
0037E:  DATA 4C,2C
00380:  DATA 00,00
00382:  DATA 25,64
00384:  DATA 2C,4D
00386:  DATA 41,47
00388:  DATA 53,4E
0038A:  DATA 53,2C
0038C:  DATA 00,00
0038E:  DATA 43,4E
00390:  DATA 54,2C
00392:  DATA 25,75
00394:  DATA 2C,25
00396:  DATA 2E,30
00398:  DATA 66,2C
0039A:  DATA 25,2E
0039C:  DATA 30,66
0039E:  DATA 0D,0A
003A0:  DATA 00,00
003A2:  DATA 50,4F
003A4:  DATA 53,2C
003A6:  DATA 25,75
003A8:  DATA 2C,25
003AA:  DATA 33,2E
003AC:  DATA 33,66
003AE:  DATA 0D,0A
003B0:  DATA 00,00
003B2:  DATA 4F,55
003B4:  DATA 54,2C
003B6:  DATA 25,75
003B8:  DATA 2C,2D
003BA:  DATA 2C,25
003BC:  DATA 4C,75
003BE:  DATA 0D,0A
003C0:  DATA 00,00
003C2:  DATA 4F,55
003C4:  DATA 54,2C
003C6:  DATA 25,75
003C8:  DATA 2C,2B
003CA:  DATA 2C,25
003CC:  DATA 4C,75
003CE:  DATA 0D,0A
003D0:  DATA 00,00
*
00716:  ADDWF  FE8,W
00718:  CLRF   FF7
0071A:  RLCF   FF7,F
0071C:  ADDLW  31
0071E:  MOVWF  FF6
00720:  MOVLW  07
00722:  ADDWFC FF7,F
00724:  TBLRD*-
00726:  MOVF   FF5,W
00728:  MOVWF  FFA
0072A:  TBLRD*
0072C:  MOVF   FF5,W
0072E:  MOVWF  FF9
00730:  DATA E0,06
00732:  DATA EA,06
00734:  DATA F4,06
00736:  DATA FE,06
*
008BE:  MOVLB  7
008C0:  MOVF   x41,W
008C2:  MULWF  x43
008C4:  MOVFF  FF3,01
008C8:  MOVFF  FF4,00
008CC:  MULWF  x44
008CE:  MOVF   FF3,W
008D0:  ADDWF  00,F
008D2:  MOVF   x42,W
008D4:  MULWF  x43
008D6:  MOVF   FF3,W
008D8:  ADDWFC 00,W
008DA:  MOVWF  02
008DC:  MOVLB  0
008DE:  RETURN 0
008E0:  MOVLB  7
008E2:  MOVF   x3B,W
008E4:  CLRF   01
008E6:  SUBWF  x3A,W
008E8:  BC    08F0
008EA:  MOVFF  73A,00
008EE:  BRA    0908
008F0:  CLRF   00
008F2:  MOVLW  08
008F4:  MOVWF  x3C
008F6:  RLCF   x3A,F
008F8:  RLCF   00,F
008FA:  MOVF   x3B,W
008FC:  SUBWF  00,W
008FE:  BTFSC  FD8.0
00900:  MOVWF  00
00902:  RLCF   01,F
00904:  DECFSZ x3C,F
00906:  BRA    08F6
00908:  MOVLB  0
0090A:  RETURN 0
*
00D72:  MOVLW  8E
00D74:  MOVWF  00
00D76:  MOVFF  74B,01
00D7A:  MOVFF  74A,02
00D7E:  CLRF   03
00D80:  MOVF   01,F
00D82:  BNZ   0D96
00D84:  MOVFF  02,01
00D88:  CLRF   02
00D8A:  MOVLW  08
00D8C:  SUBWF  00,F
00D8E:  MOVF   01,F
00D90:  BNZ   0D96
00D92:  CLRF   00
00D94:  BRA    0DA6
00D96:  BCF    FD8.0
00D98:  BTFSC  01.7
00D9A:  BRA    0DA4
00D9C:  RLCF   02,F
00D9E:  RLCF   01,F
00DA0:  DECF   00,F
00DA2:  BRA    0D96
00DA4:  BCF    01.7
00DA6:  RETURN 0
00DA8:  MOVLB  7
00DAA:  MOVF   x50,W
00DAC:  BTFSC  FD8.2
00DAE:  BRA    0E92
00DB0:  MOVWF  00
00DB2:  MOVF   x54,W
00DB4:  BTFSC  FD8.2
00DB6:  BRA    0E92
00DB8:  ADDWF  00,F
00DBA:  BNC   0DC4
00DBC:  MOVLW  81
00DBE:  ADDWF  00,F
00DC0:  BC    0E92
00DC2:  BRA    0DCC
00DC4:  MOVLW  7F
00DC6:  SUBWF  00,F
00DC8:  BNC   0E92
00DCA:  BZ    0E92
00DCC:  MOVFF  751,758
00DD0:  MOVF   x55,W
00DD2:  XORWF  x58,F
00DD4:  BSF    x51.7
00DD6:  BSF    x55.7
00DD8:  MOVF   x53,W
00DDA:  MULWF  x57
00DDC:  MOVFF  FF4,75A
00DE0:  MOVF   x52,W
00DE2:  MULWF  x56
00DE4:  MOVFF  FF4,03
00DE8:  MOVFF  FF3,759
00DEC:  MULWF  x57
00DEE:  MOVF   FF3,W
00DF0:  ADDWF  x5A,F
00DF2:  MOVF   FF4,W
00DF4:  ADDWFC x59,F
00DF6:  MOVLW  00
00DF8:  ADDWFC 03,F
00DFA:  MOVF   x53,W
00DFC:  MULWF  x56
00DFE:  MOVF   FF3,W
00E00:  ADDWF  x5A,F
00E02:  MOVF   FF4,W
00E04:  ADDWFC x59,F
00E06:  MOVLW  00
00E08:  CLRF   02
00E0A:  ADDWFC 03,F
00E0C:  ADDWFC 02,F
00E0E:  MOVF   x51,W
00E10:  MULWF  x57
00E12:  MOVF   FF3,W
00E14:  ADDWF  x59,F
00E16:  MOVF   FF4,W
00E18:  ADDWFC 03,F
00E1A:  MOVLW  00
00E1C:  ADDWFC 02,F
00E1E:  MOVF   x51,W
00E20:  MULWF  x56
00E22:  MOVF   FF3,W
00E24:  ADDWF  03,F
00E26:  MOVF   FF4,W
00E28:  ADDWFC 02,F
00E2A:  MOVLW  00
00E2C:  CLRF   01
00E2E:  ADDWFC 01,F
00E30:  MOVF   x53,W
00E32:  MULWF  x55
00E34:  MOVF   FF3,W
00E36:  ADDWF  x59,F
00E38:  MOVF   FF4,W
00E3A:  ADDWFC 03,F
00E3C:  MOVLW  00
00E3E:  ADDWFC 02,F
00E40:  ADDWFC 01,F
00E42:  MOVF   x52,W
00E44:  MULWF  x55
00E46:  MOVF   FF3,W
00E48:  ADDWF  03,F
00E4A:  MOVF   FF4,W
00E4C:  ADDWFC 02,F
00E4E:  MOVLW  00
00E50:  ADDWFC 01,F
00E52:  MOVF   x51,W
00E54:  MULWF  x55
00E56:  MOVF   FF3,W
00E58:  ADDWF  02,F
00E5A:  MOVF   FF4,W
00E5C:  ADDWFC 01,F
00E5E:  INCF   00,F
00E60:  BTFSC  01.7
00E62:  BRA    0E6E
00E64:  RLCF   x59,F
00E66:  RLCF   03,F
00E68:  RLCF   02,F
00E6A:  RLCF   01,F
00E6C:  DECF   00,F
00E6E:  MOVLW  00
00E70:  BTFSS  x59.7
00E72:  BRA    0E88
00E74:  INCF   03,F
00E76:  ADDWFC 02,F
00E78:  ADDWFC 01,F
00E7A:  MOVF   01,W
00E7C:  BNZ   0E88
00E7E:  MOVF   02,W
00E80:  BNZ   0E88
00E82:  MOVF   03,W
00E84:  BNZ   0E88
00E86:  INCF   00,F
00E88:  BTFSC  x58.7
00E8A:  BSF    01.7
00E8C:  BTFSS  x58.7
00E8E:  BCF    01.7
00E90:  BRA    0E9A
00E92:  CLRF   00
00E94:  CLRF   01
00E96:  CLRF   02
00E98:  CLRF   03
00E9A:  MOVLB  0
00E9C:  RETURN 0
00E9E:  MOVLW  80
00EA0:  BTFSS  FD8.1
00EA2:  BRA    0EA8
00EA4:  MOVLB  7
00EA6:  XORWF  x4F,F
00EA8:  MOVLB  7
00EAA:  CLRF   x54
00EAC:  CLRF   x55
00EAE:  MOVFF  74B,753
00EB2:  MOVF   x4F,W
00EB4:  XORWF  x53,F
00EB6:  MOVF   x4A,W
00EB8:  BTFSC  FD8.2
00EBA:  BRA    107A
00EBC:  MOVWF  x52
00EBE:  MOVWF  00
00EC0:  MOVF   x4E,W
00EC2:  BTFSC  FD8.2
00EC4:  BRA    108C
00EC6:  SUBWF  x52,F
00EC8:  BTFSC  FD8.2
00ECA:  BRA    0FD2
00ECC:  BNC   0F4A
00ECE:  MOVFF  74F,758
00ED2:  BSF    x58.7
00ED4:  MOVFF  750,757
00ED8:  MOVFF  751,756
00EDC:  CLRF   x55
00EDE:  BCF    FD8.0
00EE0:  RRCF   x58,F
00EE2:  RRCF   x57,F
00EE4:  RRCF   x56,F
00EE6:  RRCF   x55,F
00EE8:  DECFSZ x52,F
00EEA:  BRA    0EDC
00EEC:  BTFSS  x53.7
00EEE:  BRA    0EF6
00EF0:  BSF    x54.0
00EF2:  BRA    10B4
00EF4:  BCF    x54.0
00EF6:  BCF    x52.0
00EF8:  BSF    x54.4
00EFA:  MOVLW  07
00EFC:  MOVWF  FEA
00EFE:  MOVLW  4D
00F00:  MOVWF  FE9
00F02:  BRA    10DA
00F04:  BCF    x54.4
00F06:  BTFSC  x53.7
00F08:  BRA    0F1E
00F0A:  BTFSS  x52.0
00F0C:  BRA    0F34
00F0E:  RRCF   x58,F
00F10:  RRCF   x57,F
00F12:  RRCF   x56,F
00F14:  RRCF   x55,F
00F16:  INCF   00,F
00F18:  BTFSC  FD8.2
00F1A:  BRA    10AA
00F1C:  BRA    0F34
00F1E:  BTFSC  x58.7
00F20:  BRA    0F3A
00F22:  BCF    FD8.0
00F24:  RLCF   x55,F
00F26:  RLCF   x56,F
00F28:  RLCF   x57,F
00F2A:  RLCF   x58,F
00F2C:  DECF   00,F
00F2E:  BTFSC  FD8.2
00F30:  BRA    10AA
00F32:  BRA    0F1E
00F34:  BSF    x54.6
00F36:  BRA    1012
00F38:  BCF    x54.6
00F3A:  MOVFF  74B,753
00F3E:  BTFSS  x4B.7
00F40:  BRA    0F46
00F42:  BSF    x58.7
00F44:  BRA    109C
00F46:  BCF    x58.7
00F48:  BRA    109C
00F4A:  MOVFF  74E,752
00F4E:  MOVFF  74E,00
00F52:  MOVF   x4A,W
00F54:  SUBWF  x52,F
00F56:  MOVFF  74B,758
00F5A:  BSF    x58.7
00F5C:  MOVFF  74C,757
00F60:  MOVFF  74D,756
00F64:  CLRF   x55
00F66:  BCF    FD8.0
00F68:  RRCF   x58,F
00F6A:  RRCF   x57,F
00F6C:  RRCF   x56,F
00F6E:  RRCF   x55,F
00F70:  DECFSZ x52,F
00F72:  BRA    0F64
00F74:  BTFSS  x53.7
00F76:  BRA    0F7E
00F78:  BSF    x54.1
00F7A:  BRA    10B4
00F7C:  BCF    x54.1
00F7E:  BCF    x52.0
00F80:  BSF    x54.5
00F82:  MOVLW  07
00F84:  MOVWF  FEA
00F86:  MOVLW  51
00F88:  MOVWF  FE9
00F8A:  BRA    10DA
00F8C:  BCF    x54.5
00F8E:  BTFSC  x53.7
00F90:  BRA    0FA6
00F92:  BTFSS  x52.0
00F94:  BRA    0FBC
00F96:  RRCF   x58,F
00F98:  RRCF   x57,F
00F9A:  RRCF   x56,F
00F9C:  RRCF   x55,F
00F9E:  INCF   00,F
00FA0:  BTFSC  FD8.2
00FA2:  BRA    10AA
00FA4:  BRA    0FBC
00FA6:  BTFSC  x58.7
00FA8:  BRA    0FC2
00FAA:  BCF    FD8.0
00FAC:  RLCF   x55,F
00FAE:  RLCF   x56,F
00FB0:  RLCF   x57,F
00FB2:  RLCF   x58,F
00FB4:  DECF   00,F
00FB6:  BTFSC  FD8.2
00FB8:  BRA    10AA
00FBA:  BRA    0FA6
00FBC:  BSF    x54.7
00FBE:  BRA    1012
00FC0:  BCF    x54.7
00FC2:  MOVFF  74F,753
00FC6:  BTFSS  x4F.7
00FC8:  BRA    0FCE
00FCA:  BSF    x58.7
00FCC:  BRA    109C
00FCE:  BCF    x58.7
00FD0:  BRA    109C
00FD2:  MOVFF  74F,758
00FD6:  BSF    x58.7
00FD8:  MOVFF  750,757
00FDC:  MOVFF  751,756
00FE0:  BTFSS  x53.7
00FE2:  BRA    0FEC
00FE4:  BCF    x58.7
00FE6:  BSF    x54.2
00FE8:  BRA    10B4
00FEA:  BCF    x54.2
00FEC:  CLRF   x55
00FEE:  BCF    x52.0
00FF0:  MOVLW  07
00FF2:  MOVWF  FEA
00FF4:  MOVLW  4D
00FF6:  MOVWF  FE9
00FF8:  BRA    10DA
00FFA:  BTFSC  x53.7
00FFC:  BRA    1036
00FFE:  MOVFF  74B,753
01002:  BTFSS  x52.0
01004:  BRA    1012
01006:  RRCF   x58,F
01008:  RRCF   x57,F
0100A:  RRCF   x56,F
0100C:  RRCF   x55,F
0100E:  INCF   00,F
01010:  BZ    10AA
01012:  BTFSS  x55.7
01014:  BRA    102C
01016:  INCF   x56,F
01018:  BNZ   102C
0101A:  INCF   x57,F
0101C:  BNZ   102C
0101E:  INCF   x58,F
01020:  BNZ   102C
01022:  RRCF   x58,F
01024:  RRCF   x57,F
01026:  RRCF   x56,F
01028:  INCF   00,F
0102A:  BZ    10AA
0102C:  BTFSC  x54.6
0102E:  BRA    0F38
01030:  BTFSC  x54.7
01032:  BRA    0FC0
01034:  BRA    106E
01036:  MOVLW  80
01038:  XORWF  x58,F
0103A:  BTFSS  x58.7
0103C:  BRA    1046
0103E:  BRA    10B4
01040:  MOVFF  74F,753
01044:  BRA    105A
01046:  MOVFF  74B,753
0104A:  MOVF   x58,F
0104C:  BNZ   105A
0104E:  MOVF   x57,F
01050:  BNZ   105A
01052:  MOVF   x56,F
01054:  BNZ   105A
01056:  CLRF   00
01058:  BRA    109C
0105A:  BTFSC  x58.7
0105C:  BRA    106E
0105E:  BCF    FD8.0
01060:  RLCF   x55,F
01062:  RLCF   x56,F
01064:  RLCF   x57,F
01066:  RLCF   x58,F
01068:  DECFSZ 00,F
0106A:  BRA    105A
0106C:  BRA    10AA
0106E:  BTFSS  x53.7
01070:  BRA    1076
01072:  BSF    x58.7
01074:  BRA    109C
01076:  BCF    x58.7
01078:  BRA    109C
0107A:  MOVFF  74E,00
0107E:  MOVFF  74F,758
01082:  MOVFF  750,757
01086:  MOVFF  751,756
0108A:  BRA    109C
0108C:  MOVFF  74A,00
01090:  MOVFF  74B,758
01094:  MOVFF  74C,757
01098:  MOVFF  74D,756
0109C:  MOVFF  758,01
010A0:  MOVFF  757,02
010A4:  MOVFF  756,03
010A8:  BRA    1112
010AA:  CLRF   00
010AC:  CLRF   01
010AE:  CLRF   02
010B0:  CLRF   03
010B2:  BRA    1112
010B4:  CLRF   x55
010B6:  COMF   x56,F
010B8:  COMF   x57,F
010BA:  COMF   x58,F
010BC:  COMF   x55,F
010BE:  INCF   x55,F
010C0:  BNZ   10CC
010C2:  INCF   x56,F
010C4:  BNZ   10CC
010C6:  INCF   x57,F
010C8:  BNZ   10CC
010CA:  INCF   x58,F
010CC:  BTFSC  x54.0
010CE:  BRA    0EF4
010D0:  BTFSC  x54.1
010D2:  BRA    0F7C
010D4:  BTFSC  x54.2
010D6:  BRA    0FEA
010D8:  BRA    1040
010DA:  MOVF   FEF,W
010DC:  ADDWF  x56,F
010DE:  BNC   10EA
010E0:  INCF   x57,F
010E2:  BNZ   10EA
010E4:  INCF   x58,F
010E6:  BTFSC  FD8.2
010E8:  BSF    x52.0
010EA:  MOVF   FED,F
010EC:  MOVF   FEF,W
010EE:  ADDWF  x57,F
010F0:  BNC   10F8
010F2:  INCF   x58,F
010F4:  BTFSC  FD8.2
010F6:  BSF    x52.0
010F8:  MOVF   FED,F
010FA:  MOVF   FEF,W
010FC:  BTFSC  FEF.7
010FE:  BRA    1102
01100:  XORLW  80
01102:  ADDWF  x58,F
01104:  BTFSC  FD8.0
01106:  BSF    x52.0
01108:  BTFSC  x54.4
0110A:  BRA    0F04
0110C:  BTFSC  x54.5
0110E:  BRA    0F8C
01110:  BRA    0FFA
01112:  MOVLB  0
01114:  RETURN 0
*
0166C:  ADDWF  FE8,W
0166E:  CLRF   FF7
01670:  RLCF   FF7,F
01672:  ADDLW  87
01674:  MOVWF  FF6
01676:  MOVLW  16
01678:  ADDWFC FF7,F
0167A:  TBLRD*-
0167C:  MOVF   FF5,W
0167E:  MOVWF  FFA
01680:  TBLRD*
01682:  MOVF   FF5,W
01684:  MOVWF  FF9
01686:  DATA 2E,11
01688:  DATA EE,11
0168A:  DATA AE,12
0168C:  DATA 6E,13
0168E:  DATA 2E,14
01690:  DATA EE,14
01692:  DATA AE,15
01694:  BTFSC  FD8.1
01696:  BRA    16A0
01698:  MOVLW  07
0169A:  MOVWF  FEA
0169C:  MOVLW  39
0169E:  MOVWF  FE9
016A0:  MOVLB  7
016A2:  MOVF   x34,W
016A4:  XORWF  x38,W
016A6:  ANDLW  80
016A8:  MOVWF  x3E
016AA:  BTFSS  x34.7
016AC:  BRA    16C4
016AE:  COMF   x31,F
016B0:  COMF   x32,F
016B2:  COMF   x33,F
016B4:  COMF   x34,F
016B6:  INCF   x31,F
016B8:  BTFSC  FD8.2
016BA:  INCF   x32,F
016BC:  BTFSC  FD8.2
016BE:  INCF   x33,F
016C0:  BTFSC  FD8.2
016C2:  INCF   x34,F
016C4:  BTFSS  x38.7
016C6:  BRA    16DE
016C8:  COMF   x35,F
016CA:  COMF   x36,F
016CC:  COMF   x37,F
016CE:  COMF   x38,F
016D0:  INCF   x35,F
016D2:  BTFSC  FD8.2
016D4:  INCF   x36,F
016D6:  BTFSC  FD8.2
016D8:  INCF   x37,F
016DA:  BTFSC  FD8.2
016DC:  INCF   x38,F
016DE:  CLRF   00
016E0:  CLRF   01
016E2:  CLRF   02
016E4:  CLRF   03
016E6:  CLRF   x39
016E8:  CLRF   x3A
016EA:  CLRF   x3B
016EC:  CLRF   x3C
016EE:  MOVF   x38,W
016F0:  IORWF  x37,W
016F2:  IORWF  x36,W
016F4:  IORWF  x35,W
016F6:  BZ    1750
016F8:  MOVLW  20
016FA:  MOVWF  x3D
016FC:  BCF    FD8.0
016FE:  RLCF   x31,F
01700:  RLCF   x32,F
01702:  RLCF   x33,F
01704:  RLCF   x34,F
01706:  RLCF   x39,F
01708:  RLCF   x3A,F
0170A:  RLCF   x3B,F
0170C:  RLCF   x3C,F
0170E:  MOVF   x38,W
01710:  SUBWF  x3C,W
01712:  BNZ   1724
01714:  MOVF   x37,W
01716:  SUBWF  x3B,W
01718:  BNZ   1724
0171A:  MOVF   x36,W
0171C:  SUBWF  x3A,W
0171E:  BNZ   1724
01720:  MOVF   x35,W
01722:  SUBWF  x39,W
01724:  BNC   1744
01726:  MOVF   x35,W
01728:  SUBWF  x39,F
0172A:  MOVF   x36,W
0172C:  BTFSS  FD8.0
0172E:  INCFSZ x36,W
01730:  SUBWF  x3A,F
01732:  MOVF   x37,W
01734:  BTFSS  FD8.0
01736:  INCFSZ x37,W
01738:  SUBWF  x3B,F
0173A:  MOVF   x38,W
0173C:  BTFSS  FD8.0
0173E:  INCFSZ x38,W
01740:  SUBWF  x3C,F
01742:  BSF    FD8.0
01744:  RLCF   00,F
01746:  RLCF   01,F
01748:  RLCF   02,F
0174A:  RLCF   03,F
0174C:  DECFSZ x3D,F
0174E:  BRA    16FC
01750:  BTFSS  x3E.7
01752:  BRA    176A
01754:  COMF   00,F
01756:  COMF   01,F
01758:  COMF   02,F
0175A:  COMF   03,F
0175C:  INCF   00,F
0175E:  BTFSC  FD8.2
01760:  INCF   01,F
01762:  BTFSC  FD8.2
01764:  INCF   02,F
01766:  BTFSC  FD8.2
01768:  INCF   03,F
0176A:  MOVFF  739,FEF
0176E:  MOVFF  73A,FEC
01772:  MOVFF  73B,FEC
01776:  MOVFF  73C,FEC
0177A:  MOVLB  0
0177C:  RETURN 0
*
01CDA:  MOVLW  B6
01CDC:  MOVWF  00
01CDE:  CLRF   03
01CE0:  CLRF   02
01CE2:  CLRF   01
01CE4:  MOVLB  7
01CE6:  BCF    x14.0
01CE8:  BTFSS  x13.7
01CEA:  BRA    1D04
01CEC:  BSF    x14.0
01CEE:  COMF   x10,F
01CF0:  COMF   x11,F
01CF2:  COMF   x12,F
01CF4:  COMF   x13,F
01CF6:  INCF   x10,F
01CF8:  BNZ   1D04
01CFA:  INCF   x11,F
01CFC:  BNZ   1D04
01CFE:  INCF   x12,F
01D00:  BTFSC  FD8.2
01D02:  INCF   x13,F
01D04:  MOVF   x10,W
01D06:  IORWF  x11,W
01D08:  IORWF  x12,W
01D0A:  IORWF  x13,W
01D0C:  BNZ   1D12
01D0E:  CLRF   00
01D10:  BRA    1D30
01D12:  BCF    FD8.0
01D14:  BTFSC  01.7
01D16:  BRA    1D2A
01D18:  RLCF   x10,F
01D1A:  RLCF   x11,F
01D1C:  RLCF   x12,F
01D1E:  RLCF   x13,F
01D20:  RLCF   03,F
01D22:  RLCF   02,F
01D24:  RLCF   01,F
01D26:  DECFSZ 00,F
01D28:  BRA    1D12
01D2A:  BCF    01.7
01D2C:  BTFSC  x14.0
01D2E:  BSF    01.7
01D30:  MOVLB  0
01D32:  RETURN 0
01D34:  MOVFF  747,74E
01D38:  MOVLB  7
01D3A:  MOVF   x4B,W
01D3C:  XORWF  x4E,F
01D3E:  BTFSS  x4E.7
01D40:  BRA    1D4C
01D42:  BCF    FD8.2
01D44:  BCF    FD8.0
01D46:  BTFSC  x47.7
01D48:  BSF    FD8.0
01D4A:  BRA    1DAA
01D4C:  MOVFF  747,74E
01D50:  MOVFF  74A,74F
01D54:  MOVF   x46,W
01D56:  SUBWF  x4F,F
01D58:  BZ    1D66
01D5A:  BTFSS  x4E.7
01D5C:  BRA    1DAA
01D5E:  MOVF   FD8,W
01D60:  XORLW  01
01D62:  MOVWF  FD8
01D64:  BRA    1DAA
01D66:  MOVFF  74B,74F
01D6A:  MOVF   x47,W
01D6C:  SUBWF  x4F,F
01D6E:  BZ    1D7C
01D70:  BTFSS  x4E.7
01D72:  BRA    1DAA
01D74:  MOVF   FD8,W
01D76:  XORLW  01
01D78:  MOVWF  FD8
01D7A:  BRA    1DAA
01D7C:  MOVFF  74C,74F
01D80:  MOVF   x48,W
01D82:  SUBWF  x4F,F
01D84:  BZ    1D92
01D86:  BTFSS  x4E.7
01D88:  BRA    1DAA
01D8A:  MOVF   FD8,W
01D8C:  XORLW  01
01D8E:  MOVWF  FD8
01D90:  BRA    1DAA
01D92:  MOVFF  74D,74F
01D96:  MOVF   x49,W
01D98:  SUBWF  x4F,F
01D9A:  BZ    1DA8
01D9C:  BTFSS  x4E.7
01D9E:  BRA    1DAA
01DA0:  MOVF   FD8,W
01DA2:  XORLW  01
01DA4:  MOVWF  FD8
01DA6:  BRA    1DAA
01DA8:  BCF    FD8.0
01DAA:  MOVLB  0
01DAC:  RETURN 0
01DAE:  MOVLB  7
01DB0:  MOVF   x3F,W
01DB2:  BTFSC  FD8.2
01DB4:  BRA    1F00
01DB6:  MOVWF  x4B
01DB8:  MOVF   x43,W
01DBA:  BTFSC  FD8.2
01DBC:  BRA    1F00
01DBE:  SUBWF  x4B,F
01DC0:  BNC   1DCC
01DC2:  MOVLW  7F
01DC4:  ADDWF  x4B,F
01DC6:  BTFSC  FD8.0
01DC8:  BRA    1F00
01DCA:  BRA    1DD8
01DCC:  MOVLW  81
01DCE:  SUBWF  x4B,F
01DD0:  BTFSS  FD8.0
01DD2:  BRA    1F00
01DD4:  BTFSC  FD8.2
01DD6:  BRA    1F00
01DD8:  MOVFF  74B,00
01DDC:  CLRF   01
01DDE:  CLRF   02
01DE0:  CLRF   03
01DE2:  CLRF   x4A
01DE4:  MOVFF  740,749
01DE8:  BSF    x49.7
01DEA:  MOVFF  741,748
01DEE:  MOVFF  742,747
01DF2:  MOVLW  19
01DF4:  MOVWF  x4B
01DF6:  MOVF   x46,W
01DF8:  SUBWF  x47,F
01DFA:  BC    1E16
01DFC:  MOVLW  01
01DFE:  SUBWF  x48,F
01E00:  BC    1E16
01E02:  SUBWF  x49,F
01E04:  BC    1E16
01E06:  SUBWF  x4A,F
01E08:  BC    1E16
01E0A:  INCF   x4A,F
01E0C:  INCF   x49,F
01E0E:  INCF   x48,F
01E10:  MOVF   x46,W
01E12:  ADDWF  x47,F
01E14:  BRA    1E66
01E16:  MOVF   x45,W
01E18:  SUBWF  x48,F
01E1A:  BC    1E40
01E1C:  MOVLW  01
01E1E:  SUBWF  x49,F
01E20:  BC    1E40
01E22:  SUBWF  x4A,F
01E24:  BC    1E40
01E26:  INCF   x4A,F
01E28:  INCF   x49,F
01E2A:  MOVF   x45,W
01E2C:  ADDWF  x48,F
01E2E:  MOVF   x46,W
01E30:  ADDWF  x47,F
01E32:  BNC   1E66
01E34:  INCF   x48,F
01E36:  BNZ   1E66
01E38:  INCF   x49,F
01E3A:  BNZ   1E66
01E3C:  INCF   x4A,F
01E3E:  BRA    1E66
01E40:  MOVF   x44,W
01E42:  IORLW  80
01E44:  SUBWF  x49,F
01E46:  BC    1E64
01E48:  MOVLW  01
01E4A:  SUBWF  x4A,F
01E4C:  BC    1E64
01E4E:  INCF   x4A,F
01E50:  MOVF   x44,W
01E52:  IORLW  80
01E54:  ADDWF  x49,F
01E56:  MOVF   x45,W
01E58:  ADDWF  x48,F
01E5A:  BNC   1E2E
01E5C:  INCF   x49,F
01E5E:  BNZ   1E2E
01E60:  INCF   x4A,F
01E62:  BRA    1E2E
01E64:  BSF    03.0
01E66:  DECFSZ x4B,F
01E68:  BRA    1E6C
01E6A:  BRA    1E82
01E6C:  BCF    FD8.0
01E6E:  RLCF   x47,F
01E70:  RLCF   x48,F
01E72:  RLCF   x49,F
01E74:  RLCF   x4A,F
01E76:  BCF    FD8.0
01E78:  RLCF   03,F
01E7A:  RLCF   02,F
01E7C:  RLCF   01,F
01E7E:  RLCF   x4C,F
01E80:  BRA    1DF6
01E82:  BTFSS  x4C.0
01E84:  BRA    1E92
01E86:  BCF    FD8.0
01E88:  RRCF   01,F
01E8A:  RRCF   02,F
01E8C:  RRCF   03,F
01E8E:  RRCF   x4C,F
01E90:  BRA    1E96
01E92:  DECF   00,F
01E94:  BZ    1F00
01E96:  BTFSC  x4C.7
01E98:  BRA    1ED6
01E9A:  BCF    FD8.0
01E9C:  RLCF   x47,F
01E9E:  RLCF   x48,F
01EA0:  RLCF   x49,F
01EA2:  RLCF   x4A,F
01EA4:  MOVF   x46,W
01EA6:  SUBWF  x47,F
01EA8:  BC    1EB8
01EAA:  MOVLW  01
01EAC:  SUBWF  x48,F
01EAE:  BC    1EB8
01EB0:  SUBWF  x49,F
01EB2:  BC    1EB8
01EB4:  SUBWF  x4A,F
01EB6:  BNC   1EEC
01EB8:  MOVF   x45,W
01EBA:  SUBWF  x48,F
01EBC:  BC    1EC8
01EBE:  MOVLW  01
01EC0:  SUBWF  x49,F
01EC2:  BC    1EC8
01EC4:  SUBWF  x4A,F
01EC6:  BNC   1EEC
01EC8:  MOVF   x44,W
01ECA:  IORLW  80
01ECC:  SUBWF  x49,F
01ECE:  BC    1ED6
01ED0:  MOVLW  01
01ED2:  SUBWF  x4A,F
01ED4:  BNC   1EEC
01ED6:  INCF   03,F
01ED8:  BNZ   1EEC
01EDA:  INCF   02,F
01EDC:  BNZ   1EEC
01EDE:  INCF   01,F
01EE0:  BNZ   1EEC
01EE2:  INCF   00,F
01EE4:  BZ    1F00
01EE6:  RRCF   01,F
01EE8:  RRCF   02,F
01EEA:  RRCF   03,F
01EEC:  MOVFF  740,74B
01EF0:  MOVF   x44,W
01EF2:  XORWF  x4B,F
01EF4:  BTFSS  x4B.7
01EF6:  BRA    1EFC
01EF8:  BSF    01.7
01EFA:  BRA    1F08
01EFC:  BCF    01.7
01EFE:  BRA    1F08
01F00:  CLRF   00
01F02:  CLRF   01
01F04:  CLRF   02
01F06:  CLRF   03
01F08:  MOVLB  0
01F0A:  RETURN 0
*
026B6:  ADDWF  FE8,W
026B8:  CLRF   FF7
026BA:  RLCF   FF7,F
026BC:  ADDLW  D1
026BE:  MOVWF  FF6
026C0:  MOVLW  26
026C2:  ADDWFC FF7,F
026C4:  TBLRD*-
026C6:  MOVF   FF5,W
026C8:  MOVWF  FFA
026CA:  TBLRD*
026CC:  MOVF   FF5,W
026CE:  MOVWF  FF9
026D0:  DATA BE,25
026D2:  DATA D8,25
026D4:  DATA 2C,26
026D6:  DATA 90,26
026D8:  MOVLW  8E
026DA:  MOVWF  00
026DC:  MOVFF  73D,01
026E0:  MOVFF  73C,02
026E4:  CLRF   03
026E6:  BTFSS  01.7
026E8:  BRA    26F4
026EA:  COMF   01,F
026EC:  COMF   02,F
026EE:  INCF   02,F
026F0:  BNZ   26F4
026F2:  INCF   01,F
026F4:  MOVF   01,F
026F6:  BNZ   270A
026F8:  MOVFF  02,01
026FC:  CLRF   02
026FE:  MOVLW  08
02700:  SUBWF  00,F
02702:  MOVF   01,F
02704:  BNZ   270A
02706:  CLRF   00
02708:  BRA    2726
0270A:  BCF    FD8.0
0270C:  BTFSC  01.7
0270E:  BRA    2718
02710:  RLCF   02,F
02712:  RLCF   01,F
02714:  DECF   00,F
02716:  BRA    270A
02718:  MOVLB  7
0271A:  BTFSS  x3D.7
0271C:  BRA    2722
0271E:  MOVLB  0
02720:  BRA    2726
02722:  BCF    01.7
02724:  MOVLB  0
02726:  RETURN 0
02728:  MOVLW  8E
0272A:  MOVWF  00
0272C:  MOVLB  7
0272E:  MOVF   x46,W
02730:  SUBWF  00,F
02732:  MOVFF  747,02
02736:  MOVFF  748,01
0273A:  BSF    02.7
0273C:  MOVF   00,F
0273E:  BZ    2752
02740:  BCF    FD8.0
02742:  MOVF   02,F
02744:  BNZ   274A
02746:  MOVF   01,F
02748:  BZ    2752
0274A:  RRCF   02,F
0274C:  RRCF   01,F
0274E:  DECFSZ 00,F
02750:  BRA    2740
02752:  BTFSS  x47.7
02754:  BRA    2760
02756:  COMF   01,F
02758:  COMF   02,F
0275A:  INCF   01,F
0275C:  BTFSC  FD8.2
0275E:  INCF   02,F
02760:  MOVLB  0
02762:  RETURN 0
*
0461C:  MOVLB  7
0461E:  MOVF   x0D,W
04620:  ANDLW  07
04622:  MOVWF  00
04624:  RRCF   x0D,W
04626:  MOVWF  01
04628:  RRCF   01,F
0462A:  RRCF   01,F
0462C:  MOVLW  1F
0462E:  ANDWF  01,F
04630:  MOVF   01,W
04632:  ADDWF  x0E,W
04634:  MOVWF  FE9
04636:  MOVLW  00
04638:  ADDWFC x0F,W
0463A:  MOVWF  FEA
0463C:  MOVFF  FEF,01
04640:  INCF   00,F
04642:  BRA    4646
04644:  RRCF   01,F
04646:  DECFSZ 00,F
04648:  BRA    4644
0464A:  MOVLW  01
0464C:  ANDWF  01,F
0464E:  MOVLB  0
04650:  RETURN 0
*
0505E:  MOVF   FEF,F
05060:  BZ    5086
05062:  MOVFF  FEA,704
05066:  MOVFF  FE9,703
0506A:  MOVF   FEF,W
0506C:  MOVLB  E
0506E:  BTFSS  xC8.4
05070:  BRA    506E
05072:  MOVWF  F99
05074:  MOVFF  704,FEA
05078:  MOVFF  703,FE9
0507C:  INCF   FE9,F
0507E:  BTFSC  FD8.2
05080:  INCF   FEA,F
05082:  MOVLB  0
05084:  BRA    505E
05086:  RETURN 0
*
055D8:  MOVFF  565,FEA
055DC:  MOVFF  564,FE9
055E0:  MOVFF  750,FEF
055E4:  INCF   FE9,F
055E6:  BTFSC  FD8.2
055E8:  INCF   FEA,F
055EA:  CLRF   FEF
055EC:  MOVLB  5
055EE:  INCF   x64,F
055F0:  BTFSC  FD8.2
055F2:  INCF   x65,F
055F4:  MOVLB  0
055F6:  RETURN 0
055F8:  TBLRD*+
055FA:  MOVFF  FF6,710
055FE:  MOVFF  FF7,711
05602:  MOVFF  FF5,750
05606:  RCALL  55D8
05608:  MOVFF  710,FF6
0560C:  MOVFF  711,FF7
05610:  MOVLB  7
05612:  DECFSZ x0F,F
05614:  BRA    5618
05616:  BRA    561C
05618:  MOVLB  0
0561A:  BRA    55F8
0561C:  MOVLB  0
0561E:  RETURN 0
05620:  MOVF   01,W
05622:  MOVFF  706,73A
05626:  MOVLW  64
05628:  MOVLB  7
0562A:  MOVWF  x3B
0562C:  MOVLB  0
0562E:  CALL   08E0
05632:  MOVFF  00,706
05636:  MOVF   01,W
05638:  MOVLW  30
0563A:  BNZ   564C
0563C:  MOVLB  7
0563E:  BTFSS  x07.1
05640:  BRA    5660
05642:  BTFSC  x07.3
05644:  BRA    5660
05646:  BTFSC  x07.4
05648:  MOVLW  20
0564A:  BRA    5654
0564C:  MOVLB  7
0564E:  BCF    x07.3
05650:  BCF    x07.4
05652:  BSF    x07.0
05654:  ADDWF  01,F
05656:  MOVFF  01,750
0565A:  MOVLB  0
0565C:  RCALL  55D8
0565E:  MOVLB  7
05660:  MOVFF  706,73A
05664:  MOVLW  0A
05666:  MOVWF  x3B
05668:  MOVLB  0
0566A:  CALL   08E0
0566E:  MOVFF  00,706
05672:  MOVF   01,W
05674:  MOVLW  30
05676:  BNZ   5688
05678:  MOVLB  7
0567A:  BTFSC  x07.3
0567C:  BRA    5692
0567E:  BTFSS  x07.0
05680:  BRA    5692
05682:  BTFSC  x07.4
05684:  MOVLW  20
05686:  MOVLB  0
05688:  ADDWF  01,F
0568A:  MOVFF  01,750
0568E:  RCALL  55D8
05690:  MOVLB  7
05692:  MOVLW  30
05694:  ADDWF  x06,F
05696:  MOVFF  706,750
0569A:  MOVLB  0
0569C:  RCALL  55D8
0569E:  RETURN 0
056A0:  MOVLB  7
056A2:  MOVF   x50,W
056A4:  SUBLW  B6
056A6:  MOVWF  x50
056A8:  CLRF   03
056AA:  MOVFF  751,754
056AE:  BSF    x51.7
056B0:  BCF    FD8.0
056B2:  RRCF   x51,F
056B4:  RRCF   x52,F
056B6:  RRCF   x53,F
056B8:  RRCF   03,F
056BA:  RRCF   02,F
056BC:  RRCF   01,F
056BE:  RRCF   00,F
056C0:  DECFSZ x50,F
056C2:  BRA    56B0
056C4:  BTFSS  x54.7
056C6:  BRA    56DE
056C8:  COMF   00,F
056CA:  COMF   01,F
056CC:  COMF   02,F
056CE:  COMF   03,F
056D0:  INCF   00,F
056D2:  BTFSC  FD8.2
056D4:  INCF   01,F
056D6:  BTFSC  FD8.2
056D8:  INCF   02,F
056DA:  BTFSC  FD8.2
056DC:  INCF   03,F
056DE:  MOVLB  0
056E0:  RETURN 0
056E2:  BTFSC  FD8.1
056E4:  BRA    56EE
056E6:  MOVLW  07
056E8:  MOVWF  FEA
056EA:  MOVLW  58
056EC:  MOVWF  FE9
056EE:  CLRF   00
056F0:  CLRF   01
056F2:  CLRF   02
056F4:  CLRF   03
056F6:  MOVLB  7
056F8:  CLRF   x58
056FA:  CLRF   x59
056FC:  CLRF   x5A
056FE:  CLRF   x5B
05700:  MOVF   x57,W
05702:  IORWF  x56,W
05704:  IORWF  x55,W
05706:  IORWF  x54,W
05708:  BZ    5762
0570A:  MOVLW  20
0570C:  MOVWF  x5C
0570E:  BCF    FD8.0
05710:  RLCF   x50,F
05712:  RLCF   x51,F
05714:  RLCF   x52,F
05716:  RLCF   x53,F
05718:  RLCF   x58,F
0571A:  RLCF   x59,F
0571C:  RLCF   x5A,F
0571E:  RLCF   x5B,F
05720:  MOVF   x57,W
05722:  SUBWF  x5B,W
05724:  BNZ   5736
05726:  MOVF   x56,W
05728:  SUBWF  x5A,W
0572A:  BNZ   5736
0572C:  MOVF   x55,W
0572E:  SUBWF  x59,W
05730:  BNZ   5736
05732:  MOVF   x54,W
05734:  SUBWF  x58,W
05736:  BNC   5756
05738:  MOVF   x54,W
0573A:  SUBWF  x58,F
0573C:  MOVF   x55,W
0573E:  BTFSS  FD8.0
05740:  INCFSZ x55,W
05742:  SUBWF  x59,F
05744:  MOVF   x56,W
05746:  BTFSS  FD8.0
05748:  INCFSZ x56,W
0574A:  SUBWF  x5A,F
0574C:  MOVF   x57,W
0574E:  BTFSS  FD8.0
05750:  INCFSZ x57,W
05752:  SUBWF  x5B,F
05754:  BSF    FD8.0
05756:  RLCF   00,F
05758:  RLCF   01,F
0575A:  RLCF   02,F
0575C:  RLCF   03,F
0575E:  DECFSZ x5C,F
05760:  BRA    570E
05762:  MOVFF  758,FEF
05766:  MOVFF  759,FEC
0576A:  MOVFF  75A,FEC
0576E:  MOVFF  75B,FEC
05772:  MOVLB  0
05774:  RETURN 0
05776:  MOVF   FE9,W
05778:  MOVLB  7
0577A:  MOVWF  x48
0577C:  MOVF   x47,W
0577E:  MOVWF  x4A
05780:  BZ    57BA
05782:  MOVFF  746,753
05786:  MOVFF  745,752
0578A:  MOVFF  744,751
0578E:  MOVFF  743,750
05792:  CLRF   x57
05794:  CLRF   x56
05796:  MOVLW  20
05798:  MOVWF  x55
0579A:  MOVLW  82
0579C:  MOVWF  x54
0579E:  MOVLB  0
057A0:  CALL   0DA8
057A4:  MOVFF  03,746
057A8:  MOVFF  02,745
057AC:  MOVFF  01,744
057B0:  MOVFF  00,743
057B4:  MOVLB  7
057B6:  DECFSZ x4A,F
057B8:  BRA    5782
057BA:  MOVFF  746,753
057BE:  MOVFF  745,752
057C2:  MOVFF  744,751
057C6:  MOVFF  743,750
057CA:  MOVLB  0
057CC:  RCALL  56A0
057CE:  MOVFF  03,746
057D2:  MOVFF  02,745
057D6:  MOVFF  01,744
057DA:  MOVFF  00,743
057DE:  MOVLB  7
057E0:  BTFSS  x46.7
057E2:  BRA    57FE
057E4:  DECF   x48,F
057E6:  BSF    x48.5
057E8:  COMF   x43,F
057EA:  COMF   x44,F
057EC:  COMF   x45,F
057EE:  COMF   x46,F
057F0:  INCF   x43,F
057F2:  BTFSC  FD8.2
057F4:  INCF   x44,F
057F6:  BTFSC  FD8.2
057F8:  INCF   x45,F
057FA:  BTFSC  FD8.2
057FC:  INCF   x46,F
057FE:  MOVLW  3B
05800:  MOVWF  x4F
05802:  MOVLW  9A
05804:  MOVWF  x4E
05806:  MOVLW  CA
05808:  MOVWF  x4D
0580A:  CLRF   x4C
0580C:  MOVLW  0A
0580E:  MOVWF  x4A
05810:  MOVF   x47,W
05812:  BTFSC  FD8.2
05814:  INCF   x48,F
05816:  BSF    FD8.1
05818:  MOVLW  07
0581A:  MOVWF  FEA
0581C:  MOVLW  43
0581E:  MOVWF  FE9
05820:  MOVFF  746,753
05824:  MOVFF  745,752
05828:  MOVFF  744,751
0582C:  MOVFF  743,750
05830:  MOVFF  74F,757
05834:  MOVFF  74E,756
05838:  MOVFF  74D,755
0583C:  MOVFF  74C,754
05840:  MOVLB  0
05842:  RCALL  56E2
05844:  MOVF   01,W
05846:  MOVF   00,F
05848:  BNZ   5870
0584A:  MOVLB  7
0584C:  INCF   x47,W
0584E:  SUBWF  x4A,W
05850:  BTFSS  FD8.2
05852:  BRA    5858
05854:  MOVLB  0
05856:  BRA    5870
05858:  MOVF   x48,W
0585A:  BZ    5876
0585C:  ANDLW  0F
0585E:  SUBWF  x4A,W
05860:  BZ    5864
05862:  BC    58E4
05864:  BTFSC  x48.7
05866:  BRA    58E4
05868:  BTFSC  x48.6
0586A:  BRA    5876
0586C:  MOVLW  20
0586E:  BRA    58D8
05870:  MOVLW  20
05872:  MOVLB  7
05874:  ANDWF  x48,F
05876:  BTFSS  x48.5
05878:  BRA    5896
0587A:  BCF    x48.5
0587C:  MOVF   x47,W
0587E:  BTFSS  FD8.2
05880:  DECF   x48,F
05882:  MOVF   00,W
05884:  MOVWF  x48
05886:  MOVLW  2D
05888:  MOVWF  x50
0588A:  MOVLB  0
0588C:  RCALL  55D8
0588E:  MOVLB  7
05890:  MOVF   x48,W
05892:  MOVWF  00
05894:  CLRF   x48
05896:  MOVF   x47,W
05898:  SUBWF  x4A,W
0589A:  BNZ   58B4
0589C:  MOVF   00,W
0589E:  MOVWF  x48
058A0:  MOVLW  2E
058A2:  MOVWF  x50
058A4:  MOVLB  0
058A6:  RCALL  55D8
058A8:  MOVLB  7
058AA:  MOVF   x48,W
058AC:  MOVWF  00
058AE:  MOVLW  20
058B0:  ANDWF  x48,F
058B2:  MOVLW  00
058B4:  MOVLW  30
058B6:  BTFSS  x48.5
058B8:  BRA    58D8
058BA:  BCF    x48.5
058BC:  MOVF   x47,W
058BE:  BTFSS  FD8.2
058C0:  DECF   x48,F
058C2:  MOVF   00,W
058C4:  MOVWF  x48
058C6:  MOVLW  2D
058C8:  MOVWF  x50
058CA:  MOVLB  0
058CC:  RCALL  55D8
058CE:  MOVLB  7
058D0:  MOVF   x48,W
058D2:  MOVWF  00
058D4:  CLRF   x48
058D6:  MOVLW  30
058D8:  ADDWF  00,F
058DA:  MOVFF  00,750
058DE:  MOVLB  0
058E0:  RCALL  55D8
058E2:  MOVLB  7
058E4:  BCF    FD8.1
058E6:  MOVFF  74F,753
058EA:  MOVFF  74E,752
058EE:  MOVFF  74D,751
058F2:  MOVFF  74C,750
058F6:  CLRF   x57
058F8:  CLRF   x56
058FA:  CLRF   x55
058FC:  MOVLW  0A
058FE:  MOVWF  x54
05900:  MOVLB  0
05902:  RCALL  56E2
05904:  MOVFF  03,74F
05908:  MOVFF  02,74E
0590C:  MOVFF  01,74D
05910:  MOVFF  00,74C
05914:  MOVLB  7
05916:  DECFSZ x4A,F
05918:  BRA    5816
0591A:  MOVLB  0
0591C:  RETURN 0
0591E:  MOVFF  FEA,708
05922:  MOVFF  FE9,707
05926:  MOVLB  7
05928:  SWAPF  x01,W
0592A:  IORLW  F0
0592C:  MOVWF  x03
0592E:  ADDWF  x03,F
05930:  ADDLW  E2
05932:  MOVWF  x04
05934:  ADDLW  32
05936:  MOVWF  x06
05938:  MOVF   x01,W
0593A:  ANDLW  0F
0593C:  ADDWF  x04,F
0593E:  ADDWF  x04,F
05940:  ADDWF  x06,F
05942:  ADDLW  E9
05944:  MOVWF  x05
05946:  ADDWF  x05,F
05948:  ADDWF  x05,F
0594A:  SWAPF  x00,W
0594C:  ANDLW  0F
0594E:  ADDWF  x05,F
05950:  ADDWF  x06,F
05952:  RLCF   x05,F
05954:  RLCF   x06,F
05956:  COMF   x06,F
05958:  RLCF   x06,F
0595A:  MOVF   x00,W
0595C:  ANDLW  0F
0595E:  ADDWF  x06,F
05960:  RLCF   x03,F
05962:  MOVLW  07
05964:  MOVWF  x02
05966:  MOVLW  0A
05968:  DECF   x05,F
0596A:  ADDWF  x06,F
0596C:  BNC   5968
0596E:  DECF   x04,F
05970:  ADDWF  x05,F
05972:  BNC   596E
05974:  DECF   x03,F
05976:  ADDWF  x04,F
05978:  BNC   5974
0597A:  DECF   x02,F
0597C:  ADDWF  x03,F
0597E:  BNC   597A
05980:  MOVLW  07
05982:  MOVWF  FEA
05984:  MOVLW  02
05986:  MOVWF  FE9
05988:  MOVLW  07
0598A:  ANDWF  x07,W
0598C:  BCF    x07.6
0598E:  ADDWF  FE9,F
05990:  MOVLW  00
05992:  ADDWFC FEA,F
05994:  MOVF   FE9,W
05996:  SUBLW  06
05998:  BNZ   59A2
0599A:  MOVF   FEA,W
0599C:  SUBLW  07
0599E:  BNZ   59A2
059A0:  BSF    x07.6
059A2:  MOVF   FEF,W
059A4:  MOVWF  00
059A6:  BNZ   59B8
059A8:  BTFSC  x07.6
059AA:  BRA    59B8
059AC:  BTFSC  x07.4
059AE:  BRA    59DA
059B0:  BTFSC  x07.3
059B2:  BRA    59B8
059B4:  MOVLW  20
059B6:  BRA    59BE
059B8:  BSF    x07.3
059BA:  BCF    x07.4
059BC:  MOVLW  30
059BE:  ADDWF  00,F
059C0:  MOVFF  FEA,701
059C4:  MOVFF  FE9,700
059C8:  MOVFF  00,750
059CC:  MOVLB  0
059CE:  RCALL  55D8
059D0:  MOVFF  701,FEA
059D4:  MOVFF  700,FE9
059D8:  MOVLB  7
059DA:  MOVF   FEE,W
059DC:  BTFSS  x07.6
059DE:  BRA    5994
059E0:  MOVLB  0
059E2:  RETURN 0
*
05A36:  MOVF   FEF,F
05A38:  BZ    5A58
05A3A:  MOVFF  FEA,6FC
05A3E:  MOVFF  FE9,6FB
05A42:  MOVFF  FEF,6FD
05A46:  BRA    59E4
05A48:  MOVFF  6FC,FEA
05A4C:  MOVFF  6FB,FE9
05A50:  INCF   FE9,F
05A52:  BTFSC  FD8.2
05A54:  INCF   FEA,F
05A56:  BRA    5A36
05A58:  GOTO   AB02 (RETURN)
*
05AB6:  MOVF   FEF,F
05AB8:  BZ    5AD8
05ABA:  MOVFF  FEA,708
05ABE:  MOVFF  FE9,707
05AC2:  MOVFF  FEF,750
05AC6:  RCALL  55D8
05AC8:  MOVFF  708,FEA
05ACC:  MOVFF  707,FE9
05AD0:  INCF   FE9,F
05AD2:  BTFSC  FD8.2
05AD4:  INCF   FEA,F
05AD6:  BRA    5AB6
05AD8:  RETURN 0
*
05B8C:  TBLRD*+
05B8E:  MOVF   FF5,F
05B90:  BZ    5BAA
05B92:  MOVFF  FF6,70E
05B96:  MOVFF  FF7,70F
05B9A:  MOVFF  FF5,750
05B9E:  RCALL  55D8
05BA0:  MOVFF  70E,FF6
05BA4:  MOVFF  70F,FF7
05BA8:  BRA    5B8C
05BAA:  RETURN 0
*
05CCE:  MOVLB  7
05CD0:  MOVF   x68,W
05CD2:  XORWF  x6A,W
05CD4:  ANDLW  80
05CD6:  MOVWF  x6C
05CD8:  BTFSS  x68.7
05CDA:  BRA    5CE6
05CDC:  COMF   x67,F
05CDE:  COMF   x68,F
05CE0:  INCF   x67,F
05CE2:  BTFSC  FD8.2
05CE4:  INCF   x68,F
05CE6:  BTFSS  x6A.7
05CE8:  BRA    5CF4
05CEA:  COMF   x69,F
05CEC:  COMF   x6A,F
05CEE:  INCF   x69,F
05CF0:  BTFSC  FD8.2
05CF2:  INCF   x6A,F
05CF4:  MOVF   x67,W
05CF6:  MULWF  x69
05CF8:  MOVFF  FF3,01
05CFC:  MOVFF  FF4,00
05D00:  MULWF  x6A
05D02:  MOVF   FF3,W
05D04:  ADDWF  00,F
05D06:  MOVF   x68,W
05D08:  MULWF  x69
05D0A:  MOVF   FF3,W
05D0C:  ADDWFC 00,W
05D0E:  MOVWF  02
05D10:  BTFSS  x6C.7
05D12:  BRA    5D1E
05D14:  COMF   01,F
05D16:  COMF   02,F
05D18:  INCF   01,F
05D1A:  BTFSC  FD8.2
05D1C:  INCF   02,F
05D1E:  MOVLB  0
05D20:  GOTO   5FB4 (RETURN)
*
06078:  MOVLW  20
0607A:  MOVLB  7
0607C:  BTFSS  x35.4
0607E:  MOVLW  30
06080:  MOVWF  x36
06082:  MOVFF  734,00
06086:  BTFSS  00.7
06088:  BRA    609A
0608A:  COMF   00,F
0608C:  INCF   00,F
0608E:  MOVFF  00,734
06092:  MOVLW  2D
06094:  MOVWF  x36
06096:  BSF    x35.7
06098:  BSF    x35.0
0609A:  MOVF   01,W
0609C:  MOVFF  734,73A
060A0:  MOVLW  64
060A2:  MOVWF  x3B
060A4:  MOVLB  0
060A6:  CALL   08E0
060AA:  MOVFF  00,734
060AE:  MOVLW  30
060B0:  ADDWF  01,W
060B2:  MOVLB  7
060B4:  MOVWF  x37
060B6:  MOVFF  734,73A
060BA:  MOVLW  0A
060BC:  MOVWF  x3B
060BE:  MOVLB  0
060C0:  CALL   08E0
060C4:  MOVLW  30
060C6:  ADDWF  00,W
060C8:  MOVLB  7
060CA:  MOVWF  x39
060CC:  MOVLW  30
060CE:  ADDWF  01,W
060D0:  MOVWF  x38
060D2:  MOVFF  736,00
060D6:  MOVLW  30
060D8:  SUBWF  x37,W
060DA:  BZ    60E4
060DC:  BSF    x35.1
060DE:  BTFSC  x35.7
060E0:  BSF    x35.2
060E2:  BRA    6108
060E4:  MOVFF  736,737
060E8:  MOVLW  20
060EA:  MOVWF  x36
060EC:  MOVLW  30
060EE:  SUBWF  x38,W
060F0:  BZ    60FA
060F2:  BSF    x35.0
060F4:  BTFSC  x35.7
060F6:  BSF    x35.1
060F8:  BRA    6108
060FA:  BTFSS  FD8.2
060FC:  BSF    x35.0
060FE:  BNZ   6108
06100:  MOVFF  737,738
06104:  MOVLW  20
06106:  MOVWF  x37
06108:  BTFSC  x35.2
0610A:  BRA    6116
0610C:  BTFSC  x35.1
0610E:  BRA    6120
06110:  BTFSC  x35.0
06112:  BRA    612A
06114:  BRA    6134
06116:  MOVFF  736,750
0611A:  MOVLB  0
0611C:  CALL   55D8
06120:  MOVFF  737,750
06124:  MOVLB  0
06126:  CALL   55D8
0612A:  MOVFF  738,750
0612E:  MOVLB  0
06130:  CALL   55D8
06134:  MOVFF  739,750
06138:  MOVLB  0
0613A:  CALL   55D8
0613E:  RETURN 0
*
062EC:  MOVLB  7
062EE:  MOVF   x22,W
062F0:  ANDLW  07
062F2:  MOVWF  00
062F4:  RRCF   x22,W
062F6:  MOVWF  01
062F8:  RRCF   01,F
062FA:  RRCF   01,F
062FC:  MOVLW  1F
062FE:  ANDWF  01,F
06300:  MOVF   01,W
06302:  ADDWF  x24,W
06304:  MOVWF  FE9
06306:  MOVLW  00
06308:  ADDWFC x25,W
0630A:  MOVWF  FEA
0630C:  CLRF   01
0630E:  INCF   01,F
06310:  INCF   00,F
06312:  BRA    6316
06314:  RLCF   01,F
06316:  DECFSZ 00,F
06318:  BRA    6314
0631A:  MOVF   x23,F
0631C:  BZ    6324
0631E:  MOVF   01,W
06320:  IORWF  FEF,F
06322:  BRA    632A
06324:  COMF   01,F
06326:  MOVF   01,W
06328:  ANDWF  FEF,F
0632A:  MOVLB  0
0632C:  RETURN 0
*
092FA:  MOVF   FE9,W
092FC:  MOVLB  7
092FE:  MOVWF  x3D
09300:  BTFSS  x3C.7
09302:  BRA    931E
09304:  DECF   x3D,F
09306:  BSF    x3D.5
09308:  COMF   x39,F
0930A:  COMF   x3A,F
0930C:  COMF   x3B,F
0930E:  COMF   x3C,F
09310:  INCF   x39,F
09312:  BTFSC  FD8.2
09314:  INCF   x3A,F
09316:  BTFSC  FD8.2
09318:  INCF   x3B,F
0931A:  BTFSC  FD8.2
0931C:  INCF   x3C,F
0931E:  MOVLW  3B
09320:  MOVWF  x44
09322:  MOVLW  9A
09324:  MOVWF  x43
09326:  MOVLW  CA
09328:  MOVWF  x42
0932A:  CLRF   x41
0932C:  MOVLW  0A
0932E:  MOVWF  x3F
09330:  BSF    FD8.1
09332:  MOVLW  07
09334:  MOVWF  FEA
09336:  MOVLW  39
09338:  MOVWF  FE9
0933A:  MOVFF  73C,753
0933E:  MOVFF  73B,752
09342:  MOVFF  73A,751
09346:  MOVFF  739,750
0934A:  MOVFF  744,757
0934E:  MOVFF  743,756
09352:  MOVFF  742,755
09356:  MOVFF  741,754
0935A:  MOVLB  0
0935C:  CALL   56E2
09360:  MOVF   01,W
09362:  MOVF   00,F
09364:  BNZ   938C
09366:  MOVLB  7
09368:  MOVF   x3F,W
0936A:  XORLW  01
0936C:  BTFSS  FD8.2
0936E:  BRA    9374
09370:  MOVLB  0
09372:  BRA    938C
09374:  MOVF   x3D,W
09376:  BZ    9392
09378:  ANDLW  0F
0937A:  SUBWF  x3F,W
0937C:  BZ    9380
0937E:  BC    93DC
09380:  BTFSC  x3D.7
09382:  BRA    93DC
09384:  BTFSC  x3D.6
09386:  BRA    9392
09388:  MOVLW  20
0938A:  BRA    93CE
0938C:  MOVLW  20
0938E:  MOVLB  7
09390:  ANDWF  x3D,F
09392:  BTFSS  x3D.5
09394:  BRA    93AE
09396:  BCF    x3D.5
09398:  MOVFF  00,73D
0939C:  MOVLW  2D
0939E:  MOVWF  x50
093A0:  MOVLB  0
093A2:  CALL   55D8
093A6:  MOVLB  7
093A8:  MOVFF  73D,00
093AC:  CLRF   x3D
093AE:  MOVLW  30
093B0:  BTFSS  x3D.5
093B2:  BRA    93CE
093B4:  BCF    x3D.5
093B6:  MOVFF  00,73D
093BA:  MOVLW  2D
093BC:  MOVWF  x50
093BE:  MOVLB  0
093C0:  CALL   55D8
093C4:  MOVLB  7
093C6:  MOVFF  73D,00
093CA:  CLRF   x3D
093CC:  MOVLW  30
093CE:  ADDWF  00,F
093D0:  MOVFF  00,750
093D4:  MOVLB  0
093D6:  CALL   55D8
093DA:  MOVLB  7
093DC:  BCF    FD8.1
093DE:  MOVFF  744,753
093E2:  MOVFF  743,752
093E6:  MOVFF  742,751
093EA:  MOVFF  741,750
093EE:  CLRF   x57
093F0:  CLRF   x56
093F2:  CLRF   x55
093F4:  MOVLW  0A
093F6:  MOVWF  x54
093F8:  MOVLB  0
093FA:  CALL   56E2
093FE:  MOVFF  03,744
09402:  MOVFF  02,743
09406:  MOVFF  01,742
0940A:  MOVFF  00,741
0940E:  MOVLB  7
09410:  DECFSZ x3F,F
09412:  BRA    9330
09414:  MOVLB  0
09416:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003D2:  MOVLW  07
003D4:  MOVWF  FEA
003D6:  MOVLW  01
003D8:  MOVWF  FE9
003DA:  MOVF   FEF,W
003DC:  BZ    03FA
003DE:  MOVLW  14
003E0:  MOVWF  01
003E2:  CLRF   00
003E4:  DECFSZ 00,F
003E6:  BRA    03E4
003E8:  DECFSZ 01,F
003EA:  BRA    03E2
003EC:  MOVLW  BF
003EE:  MOVWF  00
003F0:  DECFSZ 00,F
003F2:  BRA    03F0
003F4:  BRA    03F6
003F6:  DECFSZ FEF,F
003F8:  BRA    03DE
003FA:  RETURN 0
*
0074E:  MOVLW  01
00750:  MOVLB  7
00752:  SUBWF  x07,F
00754:  BNC   076C
00756:  MOVLW  07
00758:  MOVWF  FEA
0075A:  MOVWF  FE9
0075C:  MOVF   FEF,W
0075E:  BZ    076C
00760:  MOVLW  04
00762:  MOVWF  00
00764:  DECFSZ 00,F
00766:  BRA    0764
00768:  DECFSZ FEF,F
0076A:  BRA    0760
0076C:  MOVLB  0
0076E:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
*
000CA:  BSF    F88.6
000CC:  BTFSC  F8D.6
000CE:  BRA    00CC
000D0:  MOVLW  08
000D2:  MOVWF  00
000D4:  MOVLB  7
000D6:  CLRF   x75
000D8:  MOVFF  FF2,776
000DC:  BCF    FF2.7
000DE:  BSF    00.7
000E0:  BRA    00FE
000E2:  BCF    00.7
000E4:  BRA    00FE
000E6:  BCF    FD8.0
000E8:  BTFSC  F8D.6
000EA:  BSF    FD8.0
000EC:  RRCF   x75,F
000EE:  BSF    00.6
000F0:  BRA    00FE
000F2:  BCF    00.6
000F4:  DECFSZ 00,F
000F6:  BRA    00E6
000F8:  MOVFF  775,01
000FC:  BRA    0116
000FE:  MOVLW  84
00100:  BTFSC  00.7
00102:  MOVLW  24
00104:  MOVWF  01
00106:  DECFSZ 01,F
00108:  BRA    0106
0010A:  BRA    010C
0010C:  BTFSC  00.7
0010E:  BRA    00E2
00110:  BTFSC  00.6
00112:  BRA    00F2
00114:  BRA    00E6
00116:  BTFSC  x76.7
00118:  BSF    FF2.7
0011A:  MOVLB  0
0011C:  GOTO   0142 (RETURN)
*
059E4:  MOVFF  FF2,03
059E8:  BCF    FF2.7
059EA:  BCF    F88.7
059EC:  BCF    F83.7
059EE:  MOVLW  08
059F0:  MOVWF  01
059F2:  BRA    59F4
059F4:  NOP   
059F6:  BSF    01.7
059F8:  BRA    5A1A
059FA:  BCF    01.7
059FC:  MOVLB  6
059FE:  RRCF   xFD,F
05A00:  MOVLB  0
05A02:  BTFSC  FD8.0
05A04:  BSF    F83.7
05A06:  BTFSS  FD8.0
05A08:  BCF    F83.7
05A0A:  BSF    01.6
05A0C:  BRA    5A1A
05A0E:  BCF    01.6
05A10:  DECFSZ 01,F
05A12:  BRA    59FC
05A14:  BRA    5A16
05A16:  NOP   
05A18:  BSF    F83.7
05A1A:  MOVLW  84
05A1C:  MOVWF  FE9
05A1E:  DECFSZ FE9,F
05A20:  BRA    5A1E
05A22:  BRA    5A24
05A24:  NOP   
05A26:  BTFSC  01.7
05A28:  BRA    59FA
05A2A:  BTFSC  01.6
05A2C:  BRA    5A0E
05A2E:  BTFSC  03.7
05A30:  BSF    FF2.7
05A32:  GOTO   5A48 (RETURN)
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003FC:  MOVLW  CF
003FE:  MOVWF  F87
00400:  CLRF   F82
....................    output_b(portB_reset);
00402:  MOVLW  04
00404:  MOVWF  F88
00406:  CLRF   F83
....................    output_c(portC_reset);
00408:  MOVLW  93
0040A:  MOVWF  F89
0040C:  CLRF   F84
....................    output_d(portD_reset);
0040E:  MOVLW  1F
00410:  MOVWF  F8A
00412:  CLRF   F85
....................    output_e(portE_reset);
00414:  BCF    F8B.0
00416:  BCF    F8B.1
00418:  BCF    F8B.2
0041A:  BCF    F8B.3
0041C:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
0041E:  MOVLB  F
00420:  SETF   x0B
....................    port_b_pullups(portB_pullups);
00422:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00424:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00426:  SETF   x20
....................    port_e_pullups(portE_pullups);
00428:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
0042A:  MOVLW  40
0042C:  MOVWF  x0C
0042E:  CLRF   x14
00430:  MOVLW  03
00432:  MOVWF  x1C
00434:  MOVLW  0F
00436:  MOVWF  x21
00438:  CLRF   x29
0043A:  MOVLB  0
0043C:  GOTO   A720 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05B14:  MOVFF  742,FEA
05B18:  MOVLB  7
05B1A:  MOVFF  741,FE9
05B1E:  MOVFF  FEF,745
05B22:  MOVFF  744,FEA
05B26:  MOVFF  743,FE9
05B2A:  MOVF   FEF,W
05B2C:  SUBWF  x45,W
05B2E:  BNZ   5B5E
....................       if (*s1 == '\0')
05B30:  MOVFF  742,03
05B34:  MOVFF  741,FE9
05B38:  MOVFF  03,FEA
05B3C:  MOVF   FEF,F
05B3E:  BNZ   5B46
....................          return(0);
05B40:  MOVLW  00
05B42:  MOVWF  01
05B44:  BRA    5B88
05B46:  MOVFF  742,03
05B4A:  MOVF   x41,W
05B4C:  INCF   x41,F
05B4E:  BTFSC  FD8.2
05B50:  INCF   x42,F
05B52:  INCF   x43,F
05B54:  BTFSC  FD8.2
05B56:  INCF   x44,F
05B58:  MOVLB  0
05B5A:  BRA    5B14
05B5C:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05B5E:  MOVFF  742,03
05B62:  MOVFF  741,FE9
05B66:  MOVFF  03,FEA
05B6A:  MOVFF  FEF,745
05B6E:  MOVFF  744,03
05B72:  MOVFF  743,FE9
05B76:  MOVFF  03,FEA
05B7A:  MOVF   FEF,W
05B7C:  SUBWF  x45,W
05B7E:  BC    5B84
05B80:  MOVLW  FF
05B82:  BRA    5B86
05B84:  MOVLW  01
05B86:  MOVWF  01
05B88:  MOVLB  0
05B8A:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05C84:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
05C88:  MOVFF  767,76D
05C8C:  MOVFF  766,76C
05C90:  MOVLB  7
05C92:  MOVF   x6A,F
05C94:  BNZ   5C9C
05C96:  MOVF   x69,W
05C98:  SUBLW  00
05C9A:  BC    5CC4
....................       if(*su==uc)
05C9C:  MOVFF  76D,FEA
05CA0:  MOVFF  76C,FE9
05CA4:  MOVF   x6B,W
05CA6:  SUBWF  FEF,W
05CA8:  BNZ   5CB4
....................       return su;
05CAA:  MOVFF  76C,01
05CAE:  MOVFF  76D,02
05CB2:  BRA    5CCA
05CB4:  INCF   x6C,F
05CB6:  BTFSC  FD8.2
05CB8:  INCF   x6D,F
05CBA:  MOVF   x69,W
05CBC:  BTFSC  FD8.2
05CBE:  DECF   x6A,F
05CC0:  DECF   x69,F
05CC2:  BRA    5C92
....................    return NULL;
05CC4:  MOVLW  00
05CC6:  MOVWF  01
05CC8:  MOVWF  02
05CCA:  MOVLB  0
05CCC:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
055A0:  MOVFF  742,744
055A4:  MOVFF  741,743
055A8:  MOVFF  744,FEA
055AC:  MOVLB  7
055AE:  MOVFF  743,FE9
055B2:  MOVF   FEF,F
055B4:  BZ    55C2
055B6:  INCF   x43,F
055B8:  BTFSC  FD8.2
055BA:  INCF   x44,F
055BC:  MOVLB  0
055BE:  BRA    55A8
055C0:  MOVLB  7
....................    return(sc - s);
055C2:  MOVF   x41,W
055C4:  SUBWF  x43,W
055C6:  MOVWF  00
055C8:  MOVF   x42,W
055CA:  SUBWFB x44,W
055CC:  MOVWF  03
055CE:  MOVFF  00,01
055D2:  MOVWF  02
055D4:  MOVLB  0
055D6:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06E0A:  MOVLB  7
06E0C:  CLRF   x1B
06E0E:  CLRF   x1A
06E10:  CLRF   x19
06E12:  MOVLW  7F
06E14:  MOVWF  x18
06E16:  CLRF   x1F
06E18:  CLRF   x1E
06E1A:  CLRF   x1D
06E1C:  CLRF   x1C
06E1E:  BSF    x20.0
06E20:  BCF    x20.1
06E22:  BCF    x20.2
06E24:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06E26:  MOVF   x14,W
06E28:  IORWF  x15,W
06E2A:  BNZ   6E36
....................       return 0;
06E2C:  CLRF   00
06E2E:  CLRF   01
06E30:  CLRF   02
06E32:  CLRF   03
06E34:  BRA    7060
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06E36:  MOVF   x22,W
06E38:  INCF   x22,F
06E3A:  ADDWF  x14,W
06E3C:  MOVWF  FE9
06E3E:  MOVLW  00
06E40:  ADDWFC x15,W
06E42:  MOVWF  FEA
06E44:  MOVFF  FEF,721
06E48:  MOVF   x21,F
06E4A:  BTFSC  FD8.2
06E4C:  BRA    6FE4
....................    {
....................       if (skip && !isspace(c))
06E4E:  BTFSS  x20.0
06E50:  BRA    6E70
06E52:  MOVF   x21,W
06E54:  SUBLW  20
06E56:  BZ    6E70
....................       {
....................          skip = 0;
06E58:  BCF    x20.0
....................          if (c == '+')
06E5A:  MOVF   x21,W
06E5C:  SUBLW  2B
06E5E:  BNZ   6E66
....................          {
....................             sign = 0;
06E60:  BCF    x20.1
....................             continue;
06E62:  BRA    6FCC
....................          }            
06E64:  BRA    6E70
....................          else if (c == '-')
06E66:  MOVF   x21,W
06E68:  SUBLW  2D
06E6A:  BNZ   6E70
....................          {
....................             sign = 1;
06E6C:  BSF    x20.1
....................             continue;
06E6E:  BRA    6FCC
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06E70:  BTFSC  x20.0
06E72:  BRA    6E82
06E74:  MOVF   x21,W
06E76:  SUBLW  2E
06E78:  BNZ   6E82
06E7A:  BTFSC  x20.2
06E7C:  BRA    6E82
....................          point = 1;
06E7E:  BSF    x20.2
06E80:  BRA    6FCC
....................       else if (!skip && isdigit(c))
06E82:  BTFSC  x20.0
06E84:  BRA    6FC6
06E86:  MOVF   x21,W
06E88:  SUBLW  2F
06E8A:  BTFSC  FD8.0
06E8C:  BRA    6FC6
06E8E:  MOVF   x21,W
06E90:  SUBLW  39
06E92:  BTFSS  FD8.0
06E94:  BRA    6FC6
....................       {
....................          c -= '0';
06E96:  MOVLW  30
06E98:  SUBWF  x21,F
....................          if (point)
06E9A:  BTFSS  x20.2
06E9C:  BRA    6F4C
....................          {
....................             pow10 = pow10 * 10.0;
06E9E:  MOVFF  71B,753
06EA2:  MOVFF  71A,752
06EA6:  MOVFF  719,751
06EAA:  MOVFF  718,750
06EAE:  CLRF   x57
06EB0:  CLRF   x56
06EB2:  MOVLW  20
06EB4:  MOVWF  x55
06EB6:  MOVLW  82
06EB8:  MOVWF  x54
06EBA:  MOVLB  0
06EBC:  CALL   0DA8
06EC0:  MOVFF  03,71B
06EC4:  MOVFF  02,71A
06EC8:  MOVFF  01,719
06ECC:  MOVFF  00,718
....................             result += (float)c / pow10;   
06ED0:  MOVLB  7
06ED2:  CLRF   x4B
06ED4:  MOVFF  721,74A
06ED8:  MOVLB  0
06EDA:  CALL   0D72
06EDE:  MOVFF  03,726
06EE2:  MOVFF  02,725
06EE6:  MOVFF  01,724
06EEA:  MOVFF  00,723
06EEE:  MOVFF  03,742
06EF2:  MOVFF  02,741
06EF6:  MOVFF  01,740
06EFA:  MOVFF  00,73F
06EFE:  MOVFF  71B,746
06F02:  MOVFF  71A,745
06F06:  MOVFF  719,744
06F0A:  MOVFF  718,743
06F0E:  CALL   1DAE
06F12:  BCF    FD8.1
06F14:  MOVFF  71F,74D
06F18:  MOVFF  71E,74C
06F1C:  MOVFF  71D,74B
06F20:  MOVFF  71C,74A
06F24:  MOVFF  03,751
06F28:  MOVFF  02,750
06F2C:  MOVFF  01,74F
06F30:  MOVFF  00,74E
06F34:  CALL   0E9E
06F38:  MOVFF  03,71F
06F3C:  MOVFF  02,71E
06F40:  MOVFF  01,71D
06F44:  MOVFF  00,71C
....................          }
06F48:  BRA    6FC2
06F4A:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06F4C:  CLRF   x53
06F4E:  CLRF   x52
06F50:  MOVLW  20
06F52:  MOVWF  x51
06F54:  MOVLW  82
06F56:  MOVWF  x50
06F58:  MOVFF  71F,757
06F5C:  MOVFF  71E,756
06F60:  MOVFF  71D,755
06F64:  MOVFF  71C,754
06F68:  MOVLB  0
06F6A:  CALL   0DA8
06F6E:  MOVFF  03,726
06F72:  MOVFF  02,725
06F76:  MOVFF  01,724
06F7A:  MOVFF  00,723
06F7E:  MOVLB  7
06F80:  CLRF   x4B
06F82:  MOVFF  721,74A
06F86:  MOVLB  0
06F88:  CALL   0D72
06F8C:  BCF    FD8.1
06F8E:  MOVFF  726,74D
06F92:  MOVFF  725,74C
06F96:  MOVFF  724,74B
06F9A:  MOVFF  723,74A
06F9E:  MOVFF  03,751
06FA2:  MOVFF  02,750
06FA6:  MOVFF  01,74F
06FAA:  MOVFF  00,74E
06FAE:  CALL   0E9E
06FB2:  MOVFF  03,71F
06FB6:  MOVFF  02,71E
06FBA:  MOVFF  01,71D
06FBE:  MOVFF  00,71C
....................          }
....................       }
06FC2:  BRA    6FCE
06FC4:  MOVLB  7
....................       else if (!skip)
06FC6:  BTFSC  x20.0
06FC8:  BRA    6FCC
....................          break;
06FCA:  BRA    6FE4
06FCC:  MOVLB  0
06FCE:  MOVLB  7
06FD0:  MOVF   x22,W
06FD2:  INCF   x22,F
06FD4:  ADDWF  x14,W
06FD6:  MOVWF  FE9
06FD8:  MOVLW  00
06FDA:  ADDWFC x15,W
06FDC:  MOVWF  FEA
06FDE:  MOVFF  FEF,721
06FE2:  BRA    6E48
....................    }
.................... 
....................    if (sign)
06FE4:  BTFSS  x20.1
06FE6:  BRA    701C
....................       result = -1*result;
06FE8:  CLRF   x53
06FEA:  CLRF   x52
06FEC:  MOVLW  80
06FEE:  MOVWF  x51
06FF0:  MOVLW  7F
06FF2:  MOVWF  x50
06FF4:  MOVFF  71F,757
06FF8:  MOVFF  71E,756
06FFC:  MOVFF  71D,755
07000:  MOVFF  71C,754
07004:  MOVLB  0
07006:  CALL   0DA8
0700A:  MOVFF  03,71F
0700E:  MOVFF  02,71E
07012:  MOVFF  01,71D
07016:  MOVFF  00,71C
0701A:  MOVLB  7
....................       
....................    if(endptr)
0701C:  MOVF   x16,W
0701E:  IORWF  x17,W
07020:  BZ    7050
....................    {
....................       if (ptr) {
07022:  MOVF   x22,F
07024:  BZ    703E
....................          ptr--;
07026:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
07028:  MOVFF  717,FEA
0702C:  MOVFF  716,FE9
07030:  MOVF   x22,W
07032:  ADDWF  x14,W
07034:  MOVWF  FEF
07036:  MOVLW  00
07038:  ADDWFC x15,W
0703A:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0703C:  BRA    7050
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0703E:  MOVFF  717,FEA
07042:  MOVFF  716,FE9
07046:  MOVFF  715,FEC
0704A:  MOVF   FED,F
0704C:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07050:  MOVFF  71C,00
07054:  MOVFF  71D,01
07058:  MOVFF  71E,02
0705C:  MOVFF  71F,03
07060:  MOVLB  0
07062:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05D24:  MOVLB  7
05D26:  CLRF   x3F
05D28:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05D2A:  MOVLW  30
05D2C:  MOVWF  x41
05D2E:  MOVLW  31
05D30:  MOVWF  x42
05D32:  MOVLW  32
05D34:  MOVWF  x43
05D36:  MOVLW  33
05D38:  MOVWF  x44
05D3A:  MOVLW  34
05D3C:  MOVWF  x45
05D3E:  MOVLW  35
05D40:  MOVWF  x46
05D42:  MOVLW  36
05D44:  MOVWF  x47
05D46:  MOVLW  37
05D48:  MOVWF  x48
05D4A:  MOVLW  38
05D4C:  MOVWF  x49
05D4E:  MOVLW  39
05D50:  MOVWF  x4A
05D52:  MOVLW  61
05D54:  MOVWF  x4B
05D56:  MOVLW  62
05D58:  MOVWF  x4C
05D5A:  MOVLW  63
05D5C:  MOVWF  x4D
05D5E:  MOVLW  64
05D60:  MOVWF  x4E
05D62:  MOVLW  65
05D64:  MOVWF  x4F
05D66:  MOVLW  66
05D68:  MOVWF  x50
05D6A:  MOVLW  67
05D6C:  MOVWF  x51
05D6E:  MOVLW  68
05D70:  MOVWF  x52
05D72:  MOVLW  69
05D74:  MOVWF  x53
05D76:  MOVLW  6A
05D78:  MOVWF  x54
05D7A:  MOVLW  6B
05D7C:  MOVWF  x55
05D7E:  MOVLW  6C
05D80:  MOVWF  x56
05D82:  MOVLW  6D
05D84:  MOVWF  x57
05D86:  MOVLW  6E
05D88:  MOVWF  x58
05D8A:  MOVLW  6F
05D8C:  MOVWF  x59
05D8E:  MOVLW  70
05D90:  MOVWF  x5A
05D92:  MOVLW  71
05D94:  MOVWF  x5B
05D96:  MOVLW  73
05D98:  MOVWF  x5C
05D9A:  MOVLW  74
05D9C:  MOVWF  x5D
05D9E:  MOVLW  75
05DA0:  MOVWF  x5E
05DA2:  MOVLW  76
05DA4:  MOVWF  x5F
05DA6:  MOVLW  77
05DA8:  MOVWF  x60
05DAA:  MOVLW  78
05DAC:  MOVWF  x61
05DAE:  MOVLW  79
05DB0:  MOVWF  x62
05DB2:  MOVLW  7A
05DB4:  MOVWF  x63
05DB6:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
05DB8:  MOVFF  734,739
05DBC:  MOVFF  733,738
05DC0:  MOVFF  739,FEA
05DC4:  MOVFF  738,FE9
05DC8:  MOVF   FEF,W
05DCA:  SUBLW  20
05DCC:  BNZ   5DD6
05DCE:  INCF   x38,F
05DD0:  BTFSC  FD8.2
05DD2:  INCF   x39,F
05DD4:  BRA    5DC0
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05DD6:  MOVFF  739,03
05DDA:  MOVFF  738,FE9
05DDE:  MOVFF  03,FEA
05DE2:  MOVF   FEF,W
05DE4:  SUBLW  2D
05DE6:  BZ    5DF6
05DE8:  MOVFF  739,FEA
05DEC:  MOVFF  738,FE9
05DF0:  MOVF   FEF,W
05DF2:  SUBLW  2B
05DF4:  BNZ   5E08
05DF6:  MOVFF  739,FEA
05DFA:  MOVF   x38,W
05DFC:  INCF   x38,F
05DFE:  BTFSC  FD8.2
05E00:  INCF   x39,F
05E02:  MOVWF  FE9
05E04:  MOVF   FEF,W
05E06:  BRA    5E0A
05E08:  MOVLW  2B
05E0A:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05E0C:  MOVF   x40,W
05E0E:  SUBLW  2D
05E10:  BZ    5E26
05E12:  BTFSC  x37.7
05E14:  BRA    5E26
05E16:  DECFSZ x37,W
05E18:  BRA    5E1C
05E1A:  BRA    5E26
05E1C:  BTFSC  x37.7
05E1E:  BRA    5E2A
05E20:  MOVF   x37,W
05E22:  SUBLW  24
05E24:  BC    5E2A
....................    goto StrtoulGO;
05E26:  BRA    6032
05E28:  BRA    5F22
.................... 
....................    else if (base)
05E2A:  MOVF   x37,F
05E2C:  BZ    5EBA
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05E2E:  MOVF   x37,W
05E30:  SUBLW  10
05E32:  BNZ   5E6E
05E34:  MOVFF  739,FEA
05E38:  MOVFF  738,FE9
05E3C:  MOVF   FEF,W
05E3E:  SUBLW  30
05E40:  BNZ   5E6E
05E42:  MOVLW  01
05E44:  ADDWF  x38,W
05E46:  MOVWF  FE9
05E48:  MOVLW  00
05E4A:  ADDWFC x39,W
05E4C:  MOVWF  FEA
05E4E:  MOVF   FEF,W
05E50:  SUBLW  78
05E52:  BZ    5E66
05E54:  MOVLW  01
05E56:  ADDWF  x38,W
05E58:  MOVWF  FE9
05E5A:  MOVLW  00
05E5C:  ADDWFC x39,W
05E5E:  MOVWF  FEA
05E60:  MOVF   FEF,W
05E62:  SUBLW  58
05E64:  BNZ   5E6E
....................          sc+=2;
05E66:  MOVLW  02
05E68:  ADDWF  x38,F
05E6A:  MOVLW  00
05E6C:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
05E6E:  MOVF   x37,W
05E70:  SUBLW  08
05E72:  BNZ   5E8A
05E74:  MOVFF  739,FEA
05E78:  MOVFF  738,FE9
05E7C:  MOVF   FEF,W
05E7E:  SUBLW  30
05E80:  BNZ   5E8A
....................          sc+=1;
05E82:  MOVLW  01
05E84:  ADDWF  x38,F
05E86:  MOVLW  00
05E88:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05E8A:  MOVF   x37,W
05E8C:  SUBLW  02
05E8E:  BNZ   5EB8
05E90:  MOVFF  739,FEA
05E94:  MOVFF  738,FE9
05E98:  MOVF   FEF,W
05E9A:  SUBLW  30
05E9C:  BNZ   5EB8
05E9E:  MOVLW  01
05EA0:  ADDWF  x38,W
05EA2:  MOVWF  FE9
05EA4:  MOVLW  00
05EA6:  ADDWFC x39,W
05EA8:  MOVWF  FEA
05EAA:  MOVF   FEF,W
05EAC:  SUBLW  62
05EAE:  BNZ   5EB8
....................          sc+=2;
05EB0:  MOVLW  02
05EB2:  ADDWF  x38,F
05EB4:  MOVLW  00
05EB6:  ADDWFC x39,F
.................... 
....................    }
05EB8:  BRA    5F22
....................    else if(*sc!='0') // base is 0, find base
05EBA:  MOVFF  739,FEA
05EBE:  MOVFF  738,FE9
05EC2:  MOVF   FEF,W
05EC4:  SUBLW  30
05EC6:  BZ    5ECE
....................       base=10;
05EC8:  MOVLW  0A
05ECA:  MOVWF  x37
05ECC:  BRA    5F22
....................    else if (sc[1]=='x' || sc[1]=='X')
05ECE:  MOVLW  01
05ED0:  ADDWF  x38,W
05ED2:  MOVWF  FE9
05ED4:  MOVLW  00
05ED6:  ADDWFC x39,W
05ED8:  MOVWF  FEA
05EDA:  MOVF   FEF,W
05EDC:  SUBLW  78
05EDE:  BZ    5EF2
05EE0:  MOVLW  01
05EE2:  ADDWF  x38,W
05EE4:  MOVWF  FE9
05EE6:  MOVLW  00
05EE8:  ADDWFC x39,W
05EEA:  MOVWF  FEA
05EEC:  MOVF   FEF,W
05EEE:  SUBLW  58
05EF0:  BNZ   5F00
....................       base =16,sc+=2;
05EF2:  MOVLW  10
05EF4:  MOVWF  x37
05EF6:  MOVLW  02
05EF8:  ADDWF  x38,F
05EFA:  MOVLW  00
05EFC:  ADDWFC x39,F
05EFE:  BRA    5F22
....................    else if(sc[1]=='b')
05F00:  MOVLW  01
05F02:  ADDWF  x38,W
05F04:  MOVWF  FE9
05F06:  MOVLW  00
05F08:  ADDWFC x39,W
05F0A:  MOVWF  FEA
05F0C:  MOVF   FEF,W
05F0E:  SUBLW  62
05F10:  BNZ   5F1E
....................       base=2,sc+=2;
05F12:  MOVLW  02
05F14:  MOVWF  x37
05F16:  ADDWF  x38,F
05F18:  MOVLW  00
05F1A:  ADDWFC x39,F
05F1C:  BRA    5F22
....................    else
....................       base=8;
05F1E:  MOVLW  08
05F20:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05F22:  MOVFF  739,73B
05F26:  MOVFF  738,73A
05F2A:  MOVFF  739,FEA
05F2E:  MOVFF  738,FE9
05F32:  MOVF   FEF,W
05F34:  SUBLW  30
05F36:  BNZ   5F40
05F38:  INCF   x38,F
05F3A:  BTFSC  FD8.2
05F3C:  INCF   x39,F
05F3E:  BRA    5F2A
....................    sd=memchr(digits,tolower(*sc),base);
05F40:  MOVFF  739,03
05F44:  MOVFF  738,FE9
05F48:  MOVFF  03,FEA
05F4C:  MOVFF  FEF,765
05F50:  MOVF   x65,W
05F52:  SUBLW  40
05F54:  BC    5F62
05F56:  MOVF   x65,W
05F58:  SUBLW  5A
05F5A:  BNC   5F62
05F5C:  MOVF   x65,W
05F5E:  IORLW  20
05F60:  BRA    5F64
05F62:  MOVF   x65,W
05F64:  MOVWF  x65
05F66:  MOVLW  07
05F68:  MOVWF  x67
05F6A:  MOVLW  41
05F6C:  MOVWF  x66
05F6E:  MOVFF  765,768
05F72:  CLRF   x6A
05F74:  MOVFF  737,769
05F78:  BTFSC  x69.7
05F7A:  DECF   x6A,F
05F7C:  MOVLB  0
05F7E:  RCALL  5C84
05F80:  MOVFF  02,73D
05F84:  MOVFF  01,73C
....................    for(; sd!=0; )
05F88:  MOVLB  7
05F8A:  MOVF   x3C,F
05F8C:  BNZ   5F92
05F8E:  MOVF   x3D,F
05F90:  BZ    6026
....................    {
....................       x=x*base+(int16)(sd-digits);
05F92:  CLRF   03
05F94:  MOVF   x37,W
05F96:  MOVWF  00
05F98:  BTFSC  FE8.7
05F9A:  DECF   03,F
05F9C:  MOVWF  x65
05F9E:  MOVFF  03,766
05FA2:  MOVFF  73F,768
05FA6:  MOVFF  73E,767
05FAA:  MOVFF  03,76A
05FAE:  MOVWF  x69
05FB0:  MOVLB  0
05FB2:  BRA    5CCE
05FB4:  MOVFF  01,765
05FB8:  MOVLW  41
05FBA:  MOVLB  7
05FBC:  SUBWF  x3C,W
05FBE:  MOVWF  00
05FC0:  MOVLW  07
05FC2:  SUBWFB x3D,W
05FC4:  MOVWF  03
05FC6:  MOVF   00,W
05FC8:  ADDWF  01,W
05FCA:  MOVWF  01
05FCC:  MOVF   02,W
05FCE:  ADDWFC 03,F
05FD0:  MOVFF  01,73E
05FD4:  MOVFF  03,73F
....................       ++sc;
05FD8:  INCF   x38,F
05FDA:  BTFSC  FD8.2
05FDC:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
05FDE:  MOVFF  739,FEA
05FE2:  MOVFF  738,FE9
05FE6:  MOVFF  FEF,765
05FEA:  MOVF   x65,W
05FEC:  SUBLW  40
05FEE:  BC    5FFC
05FF0:  MOVF   x65,W
05FF2:  SUBLW  5A
05FF4:  BNC   5FFC
05FF6:  MOVF   x65,W
05FF8:  IORLW  20
05FFA:  BRA    5FFE
05FFC:  MOVF   x65,W
05FFE:  MOVWF  x65
06000:  MOVLW  07
06002:  MOVWF  x67
06004:  MOVLW  41
06006:  MOVWF  x66
06008:  MOVFF  765,768
0600C:  CLRF   x6A
0600E:  MOVFF  737,769
06012:  BTFSC  x69.7
06014:  DECF   x6A,F
06016:  MOVLB  0
06018:  RCALL  5C84
0601A:  MOVFF  02,73D
0601E:  MOVFF  01,73C
06022:  BRA    5F88
06024:  MOVLB  7
....................    }
....................    if(s1==sc)
06026:  MOVF   x38,W
06028:  SUBWF  x3A,W
0602A:  BNZ   6054
0602C:  MOVF   x39,W
0602E:  SUBWF  x3B,W
06030:  BNZ   6054
....................    {
....................    StrtoulGO:
....................       if (endptr)
06032:  MOVLB  7
06034:  MOVF   x35,W
06036:  IORWF  x36,W
06038:  BZ    604C
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
0603A:  MOVFF  736,FEA
0603E:  MOVFF  735,FE9
06042:  MOVFF  734,FEC
06046:  MOVF   FED,F
06048:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
0604C:  MOVLW  00
0604E:  MOVWF  01
06050:  MOVWF  02
06052:  BRA    6074
....................    }
....................    if (endptr)
06054:  MOVF   x35,W
06056:  IORWF  x36,W
06058:  BZ    606C
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
0605A:  MOVFF  736,FEA
0605E:  MOVFF  735,FE9
06062:  MOVFF  739,FEC
06066:  MOVF   FED,F
06068:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
0606C:  MOVFF  73E,01
06070:  MOVFF  73F,02
06074:  MOVLB  0
06076:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
004A2:  MOVLB  7
004A4:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
004A6:  CLRF   x00
004A8:  MOVLB  6
004AA:  MOVF   xFF,W
004AC:  MOVLB  7
004AE:  SUBWF  x00,W
004B0:  BC    0512
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
004B2:  MOVF   x00,W
004B4:  MOVLB  6
004B6:  ADDWF  xFD,W
004B8:  MOVLB  7
004BA:  MOVWF  x01
004BC:  MOVLW  00
004BE:  MOVLB  6
004C0:  ADDWFC xFE,W
004C2:  MOVLB  7
004C4:  MOVWF  x02
004C6:  MOVF   x00,W
004C8:  MOVLB  6
004CA:  ADDWF  xFB,W
004CC:  MOVWF  01
004CE:  MOVLW  00
004D0:  ADDWFC xFC,W
004D2:  MOVWF  03
004D4:  MOVF   01,W
004D6:  MOVWF  FE9
004D8:  MOVFF  03,FEA
004DC:  MOVFF  FEF,703
004E0:  BSF    F7F.7
004E2:  MOVF   FF2,W
004E4:  MOVWF  00
004E6:  BCF    FF2.7
004E8:  MOVFF  702,F7A
004EC:  MOVFF  701,F79
004F0:  MOVLW  31
004F2:  MOVWF  F7B
004F4:  MOVFF  703,F7C
004F8:  MOVLB  F
004FA:  MOVLW  55
004FC:  MOVWF  F81
004FE:  MOVLW  AA
00500:  MOVWF  F81
00502:  BSF    F80.4
00504:  BTFSC  F80.4
00506:  BRA    0504
00508:  MOVF   00,W
0050A:  IORWF  FF2,F
0050C:  MOVLB  7
0050E:  INCF   x00,F
00510:  BRA    04A8
....................    }
00512:  MOVLB  0
00514:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00440:  MOVLB  7
00442:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00444:  CLRF   x00
00446:  MOVLB  6
00448:  MOVF   xFF,W
0044A:  MOVLB  7
0044C:  SUBWF  x00,W
0044E:  BC    049E
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00450:  MOVF   x00,W
00452:  MOVLB  6
00454:  ADDWF  xFB,W
00456:  MOVWF  01
00458:  MOVLW  00
0045A:  ADDWFC xFC,W
0045C:  MOVWF  03
0045E:  MOVF   01,W
00460:  MOVWF  FE9
00462:  MOVFF  03,FEA
00466:  MOVLB  7
00468:  MOVF   x00,W
0046A:  MOVLB  6
0046C:  ADDWF  xFD,W
0046E:  MOVLB  7
00470:  MOVWF  x03
00472:  MOVLW  00
00474:  MOVLB  6
00476:  ADDWFC xFE,W
00478:  MOVLB  7
0047A:  MOVWF  x04
0047C:  BSF    F7F.7
0047E:  MOVFF  FF2,705
00482:  BCF    FF2.7
00484:  MOVFF  704,F7A
00488:  MOVFF  703,F79
0048C:  MOVLW  31
0048E:  MOVWF  F7B
00490:  BSF    F80.0
00492:  MOVF   F7C,W
00494:  BTFSC  x05.7
00496:  BSF    FF2.7
00498:  MOVWF  FEF
0049A:  INCF   x00,F
0049C:  BRA    0446
....................    }
0049E:  MOVLB  0
004A0:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
00516:  MOVLB  6
00518:  CLRF   xFC
0051A:  MOVLW  20
0051C:  MOVWF  xFB
0051E:  CLRF   xFE
00520:  CLRF   xFD
00522:  MOVLW  80
00524:  MOVWF  xFF
00526:  MOVLB  0
00528:  RCALL  04A2
....................    delay_ms(1);
0052A:  MOVLW  01
0052C:  MOVLB  7
0052E:  MOVWF  x01
00530:  MOVLB  0
00532:  RCALL  03D2
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
00534:  MOVLB  6
00536:  CLRF   xFC
00538:  MOVLW  70
0053A:  MOVWF  xFB
0053C:  CLRF   xFE
0053E:  MOVLW  80
00540:  MOVWF  xFD
00542:  MOVLW  02
00544:  MOVWF  xFF
00546:  MOVLB  0
00548:  RCALL  04A2
....................    delay_ms(1);
0054A:  MOVLW  01
0054C:  MOVLB  7
0054E:  MOVWF  x01
00550:  MOVLB  0
00552:  RCALL  03D2
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00554:  MOVLB  6
00556:  CLRF   xFC
00558:  MOVLW  71
0055A:  MOVWF  xFB
0055C:  CLRF   xFE
0055E:  MOVLW  90
00560:  MOVWF  xFD
00562:  MOVLW  02
00564:  MOVWF  xFF
00566:  MOVLB  0
00568:  RCALL  04A2
....................    delay_ms(1);
0056A:  MOVLW  01
0056C:  MOVLB  7
0056E:  MOVWF  x01
00570:  MOVLB  0
00572:  RCALL  03D2
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00574:  MOVLB  6
00576:  CLRF   xFC
00578:  MOVLW  72
0057A:  MOVWF  xFB
0057C:  CLRF   xFE
0057E:  MOVLW  A0
00580:  MOVWF  xFD
00582:  MOVLW  20
00584:  MOVWF  xFF
00586:  MOVLB  0
00588:  RCALL  04A2
....................    delay_ms(1);
0058A:  MOVLW  01
0058C:  MOVLB  7
0058E:  MOVWF  x01
00590:  MOVLB  0
00592:  RCALL  03D2
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00594:  MOVLB  6
00596:  CLRF   xFC
00598:  MOVLW  92
0059A:  MOVWF  xFB
0059C:  CLRF   xFE
0059E:  MOVLW  C0
005A0:  MOVWF  xFD
005A2:  MOVLW  30
005A4:  MOVWF  xFF
005A6:  MOVLB  0
005A8:  RCALL  04A2
....................    delay_ms(1);
005AA:  MOVLW  01
005AC:  MOVLB  7
005AE:  MOVWF  x01
005B0:  MOVLB  0
005B2:  RCALL  03D2
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005B4:  MOVLB  6
005B6:  CLRF   xFC
005B8:  MOVLW  C2
005BA:  MOVWF  xFB
005BC:  CLRF   xFE
005BE:  MOVLW  F0
005C0:  MOVWF  xFD
005C2:  MOVLW  38
005C4:  MOVWF  xFF
005C6:  MOVLB  0
005C8:  RCALL  04A2
....................    delay_ms(1);
005CA:  MOVLW  01
005CC:  MOVLB  7
005CE:  MOVWF  x01
005D0:  MOVLB  0
005D2:  RCALL  03D2
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005D4:  MOVLB  6
005D6:  CLRF   xFC
005D8:  MOVLW  FA
005DA:  MOVWF  xFB
005DC:  MOVLW  01
005DE:  MOVWF  xFE
005E0:  MOVLW  40
005E2:  MOVWF  xFD
005E4:  MOVLW  01
005E6:  MOVWF  xFF
005E8:  MOVLB  0
005EA:  RCALL  04A2
....................    delay_ms(1);
005EC:  MOVLW  01
005EE:  MOVLB  7
005F0:  MOVWF  x01
005F2:  MOVLB  0
005F4:  RCALL  03D2
005F6:  GOTO   06C6 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005FA:  MOVLB  6
005FC:  CLRF   xFC
005FE:  MOVLW  20
00600:  MOVWF  xFB
00602:  CLRF   xFE
00604:  CLRF   xFD
00606:  MOVLW  80
00608:  MOVWF  xFF
0060A:  MOVLB  0
0060C:  RCALL  0440
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
0060E:  MOVLB  6
00610:  CLRF   xFC
00612:  MOVLW  70
00614:  MOVWF  xFB
00616:  CLRF   xFE
00618:  MOVLW  80
0061A:  MOVWF  xFD
0061C:  MOVLW  02
0061E:  MOVWF  xFF
00620:  MOVLB  0
00622:  RCALL  0440
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00624:  MOVLB  6
00626:  CLRF   xFC
00628:  MOVLW  71
0062A:  MOVWF  xFB
0062C:  CLRF   xFE
0062E:  MOVLW  90
00630:  MOVWF  xFD
00632:  MOVLW  02
00634:  MOVWF  xFF
00636:  MOVLB  0
00638:  RCALL  0440
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0063A:  MOVLB  6
0063C:  CLRF   xFC
0063E:  MOVLW  72
00640:  MOVWF  xFB
00642:  CLRF   xFE
00644:  MOVLW  A0
00646:  MOVWF  xFD
00648:  MOVLW  20
0064A:  MOVWF  xFF
0064C:  MOVLB  0
0064E:  RCALL  0440
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00650:  MOVLB  6
00652:  CLRF   xFC
00654:  MOVLW  92
00656:  MOVWF  xFB
00658:  CLRF   xFE
0065A:  MOVLW  C0
0065C:  MOVWF  xFD
0065E:  MOVLW  30
00660:  MOVWF  xFF
00662:  MOVLB  0
00664:  RCALL  0440
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00666:  MOVLB  6
00668:  CLRF   xFC
0066A:  MOVLW  C2
0066C:  MOVWF  xFB
0066E:  CLRF   xFE
00670:  MOVLW  F0
00672:  MOVWF  xFD
00674:  MOVLW  38
00676:  MOVWF  xFF
00678:  MOVLB  0
0067A:  RCALL  0440
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0067C:  MOVLB  6
0067E:  CLRF   xFC
00680:  MOVLW  FA
00682:  MOVWF  xFB
00684:  MOVLW  01
00686:  MOVWF  xFE
00688:  MOVLW  40
0068A:  MOVWF  xFD
0068C:  MOVLW  01
0068E:  MOVWF  xFF
00690:  MOVLB  0
00692:  RCALL  0440
00694:  GOTO   06CA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00698:  MOVLB  6
0069A:  CLRF   xFC
0069C:  MOVLW  FA
0069E:  MOVWF  xFB
006A0:  MOVLW  01
006A2:  MOVWF  xFE
006A4:  MOVLW  40
006A6:  MOVWF  xFD
006A8:  MOVLW  01
006AA:  MOVWF  xFF
006AC:  MOVLB  0
006AE:  RCALL  0440
....................    delay_ms(1);
006B0:  MOVLW  01
006B2:  MOVLB  7
006B4:  MOVWF  x01
006B6:  MOVLB  0
006B8:  RCALL  03D2
....................    if (paramsValid != isValid)
006BA:  MOVF   xFA,W
006BC:  SUBLW  AA
006BE:  BZ    06C8
....................    {
....................       paramsValid = isValid;
006C0:  MOVLW  AA
006C2:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
006C4:  BRA    0516
....................    }
006C6:  BRA    06CA
....................    else
....................    {
....................       params_load_from_ee();
006C8:  BRA    05FA
....................    }
006CA:  GOTO   A724 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
0016E:  MOVLW  1F
00170:  MOVWF  F8A
00172:  BSF    F85.5
....................    output_high(_CS1);
00174:  MOVWF  F8A
00176:  BSF    F85.6
....................    output_high(_CS2);
00178:  MOVWF  F8A
0017A:  BSF    F85.7
....................    output_high(_CS3); 
0017C:  MOVLW  04
0017E:  MOVWF  F88
00180:  BSF    F83.0
....................    delay_us(10);
00182:  MOVLW  35
00184:  MOVWF  00
00186:  DECFSZ 00,F
00188:  BRA    0186
0018A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
006CE:  RCALL  016E
....................    switch(ch)
006D0:  MOVLB  7
006D2:  MOVF   x0C,W
006D4:  ADDLW  FC
006D6:  BC    070A
006D8:  ADDLW  04
006DA:  MOVLB  0
006DC:  GOTO   0716
....................    {
....................       case 0:
....................          output_low(_CS0);
006E0:  MOVLW  1F
006E2:  MOVWF  F8A
006E4:  BCF    F85.5
....................       break; 
006E6:  MOVLB  7
006E8:  BRA    070A
....................       case 1:
....................          output_low(_CS1);
006EA:  MOVLW  1F
006EC:  MOVWF  F8A
006EE:  BCF    F85.6
....................       break;   
006F0:  MOVLB  7
006F2:  BRA    070A
....................       case 2:
....................          output_low(_CS2);
006F4:  MOVLW  1F
006F6:  MOVWF  F8A
006F8:  BCF    F85.7
....................       break;
006FA:  MOVLB  7
006FC:  BRA    070A
....................       case 3:
....................          output_low(_CS3);
006FE:  MOVLW  04
00700:  MOVWF  F88
00702:  BCF    F83.0
....................       break;              
00704:  MOVLB  7
00706:  BRA    070A
00708:  MOVLB  7
....................    }
....................    delay_us(10);
0070A:  MOVLW  35
0070C:  MOVWF  00
0070E:  DECFSZ 00,F
00710:  BRA    070E
00712:  MOVLB  0
00714:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0018C:  RCALL  016E
....................    switch(block)
0018E:  MOVLB  7
00190:  MOVF   x74,W
00192:  XORLW  00
00194:  MOVLB  0
00196:  BZ    019E
00198:  XORLW  01
0019A:  BZ    01AA
0019C:  BRA    01B6
....................    {
....................       case 0:
....................          output_low(_CS0);
0019E:  MOVLW  1F
001A0:  MOVWF  F8A
001A2:  BCF    F85.5
....................          output_low(_CS1);
001A4:  MOVWF  F8A
001A6:  BCF    F85.6
....................       break; 
001A8:  BRA    01B6
....................       case 1:         
....................          output_low(_CS2);
001AA:  MOVLW  1F
001AC:  MOVWF  F8A
001AE:  BCF    F85.7
....................          output_low(_CS3);
001B0:  MOVLW  04
001B2:  MOVWF  F88
001B4:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
001B6:  MOVLW  35
001B8:  MOVWF  00
001BA:  DECFSZ 00,F
001BC:  BRA    01BA
001BE:  GOTO   01C8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
00800:  MOVLW  1F
00802:  MOVWF  F8A
00804:  BCF    F85.5
....................    output_low(_CS1);
00806:  MOVWF  F8A
00808:  BCF    F85.6
....................    output_low(_CS2);
0080A:  MOVWF  F8A
0080C:  BCF    F85.7
....................    output_low(_CS3);
0080E:  MOVLW  04
00810:  MOVWF  F88
00812:  BCF    F83.0
....................    delay_us(10);
00814:  MOVLW  35
00816:  MOVWF  00
00818:  DECFSZ 00,F
0081A:  BRA    0818
0081C:  GOTO   0822 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00738:  MOVFF  70A,70C
0073C:  RCALL  06CE
....................    spi_write2(command);
0073E:  MOVLB  E
00740:  MOVF   x8D,W
00742:  MOVFF  70B,E8D
00746:  RRCF   x90,W
00748:  BNC   0746
0074A:  MOVLB  0
0074C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C2:  MOVFF  772,774
001C6:  BRA    018C
....................    spi_write2(command);
001C8:  MOVLB  E
001CA:  MOVF   x8D,W
001CC:  MOVFF  773,E8D
001D0:  RRCF   x90,W
001D2:  BNC   01D0
001D4:  MOVLB  0
001D6:  GOTO   01E8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
00820:  BRA    0800
....................    spi_write2(command);
00822:  MOVLB  E
00824:  MOVF   x8D,W
00826:  MOVFF  701,E8D
0082A:  RRCF   x90,W
0082C:  BNC   082A
0082E:  MOVLB  0
00830:  GOTO   083E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0084C:  MOVFF  709,70C
00850:  RCALL  06CE
....................    spi_read2(command);
00852:  MOVLB  E
00854:  MOVF   x8D,W
00856:  MOVFF  70A,E8D
0085A:  RRCF   x90,W
0085C:  BNC   085A
0085E:  MOVLB  0
00860:  GOTO   0872 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00770:  MOVLB  7
00772:  MOVF   x07,W
00774:  IORLW  40
00776:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00778:  MOVFF  706,70A
0077C:  MOVFF  709,70B
00780:  MOVLB  0
00782:  RCALL  0738
....................    spi_write2(data);
00784:  MOVLB  E
00786:  MOVF   x8D,W
00788:  MOVFF  708,E8D
0078C:  RRCF   x90,W
0078E:  BNC   078C
....................    ads_deselect_all();
00790:  MOVLB  0
00792:  RCALL  016E
00794:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001DA:  MOVFF  771,772
001DE:  MOVLW  08
001E0:  MOVLB  7
001E2:  MOVWF  x73
001E4:  MOVLB  0
001E6:  BRA    01C2
....................    delay_us(10);
001E8:  MOVLW  35
001EA:  MOVWF  00
001EC:  DECFSZ 00,F
001EE:  BRA    01EC
....................    ads_deselect_all();
001F0:  RCALL  016E
001F2:  GOTO   0238 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
00834:  MOVLW  08
00836:  MOVLB  7
00838:  MOVWF  x01
0083A:  MOVLB  0
0083C:  BRA    0820
....................    delay_us(10);
0083E:  MOVLW  35
00840:  MOVWF  00
00842:  DECFSZ 00,F
00844:  BRA    0842
....................    ads_deselect_all();
00846:  RCALL  016E
00848:  GOTO   09CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00864:  MOVFF  704,709
00868:  MOVLW  10
0086A:  MOVLB  7
0086C:  MOVWF  x0A
0086E:  MOVLB  0
00870:  BRA    084C
....................    data.dBytes[3] = 0;
00872:  MOVLB  7
00874:  CLRF   x08
....................    data.dBytes[2] = spi_read2(0);
00876:  MOVLB  E
00878:  MOVF   x8D,W
0087A:  CLRF   x8D
0087C:  RRCF   x90,W
0087E:  BNC   087C
00880:  MOVFF  E8D,707
....................    data.dBytes[1] = spi_read2(0);
00884:  MOVF   x8D,W
00886:  CLRF   x8D
00888:  RRCF   x90,W
0088A:  BNC   0888
0088C:  MOVFF  E8D,706
....................    data.dBytes[0] = spi_read2(0);
00890:  MOVF   x8D,W
00892:  CLRF   x8D
00894:  RRCF   x90,W
00896:  BNC   0894
00898:  MOVFF  E8D,705
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
0089C:  MOVLB  7
0089E:  MOVF   x07,W
008A0:  ANDLW  80
008A2:  BZ    08A8
008A4:  MOVLW  FF
008A6:  IORWF  x08,F
....................    
....................    ads_deselect_all();
008A8:  MOVLB  0
008AA:  RCALL  016E
....................    return data.dWord;
008AC:  MOVFF  705,00
008B0:  MOVFF  706,01
008B4:  MOVFF  707,02
008B8:  MOVFF  708,03
008BC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00796:  MOVFF  701,70A
0079A:  MOVLW  06
0079C:  MOVLB  7
0079E:  MOVWF  x0B
007A0:  MOVLB  0
007A2:  RCALL  0738
....................    delay_us(300);                    
007A4:  MOVLW  02
007A6:  MOVLB  7
007A8:  MOVWF  x06
007AA:  MOVLW  96
007AC:  MOVWF  x07
007AE:  MOVLB  0
007B0:  RCALL  074E
007B2:  MOVLB  7
007B4:  DECFSZ x06,F
007B6:  BRA    07AA
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
007B8:  MOVFF  701,706
007BC:  CLRF   x07
007BE:  MOVFF  702,708
007C2:  MOVLB  0
007C4:  RCALL  0770
....................    ads_write_reg(ch, reg1, rc1);
007C6:  MOVFF  701,706
007CA:  MOVLW  04
007CC:  MOVLB  7
007CE:  MOVWF  x07
007D0:  MOVFF  703,708
007D4:  MOVLB  0
007D6:  RCALL  0770
....................    ads_write_reg(ch, reg2, rc2);
007D8:  MOVFF  701,706
007DC:  MOVLW  08
007DE:  MOVLB  7
007E0:  MOVWF  x07
007E2:  MOVFF  704,708
007E6:  MOVLB  0
007E8:  RCALL  0770
....................    ads_write_reg(ch, reg3, rc3);  
007EA:  MOVFF  701,706
007EE:  MOVLW  0C
007F0:  MOVLB  7
007F2:  MOVWF  x07
007F4:  MOVFF  705,708
007F8:  MOVLB  0
007FA:  RCALL  0770
007FC:  GOTO   09A8 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02764:  MOVLB  7
02766:  BCF    x45.0
....................    y = x;
02768:  MOVFF  739,73E
0276C:  MOVFF  738,73D
02770:  MOVFF  737,73C
02774:  MOVFF  736,73B
.................... 
....................    if (x < 0)
02778:  MOVFF  739,749
0277C:  MOVFF  738,748
02780:  MOVFF  737,747
02784:  MOVFF  736,746
02788:  CLRF   x4D
0278A:  CLRF   x4C
0278C:  CLRF   x4B
0278E:  CLRF   x4A
02790:  MOVLB  0
02792:  CALL   1D34
02796:  BNC   27A4
....................    {
....................       s = 1;
02798:  MOVLB  7
0279A:  BSF    x45.0
....................       y = -y;
0279C:  MOVF   x3C,W
0279E:  XORLW  80
027A0:  MOVWF  x3C
027A2:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
027A4:  MOVFF  73E,749
027A8:  MOVFF  73D,748
027AC:  MOVFF  73C,747
027B0:  MOVFF  73B,746
027B4:  MOVLB  7
027B6:  CLRF   x4D
027B8:  CLRF   x4C
027BA:  CLRF   x4B
027BC:  MOVLW  8E
027BE:  MOVWF  x4A
027C0:  MOVLB  0
027C2:  CALL   1D34
027C6:  BC    27CA
027C8:  BNZ   27FA
....................       res = (float32)(unsigned int16)y;
027CA:  MOVFF  73E,749
027CE:  MOVFF  73D,748
027D2:  MOVFF  73C,747
027D6:  MOVFF  73B,746
027DA:  RCALL  2728
027DC:  MOVFF  02,74B
027E0:  MOVFF  01,74A
027E4:  CALL   0D72
027E8:  MOVFF  03,742
027EC:  MOVFF  02,741
027F0:  MOVFF  01,740
027F4:  MOVFF  00,73F
027F8:  BRA    299C
.................... 
....................  else if (y < 10000000.0)
027FA:  MOVFF  73E,749
027FE:  MOVFF  73D,748
02802:  MOVFF  73C,747
02806:  MOVFF  73B,746
0280A:  MOVLW  80
0280C:  MOVLB  7
0280E:  MOVWF  x4D
02810:  MOVLW  96
02812:  MOVWF  x4C
02814:  MOVLW  18
02816:  MOVWF  x4B
02818:  MOVLW  96
0281A:  MOVWF  x4A
0281C:  MOVLB  0
0281E:  CALL   1D34
02822:  BTFSS  FD8.0
02824:  BRA    298C
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02826:  MOVFF  73E,753
0282A:  MOVFF  73D,752
0282E:  MOVFF  73C,751
02832:  MOVFF  73B,750
02836:  MOVLB  7
02838:  CLRF   x57
0283A:  CLRF   x56
0283C:  CLRF   x55
0283E:  MOVLW  70
02840:  MOVWF  x54
02842:  MOVLB  0
02844:  CALL   0DA8
02848:  MOVFF  03,749
0284C:  MOVFF  02,748
02850:  MOVFF  01,747
02854:  MOVFF  00,746
02858:  RCALL  2728
0285A:  MOVFF  02,744
0285E:  MOVFF  01,743
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02862:  MOVFF  73E,753
02866:  MOVFF  73D,752
0286A:  MOVFF  73C,751
0286E:  MOVFF  73B,750
02872:  MOVLB  7
02874:  CLRF   x57
02876:  CLRF   x56
02878:  CLRF   x55
0287A:  MOVLW  70
0287C:  MOVWF  x54
0287E:  MOVLB  0
02880:  CALL   0DA8
02884:  MOVFF  03,749
02888:  MOVFF  02,748
0288C:  MOVFF  01,747
02890:  MOVFF  00,746
02894:  MOVFF  744,74B
02898:  MOVFF  743,74A
0289C:  CALL   0D72
028A0:  BSF    FD8.1
028A2:  MOVFF  749,74D
028A6:  MOVFF  748,74C
028AA:  MOVFF  747,74B
028AE:  MOVFF  746,74A
028B2:  MOVFF  03,751
028B6:  MOVFF  02,750
028BA:  MOVFF  01,74F
028BE:  MOVFF  00,74E
028C2:  CALL   0E9E
028C6:  MOVLB  7
028C8:  CLRF   x53
028CA:  CLRF   x52
028CC:  CLRF   x51
028CE:  MOVLW  8E
028D0:  MOVWF  x50
028D2:  MOVFF  03,757
028D6:  MOVFF  02,756
028DA:  MOVFF  01,755
028DE:  MOVFF  00,754
028E2:  MOVLB  0
028E4:  CALL   0DA8
028E8:  MOVFF  03,73E
028EC:  MOVFF  02,73D
028F0:  MOVFF  01,73C
028F4:  MOVFF  00,73B
....................       res = 32768.0*(float32)l;
028F8:  MOVFF  744,74B
028FC:  MOVFF  743,74A
02900:  CALL   0D72
02904:  MOVLB  7
02906:  CLRF   x53
02908:  CLRF   x52
0290A:  CLRF   x51
0290C:  MOVLW  8E
0290E:  MOVWF  x50
02910:  MOVFF  03,757
02914:  MOVFF  02,756
02918:  MOVFF  01,755
0291C:  MOVFF  00,754
02920:  MOVLB  0
02922:  CALL   0DA8
02926:  MOVFF  03,742
0292A:  MOVFF  02,741
0292E:  MOVFF  01,740
02932:  MOVFF  00,73F
....................       res += (float32)(unsigned int16)y;
02936:  MOVFF  73E,749
0293A:  MOVFF  73D,748
0293E:  MOVFF  73C,747
02942:  MOVFF  73B,746
02946:  RCALL  2728
02948:  MOVFF  02,74B
0294C:  MOVFF  01,74A
02950:  CALL   0D72
02954:  BCF    FD8.1
02956:  MOVFF  742,74D
0295A:  MOVFF  741,74C
0295E:  MOVFF  740,74B
02962:  MOVFF  73F,74A
02966:  MOVFF  03,751
0296A:  MOVFF  02,750
0296E:  MOVFF  01,74F
02972:  MOVFF  00,74E
02976:  CALL   0E9E
0297A:  MOVFF  03,742
0297E:  MOVFF  02,741
02982:  MOVFF  01,740
02986:  MOVFF  00,73F
....................    }
0298A:  BRA    299C
.................... 
....................  else
....................   res = y;
0298C:  MOVFF  73E,742
02990:  MOVFF  73D,741
02994:  MOVFF  73C,740
02998:  MOVFF  73B,73F
.................... 
....................  y = y - (float32)(unsigned int16)y;
0299C:  MOVFF  73E,749
029A0:  MOVFF  73D,748
029A4:  MOVFF  73C,747
029A8:  MOVFF  73B,746
029AC:  RCALL  2728
029AE:  MOVFF  02,74B
029B2:  MOVFF  01,74A
029B6:  CALL   0D72
029BA:  BSF    FD8.1
029BC:  MOVFF  73E,74D
029C0:  MOVFF  73D,74C
029C4:  MOVFF  73C,74B
029C8:  MOVFF  73B,74A
029CC:  MOVFF  03,751
029D0:  MOVFF  02,750
029D4:  MOVFF  01,74F
029D8:  MOVFF  00,74E
029DC:  CALL   0E9E
029E0:  MOVFF  03,73E
029E4:  MOVFF  02,73D
029E8:  MOVFF  01,73C
029EC:  MOVFF  00,73B
.................... 
....................  if (s)
029F0:  MOVLB  7
029F2:  BTFSS  x45.0
029F4:  BRA    29FC
....................   res = -res;
029F6:  MOVF   x40,W
029F8:  XORLW  80
029FA:  MOVWF  x40
.................... 
....................  if (y != 0)
029FC:  MOVFF  73E,749
02A00:  MOVFF  73D,748
02A04:  MOVFF  73C,747
02A08:  MOVFF  73B,746
02A0C:  CLRF   x4D
02A0E:  CLRF   x4C
02A10:  CLRF   x4B
02A12:  CLRF   x4A
02A14:  MOVLB  0
02A16:  CALL   1D34
02A1A:  BZ    2A94
....................  {
....................   if (s == 1 && n == 0)
02A1C:  MOVLB  7
02A1E:  BTFSS  x45.0
02A20:  BRA    2A5A
02A22:  MOVF   x3A,F
02A24:  BNZ   2A5A
....................    res -= 1.0;
02A26:  BSF    FD8.1
02A28:  MOVFF  742,74D
02A2C:  MOVFF  741,74C
02A30:  MOVFF  740,74B
02A34:  MOVFF  73F,74A
02A38:  CLRF   x51
02A3A:  CLRF   x50
02A3C:  CLRF   x4F
02A3E:  MOVLW  7F
02A40:  MOVWF  x4E
02A42:  MOVLB  0
02A44:  CALL   0E9E
02A48:  MOVFF  03,742
02A4C:  MOVFF  02,741
02A50:  MOVFF  01,740
02A54:  MOVFF  00,73F
02A58:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A5A:  BTFSC  x45.0
02A5C:  BRA    2A96
02A5E:  DECFSZ x3A,W
02A60:  BRA    2A96
....................    res += 1.0;
02A62:  BCF    FD8.1
02A64:  MOVFF  742,74D
02A68:  MOVFF  741,74C
02A6C:  MOVFF  740,74B
02A70:  MOVFF  73F,74A
02A74:  CLRF   x51
02A76:  CLRF   x50
02A78:  CLRF   x4F
02A7A:  MOVLW  7F
02A7C:  MOVWF  x4E
02A7E:  MOVLB  0
02A80:  CALL   0E9E
02A84:  MOVFF  03,742
02A88:  MOVFF  02,741
02A8C:  MOVFF  01,740
02A90:  MOVFF  00,73F
02A94:  MOVLB  7
....................  }
....................  if (x == 0)
02A96:  MOVFF  739,749
02A9A:  MOVFF  738,748
02A9E:  MOVFF  737,747
02AA2:  MOVFF  736,746
02AA6:  CLRF   x4D
02AA8:  CLRF   x4C
02AAA:  CLRF   x4B
02AAC:  CLRF   x4A
02AAE:  MOVLB  0
02AB0:  CALL   1D34
02AB4:  BNZ   2AC2
....................     res = 0;
02AB6:  MOVLB  7
02AB8:  CLRF   x42
02ABA:  CLRF   x41
02ABC:  CLRF   x40
02ABE:  CLRF   x3F
02AC0:  MOVLB  0
.................... 
....................  return (res);
02AC2:  MOVFF  73F,00
02AC6:  MOVFF  740,01
02ACA:  MOVFF  741,02
02ACE:  MOVFF  742,03
02AD2:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AF2:  MOVFF  735,739
02AF6:  MOVFF  734,738
02AFA:  MOVFF  733,737
02AFE:  MOVFF  732,736
02B02:  MOVLB  7
02B04:  CLRF   x3A
02B06:  MOVLB  0
02B08:  RCALL  2764
02B0A:  GOTO   2C16 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02AD4:  MOVFF  735,739
02AD8:  MOVFF  734,738
02ADC:  MOVFF  733,737
02AE0:  MOVFF  732,736
02AE4:  MOVLW  01
02AE6:  MOVLB  7
02AE8:  MOVWF  x3A
02AEA:  MOVLB  0
02AEC:  RCALL  2764
02AEE:  GOTO   2BCE (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02B0E:  MOVFF  729,749
02B12:  MOVFF  728,748
02B16:  MOVFF  727,747
02B1A:  MOVFF  726,746
02B1E:  MOVLB  7
02B20:  CLRF   x4D
02B22:  CLRF   x4C
02B24:  CLRF   x4B
02B26:  CLRF   x4A
02B28:  MOVLB  0
02B2A:  CALL   1D34
02B2E:  BTFSC  FD8.2
02B30:  BRA    2C72
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02B32:  MOVFF  725,742
02B36:  MOVFF  724,741
02B3A:  MOVFF  723,740
02B3E:  MOVFF  722,73F
02B42:  MOVFF  729,746
02B46:  MOVFF  728,745
02B4A:  MOVFF  727,744
02B4E:  MOVFF  726,743
02B52:  CALL   1DAE
02B56:  MOVFF  03,731
02B5A:  MOVFF  02,730
02B5E:  MOVFF  01,72F
02B62:  MOVFF  00,72E
02B66:  MOVFF  03,749
02B6A:  MOVFF  02,748
02B6E:  MOVFF  01,747
02B72:  MOVFF  00,746
02B76:  MOVLB  7
02B78:  CLRF   x4D
02B7A:  CLRF   x4C
02B7C:  CLRF   x4B
02B7E:  CLRF   x4A
02B80:  MOVLB  0
02B82:  CALL   1D34
02B86:  BNC   2BD0
02B88:  MOVFF  725,742
02B8C:  MOVFF  724,741
02B90:  MOVFF  723,740
02B94:  MOVFF  722,73F
02B98:  MOVFF  729,746
02B9C:  MOVFF  728,745
02BA0:  MOVFF  727,744
02BA4:  MOVFF  726,743
02BA8:  CALL   1DAE
02BAC:  MOVFF  03,731
02BB0:  MOVFF  02,730
02BB4:  MOVFF  01,72F
02BB8:  MOVFF  00,72E
02BBC:  MOVFF  03,735
02BC0:  MOVFF  02,734
02BC4:  MOVFF  01,733
02BC8:  MOVFF  00,732
02BCC:  BRA    2AD4
02BCE:  BRA    2C16
02BD0:  MOVFF  725,742
02BD4:  MOVFF  724,741
02BD8:  MOVFF  723,740
02BDC:  MOVFF  722,73F
02BE0:  MOVFF  729,746
02BE4:  MOVFF  728,745
02BE8:  MOVFF  727,744
02BEC:  MOVFF  726,743
02BF0:  CALL   1DAE
02BF4:  MOVFF  03,731
02BF8:  MOVFF  02,730
02BFC:  MOVFF  01,72F
02C00:  MOVFF  00,72E
02C04:  MOVFF  03,735
02C08:  MOVFF  02,734
02C0C:  MOVFF  01,733
02C10:  MOVFF  00,732
02C14:  BRA    2AF2
02C16:  MOVFF  03,72D
02C1A:  MOVFF  02,72C
02C1E:  MOVFF  01,72B
02C22:  MOVFF  00,72A
....................       return(x-(i*y));
02C26:  MOVFF  72D,753
02C2A:  MOVFF  72C,752
02C2E:  MOVFF  72B,751
02C32:  MOVFF  72A,750
02C36:  MOVFF  729,757
02C3A:  MOVFF  728,756
02C3E:  MOVFF  727,755
02C42:  MOVFF  726,754
02C46:  CALL   0DA8
02C4A:  BSF    FD8.1
02C4C:  MOVFF  725,74D
02C50:  MOVFF  724,74C
02C54:  MOVFF  723,74B
02C58:  MOVFF  722,74A
02C5C:  MOVFF  03,751
02C60:  MOVFF  02,750
02C64:  MOVFF  01,74F
02C68:  MOVFF  00,74E
02C6C:  CALL   0E9E
02C70:  BRA    2C72
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C72:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
03008:  MOVFF  729,753
0300C:  MOVFF  728,752
03010:  MOVFF  727,751
03014:  MOVFF  726,750
03018:  MOVLW  3B
0301A:  MOVLB  7
0301C:  MOVWF  x57
0301E:  MOVLW  AA
03020:  MOVWF  x56
03022:  MOVLW  38
03024:  MOVWF  x55
03026:  MOVLW  7F
03028:  MOVWF  x54
0302A:  MOVLB  0
0302C:  CALL   0DA8
03030:  MOVFF  03,749
03034:  MOVFF  02,748
03038:  MOVFF  01,747
0303C:  MOVFF  00,746
03040:  CALL   2728
03044:  MOVFF  01,736
....................    s = 0;
03048:  MOVLB  7
0304A:  BCF    x37.0
....................    y = x;
0304C:  MOVFF  729,72D
03050:  MOVFF  728,72C
03054:  MOVFF  727,72B
03058:  MOVFF  726,72A
.................... 
....................    if (x < 0)
0305C:  MOVFF  729,749
03060:  MOVFF  728,748
03064:  MOVFF  727,747
03068:  MOVFF  726,746
0306C:  CLRF   x4D
0306E:  CLRF   x4C
03070:  CLRF   x4B
03072:  CLRF   x4A
03074:  MOVLB  0
03076:  CALL   1D34
0307A:  BNC   308A
....................    {
....................       s = 1;
0307C:  MOVLB  7
0307E:  BSF    x37.0
....................       n = -n;
03080:  NEGF   x36
....................       y = -y;
03082:  MOVF   x2B,W
03084:  XORLW  80
03086:  MOVWF  x2B
03088:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0308A:  MOVLB  7
0308C:  CLRF   x31
0308E:  CLRF   x30
03090:  CLRF   x2F
03092:  CLRF   x2E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03094:  MOVLW  07
03096:  MOVWF  x39
03098:  MOVLW  2E
0309A:  MOVFF  739,FEA
0309E:  MOVWF  FE9
030A0:  MOVLW  7F
030A2:  ADDWF  x36,W
030A4:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
030A6:  MOVFF  72D,753
030AA:  MOVFF  72C,752
030AE:  MOVFF  72B,751
030B2:  MOVFF  72A,750
030B6:  MOVLW  3B
030B8:  MOVWF  x57
030BA:  MOVLW  AA
030BC:  MOVWF  x56
030BE:  MOVLW  38
030C0:  MOVWF  x55
030C2:  MOVLW  7F
030C4:  MOVWF  x54
030C6:  MOVLB  0
030C8:  CALL   0DA8
030CC:  MOVFF  03,73B
030D0:  MOVFF  02,73A
030D4:  MOVFF  01,739
030D8:  MOVFF  00,738
030DC:  MOVLB  7
030DE:  CLRF   x3D
030E0:  MOVFF  736,73C
030E4:  BTFSC  x3C.7
030E6:  DECF   x3D,F
030E8:  MOVLB  0
030EA:  CALL   26D8
030EE:  BSF    FD8.1
030F0:  MOVFF  73B,74D
030F4:  MOVFF  73A,74C
030F8:  MOVFF  739,74B
030FC:  MOVFF  738,74A
03100:  MOVFF  03,751
03104:  MOVFF  02,750
03108:  MOVFF  01,74F
0310C:  MOVFF  00,74E
03110:  CALL   0E9E
03114:  MOVFF  03,72D
03118:  MOVFF  02,72C
0311C:  MOVFF  01,72B
03120:  MOVFF  00,72A
.................... 
....................    r = pe[0]*y + pe[1];
03124:  MOVLW  7C
03126:  MOVLB  7
03128:  MOVWF  x53
0312A:  MOVLW  88
0312C:  MOVWF  x52
0312E:  MOVLW  59
03130:  MOVWF  x51
03132:  MOVLW  72
03134:  MOVWF  x50
03136:  MOVFF  72D,757
0313A:  MOVFF  72C,756
0313E:  MOVFF  72B,755
03142:  MOVFF  72A,754
03146:  MOVLB  0
03148:  CALL   0DA8
0314C:  MOVFF  03,73B
03150:  MOVFF  02,73A
03154:  MOVFF  01,739
03158:  MOVFF  00,738
0315C:  BCF    FD8.1
0315E:  MOVFF  03,74D
03162:  MOVFF  02,74C
03166:  MOVFF  01,74B
0316A:  MOVFF  00,74A
0316E:  MOVLW  E0
03170:  MOVLB  7
03172:  MOVWF  x51
03174:  MOVLW  97
03176:  MOVWF  x50
03178:  MOVLW  26
0317A:  MOVWF  x4F
0317C:  MOVLW  75
0317E:  MOVWF  x4E
03180:  MOVLB  0
03182:  CALL   0E9E
03186:  MOVFF  03,735
0318A:  MOVFF  02,734
0318E:  MOVFF  01,733
03192:  MOVFF  00,732
....................    r = r*y + pe[2];
03196:  MOVFF  735,753
0319A:  MOVFF  734,752
0319E:  MOVFF  733,751
031A2:  MOVFF  732,750
031A6:  MOVFF  72D,757
031AA:  MOVFF  72C,756
031AE:  MOVFF  72B,755
031B2:  MOVFF  72A,754
031B6:  CALL   0DA8
031BA:  MOVFF  03,73B
031BE:  MOVFF  02,73A
031C2:  MOVFF  01,739
031C6:  MOVFF  00,738
031CA:  BCF    FD8.1
031CC:  MOVFF  03,74D
031D0:  MOVFF  02,74C
031D4:  MOVFF  01,74B
031D8:  MOVFF  00,74A
031DC:  MOVLW  C4
031DE:  MOVLB  7
031E0:  MOVWF  x51
031E2:  MOVLW  1D
031E4:  MOVWF  x50
031E6:  MOVLW  1E
031E8:  MOVWF  x4F
031EA:  MOVLW  78
031EC:  MOVWF  x4E
031EE:  MOVLB  0
031F0:  CALL   0E9E
031F4:  MOVFF  03,735
031F8:  MOVFF  02,734
031FC:  MOVFF  01,733
03200:  MOVFF  00,732
....................    r = r*y + pe[3];
03204:  MOVFF  735,753
03208:  MOVFF  734,752
0320C:  MOVFF  733,751
03210:  MOVFF  732,750
03214:  MOVFF  72D,757
03218:  MOVFF  72C,756
0321C:  MOVFF  72B,755
03220:  MOVFF  72A,754
03224:  CALL   0DA8
03228:  MOVFF  03,73B
0322C:  MOVFF  02,73A
03230:  MOVFF  01,739
03234:  MOVFF  00,738
03238:  BCF    FD8.1
0323A:  MOVFF  03,74D
0323E:  MOVFF  02,74C
03242:  MOVFF  01,74B
03246:  MOVFF  00,74A
0324A:  MOVLW  5E
0324C:  MOVLB  7
0324E:  MOVWF  x51
03250:  MOVLW  50
03252:  MOVWF  x50
03254:  MOVLW  63
03256:  MOVWF  x4F
03258:  MOVLW  7A
0325A:  MOVWF  x4E
0325C:  MOVLB  0
0325E:  CALL   0E9E
03262:  MOVFF  03,735
03266:  MOVFF  02,734
0326A:  MOVFF  01,733
0326E:  MOVFF  00,732
....................    r = r*y + pe[4];
03272:  MOVFF  735,753
03276:  MOVFF  734,752
0327A:  MOVFF  733,751
0327E:  MOVFF  732,750
03282:  MOVFF  72D,757
03286:  MOVFF  72C,756
0328A:  MOVFF  72B,755
0328E:  MOVFF  72A,754
03292:  CALL   0DA8
03296:  MOVFF  03,73B
0329A:  MOVFF  02,73A
0329E:  MOVFF  01,739
032A2:  MOVFF  00,738
032A6:  BCF    FD8.1
032A8:  MOVFF  03,74D
032AC:  MOVFF  02,74C
032B0:  MOVFF  01,74B
032B4:  MOVFF  00,74A
032B8:  MOVLW  1A
032BA:  MOVLB  7
032BC:  MOVWF  x51
032BE:  MOVLW  FE
032C0:  MOVWF  x50
032C2:  MOVLW  75
032C4:  MOVWF  x4F
032C6:  MOVLW  7C
032C8:  MOVWF  x4E
032CA:  MOVLB  0
032CC:  CALL   0E9E
032D0:  MOVFF  03,735
032D4:  MOVFF  02,734
032D8:  MOVFF  01,733
032DC:  MOVFF  00,732
....................    r = r*y + pe[5];
032E0:  MOVFF  735,753
032E4:  MOVFF  734,752
032E8:  MOVFF  733,751
032EC:  MOVFF  732,750
032F0:  MOVFF  72D,757
032F4:  MOVFF  72C,756
032F8:  MOVFF  72B,755
032FC:  MOVFF  72A,754
03300:  CALL   0DA8
03304:  MOVFF  03,73B
03308:  MOVFF  02,73A
0330C:  MOVFF  01,739
03310:  MOVFF  00,738
03314:  BCF    FD8.1
03316:  MOVFF  03,74D
0331A:  MOVFF  02,74C
0331E:  MOVFF  01,74B
03322:  MOVFF  00,74A
03326:  MOVLW  18
03328:  MOVLB  7
0332A:  MOVWF  x51
0332C:  MOVLW  72
0332E:  MOVWF  x50
03330:  MOVLW  31
03332:  MOVWF  x4F
03334:  MOVLW  7E
03336:  MOVWF  x4E
03338:  MOVLB  0
0333A:  CALL   0E9E
0333E:  MOVFF  03,735
03342:  MOVFF  02,734
03346:  MOVFF  01,733
0334A:  MOVFF  00,732
.................... 
....................    res = res*(1.0 + y*r);
0334E:  MOVFF  72D,753
03352:  MOVFF  72C,752
03356:  MOVFF  72B,751
0335A:  MOVFF  72A,750
0335E:  MOVFF  735,757
03362:  MOVFF  734,756
03366:  MOVFF  733,755
0336A:  MOVFF  732,754
0336E:  CALL   0DA8
03372:  BCF    FD8.1
03374:  MOVLB  7
03376:  CLRF   x4D
03378:  CLRF   x4C
0337A:  CLRF   x4B
0337C:  MOVLW  7F
0337E:  MOVWF  x4A
03380:  MOVFF  03,751
03384:  MOVFF  02,750
03388:  MOVFF  01,74F
0338C:  MOVFF  00,74E
03390:  MOVLB  0
03392:  CALL   0E9E
03396:  MOVFF  731,753
0339A:  MOVFF  730,752
0339E:  MOVFF  72F,751
033A2:  MOVFF  72E,750
033A6:  MOVFF  03,757
033AA:  MOVFF  02,756
033AE:  MOVFF  01,755
033B2:  MOVFF  00,754
033B6:  CALL   0DA8
033BA:  MOVFF  03,731
033BE:  MOVFF  02,730
033C2:  MOVFF  01,72F
033C6:  MOVFF  00,72E
.................... 
....................    if (s)
033CA:  MOVLB  7
033CC:  BTFSS  x37.0
033CE:  BRA    3402
....................       res = 1.0/res;
033D0:  CLRF   x42
033D2:  CLRF   x41
033D4:  CLRF   x40
033D6:  MOVLW  7F
033D8:  MOVWF  x3F
033DA:  MOVFF  731,746
033DE:  MOVFF  730,745
033E2:  MOVFF  72F,744
033E6:  MOVFF  72E,743
033EA:  MOVLB  0
033EC:  CALL   1DAE
033F0:  MOVFF  03,731
033F4:  MOVFF  02,730
033F8:  MOVFF  01,72F
033FC:  MOVFF  00,72E
03400:  MOVLB  7
....................    return(res);
03402:  MOVFF  72E,00
03406:  MOVFF  72F,01
0340A:  MOVFF  730,02
0340E:  MOVFF  731,03
03412:  MOVLB  0
03414:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C74:  MOVFF  729,72D
02C78:  MOVFF  728,72C
02C7C:  MOVFF  727,72B
02C80:  MOVFF  726,72A
.................... 
....................    if (y != 1.0)
02C84:  MOVFF  72D,749
02C88:  MOVFF  72C,748
02C8C:  MOVFF  72B,747
02C90:  MOVFF  72A,746
02C94:  MOVLB  7
02C96:  CLRF   x4D
02C98:  CLRF   x4C
02C9A:  CLRF   x4B
02C9C:  MOVLW  7F
02C9E:  MOVWF  x4A
02CA0:  MOVLB  0
02CA2:  CALL   1D34
02CA6:  BTFSC  FD8.2
02CA8:  BRA    2FEA
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02CAA:  MOVLW  07
02CAC:  MOVLB  7
02CAE:  MOVWF  x3C
02CB0:  MOVLW  2A
02CB2:  MOVFF  73C,FEA
02CB6:  MOVWF  FE9
02CB8:  MOVLW  7E
02CBA:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02CBC:  BSF    FD8.1
02CBE:  MOVFF  72D,74D
02CC2:  MOVFF  72C,74C
02CC6:  MOVFF  72B,74B
02CCA:  MOVFF  72A,74A
02CCE:  CLRF   x51
02CD0:  CLRF   x50
02CD2:  CLRF   x4F
02CD4:  MOVLW  7F
02CD6:  MOVWF  x4E
02CD8:  MOVLB  0
02CDA:  CALL   0E9E
02CDE:  MOVFF  03,73E
02CE2:  MOVFF  02,73D
02CE6:  MOVFF  01,73C
02CEA:  MOVFF  00,73B
02CEE:  BCF    FD8.1
02CF0:  MOVFF  72D,74D
02CF4:  MOVFF  72C,74C
02CF8:  MOVFF  72B,74B
02CFC:  MOVFF  72A,74A
02D00:  MOVLB  7
02D02:  CLRF   x51
02D04:  CLRF   x50
02D06:  CLRF   x4F
02D08:  MOVLW  7F
02D0A:  MOVWF  x4E
02D0C:  MOVLB  0
02D0E:  CALL   0E9E
02D12:  MOVFF  73E,742
02D16:  MOVFF  73D,741
02D1A:  MOVFF  73C,740
02D1E:  MOVFF  73B,73F
02D22:  MOVFF  03,746
02D26:  MOVFF  02,745
02D2A:  MOVFF  01,744
02D2E:  MOVFF  00,743
02D32:  CALL   1DAE
02D36:  MOVFF  03,72D
02D3A:  MOVFF  02,72C
02D3E:  MOVFF  01,72B
02D42:  MOVFF  00,72A
.................... 
....................       y2=y*y;
02D46:  MOVFF  72D,753
02D4A:  MOVFF  72C,752
02D4E:  MOVFF  72B,751
02D52:  MOVFF  72A,750
02D56:  MOVFF  72D,757
02D5A:  MOVFF  72C,756
02D5E:  MOVFF  72B,755
02D62:  MOVFF  72A,754
02D66:  CALL   0DA8
02D6A:  MOVFF  03,739
02D6E:  MOVFF  02,738
02D72:  MOVFF  01,737
02D76:  MOVFF  00,736
.................... 
....................       res = pl[0]*y2 + pl[1];
02D7A:  MOVLW  99
02D7C:  MOVLB  7
02D7E:  MOVWF  x53
02D80:  MOVLW  47
02D82:  MOVWF  x52
02D84:  MOVLW  8A
02D86:  MOVWF  x51
02D88:  MOVLW  7F
02D8A:  MOVWF  x50
02D8C:  MOVFF  739,757
02D90:  MOVFF  738,756
02D94:  MOVFF  737,755
02D98:  MOVFF  736,754
02D9C:  MOVLB  0
02D9E:  CALL   0DA8
02DA2:  MOVFF  03,73E
02DA6:  MOVFF  02,73D
02DAA:  MOVFF  01,73C
02DAE:  MOVFF  00,73B
02DB2:  BCF    FD8.1
02DB4:  MOVFF  03,74D
02DB8:  MOVFF  02,74C
02DBC:  MOVFF  01,74B
02DC0:  MOVFF  00,74A
02DC4:  MOVLB  7
02DC6:  CLRF   x51
02DC8:  CLRF   x50
02DCA:  CLRF   x4F
02DCC:  MOVLW  80
02DCE:  MOVWF  x4E
02DD0:  MOVLB  0
02DD2:  CALL   0E9E
02DD6:  MOVFF  03,731
02DDA:  MOVFF  02,730
02DDE:  MOVFF  01,72F
02DE2:  MOVFF  00,72E
.................... 
....................       r = ql[0]*y2 + ql[1];
02DE6:  MOVLW  4C
02DE8:  MOVLB  7
02DEA:  MOVWF  x53
02DEC:  MOVLW  F3
02DEE:  MOVWF  x52
02DF0:  MOVLW  3A
02DF2:  MOVWF  x51
02DF4:  MOVLW  7B
02DF6:  MOVWF  x50
02DF8:  MOVFF  739,757
02DFC:  MOVFF  738,756
02E00:  MOVFF  737,755
02E04:  MOVFF  736,754
02E08:  MOVLB  0
02E0A:  CALL   0DA8
02E0E:  MOVFF  03,73E
02E12:  MOVFF  02,73D
02E16:  MOVFF  01,73C
02E1A:  MOVFF  00,73B
02E1E:  BCF    FD8.1
02E20:  MOVFF  03,74D
02E24:  MOVFF  02,74C
02E28:  MOVFF  01,74B
02E2C:  MOVFF  00,74A
02E30:  MOVLW  2B
02E32:  MOVLB  7
02E34:  MOVWF  x51
02E36:  MOVLW  9D
02E38:  MOVWF  x50
02E3A:  MOVLW  DF
02E3C:  MOVWF  x4F
02E3E:  MOVLW  7E
02E40:  MOVWF  x4E
02E42:  MOVLB  0
02E44:  CALL   0E9E
02E48:  MOVFF  03,735
02E4C:  MOVFF  02,734
02E50:  MOVFF  01,733
02E54:  MOVFF  00,732
....................       r = r*y2 + 1.0;
02E58:  MOVFF  735,753
02E5C:  MOVFF  734,752
02E60:  MOVFF  733,751
02E64:  MOVFF  732,750
02E68:  MOVFF  739,757
02E6C:  MOVFF  738,756
02E70:  MOVFF  737,755
02E74:  MOVFF  736,754
02E78:  CALL   0DA8
02E7C:  MOVFF  03,73E
02E80:  MOVFF  02,73D
02E84:  MOVFF  01,73C
02E88:  MOVFF  00,73B
02E8C:  BCF    FD8.1
02E8E:  MOVFF  03,74D
02E92:  MOVFF  02,74C
02E96:  MOVFF  01,74B
02E9A:  MOVFF  00,74A
02E9E:  MOVLB  7
02EA0:  CLRF   x51
02EA2:  CLRF   x50
02EA4:  CLRF   x4F
02EA6:  MOVLW  7F
02EA8:  MOVWF  x4E
02EAA:  MOVLB  0
02EAC:  CALL   0E9E
02EB0:  MOVFF  03,735
02EB4:  MOVFF  02,734
02EB8:  MOVFF  01,733
02EBC:  MOVFF  00,732
.................... 
....................       res = y*res/r;
02EC0:  MOVFF  72D,753
02EC4:  MOVFF  72C,752
02EC8:  MOVFF  72B,751
02ECC:  MOVFF  72A,750
02ED0:  MOVFF  731,757
02ED4:  MOVFF  730,756
02ED8:  MOVFF  72F,755
02EDC:  MOVFF  72E,754
02EE0:  CALL   0DA8
02EE4:  MOVFF  03,73E
02EE8:  MOVFF  02,73D
02EEC:  MOVFF  01,73C
02EF0:  MOVFF  00,73B
02EF4:  MOVFF  03,742
02EF8:  MOVFF  02,741
02EFC:  MOVFF  01,740
02F00:  MOVFF  00,73F
02F04:  MOVFF  735,746
02F08:  MOVFF  734,745
02F0C:  MOVFF  733,744
02F10:  MOVFF  732,743
02F14:  CALL   1DAE
02F18:  MOVFF  03,731
02F1C:  MOVFF  02,730
02F20:  MOVFF  01,72F
02F24:  MOVFF  00,72E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02F28:  MOVLW  07
02F2A:  MOVLB  7
02F2C:  MOVWF  x3C
02F2E:  MOVLW  26
02F30:  MOVFF  73C,FEA
02F34:  MOVWF  FE9
02F36:  MOVLW  7E
02F38:  SUBWF  FEF,W
02F3A:  MOVWF  x3A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02F3C:  BTFSS  x3A.7
02F3E:  BRA    2F6A
....................          r = -(float32)-n;
02F40:  MOVLW  00
02F42:  BSF    FD8.0
02F44:  SUBFWB x3A,W
02F46:  CLRF   x3D
02F48:  MOVWF  x3C
02F4A:  BTFSC  x3C.7
02F4C:  DECF   x3D,F
02F4E:  MOVLB  0
02F50:  CALL   26D8
02F54:  MOVFF  00,732
02F58:  MOVF   01,W
02F5A:  XORLW  80
02F5C:  MOVLB  7
02F5E:  MOVWF  x33
02F60:  MOVFF  02,734
02F64:  MOVFF  03,735
02F68:  BRA    2F8C
....................       else
....................          r = (float32)n;
02F6A:  CLRF   x3D
02F6C:  MOVFF  73A,73C
02F70:  BTFSC  x3C.7
02F72:  DECF   x3D,F
02F74:  MOVLB  0
02F76:  CALL   26D8
02F7A:  MOVFF  03,735
02F7E:  MOVFF  02,734
02F82:  MOVFF  01,733
02F86:  MOVFF  00,732
02F8A:  MOVLB  7
.................... 
....................       res += r*LN2;
02F8C:  MOVFF  735,753
02F90:  MOVFF  734,752
02F94:  MOVFF  733,751
02F98:  MOVFF  732,750
02F9C:  MOVLW  18
02F9E:  MOVWF  x57
02FA0:  MOVLW  72
02FA2:  MOVWF  x56
02FA4:  MOVLW  31
02FA6:  MOVWF  x55
02FA8:  MOVLW  7E
02FAA:  MOVWF  x54
02FAC:  MOVLB  0
02FAE:  CALL   0DA8
02FB2:  BCF    FD8.1
02FB4:  MOVFF  731,74D
02FB8:  MOVFF  730,74C
02FBC:  MOVFF  72F,74B
02FC0:  MOVFF  72E,74A
02FC4:  MOVFF  03,751
02FC8:  MOVFF  02,750
02FCC:  MOVFF  01,74F
02FD0:  MOVFF  00,74E
02FD4:  CALL   0E9E
02FD8:  MOVFF  03,731
02FDC:  MOVFF  02,730
02FE0:  MOVFF  01,72F
02FE4:  MOVFF  00,72E
....................    }
02FE8:  BRA    2FF6
.................... 
....................    else
....................       res = 0.0;
02FEA:  MOVLB  7
02FEC:  CLRF   x31
02FEE:  CLRF   x30
02FF0:  CLRF   x2F
02FF2:  CLRF   x2E
02FF4:  MOVLB  0
.................... 
....................    return(res);
02FF6:  MOVFF  72E,00
02FFA:  MOVFF  72F,01
02FFE:  MOVFF  730,02
03002:  MOVFF  731,03
03006:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03416:  MOVFF  71D,749
0341A:  MOVFF  71C,748
0341E:  MOVFF  71B,747
03422:  MOVFF  71A,746
03426:  MOVLB  7
03428:  CLRF   x4D
0342A:  CLRF   x4C
0342C:  CLRF   x4B
0342E:  CLRF   x4A
03430:  MOVLB  0
03432:  CALL   1D34
03436:  BTFSS  FD8.0
03438:  BRA    35D4
0343A:  MOVFF  721,725
0343E:  MOVFF  720,724
03442:  MOVFF  71F,723
03446:  MOVFF  71E,722
0344A:  MOVLB  7
0344C:  CLRF   x29
0344E:  CLRF   x28
03450:  CLRF   x27
03452:  MOVLW  7F
03454:  MOVWF  x26
03456:  MOVLB  0
03458:  CALL   2B0E
0345C:  MOVFF  03,725
03460:  MOVFF  02,724
03464:  MOVFF  01,723
03468:  MOVFF  00,722
0346C:  MOVFF  03,749
03470:  MOVFF  02,748
03474:  MOVFF  01,747
03478:  MOVFF  00,746
0347C:  MOVLB  7
0347E:  CLRF   x4D
03480:  CLRF   x4C
03482:  CLRF   x4B
03484:  CLRF   x4A
03486:  MOVLB  0
03488:  CALL   1D34
0348C:  BTFSS  FD8.2
0348E:  BRA    35D4
....................       if(fmod(y, 2) == 0) {
03490:  MOVFF  721,725
03494:  MOVFF  720,724
03498:  MOVFF  71F,723
0349C:  MOVFF  71E,722
034A0:  MOVLB  7
034A2:  CLRF   x29
034A4:  CLRF   x28
034A6:  CLRF   x27
034A8:  MOVLW  80
034AA:  MOVWF  x26
034AC:  MOVLB  0
034AE:  CALL   2B0E
034B2:  MOVFF  03,725
034B6:  MOVFF  02,724
034BA:  MOVFF  01,723
034BE:  MOVFF  00,722
034C2:  MOVFF  03,749
034C6:  MOVFF  02,748
034CA:  MOVFF  01,747
034CE:  MOVFF  00,746
034D2:  MOVLB  7
034D4:  CLRF   x4D
034D6:  CLRF   x4C
034D8:  CLRF   x4B
034DA:  CLRF   x4A
034DC:  MOVLB  0
034DE:  CALL   1D34
034E2:  BNZ   355A
....................          return (exp(log(-x) * y));
034E4:  MOVLB  7
034E6:  MOVF   x1B,W
034E8:  XORLW  80
034EA:  MOVWF  x23
034EC:  MOVFF  71D,729
034F0:  MOVFF  71C,728
034F4:  MOVWF  x27
034F6:  MOVFF  71A,726
034FA:  MOVLB  0
034FC:  CALL   2C74
03500:  MOVFF  03,725
03504:  MOVFF  02,724
03508:  MOVFF  01,723
0350C:  MOVFF  00,722
03510:  MOVFF  03,753
03514:  MOVFF  02,752
03518:  MOVFF  01,751
0351C:  MOVFF  00,750
03520:  MOVFF  721,757
03524:  MOVFF  720,756
03528:  MOVFF  71F,755
0352C:  MOVFF  71E,754
03530:  CALL   0DA8
03534:  MOVFF  03,725
03538:  MOVFF  02,724
0353C:  MOVFF  01,723
03540:  MOVFF  00,722
03544:  MOVFF  03,729
03548:  MOVFF  02,728
0354C:  MOVFF  01,727
03550:  MOVFF  00,726
03554:  RCALL  3008
03556:  BRA    3712
....................       } else {
03558:  BRA    35D2
....................          return (-exp(log(-x) * y));
0355A:  MOVLB  7
0355C:  MOVF   x1B,W
0355E:  XORLW  80
03560:  MOVWF  x23
03562:  MOVFF  71D,729
03566:  MOVFF  71C,728
0356A:  MOVWF  x27
0356C:  MOVFF  71A,726
03570:  MOVLB  0
03572:  CALL   2C74
03576:  MOVFF  03,725
0357A:  MOVFF  02,724
0357E:  MOVFF  01,723
03582:  MOVFF  00,722
03586:  MOVFF  03,753
0358A:  MOVFF  02,752
0358E:  MOVFF  01,751
03592:  MOVFF  00,750
03596:  MOVFF  721,757
0359A:  MOVFF  720,756
0359E:  MOVFF  71F,755
035A2:  MOVFF  71E,754
035A6:  CALL   0DA8
035AA:  MOVFF  03,725
035AE:  MOVFF  02,724
035B2:  MOVFF  01,723
035B6:  MOVFF  00,722
035BA:  MOVFF  03,729
035BE:  MOVFF  02,728
035C2:  MOVFF  01,727
035C6:  MOVFF  00,726
035CA:  RCALL  3008
035CC:  MOVLW  80
035CE:  XORWF  01,F
035D0:  BRA    3712
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
035D2:  BRA    3712
035D4:  MOVFF  71D,749
035D8:  MOVFF  71C,748
035DC:  MOVFF  71B,747
035E0:  MOVFF  71A,746
035E4:  MOVLB  7
035E6:  CLRF   x4D
035E8:  CLRF   x4C
035EA:  CLRF   x4B
035EC:  CLRF   x4A
035EE:  MOVLB  0
035F0:  CALL   1D34
035F4:  BNC   3656
035F6:  MOVFF  721,725
035FA:  MOVFF  720,724
035FE:  MOVFF  71F,723
03602:  MOVFF  71E,722
03606:  MOVLB  7
03608:  CLRF   x29
0360A:  CLRF   x28
0360C:  CLRF   x27
0360E:  MOVLW  7F
03610:  MOVWF  x26
03612:  MOVLB  0
03614:  CALL   2B0E
03618:  MOVFF  03,725
0361C:  MOVFF  02,724
03620:  MOVFF  01,723
03624:  MOVFF  00,722
03628:  MOVFF  03,749
0362C:  MOVFF  02,748
03630:  MOVFF  01,747
03634:  MOVFF  00,746
03638:  MOVLB  7
0363A:  CLRF   x4D
0363C:  CLRF   x4C
0363E:  CLRF   x4B
03640:  CLRF   x4A
03642:  MOVLB  0
03644:  CALL   1D34
03648:  BZ    3656
....................       return 0;
0364A:  CLRF   00
0364C:  CLRF   01
0364E:  CLRF   02
03650:  CLRF   03
03652:  BRA    3712
....................    } else {
03654:  BRA    3712
....................       if(x != 0 || 0 >= y) {
03656:  MOVFF  71D,749
0365A:  MOVFF  71C,748
0365E:  MOVFF  71B,747
03662:  MOVFF  71A,746
03666:  MOVLB  7
03668:  CLRF   x4D
0366A:  CLRF   x4C
0366C:  CLRF   x4B
0366E:  CLRF   x4A
03670:  MOVLB  0
03672:  CALL   1D34
03676:  BNZ   369C
03678:  MOVFF  721,749
0367C:  MOVFF  720,748
03680:  MOVFF  71F,747
03684:  MOVFF  71E,746
03688:  MOVLB  7
0368A:  CLRF   x4D
0368C:  CLRF   x4C
0368E:  CLRF   x4B
03690:  CLRF   x4A
03692:  MOVLB  0
03694:  CALL   1D34
03698:  BC    369C
0369A:  BNZ   370A
....................          return (exp(log(x) * y));
0369C:  MOVFF  71D,729
036A0:  MOVFF  71C,728
036A4:  MOVFF  71B,727
036A8:  MOVFF  71A,726
036AC:  CALL   2C74
036B0:  MOVFF  03,725
036B4:  MOVFF  02,724
036B8:  MOVFF  01,723
036BC:  MOVFF  00,722
036C0:  MOVFF  03,753
036C4:  MOVFF  02,752
036C8:  MOVFF  01,751
036CC:  MOVFF  00,750
036D0:  MOVFF  721,757
036D4:  MOVFF  720,756
036D8:  MOVFF  71F,755
036DC:  MOVFF  71E,754
036E0:  CALL   0DA8
036E4:  MOVFF  03,725
036E8:  MOVFF  02,724
036EC:  MOVFF  01,723
036F0:  MOVFF  00,722
036F4:  MOVFF  03,729
036F8:  MOVFF  02,728
036FC:  MOVFF  01,727
03700:  MOVFF  00,726
03704:  RCALL  3008
03706:  BRA    3712
....................       } else return 0;
03708:  BRA    3712
0370A:  CLRF   00
0370C:  CLRF   01
0370E:  CLRF   02
03710:  CLRF   03
....................    }
03712:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01F0C:  MOVLB  7
01F0E:  BCF    x38.0
....................    flag = 0;
01F10:  BCF    x38.1
....................    y = x;
01F12:  MOVFF  72B,72F
01F16:  MOVFF  72A,72E
01F1A:  MOVFF  729,72D
01F1E:  MOVFF  728,72C
.................... 
....................    if (x < 0)
01F22:  MOVFF  72B,749
01F26:  MOVFF  72A,748
01F2A:  MOVFF  729,747
01F2E:  MOVFF  728,746
01F32:  CLRF   x4D
01F34:  CLRF   x4C
01F36:  CLRF   x4B
01F38:  CLRF   x4A
01F3A:  MOVLB  0
01F3C:  RCALL  1D34
01F3E:  BNC   1F4C
....................    {
....................       s = 1;
01F40:  MOVLB  7
01F42:  BSF    x38.0
....................       y = -y;
01F44:  MOVF   x2D,W
01F46:  XORLW  80
01F48:  MOVWF  x2D
01F4A:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F4C:  MOVLB  7
01F4E:  CLRF   x49
01F50:  CLRF   x48
01F52:  CLRF   x47
01F54:  MOVLW  7F
01F56:  MOVWF  x46
01F58:  MOVFF  72F,74D
01F5C:  MOVFF  72E,74C
01F60:  MOVFF  72D,74B
01F64:  MOVFF  72C,74A
01F68:  MOVLB  0
01F6A:  RCALL  1D34
01F6C:  BNC   1FA4
....................    {
....................       y = 1.0/y;
01F6E:  MOVLB  7
01F70:  CLRF   x42
01F72:  CLRF   x41
01F74:  CLRF   x40
01F76:  MOVLW  7F
01F78:  MOVWF  x3F
01F7A:  MOVFF  72F,746
01F7E:  MOVFF  72E,745
01F82:  MOVFF  72D,744
01F86:  MOVFF  72C,743
01F8A:  MOVLB  0
01F8C:  RCALL  1DAE
01F8E:  MOVFF  03,72F
01F92:  MOVFF  02,72E
01F96:  MOVFF  01,72D
01F9A:  MOVFF  00,72C
....................       flag = 1;
01F9E:  MOVLB  7
01FA0:  BSF    x38.1
01FA2:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01FA4:  MOVLW  0A
01FA6:  MOVLB  7
01FA8:  MOVWF  x53
01FAA:  MOVLW  89
01FAC:  MOVWF  x52
01FAE:  MOVLW  34
01FB0:  MOVWF  x51
01FB2:  MOVLW  7C
01FB4:  MOVWF  x50
01FB6:  MOVFF  72F,757
01FBA:  MOVFF  72E,756
01FBE:  MOVFF  72D,755
01FC2:  MOVFF  72C,754
01FC6:  MOVLB  0
01FC8:  CALL   0DA8
01FCC:  MOVFF  03,73C
01FD0:  MOVFF  02,73B
01FD4:  MOVFF  01,73A
01FD8:  MOVFF  00,739
01FDC:  MOVFF  03,753
01FE0:  MOVFF  02,752
01FE4:  MOVFF  01,751
01FE8:  MOVFF  00,750
01FEC:  MOVFF  72F,757
01FF0:  MOVFF  72E,756
01FF4:  MOVFF  72D,755
01FF8:  MOVFF  72C,754
01FFC:  CALL   0DA8
02000:  MOVFF  03,73C
02004:  MOVFF  02,73B
02008:  MOVFF  01,73A
0200C:  MOVFF  00,739
02010:  BCF    FD8.1
02012:  MOVFF  03,74D
02016:  MOVFF  02,74C
0201A:  MOVFF  01,74B
0201E:  MOVFF  00,74A
02022:  MOVLW  7C
02024:  MOVLB  7
02026:  MOVWF  x51
02028:  MOVLW  79
0202A:  MOVWF  x50
0202C:  MOVLW  35
0202E:  MOVWF  x4F
02030:  MOVLW  81
02032:  MOVWF  x4E
02034:  MOVLB  0
02036:  CALL   0E9E
0203A:  MOVFF  03,733
0203E:  MOVFF  02,732
02042:  MOVFF  01,731
02046:  MOVFF  00,730
....................    res = res*y*y + pat[2];
0204A:  MOVFF  733,753
0204E:  MOVFF  732,752
02052:  MOVFF  731,751
02056:  MOVFF  730,750
0205A:  MOVFF  72F,757
0205E:  MOVFF  72E,756
02062:  MOVFF  72D,755
02066:  MOVFF  72C,754
0206A:  CALL   0DA8
0206E:  MOVFF  03,73C
02072:  MOVFF  02,73B
02076:  MOVFF  01,73A
0207A:  MOVFF  00,739
0207E:  MOVFF  03,753
02082:  MOVFF  02,752
02086:  MOVFF  01,751
0208A:  MOVFF  00,750
0208E:  MOVFF  72F,757
02092:  MOVFF  72E,756
02096:  MOVFF  72D,755
0209A:  MOVFF  72C,754
0209E:  CALL   0DA8
020A2:  MOVFF  03,73C
020A6:  MOVFF  02,73B
020AA:  MOVFF  01,73A
020AE:  MOVFF  00,739
020B2:  BCF    FD8.1
020B4:  MOVFF  03,74D
020B8:  MOVFF  02,74C
020BC:  MOVFF  01,74B
020C0:  MOVFF  00,74A
020C4:  MOVLW  3F
020C6:  MOVLB  7
020C8:  MOVWF  x51
020CA:  MOVLW  02
020CC:  MOVWF  x50
020CE:  MOVLW  33
020D0:  MOVWF  x4F
020D2:  MOVLW  83
020D4:  MOVWF  x4E
020D6:  MOVLB  0
020D8:  CALL   0E9E
020DC:  MOVFF  03,733
020E0:  MOVFF  02,732
020E4:  MOVFF  01,731
020E8:  MOVFF  00,730
....................    res = res*y*y + pat[3];
020EC:  MOVFF  733,753
020F0:  MOVFF  732,752
020F4:  MOVFF  731,751
020F8:  MOVFF  730,750
020FC:  MOVFF  72F,757
02100:  MOVFF  72E,756
02104:  MOVFF  72D,755
02108:  MOVFF  72C,754
0210C:  CALL   0DA8
02110:  MOVFF  03,73C
02114:  MOVFF  02,73B
02118:  MOVFF  01,73A
0211C:  MOVFF  00,739
02120:  MOVFF  03,753
02124:  MOVFF  02,752
02128:  MOVFF  01,751
0212C:  MOVFF  00,750
02130:  MOVFF  72F,757
02134:  MOVFF  72E,756
02138:  MOVFF  72D,755
0213C:  MOVFF  72C,754
02140:  CALL   0DA8
02144:  MOVFF  03,73C
02148:  MOVFF  02,73B
0214C:  MOVFF  01,73A
02150:  MOVFF  00,739
02154:  BCF    FD8.1
02156:  MOVFF  03,74D
0215A:  MOVFF  02,74C
0215E:  MOVFF  01,74B
02162:  MOVFF  00,74A
02166:  MOVLW  33
02168:  MOVLB  7
0216A:  MOVWF  x51
0216C:  MOVLW  8C
0216E:  MOVWF  x50
02170:  MOVLW  1E
02172:  MOVWF  x4F
02174:  MOVLW  83
02176:  MOVWF  x4E
02178:  MOVLB  0
0217A:  CALL   0E9E
0217E:  MOVFF  03,733
02182:  MOVFF  02,732
02186:  MOVFF  01,731
0218A:  MOVFF  00,730
.................... 
....................    r = qat[0]*y*y + qat[1];
0218E:  MOVLB  7
02190:  CLRF   x53
02192:  CLRF   x52
02194:  CLRF   x51
02196:  MOVLW  7F
02198:  MOVWF  x50
0219A:  MOVFF  72F,757
0219E:  MOVFF  72E,756
021A2:  MOVFF  72D,755
021A6:  MOVFF  72C,754
021AA:  MOVLB  0
021AC:  CALL   0DA8
021B0:  MOVFF  03,73C
021B4:  MOVFF  02,73B
021B8:  MOVFF  01,73A
021BC:  MOVFF  00,739
021C0:  MOVFF  03,753
021C4:  MOVFF  02,752
021C8:  MOVFF  01,751
021CC:  MOVFF  00,750
021D0:  MOVFF  72F,757
021D4:  MOVFF  72E,756
021D8:  MOVFF  72D,755
021DC:  MOVFF  72C,754
021E0:  CALL   0DA8
021E4:  MOVFF  03,73C
021E8:  MOVFF  02,73B
021EC:  MOVFF  01,73A
021F0:  MOVFF  00,739
021F4:  BCF    FD8.1
021F6:  MOVFF  03,74D
021FA:  MOVFF  02,74C
021FE:  MOVFF  01,74B
02202:  MOVFF  00,74A
02206:  MOVLW  1B
02208:  MOVLB  7
0220A:  MOVWF  x51
0220C:  MOVLW  E4
0220E:  MOVWF  x50
02210:  MOVLW  35
02212:  MOVWF  x4F
02214:  MOVLW  82
02216:  MOVWF  x4E
02218:  MOVLB  0
0221A:  CALL   0E9E
0221E:  MOVFF  03,737
02222:  MOVFF  02,736
02226:  MOVFF  01,735
0222A:  MOVFF  00,734
....................    r = r*y*y + qat[2];
0222E:  MOVFF  737,753
02232:  MOVFF  736,752
02236:  MOVFF  735,751
0223A:  MOVFF  734,750
0223E:  MOVFF  72F,757
02242:  MOVFF  72E,756
02246:  MOVFF  72D,755
0224A:  MOVFF  72C,754
0224E:  CALL   0DA8
02252:  MOVFF  03,73C
02256:  MOVFF  02,73B
0225A:  MOVFF  01,73A
0225E:  MOVFF  00,739
02262:  MOVFF  03,753
02266:  MOVFF  02,752
0226A:  MOVFF  01,751
0226E:  MOVFF  00,750
02272:  MOVFF  72F,757
02276:  MOVFF  72E,756
0227A:  MOVFF  72D,755
0227E:  MOVFF  72C,754
02282:  CALL   0DA8
02286:  MOVFF  03,73C
0228A:  MOVFF  02,73B
0228E:  MOVFF  01,73A
02292:  MOVFF  00,739
02296:  BCF    FD8.1
02298:  MOVFF  03,74D
0229C:  MOVFF  02,74C
022A0:  MOVFF  01,74B
022A4:  MOVFF  00,74A
022A8:  MOVLW  A4
022AA:  MOVLB  7
022AC:  MOVWF  x51
022AE:  MOVLW  DB
022B0:  MOVWF  x50
022B2:  MOVLW  67
022B4:  MOVWF  x4F
022B6:  MOVLW  83
022B8:  MOVWF  x4E
022BA:  MOVLB  0
022BC:  CALL   0E9E
022C0:  MOVFF  03,737
022C4:  MOVFF  02,736
022C8:  MOVFF  01,735
022CC:  MOVFF  00,734
....................    r = r*y*y + qat[3];
022D0:  MOVFF  737,753
022D4:  MOVFF  736,752
022D8:  MOVFF  735,751
022DC:  MOVFF  734,750
022E0:  MOVFF  72F,757
022E4:  MOVFF  72E,756
022E8:  MOVFF  72D,755
022EC:  MOVFF  72C,754
022F0:  CALL   0DA8
022F4:  MOVFF  03,73C
022F8:  MOVFF  02,73B
022FC:  MOVFF  01,73A
02300:  MOVFF  00,739
02304:  MOVFF  03,753
02308:  MOVFF  02,752
0230C:  MOVFF  01,751
02310:  MOVFF  00,750
02314:  MOVFF  72F,757
02318:  MOVFF  72E,756
0231C:  MOVFF  72D,755
02320:  MOVFF  72C,754
02324:  CALL   0DA8
02328:  MOVFF  03,73C
0232C:  MOVFF  02,73B
02330:  MOVFF  01,73A
02334:  MOVFF  00,739
02338:  BCF    FD8.1
0233A:  MOVFF  03,74D
0233E:  MOVFF  02,74C
02342:  MOVFF  01,74B
02346:  MOVFF  00,74A
0234A:  MOVLW  33
0234C:  MOVLB  7
0234E:  MOVWF  x51
02350:  MOVLW  8C
02352:  MOVWF  x50
02354:  MOVLW  1E
02356:  MOVWF  x4F
02358:  MOVLW  83
0235A:  MOVWF  x4E
0235C:  MOVLB  0
0235E:  CALL   0E9E
02362:  MOVFF  03,737
02366:  MOVFF  02,736
0236A:  MOVFF  01,735
0236E:  MOVFF  00,734
.................... 
....................    res = y*res/r;
02372:  MOVFF  72F,753
02376:  MOVFF  72E,752
0237A:  MOVFF  72D,751
0237E:  MOVFF  72C,750
02382:  MOVFF  733,757
02386:  MOVFF  732,756
0238A:  MOVFF  731,755
0238E:  MOVFF  730,754
02392:  CALL   0DA8
02396:  MOVFF  03,73C
0239A:  MOVFF  02,73B
0239E:  MOVFF  01,73A
023A2:  MOVFF  00,739
023A6:  MOVFF  03,742
023AA:  MOVFF  02,741
023AE:  MOVFF  01,740
023B2:  MOVFF  00,73F
023B6:  MOVFF  737,746
023BA:  MOVFF  736,745
023BE:  MOVFF  735,744
023C2:  MOVFF  734,743
023C6:  RCALL  1DAE
023C8:  MOVFF  03,733
023CC:  MOVFF  02,732
023D0:  MOVFF  01,731
023D4:  MOVFF  00,730
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
023D8:  MOVLB  7
023DA:  BTFSS  x38.1
023DC:  BRA    2418
....................       res = PI_DIV_BY_TWO - res;
023DE:  BSF    FD8.1
023E0:  MOVLW  DB
023E2:  MOVWF  x4D
023E4:  MOVLW  0F
023E6:  MOVWF  x4C
023E8:  MOVLW  49
023EA:  MOVWF  x4B
023EC:  MOVLW  7F
023EE:  MOVWF  x4A
023F0:  MOVFF  733,751
023F4:  MOVFF  732,750
023F8:  MOVFF  731,74F
023FC:  MOVFF  730,74E
02400:  MOVLB  0
02402:  CALL   0E9E
02406:  MOVFF  03,733
0240A:  MOVFF  02,732
0240E:  MOVFF  01,731
02412:  MOVFF  00,730
02416:  MOVLB  7
....................    if (s)
02418:  BTFSS  x38.0
0241A:  BRA    2422
....................       res = -res;
0241C:  MOVF   x31,W
0241E:  XORLW  80
02420:  MOVWF  x31
.................... 
....................    return(res);
02422:  MOVFF  730,00
02426:  MOVFF  731,01
0242A:  MOVFF  732,02
0242E:  MOVFF  733,03
02432:  MOVLB  0
02434:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02436:  MOVLB  7
02438:  BCF    x26.0
....................    quad=0; //quadrant
0243A:  CLRF   x27
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
0243C:  MOVFF  71D,749
02440:  MOVFF  71C,748
02444:  MOVFF  71B,747
02448:  MOVFF  71A,746
0244C:  CLRF   x4D
0244E:  CLRF   x4C
02450:  CLRF   x4B
02452:  CLRF   x4A
02454:  MOVLB  0
02456:  RCALL  1D34
02458:  BC    245C
0245A:  BNZ   2486
0245C:  MOVFF  721,749
02460:  MOVFF  720,748
02464:  MOVFF  71F,747
02468:  MOVFF  71E,746
0246C:  MOVLB  7
0246E:  CLRF   x4D
02470:  CLRF   x4C
02472:  CLRF   x4B
02474:  CLRF   x4A
02476:  MOVLB  0
02478:  RCALL  1D34
0247A:  BC    247E
0247C:  BNZ   2482
0247E:  MOVLW  03
02480:  BRA    2484
02482:  MOVLW  04
02484:  BRA    24AC
02486:  MOVFF  721,749
0248A:  MOVFF  720,748
0248E:  MOVFF  71F,747
02492:  MOVFF  71E,746
02496:  MOVLB  7
02498:  CLRF   x4D
0249A:  CLRF   x4C
0249C:  CLRF   x4B
0249E:  CLRF   x4A
024A0:  MOVLB  0
024A2:  RCALL  1D34
024A4:  BNC   24AA
024A6:  MOVLW  02
024A8:  BRA    24AC
024AA:  MOVLW  01
024AC:  MOVLB  7
024AE:  MOVWF  x27
....................    if(y<0.0)
024B0:  MOVFF  71D,749
024B4:  MOVFF  71C,748
024B8:  MOVFF  71B,747
024BC:  MOVFF  71A,746
024C0:  CLRF   x4D
024C2:  CLRF   x4C
024C4:  CLRF   x4B
024C6:  CLRF   x4A
024C8:  MOVLB  0
024CA:  RCALL  1D34
024CC:  BNC   24DA
....................    {
....................       sign=1;
024CE:  MOVLB  7
024D0:  BSF    x26.0
....................       y=-y;
024D2:  MOVF   x1B,W
024D4:  XORLW  80
024D6:  MOVWF  x1B
024D8:  MOVLB  0
....................    }
....................    if(x<0.0)
024DA:  MOVFF  721,749
024DE:  MOVFF  720,748
024E2:  MOVFF  71F,747
024E6:  MOVFF  71E,746
024EA:  MOVLB  7
024EC:  CLRF   x4D
024EE:  CLRF   x4C
024F0:  CLRF   x4B
024F2:  CLRF   x4A
024F4:  MOVLB  0
024F6:  RCALL  1D34
024F8:  BNC   2504
....................    {
....................       x=-x;
024FA:  MOVLB  7
024FC:  MOVF   x1F,W
024FE:  XORLW  80
02500:  MOVWF  x1F
02502:  MOVLB  0
....................    }
....................    if (x==0.0)
02504:  MOVFF  721,749
02508:  MOVFF  720,748
0250C:  MOVFF  71F,747
02510:  MOVFF  71E,746
02514:  MOVLB  7
02516:  CLRF   x4D
02518:  CLRF   x4C
0251A:  CLRF   x4B
0251C:  CLRF   x4A
0251E:  MOVLB  0
02520:  RCALL  1D34
02522:  BNZ   2578
....................    {
....................       if(y==0.0)
02524:  MOVFF  71D,749
02528:  MOVFF  71C,748
0252C:  MOVFF  71B,747
02530:  MOVFF  71A,746
02534:  MOVLB  7
02536:  CLRF   x4D
02538:  CLRF   x4C
0253A:  CLRF   x4B
0253C:  CLRF   x4A
0253E:  MOVLB  0
02540:  CALL   1D34
02544:  BNZ   2548
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02546:  BRA    2576
....................       else
....................       {
....................          if(sign)
02548:  MOVLB  7
0254A:  BTFSS  x26.0
0254C:  BRA    2562
....................          {
....................          return (-(PI_DIV_BY_TWO));
0254E:  MOVLW  7F
02550:  MOVWF  00
02552:  MOVLW  C9
02554:  MOVWF  01
02556:  MOVLW  0F
02558:  MOVWF  02
0255A:  MOVLW  DB
0255C:  MOVWF  03
0255E:  BRA    26B0
....................          }
02560:  BRA    2574
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02562:  MOVLW  7F
02564:  MOVWF  00
02566:  MOVLW  49
02568:  MOVWF  01
0256A:  MOVLW  0F
0256C:  MOVWF  02
0256E:  MOVLW  DB
02570:  MOVWF  03
02572:  BRA    26B0
02574:  MOVLB  0
....................          }
....................       }
....................    }
02576:  BRA    26AE
....................    else
....................    {
....................       z=y/x;
02578:  MOVFF  71D,742
0257C:  MOVFF  71C,741
02580:  MOVFF  71B,740
02584:  MOVFF  71A,73F
02588:  MOVFF  721,746
0258C:  MOVFF  720,745
02590:  MOVFF  71F,744
02594:  MOVFF  71E,743
02598:  RCALL  1DAE
0259A:  MOVFF  03,725
0259E:  MOVFF  02,724
025A2:  MOVFF  01,723
025A6:  MOVFF  00,722
....................       switch(quad)
025AA:  MOVLW  01
025AC:  MOVLB  7
025AE:  SUBWF  x27,W
025B0:  ADDLW  FC
025B2:  BTFSC  FD8.0
025B4:  BRA    26B0
025B6:  ADDLW  04
025B8:  MOVLB  0
025BA:  GOTO   26B6
....................       {
....................          case 1:
....................          {
....................             return atan(z);
025BE:  MOVFF  725,72B
025C2:  MOVFF  724,72A
025C6:  MOVFF  723,729
025CA:  MOVFF  722,728
025CE:  RCALL  1F0C
025D0:  MOVLB  7
025D2:  BRA    26B0
....................             break;
025D4:  BRA    26B0
025D6:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
025D8:  MOVFF  725,72B
025DC:  MOVFF  724,72A
025E0:  MOVFF  723,729
025E4:  MOVFF  722,728
025E8:  RCALL  1F0C
025EA:  MOVFF  FEA,729
025EE:  MOVFF  FE9,728
025F2:  BSF    FD8.1
025F4:  MOVLW  DB
025F6:  MOVLB  7
025F8:  MOVWF  x4D
025FA:  MOVLW  0F
025FC:  MOVWF  x4C
025FE:  MOVLW  49
02600:  MOVWF  x4B
02602:  MOVLW  80
02604:  MOVWF  x4A
02606:  MOVFF  03,751
0260A:  MOVFF  02,750
0260E:  MOVFF  01,74F
02612:  MOVFF  00,74E
02616:  MOVLB  0
02618:  CALL   0E9E
0261C:  MOVFF  729,FEA
02620:  MOVFF  728,FE9
02624:  MOVLB  7
02626:  BRA    26B0
....................             break;
02628:  BRA    26B0
0262A:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
0262C:  MOVFF  725,72B
02630:  MOVFF  724,72A
02634:  MOVFF  723,729
02638:  MOVFF  722,728
0263C:  RCALL  1F0C
0263E:  MOVFF  03,72B
02642:  MOVFF  02,72A
02646:  MOVFF  01,729
0264A:  MOVFF  00,728
0264E:  MOVFF  FEA,72D
02652:  MOVFF  FE9,72C
02656:  BSF    FD8.1
02658:  MOVFF  03,74D
0265C:  MOVFF  02,74C
02660:  MOVFF  01,74B
02664:  MOVFF  00,74A
02668:  MOVLW  DB
0266A:  MOVLB  7
0266C:  MOVWF  x51
0266E:  MOVLW  0F
02670:  MOVWF  x50
02672:  MOVLW  49
02674:  MOVWF  x4F
02676:  MOVLW  80
02678:  MOVWF  x4E
0267A:  MOVLB  0
0267C:  CALL   0E9E
02680:  MOVFF  72D,FEA
02684:  MOVFF  72C,FE9
02688:  MOVLB  7
0268A:  BRA    26B0
....................             break;
0268C:  BRA    26B0
0268E:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02690:  MOVFF  725,72B
02694:  MOVFF  724,72A
02698:  MOVFF  723,729
0269C:  MOVFF  722,728
026A0:  RCALL  1F0C
026A2:  MOVLW  80
026A4:  XORWF  01,F
026A6:  MOVLB  7
026A8:  BRA    26B0
....................             break;
026AA:  BRA    26B0
026AC:  MOVLB  0
026AE:  MOVLB  7
....................          }
....................       }
....................    }
026B0:  MOVLB  0
026B2:  GOTO   3DBC (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
0090C:  MOVFF  730,FEA
00910:  MOVLB  7
00912:  MOVFF  72F,FE9
00916:  CLRF   x42
00918:  MOVFF  FEF,741
0091C:  CLRF   x44
0091E:  MOVLW  04
00920:  MOVWF  x43
00922:  MOVLB  0
00924:  RCALL  08BE
00926:  MOVF   01,W
00928:  MOVLB  7
0092A:  ADDWF  x2D,W
0092C:  MOVWF  FE9
0092E:  MOVF   x2E,W
00930:  ADDWFC 02,W
00932:  MOVWF  FEA
00934:  MOVFF  731,FEF
00938:  MOVFF  732,FEC
0093C:  MOVFF  733,FEC
00940:  MOVFF  734,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
00944:  MOVFF  730,736
00948:  MOVFF  730,FEA
0094C:  MOVFF  72F,FE9
00950:  MOVLW  01
00952:  ADDWF  FEF,W
00954:  MOVWF  x38
00956:  MOVWF  x3A
00958:  MOVLW  05
0095A:  MOVWF  x3B
0095C:  MOVLB  0
0095E:  RCALL  08E0
00960:  MOVLB  7
00962:  MOVFF  736,FEA
00966:  MOVFF  72F,FE9
0096A:  MOVFF  00,FEF
0096E:  MOVLB  0
00970:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
01116:  MOVLB  F
01118:  BTFSC  x5B.0
0111A:  BRA    1666
....................       switch (state)
0111C:  MOVLB  1
0111E:  MOVF   xE6,W
01120:  ADDLW  F9
01122:  BTFSC  FD8.0
01124:  BRA    1664
01126:  ADDLW  07
01128:  MOVLB  0
0112A:  GOTO   166C
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
0112E:  MOVLB  F
01130:  BTFSC  x5B.0
01132:  BRA    1130
01134:  MOVFF  F5F,02
01138:  MOVFF  F5E,01
0113C:  MOVFF  02,6FC
01140:  MOVFF  01,6FB
01144:  MOVFF  02,74B
01148:  MOVFF  01,74A
0114C:  MOVLB  0
0114E:  RCALL  0D72
01150:  MOVFF  03,753
01154:  MOVFF  02,752
01158:  MOVFF  01,751
0115C:  MOVFF  00,750
01160:  MOVFF  C9,757
01164:  MOVFF  C8,756
01168:  MOVFF  C7,755
0116C:  MOVFF  C6,754
01170:  RCALL  0DA8
01172:  MOVFF  03,6FE
01176:  MOVFF  02,6FD
0117A:  MOVFF  01,6FC
0117E:  MOVFF  00,6FB
01182:  BCF    FD8.1
01184:  MOVFF  03,74D
01188:  MOVFF  02,74C
0118C:  MOVFF  01,74B
01190:  MOVFF  00,74A
01194:  MOVFF  C5,751
01198:  MOVFF  C4,750
0119C:  MOVFF  C3,74F
011A0:  MOVFF  C2,74E
011A4:  RCALL  0E9E
011A6:  MOVFF  03,FE
011AA:  MOVFF  02,FD
011AE:  MOVFF  01,FC
011B2:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
011B6:  MOVLB  F
011B8:  MOVF   x5A,W
011BA:  ANDLW  3F
011BC:  MOVWF  01
011BE:  MOVLW  10
011C0:  MOVWF  x5A
011C2:  BTFSS  x5B.7
011C4:  BRA    11D4
011C6:  MOVF   01,W
011C8:  SUBLW  10
011CA:  BZ    11D4
011CC:  BSF    x5B.0
011CE:  NOP   
011D0:  BTFSC  x5B.0
011D2:  BRA    11D0
....................             delay_ms(10);
011D4:  MOVLW  0A
011D6:  MOVLB  7
011D8:  MOVWF  x01
011DA:  MOVLB  0
011DC:  CALL   03D2
....................             read_adc(ADC_START_ONLY);
011E0:  MOVLB  F
011E2:  BSF    x5B.0
011E4:  NOP   
....................             state = 1;
011E6:  MOVLW  01
011E8:  MOVLB  1
011EA:  MOVWF  xE6
....................          break;
011EC:  BRA    1664
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011EE:  MOVLB  F
011F0:  BTFSC  x5B.0
011F2:  BRA    11F0
011F4:  MOVFF  F5F,02
011F8:  MOVFF  F5E,01
011FC:  MOVFF  02,6FC
01200:  MOVFF  01,6FB
01204:  MOVFF  02,74B
01208:  MOVFF  01,74A
0120C:  MOVLB  0
0120E:  RCALL  0D72
01210:  MOVFF  03,753
01214:  MOVFF  02,752
01218:  MOVFF  01,751
0121C:  MOVFF  00,750
01220:  MOVFF  D1,757
01224:  MOVFF  D0,756
01228:  MOVFF  CF,755
0122C:  MOVFF  CE,754
01230:  RCALL  0DA8
01232:  MOVFF  03,6FE
01236:  MOVFF  02,6FD
0123A:  MOVFF  01,6FC
0123E:  MOVFF  00,6FB
01242:  BCF    FD8.1
01244:  MOVFF  03,74D
01248:  MOVFF  02,74C
0124C:  MOVFF  01,74B
01250:  MOVFF  00,74A
01254:  MOVFF  CD,751
01258:  MOVFF  CC,750
0125C:  MOVFF  CB,74F
01260:  MOVFF  CA,74E
01264:  RCALL  0E9E
01266:  MOVFF  03,102
0126A:  MOVFF  02,101
0126E:  MOVFF  01,100
01272:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
01276:  MOVLB  F
01278:  MOVF   x5A,W
0127A:  ANDLW  3F
0127C:  MOVWF  01
0127E:  MOVLW  18
01280:  MOVWF  x5A
01282:  BTFSS  x5B.7
01284:  BRA    1294
01286:  MOVF   01,W
01288:  SUBLW  18
0128A:  BZ    1294
0128C:  BSF    x5B.0
0128E:  NOP   
01290:  BTFSC  x5B.0
01292:  BRA    1290
....................             delay_ms(10);
01294:  MOVLW  0A
01296:  MOVLB  7
01298:  MOVWF  x01
0129A:  MOVLB  0
0129C:  CALL   03D2
....................             read_adc(ADC_START_ONLY);
012A0:  MOVLB  F
012A2:  BSF    x5B.0
012A4:  NOP   
....................             state = 2;
012A6:  MOVLW  02
012A8:  MOVLB  1
012AA:  MOVWF  xE6
....................          break;
012AC:  BRA    1664
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
012AE:  MOVLB  F
012B0:  BTFSC  x5B.0
012B2:  BRA    12B0
012B4:  MOVFF  F5F,02
012B8:  MOVFF  F5E,01
012BC:  MOVFF  02,6FC
012C0:  MOVFF  01,6FB
012C4:  MOVFF  02,74B
012C8:  MOVFF  01,74A
012CC:  MOVLB  0
012CE:  RCALL  0D72
012D0:  MOVFF  03,753
012D4:  MOVFF  02,752
012D8:  MOVFF  01,751
012DC:  MOVFF  00,750
012E0:  MOVFF  D9,757
012E4:  MOVFF  D8,756
012E8:  MOVFF  D7,755
012EC:  MOVFF  D6,754
012F0:  RCALL  0DA8
012F2:  MOVFF  03,6FE
012F6:  MOVFF  02,6FD
012FA:  MOVFF  01,6FC
012FE:  MOVFF  00,6FB
01302:  BCF    FD8.1
01304:  MOVFF  03,74D
01308:  MOVFF  02,74C
0130C:  MOVFF  01,74B
01310:  MOVFF  00,74A
01314:  MOVFF  D5,751
01318:  MOVFF  D4,750
0131C:  MOVFF  D3,74F
01320:  MOVFF  D2,74E
01324:  RCALL  0E9E
01326:  MOVFF  03,106
0132A:  MOVFF  02,105
0132E:  MOVFF  01,104
01332:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
01336:  MOVLB  F
01338:  MOVF   x5A,W
0133A:  ANDLW  3F
0133C:  MOVWF  01
0133E:  MOVLW  19
01340:  MOVWF  x5A
01342:  BTFSS  x5B.7
01344:  BRA    1354
01346:  MOVF   01,W
01348:  SUBLW  19
0134A:  BZ    1354
0134C:  BSF    x5B.0
0134E:  NOP   
01350:  BTFSC  x5B.0
01352:  BRA    1350
....................             delay_ms(10);
01354:  MOVLW  0A
01356:  MOVLB  7
01358:  MOVWF  x01
0135A:  MOVLB  0
0135C:  CALL   03D2
....................             read_adc(ADC_START_ONLY);
01360:  MOVLB  F
01362:  BSF    x5B.0
01364:  NOP   
....................             state = 3;
01366:  MOVLW  03
01368:  MOVLB  1
0136A:  MOVWF  xE6
....................          break;
0136C:  BRA    1664
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
0136E:  MOVLB  F
01370:  BTFSC  x5B.0
01372:  BRA    1370
01374:  MOVFF  F5F,02
01378:  MOVFF  F5E,01
0137C:  MOVFF  02,6FC
01380:  MOVFF  01,6FB
01384:  MOVFF  02,74B
01388:  MOVFF  01,74A
0138C:  MOVLB  0
0138E:  RCALL  0D72
01390:  MOVFF  03,753
01394:  MOVFF  02,752
01398:  MOVFF  01,751
0139C:  MOVFF  00,750
013A0:  MOVFF  E1,757
013A4:  MOVFF  E0,756
013A8:  MOVFF  DF,755
013AC:  MOVFF  DE,754
013B0:  RCALL  0DA8
013B2:  MOVFF  03,6FE
013B6:  MOVFF  02,6FD
013BA:  MOVFF  01,6FC
013BE:  MOVFF  00,6FB
013C2:  BCF    FD8.1
013C4:  MOVFF  03,74D
013C8:  MOVFF  02,74C
013CC:  MOVFF  01,74B
013D0:  MOVFF  00,74A
013D4:  MOVFF  DD,751
013D8:  MOVFF  DC,750
013DC:  MOVFF  DB,74F
013E0:  MOVFF  DA,74E
013E4:  RCALL  0E9E
013E6:  MOVFF  03,10A
013EA:  MOVFF  02,109
013EE:  MOVFF  01,108
013F2:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
013F6:  MOVLB  F
013F8:  MOVF   x5A,W
013FA:  ANDLW  3F
013FC:  MOVWF  01
013FE:  MOVLW  11
01400:  MOVWF  x5A
01402:  BTFSS  x5B.7
01404:  BRA    1414
01406:  MOVF   01,W
01408:  SUBLW  11
0140A:  BZ    1414
0140C:  BSF    x5B.0
0140E:  NOP   
01410:  BTFSC  x5B.0
01412:  BRA    1410
....................             delay_ms(10);
01414:  MOVLW  0A
01416:  MOVLB  7
01418:  MOVWF  x01
0141A:  MOVLB  0
0141C:  CALL   03D2
....................             read_adc(ADC_START_ONLY);
01420:  MOVLB  F
01422:  BSF    x5B.0
01424:  NOP   
....................             state = 4;
01426:  MOVLW  04
01428:  MOVLB  1
0142A:  MOVWF  xE6
....................          break;
0142C:  BRA    1664
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0142E:  MOVLB  F
01430:  BTFSC  x5B.0
01432:  BRA    1430
01434:  MOVFF  F5F,02
01438:  MOVFF  F5E,01
0143C:  MOVFF  02,6FC
01440:  MOVFF  01,6FB
01444:  MOVFF  02,74B
01448:  MOVFF  01,74A
0144C:  MOVLB  0
0144E:  RCALL  0D72
01450:  MOVFF  03,753
01454:  MOVFF  02,752
01458:  MOVFF  01,751
0145C:  MOVFF  00,750
01460:  MOVFF  E9,757
01464:  MOVFF  E8,756
01468:  MOVFF  E7,755
0146C:  MOVFF  E6,754
01470:  RCALL  0DA8
01472:  MOVFF  03,6FE
01476:  MOVFF  02,6FD
0147A:  MOVFF  01,6FC
0147E:  MOVFF  00,6FB
01482:  BCF    FD8.1
01484:  MOVFF  03,74D
01488:  MOVFF  02,74C
0148C:  MOVFF  01,74B
01490:  MOVFF  00,74A
01494:  MOVFF  E5,751
01498:  MOVFF  E4,750
0149C:  MOVFF  E3,74F
014A0:  MOVFF  E2,74E
014A4:  RCALL  0E9E
014A6:  MOVFF  03,10E
014AA:  MOVFF  02,10D
014AE:  MOVFF  01,10C
014B2:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
014B6:  MOVLB  F
014B8:  MOVF   x5A,W
014BA:  ANDLW  3F
014BC:  MOVWF  01
014BE:  MOVLW  1B
014C0:  MOVWF  x5A
014C2:  BTFSS  x5B.7
014C4:  BRA    14D4
014C6:  MOVF   01,W
014C8:  SUBLW  1B
014CA:  BZ    14D4
014CC:  BSF    x5B.0
014CE:  NOP   
014D0:  BTFSC  x5B.0
014D2:  BRA    14D0
....................             delay_ms(10);
014D4:  MOVLW  0A
014D6:  MOVLB  7
014D8:  MOVWF  x01
014DA:  MOVLB  0
014DC:  CALL   03D2
....................             read_adc(ADC_START_ONLY);
014E0:  MOVLB  F
014E2:  BSF    x5B.0
014E4:  NOP   
....................             state = 5;
014E6:  MOVLW  05
014E8:  MOVLB  1
014EA:  MOVWF  xE6
....................          break;
014EC:  BRA    1664
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014EE:  MOVLB  F
014F0:  BTFSC  x5B.0
014F2:  BRA    14F0
014F4:  MOVFF  F5F,02
014F8:  MOVFF  F5E,01
014FC:  MOVFF  02,6FC
01500:  MOVFF  01,6FB
01504:  MOVFF  02,74B
01508:  MOVFF  01,74A
0150C:  MOVLB  0
0150E:  RCALL  0D72
01510:  MOVFF  03,753
01514:  MOVFF  02,752
01518:  MOVFF  01,751
0151C:  MOVFF  00,750
01520:  MOVFF  F1,757
01524:  MOVFF  F0,756
01528:  MOVFF  EF,755
0152C:  MOVFF  EE,754
01530:  RCALL  0DA8
01532:  MOVFF  03,6FE
01536:  MOVFF  02,6FD
0153A:  MOVFF  01,6FC
0153E:  MOVFF  00,6FB
01542:  BCF    FD8.1
01544:  MOVFF  03,74D
01548:  MOVFF  02,74C
0154C:  MOVFF  01,74B
01550:  MOVFF  00,74A
01554:  MOVFF  ED,751
01558:  MOVFF  EC,750
0155C:  MOVFF  EB,74F
01560:  MOVFF  EA,74E
01564:  RCALL  0E9E
01566:  MOVFF  03,112
0156A:  MOVFF  02,111
0156E:  MOVFF  01,110
01572:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
01576:  MOVLB  F
01578:  MOVF   x5A,W
0157A:  ANDLW  3F
0157C:  MOVWF  01
0157E:  MOVLW  1A
01580:  MOVWF  x5A
01582:  BTFSS  x5B.7
01584:  BRA    1594
01586:  MOVF   01,W
01588:  SUBLW  1A
0158A:  BZ    1594
0158C:  BSF    x5B.0
0158E:  NOP   
01590:  BTFSC  x5B.0
01592:  BRA    1590
....................             delay_ms(10);
01594:  MOVLW  0A
01596:  MOVLB  7
01598:  MOVWF  x01
0159A:  MOVLB  0
0159C:  CALL   03D2
....................             read_adc(ADC_START_ONLY);
015A0:  MOVLB  F
015A2:  BSF    x5B.0
015A4:  NOP   
....................             state = 6;
015A6:  MOVLW  06
015A8:  MOVLB  1
015AA:  MOVWF  xE6
....................          break;
015AC:  BRA    1664
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
015AE:  MOVLB  F
015B0:  BTFSC  x5B.0
015B2:  BRA    15B0
015B4:  MOVFF  F5F,02
015B8:  MOVFF  F5E,01
015BC:  MOVFF  02,6FC
015C0:  MOVFF  01,6FB
015C4:  MOVFF  02,74B
015C8:  MOVFF  01,74A
015CC:  MOVLB  0
015CE:  CALL   0D72
015D2:  MOVFF  03,753
015D6:  MOVFF  02,752
015DA:  MOVFF  01,751
015DE:  MOVFF  00,750
015E2:  MOVFF  F9,757
015E6:  MOVFF  F8,756
015EA:  MOVFF  F7,755
015EE:  MOVFF  F6,754
015F2:  CALL   0DA8
015F6:  MOVFF  03,6FE
015FA:  MOVFF  02,6FD
015FE:  MOVFF  01,6FC
01602:  MOVFF  00,6FB
01606:  BCF    FD8.1
01608:  MOVFF  03,74D
0160C:  MOVFF  02,74C
01610:  MOVFF  01,74B
01614:  MOVFF  00,74A
01618:  MOVFF  F5,751
0161C:  MOVFF  F4,750
01620:  MOVFF  F3,74F
01624:  MOVFF  F2,74E
01628:  RCALL  0E9E
0162A:  MOVFF  03,116
0162E:  MOVFF  02,115
01632:  MOVFF  01,114
01636:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
0163A:  MOVLB  F
0163C:  MOVF   x5A,W
0163E:  ANDLW  3F
01640:  MOVWF  01
01642:  MOVLW  06
01644:  MOVWF  x5A
01646:  BTFSS  x5B.7
01648:  BRA    1658
0164A:  MOVF   01,W
0164C:  SUBLW  06
0164E:  BZ    1658
01650:  BSF    x5B.0
01652:  NOP   
01654:  BTFSC  x5B.0
01656:  BRA    1654
....................             read_adc(ADC_START_ONLY);
01658:  BSF    x5B.0
0165A:  NOP   
....................             state = 0;
0165C:  MOVLB  1
0165E:  CLRF   xE6
....................          break;   
01660:  BRA    1664
01662:  MOVLB  1
01664:  MOVLB  F
....................       }
....................    }
01666:  MOVLB  0
01668:  GOTO   A742 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03714:  MOVLB  7
03716:  MOVF   x03,W
03718:  MULLW  26
0371A:  MOVF   FF3,W
0371C:  CLRF   x0D
0371E:  MOVWF  x0C
03720:  MOVLW  10
03722:  ADDWF  x0C,W
03724:  MOVWF  01
03726:  MOVLW  00
03728:  ADDWFC x0D,W
0372A:  MOVWF  03
0372C:  MOVF   01,W
0372E:  ADDLW  17
03730:  MOVWF  01
03732:  MOVLW  01
03734:  ADDWFC 03,F
03736:  MOVFF  01,70C
0373A:  MOVFF  03,70D
0373E:  MOVF   x03,W
03740:  MULLW  26
03742:  MOVF   FF3,W
03744:  CLRF   x0F
03746:  MOVWF  x0E
03748:  MOVLW  08
0374A:  ADDWF  x0E,W
0374C:  MOVWF  01
0374E:  MOVLW  00
03750:  ADDWFC x0F,W
03752:  MOVWF  03
03754:  MOVF   01,W
03756:  ADDLW  17
03758:  MOVWF  FE9
0375A:  MOVLW  01
0375C:  ADDWFC 03,W
0375E:  MOVWF  FEA
03760:  MOVFF  FEF,00
03764:  MOVFF  FEC,01
03768:  MOVFF  FEC,02
0376C:  MOVFF  FEC,03
03770:  MOVFF  70D,FEA
03774:  MOVFF  70C,FE9
03778:  MOVFF  00,FEF
0377C:  MOVFF  01,FEC
03780:  MOVFF  02,FEC
03784:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03788:  MOVF   x03,W
0378A:  MULLW  26
0378C:  MOVF   FF3,W
0378E:  CLRF   x0D
03790:  MOVWF  x0C
03792:  MOVLW  14
03794:  ADDWF  x0C,W
03796:  MOVWF  01
03798:  MOVLW  00
0379A:  ADDWFC x0D,W
0379C:  MOVWF  03
0379E:  MOVF   01,W
037A0:  ADDLW  17
037A2:  MOVWF  01
037A4:  MOVLW  01
037A6:  ADDWFC 03,F
037A8:  MOVFF  01,70C
037AC:  MOVFF  03,70D
037B0:  MOVF   x03,W
037B2:  MULLW  26
037B4:  MOVF   FF3,W
037B6:  CLRF   x0F
037B8:  MOVWF  x0E
037BA:  MOVLW  0C
037BC:  ADDWF  x0E,W
037BE:  MOVWF  01
037C0:  MOVLW  00
037C2:  ADDWFC x0F,W
037C4:  MOVWF  03
037C6:  MOVF   01,W
037C8:  ADDLW  17
037CA:  MOVWF  FE9
037CC:  MOVLW  01
037CE:  ADDWFC 03,W
037D0:  MOVWF  FEA
037D2:  MOVFF  FEF,00
037D6:  MOVFF  FEC,01
037DA:  MOVFF  FEC,02
037DE:  MOVFF  FEC,03
037E2:  MOVFF  70D,FEA
037E6:  MOVFF  70C,FE9
037EA:  MOVFF  00,FEF
037EE:  MOVFF  01,FEC
037F2:  MOVFF  02,FEC
037F6:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037FA:  MOVF   x03,W
037FC:  MULLW  26
037FE:  MOVF   FF3,W
03800:  CLRF   x0D
03802:  MOVWF  x0C
03804:  MOVLW  17
03806:  ADDWF  x0C,W
03808:  MOVWF  01
0380A:  MOVLW  01
0380C:  ADDWFC x0D,W
0380E:  MOVWF  03
03810:  MOVFF  01,70E
03814:  MOVWF  x0F
03816:  MOVF   x03,W
03818:  MULLW  09
0381A:  MOVF   FF3,W
0381C:  CLRF   x11
0381E:  MOVWF  x10
03820:  MOVLW  01
03822:  ADDWF  x10,W
03824:  MOVWF  01
03826:  MOVLW  00
03828:  ADDWFC x11,W
0382A:  MOVWF  03
0382C:  MOVF   01,W
0382E:  ADDLW  D4
03830:  MOVWF  FE9
03832:  MOVLW  01
03834:  ADDWFC 03,W
03836:  MOVWF  FEA
03838:  MOVFF  FEF,710
0383C:  MOVFF  FEC,01
03840:  MOVFF  FEC,02
03844:  MOVFF  FEC,03
03848:  MOVFF  03,713
0384C:  MOVFF  02,712
03850:  MOVFF  01,711
03854:  MOVLB  0
03856:  CALL   1CDA
0385A:  MOVFF  70F,FEA
0385E:  MOVFF  70E,FE9
03862:  MOVFF  00,FEF
03866:  MOVFF  01,FEC
0386A:  MOVFF  02,FEC
0386E:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03872:  MOVLB  7
03874:  MOVF   x03,W
03876:  MULLW  26
03878:  MOVF   FF3,W
0387A:  CLRF   x0D
0387C:  MOVWF  x0C
0387E:  MOVLW  04
03880:  ADDWF  x0C,W
03882:  MOVWF  01
03884:  MOVLW  00
03886:  ADDWFC x0D,W
03888:  MOVWF  03
0388A:  MOVF   01,W
0388C:  ADDLW  17
0388E:  MOVWF  01
03890:  MOVLW  01
03892:  ADDWFC 03,F
03894:  MOVFF  01,70C
03898:  MOVFF  03,70D
0389C:  MOVF   x03,W
0389E:  MULLW  09
038A0:  MOVF   FF3,W
038A2:  CLRF   x0F
038A4:  MOVWF  x0E
038A6:  MOVLW  05
038A8:  ADDWF  x0E,W
038AA:  MOVWF  01
038AC:  MOVLW  00
038AE:  ADDWFC x0F,W
038B0:  MOVWF  03
038B2:  MOVF   01,W
038B4:  ADDLW  D4
038B6:  MOVWF  FE9
038B8:  MOVLW  01
038BA:  ADDWFC 03,W
038BC:  MOVWF  FEA
038BE:  MOVFF  FEF,710
038C2:  MOVFF  FEC,01
038C6:  MOVFF  FEC,02
038CA:  MOVFF  FEC,03
038CE:  MOVFF  03,713
038D2:  MOVFF  02,712
038D6:  MOVFF  01,711
038DA:  MOVLB  0
038DC:  CALL   1CDA
038E0:  MOVFF  70D,FEA
038E4:  MOVFF  70C,FE9
038E8:  MOVFF  00,FEF
038EC:  MOVFF  01,FEC
038F0:  MOVFF  02,FEC
038F4:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038F8:  MOVLB  7
038FA:  MOVF   x03,W
038FC:  MULLW  26
038FE:  MOVF   FF3,W
03900:  CLRF   x0D
03902:  MOVWF  x0C
03904:  MOVLW  08
03906:  ADDWF  x0C,W
03908:  MOVWF  01
0390A:  MOVLW  00
0390C:  ADDWFC x0D,W
0390E:  MOVWF  03
03910:  MOVF   01,W
03912:  ADDLW  17
03914:  MOVWF  01
03916:  MOVLW  01
03918:  ADDWFC 03,F
0391A:  MOVFF  01,70C
0391E:  MOVFF  03,70D
03922:  MOVF   x03,W
03924:  MULLW  26
03926:  MOVF   FF3,W
03928:  CLRF   x0F
0392A:  MOVWF  x0E
0392C:  MOVLW  17
0392E:  ADDWF  x0E,W
03930:  MOVWF  FE9
03932:  MOVLW  01
03934:  ADDWFC x0F,W
03936:  MOVWF  FEA
03938:  MOVFF  FEF,750
0393C:  MOVFF  FEC,751
03940:  MOVFF  FEC,752
03944:  MOVFF  FEC,753
03948:  MOVF   x03,W
0394A:  MULLW  10
0394C:  MOVF   FF3,W
0394E:  CLRF   x15
03950:  MOVWF  x14
03952:  MOVLW  08
03954:  ADDWF  x14,W
03956:  MOVWF  01
03958:  MOVLW  00
0395A:  ADDWFC x15,W
0395C:  MOVWF  03
0395E:  MOVF   01,W
03960:  ADDLW  72
03962:  MOVWF  FE9
03964:  MOVLW  00
03966:  ADDWFC 03,W
03968:  MOVWF  FEA
0396A:  MOVFF  FEF,754
0396E:  MOVFF  FEC,01
03972:  MOVFF  FEC,02
03976:  MOVFF  FEC,03
0397A:  MOVFF  03,757
0397E:  MOVFF  02,756
03982:  MOVFF  01,755
03986:  MOVLB  0
03988:  CALL   0DA8
0398C:  MOVFF  03,74D
03990:  MOVFF  02,74C
03994:  MOVFF  01,74B
03998:  MOVFF  00,74A
0399C:  MOVLB  7
0399E:  MOVF   x03,W
039A0:  MULLW  10
039A2:  MOVF   FF3,W
039A4:  CLRF   x15
039A6:  MOVWF  x14
039A8:  MOVLW  72
039AA:  ADDWF  x14,W
039AC:  MOVWF  FE9
039AE:  MOVLW  00
039B0:  ADDWFC x15,W
039B2:  MOVWF  FEA
039B4:  MOVFF  FEF,74E
039B8:  MOVFF  FEC,01
039BC:  MOVFF  FEC,02
039C0:  MOVFF  FEC,03
039C4:  BCF    FD8.1
039C6:  MOVFF  03,751
039CA:  MOVFF  02,750
039CE:  MOVFF  01,74F
039D2:  MOVLB  0
039D4:  CALL   0E9E
039D8:  MOVFF  70D,FEA
039DC:  MOVFF  70C,FE9
039E0:  MOVFF  00,FEF
039E4:  MOVFF  01,FEC
039E8:  MOVFF  02,FEC
039EC:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039F0:  MOVLB  7
039F2:  MOVF   x03,W
039F4:  MULLW  26
039F6:  MOVF   FF3,W
039F8:  CLRF   x0D
039FA:  MOVWF  x0C
039FC:  MOVLW  0C
039FE:  ADDWF  x0C,W
03A00:  MOVWF  01
03A02:  MOVLW  00
03A04:  ADDWFC x0D,W
03A06:  MOVWF  03
03A08:  MOVF   01,W
03A0A:  ADDLW  17
03A0C:  MOVWF  01
03A0E:  MOVLW  01
03A10:  ADDWFC 03,F
03A12:  MOVFF  01,70C
03A16:  MOVFF  03,70D
03A1A:  MOVF   x03,W
03A1C:  MULLW  26
03A1E:  MOVF   FF3,W
03A20:  CLRF   x0F
03A22:  MOVWF  x0E
03A24:  MOVLW  04
03A26:  ADDWF  x0E,W
03A28:  MOVWF  01
03A2A:  MOVLW  00
03A2C:  ADDWFC x0F,W
03A2E:  MOVWF  03
03A30:  MOVF   01,W
03A32:  ADDLW  17
03A34:  MOVWF  FE9
03A36:  MOVLW  01
03A38:  ADDWFC 03,W
03A3A:  MOVWF  FEA
03A3C:  MOVFF  FEF,750
03A40:  MOVFF  FEC,751
03A44:  MOVFF  FEC,752
03A48:  MOVFF  FEC,753
03A4C:  MOVF   x03,W
03A4E:  MULLW  10
03A50:  MOVF   FF3,W
03A52:  CLRF   x13
03A54:  MOVWF  x12
03A56:  MOVLW  0C
03A58:  ADDWF  x12,W
03A5A:  MOVWF  01
03A5C:  MOVLW  00
03A5E:  ADDWFC x13,W
03A60:  MOVWF  03
03A62:  MOVF   01,W
03A64:  ADDLW  72
03A66:  MOVWF  FE9
03A68:  MOVLW  00
03A6A:  ADDWFC 03,W
03A6C:  MOVWF  FEA
03A6E:  MOVFF  FEF,754
03A72:  MOVFF  FEC,01
03A76:  MOVFF  FEC,02
03A7A:  MOVFF  FEC,03
03A7E:  MOVFF  03,757
03A82:  MOVFF  02,756
03A86:  MOVFF  01,755
03A8A:  MOVLB  0
03A8C:  CALL   0DA8
03A90:  MOVFF  03,74D
03A94:  MOVFF  02,74C
03A98:  MOVFF  01,74B
03A9C:  MOVFF  00,74A
03AA0:  MOVLB  7
03AA2:  MOVF   x03,W
03AA4:  MULLW  10
03AA6:  MOVF   FF3,W
03AA8:  CLRF   x13
03AAA:  MOVWF  x12
03AAC:  MOVLW  04
03AAE:  ADDWF  x12,W
03AB0:  MOVWF  01
03AB2:  MOVLW  00
03AB4:  ADDWFC x13,W
03AB6:  MOVWF  03
03AB8:  MOVF   01,W
03ABA:  ADDLW  72
03ABC:  MOVWF  FE9
03ABE:  MOVLW  00
03AC0:  ADDWFC 03,W
03AC2:  MOVWF  FEA
03AC4:  MOVFF  FEF,74E
03AC8:  MOVFF  FEC,01
03ACC:  MOVFF  FEC,02
03AD0:  MOVFF  FEC,03
03AD4:  BCF    FD8.1
03AD6:  MOVFF  03,751
03ADA:  MOVFF  02,750
03ADE:  MOVFF  01,74F
03AE2:  MOVLB  0
03AE4:  CALL   0E9E
03AE8:  MOVFF  70D,FEA
03AEC:  MOVFF  70C,FE9
03AF0:  MOVFF  00,FEF
03AF4:  MOVFF  01,FEC
03AF8:  MOVFF  02,FEC
03AFC:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03B00:  MOVLB  7
03B02:  CLRF   x07
03B04:  CLRF   x06
03B06:  CLRF   x05
03B08:  CLRF   x04
03B0A:  CLRF   x0B
03B0C:  CLRF   x0A
03B0E:  CLRF   x09
03B10:  MOVLW  7F
03B12:  MOVWF  x08
....................    
....................    if (adcVals[ch].cosCounts < 0){
03B14:  MOVF   x03,W
03B16:  MULLW  26
03B18:  MOVF   FF3,W
03B1A:  CLRF   x0D
03B1C:  MOVWF  x0C
03B1E:  MOVLW  0C
03B20:  ADDWF  x0C,W
03B22:  MOVWF  01
03B24:  MOVLW  00
03B26:  ADDWFC x0D,W
03B28:  MOVWF  03
03B2A:  MOVF   01,W
03B2C:  ADDLW  17
03B2E:  MOVWF  FE9
03B30:  MOVLW  01
03B32:  ADDWFC 03,W
03B34:  MOVWF  FEA
03B36:  MOVFF  FEF,746
03B3A:  MOVFF  FEC,747
03B3E:  MOVFF  FEC,748
03B42:  MOVFF  FEC,749
03B46:  CLRF   x4D
03B48:  CLRF   x4C
03B4A:  CLRF   x4B
03B4C:  CLRF   x4A
03B4E:  MOVLB  0
03B50:  CALL   1D34
03B54:  BTFSS  FD8.0
03B56:  BRA    3CC0
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B58:  MOVLB  7
03B5A:  MOVF   x03,W
03B5C:  MULLW  26
03B5E:  MOVF   FF3,W
03B60:  CLRF   x0D
03B62:  MOVWF  x0C
03B64:  MOVLW  08
03B66:  ADDWF  x0C,W
03B68:  MOVWF  01
03B6A:  MOVLW  00
03B6C:  ADDWFC x0D,W
03B6E:  MOVWF  03
03B70:  MOVF   01,W
03B72:  ADDLW  17
03B74:  MOVWF  FE9
03B76:  MOVLW  01
03B78:  ADDWFC 03,W
03B7A:  MOVWF  FEA
03B7C:  MOVFF  FEF,74A
03B80:  MOVFF  FEC,70D
03B84:  MOVFF  FEC,74C
03B88:  MOVFF  FEC,74D
03B8C:  CLRF   x49
03B8E:  CLRF   x48
03B90:  CLRF   x47
03B92:  CLRF   x46
03B94:  MOVFF  70D,74B
03B98:  MOVLB  0
03B9A:  CALL   1D34
03B9E:  BNC   3C0C
03BA0:  MOVLB  7
03BA2:  MOVF   x03,W
03BA4:  MULLW  26
03BA6:  MOVF   FF3,W
03BA8:  CLRF   x0D
03BAA:  MOVWF  x0C
03BAC:  MOVLW  10
03BAE:  ADDWF  x0C,W
03BB0:  MOVWF  01
03BB2:  MOVLW  00
03BB4:  ADDWFC x0D,W
03BB6:  MOVWF  03
03BB8:  MOVF   01,W
03BBA:  ADDLW  17
03BBC:  MOVWF  FE9
03BBE:  MOVLW  01
03BC0:  ADDWFC 03,W
03BC2:  MOVWF  FEA
03BC4:  MOVFF  FEF,746
03BC8:  MOVFF  FEC,747
03BCC:  MOVFF  FEC,748
03BD0:  MOVFF  FEC,749
03BD4:  CLRF   x4D
03BD6:  CLRF   x4C
03BD8:  CLRF   x4B
03BDA:  CLRF   x4A
03BDC:  MOVLB  0
03BDE:  CALL   1D34
03BE2:  BNC   3C0C
....................          adcVals[ch].npoles--;
03BE4:  MOVLB  7
03BE6:  MOVF   x03,W
03BE8:  MULLW  26
03BEA:  MOVF   FF3,W
03BEC:  CLRF   x0D
03BEE:  MOVWF  x0C
03BF0:  MOVLW  1C
03BF2:  ADDWF  x0C,W
03BF4:  MOVWF  01
03BF6:  MOVLW  00
03BF8:  ADDWFC x0D,W
03BFA:  MOVWF  03
03BFC:  MOVF   01,W
03BFE:  ADDLW  17
03C00:  MOVWF  FE9
03C02:  MOVLW  01
03C04:  ADDWFC 03,W
03C06:  MOVWF  FEA
03C08:  DECF   FEF,F
....................       }
03C0A:  BRA    3CBE
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03C0C:  MOVLB  7
03C0E:  MOVF   x03,W
03C10:  MULLW  26
03C12:  MOVF   FF3,W
03C14:  CLRF   x0D
03C16:  MOVWF  x0C
03C18:  MOVLW  08
03C1A:  ADDWF  x0C,W
03C1C:  MOVWF  01
03C1E:  MOVLW  00
03C20:  ADDWFC x0D,W
03C22:  MOVWF  03
03C24:  MOVF   01,W
03C26:  ADDLW  17
03C28:  MOVWF  FE9
03C2A:  MOVLW  01
03C2C:  ADDWFC 03,W
03C2E:  MOVWF  FEA
03C30:  MOVFF  FEF,746
03C34:  MOVFF  FEC,70D
03C38:  MOVFF  FEC,748
03C3C:  MOVFF  FEC,749
03C40:  MOVFF  70D,747
03C44:  CLRF   x4D
03C46:  CLRF   x4C
03C48:  CLRF   x4B
03C4A:  CLRF   x4A
03C4C:  MOVLB  0
03C4E:  CALL   1D34
03C52:  BNC   3CC0
03C54:  MOVLB  7
03C56:  MOVF   x03,W
03C58:  MULLW  26
03C5A:  MOVF   FF3,W
03C5C:  CLRF   x0D
03C5E:  MOVWF  x0C
03C60:  MOVLW  10
03C62:  ADDWF  x0C,W
03C64:  MOVWF  01
03C66:  MOVLW  00
03C68:  ADDWFC x0D,W
03C6A:  MOVWF  03
03C6C:  MOVF   01,W
03C6E:  ADDLW  17
03C70:  MOVWF  FE9
03C72:  MOVLW  01
03C74:  ADDWFC 03,W
03C76:  MOVWF  FEA
03C78:  MOVFF  FEF,74A
03C7C:  MOVFF  FEC,74B
03C80:  MOVFF  FEC,74C
03C84:  MOVFF  FEC,74D
03C88:  CLRF   x49
03C8A:  CLRF   x48
03C8C:  CLRF   x47
03C8E:  CLRF   x46
03C90:  MOVLB  0
03C92:  CALL   1D34
03C96:  BNC   3CC0
....................          adcVals[ch].npoles++;
03C98:  MOVLB  7
03C9A:  MOVF   x03,W
03C9C:  MULLW  26
03C9E:  MOVF   FF3,W
03CA0:  CLRF   x0D
03CA2:  MOVWF  x0C
03CA4:  MOVLW  1C
03CA6:  ADDWF  x0C,W
03CA8:  MOVWF  01
03CAA:  MOVLW  00
03CAC:  ADDWFC x0D,W
03CAE:  MOVWF  03
03CB0:  MOVF   01,W
03CB2:  ADDLW  17
03CB4:  MOVWF  FE9
03CB6:  MOVLW  01
03CB8:  ADDWFC 03,W
03CBA:  MOVWF  FEA
03CBC:  INCF   FEF,F
03CBE:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03CC0:  MOVLB  7
03CC2:  MOVF   x03,W
03CC4:  MULLW  26
03CC6:  MOVF   FF3,W
03CC8:  CLRF   x0D
03CCA:  MOVWF  x0C
03CCC:  MOVLW  18
03CCE:  ADDWF  x0C,W
03CD0:  MOVWF  01
03CD2:  MOVLW  00
03CD4:  ADDWFC x0D,W
03CD6:  MOVWF  03
03CD8:  MOVF   01,W
03CDA:  ADDLW  17
03CDC:  MOVWF  01
03CDE:  MOVLW  01
03CE0:  ADDWFC 03,F
03CE2:  MOVFF  01,70C
03CE6:  MOVFF  03,70D
03CEA:  MOVFF  70B,753
03CEE:  MOVFF  70A,752
03CF2:  MOVFF  709,751
03CF6:  MOVFF  708,750
03CFA:  MOVLW  AA
03CFC:  MOVWF  x57
03CFE:  MOVLW  27
03D00:  MOVWF  x56
03D02:  MOVLW  1F
03D04:  MOVWF  x55
03D06:  MOVLW  86
03D08:  MOVWF  x54
03D0A:  MOVLB  0
03D0C:  CALL   0DA8
03D10:  MOVFF  03,711
03D14:  MOVFF  02,710
03D18:  MOVFF  01,70F
03D1C:  MOVFF  00,70E
03D20:  MOVLB  7
03D22:  MOVF   x03,W
03D24:  MULLW  26
03D26:  MOVF   FF3,W
03D28:  CLRF   x13
03D2A:  MOVWF  x12
03D2C:  MOVLW  08
03D2E:  ADDWF  x12,W
03D30:  MOVWF  01
03D32:  MOVLW  00
03D34:  ADDWFC x13,W
03D36:  MOVWF  03
03D38:  MOVF   01,W
03D3A:  ADDLW  17
03D3C:  MOVWF  FE9
03D3E:  MOVLW  01
03D40:  ADDWFC 03,W
03D42:  MOVWF  FEA
03D44:  MOVFF  FEF,712
03D48:  MOVFF  FEC,713
03D4C:  MOVFF  FEC,714
03D50:  MOVFF  FEC,715
03D54:  MOVF   x03,W
03D56:  MULLW  26
03D58:  MOVF   FF3,W
03D5A:  CLRF   x17
03D5C:  MOVWF  x16
03D5E:  MOVLW  0C
03D60:  ADDWF  x16,W
03D62:  MOVWF  01
03D64:  MOVLW  00
03D66:  ADDWFC x17,W
03D68:  MOVWF  03
03D6A:  MOVF   01,W
03D6C:  ADDLW  17
03D6E:  MOVWF  FE9
03D70:  MOVLW  01
03D72:  ADDWFC 03,W
03D74:  MOVWF  FEA
03D76:  MOVFF  FEF,00
03D7A:  MOVFF  FEC,01
03D7E:  MOVFF  FEC,02
03D82:  MOVFF  FEC,03
03D86:  MOVFF  03,719
03D8A:  MOVFF  02,718
03D8E:  MOVFF  01,717
03D92:  MOVFF  00,716
03D96:  MOVFF  715,71D
03D9A:  MOVFF  714,71C
03D9E:  MOVFF  713,71B
03DA2:  MOVFF  712,71A
03DA6:  MOVFF  03,721
03DAA:  MOVFF  02,720
03DAE:  MOVFF  01,71F
03DB2:  MOVFF  00,71E
03DB6:  MOVLB  0
03DB8:  GOTO   2436
03DBC:  MOVFF  711,753
03DC0:  MOVFF  710,752
03DC4:  MOVFF  70F,751
03DC8:  MOVFF  70E,750
03DCC:  MOVFF  03,757
03DD0:  MOVFF  02,756
03DD4:  MOVFF  01,755
03DD8:  MOVFF  00,754
03DDC:  CALL   0DA8
03DE0:  MOVFF  70D,FEA
03DE4:  MOVFF  70C,FE9
03DE8:  MOVFF  00,FEF
03DEC:  MOVFF  01,FEC
03DF0:  MOVFF  02,FEC
03DF4:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DF8:  MOVLB  7
03DFA:  MOVF   x03,W
03DFC:  MULLW  26
03DFE:  MOVF   FF3,W
03E00:  CLRF   x0D
03E02:  MOVWF  x0C
03E04:  MOVLW  18
03E06:  ADDWF  x0C,W
03E08:  MOVWF  01
03E0A:  MOVLW  00
03E0C:  ADDWFC x0D,W
03E0E:  MOVWF  03
03E10:  MOVF   01,W
03E12:  ADDLW  17
03E14:  MOVWF  FE9
03E16:  MOVLW  01
03E18:  ADDWFC 03,W
03E1A:  MOVWF  FEA
03E1C:  MOVFF  FEF,70C
03E20:  MOVFF  FEC,70D
03E24:  MOVFF  FEC,70E
03E28:  MOVFF  FEC,70F
03E2C:  CLRF   x53
03E2E:  CLRF   x52
03E30:  MOVLW  7A
03E32:  MOVWF  x51
03E34:  MOVLW  88
03E36:  MOVWF  x50
03E38:  MOVFF  70B,757
03E3C:  MOVFF  70A,756
03E40:  MOVFF  709,755
03E44:  MOVFF  708,754
03E48:  MOVLB  0
03E4A:  CALL   0DA8
03E4E:  MOVFF  03,713
03E52:  MOVFF  02,712
03E56:  MOVFF  01,711
03E5A:  MOVFF  00,710
03E5E:  MOVLB  7
03E60:  MOVF   x03,W
03E62:  MULLW  26
03E64:  MOVF   FF3,W
03E66:  CLRF   x15
03E68:  MOVWF  x14
03E6A:  MOVLW  1C
03E6C:  ADDWF  x14,W
03E6E:  MOVWF  01
03E70:  MOVLW  00
03E72:  ADDWFC x15,W
03E74:  MOVWF  03
03E76:  MOVF   01,W
03E78:  ADDLW  17
03E7A:  MOVWF  FE9
03E7C:  MOVLW  01
03E7E:  ADDWFC 03,W
03E80:  MOVWF  FEA
03E82:  MOVF   FEF,W
03E84:  CLRF   x3D
03E86:  MOVWF  x3C
03E88:  BTFSC  x3C.7
03E8A:  DECF   x3D,F
03E8C:  MOVLB  0
03E8E:  CALL   26D8
03E92:  MOVFF  713,753
03E96:  MOVFF  712,752
03E9A:  MOVFF  711,751
03E9E:  MOVFF  710,750
03EA2:  MOVFF  03,757
03EA6:  MOVFF  02,756
03EAA:  MOVFF  01,755
03EAE:  MOVFF  00,754
03EB2:  CALL   0DA8
03EB6:  MOVFF  FEA,711
03EBA:  MOVFF  FE9,710
03EBE:  BCF    FD8.1
03EC0:  MOVFF  70F,74D
03EC4:  MOVFF  70E,74C
03EC8:  MOVFF  70D,74B
03ECC:  MOVFF  70C,74A
03ED0:  MOVFF  03,751
03ED4:  MOVFF  02,750
03ED8:  MOVFF  01,74F
03EDC:  MOVFF  00,74E
03EE0:  CALL   0E9E
03EE4:  MOVFF  711,FEA
03EE8:  MOVFF  710,FE9
03EEC:  MOVFF  03,707
03EF0:  MOVFF  02,706
03EF4:  MOVFF  01,705
03EF8:  MOVFF  00,704
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EFC:  MOVLB  7
03EFE:  MOVF   x03,W
03F00:  MULLW  26
03F02:  MOVF   FF3,W
03F04:  CLRF   x0D
03F06:  MOVWF  x0C
03F08:  MOVLW  1D
03F0A:  ADDWF  x0C,W
03F0C:  MOVWF  01
03F0E:  MOVLW  00
03F10:  ADDWFC x0D,W
03F12:  MOVWF  03
03F14:  MOVF   01,W
03F16:  ADDLW  17
03F18:  MOVWF  01
03F1A:  MOVLW  01
03F1C:  ADDWFC 03,F
03F1E:  MOVFF  01,70C
03F22:  MOVFF  03,70D
03F26:  MOVF   x03,W
03F28:  MULLW  18
03F2A:  MOVF   FF3,W
03F2C:  CLRF   x0F
03F2E:  MOVWF  x0E
03F30:  MOVLW  14
03F32:  ADDWF  x0E,W
03F34:  MOVWF  01
03F36:  MOVLW  00
03F38:  ADDWFC x0F,W
03F3A:  MOVWF  03
03F3C:  MOVF   01,W
03F3E:  ADDLW  92
03F40:  MOVWF  FE9
03F42:  MOVLW  00
03F44:  ADDWFC 03,W
03F46:  MOVWF  FEA
03F48:  MOVFF  FEF,754
03F4C:  MOVFF  FEC,01
03F50:  MOVFF  FEC,02
03F54:  MOVFF  FEC,03
03F58:  MOVFF  707,753
03F5C:  MOVFF  706,752
03F60:  MOVFF  705,751
03F64:  MOVFF  704,750
03F68:  MOVFF  03,757
03F6C:  MOVFF  02,756
03F70:  MOVFF  01,755
03F74:  MOVLB  0
03F76:  CALL   0DA8
03F7A:  MOVFF  03,711
03F7E:  MOVFF  02,710
03F82:  MOVFF  01,70F
03F86:  MOVFF  00,70E
03F8A:  MOVFF  03,71D
03F8E:  MOVFF  02,71C
03F92:  MOVFF  01,71B
03F96:  MOVFF  00,71A
03F9A:  MOVLB  7
03F9C:  CLRF   x21
03F9E:  CLRF   x20
03FA0:  MOVLW  20
03FA2:  MOVWF  x1F
03FA4:  MOVLW  81
03FA6:  MOVWF  x1E
03FA8:  MOVLB  0
03FAA:  CALL   3416
03FAE:  MOVFF  03,711
03FB2:  MOVFF  02,710
03FB6:  MOVFF  01,70F
03FBA:  MOVFF  00,70E
03FBE:  MOVLB  7
03FC0:  MOVF   x03,W
03FC2:  MULLW  18
03FC4:  MOVF   FF3,W
03FC6:  CLRF   x13
03FC8:  MOVWF  x12
03FCA:  MOVLW  10
03FCC:  ADDWF  x12,W
03FCE:  MOVWF  01
03FD0:  MOVLW  00
03FD2:  ADDWFC x13,W
03FD4:  MOVWF  03
03FD6:  MOVF   01,W
03FD8:  ADDLW  92
03FDA:  MOVWF  FE9
03FDC:  MOVLW  00
03FDE:  ADDWFC 03,W
03FE0:  MOVWF  FEA
03FE2:  MOVFF  FEF,754
03FE6:  MOVFF  FEC,01
03FEA:  MOVFF  FEC,02
03FEE:  MOVFF  FEC,03
03FF2:  MOVFF  707,753
03FF6:  MOVFF  706,752
03FFA:  MOVFF  705,751
03FFE:  MOVFF  704,750
04002:  MOVFF  03,757
04006:  MOVFF  02,756
0400A:  MOVFF  01,755
0400E:  MOVLB  0
04010:  CALL   0DA8
04014:  MOVFF  03,715
04018:  MOVFF  02,714
0401C:  MOVFF  01,713
04020:  MOVFF  00,712
04024:  MOVFF  03,71D
04028:  MOVFF  02,71C
0402C:  MOVFF  01,71B
04030:  MOVFF  00,71A
04034:  MOVLB  7
04036:  CLRF   x21
04038:  CLRF   x20
0403A:  CLRF   x1F
0403C:  MOVLW  81
0403E:  MOVWF  x1E
04040:  MOVLB  0
04042:  CALL   3416
04046:  MOVFF  FEA,713
0404A:  MOVFF  FE9,712
0404E:  BCF    FD8.1
04050:  MOVFF  711,74D
04054:  MOVFF  710,74C
04058:  MOVFF  70F,74B
0405C:  MOVFF  70E,74A
04060:  MOVFF  03,751
04064:  MOVFF  02,750
04068:  MOVFF  01,74F
0406C:  MOVFF  00,74E
04070:  CALL   0E9E
04074:  MOVFF  713,FEA
04078:  MOVFF  712,FE9
0407C:  MOVFF  03,711
04080:  MOVFF  02,710
04084:  MOVFF  01,70F
04088:  MOVFF  00,70E
0408C:  MOVLB  7
0408E:  MOVF   x03,W
04090:  MULLW  18
04092:  MOVF   FF3,W
04094:  CLRF   x15
04096:  MOVWF  x14
04098:  MOVLW  0C
0409A:  ADDWF  x14,W
0409C:  MOVWF  01
0409E:  MOVLW  00
040A0:  ADDWFC x15,W
040A2:  MOVWF  03
040A4:  MOVF   01,W
040A6:  ADDLW  92
040A8:  MOVWF  FE9
040AA:  MOVLW  00
040AC:  ADDWFC 03,W
040AE:  MOVWF  FEA
040B0:  MOVFF  FEF,754
040B4:  MOVFF  FEC,01
040B8:  MOVFF  FEC,02
040BC:  MOVFF  FEC,03
040C0:  MOVFF  707,753
040C4:  MOVFF  706,752
040C8:  MOVFF  705,751
040CC:  MOVFF  704,750
040D0:  MOVFF  03,757
040D4:  MOVFF  02,756
040D8:  MOVFF  01,755
040DC:  MOVLB  0
040DE:  CALL   0DA8
040E2:  MOVFF  03,717
040E6:  MOVFF  02,716
040EA:  MOVFF  01,715
040EE:  MOVFF  00,714
040F2:  MOVFF  03,71D
040F6:  MOVFF  02,71C
040FA:  MOVFF  01,71B
040FE:  MOVFF  00,71A
04102:  MOVLB  7
04104:  CLRF   x21
04106:  CLRF   x20
04108:  MOVLW  40
0410A:  MOVWF  x1F
0410C:  MOVLW  80
0410E:  MOVWF  x1E
04110:  MOVLB  0
04112:  CALL   3416
04116:  MOVFF  FEA,715
0411A:  MOVFF  FE9,714
0411E:  BCF    FD8.1
04120:  MOVFF  711,74D
04124:  MOVFF  710,74C
04128:  MOVFF  70F,74B
0412C:  MOVFF  70E,74A
04130:  MOVFF  03,751
04134:  MOVFF  02,750
04138:  MOVFF  01,74F
0413C:  MOVFF  00,74E
04140:  CALL   0E9E
04144:  MOVFF  715,FEA
04148:  MOVFF  714,FE9
0414C:  MOVFF  03,711
04150:  MOVFF  02,710
04154:  MOVFF  01,70F
04158:  MOVFF  00,70E
0415C:  MOVLB  7
0415E:  MOVF   x03,W
04160:  MULLW  18
04162:  MOVF   FF3,W
04164:  CLRF   x17
04166:  MOVWF  x16
04168:  MOVLW  08
0416A:  ADDWF  x16,W
0416C:  MOVWF  01
0416E:  MOVLW  00
04170:  ADDWFC x17,W
04172:  MOVWF  03
04174:  MOVF   01,W
04176:  ADDLW  92
04178:  MOVWF  FE9
0417A:  MOVLW  00
0417C:  ADDWFC 03,W
0417E:  MOVWF  FEA
04180:  MOVFF  FEF,754
04184:  MOVFF  FEC,01
04188:  MOVFF  FEC,02
0418C:  MOVFF  FEC,03
04190:  MOVFF  707,753
04194:  MOVFF  706,752
04198:  MOVFF  705,751
0419C:  MOVFF  704,750
041A0:  MOVFF  03,757
041A4:  MOVFF  02,756
041A8:  MOVFF  01,755
041AC:  MOVLB  0
041AE:  CALL   0DA8
041B2:  MOVFF  03,719
041B6:  MOVFF  02,718
041BA:  MOVFF  01,717
041BE:  MOVFF  00,716
041C2:  MOVFF  03,71D
041C6:  MOVFF  02,71C
041CA:  MOVFF  01,71B
041CE:  MOVFF  00,71A
041D2:  MOVLB  7
041D4:  CLRF   x21
041D6:  CLRF   x20
041D8:  CLRF   x1F
041DA:  MOVLW  80
041DC:  MOVWF  x1E
041DE:  MOVLB  0
041E0:  CALL   3416
041E4:  MOVFF  FEA,717
041E8:  MOVFF  FE9,716
041EC:  BCF    FD8.1
041EE:  MOVFF  711,74D
041F2:  MOVFF  710,74C
041F6:  MOVFF  70F,74B
041FA:  MOVFF  70E,74A
041FE:  MOVFF  03,751
04202:  MOVFF  02,750
04206:  MOVFF  01,74F
0420A:  MOVFF  00,74E
0420E:  CALL   0E9E
04212:  MOVFF  717,FEA
04216:  MOVFF  716,FE9
0421A:  MOVFF  03,711
0421E:  MOVFF  02,710
04222:  MOVFF  01,70F
04226:  MOVFF  00,70E
0422A:  MOVLB  7
0422C:  MOVF   x03,W
0422E:  MULLW  18
04230:  MOVF   FF3,W
04232:  CLRF   x19
04234:  MOVWF  x18
04236:  MOVLW  04
04238:  ADDWF  x18,W
0423A:  MOVWF  01
0423C:  MOVLW  00
0423E:  ADDWFC x19,W
04240:  MOVWF  03
04242:  MOVF   01,W
04244:  ADDLW  92
04246:  MOVWF  FE9
04248:  MOVLW  00
0424A:  ADDWFC 03,W
0424C:  MOVWF  FEA
0424E:  MOVFF  FEF,754
04252:  MOVFF  FEC,01
04256:  MOVFF  FEC,02
0425A:  MOVFF  FEC,03
0425E:  MOVFF  707,753
04262:  MOVFF  706,752
04266:  MOVFF  705,751
0426A:  MOVFF  704,750
0426E:  MOVFF  03,757
04272:  MOVFF  02,756
04276:  MOVFF  01,755
0427A:  MOVLB  0
0427C:  CALL   0DA8
04280:  MOVFF  FEA,719
04284:  MOVFF  FE9,718
04288:  BCF    FD8.1
0428A:  MOVFF  711,74D
0428E:  MOVFF  710,74C
04292:  MOVFF  70F,74B
04296:  MOVFF  70E,74A
0429A:  MOVFF  03,751
0429E:  MOVFF  02,750
042A2:  MOVFF  01,74F
042A6:  MOVFF  00,74E
042AA:  CALL   0E9E
042AE:  MOVFF  719,FEA
042B2:  MOVFF  718,FE9
042B6:  MOVFF  03,74D
042BA:  MOVFF  02,74C
042BE:  MOVFF  01,74B
042C2:  MOVFF  00,74A
042C6:  MOVLB  7
042C8:  MOVF   x03,W
042CA:  MULLW  18
042CC:  MOVF   FF3,W
042CE:  CLRF   x1B
042D0:  MOVWF  x1A
042D2:  MOVLW  92
042D4:  ADDWF  x1A,W
042D6:  MOVWF  FE9
042D8:  MOVLW  00
042DA:  ADDWFC x1B,W
042DC:  MOVWF  FEA
042DE:  MOVFF  FEF,74E
042E2:  MOVFF  FEC,01
042E6:  MOVFF  FEC,02
042EA:  MOVFF  FEC,03
042EE:  BCF    FD8.1
042F0:  MOVFF  03,751
042F4:  MOVFF  02,750
042F8:  MOVFF  01,74F
042FC:  MOVLB  0
042FE:  CALL   0E9E
04302:  MOVFF  70D,FEA
04306:  MOVFF  70C,FE9
0430A:  MOVFF  00,FEF
0430E:  MOVFF  01,FEC
04312:  MOVFF  02,FEC
04316:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
0431A:  MOVLB  7
0431C:  MOVF   x03,F
0431E:  BNZ   437C
04320:  MOVF   x03,W
04322:  MULLW  26
04324:  MOVF   FF3,W
04326:  CLRF   x0D
04328:  MOVWF  x0C
0432A:  MOVLW  1D
0432C:  ADDWF  x0C,W
0432E:  MOVWF  01
04330:  MOVLW  00
04332:  ADDWFC x0D,W
04334:  MOVWF  03
04336:  MOVF   01,W
04338:  ADDLW  17
0433A:  MOVWF  FE9
0433C:  MOVLW  01
0433E:  ADDWFC 03,W
04340:  MOVWF  FEA
04342:  MOVFF  FEF,750
04346:  MOVFF  FEC,751
0434A:  MOVFF  FEC,752
0434E:  MOVFF  FEC,753
04352:  MOVF   FED,F
04354:  MOVF   FED,F
04356:  MOVF   FED,F
04358:  CLRF   x57
0435A:  CLRF   x56
0435C:  MOVLW  80
0435E:  MOVWF  x55
04360:  MOVLW  7F
04362:  MOVWF  x54
04364:  MOVLB  0
04366:  CALL   0DA8
0436A:  MOVFF  00,FEF
0436E:  MOVFF  01,FEC
04372:  MOVFF  02,FEC
04376:  MOVFF  03,FEC
0437A:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
0437C:  MOVF   x03,W
0437E:  MULLW  28
04380:  MOVF   FF3,W
04382:  CLRF   x0D
04384:  MOVWF  x0C
04386:  MOVLW  14
04388:  ADDWF  x0C,W
0438A:  MOVWF  01
0438C:  MOVLW  00
0438E:  ADDWFC x0D,W
04390:  MOVWF  03
04392:  MOVF   01,W
04394:  ADDLW  20
04396:  MOVWF  01
04398:  MOVLW  00
0439A:  ADDWFC 03,F
0439C:  MOVFF  01,70C
043A0:  MOVFF  03,70D
043A4:  MOVF   x03,W
043A6:  MULLW  28
043A8:  MOVF   FF3,W
043AA:  CLRF   x0F
043AC:  MOVWF  x0E
043AE:  MOVLW  10
043B0:  ADDWF  x0E,W
043B2:  MOVWF  01
043B4:  MOVLW  00
043B6:  ADDWFC x0F,W
043B8:  MOVWF  03
043BA:  MOVF   01,W
043BC:  ADDLW  20
043BE:  MOVWF  FE9
043C0:  MOVLW  00
043C2:  ADDWFC 03,W
043C4:  MOVWF  FEA
043C6:  MOVFF  FEF,00
043CA:  MOVFF  FEC,01
043CE:  MOVFF  FEC,02
043D2:  MOVFF  FEC,03
043D6:  MOVFF  70D,FEA
043DA:  MOVFF  70C,FE9
043DE:  MOVFF  00,FEF
043E2:  MOVFF  01,FEC
043E6:  MOVFF  02,FEC
043EA:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043EE:  MOVF   x03,W
043F0:  MULLW  28
043F2:  MOVF   FF3,W
043F4:  CLRF   x0D
043F6:  MOVWF  x0C
043F8:  MOVLW  10
043FA:  ADDWF  x0C,W
043FC:  MOVWF  01
043FE:  MOVLW  00
04400:  ADDWFC x0D,W
04402:  MOVWF  03
04404:  MOVF   01,W
04406:  ADDLW  20
04408:  MOVWF  01
0440A:  MOVLW  00
0440C:  ADDWFC 03,F
0440E:  MOVFF  01,70C
04412:  MOVFF  03,70D
04416:  MOVF   x03,W
04418:  MULLW  26
0441A:  MOVF   FF3,W
0441C:  CLRF   x0F
0441E:  MOVWF  x0E
04420:  MOVLW  1D
04422:  ADDWF  x0E,W
04424:  MOVWF  01
04426:  MOVLW  00
04428:  ADDWFC x0F,W
0442A:  MOVWF  03
0442C:  MOVF   01,W
0442E:  ADDLW  17
04430:  MOVWF  FE9
04432:  MOVLW  01
04434:  ADDWFC 03,W
04436:  MOVWF  FEA
04438:  MOVFF  FEF,00
0443C:  MOVFF  FEC,01
04440:  MOVFF  FEC,02
04444:  MOVFF  FEC,03
04448:  MOVFF  70D,FEA
0444C:  MOVFF  70C,FE9
04450:  MOVFF  00,FEF
04454:  MOVFF  01,FEC
04458:  MOVFF  02,FEC
0445C:  MOVFF  03,FEC
04460:  MOVLB  0
04462:  GOTO   45C2 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001F6:  MOVLB  1
001F8:  MOVF   xE7,W
001FA:  MULLW  09
001FC:  MOVF   FF3,W
001FE:  MOVLB  7
00200:  CLRF   x72
00202:  MOVWF  x71
00204:  MOVLW  D4
00206:  ADDWF  x71,W
00208:  MOVWF  FE9
0020A:  MOVLW  01
0020C:  ADDWFC x72,W
0020E:  MOVWF  FEA
00210:  BTFSC  FEF.1
00212:  BRA    028C
....................       smData[ch].adcBusy = true;
00214:  MOVLB  1
00216:  MOVF   xE7,W
00218:  MULLW  09
0021A:  MOVF   FF3,W
0021C:  MOVLB  7
0021E:  CLRF   x72
00220:  MOVWF  x71
00222:  MOVLW  D4
00224:  ADDWF  x71,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC x72,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
00230:  MOVFF  1E7,771
00234:  MOVLB  0
00236:  BRA    01DA
....................       ch = !ch;
00238:  MOVLB  1
0023A:  MOVF   xE7,F
0023C:  BZ    0242
0023E:  MOVLW  00
00240:  BRA    0244
00242:  MOVLW  01
00244:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00246:  MOVF   xE7,F
00248:  BZ    024E
0024A:  MOVLW  00
0024C:  BRA    0250
0024E:  MOVLW  01
00250:  MULLW  09
00252:  MOVF   FF3,W
00254:  MOVLB  7
00256:  CLRF   x72
00258:  MOVWF  x71
0025A:  MOVLW  D4
0025C:  ADDWF  x71,W
0025E:  MOVWF  FE9
00260:  MOVLW  01
00262:  ADDWFC x72,W
00264:  MOVWF  FEA
00266:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00268:  MOVLB  1
0026A:  MOVF   xE7,F
0026C:  BZ    0272
0026E:  MOVLW  00
00270:  BRA    0274
00272:  MOVLW  01
00274:  MULLW  09
00276:  MOVF   FF3,W
00278:  MOVLB  7
0027A:  CLRF   x72
0027C:  MOVWF  x71
0027E:  MOVLW  D4
00280:  ADDWF  x71,W
00282:  MOVWF  FE9
00284:  MOVLW  01
00286:  ADDWFC x72,W
00288:  MOVWF  FEA
0028A:  BCF    FEF.1
....................    }
0028C:  MOVLB  0
0028E:  GOTO   0350 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
0177E:  MOVLB  7
01780:  CLRF   x17
01782:  CLRF   x16
01784:  CLRF   x15
01786:  CLRF   x14
01788:  CLRF   x1B
0178A:  CLRF   x1A
0178C:  CLRF   x19
0178E:  CLRF   x18
01790:  CLRF   x1F
01792:  CLRF   x1E
01794:  CLRF   x1D
01796:  CLRF   x1C
01798:  CLRF   x23
0179A:  CLRF   x22
0179C:  CLRF   x21
0179E:  CLRF   x20
017A0:  CLRF   x27
017A2:  CLRF   x26
017A4:  CLRF   x25
017A6:  CLRF   x24
017A8:  CLRF   x2B
017AA:  CLRF   x2A
017AC:  CLRF   x29
017AE:  CLRF   x28
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
017B0:  MOVF   x03,F
017B2:  BNZ   17D6
....................       sQ_ch = sQ_x;
017B4:  MOVLW  01
017B6:  MOVWF  x0D
017B8:  MOVLW  80
017BA:  MOVWF  x0C
....................       cQ_ch = cQ_x;
017BC:  MOVLW  01
017BE:  MOVWF  x0F
017C0:  MOVLW  94
017C2:  MOVWF  x0E
....................       sIn_ch = &sIn_x;
017C4:  MOVLW  01
017C6:  MOVWF  x11
017C8:  MOVLW  D0
017CA:  MOVWF  x10
....................       cIn_ch = &cIn_x;
017CC:  MOVLW  01
017CE:  MOVWF  x13
017D0:  MOVLW  D1
017D2:  MOVWF  x12
....................    }
017D4:  BRA    17FA
....................    else if (ch==1){
017D6:  DECFSZ x03,W
017D8:  BRA    17FA
....................       sQ_ch = sQ_y;
017DA:  MOVLW  01
017DC:  MOVWF  x0D
017DE:  MOVLW  A8
017E0:  MOVWF  x0C
....................       cQ_ch = cQ_y;
017E2:  MOVLW  01
017E4:  MOVWF  x0F
017E6:  MOVLW  BC
017E8:  MOVWF  x0E
....................       sIn_ch = &sIn_y;
017EA:  MOVLW  01
017EC:  MOVWF  x11
017EE:  MOVLW  D2
017F0:  MOVWF  x10
....................       cIn_ch = &cIn_y;
017F2:  MOVLW  01
017F4:  MOVWF  x13
017F6:  MOVLW  D3
017F8:  MOVWF  x12
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017FA:  MOVFF  70D,72E
017FE:  MOVFF  70C,72D
01802:  MOVFF  711,730
01806:  MOVFF  710,72F
0180A:  MOVFF  707,734
0180E:  MOVFF  706,733
01812:  MOVFF  705,732
01816:  MOVFF  704,731
0181A:  MOVLB  0
0181C:  CALL   090C
....................    push(cQ_ch, cIn_ch, cosCnts);
01820:  MOVFF  70F,72E
01824:  MOVFF  70E,72D
01828:  MOVFF  713,730
0182C:  MOVFF  712,72F
01830:  MOVFF  70B,734
01834:  MOVFF  70A,733
01838:  MOVFF  709,732
0183C:  MOVFF  708,731
01840:  CALL   090C
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01844:  MOVLB  7
01846:  MOVFF  70C,FE9
0184A:  MOVFF  70D,FEA
0184E:  MOVFF  FEF,71C
01852:  MOVFF  FEC,71D
01856:  MOVFF  FEC,71E
0185A:  MOVFF  FEC,71F
....................    sinMin=sQ_ch[0];
0185E:  MOVFF  70C,FE9
01862:  MOVFF  70D,FEA
01866:  MOVFF  FEF,720
0186A:  MOVFF  FEC,721
0186E:  MOVFF  FEC,722
01872:  MOVFF  FEC,723
....................    cosMax=cQ_ch[0];
01876:  MOVFF  70E,FE9
0187A:  MOVFF  70F,FEA
0187E:  MOVFF  FEF,724
01882:  MOVFF  FEC,725
01886:  MOVFF  FEC,726
0188A:  MOVFF  FEC,727
....................    cosMin=cQ_ch[0];
0188E:  MOVFF  70E,FE9
01892:  MOVFF  70F,FEA
01896:  MOVFF  FEF,728
0189A:  MOVFF  FEC,729
0189E:  MOVFF  FEC,72A
018A2:  MOVFF  FEC,72B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
018A6:  MOVLW  01
018A8:  MOVWF  x2C
018AA:  MOVF   x2C,W
018AC:  SUBLW  04
018AE:  BTFSS  FD8.0
018B0:  BRA    1BC0
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
018B2:  CLRF   x42
018B4:  MOVFF  72C,741
018B8:  CLRF   x44
018BA:  MOVLW  04
018BC:  MOVWF  x43
018BE:  MOVLB  0
018C0:  CALL   08BE
018C4:  MOVFF  02,03
018C8:  MOVF   01,W
018CA:  MOVLB  7
018CC:  ADDWF  x0C,W
018CE:  MOVWF  FE9
018D0:  MOVF   x0D,W
018D2:  ADDWFC 02,W
018D4:  MOVWF  FEA
018D6:  MOVFF  FEF,00
018DA:  MOVFF  FEC,01
018DE:  MOVFF  FEC,02
018E2:  MOVFF  FEC,03
018E6:  BTFSS  x1F.7
018E8:  BRA    18F0
018EA:  BTFSS  03.7
018EC:  BRA    1912
018EE:  BRA    18F4
018F0:  BTFSC  03.7
018F2:  BRA    1948
018F4:  MOVF   x1F,W
018F6:  SUBWF  03,W
018F8:  BNC   1948
018FA:  BNZ   1912
018FC:  MOVF   x1E,W
018FE:  SUBWF  02,W
01900:  BNC   1948
01902:  BNZ   1912
01904:  MOVF   x1D,W
01906:  SUBWF  01,W
01908:  BNC   1948
0190A:  BNZ   1912
0190C:  MOVF   00,W
0190E:  SUBWF  x1C,W
01910:  BC    1948
01912:  CLRF   x42
01914:  MOVFF  72C,741
01918:  CLRF   x44
0191A:  MOVLW  04
0191C:  MOVWF  x43
0191E:  MOVLB  0
01920:  CALL   08BE
01924:  MOVFF  02,03
01928:  MOVF   01,W
0192A:  MOVLB  7
0192C:  ADDWF  x0C,W
0192E:  MOVWF  FE9
01930:  MOVF   x0D,W
01932:  ADDWFC 02,W
01934:  MOVWF  FEA
01936:  MOVFF  FEF,71C
0193A:  MOVFF  FEC,71D
0193E:  MOVFF  FEC,71E
01942:  MOVFF  FEC,71F
01946:  MOVF   x1C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
01948:  CLRF   x42
0194A:  MOVFF  72C,741
0194E:  CLRF   x44
01950:  MOVLW  04
01952:  MOVWF  x43
01954:  MOVLB  0
01956:  CALL   08BE
0195A:  MOVFF  02,03
0195E:  MOVF   01,W
01960:  MOVLB  7
01962:  ADDWF  x0C,W
01964:  MOVWF  FE9
01966:  MOVF   x0D,W
01968:  ADDWFC 02,W
0196A:  MOVWF  FEA
0196C:  MOVFF  FEF,00
01970:  MOVFF  FEC,01
01974:  MOVFF  FEC,02
01978:  MOVFF  FEC,03
0197C:  BTFSS  03.7
0197E:  BRA    1986
01980:  BTFSS  x23.7
01982:  BRA    19A8
01984:  BRA    198A
01986:  BTFSC  x23.7
01988:  BRA    19EC
0198A:  MOVF   03,W
0198C:  SUBWF  x23,W
0198E:  BNC   19EC
01990:  BNZ   19A8
01992:  MOVF   02,W
01994:  SUBWF  x22,W
01996:  BNC   19EC
01998:  BNZ   19A8
0199A:  MOVF   01,W
0199C:  SUBWF  x21,W
0199E:  BNC   19EC
019A0:  BNZ   19A8
019A2:  MOVF   x20,W
019A4:  SUBWF  00,W
019A6:  BC    19EC
019A8:  CLRF   x42
019AA:  MOVFF  72C,741
019AE:  CLRF   x44
019B0:  MOVLW  04
019B2:  MOVWF  x43
019B4:  MOVLB  0
019B6:  CALL   08BE
019BA:  MOVFF  02,03
019BE:  MOVF   01,W
019C0:  MOVLB  7
019C2:  ADDWF  x0C,W
019C4:  MOVWF  FE9
019C6:  MOVF   x0D,W
019C8:  ADDWFC 02,W
019CA:  MOVWF  FEA
019CC:  MOVFF  FEF,720
019D0:  MOVFF  FEC,721
019D4:  MOVFF  FEC,722
019D8:  MOVFF  FEC,723
019DC:  MOVFF  720,00
019E0:  MOVFF  721,01
019E4:  MOVFF  722,02
019E8:  MOVFF  723,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019EC:  CLRF   x42
019EE:  MOVFF  72C,741
019F2:  CLRF   x44
019F4:  MOVLW  04
019F6:  MOVWF  x43
019F8:  MOVLB  0
019FA:  CALL   08BE
019FE:  MOVFF  02,03
01A02:  MOVF   01,W
01A04:  MOVLB  7
01A06:  ADDWF  x0E,W
01A08:  MOVWF  FE9
01A0A:  MOVF   x0F,W
01A0C:  ADDWFC 02,W
01A0E:  MOVWF  FEA
01A10:  MOVFF  FEF,00
01A14:  MOVFF  FEC,01
01A18:  MOVFF  FEC,02
01A1C:  MOVFF  FEC,03
01A20:  BTFSS  x27.7
01A22:  BRA    1A2A
01A24:  BTFSS  03.7
01A26:  BRA    1A4C
01A28:  BRA    1A2E
01A2A:  BTFSC  03.7
01A2C:  BRA    1A90
01A2E:  MOVF   x27,W
01A30:  SUBWF  03,W
01A32:  BNC   1A90
01A34:  BNZ   1A4C
01A36:  MOVF   x26,W
01A38:  SUBWF  02,W
01A3A:  BNC   1A90
01A3C:  BNZ   1A4C
01A3E:  MOVF   x25,W
01A40:  SUBWF  01,W
01A42:  BNC   1A90
01A44:  BNZ   1A4C
01A46:  MOVF   00,W
01A48:  SUBWF  x24,W
01A4A:  BC    1A90
01A4C:  CLRF   x42
01A4E:  MOVFF  72C,741
01A52:  CLRF   x44
01A54:  MOVLW  04
01A56:  MOVWF  x43
01A58:  MOVLB  0
01A5A:  CALL   08BE
01A5E:  MOVFF  02,03
01A62:  MOVF   01,W
01A64:  MOVLB  7
01A66:  ADDWF  x0E,W
01A68:  MOVWF  FE9
01A6A:  MOVF   x0F,W
01A6C:  ADDWFC 02,W
01A6E:  MOVWF  FEA
01A70:  MOVFF  FEF,724
01A74:  MOVFF  FEC,725
01A78:  MOVFF  FEC,726
01A7C:  MOVFF  FEC,727
01A80:  MOVFF  724,00
01A84:  MOVFF  725,01
01A88:  MOVFF  726,02
01A8C:  MOVFF  727,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A90:  CLRF   x42
01A92:  MOVFF  72C,741
01A96:  CLRF   x44
01A98:  MOVLW  04
01A9A:  MOVWF  x43
01A9C:  MOVLB  0
01A9E:  CALL   08BE
01AA2:  MOVFF  02,03
01AA6:  MOVF   01,W
01AA8:  MOVLB  7
01AAA:  ADDWF  x0E,W
01AAC:  MOVWF  FE9
01AAE:  MOVF   x0F,W
01AB0:  ADDWFC 02,W
01AB2:  MOVWF  FEA
01AB4:  MOVFF  FEF,00
01AB8:  MOVFF  FEC,01
01ABC:  MOVFF  FEC,02
01AC0:  MOVFF  FEC,03
01AC4:  BTFSS  03.7
01AC6:  BRA    1ACE
01AC8:  BTFSS  x2B.7
01ACA:  BRA    1AF0
01ACC:  BRA    1AD2
01ACE:  BTFSC  x2B.7
01AD0:  BRA    1B34
01AD2:  MOVF   03,W
01AD4:  SUBWF  x2B,W
01AD6:  BNC   1B34
01AD8:  BNZ   1AF0
01ADA:  MOVF   02,W
01ADC:  SUBWF  x2A,W
01ADE:  BNC   1B34
01AE0:  BNZ   1AF0
01AE2:  MOVF   01,W
01AE4:  SUBWF  x29,W
01AE6:  BNC   1B34
01AE8:  BNZ   1AF0
01AEA:  MOVF   x28,W
01AEC:  SUBWF  00,W
01AEE:  BC    1B34
01AF0:  CLRF   x42
01AF2:  MOVFF  72C,741
01AF6:  CLRF   x44
01AF8:  MOVLW  04
01AFA:  MOVWF  x43
01AFC:  MOVLB  0
01AFE:  CALL   08BE
01B02:  MOVFF  02,03
01B06:  MOVF   01,W
01B08:  MOVLB  7
01B0A:  ADDWF  x0E,W
01B0C:  MOVWF  FE9
01B0E:  MOVF   x0F,W
01B10:  ADDWFC 02,W
01B12:  MOVWF  FEA
01B14:  MOVFF  FEF,728
01B18:  MOVFF  FEC,729
01B1C:  MOVFF  FEC,72A
01B20:  MOVFF  FEC,72B
01B24:  MOVFF  728,00
01B28:  MOVFF  729,01
01B2C:  MOVFF  72A,02
01B30:  MOVFF  72B,03
....................       sumSin+=sQ_ch[i];
01B34:  CLRF   x42
01B36:  MOVFF  72C,741
01B3A:  CLRF   x44
01B3C:  MOVLW  04
01B3E:  MOVWF  x43
01B40:  MOVLB  0
01B42:  CALL   08BE
01B46:  MOVFF  02,03
01B4A:  MOVF   01,W
01B4C:  MOVLB  7
01B4E:  ADDWF  x0C,W
01B50:  MOVWF  FE9
01B52:  MOVF   x0D,W
01B54:  ADDWFC 02,W
01B56:  MOVWF  FEA
01B58:  MOVFF  FEF,00
01B5C:  MOVFF  FEC,01
01B60:  MOVFF  FEC,02
01B64:  MOVFF  FEC,03
01B68:  MOVF   00,W
01B6A:  ADDWF  x14,F
01B6C:  MOVF   01,W
01B6E:  ADDWFC x15,F
01B70:  MOVF   02,W
01B72:  ADDWFC x16,F
01B74:  MOVF   03,W
01B76:  ADDWFC x17,F
....................       sumCos+=cQ_ch[i];
01B78:  CLRF   x42
01B7A:  MOVFF  72C,741
01B7E:  CLRF   x44
01B80:  MOVLW  04
01B82:  MOVWF  x43
01B84:  MOVLB  0
01B86:  CALL   08BE
01B8A:  MOVFF  02,03
01B8E:  MOVF   01,W
01B90:  MOVLB  7
01B92:  ADDWF  x0E,W
01B94:  MOVWF  FE9
01B96:  MOVF   x0F,W
01B98:  ADDWFC 02,W
01B9A:  MOVWF  FEA
01B9C:  MOVFF  FEF,00
01BA0:  MOVFF  FEC,01
01BA4:  MOVFF  FEC,02
01BA8:  MOVFF  FEC,03
01BAC:  MOVF   00,W
01BAE:  ADDWF  x18,F
01BB0:  MOVF   01,W
01BB2:  ADDWFC x19,F
01BB4:  MOVF   02,W
01BB6:  ADDWFC x1A,F
01BB8:  MOVF   03,W
01BBA:  ADDWFC x1B,F
01BBC:  INCF   x2C,F
01BBE:  BRA    18AA
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01BC0:  MOVF   x20,W
01BC2:  ADDWF  x1C,W
01BC4:  MOVWF  00
01BC6:  MOVF   x21,W
01BC8:  ADDWFC x1D,W
01BCA:  MOVWF  01
01BCC:  MOVF   x22,W
01BCE:  ADDWFC x1E,W
01BD0:  MOVWF  02
01BD2:  MOVF   x23,W
01BD4:  ADDWFC x1F,W
01BD6:  MOVWF  03
01BD8:  MOVF   00,W
01BDA:  SUBWF  x14,F
01BDC:  MOVF   01,W
01BDE:  SUBWFB x15,F
01BE0:  MOVF   02,W
01BE2:  SUBWFB x16,F
01BE4:  MOVF   03,W
01BE6:  SUBWFB x17,F
....................    sumCos-=(cosMax+cosMin);
01BE8:  MOVF   x28,W
01BEA:  ADDWF  x24,W
01BEC:  MOVWF  00
01BEE:  MOVF   x29,W
01BF0:  ADDWFC x25,W
01BF2:  MOVWF  01
01BF4:  MOVF   x2A,W
01BF6:  ADDWFC x26,W
01BF8:  MOVWF  02
01BFA:  MOVF   x2B,W
01BFC:  ADDWFC x27,W
01BFE:  MOVWF  03
01C00:  MOVF   00,W
01C02:  SUBWF  x18,F
01C04:  MOVF   01,W
01C06:  SUBWFB x19,F
01C08:  MOVF   02,W
01C0A:  SUBWFB x1A,F
01C0C:  MOVF   03,W
01C0E:  SUBWFB x1B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01C10:  MOVF   x03,W
01C12:  MULLW  09
01C14:  MOVF   FF3,W
01C16:  CLRF   x2E
01C18:  MOVWF  x2D
01C1A:  MOVLW  01
01C1C:  ADDWF  x2D,W
01C1E:  MOVWF  01
01C20:  MOVLW  00
01C22:  ADDWFC x2E,W
01C24:  MOVWF  03
01C26:  MOVF   01,W
01C28:  ADDLW  D4
01C2A:  MOVWF  FE9
01C2C:  MOVLW  01
01C2E:  ADDWFC 03,W
01C30:  MOVWF  FEA
01C32:  MOVFF  FEA,730
01C36:  MOVFF  FE9,72F
01C3A:  BCF    FD8.1
01C3C:  MOVFF  717,734
01C40:  MOVFF  716,733
01C44:  MOVFF  715,732
01C48:  MOVFF  714,731
01C4C:  CLRF   x38
01C4E:  CLRF   x37
01C50:  CLRF   x36
01C52:  MOVLW  03
01C54:  MOVWF  x35
01C56:  MOVLB  0
01C58:  RCALL  1694
01C5A:  MOVFF  730,FEA
01C5E:  MOVFF  72F,FE9
01C62:  MOVFF  00,FEF
01C66:  MOVFF  01,FEC
01C6A:  MOVFF  02,FEC
01C6E:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C72:  MOVLB  7
01C74:  MOVF   x03,W
01C76:  MULLW  09
01C78:  MOVF   FF3,W
01C7A:  CLRF   x2E
01C7C:  MOVWF  x2D
01C7E:  MOVLW  05
01C80:  ADDWF  x2D,W
01C82:  MOVWF  01
01C84:  MOVLW  00
01C86:  ADDWFC x2E,W
01C88:  MOVWF  03
01C8A:  MOVF   01,W
01C8C:  ADDLW  D4
01C8E:  MOVWF  FE9
01C90:  MOVLW  01
01C92:  ADDWFC 03,W
01C94:  MOVWF  FEA
01C96:  MOVFF  FEA,730
01C9A:  MOVFF  FE9,72F
01C9E:  BCF    FD8.1
01CA0:  MOVFF  71B,734
01CA4:  MOVFF  71A,733
01CA8:  MOVFF  719,732
01CAC:  MOVFF  718,731
01CB0:  CLRF   x38
01CB2:  CLRF   x37
01CB4:  CLRF   x36
01CB6:  MOVLW  03
01CB8:  MOVWF  x35
01CBA:  MOVLB  0
01CBC:  RCALL  1694
01CBE:  MOVFF  730,FEA
01CC2:  MOVFF  72F,FE9
01CC6:  MOVFF  00,FEF
01CCA:  MOVFF  01,FEC
01CCE:  MOVFF  02,FEC
01CD2:  MOVFF  03,FEC
01CD6:  GOTO   454A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04466:  MOVLB  6
04468:  CLRF   xFE
0446A:  CLRF   xFD
0446C:  CLRF   xFC
0446E:  CLRF   xFB
04470:  MOVLB  7
04472:  CLRF   x02
04474:  CLRF   x01
04476:  CLRF   x00
04478:  MOVLB  6
0447A:  CLRF   xFF
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
0447C:  MOVLB  1
0447E:  MOVF   xE8,W
04480:  MULLW  09
04482:  MOVF   FF3,W
04484:  MOVLB  7
04486:  CLRF   x04
04488:  MOVWF  x03
0448A:  MOVLW  D4
0448C:  ADDWF  x03,W
0448E:  MOVWF  FE9
04490:  MOVLW  01
04492:  ADDWFC x04,W
04494:  MOVWF  FEA
04496:  BTFSC  FEF.1
04498:  BRA    4616
0449A:  MOVLB  1
0449C:  MOVF   xE8,W
0449E:  MULLW  09
044A0:  MOVF   FF3,W
044A2:  MOVLB  7
044A4:  CLRF   x06
044A6:  MOVWF  x05
044A8:  MOVLW  D4
044AA:  ADDWF  x05,W
044AC:  MOVWF  FE9
044AE:  MOVLW  01
044B0:  ADDWFC x06,W
044B2:  MOVWF  FEA
044B4:  BTFSS  FEF.0
044B6:  BRA    4616
....................       smData[ch].adcBusy = true;
044B8:  MOVLB  1
044BA:  MOVF   xE8,W
044BC:  MULLW  09
044BE:  MOVF   FF3,W
044C0:  MOVLB  7
044C2:  CLRF   x04
044C4:  MOVWF  x03
044C6:  MOVLW  D4
044C8:  ADDWF  x03,W
044CA:  MOVWF  FE9
044CC:  MOVLW  01
044CE:  ADDWFC x04,W
044D0:  MOVWF  FEA
044D2:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
044D4:  BCF    FD8.0
044D6:  MOVLB  1
044D8:  RLCF   xE8,W
044DA:  MOVLB  7
044DC:  MOVWF  x03
044DE:  MOVWF  x04
044E0:  MOVLB  0
044E2:  CALL   0864
044E6:  MOVFF  03,6FE
044EA:  MOVFF  02,6FD
044EE:  MOVFF  01,6FC
044F2:  MOVFF  00,6FB
....................       cosNew = ads_read_data(ch*2+1);      
044F6:  BCF    FD8.0
044F8:  MOVLB  1
044FA:  RLCF   xE8,W
044FC:  ADDLW  01
044FE:  MOVLB  7
04500:  MOVWF  x03
04502:  MOVWF  x04
04504:  MOVLB  0
04506:  CALL   0864
0450A:  MOVFF  03,702
0450E:  MOVFF  02,701
04512:  MOVFF  01,700
04516:  MOVFF  00,6FF
....................       
....................       if (adcFilter){
0451A:  MOVLB  1
0451C:  BTFSS  x63.0
0451E:  BRA    454E
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04520:  MOVFF  1E8,703
04524:  MOVFF  6FE,707
04528:  MOVFF  6FD,706
0452C:  MOVFF  6FC,705
04530:  MOVFF  6FB,704
04534:  MOVFF  702,70B
04538:  MOVFF  701,70A
0453C:  MOVFF  700,709
04540:  MOVFF  6FF,708
04544:  MOVLB  0
04546:  GOTO   177E
....................       }
0454A:  BRA    45BA
0454C:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
0454E:  MOVF   xE8,W
04550:  MULLW  09
04552:  MOVF   FF3,W
04554:  MOVLB  7
04556:  CLRF   x04
04558:  MOVWF  x03
0455A:  MOVLW  01
0455C:  ADDWF  x03,W
0455E:  MOVWF  01
04560:  MOVLW  00
04562:  ADDWFC x04,W
04564:  MOVWF  03
04566:  MOVF   01,W
04568:  ADDLW  D4
0456A:  MOVWF  FE9
0456C:  MOVLW  01
0456E:  ADDWFC 03,W
04570:  MOVWF  FEA
04572:  MOVFF  6FB,FEF
04576:  MOVFF  6FC,FEC
0457A:  MOVFF  6FD,FEC
0457E:  MOVFF  6FE,FEC
....................          smData[ch].avgCos = cosNew;
04582:  MOVLB  1
04584:  MOVF   xE8,W
04586:  MULLW  09
04588:  MOVF   FF3,W
0458A:  MOVLB  7
0458C:  CLRF   x04
0458E:  MOVWF  x03
04590:  MOVLW  05
04592:  ADDWF  x03,W
04594:  MOVWF  01
04596:  MOVLW  00
04598:  ADDWFC x04,W
0459A:  MOVWF  03
0459C:  MOVF   01,W
0459E:  ADDLW  D4
045A0:  MOVWF  FE9
045A2:  MOVLW  01
045A4:  ADDWFC 03,W
045A6:  MOVWF  FEA
045A8:  MOVFF  6FF,FEF
045AC:  MOVFF  700,FEC
045B0:  MOVFF  701,FEC
045B4:  MOVFF  702,FEC
045B8:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045BA:  MOVFF  1E8,703
045BE:  GOTO   3714
....................       ch = !ch;
045C2:  MOVLB  1
045C4:  MOVF   xE8,F
045C6:  BZ    45CC
045C8:  MOVLW  00
045CA:  BRA    45CE
045CC:  MOVLW  01
045CE:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
045D0:  MOVF   xE8,F
045D2:  BZ    45D8
045D4:  MOVLW  00
045D6:  BRA    45DA
045D8:  MOVLW  01
045DA:  MULLW  09
045DC:  MOVF   FF3,W
045DE:  MOVLB  7
045E0:  CLRF   x04
045E2:  MOVWF  x03
045E4:  MOVLW  D4
045E6:  ADDWF  x03,W
045E8:  MOVWF  FE9
045EA:  MOVLW  01
045EC:  ADDWFC x04,W
045EE:  MOVWF  FEA
045F0:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045F2:  MOVLB  1
045F4:  MOVF   xE8,F
045F6:  BZ    45FC
045F8:  MOVLW  00
045FA:  BRA    45FE
045FC:  MOVLW  01
045FE:  MULLW  09
04600:  MOVF   FF3,W
04602:  MOVLB  7
04604:  CLRF   x04
04606:  MOVWF  x03
04608:  MOVLW  D4
0460A:  ADDWF  x03,W
0460C:  MOVWF  FE9
0460E:  MOVLW  01
04610:  ADDWFC x04,W
04612:  MOVWF  FEA
04614:  BCF    FEF.1
....................    }
04616:  MOVLB  0
04618:  GOTO   A746 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00972:  MOVLB  6
00974:  CLRF   xFB
00976:  CLRF   xFC
00978:  CLRF   xFD
0097A:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
0097C:  CLRF   xFF
0097E:  MOVF   xFF,W
00980:  SUBLW  03
00982:  BNC   09B8
....................       rc0=reg0config;
00984:  MOVLW  30
00986:  MOVWF  xFB
....................       rc1=reg1config;
00988:  MOVLW  10
0098A:  MOVWF  xFC
....................       rc2=reg2config;
0098C:  CLRF   xFD
....................       rc3=reg3config;
0098E:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00990:  MOVFF  6FF,701
00994:  MOVFF  6FB,702
00998:  MOVFF  6FC,703
0099C:  MOVFF  6FD,704
009A0:  MOVFF  6FE,705
009A4:  MOVLB  0
009A6:  BRA    0796
....................       delay_ms(100);
009A8:  MOVLW  64
009AA:  MOVLB  7
009AC:  MOVWF  x01
009AE:  MOVLB  0
009B0:  RCALL  03D2
009B2:  MOVLB  6
009B4:  INCF   xFF,F
009B6:  BRA    097E
....................    }
....................    
....................    if (adcFilter){
009B8:  MOVLB  1
009BA:  BTFSS  x63.0
009BC:  BRA    0ADE
....................       for (int i = 0; i < BUFFER_SIZE; i++){
009BE:  MOVLB  7
009C0:  CLRF   x00
009C2:  MOVF   x00,W
009C4:  SUBLW  04
009C6:  BTFSS  FD8.0
009C8:  BRA    0ADC
....................          ads_start_conv_all();
009CA:  MOVLB  0
009CC:  BRA    0834
....................          delay_ms(50);
009CE:  MOVLW  32
009D0:  MOVLB  7
009D2:  MOVWF  x01
009D4:  MOVLB  0
009D6:  RCALL  03D2
....................          push(sQ_x, &sIn_x, ads_read_data(0));
009D8:  MOVLB  7
009DA:  CLRF   x04
009DC:  MOVLB  0
009DE:  RCALL  0864
009E0:  MOVFF  03,704
009E4:  MOVFF  02,703
009E8:  MOVFF  01,702
009EC:  MOVFF  00,701
009F0:  MOVLW  01
009F2:  MOVLB  7
009F4:  MOVWF  x2E
009F6:  MOVLW  80
009F8:  MOVWF  x2D
009FA:  MOVLW  01
009FC:  MOVWF  x30
009FE:  MOVLW  D0
00A00:  MOVWF  x2F
00A02:  MOVFF  03,734
00A06:  MOVFF  02,733
00A0A:  MOVFF  01,732
00A0E:  MOVFF  00,731
00A12:  MOVLB  0
00A14:  RCALL  090C
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
00A16:  MOVLW  01
00A18:  MOVLB  7
00A1A:  MOVWF  x04
00A1C:  MOVLB  0
00A1E:  RCALL  0864
00A20:  MOVFF  03,704
00A24:  MOVFF  02,703
00A28:  MOVFF  01,702
00A2C:  MOVFF  00,701
00A30:  MOVLW  01
00A32:  MOVLB  7
00A34:  MOVWF  x2E
00A36:  MOVLW  94
00A38:  MOVWF  x2D
00A3A:  MOVLW  01
00A3C:  MOVWF  x30
00A3E:  MOVLW  D1
00A40:  MOVWF  x2F
00A42:  MOVFF  03,734
00A46:  MOVFF  02,733
00A4A:  MOVFF  01,732
00A4E:  MOVFF  00,731
00A52:  MOVLB  0
00A54:  RCALL  090C
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A56:  MOVLW  02
00A58:  MOVLB  7
00A5A:  MOVWF  x04
00A5C:  MOVLB  0
00A5E:  RCALL  0864
00A60:  MOVFF  03,704
00A64:  MOVFF  02,703
00A68:  MOVFF  01,702
00A6C:  MOVFF  00,701
00A70:  MOVLW  01
00A72:  MOVLB  7
00A74:  MOVWF  x2E
00A76:  MOVLW  A8
00A78:  MOVWF  x2D
00A7A:  MOVLW  01
00A7C:  MOVWF  x30
00A7E:  MOVLW  D2
00A80:  MOVWF  x2F
00A82:  MOVFF  03,734
00A86:  MOVFF  02,733
00A8A:  MOVFF  01,732
00A8E:  MOVFF  00,731
00A92:  MOVLB  0
00A94:  RCALL  090C
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A96:  MOVLW  03
00A98:  MOVLB  7
00A9A:  MOVWF  x04
00A9C:  MOVLB  0
00A9E:  RCALL  0864
00AA0:  MOVFF  03,704
00AA4:  MOVFF  02,703
00AA8:  MOVFF  01,702
00AAC:  MOVFF  00,701
00AB0:  MOVLW  01
00AB2:  MOVLB  7
00AB4:  MOVWF  x2E
00AB6:  MOVLW  BC
00AB8:  MOVWF  x2D
00ABA:  MOVLW  01
00ABC:  MOVWF  x30
00ABE:  MOVLW  D3
00AC0:  MOVWF  x2F
00AC2:  MOVFF  03,734
00AC6:  MOVFF  02,733
00ACA:  MOVFF  01,732
00ACE:  MOVFF  00,731
00AD2:  MOVLB  0
00AD4:  RCALL  090C
00AD6:  MOVLB  7
00AD8:  INCF   x00,F
00ADA:  BRA    09C2
00ADC:  MOVLB  1
....................       }
....................    }
00ADE:  MOVLB  0
00AE0:  GOTO   0B44 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00AE4:  MOVLW  00
00AE6:  MOVLB  F
00AE8:  MOVWF  x53
00AEA:  MOVLW  40
00AEC:  MOVWF  x0C
00AEE:  MOVLW  00
00AF0:  MOVWF  x14
00AF2:  MOVLW  03
00AF4:  MOVWF  x1C
00AF6:  MOVLW  0F
00AF8:  MOVWF  x21
00AFA:  MOVLW  00
00AFC:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AFE:  MOVLW  08
00B00:  MOVWF  x55
00B02:  CLRF   x56
00B04:  CLRF   x52
00B06:  SETF   x57
00B08:  CLRF   F61
00B0A:  MOVLW  94
00B0C:  MOVWF  x5B
....................    output_high(EN_EXC);
00B0E:  MOVLW  E8
00B10:  MOVWF  F8B
00B12:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B14:  MOVF   x5A,W
00B16:  ANDLW  3F
00B18:  MOVWF  01
00B1A:  MOVLW  06
00B1C:  MOVWF  x5A
00B1E:  BTFSS  x5B.7
00B20:  BRA    0B30
00B22:  MOVF   01,W
00B24:  SUBLW  06
00B26:  BZ    0B30
00B28:  BSF    x5B.0
00B2A:  NOP   
00B2C:  BTFSC  x5B.0
00B2E:  BRA    0B2C
....................    delay_ms(10);
00B30:  MOVLW  0A
00B32:  MOVLB  7
00B34:  MOVWF  x01
00B36:  MOVLB  0
00B38:  RCALL  03D2
....................    read_adc(ADC_START_ONLY);
00B3A:  MOVLB  F
00B3C:  BSF    x5B.0
00B3E:  NOP   
....................    setup_external_ADCs();
00B40:  MOVLB  0
00B42:  BRA    0972
....................    intTimeoutReg = sensorSampleRate;
00B44:  MOVLB  1
00B46:  CLRF   x7F
00B48:  MOVLW  32
00B4A:  MOVWF  x7E
00B4C:  MOVLB  0
00B4E:  GOTO   A728 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046E4:  MOVLB  7
046E6:  MOVF   x01,W
046E8:  MULLW  28
046EA:  MOVF   FF3,W
046EC:  CLRF   x0F
046EE:  MOVWF  x0E
046F0:  MOVLW  0C
046F2:  ADDWF  x0E,W
046F4:  MOVWF  01
046F6:  MOVLW  00
046F8:  ADDWFC x0F,W
046FA:  MOVWF  03
046FC:  MOVF   01,W
046FE:  ADDLW  20
04700:  MOVWF  FE9
04702:  MOVLW  00
04704:  ADDWFC 03,W
04706:  MOVWF  FEA
04708:  MOVFF  FEF,74A
0470C:  MOVFF  FEC,74B
04710:  MOVFF  FEC,74C
04714:  MOVFF  FEC,74D
04718:  MOVF   x01,W
0471A:  MULLW  28
0471C:  MOVF   FF3,W
0471E:  CLRF   x13
04720:  MOVWF  x12
04722:  MOVLW  10
04724:  ADDWF  x12,W
04726:  MOVWF  01
04728:  MOVLW  00
0472A:  ADDWFC x13,W
0472C:  MOVWF  03
0472E:  MOVF   01,W
04730:  ADDLW  20
04732:  MOVWF  FE9
04734:  MOVLW  00
04736:  ADDWFC 03,W
04738:  MOVWF  FEA
0473A:  MOVFF  FEF,74E
0473E:  MOVFF  FEC,01
04742:  MOVFF  FEC,02
04746:  MOVFF  FEC,03
0474A:  MOVFF  FEA,713
0474E:  MOVFF  FE9,712
04752:  BSF    FD8.1
04754:  MOVFF  03,751
04758:  MOVFF  02,750
0475C:  MOVFF  01,74F
04760:  MOVLB  0
04762:  CALL   0E9E
04766:  MOVFF  713,FEA
0476A:  MOVFF  712,FE9
0476E:  MOVFF  03,705
04772:  MOVFF  02,704
04776:  MOVFF  01,703
0477A:  MOVFF  00,702
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
0477E:  MOVLB  7
04780:  MOVF   x01,W
04782:  MULLW  28
04784:  MOVF   FF3,W
04786:  CLRF   x0F
04788:  MOVWF  x0E
0478A:  MOVLW  1C
0478C:  ADDWF  x0E,W
0478E:  MOVWF  01
04790:  MOVLW  00
04792:  ADDWFC x0F,W
04794:  MOVWF  03
04796:  MOVF   01,W
04798:  ADDLW  20
0479A:  MOVWF  01
0479C:  MOVLW  00
0479E:  ADDWFC 03,F
047A0:  MOVFF  01,70E
047A4:  MOVFF  03,70F
047A8:  MOVFF  03,FEA
047AC:  MOVFF  01,FE9
047B0:  MOVFF  FEF,710
047B4:  MOVFF  FEC,711
047B8:  MOVFF  FEC,712
047BC:  MOVFF  FEC,713
047C0:  MOVF   x01,W
047C2:  MULLW  28
047C4:  MOVF   FF3,W
047C6:  CLRF   x15
047C8:  MOVWF  x14
047CA:  MOVLW  04
047CC:  ADDWF  x14,W
047CE:  MOVWF  01
047D0:  MOVLW  00
047D2:  ADDWFC x15,W
047D4:  MOVWF  03
047D6:  MOVF   01,W
047D8:  ADDLW  20
047DA:  MOVWF  FE9
047DC:  MOVLW  00
047DE:  ADDWFC 03,W
047E0:  MOVWF  FEA
047E2:  MOVFF  FEF,754
047E6:  MOVFF  FEC,01
047EA:  MOVFF  FEC,02
047EE:  MOVFF  FEC,03
047F2:  MOVFF  705,753
047F6:  MOVFF  704,752
047FA:  MOVFF  703,751
047FE:  MOVFF  702,750
04802:  MOVFF  03,757
04806:  MOVFF  02,756
0480A:  MOVFF  01,755
0480E:  MOVLB  0
04810:  CALL   0DA8
04814:  BCF    FD8.1
04816:  MOVFF  713,74D
0481A:  MOVFF  712,74C
0481E:  MOVFF  711,74B
04822:  MOVFF  710,74A
04826:  MOVFF  03,751
0482A:  MOVFF  02,750
0482E:  MOVFF  01,74F
04832:  MOVFF  00,74E
04836:  CALL   0E9E
0483A:  MOVFF  70F,FEA
0483E:  MOVFF  70E,FE9
04842:  MOVFF  00,FEF
04846:  MOVFF  01,FEC
0484A:  MOVFF  02,FEC
0484E:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
04852:  MOVLB  7
04854:  MOVF   x01,W
04856:  MULLW  28
04858:  MOVF   FF3,W
0485A:  CLRF   x0F
0485C:  MOVWF  x0E
0485E:  MOVLW  1C
04860:  ADDWF  x0E,W
04862:  MOVWF  01
04864:  MOVLW  00
04866:  ADDWFC x0F,W
04868:  MOVWF  03
0486A:  MOVF   01,W
0486C:  ADDLW  20
0486E:  MOVWF  FE9
04870:  MOVLW  00
04872:  ADDWFC 03,W
04874:  MOVWF  FEA
04876:  MOVFF  FEF,74A
0487A:  MOVFF  FEC,70F
0487E:  MOVFF  FEC,74C
04882:  MOVFF  FEC,74D
04886:  CLRF   x49
04888:  CLRF   x48
0488A:  MOVLW  7C
0488C:  MOVWF  x47
0488E:  MOVLW  84
04890:  MOVWF  x46
04892:  MOVFF  70F,74B
04896:  MOVLB  0
04898:  CALL   1D34
0489C:  BNC   48D0
0489E:  MOVLB  7
048A0:  MOVF   x01,W
048A2:  MULLW  28
048A4:  MOVF   FF3,W
048A6:  CLRF   x0F
048A8:  MOVWF  x0E
048AA:  MOVLW  1C
048AC:  ADDWF  x0E,W
048AE:  MOVWF  01
048B0:  MOVLW  00
048B2:  ADDWFC x0F,W
048B4:  MOVWF  03
048B6:  MOVF   01,W
048B8:  ADDLW  20
048BA:  MOVWF  FE9
048BC:  MOVLW  00
048BE:  ADDWFC 03,W
048C0:  MOVWF  FEA
048C2:  MOVLW  84
048C4:  MOVWF  FEF
048C6:  MOVLW  7C
048C8:  MOVWF  FEC
048CA:  CLRF   FEC
048CC:  CLRF   FEC
048CE:  BRA    494C
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
048D0:  MOVLB  7
048D2:  MOVF   x01,W
048D4:  MULLW  28
048D6:  MOVF   FF3,W
048D8:  CLRF   x0F
048DA:  MOVWF  x0E
048DC:  MOVLW  1C
048DE:  ADDWF  x0E,W
048E0:  MOVWF  01
048E2:  MOVLW  00
048E4:  ADDWFC x0F,W
048E6:  MOVWF  03
048E8:  MOVF   01,W
048EA:  ADDLW  20
048EC:  MOVWF  FE9
048EE:  MOVLW  00
048F0:  ADDWFC 03,W
048F2:  MOVWF  FEA
048F4:  MOVFF  FEF,746
048F8:  MOVFF  FEC,70F
048FC:  MOVFF  FEC,748
04900:  MOVFF  FEC,749
04904:  MOVFF  70F,747
04908:  CLRF   x4D
0490A:  CLRF   x4C
0490C:  MOVLW  C0
0490E:  MOVWF  x4B
04910:  MOVLW  82
04912:  MOVWF  x4A
04914:  MOVLB  0
04916:  CALL   1D34
0491A:  BNC   494E
0491C:  MOVLB  7
0491E:  MOVF   x01,W
04920:  MULLW  28
04922:  MOVF   FF3,W
04924:  CLRF   x0F
04926:  MOVWF  x0E
04928:  MOVLW  1C
0492A:  ADDWF  x0E,W
0492C:  MOVWF  01
0492E:  MOVLW  00
04930:  ADDWFC x0F,W
04932:  MOVWF  03
04934:  MOVF   01,W
04936:  ADDLW  20
04938:  MOVWF  FE9
0493A:  MOVLW  00
0493C:  ADDWFC 03,W
0493E:  MOVWF  FEA
04940:  MOVLW  82
04942:  MOVWF  FEF
04944:  MOVLW  C0
04946:  MOVWF  FEC
04948:  CLRF   FEC
0494A:  CLRF   FEC
0494C:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
0494E:  MOVLB  7
04950:  MOVF   x01,W
04952:  MULLW  28
04954:  MOVF   FF3,W
04956:  CLRF   x0F
04958:  MOVWF  x0E
0495A:  MOVLW  20
0495C:  ADDWF  x0E,W
0495E:  MOVWF  FE9
04960:  MOVLW  00
04962:  ADDWFC x0F,W
04964:  MOVWF  FEA
04966:  MOVFF  FEF,754
0496A:  MOVFF  FEC,01
0496E:  MOVFF  FEC,02
04972:  MOVFF  FEC,03
04976:  MOVFF  705,753
0497A:  MOVFF  704,752
0497E:  MOVFF  703,751
04982:  MOVFF  702,750
04986:  MOVFF  03,757
0498A:  MOVFF  02,756
0498E:  MOVFF  01,755
04992:  MOVLB  0
04994:  CALL   0DA8
04998:  MOVFF  03,709
0499C:  MOVFF  02,708
049A0:  MOVFF  01,707
049A4:  MOVFF  00,706
049A8:  MOVLB  7
049AA:  MOVF   x01,W
049AC:  MULLW  28
049AE:  MOVF   FF3,W
049B0:  CLRF   x11
049B2:  MOVWF  x10
049B4:  MOVLW  08
049B6:  ADDWF  x10,W
049B8:  MOVWF  01
049BA:  MOVLW  00
049BC:  ADDWFC x11,W
049BE:  MOVWF  03
049C0:  MOVF   01,W
049C2:  ADDLW  20
049C4:  MOVWF  FE9
049C6:  MOVLW  00
049C8:  ADDWFC 03,W
049CA:  MOVWF  FEA
049CC:  MOVFF  FEF,710
049D0:  MOVFF  FEC,711
049D4:  MOVFF  FEC,712
049D8:  MOVFF  FEC,713
049DC:  MOVF   x01,W
049DE:  MULLW  28
049E0:  MOVF   FF3,W
049E2:  CLRF   x15
049E4:  MOVWF  x14
049E6:  MOVLW  10
049E8:  ADDWF  x14,W
049EA:  MOVWF  01
049EC:  MOVLW  00
049EE:  ADDWFC x15,W
049F0:  MOVWF  03
049F2:  MOVF   01,W
049F4:  ADDLW  20
049F6:  MOVWF  FE9
049F8:  MOVLW  00
049FA:  ADDWFC 03,W
049FC:  MOVWF  FEA
049FE:  MOVFF  FEF,74A
04A02:  MOVFF  FEC,74B
04A06:  MOVFF  FEC,74C
04A0A:  MOVFF  FEC,74D
04A0E:  MOVF   x01,W
04A10:  MULLW  28
04A12:  MOVF   FF3,W
04A14:  CLRF   x19
04A16:  MOVWF  x18
04A18:  MOVLW  14
04A1A:  ADDWF  x18,W
04A1C:  MOVWF  01
04A1E:  MOVLW  00
04A20:  ADDWFC x19,W
04A22:  MOVWF  03
04A24:  MOVF   01,W
04A26:  ADDLW  20
04A28:  MOVWF  FE9
04A2A:  MOVLW  00
04A2C:  ADDWFC 03,W
04A2E:  MOVWF  FEA
04A30:  MOVFF  FEF,74E
04A34:  MOVFF  FEC,01
04A38:  MOVFF  FEC,02
04A3C:  MOVFF  FEC,03
04A40:  MOVFF  FEA,719
04A44:  MOVFF  FE9,718
04A48:  BSF    FD8.1
04A4A:  MOVFF  03,751
04A4E:  MOVFF  02,750
04A52:  MOVFF  01,74F
04A56:  MOVLB  0
04A58:  CALL   0E9E
04A5C:  MOVFF  719,FEA
04A60:  MOVFF  718,FE9
04A64:  MOVFF  713,753
04A68:  MOVFF  712,752
04A6C:  MOVFF  711,751
04A70:  MOVFF  710,750
04A74:  MOVFF  03,757
04A78:  MOVFF  02,756
04A7C:  MOVFF  01,755
04A80:  MOVFF  00,754
04A84:  CALL   0DA8
04A88:  MOVFF  03,70D
04A8C:  MOVFF  02,70C
04A90:  MOVFF  01,70B
04A94:  MOVFF  00,70A
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A98:  MOVLB  7
04A9A:  MOVF   x01,W
04A9C:  MULLW  28
04A9E:  MOVF   FF3,W
04AA0:  CLRF   x0F
04AA2:  MOVWF  x0E
04AA4:  MOVLW  18
04AA6:  ADDWF  x0E,W
04AA8:  MOVWF  01
04AAA:  MOVLW  00
04AAC:  ADDWFC x0F,W
04AAE:  MOVWF  03
04AB0:  MOVF   01,W
04AB2:  ADDLW  20
04AB4:  MOVWF  01
04AB6:  MOVLW  00
04AB8:  ADDWFC 03,F
04ABA:  MOVFF  01,70E
04ABE:  MOVFF  03,70F
04AC2:  MOVF   x01,W
04AC4:  MULLW  28
04AC6:  MOVF   FF3,W
04AC8:  CLRF   x11
04ACA:  MOVWF  x10
04ACC:  MOVLW  1C
04ACE:  ADDWF  x10,W
04AD0:  MOVWF  01
04AD2:  MOVLW  00
04AD4:  ADDWFC x11,W
04AD6:  MOVWF  03
04AD8:  MOVF   01,W
04ADA:  ADDLW  20
04ADC:  MOVWF  FE9
04ADE:  MOVLW  00
04AE0:  ADDWFC 03,W
04AE2:  MOVWF  FEA
04AE4:  MOVFF  FEF,74E
04AE8:  MOVFF  FEC,01
04AEC:  MOVFF  FEC,02
04AF0:  MOVFF  FEC,03
04AF4:  MOVFF  FEA,711
04AF8:  MOVFF  FE9,710
04AFC:  BCF    FD8.1
04AFE:  MOVFF  709,74D
04B02:  MOVFF  708,74C
04B06:  MOVFF  707,74B
04B0A:  MOVFF  706,74A
04B0E:  MOVFF  03,751
04B12:  MOVFF  02,750
04B16:  MOVFF  01,74F
04B1A:  MOVLB  0
04B1C:  CALL   0E9E
04B20:  MOVFF  711,FEA
04B24:  MOVFF  710,FE9
04B28:  MOVFF  03,715
04B2C:  MOVFF  02,714
04B30:  MOVFF  01,713
04B34:  MOVFF  00,712
04B38:  BCF    FD8.1
04B3A:  MOVFF  03,74D
04B3E:  MOVFF  02,74C
04B42:  MOVFF  01,74B
04B46:  MOVFF  00,74A
04B4A:  MOVFF  70D,751
04B4E:  MOVFF  70C,750
04B52:  MOVFF  70B,74F
04B56:  MOVFF  70A,74E
04B5A:  CALL   0E9E
04B5E:  MOVFF  70F,FEA
04B62:  MOVFF  70E,FE9
04B66:  MOVFF  00,FEF
04B6A:  MOVFF  01,FEC
04B6E:  MOVFF  02,FEC
04B72:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B76:  MOVLB  7
04B78:  MOVF   x01,W
04B7A:  MULLW  28
04B7C:  MOVF   FF3,W
04B7E:  CLRF   x0F
04B80:  MOVWF  x0E
04B82:  MOVLW  18
04B84:  ADDWF  x0E,W
04B86:  MOVWF  01
04B88:  MOVLW  00
04B8A:  ADDWFC x0F,W
04B8C:  MOVWF  03
04B8E:  MOVF   01,W
04B90:  ADDLW  20
04B92:  MOVWF  FE9
04B94:  MOVLW  00
04B96:  ADDWFC 03,W
04B98:  MOVWF  FEA
04B9A:  MOVFF  FEF,74A
04B9E:  MOVFF  FEC,70F
04BA2:  MOVFF  FEC,74C
04BA6:  MOVFF  FEC,74D
04BAA:  CLRF   x49
04BAC:  CLRF   x48
04BAE:  MOVLW  7C
04BB0:  MOVWF  x47
04BB2:  MOVLW  84
04BB4:  MOVWF  x46
04BB6:  MOVFF  70F,74B
04BBA:  MOVLB  0
04BBC:  CALL   1D34
04BC0:  BNC   4BF4
04BC2:  MOVLB  7
04BC4:  MOVF   x01,W
04BC6:  MULLW  28
04BC8:  MOVF   FF3,W
04BCA:  CLRF   x0F
04BCC:  MOVWF  x0E
04BCE:  MOVLW  18
04BD0:  ADDWF  x0E,W
04BD2:  MOVWF  01
04BD4:  MOVLW  00
04BD6:  ADDWFC x0F,W
04BD8:  MOVWF  03
04BDA:  MOVF   01,W
04BDC:  ADDLW  20
04BDE:  MOVWF  FE9
04BE0:  MOVLW  00
04BE2:  ADDWFC 03,W
04BE4:  MOVWF  FEA
04BE6:  MOVLW  84
04BE8:  MOVWF  FEF
04BEA:  MOVLW  7C
04BEC:  MOVWF  FEC
04BEE:  CLRF   FEC
04BF0:  CLRF   FEC
04BF2:  BRA    4C70
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BF4:  MOVLB  7
04BF6:  MOVF   x01,W
04BF8:  MULLW  28
04BFA:  MOVF   FF3,W
04BFC:  CLRF   x0F
04BFE:  MOVWF  x0E
04C00:  MOVLW  18
04C02:  ADDWF  x0E,W
04C04:  MOVWF  01
04C06:  MOVLW  00
04C08:  ADDWFC x0F,W
04C0A:  MOVWF  03
04C0C:  MOVF   01,W
04C0E:  ADDLW  20
04C10:  MOVWF  FE9
04C12:  MOVLW  00
04C14:  ADDWFC 03,W
04C16:  MOVWF  FEA
04C18:  MOVFF  FEF,746
04C1C:  MOVFF  FEC,70F
04C20:  MOVFF  FEC,748
04C24:  MOVFF  FEC,749
04C28:  MOVFF  70F,747
04C2C:  CLRF   x4D
04C2E:  CLRF   x4C
04C30:  MOVLW  C0
04C32:  MOVWF  x4B
04C34:  MOVLW  82
04C36:  MOVWF  x4A
04C38:  MOVLB  0
04C3A:  CALL   1D34
04C3E:  BNC   4C70
04C40:  MOVLB  7
04C42:  MOVF   x01,W
04C44:  MULLW  28
04C46:  MOVF   FF3,W
04C48:  CLRF   x0F
04C4A:  MOVWF  x0E
04C4C:  MOVLW  18
04C4E:  ADDWF  x0E,W
04C50:  MOVWF  01
04C52:  MOVLW  00
04C54:  ADDWFC x0F,W
04C56:  MOVWF  03
04C58:  MOVF   01,W
04C5A:  ADDLW  20
04C5C:  MOVWF  FE9
04C5E:  MOVLW  00
04C60:  ADDWFC 03,W
04C62:  MOVWF  FEA
04C64:  MOVLW  82
04C66:  MOVWF  FEF
04C68:  MOVLW  C0
04C6A:  MOVWF  FEC
04C6C:  CLRF   FEC
04C6E:  CLRF   FEC
04C70:  MOVLB  0
04C72:  GOTO   4CF0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C76:  MOVLB  6
04C78:  MOVF   xFE,W
04C7A:  MULLW  28
04C7C:  MOVF   FF3,W
04C7E:  MOVLB  7
04C80:  CLRF   x01
04C82:  MOVWF  x00
04C84:  MOVLW  0C
04C86:  ADDWF  x00,W
04C88:  MOVWF  01
04C8A:  MOVLW  00
04C8C:  ADDWFC x01,W
04C8E:  MOVWF  03
04C90:  MOVF   01,W
04C92:  ADDLW  20
04C94:  MOVWF  FE9
04C96:  MOVLW  00
04C98:  ADDWFC 03,W
04C9A:  MOVWF  FEA
04C9C:  MOVFF  FEF,746
04CA0:  MOVFF  FEC,747
04CA4:  MOVFF  FEC,748
04CA8:  MOVFF  FEC,749
04CAC:  MOVLB  6
04CAE:  MOVF   xFE,W
04CB0:  MULLW  28
04CB2:  MOVF   FF3,W
04CB4:  MOVLB  7
04CB6:  CLRF   x05
04CB8:  MOVWF  x04
04CBA:  MOVLW  10
04CBC:  ADDWF  x04,W
04CBE:  MOVWF  01
04CC0:  MOVLW  00
04CC2:  ADDWFC x05,W
04CC4:  MOVWF  03
04CC6:  MOVF   01,W
04CC8:  ADDLW  20
04CCA:  MOVWF  FE9
04CCC:  MOVLW  00
04CCE:  ADDWFC 03,W
04CD0:  MOVWF  FEA
04CD2:  MOVFF  FEF,74A
04CD6:  MOVFF  FEC,74B
04CDA:  MOVFF  FEC,74C
04CDE:  MOVFF  FEC,74D
04CE2:  MOVLB  0
04CE4:  CALL   1D34
04CE8:  BZ    4CF0
04CEA:  MOVFF  6FE,701
04CEE:  BRA    46E4
....................    if ((index++) >= numChannels) index = 0;
04CF0:  MOVLB  1
04CF2:  MOVF   xE9,W
04CF4:  INCF   xE9,F
04CF6:  SUBLW  01
04CF8:  BC    4CFC
04CFA:  CLRF   xE9
04CFC:  MOVLB  0
04CFE:  GOTO   4E10 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B52:  CLRF   03
00B54:  MOVF   F91,W
00B56:  MOVFF  700,F91
00B5A:  RRCF   F94,W
00B5C:  BNC   0B5A
00B5E:  MOVF   F91,W
00B60:  MOVWF  02
00B62:  MOVFF  6FF,F91
00B66:  RRCF   F94,W
00B68:  BNC   0B66
00B6A:  MOVF   F91,W
00B6C:  MOVWF  01
00B6E:  MOVFF  6FE,F91
00B72:  RRCF   F94,W
00B74:  BNC   0B72
00B76:  MOVFF  F91,00
00B7A:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04652:  MOVLB  6
04654:  MOVF   xFF,F
04656:  BZ    469E
....................       if (chMap[0] == ch) output_low(INV_HVX);
04658:  MOVLW  00
0465A:  MOVLB  0
0465C:  BTFSC  x70.0
0465E:  MOVLW  01
04660:  MOVLB  6
04662:  SUBWF  xFE,W
04664:  BNZ   466C
04666:  MOVLW  04
04668:  MOVWF  F88
0466A:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0466C:  MOVLW  00
0466E:  MOVLB  0
04670:  BTFSC  x70.1
04672:  MOVLW  01
04674:  MOVLB  6
04676:  SUBWF  xFE,W
04678:  BNZ   4680
0467A:  MOVLW  04
0467C:  MOVWF  F88
0467E:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04680:  MOVF   xFE,W
04682:  MULLW  07
04684:  MOVF   FF3,W
04686:  MOVLB  7
04688:  CLRF   x01
0468A:  MOVWF  x00
0468C:  MOVLW  64
0468E:  ADDWF  x00,W
04690:  MOVWF  FE9
04692:  MOVLW  01
04694:  ADDWFC x01,W
04696:  MOVWF  FEA
04698:  BSF    FEF.0
....................    }
0469A:  BRA    46E0
0469C:  MOVLB  6
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
0469E:  MOVLW  00
046A0:  MOVLB  0
046A2:  BTFSC  x70.0
046A4:  MOVLW  01
046A6:  MOVLB  6
046A8:  SUBWF  xFE,W
046AA:  BNZ   46B2
046AC:  MOVLW  04
046AE:  MOVWF  F88
046B0:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
046B2:  MOVLW  00
046B4:  MOVLB  0
046B6:  BTFSC  x70.1
046B8:  MOVLW  01
046BA:  MOVLB  6
046BC:  SUBWF  xFE,W
046BE:  BNZ   46C6
046C0:  MOVLW  04
046C2:  MOVWF  F88
046C4:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
046C6:  MOVF   xFE,W
046C8:  MULLW  07
046CA:  MOVF   FF3,W
046CC:  MOVLB  7
046CE:  CLRF   x01
046D0:  MOVWF  x00
046D2:  MOVLW  64
046D4:  ADDWF  x00,W
046D6:  MOVWF  FE9
046D8:  MOVLW  01
046DA:  ADDWFC x01,W
046DC:  MOVWF  FEA
046DE:  BCF    FEF.0
....................    }
046E0:  MOVLB  0
046E2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04D02:  MOVLB  6
04D04:  CLRF   xFD
04D06:  CLRF   xFC
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04D08:  MOVFF  6FB,70D
04D0C:  MOVLB  7
04D0E:  CLRF   x0F
04D10:  MOVLW  71
04D12:  MOVWF  x0E
04D14:  MOVLB  0
04D16:  RCALL  461C
04D18:  MOVF   01,F
04D1A:  BNZ   4E0A
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04D1C:  MOVLB  6
04D1E:  MOVF   xFB,W
04D20:  MULLW  07
04D22:  MOVF   FF3,W
04D24:  CLRF   xFF
04D26:  MOVWF  xFE
04D28:  MOVLW  03
04D2A:  ADDWF  xFE,W
04D2C:  MOVWF  01
04D2E:  MOVLW  00
04D30:  ADDWFC xFF,W
04D32:  MOVWF  03
04D34:  MOVF   01,W
04D36:  ADDLW  64
04D38:  MOVWF  FE9
04D3A:  MOVLW  01
04D3C:  ADDWFC 03,W
04D3E:  MOVWF  FEA
04D40:  MOVFF  FEF,746
04D44:  MOVFF  FEC,747
04D48:  MOVFF  FEC,748
04D4C:  MOVFF  FEC,749
04D50:  MOVLB  7
04D52:  CLRF   x4D
04D54:  CLRF   x4C
04D56:  CLRF   x4B
04D58:  CLRF   x4A
04D5A:  MOVLB  0
04D5C:  CALL   1D34
04D60:  BNC   4D72
04D62:  MOVFF  6FB,6FE
04D66:  MOVLW  01
04D68:  MOVLB  6
04D6A:  MOVWF  xFF
04D6C:  MOVLB  0
04D6E:  RCALL  4652
04D70:  BRA    4D7E
....................         else                         invert_voltage(ch, FALSE);
04D72:  MOVFF  6FB,6FE
04D76:  MOVLB  6
04D78:  CLRF   xFF
04D7A:  MOVLB  0
04D7C:  RCALL  4652
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D7E:  MOVLB  6
04D80:  MOVF   xFB,W
04D82:  MULLW  07
04D84:  MOVF   FF3,W
04D86:  CLRF   xFF
04D88:  MOVWF  xFE
04D8A:  MOVLW  03
04D8C:  ADDWF  xFE,W
04D8E:  MOVWF  01
04D90:  MOVLW  00
04D92:  ADDWFC xFF,W
04D94:  MOVWF  03
04D96:  MOVF   01,W
04D98:  ADDLW  64
04D9A:  MOVWF  FE9
04D9C:  MOVLW  01
04D9E:  ADDWFC 03,W
04DA0:  MOVWF  FEA
04DA2:  MOVFF  FEF,00
04DA6:  MOVFF  FEC,01
04DAA:  MOVFF  FEC,02
04DAE:  MOVFF  FEC,03
04DB2:  BCF    01.7
04DB4:  MOVFF  03,701
04DB8:  MOVFF  02,700
04DBC:  MOVFF  01,6FF
04DC0:  MOVFF  00,6FE
04DC4:  MOVFF  03,753
04DC8:  MOVFF  02,752
04DCC:  MOVFF  01,751
04DD0:  MOVFF  00,750
04DD4:  MOVLW  66
04DD6:  MOVLB  7
04DD8:  MOVWF  x57
04DDA:  MOVLW  D6
04DDC:  MOVWF  x56
04DDE:  MOVLW  23
04DE0:  MOVWF  x55
04DE2:  MOVLW  88
04DE4:  MOVWF  x54
04DE6:  MOVLB  0
04DE8:  CALL   0DA8
04DEC:  MOVFF  03,749
04DF0:  MOVFF  02,748
04DF4:  MOVFF  01,747
04DF8:  MOVFF  00,746
04DFC:  CALL   2728
04E00:  MOVFF  02,6FD
04E04:  MOVFF  01,6FC
....................     }
04E08:  BRA    4F00
....................     else {
....................         pid_task(ch);
04E0A:  MOVFF  6FB,6FE
04E0E:  BRA    4C76
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04E10:  MOVLB  6
04E12:  MOVF   xFB,W
04E14:  MULLW  28
04E16:  MOVF   FF3,W
04E18:  CLRF   xFF
04E1A:  MOVWF  xFE
04E1C:  MOVLW  18
04E1E:  ADDWF  xFE,W
04E20:  MOVWF  01
04E22:  MOVLW  00
04E24:  ADDWFC xFF,W
04E26:  MOVWF  03
04E28:  MOVF   01,W
04E2A:  ADDLW  20
04E2C:  MOVWF  FE9
04E2E:  MOVLW  00
04E30:  ADDWFC 03,W
04E32:  MOVWF  FEA
04E34:  MOVFF  FEF,746
04E38:  MOVFF  FEC,747
04E3C:  MOVFF  FEC,748
04E40:  MOVFF  FEC,749
04E44:  MOVLB  7
04E46:  CLRF   x4D
04E48:  CLRF   x4C
04E4A:  CLRF   x4B
04E4C:  CLRF   x4A
04E4E:  MOVLB  0
04E50:  CALL   1D34
04E54:  BNC   4E68
04E56:  MOVFF  6FB,6FE
04E5A:  MOVLW  01
04E5C:  MOVLB  6
04E5E:  MOVWF  xFF
04E60:  MOVLB  0
04E62:  CALL   4652
04E66:  BRA    4E76
....................         else                       invert_voltage(ch, FALSE);
04E68:  MOVFF  6FB,6FE
04E6C:  MOVLB  6
04E6E:  CLRF   xFF
04E70:  MOVLB  0
04E72:  CALL   4652
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E76:  MOVLB  6
04E78:  MOVF   xFB,W
04E7A:  MULLW  28
04E7C:  MOVF   FF3,W
04E7E:  CLRF   xFF
04E80:  MOVWF  xFE
04E82:  MOVLW  18
04E84:  ADDWF  xFE,W
04E86:  MOVWF  01
04E88:  MOVLW  00
04E8A:  ADDWFC xFF,W
04E8C:  MOVWF  03
04E8E:  MOVF   01,W
04E90:  ADDLW  20
04E92:  MOVWF  FE9
04E94:  MOVLW  00
04E96:  ADDWFC 03,W
04E98:  MOVWF  FEA
04E9A:  MOVFF  FEF,00
04E9E:  MOVFF  FEC,01
04EA2:  MOVFF  FEC,02
04EA6:  MOVFF  FEC,03
04EAA:  BCF    01.7
04EAC:  MOVFF  03,701
04EB0:  MOVFF  02,700
04EB4:  MOVFF  01,6FF
04EB8:  MOVFF  00,6FE
04EBC:  MOVFF  03,753
04EC0:  MOVFF  02,752
04EC4:  MOVFF  01,751
04EC8:  MOVFF  00,750
04ECC:  MOVLW  66
04ECE:  MOVLB  7
04ED0:  MOVWF  x57
04ED2:  MOVLW  D6
04ED4:  MOVWF  x56
04ED6:  MOVLW  23
04ED8:  MOVWF  x55
04EDA:  MOVLW  88
04EDC:  MOVWF  x54
04EDE:  MOVLB  0
04EE0:  CALL   0DA8
04EE4:  MOVFF  03,749
04EE8:  MOVFF  02,748
04EEC:  MOVFF  01,747
04EF0:  MOVFF  00,746
04EF4:  CALL   2728
04EF8:  MOVFF  02,6FD
04EFC:  MOVFF  01,6FC
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04F00:  MOVLB  6
04F02:  MOVF   xFB,W
04F04:  MULLW  07
04F06:  MOVF   FF3,W
04F08:  CLRF   xFF
04F0A:  MOVWF  xFE
04F0C:  MOVLW  01
04F0E:  ADDWF  xFE,W
04F10:  MOVWF  01
04F12:  MOVLW  00
04F14:  ADDWFC xFF,W
04F16:  MOVWF  03
04F18:  MOVF   01,W
04F1A:  ADDLW  64
04F1C:  MOVWF  FE9
04F1E:  MOVLW  01
04F20:  ADDWFC 03,W
04F22:  MOVWF  FEA
04F24:  MOVFF  6FD,FEC
04F28:  MOVF   FED,F
04F2A:  MOVFF  6FC,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F2E:  MOVLW  00
04F30:  MOVLB  0
04F32:  BTFSC  x70.0
04F34:  MOVLW  01
04F36:  MOVLB  6
04F38:  SUBWF  xFB,W
04F3A:  BNZ   4F42
04F3C:  MOVLW  E8
04F3E:  MOVWF  F8B
04F40:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F42:  MOVLW  00
04F44:  MOVLB  0
04F46:  BTFSC  x70.1
04F48:  MOVLW  01
04F4A:  MOVLB  6
04F4C:  SUBWF  xFB,W
04F4E:  BNZ   4F56
04F50:  MOVLW  E8
04F52:  MOVWF  F8B
04F54:  BSF    F86.1
....................    
....................     delay_ms(1);
04F56:  MOVLW  01
04F58:  MOVLB  7
04F5A:  MOVWF  x01
04F5C:  MOVLB  0
04F5E:  CALL   03D2
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04F62:  MOVLW  00
04F64:  BTFSC  x70.0
04F66:  MOVLW  01
04F68:  MOVLB  6
04F6A:  SUBWF  xFB,W
04F6C:  BNZ   4F74
04F6E:  MOVLW  E8
04F70:  MOVWF  F8B
04F72:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04F74:  MOVLW  00
04F76:  MOVLB  0
04F78:  BTFSC  x70.1
04F7A:  MOVLW  01
04F7C:  MOVLB  6
04F7E:  SUBWF  xFB,W
04F80:  BNZ   4F88
04F82:  MOVLW  E8
04F84:  MOVWF  F8B
04F86:  BCF    F86.1
....................     delay_ms(1);
04F88:  MOVLW  01
04F8A:  MOVLB  7
04F8C:  MOVWF  x01
04F8E:  MOVLB  0
04F90:  CALL   03D2
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F94:  MOVLB  7
04F96:  CLRF   x01
04F98:  CLRF   x00
04F9A:  MOVFF  6FD,6FF
04F9E:  MOVFF  6FC,6FE
04FA2:  MOVLB  0
04FA4:  CALL   0B52
....................     delay_ms(1);
04FA8:  MOVLW  01
04FAA:  MOVLB  7
04FAC:  MOVWF  x01
04FAE:  MOVLB  0
04FB0:  CALL   03D2
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04FB4:  MOVLW  00
04FB6:  BTFSC  x70.0
04FB8:  MOVLW  01
04FBA:  MOVLB  6
04FBC:  SUBWF  xFB,W
04FBE:  BNZ   4FC6
04FC0:  MOVLW  E8
04FC2:  MOVWF  F8B
04FC4:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04FC6:  MOVLW  00
04FC8:  MOVLB  0
04FCA:  BTFSC  x70.1
04FCC:  MOVLW  01
04FCE:  MOVLB  6
04FD0:  SUBWF  xFB,W
04FD2:  BNZ   4FDA
04FD4:  MOVLW  E8
04FD6:  MOVWF  F8B
04FD8:  BSF    F86.1
04FDA:  MOVLB  0
04FDC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04FDE:  MOVLB  1
04FE0:  MOVF   xEA,W
04FE2:  XORLW  00
04FE4:  MOVLB  0
04FE6:  BZ    4FEE
04FE8:  XORLW  01
04FEA:  BZ    5000
04FEC:  BRA    5010
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04FEE:  MOVLB  6
04FF0:  CLRF   xFB
04FF2:  MOVLB  0
04FF4:  RCALL  4D02
....................          state = 1;
04FF6:  MOVLW  01
04FF8:  MOVLB  1
04FFA:  MOVWF  xEA
....................       break;
04FFC:  MOVLB  0
04FFE:  BRA    5010
....................       case 1:
....................          set_nanoDAC_outputs(chY);
05000:  MOVLW  01
05002:  MOVLB  6
05004:  MOVWF  xFB
05006:  MOVLB  0
05008:  RCALL  4D02
....................          state = 0;
0500A:  MOVLB  1
0500C:  CLRF   xEA
....................       break;
0500E:  MOVLB  0
....................    }
05010:  GOTO   A758 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B7C:  MOVLB  7
00B7E:  CLRF   x01
00B80:  CLRF   x00
00B82:  MOVLB  6
00B84:  CLRF   xFF
00B86:  CLRF   xFE
00B88:  MOVLB  0
00B8A:  RCALL  0B52
....................    output_low(_SYNC_X);
00B8C:  MOVLW  E8
00B8E:  MOVWF  F8B
00B90:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B92:  MOVWF  F8B
00B94:  BCF    F86.1
....................    output_high(_SYNC_X);
00B96:  MOVWF  F8B
00B98:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B9A:  MOVWF  F8B
00B9C:  BSF    F86.1
00B9E:  GOTO   A72C (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00BA2:  MOVLB  7
00BA4:  MOVF   x01,W
00BA6:  SUBLW  03
00BA8:  BTFSS  FD8.0
00BAA:  BRA    0D18
....................    {
....................       for (int i = 0; i <numParam; i ++)
00BAC:  CLRF   x02
00BAE:  MOVF   x02,W
00BB0:  SUBLW  06
00BB2:  BNC   0C02
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00BB4:  CLRF   x42
00BB6:  MOVFF  701,741
00BBA:  CLRF   x44
00BBC:  MOVLW  B5
00BBE:  MOVWF  x43
00BC0:  MOVLB  0
00BC2:  RCALL  08BE
00BC4:  MOVFF  02,704
00BC8:  MOVFF  01,703
00BCC:  MOVLW  06
00BCE:  MOVLB  7
00BD0:  ADDWF  x03,F
00BD2:  MOVLW  00
00BD4:  ADDWFC x04,F
00BD6:  CLRF   x42
00BD8:  MOVFF  702,741
00BDC:  CLRF   x44
00BDE:  MOVLW  19
00BE0:  MOVWF  x43
00BE2:  MOVLB  0
00BE4:  RCALL  08BE
00BE6:  MOVF   01,W
00BE8:  MOVLB  7
00BEA:  ADDWF  x03,F
00BEC:  MOVF   02,W
00BEE:  ADDWFC x04,F
00BF0:  MOVLW  EB
00BF2:  ADDWF  x03,W
00BF4:  MOVWF  FE9
00BF6:  MOVLW  01
00BF8:  ADDWFC x04,W
00BFA:  MOVWF  FEA
00BFC:  CLRF   FEF
00BFE:  INCF   x02,F
00C00:  BRA    0BAE
....................       }
....................       SERcmd[recNum].t = 0;
00C02:  CLRF   x42
00C04:  MOVFF  701,741
00C08:  CLRF   x44
00C0A:  MOVLW  B5
00C0C:  MOVWF  x43
00C0E:  MOVLB  0
00C10:  RCALL  08BE
00C12:  MOVFF  01,703
00C16:  MOVLW  05
00C18:  MOVLB  7
00C1A:  ADDWF  01,W
00C1C:  MOVWF  01
00C1E:  MOVLW  00
00C20:  ADDWFC 02,W
00C22:  MOVWF  03
00C24:  MOVF   01,W
00C26:  ADDLW  EB
00C28:  MOVWF  FE9
00C2A:  MOVLW  01
00C2C:  ADDWFC 03,W
00C2E:  MOVWF  FEA
00C30:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C32:  CLRF   x42
00C34:  MOVFF  701,741
00C38:  CLRF   x44
00C3A:  MOVLW  B5
00C3C:  MOVWF  x43
00C3E:  MOVLB  0
00C40:  RCALL  08BE
00C42:  MOVFF  01,703
00C46:  MOVLW  01
00C48:  MOVLB  7
00C4A:  ADDWF  01,W
00C4C:  MOVWF  01
00C4E:  MOVLW  00
00C50:  ADDWFC 02,W
00C52:  MOVWF  03
00C54:  MOVF   01,W
00C56:  ADDLW  EB
00C58:  MOVWF  FE9
00C5A:  MOVLW  01
00C5C:  ADDWFC 03,W
00C5E:  MOVWF  FEA
00C60:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C62:  CLRF   x42
00C64:  MOVFF  701,741
00C68:  CLRF   x44
00C6A:  MOVLW  B5
00C6C:  MOVWF  x43
00C6E:  MOVLB  0
00C70:  RCALL  08BE
00C72:  MOVFF  01,703
00C76:  MOVLW  02
00C78:  MOVLB  7
00C7A:  ADDWF  01,W
00C7C:  MOVWF  01
00C7E:  MOVLW  00
00C80:  ADDWFC 02,W
00C82:  MOVWF  03
00C84:  MOVF   01,W
00C86:  ADDLW  EB
00C88:  MOVWF  FE9
00C8A:  MOVLW  01
00C8C:  ADDWFC 03,W
00C8E:  MOVWF  FEA
00C90:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C92:  CLRF   x42
00C94:  MOVFF  701,741
00C98:  CLRF   x44
00C9A:  MOVLW  B5
00C9C:  MOVWF  x43
00C9E:  MOVLB  0
00CA0:  RCALL  08BE
00CA2:  MOVFF  01,703
00CA6:  MOVLW  03
00CA8:  MOVLB  7
00CAA:  ADDWF  01,W
00CAC:  MOVWF  01
00CAE:  MOVLW  00
00CB0:  ADDWFC 02,W
00CB2:  MOVWF  03
00CB4:  MOVF   01,W
00CB6:  ADDLW  EB
00CB8:  MOVWF  FE9
00CBA:  MOVLW  01
00CBC:  ADDWFC 03,W
00CBE:  MOVWF  FEA
00CC0:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00CC2:  CLRF   x42
00CC4:  MOVFF  701,741
00CC8:  CLRF   x44
00CCA:  MOVLW  B5
00CCC:  MOVWF  x43
00CCE:  MOVLB  0
00CD0:  RCALL  08BE
00CD2:  MOVFF  01,703
00CD6:  MOVLW  04
00CD8:  MOVLB  7
00CDA:  ADDWF  01,W
00CDC:  MOVWF  01
00CDE:  MOVLW  00
00CE0:  ADDWFC 02,W
00CE2:  MOVWF  03
00CE4:  MOVF   01,W
00CE6:  ADDLW  EB
00CE8:  MOVWF  FE9
00CEA:  MOVLW  01
00CEC:  ADDWFC 03,W
00CEE:  MOVWF  FEA
00CF0:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CF2:  CLRF   x42
00CF4:  MOVFF  701,741
00CF8:  CLRF   x44
00CFA:  MOVLW  B5
00CFC:  MOVWF  x43
00CFE:  MOVLB  0
00D00:  RCALL  08BE
00D02:  MOVLW  EB
00D04:  MOVLB  7
00D06:  ADDWF  01,W
00D08:  MOVWF  FE9
00D0A:  MOVLW  01
00D0C:  ADDWFC 02,W
00D0E:  MOVWF  FEA
00D10:  BCF    FEF.0
....................       retData[0] = '\0';
00D12:  MOVLB  4
00D14:  CLRF   xC1
00D16:  MOVLB  7
....................    }
00D18:  MOVLB  0
00D1A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05A5C:  MOVLB  7
05A5E:  CLRF   x42
05A60:  MOVFF  4BF,741
05A64:  CLRF   x44
05A66:  MOVLW  B5
05A68:  MOVWF  x43
05A6A:  MOVLB  0
05A6C:  CALL   08BE
05A70:  MOVFF  02,702
05A74:  MOVFF  01,701
05A78:  MOVLW  EB
05A7A:  MOVLB  7
05A7C:  ADDWF  01,W
05A7E:  MOVWF  FE9
05A80:  MOVLW  01
05A82:  ADDWFC 02,W
05A84:  MOVWF  FEA
05A86:  BTFSC  FEF.0
05A88:  BRA    5AAA
....................    {
....................       if (SRI == SWI) return FALSE;
05A8A:  MOVLB  4
05A8C:  MOVF   xC0,W
05A8E:  SUBWF  xBF,W
05A90:  BNZ   5A98
05A92:  MOVLW  00
05A94:  MOVWF  01
05A96:  BRA    5AB0
....................       SRI +=1;
05A98:  MOVLW  01
05A9A:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05A9C:  MOVF   xBF,W
05A9E:  SUBLW  03
05AA0:  BC    5AA4
05AA2:  CLRF   xBF
05AA4:  MOVLB  0
05AA6:  BRA    5A5C
05AA8:  MOVLB  7
....................    }
....................    return TRUE;
05AAA:  MOVLW  01
05AAC:  MOVWF  01
05AAE:  MOVLB  4
05AB0:  MOVLB  0
05AB2:  GOTO   A1EE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
0504C:  MOVLW  01
0504E:  MOVLB  4
05050:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
05052:  MOVF   xC0,W
05054:  SUBLW  03
05056:  BC    505A
05058:  CLRF   xC0
0505A:  MOVLB  0
0505C:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* pBuff){
....................     output_high(TX_ENABLE);
*
0A19E:  MOVLW  93
0A1A0:  MOVWF  F89
0A1A2:  BSF    F84.5
....................     delay_us(500);
0A1A4:  MOVLW  02
0A1A6:  MOVLB  7
0A1A8:  MOVWF  x03
0A1AA:  MOVLW  FA
0A1AC:  MOVWF  x07
0A1AE:  MOVLB  0
0A1B0:  CALL   074E
0A1B4:  MOVLB  7
0A1B6:  DECFSZ x03,F
0A1B8:  BRA    A1AA
....................     
....................     fprintf(SERIAL, "%s", pBuff);
0A1BA:  MOVFF  702,FEA
0A1BE:  MOVFF  701,FE9
0A1C2:  MOVLB  0
0A1C4:  CALL   505E
....................     delay_us(500);
0A1C8:  MOVLW  02
0A1CA:  MOVLB  7
0A1CC:  MOVWF  x03
0A1CE:  MOVLW  FA
0A1D0:  MOVWF  x07
0A1D2:  MOVLB  0
0A1D4:  CALL   074E
0A1D8:  MOVLB  7
0A1DA:  DECFSZ x03,F
0A1DC:  BRA    A1CE
....................     
....................     output_low(TX_ENABLE);
0A1DE:  MOVLW  93
0A1E0:  MOVWF  F89
0A1E2:  BCF    F84.5
0A1E4:  MOVLB  0
0A1E6:  GOTO   A306 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
00120:  MOVLB  0
.................... {
....................    while (kbhit())
00122:  BTFSC  F8D.6
00124:  BRA    0164
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
00126:  CLRF   03
00128:  MOVLB  5
0012A:  MOVF   x61,W
0012C:  ADDLW  25
0012E:  MOVWF  FE9
00130:  MOVLW  05
00132:  ADDWFC 03,W
00134:  MOVWF  FEA
00136:  MOVFF  FEA,774
0013A:  MOVFF  FE9,773
0013E:  MOVLB  0
00140:  BRA    00CA
00142:  MOVFF  774,FEA
00146:  MOVFF  773,FE9
0014A:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
0014E:  MOVLW  01
00150:  MOVLB  5
00152:  ADDWF  x61,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
00154:  MOVF   x61,W
00156:  SUBLW  3B
00158:  BC    015C
0015A:  CLRF   x61
....................       BYTES_AVAILABLE=TRUE;
0015C:  MOVLB  1
0015E:  BSF    x63.1
00160:  MOVLB  0
00162:  BRA    0122
....................    }
00164:  MOVLB  E
00166:  BCF    xC8.5
00168:  MOVLB  0
0016A:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05014:  CLRF   03
05016:  MOVLB  5
05018:  MOVF   x62,W
0501A:  ADDLW  25
0501C:  MOVWF  FE9
0501E:  MOVLW  05
05020:  ADDWFC 03,W
05022:  MOVWF  FEA
05024:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05028:  MOVLW  01
0502A:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
0502C:  MOVF   x62,W
0502E:  SUBLW  3B
05030:  BC    5034
05032:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05034:  MOVF   x61,W
05036:  SUBWF  x62,W
05038:  BNZ   5040
0503A:  MOVLB  1
0503C:  BCF    x63.1
0503E:  MOVLB  5
....................    return data;
05040:  MOVLB  6
05042:  MOVFF  6FC,01
05046:  MOVLB  0
05048:  GOTO   50CA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05088:  MOVLB  1
0508A:  BTFSS  x63.1
0508C:  BRA    559A
0508E:  MOVLB  7
05090:  CLRF   x42
05092:  MOVFF  4C0,741
05096:  CLRF   x44
05098:  MOVLW  B5
0509A:  MOVWF  x43
0509C:  MOVLB  0
0509E:  CALL   08BE
050A2:  MOVFF  02,6FD
050A6:  MOVFF  01,6FC
050AA:  MOVLW  EB
050AC:  MOVLB  6
050AE:  ADDWF  01,W
050B0:  MOVWF  01
050B2:  MOVLW  01
050B4:  ADDWFC 02,W
050B6:  MOVWF  03
050B8:  MOVFF  01,FE9
050BC:  MOVWF  FEA
050BE:  BTFSS  FEF.0
050C0:  BRA    50C6
050C2:  MOVLB  1
050C4:  BRA    559A
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
050C6:  MOVLB  0
050C8:  BRA    5014
050CA:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
050CE:  MOVLB  6
050D0:  MOVF   xFB,W
050D2:  SUBLW  0D
050D4:  BZ    50DC
050D6:  MOVF   xFB,W
050D8:  SUBLW  20
050DA:  BNZ   50DE
....................       {
....................       }
050DC:  BRA    5594
....................       else if (rxChar == UART_SOT_CHAR)
050DE:  MOVF   xFB,W
050E0:  SUBLW  7E
050E2:  BNZ   5126
....................       {
....................          resetSERcmd(SWI);
050E4:  MOVFF  4C0,701
050E8:  MOVLB  0
050EA:  CALL   0BA2
....................          SERcmd[SWI].t = rxChar;
050EE:  MOVLB  7
050F0:  CLRF   x42
050F2:  MOVFF  4C0,741
050F6:  CLRF   x44
050F8:  MOVLW  B5
050FA:  MOVWF  x43
050FC:  MOVLB  0
050FE:  CALL   08BE
05102:  MOVFF  01,6FC
05106:  MOVLW  05
05108:  MOVLB  6
0510A:  ADDWF  01,W
0510C:  MOVWF  01
0510E:  MOVLW  00
05110:  ADDWFC 02,W
05112:  MOVWF  03
05114:  MOVF   01,W
05116:  ADDLW  EB
05118:  MOVWF  FE9
0511A:  MOVLW  01
0511C:  ADDWFC 03,W
0511E:  MOVWF  FEA
05120:  MOVFF  6FB,FEF
....................       }
05124:  BRA    5594
....................       else if (rxChar >= oneByteCmdTestValue)
05126:  MOVF   xFB,W
05128:  SUBLW  7F
0512A:  BC    5198
....................       {
....................          resetSERcmd(SWI);
0512C:  MOVFF  4C0,701
05130:  MOVLB  0
05132:  CALL   0BA2
....................          SERcmd[SWI].t = rxChar;
05136:  MOVLB  7
05138:  CLRF   x42
0513A:  MOVFF  4C0,741
0513E:  CLRF   x44
05140:  MOVLW  B5
05142:  MOVWF  x43
05144:  MOVLB  0
05146:  CALL   08BE
0514A:  MOVFF  01,6FC
0514E:  MOVLW  05
05150:  MOVLB  6
05152:  ADDWF  01,W
05154:  MOVWF  01
05156:  MOVLW  00
05158:  ADDWFC 02,W
0515A:  MOVWF  03
0515C:  MOVF   01,W
0515E:  ADDLW  EB
05160:  MOVWF  FE9
05162:  MOVLW  01
05164:  ADDWFC 03,W
05166:  MOVWF  FEA
05168:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
0516C:  MOVLB  7
0516E:  CLRF   x42
05170:  MOVFF  4C0,741
05174:  CLRF   x44
05176:  MOVLW  B5
05178:  MOVWF  x43
0517A:  MOVLB  0
0517C:  CALL   08BE
05180:  MOVLW  EB
05182:  MOVLB  6
05184:  ADDWF  01,W
05186:  MOVWF  FE9
05188:  MOVLW  01
0518A:  ADDWFC 02,W
0518C:  MOVWF  FEA
0518E:  BSF    FEF.0
....................          setNextSERWriteIndex();
05190:  MOVLB  0
05192:  RCALL  504C
....................       }
05194:  BRA    5592
05196:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05198:  MOVF   xFB,W
0519A:  SUBLW  0A
0519C:  BTFSS  FD8.2
0519E:  BRA    52AC
....................       {
....................          SERcmd[SWI].full = TRUE;
051A0:  MOVLB  7
051A2:  CLRF   x42
051A4:  MOVFF  4C0,741
051A8:  CLRF   x44
051AA:  MOVLW  B5
051AC:  MOVWF  x43
051AE:  MOVLB  0
051B0:  CALL   08BE
051B4:  MOVLW  EB
051B6:  MOVLB  6
051B8:  ADDWF  01,W
051BA:  MOVWF  FE9
051BC:  MOVLW  01
051BE:  ADDWFC 02,W
051C0:  MOVWF  FEA
051C2:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
051C4:  MOVLB  7
051C6:  CLRF   x42
051C8:  MOVFF  4C0,741
051CC:  CLRF   x44
051CE:  MOVLW  B5
051D0:  MOVWF  x43
051D2:  MOVLB  0
051D4:  CALL   08BE
051D8:  MOVFF  01,6FC
051DC:  MOVLW  04
051DE:  ADDWF  01,W
051E0:  MOVWF  01
051E2:  MOVLW  00
051E4:  ADDWFC 02,W
051E6:  MOVWF  03
051E8:  MOVF   01,W
051EA:  ADDLW  EB
051EC:  MOVWF  01
051EE:  MOVLW  01
051F0:  ADDWFC 03,F
051F2:  MOVFF  01,6FC
051F6:  MOVFF  03,6FD
051FA:  MOVLB  7
051FC:  CLRF   x42
051FE:  MOVFF  4C0,741
05202:  CLRF   x44
05204:  MOVLW  B5
05206:  MOVWF  x43
05208:  MOVLB  0
0520A:  CALL   08BE
0520E:  MOVFF  01,6FE
05212:  MOVLW  02
05214:  MOVLB  6
05216:  ADDWF  01,W
05218:  MOVWF  01
0521A:  MOVLW  00
0521C:  ADDWFC 02,W
0521E:  MOVWF  03
05220:  MOVF   01,W
05222:  ADDLW  EB
05224:  MOVWF  FE9
05226:  MOVLW  01
05228:  ADDWFC 03,W
0522A:  MOVWF  FEA
0522C:  MOVFF  FEF,6FE
05230:  MOVFF  6FD,FEA
05234:  MOVFF  6FC,FE9
05238:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
0523C:  MOVLB  7
0523E:  CLRF   x42
05240:  MOVFF  4C0,741
05244:  CLRF   x44
05246:  MOVLW  B5
05248:  MOVWF  x43
0524A:  MOVLB  0
0524C:  CALL   08BE
05250:  MOVFF  01,6FC
05254:  MOVLW  01
05256:  MOVLB  6
05258:  ADDWF  01,W
0525A:  MOVWF  01
0525C:  MOVLW  00
0525E:  ADDWFC 02,W
05260:  MOVWF  03
05262:  MOVF   01,W
05264:  ADDLW  EB
05266:  MOVWF  FE9
05268:  MOVLW  01
0526A:  ADDWFC 03,W
0526C:  MOVWF  FEA
0526E:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05270:  MOVLB  7
05272:  CLRF   x42
05274:  MOVFF  4C0,741
05278:  CLRF   x44
0527A:  MOVLW  B5
0527C:  MOVWF  x43
0527E:  MOVLB  0
05280:  CALL   08BE
05284:  MOVFF  01,6FC
05288:  MOVLW  02
0528A:  MOVLB  6
0528C:  ADDWF  01,W
0528E:  MOVWF  01
05290:  MOVLW  00
05292:  ADDWFC 02,W
05294:  MOVWF  03
05296:  MOVF   01,W
05298:  ADDLW  EB
0529A:  MOVWF  FE9
0529C:  MOVLW  01
0529E:  ADDWFC 03,W
052A0:  MOVWF  FEA
052A2:  CLRF   FEF
....................          setNextSERWriteIndex();
052A4:  MOVLB  0
052A6:  RCALL  504C
....................       }
052A8:  BRA    5592
052AA:  MOVLB  6
....................       else if (rxChar == delimiter)
052AC:  MOVF   xFB,W
052AE:  SUBLW  2C
052B0:  BNZ   5374
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052B2:  MOVLB  7
052B4:  CLRF   x42
052B6:  MOVFF  4C0,741
052BA:  CLRF   x44
052BC:  MOVLW  B5
052BE:  MOVWF  x43
052C0:  MOVLB  0
052C2:  CALL   08BE
052C6:  MOVFF  02,6FD
052CA:  MOVFF  01,6FC
052CE:  MOVLW  02
052D0:  MOVLB  6
052D2:  ADDWF  01,W
052D4:  MOVWF  01
052D6:  MOVLW  00
052D8:  ADDWFC 02,W
052DA:  MOVWF  03
052DC:  MOVF   01,W
052DE:  ADDLW  EB
052E0:  MOVWF  FE9
052E2:  MOVLW  01
052E4:  ADDWFC 03,W
052E6:  MOVWF  FEA
052E8:  MOVF   FEF,W
052EA:  SUBLW  05
052EC:  BNC   535C
....................          {
....................             SERcmd[SWI].paramIndex +=1;
052EE:  MOVLB  7
052F0:  CLRF   x42
052F2:  MOVFF  4C0,741
052F6:  CLRF   x44
052F8:  MOVLW  B5
052FA:  MOVWF  x43
052FC:  MOVLB  0
052FE:  CALL   08BE
05302:  MOVFF  01,6FC
05306:  MOVLW  02
05308:  MOVLB  6
0530A:  ADDWF  01,W
0530C:  MOVWF  01
0530E:  MOVLW  00
05310:  ADDWFC 02,W
05312:  MOVWF  03
05314:  MOVF   01,W
05316:  ADDLW  EB
05318:  MOVWF  FE9
0531A:  MOVLW  01
0531C:  ADDWFC 03,W
0531E:  MOVWF  FEA
05320:  MOVLW  01
05322:  ADDWF  FEF,W
05324:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05326:  MOVLB  7
05328:  CLRF   x42
0532A:  MOVFF  4C0,741
0532E:  CLRF   x44
05330:  MOVLW  B5
05332:  MOVWF  x43
05334:  MOVLB  0
05336:  CALL   08BE
0533A:  MOVFF  01,6FC
0533E:  MOVLW  01
05340:  MOVLB  6
05342:  ADDWF  01,W
05344:  MOVWF  01
05346:  MOVLW  00
05348:  ADDWFC 02,W
0534A:  MOVWF  03
0534C:  MOVF   01,W
0534E:  ADDLW  EB
05350:  MOVWF  FE9
05352:  MOVLW  01
05354:  ADDWFC 03,W
05356:  MOVWF  FEA
05358:  CLRF   FEF
....................          }
0535A:  BRA    5372
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
0535C:  MOVFF  4C0,701
05360:  MOVLB  0
05362:  CALL   0BA2
....................             fprintf(SERIAL, retData);
05366:  MOVLW  04
05368:  MOVWF  FEA
0536A:  MOVLW  C1
0536C:  MOVWF  FE9
0536E:  RCALL  505E
05370:  MOVLB  6
....................          }
....................       }
05372:  BRA    5594
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05374:  MOVLB  7
05376:  CLRF   x42
05378:  MOVFF  4C0,741
0537C:  CLRF   x44
0537E:  MOVLW  B5
05380:  MOVWF  x43
05382:  MOVLB  0
05384:  CALL   08BE
05388:  MOVFF  02,6FD
0538C:  MOVFF  01,6FC
05390:  MOVLW  01
05392:  MOVLB  6
05394:  ADDWF  01,W
05396:  MOVWF  01
05398:  MOVLW  00
0539A:  ADDWFC 02,W
0539C:  MOVWF  03
0539E:  MOVF   01,W
053A0:  ADDLW  EB
053A2:  MOVWF  FE9
053A4:  MOVLW  01
053A6:  ADDWFC 03,W
053A8:  MOVWF  FEA
053AA:  MOVF   FEF,W
053AC:  SUBLW  18
053AE:  BTFSS  FD8.0
053B0:  BRA    557E
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053B2:  MOVLB  7
053B4:  CLRF   x42
053B6:  MOVFF  4C0,741
053BA:  CLRF   x44
053BC:  MOVLW  B5
053BE:  MOVWF  x43
053C0:  MOVLB  0
053C2:  CALL   08BE
053C6:  MOVFF  02,6FD
053CA:  MOVFF  01,6FC
053CE:  MOVLW  06
053D0:  MOVLB  6
053D2:  ADDWF  xFC,F
053D4:  MOVLW  00
053D6:  ADDWFC xFD,F
053D8:  MOVLB  7
053DA:  CLRF   x42
053DC:  MOVFF  4C0,741
053E0:  CLRF   x44
053E2:  MOVLW  B5
053E4:  MOVWF  x43
053E6:  MOVLB  0
053E8:  CALL   08BE
053EC:  MOVFF  02,6FF
053F0:  MOVFF  01,6FE
053F4:  MOVLW  02
053F6:  ADDWF  01,W
053F8:  MOVWF  01
053FA:  MOVLW  00
053FC:  ADDWFC 02,W
053FE:  MOVWF  03
05400:  MOVF   01,W
05402:  ADDLW  EB
05404:  MOVWF  FE9
05406:  MOVLW  01
05408:  ADDWFC 03,W
0540A:  MOVWF  FEA
0540C:  MOVLB  7
0540E:  CLRF   x42
05410:  MOVFF  FEF,741
05414:  CLRF   x44
05416:  MOVLW  19
05418:  MOVWF  x43
0541A:  MOVLB  0
0541C:  CALL   08BE
05420:  MOVFF  02,03
05424:  MOVF   01,W
05426:  MOVLB  6
05428:  ADDWF  xFC,F
0542A:  MOVF   02,W
0542C:  ADDWFC xFD,F
0542E:  MOVLB  7
05430:  CLRF   x42
05432:  MOVFF  4C0,741
05436:  CLRF   x44
05438:  MOVLW  B5
0543A:  MOVWF  x43
0543C:  MOVLB  0
0543E:  CALL   08BE
05442:  MOVFF  01,6FE
05446:  MOVLW  01
05448:  MOVLB  6
0544A:  ADDWF  01,W
0544C:  MOVWF  01
0544E:  MOVLW  00
05450:  ADDWFC 02,W
05452:  MOVWF  03
05454:  MOVF   01,W
05456:  ADDLW  EB
05458:  MOVWF  FE9
0545A:  MOVLW  01
0545C:  ADDWFC 03,W
0545E:  MOVWF  FEA
05460:  MOVF   FEF,W
05462:  ADDWF  xFC,W
05464:  MOVWF  01
05466:  MOVLW  00
05468:  ADDWFC xFD,W
0546A:  MOVWF  03
0546C:  MOVF   01,W
0546E:  ADDLW  EB
05470:  MOVWF  FE9
05472:  MOVLW  01
05474:  ADDWFC 03,W
05476:  MOVWF  FEA
05478:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
0547C:  MOVLB  7
0547E:  CLRF   x42
05480:  MOVFF  4C0,741
05484:  CLRF   x44
05486:  MOVLW  B5
05488:  MOVWF  x43
0548A:  MOVLB  0
0548C:  CALL   08BE
05490:  MOVFF  01,6FC
05494:  MOVLW  01
05496:  MOVLB  6
05498:  ADDWF  01,W
0549A:  MOVWF  01
0549C:  MOVLW  00
0549E:  ADDWFC 02,W
054A0:  MOVWF  03
054A2:  MOVF   01,W
054A4:  ADDLW  EB
054A6:  MOVWF  FE9
054A8:  MOVLW  01
054AA:  ADDWFC 03,W
054AC:  MOVWF  FEA
054AE:  MOVLW  01
054B0:  ADDWF  FEF,W
054B2:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054B4:  MOVLB  7
054B6:  CLRF   x42
054B8:  MOVFF  4C0,741
054BC:  CLRF   x44
054BE:  MOVLW  B5
054C0:  MOVWF  x43
054C2:  MOVLB  0
054C4:  CALL   08BE
054C8:  MOVFF  02,6FD
054CC:  MOVFF  01,6FC
054D0:  MOVLW  06
054D2:  MOVLB  6
054D4:  ADDWF  xFC,F
054D6:  MOVLW  00
054D8:  ADDWFC xFD,F
054DA:  MOVLB  7
054DC:  CLRF   x42
054DE:  MOVFF  4C0,741
054E2:  CLRF   x44
054E4:  MOVLW  B5
054E6:  MOVWF  x43
054E8:  MOVLB  0
054EA:  CALL   08BE
054EE:  MOVFF  02,6FF
054F2:  MOVFF  01,6FE
054F6:  MOVLW  02
054F8:  ADDWF  01,W
054FA:  MOVWF  01
054FC:  MOVLW  00
054FE:  ADDWFC 02,W
05500:  MOVWF  03
05502:  MOVF   01,W
05504:  ADDLW  EB
05506:  MOVWF  FE9
05508:  MOVLW  01
0550A:  ADDWFC 03,W
0550C:  MOVWF  FEA
0550E:  MOVLB  7
05510:  CLRF   x42
05512:  MOVFF  FEF,741
05516:  CLRF   x44
05518:  MOVLW  19
0551A:  MOVWF  x43
0551C:  MOVLB  0
0551E:  CALL   08BE
05522:  MOVFF  02,03
05526:  MOVF   01,W
05528:  MOVLB  6
0552A:  ADDWF  xFC,F
0552C:  MOVF   02,W
0552E:  ADDWFC xFD,F
05530:  MOVLB  7
05532:  CLRF   x42
05534:  MOVFF  4C0,741
05538:  CLRF   x44
0553A:  MOVLW  B5
0553C:  MOVWF  x43
0553E:  MOVLB  0
05540:  CALL   08BE
05544:  MOVFF  01,6FE
05548:  MOVLW  01
0554A:  MOVLB  6
0554C:  ADDWF  01,W
0554E:  MOVWF  01
05550:  MOVLW  00
05552:  ADDWFC 02,W
05554:  MOVWF  03
05556:  MOVF   01,W
05558:  ADDLW  EB
0555A:  MOVWF  FE9
0555C:  MOVLW  01
0555E:  ADDWFC 03,W
05560:  MOVWF  FEA
05562:  MOVF   FEF,W
05564:  ADDWF  xFC,W
05566:  MOVWF  01
05568:  MOVLW  00
0556A:  ADDWFC xFD,W
0556C:  MOVWF  03
0556E:  MOVF   01,W
05570:  ADDLW  EB
05572:  MOVWF  FE9
05574:  MOVLW  01
05576:  ADDWFC 03,W
05578:  MOVWF  FEA
0557A:  CLRF   FEF
....................          }
0557C:  BRA    5594
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
0557E:  MOVFF  4C0,701
05582:  MOVLB  0
05584:  CALL   0BA2
....................             fprintf(SERIAL, retData);
05588:  MOVLW  04
0558A:  MOVWF  FEA
0558C:  MOVLW  C1
0558E:  MOVWF  FE9
05590:  RCALL  505E
05592:  MOVLB  6
....................          }
....................       }
05594:  MOVLB  0
05596:  BRA    5088
05598:  MOVLB  1
....................    }          
0559A:  MOVLB  0
0559C:  GOTO   A76C (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00D1C:  MOVLB  6
00D1E:  CLRF   xFB
00D20:  MOVF   xFB,W
00D22:  SUBLW  03
00D24:  BNC   0D34
....................    {
....................       resetSERcmd(i);
00D26:  MOVFF  6FB,701
00D2A:  MOVLB  0
00D2C:  RCALL  0BA2
00D2E:  MOVLB  6
00D30:  INCF   xFB,F
00D32:  BRA    0D20
....................    }
....................    enable_interrupts(INT_RDA);
00D34:  MOVLB  E
00D36:  BSF    xC0.5
00D38:  MOVLB  0
00D3A:  GOTO   A730 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D3E:  MOVLB  E
00D40:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D42:  MOVLW  01
00D44:  MOVWF  FD1
00D46:  MOVLW  07
00D48:  MOVWF  FCE
00D4A:  CLRF   FCF
00D4C:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D4E:  MOVLB  1
00D50:  CLRF   x75
00D52:  CLRF   x74
00D54:  CLRF   x73
00D56:  CLRF   x72
....................    timeoutReg1 = 0;
00D58:  CLRF   x79
00D5A:  CLRF   x78
00D5C:  CLRF   x77
00D5E:  CLRF   x76
....................    timeoutReg2 = 0;
00D60:  CLRF   x7D
00D62:  CLRF   x7C
00D64:  CLRF   x7B
00D66:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D68:  MOVLB  E
00D6A:  BSF    xC1.0
00D6C:  MOVLB  0
00D6E:  GOTO   A734 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00292:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00294:  MOVLW  0B
00296:  MOVWF  FCD
00298:  MOVLW  DB
0029A:  MOVWF  FCC
0029C:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0029E:  MOVLB  1
002A0:  MOVF   x75,F
002A2:  BNZ   02B2
002A4:  MOVF   x74,F
002A6:  BNZ   02B2
002A8:  MOVF   x73,F
002AA:  BNZ   02B2
002AC:  MOVF   x72,W
002AE:  SUBLW  0A
002B0:  BC    02C0
002B2:  MOVLW  0A
002B4:  SUBWF  x72,F
002B6:  MOVLW  00
002B8:  SUBWFB x73,F
002BA:  SUBWFB x74,F
002BC:  SUBWFB x75,F
002BE:  BRA    02C8
002C0:  CLRF   x75
002C2:  CLRF   x74
002C4:  CLRF   x73
002C6:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
002C8:  MOVF   x79,F
002CA:  BNZ   02DA
002CC:  MOVF   x78,F
002CE:  BNZ   02DA
002D0:  MOVF   x77,F
002D2:  BNZ   02DA
002D4:  MOVF   x76,W
002D6:  SUBLW  0A
002D8:  BC    02E8
002DA:  MOVLW  0A
002DC:  SUBWF  x76,F
002DE:  MOVLW  00
002E0:  SUBWFB x77,F
002E2:  SUBWFB x78,F
002E4:  SUBWFB x79,F
002E6:  BRA    02F0
002E8:  CLRF   x79
002EA:  CLRF   x78
002EC:  CLRF   x77
002EE:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002F0:  MOVF   x7D,F
002F2:  BNZ   0302
002F4:  MOVF   x7C,F
002F6:  BNZ   0302
002F8:  MOVF   x7B,F
002FA:  BNZ   0302
002FC:  MOVF   x7A,W
002FE:  SUBLW  0A
00300:  BC    0310
00302:  MOVLW  0A
00304:  SUBWF  x7A,F
00306:  MOVLW  00
00308:  SUBWFB x7B,F
0030A:  SUBWFB x7C,F
0030C:  SUBWFB x7D,F
0030E:  BRA    0318
00310:  CLRF   x7D
00312:  CLRF   x7C
00314:  CLRF   x7B
00316:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
00318:  MOVF   x7E,F
0031A:  BNZ   0320
0031C:  MOVF   x7F,F
0031E:  BZ    035C
....................    {
....................       timeCounter+=10;
00320:  MOVLW  0A
00322:  MOVLB  5
00324:  ADDWF  x66,F
00326:  MOVLW  00
00328:  ADDWFC x67,F
0032A:  ADDWFC x68,F
0032C:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
0032E:  MOVF   x69,F
00330:  BNZ   034C
00332:  MOVF   x68,F
00334:  BNZ   034C
00336:  MOVLB  1
00338:  MOVF   x7F,W
0033A:  MOVLB  5
0033C:  SUBWF  x67,W
0033E:  BNC   035A
00340:  BNZ   034C
00342:  MOVLB  1
00344:  MOVF   x7E,W
00346:  MOVLB  5
00348:  SUBWF  x66,W
0034A:  BNC   035A
....................       {
....................          sensor_monitor_interrupt_task();
0034C:  MOVLB  0
0034E:  BRA    01F6
....................          timeCounter = 0;
00350:  MOVLB  5
00352:  CLRF   x69
00354:  CLRF   x68
00356:  CLRF   x67
00358:  CLRF   x66
0035A:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
0035C:  MOVLB  E
0035E:  BCF    xC9.0
00360:  MOVLB  0
00362:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05BAC:  MOVLW  04
05BAE:  MOVLB  7
05BB0:  MOVWF  x42
05BB2:  MOVLW  C1
05BB4:  MOVWF  x41
05BB6:  MOVLB  0
05BB8:  RCALL  55A0
05BBA:  MOVFF  02,03
05BBE:  MOVF   01,W
05BC0:  ADDLW  C1
05BC2:  MOVLB  7
05BC4:  MOVWF  x0B
05BC6:  MOVLW  04
05BC8:  ADDWFC 02,W
05BCA:  MOVWF  x0C
05BCC:  MOVFF  FE8,565
05BD0:  MOVFF  70B,564
05BD4:  MOVLW  66
05BD6:  MOVWF  FF6
05BD8:  MOVLW  03
05BDA:  MOVWF  FF7
05BDC:  MOVLB  0
05BDE:  RCALL  5B8C
05BE0:  MOVLW  2C
05BE2:  MOVLB  7
05BE4:  MOVWF  x50
05BE6:  MOVLB  0
05BE8:  RCALL  55D8
....................    return SUCCESS;
05BEA:  MOVLW  00
05BEC:  MOVWF  01
05BEE:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05BF0:  MOVLW  04
05BF2:  MOVLB  7
05BF4:  MOVWF  x42
05BF6:  MOVLW  C1
05BF8:  MOVWF  x41
05BFA:  MOVLB  0
05BFC:  RCALL  55A0
05BFE:  MOVFF  02,03
05C02:  MOVF   01,W
05C04:  ADDLW  C1
05C06:  MOVLB  7
05C08:  MOVWF  x0B
05C0A:  MOVLW  04
05C0C:  ADDWFC 02,W
05C0E:  MOVWF  x0C
05C10:  MOVFF  FE8,565
05C14:  MOVFF  70B,564
05C18:  MOVLW  70
05C1A:  MOVWF  FF6
05C1C:  MOVLW  03
05C1E:  MOVWF  FF7
05C20:  MOVLB  0
05C22:  RCALL  5B8C
05C24:  MOVLW  2C
05C26:  MOVLB  7
05C28:  MOVWF  x50
05C2A:  MOVLB  0
05C2C:  RCALL  55D8
....................    return SUCCESS;
05C2E:  MOVLW  00
05C30:  MOVWF  01
05C32:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06140:  MOVLB  7
06142:  CLRF   x42
06144:  MOVFF  690,741
06148:  CLRF   x44
0614A:  MOVLW  B5
0614C:  MOVWF  x43
0614E:  MOVLB  0
06150:  CALL   08BE
06154:  MOVFF  02,70D
06158:  MOVFF  01,70C
0615C:  MOVLW  06
0615E:  MOVLB  7
06160:  ADDWF  x0C,F
06162:  MOVLW  00
06164:  ADDWFC x0D,F
06166:  MOVLW  32
06168:  ADDWF  x0C,W
0616A:  MOVWF  01
0616C:  MOVLW  00
0616E:  ADDWFC x0D,W
06170:  MOVWF  03
06172:  MOVF   01,W
06174:  ADDLW  EB
06176:  MOVWF  01
06178:  MOVLW  01
0617A:  ADDWFC 03,F
0617C:  MOVFF  01,70C
06180:  MOVFF  03,70D
06184:  MOVFF  03,734
06188:  MOVFF  01,733
0618C:  MOVLB  0
0618E:  RCALL  5C34
06190:  MOVF   01,F
06192:  BNZ   619C
06194:  MOVLW  02
06196:  MOVWF  01
06198:  BRA    62EA
0619A:  BRA    61F8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0619C:  MOVLB  7
0619E:  CLRF   x42
061A0:  MOVFF  690,741
061A4:  CLRF   x44
061A6:  MOVLW  B5
061A8:  MOVWF  x43
061AA:  MOVLB  0
061AC:  CALL   08BE
061B0:  MOVFF  02,70D
061B4:  MOVFF  01,70C
061B8:  MOVLW  06
061BA:  MOVLB  7
061BC:  ADDWF  x0C,F
061BE:  MOVLW  00
061C0:  ADDWFC x0D,F
061C2:  MOVLW  32
061C4:  ADDWF  x0C,W
061C6:  MOVWF  01
061C8:  MOVLW  00
061CA:  ADDWFC x0D,W
061CC:  MOVWF  03
061CE:  MOVF   01,W
061D0:  ADDLW  EB
061D2:  MOVWF  01
061D4:  MOVLW  01
061D6:  ADDWFC 03,F
061D8:  MOVFF  01,70C
061DC:  MOVFF  03,70D
061E0:  MOVFF  03,734
061E4:  MOVFF  01,733
061E8:  CLRF   x36
061EA:  CLRF   x35
061EC:  MOVLW  0A
061EE:  MOVWF  x37
061F0:  MOVLB  0
061F2:  RCALL  5D24
061F4:  MOVFF  01,70B
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
061F8:  MOVLW  01
061FA:  MOVLB  7
061FC:  SUBWF  x0B,W
061FE:  MOVWF  x0D
06200:  CLRF   x0F
06202:  MOVLW  70
06204:  MOVWF  x0E
06206:  MOVLB  0
06208:  CALL   461C
0620C:  BTFSC  01.0
0620E:  BRA    626C
06210:  MOVLW  04
06212:  MOVLB  7
06214:  MOVWF  x42
06216:  MOVLW  C1
06218:  MOVWF  x41
0621A:  MOVLB  0
0621C:  CALL   55A0
06220:  MOVFF  02,03
06224:  MOVF   01,W
06226:  ADDLW  C1
06228:  MOVLB  7
0622A:  MOVWF  x0C
0622C:  MOVLW  04
0622E:  ADDWFC 02,W
06230:  MOVWF  x0D
06232:  MOVFF  FE8,565
06236:  MOVFF  70C,564
0623A:  MOVFF  70B,734
0623E:  MOVLW  18
06240:  MOVWF  x35
06242:  MOVLB  0
06244:  RCALL  6078
06246:  MOVLW  2C
06248:  MOVLB  7
0624A:  MOVWF  x50
0624C:  MOVLB  0
0624E:  CALL   55D8
06252:  MOVLW  58
06254:  MOVLB  7
06256:  MOVWF  x50
06258:  MOVLB  0
0625A:  CALL   55D8
0625E:  MOVLW  2C
06260:  MOVLB  7
06262:  MOVWF  x50
06264:  MOVLB  0
06266:  CALL   55D8
0626A:  BRA    62E6
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
0626C:  MOVLW  01
0626E:  MOVLB  7
06270:  SUBWF  x0B,W
06272:  MOVWF  x0D
06274:  CLRF   x0F
06276:  MOVLW  70
06278:  MOVWF  x0E
0627A:  MOVLB  0
0627C:  CALL   461C
06280:  BTFSS  01.0
06282:  BRA    62E0
06284:  MOVLW  04
06286:  MOVLB  7
06288:  MOVWF  x42
0628A:  MOVLW  C1
0628C:  MOVWF  x41
0628E:  MOVLB  0
06290:  CALL   55A0
06294:  MOVFF  02,03
06298:  MOVF   01,W
0629A:  ADDLW  C1
0629C:  MOVLB  7
0629E:  MOVWF  x0C
062A0:  MOVLW  04
062A2:  ADDWFC 02,W
062A4:  MOVWF  x0D
062A6:  MOVFF  FE8,565
062AA:  MOVFF  70C,564
062AE:  MOVFF  70B,734
062B2:  MOVLW  18
062B4:  MOVWF  x35
062B6:  MOVLB  0
062B8:  RCALL  6078
062BA:  MOVLW  2C
062BC:  MOVLB  7
062BE:  MOVWF  x50
062C0:  MOVLB  0
062C2:  CALL   55D8
062C6:  MOVLW  59
062C8:  MOVLB  7
062CA:  MOVWF  x50
062CC:  MOVLB  0
062CE:  CALL   55D8
062D2:  MOVLW  2C
062D4:  MOVLB  7
062D6:  MOVWF  x50
062D8:  MOVLB  0
062DA:  CALL   55D8
062DE:  BRA    62E6
....................    else return INV_PARAM;
062E0:  MOVLW  02
062E2:  MOVWF  01
062E4:  BRA    62EA
....................    
....................    return SUCCESS;
062E6:  MOVLW  00
062E8:  MOVWF  01
062EA:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0632E:  MOVLB  7
06330:  CLRF   x42
06332:  MOVFF  690,741
06336:  CLRF   x44
06338:  MOVLW  B5
0633A:  MOVWF  x43
0633C:  MOVLB  0
0633E:  CALL   08BE
06342:  MOVFF  02,70E
06346:  MOVFF  01,70D
0634A:  MOVLW  06
0634C:  MOVLB  7
0634E:  ADDWF  x0D,F
06350:  MOVLW  00
06352:  ADDWFC x0E,F
06354:  MOVLW  32
06356:  ADDWF  x0D,W
06358:  MOVWF  01
0635A:  MOVLW  00
0635C:  ADDWFC x0E,W
0635E:  MOVWF  03
06360:  MOVF   01,W
06362:  ADDLW  EB
06364:  MOVWF  01
06366:  MOVLW  01
06368:  ADDWFC 03,F
0636A:  MOVFF  01,70D
0636E:  MOVFF  03,70E
06372:  MOVFF  03,734
06376:  MOVFF  01,733
0637A:  MOVLB  0
0637C:  RCALL  5C34
0637E:  MOVF   01,F
06380:  BNZ   638A
06382:  MOVLW  02
06384:  MOVWF  01
06386:  BRA    64DA
06388:  BRA    63E6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0638A:  MOVLB  7
0638C:  CLRF   x42
0638E:  MOVFF  690,741
06392:  CLRF   x44
06394:  MOVLW  B5
06396:  MOVWF  x43
06398:  MOVLB  0
0639A:  CALL   08BE
0639E:  MOVFF  02,70E
063A2:  MOVFF  01,70D
063A6:  MOVLW  06
063A8:  MOVLB  7
063AA:  ADDWF  x0D,F
063AC:  MOVLW  00
063AE:  ADDWFC x0E,F
063B0:  MOVLW  32
063B2:  ADDWF  x0D,W
063B4:  MOVWF  01
063B6:  MOVLW  00
063B8:  ADDWFC x0E,W
063BA:  MOVWF  03
063BC:  MOVF   01,W
063BE:  ADDLW  EB
063C0:  MOVWF  01
063C2:  MOVLW  01
063C4:  ADDWFC 03,F
063C6:  MOVFF  01,70D
063CA:  MOVFF  03,70E
063CE:  MOVFF  03,734
063D2:  MOVFF  01,733
063D6:  CLRF   x36
063D8:  CLRF   x35
063DA:  MOVLW  0A
063DC:  MOVWF  x37
063DE:  MOVLB  0
063E0:  RCALL  5D24
063E2:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
063E6:  MOVLB  7
063E8:  CLRF   x42
063EA:  MOVFF  690,741
063EE:  CLRF   x44
063F0:  MOVLW  B5
063F2:  MOVWF  x43
063F4:  MOVLB  0
063F6:  CALL   08BE
063FA:  MOVFF  02,70E
063FE:  MOVFF  01,70D
06402:  MOVLW  06
06404:  MOVLB  7
06406:  ADDWF  x0D,F
06408:  MOVLW  00
0640A:  ADDWFC x0E,F
0640C:  MOVLW  4B
0640E:  ADDWF  x0D,W
06410:  MOVWF  01
06412:  MOVLW  00
06414:  ADDWFC x0E,W
06416:  MOVWF  03
06418:  MOVF   01,W
0641A:  ADDLW  EB
0641C:  MOVWF  01
0641E:  MOVLW  01
06420:  ADDWFC 03,F
06422:  MOVFF  01,70D
06426:  MOVFF  03,70E
0642A:  MOVFF  03,742
0642E:  MOVFF  01,741
06432:  MOVLB  0
06434:  CALL   55A0
06438:  MOVFF  02,03
0643C:  MOVF   01,W
0643E:  SUBLW  01
06440:  BNZ   6446
06442:  MOVF   03,F
06444:  BZ    644E
06446:  MOVLW  02
06448:  MOVWF  01
0644A:  BRA    64DA
0644C:  BRA    648E
....................    else arg2 = SERcmd[rec].p[3][0];
0644E:  MOVLB  7
06450:  CLRF   x42
06452:  MOVFF  690,741
06456:  CLRF   x44
06458:  MOVLW  B5
0645A:  MOVWF  x43
0645C:  MOVLB  0
0645E:  CALL   08BE
06462:  MOVFF  02,70E
06466:  MOVFF  01,70D
0646A:  MOVLW  06
0646C:  MOVLB  7
0646E:  ADDWF  x0D,F
06470:  MOVLW  00
06472:  ADDWFC x0E,F
06474:  MOVLW  4B
06476:  ADDWF  x0D,F
06478:  MOVLW  00
0647A:  ADDWFC x0E,F
0647C:  MOVLW  EB
0647E:  ADDWF  x0D,W
06480:  MOVWF  FE9
06482:  MOVLW  01
06484:  ADDWFC x0E,W
06486:  MOVWF  FEA
06488:  MOVFF  FEF,70C
0648C:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
0648E:  MOVLB  7
06490:  MOVF   x0C,W
06492:  SUBLW  58
06494:  BNZ   64AE
06496:  MOVLW  01
06498:  SUBWF  x0B,W
0649A:  MOVWF  x0D
0649C:  MOVWF  x22
0649E:  CLRF   x23
064A0:  CLRF   x25
064A2:  MOVLW  70
064A4:  MOVWF  x24
064A6:  MOVLB  0
064A8:  RCALL  62EC
064AA:  BRA    64D6
064AC:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
064AE:  MOVF   x0C,W
064B0:  SUBLW  59
064B2:  BNZ   64CE
064B4:  MOVLW  01
064B6:  SUBWF  x0B,W
064B8:  MOVWF  x0D
064BA:  MOVWF  x22
064BC:  MOVLW  01
064BE:  MOVWF  x23
064C0:  CLRF   x25
064C2:  MOVLW  70
064C4:  MOVWF  x24
064C6:  MOVLB  0
064C8:  RCALL  62EC
064CA:  BRA    64D6
064CC:  MOVLB  7
....................    else return INV_PARAM;
064CE:  MOVLW  02
064D0:  MOVWF  01
064D2:  MOVLB  0
064D4:  BRA    64DA
....................    
....................    return SUCCESS;
064D6:  MOVLW  00
064D8:  MOVWF  01
064DA:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
064DC:  MOVLB  7
064DE:  CLRF   x42
064E0:  MOVFF  690,741
064E4:  CLRF   x44
064E6:  MOVLW  B5
064E8:  MOVWF  x43
064EA:  MOVLB  0
064EC:  CALL   08BE
064F0:  MOVFF  02,70D
064F4:  MOVFF  01,70C
064F8:  MOVLW  06
064FA:  MOVLB  7
064FC:  ADDWF  x0C,F
064FE:  MOVLW  00
06500:  ADDWFC x0D,F
06502:  MOVLW  32
06504:  ADDWF  x0C,W
06506:  MOVWF  01
06508:  MOVLW  00
0650A:  ADDWFC x0D,W
0650C:  MOVWF  03
0650E:  MOVF   01,W
06510:  ADDLW  EB
06512:  MOVWF  01
06514:  MOVLW  01
06516:  ADDWFC 03,F
06518:  MOVFF  01,70C
0651C:  MOVFF  03,70D
06520:  MOVFF  03,734
06524:  MOVFF  01,733
06528:  MOVLB  0
0652A:  CALL   5C34
0652E:  MOVF   01,F
06530:  BNZ   653A
06532:  MOVLW  02
06534:  MOVWF  01
06536:  BRA    666A
06538:  BRA    6598
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0653A:  MOVLB  7
0653C:  CLRF   x42
0653E:  MOVFF  690,741
06542:  CLRF   x44
06544:  MOVLW  B5
06546:  MOVWF  x43
06548:  MOVLB  0
0654A:  CALL   08BE
0654E:  MOVFF  02,70D
06552:  MOVFF  01,70C
06556:  MOVLW  06
06558:  MOVLB  7
0655A:  ADDWF  x0C,F
0655C:  MOVLW  00
0655E:  ADDWFC x0D,F
06560:  MOVLW  32
06562:  ADDWF  x0C,W
06564:  MOVWF  01
06566:  MOVLW  00
06568:  ADDWFC x0D,W
0656A:  MOVWF  03
0656C:  MOVF   01,W
0656E:  ADDLW  EB
06570:  MOVWF  01
06572:  MOVLW  01
06574:  ADDWFC 03,F
06576:  MOVFF  01,70C
0657A:  MOVFF  03,70D
0657E:  MOVFF  03,734
06582:  MOVFF  01,733
06586:  CLRF   x36
06588:  CLRF   x35
0658A:  MOVLW  0A
0658C:  MOVWF  x37
0658E:  MOVLB  0
06590:  CALL   5D24
06594:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06598:  MOVLW  01
0659A:  MOVLB  7
0659C:  SUBWF  x0B,W
0659E:  MOVWF  x0D
065A0:  CLRF   x0F
065A2:  MOVLW  71
065A4:  MOVWF  x0E
065A6:  MOVLB  0
065A8:  CALL   461C
065AC:  BTFSC  01.0
065AE:  BRA    65FC
065B0:  MOVLW  04
065B2:  MOVLB  7
065B4:  MOVWF  x42
065B6:  MOVLW  C1
065B8:  MOVWF  x41
065BA:  MOVLB  0
065BC:  CALL   55A0
065C0:  MOVFF  02,03
065C4:  MOVF   01,W
065C6:  ADDLW  C1
065C8:  MOVLB  7
065CA:  MOVWF  x0C
065CC:  MOVLW  04
065CE:  ADDWFC 02,W
065D0:  MOVWF  x0D
065D2:  MOVFF  FE8,565
065D6:  MOVFF  70C,564
065DA:  MOVFF  70B,734
065DE:  MOVLW  18
065E0:  MOVWF  x35
065E2:  MOVLB  0
065E4:  RCALL  6078
065E6:  MOVLW  78
065E8:  MOVWF  FF6
065EA:  MOVLW  03
065EC:  MOVWF  FF7
065EE:  MOVLW  08
065F0:  MOVLB  7
065F2:  MOVWF  x0F
065F4:  MOVLB  0
065F6:  CALL   55F8
065FA:  BRA    6666
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
065FC:  MOVLW  01
065FE:  MOVLB  7
06600:  SUBWF  x0B,W
06602:  MOVWF  x0D
06604:  CLRF   x0F
06606:  MOVLW  71
06608:  MOVWF  x0E
0660A:  MOVLB  0
0660C:  CALL   461C
06610:  BTFSS  01.0
06612:  BRA    6660
06614:  MOVLW  04
06616:  MOVLB  7
06618:  MOVWF  x42
0661A:  MOVLW  C1
0661C:  MOVWF  x41
0661E:  MOVLB  0
06620:  CALL   55A0
06624:  MOVFF  02,03
06628:  MOVF   01,W
0662A:  ADDLW  C1
0662C:  MOVLB  7
0662E:  MOVWF  x0C
06630:  MOVLW  04
06632:  ADDWFC 02,W
06634:  MOVWF  x0D
06636:  MOVFF  FE8,565
0663A:  MOVFF  70C,564
0663E:  MOVFF  70B,734
06642:  MOVLW  18
06644:  MOVWF  x35
06646:  MOVLB  0
06648:  RCALL  6078
0664A:  MOVLW  84
0664C:  MOVWF  FF6
0664E:  MOVLW  03
06650:  MOVWF  FF7
06652:  MOVLW  08
06654:  MOVLB  7
06656:  MOVWF  x0F
06658:  MOVLB  0
0665A:  CALL   55F8
0665E:  BRA    6666
....................    else return INV_PARAM;
06660:  MOVLW  02
06662:  MOVWF  01
06664:  BRA    666A
....................    
....................    return SUCCESS;
06666:  MOVLW  00
06668:  MOVWF  01
0666A:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
0666C:  MOVLW  4D
0666E:  MOVLB  7
06670:  MOVWF  x10
06672:  MOVLW  41
06674:  MOVWF  x11
06676:  MOVLW  4E
06678:  MOVWF  x12
0667A:  MOVLW  55
0667C:  MOVWF  x13
0667E:  MOVLW  41
06680:  MOVWF  x14
06682:  MOVLW  4C
06684:  MOVWF  x15
06686:  CLRF   x16
06688:  MOVLW  07
0668A:  MOVWF  x0F
0668C:  MOVLW  10
0668E:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
06690:  MOVLW  4D
06692:  MOVWF  x19
06694:  MOVLW  41
06696:  MOVWF  x1A
06698:  MOVLW  47
0669A:  MOVWF  x1B
0669C:  MOVLW  53
0669E:  MOVWF  x1C
066A0:  MOVLW  4E
066A2:  MOVWF  x1D
066A4:  MOVLW  53
066A6:  MOVWF  x1E
066A8:  CLRF   x1F
066AA:  MOVLW  07
066AC:  MOVWF  x18
066AE:  MOVLW  19
066B0:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
066B2:  CLRF   x42
066B4:  MOVFF  690,741
066B8:  CLRF   x44
066BA:  MOVLW  B5
066BC:  MOVWF  x43
066BE:  MOVLB  0
066C0:  CALL   08BE
066C4:  MOVFF  02,721
066C8:  MOVFF  01,720
066CC:  MOVLW  06
066CE:  MOVLB  7
066D0:  ADDWF  x20,F
066D2:  MOVLW  00
066D4:  ADDWFC x21,F
066D6:  MOVLW  32
066D8:  ADDWF  x20,W
066DA:  MOVWF  01
066DC:  MOVLW  00
066DE:  ADDWFC x21,W
066E0:  MOVWF  03
066E2:  MOVF   01,W
066E4:  ADDLW  EB
066E6:  MOVWF  01
066E8:  MOVLW  01
066EA:  ADDWFC 03,F
066EC:  MOVFF  01,720
066F0:  MOVFF  03,721
066F4:  MOVFF  03,734
066F8:  MOVFF  01,733
066FC:  MOVLB  0
066FE:  CALL   5C34
06702:  MOVF   01,F
06704:  BNZ   670E
06706:  MOVLW  02
06708:  MOVWF  01
0670A:  BRA    6884
0670C:  BRA    676C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0670E:  MOVLB  7
06710:  CLRF   x42
06712:  MOVFF  690,741
06716:  CLRF   x44
06718:  MOVLW  B5
0671A:  MOVWF  x43
0671C:  MOVLB  0
0671E:  CALL   08BE
06722:  MOVFF  02,721
06726:  MOVFF  01,720
0672A:  MOVLW  06
0672C:  MOVLB  7
0672E:  ADDWF  x20,F
06730:  MOVLW  00
06732:  ADDWFC x21,F
06734:  MOVLW  32
06736:  ADDWF  x20,W
06738:  MOVWF  01
0673A:  MOVLW  00
0673C:  ADDWFC x21,W
0673E:  MOVWF  03
06740:  MOVF   01,W
06742:  ADDLW  EB
06744:  MOVWF  01
06746:  MOVLW  01
06748:  ADDWFC 03,F
0674A:  MOVFF  01,720
0674E:  MOVFF  03,721
06752:  MOVFF  03,734
06756:  MOVFF  01,733
0675A:  CLRF   x36
0675C:  CLRF   x35
0675E:  MOVLW  0A
06760:  MOVWF  x37
06762:  MOVLB  0
06764:  CALL   5D24
06768:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
0676C:  MOVLB  7
0676E:  CLRF   x42
06770:  MOVFF  690,741
06774:  CLRF   x44
06776:  MOVLW  B5
06778:  MOVWF  x43
0677A:  MOVLB  0
0677C:  CALL   08BE
06780:  MOVFF  02,721
06784:  MOVFF  01,720
06788:  MOVLW  06
0678A:  MOVLB  7
0678C:  ADDWF  x20,F
0678E:  MOVLW  00
06790:  ADDWFC x21,F
06792:  MOVLW  4B
06794:  ADDWF  x20,W
06796:  MOVWF  01
06798:  MOVLW  00
0679A:  ADDWFC x21,W
0679C:  MOVWF  03
0679E:  MOVF   01,W
067A0:  ADDLW  EB
067A2:  MOVWF  01
067A4:  MOVLW  01
067A6:  ADDWFC 03,F
067A8:  MOVFF  01,720
067AC:  MOVFF  03,721
067B0:  MOVFF  03,742
067B4:  MOVFF  01,741
067B8:  MOVLB  0
067BA:  CALL   55A0
067BE:  MOVFF  02,03
067C2:  MOVF   01,W
067C4:  BNZ   67D2
067C6:  MOVF   03,F
067C8:  BNZ   67D2
067CA:  MOVLW  02
067CC:  MOVWF  01
067CE:  BRA    6884
067D0:  BRA    6818
....................    else arg2 = SERcmd[rec].p[3];
067D2:  MOVLB  7
067D4:  CLRF   x42
067D6:  MOVFF  690,741
067DA:  CLRF   x44
067DC:  MOVLW  B5
067DE:  MOVWF  x43
067E0:  MOVLB  0
067E2:  CALL   08BE
067E6:  MOVFF  02,721
067EA:  MOVFF  01,720
067EE:  MOVLW  06
067F0:  MOVLB  7
067F2:  ADDWF  x20,F
067F4:  MOVLW  00
067F6:  ADDWFC x21,F
067F8:  MOVLW  4B
067FA:  ADDWF  x20,W
067FC:  MOVWF  01
067FE:  MOVLW  00
06800:  ADDWFC x21,W
06802:  MOVWF  03
06804:  MOVF   01,W
06806:  ADDLW  EB
06808:  MOVWF  01
0680A:  MOVLW  01
0680C:  ADDWFC 03,F
0680E:  MOVFF  01,70C
06812:  MOVFF  03,70D
06816:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06818:  MOVFF  70F,742
0681C:  MOVFF  70E,741
06820:  MOVFF  70D,744
06824:  MOVFF  70C,743
06828:  CALL   5B14
0682C:  MOVF   01,F
0682E:  BNZ   6848
06830:  MOVLW  01
06832:  MOVLB  7
06834:  SUBWF  x0B,W
06836:  MOVWF  x20
06838:  MOVWF  x22
0683A:  CLRF   x23
0683C:  CLRF   x25
0683E:  MOVLW  71
06840:  MOVWF  x24
06842:  MOVLB  0
06844:  RCALL  62EC
06846:  BRA    6880
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06848:  MOVFF  718,742
0684C:  MOVFF  717,741
06850:  MOVFF  70D,744
06854:  MOVFF  70C,743
06858:  CALL   5B14
0685C:  MOVF   01,F
0685E:  BNZ   687A
06860:  MOVLW  01
06862:  MOVLB  7
06864:  SUBWF  x0B,W
06866:  MOVWF  x20
06868:  MOVWF  x22
0686A:  MOVLW  01
0686C:  MOVWF  x23
0686E:  CLRF   x25
06870:  MOVLW  71
06872:  MOVWF  x24
06874:  MOVLB  0
06876:  RCALL  62EC
06878:  BRA    6880
....................    else return INV_PARAM;
0687A:  MOVLW  02
0687C:  MOVWF  01
0687E:  BRA    6884
....................    
....................    return SUCCESS;
06880:  MOVLW  00
06882:  MOVWF  01
06884:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06886:  MOVLB  7
06888:  CLRF   x42
0688A:  MOVFF  690,741
0688E:  CLRF   x44
06890:  MOVLW  B5
06892:  MOVWF  x43
06894:  MOVLB  0
06896:  CALL   08BE
0689A:  MOVFF  02,70E
0689E:  MOVFF  01,70D
068A2:  MOVLW  06
068A4:  MOVLB  7
068A6:  ADDWF  x0D,F
068A8:  MOVLW  00
068AA:  ADDWFC x0E,F
068AC:  MOVLW  32
068AE:  ADDWF  x0D,W
068B0:  MOVWF  01
068B2:  MOVLW  00
068B4:  ADDWFC x0E,W
068B6:  MOVWF  03
068B8:  MOVF   01,W
068BA:  ADDLW  EB
068BC:  MOVWF  01
068BE:  MOVLW  01
068C0:  ADDWFC 03,F
068C2:  MOVFF  01,70D
068C6:  MOVFF  03,70E
068CA:  MOVFF  03,734
068CE:  MOVFF  01,733
068D2:  MOVLB  0
068D4:  CALL   5C34
068D8:  MOVF   01,F
068DA:  BNZ   68E4
068DC:  MOVLW  02
068DE:  MOVWF  01
068E0:  BRA    6D46
068E2:  BRA    6942
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
068E4:  MOVLB  7
068E6:  CLRF   x42
068E8:  MOVFF  690,741
068EC:  CLRF   x44
068EE:  MOVLW  B5
068F0:  MOVWF  x43
068F2:  MOVLB  0
068F4:  CALL   08BE
068F8:  MOVFF  02,70E
068FC:  MOVFF  01,70D
06900:  MOVLW  06
06902:  MOVLB  7
06904:  ADDWF  x0D,F
06906:  MOVLW  00
06908:  ADDWFC x0E,F
0690A:  MOVLW  32
0690C:  ADDWF  x0D,W
0690E:  MOVWF  01
06910:  MOVLW  00
06912:  ADDWFC x0E,W
06914:  MOVWF  03
06916:  MOVF   01,W
06918:  ADDLW  EB
0691A:  MOVWF  01
0691C:  MOVLW  01
0691E:  ADDWFC 03,F
06920:  MOVFF  01,70D
06924:  MOVFF  03,70E
06928:  MOVFF  03,734
0692C:  MOVFF  01,733
06930:  CLRF   x36
06932:  CLRF   x35
06934:  MOVLW  0A
06936:  MOVWF  x37
06938:  MOVLB  0
0693A:  CALL   5D24
0693E:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06942:  MOVLB  7
06944:  CLRF   x42
06946:  MOVFF  690,741
0694A:  CLRF   x44
0694C:  MOVLW  B5
0694E:  MOVWF  x43
06950:  MOVLB  0
06952:  CALL   08BE
06956:  MOVFF  02,70E
0695A:  MOVFF  01,70D
0695E:  MOVLW  06
06960:  MOVLB  7
06962:  ADDWF  x0D,F
06964:  MOVLW  00
06966:  ADDWFC x0E,F
06968:  MOVLW  4B
0696A:  ADDWF  x0D,W
0696C:  MOVWF  01
0696E:  MOVLW  00
06970:  ADDWFC x0E,W
06972:  MOVWF  03
06974:  MOVF   01,W
06976:  ADDLW  EB
06978:  MOVWF  01
0697A:  MOVLW  01
0697C:  ADDWFC 03,F
0697E:  MOVFF  01,70D
06982:  MOVFF  03,70E
06986:  MOVFF  03,742
0698A:  MOVFF  01,741
0698E:  MOVLB  0
06990:  CALL   55A0
06994:  MOVFF  02,03
06998:  MOVF   01,W
0699A:  SUBLW  01
0699C:  BNZ   69A2
0699E:  MOVF   03,F
069A0:  BZ    69AA
069A2:  MOVLW  02
069A4:  MOVWF  01
069A6:  BRA    6D46
069A8:  BRA    69EA
....................    else arg2 = SERcmd[rec].p[3][0];
069AA:  MOVLB  7
069AC:  CLRF   x42
069AE:  MOVFF  690,741
069B2:  CLRF   x44
069B4:  MOVLW  B5
069B6:  MOVWF  x43
069B8:  MOVLB  0
069BA:  CALL   08BE
069BE:  MOVFF  02,70E
069C2:  MOVFF  01,70D
069C6:  MOVLW  06
069C8:  MOVLB  7
069CA:  ADDWF  x0D,F
069CC:  MOVLW  00
069CE:  ADDWFC x0E,F
069D0:  MOVLW  4B
069D2:  ADDWF  x0D,F
069D4:  MOVLW  00
069D6:  ADDWFC x0E,F
069D8:  MOVLW  EB
069DA:  ADDWF  x0D,W
069DC:  MOVWF  FE9
069DE:  MOVLW  01
069E0:  ADDWFC x0E,W
069E2:  MOVWF  FEA
069E4:  MOVFF  FEF,70C
069E8:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
069EA:  MOVLB  7
069EC:  MOVF   x0C,W
069EE:  SUBLW  50
069F0:  BNZ   6A8C
069F2:  MOVLW  04
069F4:  MOVWF  x42
069F6:  MOVLW  C1
069F8:  MOVWF  x41
069FA:  MOVLB  0
069FC:  CALL   55A0
06A00:  MOVFF  02,03
06A04:  MOVF   01,W
06A06:  ADDLW  C1
06A08:  MOVLB  7
06A0A:  MOVWF  x0D
06A0C:  MOVLW  04
06A0E:  ADDWFC 02,W
06A10:  MOVWF  x0E
06A12:  MOVLW  01
06A14:  SUBWF  x0B,W
06A16:  MULLW  28
06A18:  MOVF   FF3,W
06A1A:  CLRF   x10
06A1C:  MOVWF  x0F
06A1E:  MOVLW  20
06A20:  ADDWF  x0F,W
06A22:  MOVWF  FE9
06A24:  MOVLW  00
06A26:  ADDWFC x10,W
06A28:  MOVWF  FEA
06A2A:  MOVFF  FEF,711
06A2E:  MOVFF  FEC,712
06A32:  MOVFF  FEC,713
06A36:  MOVFF  FEC,714
06A3A:  MOVFF  70E,565
06A3E:  MOVFF  70D,564
06A42:  MOVFF  70B,734
06A46:  MOVLW  18
06A48:  MOVWF  x35
06A4A:  MOVLB  0
06A4C:  CALL   6078
06A50:  MOVLW  2C
06A52:  MOVLB  7
06A54:  MOVWF  x50
06A56:  MOVLB  0
06A58:  CALL   55D8
06A5C:  MOVLW  89
06A5E:  MOVWF  FE9
06A60:  MOVFF  714,746
06A64:  MOVFF  713,745
06A68:  MOVFF  712,744
06A6C:  MOVFF  711,743
06A70:  MOVLW  02
06A72:  MOVLB  7
06A74:  MOVWF  x47
06A76:  MOVLB  0
06A78:  CALL   5776
06A7C:  MOVLW  2C
06A7E:  MOVLB  7
06A80:  MOVWF  x50
06A82:  MOVLB  0
06A84:  CALL   55D8
06A88:  BRA    6D42
06A8A:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06A8C:  MOVF   x0C,W
06A8E:  SUBLW  49
06A90:  BNZ   6B34
06A92:  MOVLW  04
06A94:  MOVWF  x42
06A96:  MOVLW  C1
06A98:  MOVWF  x41
06A9A:  MOVLB  0
06A9C:  CALL   55A0
06AA0:  MOVF   01,W
06AA2:  ADDLW  C1
06AA4:  MOVLB  7
06AA6:  MOVWF  x0D
06AA8:  MOVLW  04
06AAA:  ADDWFC 02,W
06AAC:  MOVWF  x0E
06AAE:  MOVLW  01
06AB0:  SUBWF  x0B,W
06AB2:  MULLW  28
06AB4:  MOVF   FF3,W
06AB6:  CLRF   x10
06AB8:  MOVWF  x0F
06ABA:  MOVLW  04
06ABC:  ADDWF  x0F,W
06ABE:  MOVWF  01
06AC0:  MOVLW  00
06AC2:  ADDWFC x10,W
06AC4:  MOVWF  03
06AC6:  MOVF   01,W
06AC8:  ADDLW  20
06ACA:  MOVWF  FE9
06ACC:  MOVLW  00
06ACE:  ADDWFC 03,W
06AD0:  MOVWF  FEA
06AD2:  MOVFF  FEF,70F
06AD6:  MOVFF  FEC,710
06ADA:  MOVFF  FEC,711
06ADE:  MOVFF  FEC,712
06AE2:  MOVFF  70E,565
06AE6:  MOVFF  70D,564
06AEA:  MOVFF  70B,734
06AEE:  MOVLW  18
06AF0:  MOVWF  x35
06AF2:  MOVLB  0
06AF4:  CALL   6078
06AF8:  MOVLW  2C
06AFA:  MOVLB  7
06AFC:  MOVWF  x50
06AFE:  MOVLB  0
06B00:  CALL   55D8
06B04:  MOVLW  89
06B06:  MOVWF  FE9
06B08:  MOVFF  712,746
06B0C:  MOVFF  711,745
06B10:  MOVFF  710,744
06B14:  MOVFF  70F,743
06B18:  MOVLW  02
06B1A:  MOVLB  7
06B1C:  MOVWF  x47
06B1E:  MOVLB  0
06B20:  CALL   5776
06B24:  MOVLW  2C
06B26:  MOVLB  7
06B28:  MOVWF  x50
06B2A:  MOVLB  0
06B2C:  CALL   55D8
06B30:  BRA    6D42
06B32:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06B34:  MOVF   x0C,W
06B36:  SUBLW  44
06B38:  BNZ   6BDC
06B3A:  MOVLW  04
06B3C:  MOVWF  x42
06B3E:  MOVLW  C1
06B40:  MOVWF  x41
06B42:  MOVLB  0
06B44:  CALL   55A0
06B48:  MOVF   01,W
06B4A:  ADDLW  C1
06B4C:  MOVLB  7
06B4E:  MOVWF  x0D
06B50:  MOVLW  04
06B52:  ADDWFC 02,W
06B54:  MOVWF  x0E
06B56:  MOVLW  01
06B58:  SUBWF  x0B,W
06B5A:  MULLW  28
06B5C:  MOVF   FF3,W
06B5E:  CLRF   x10
06B60:  MOVWF  x0F
06B62:  MOVLW  08
06B64:  ADDWF  x0F,W
06B66:  MOVWF  01
06B68:  MOVLW  00
06B6A:  ADDWFC x10,W
06B6C:  MOVWF  03
06B6E:  MOVF   01,W
06B70:  ADDLW  20
06B72:  MOVWF  FE9
06B74:  MOVLW  00
06B76:  ADDWFC 03,W
06B78:  MOVWF  FEA
06B7A:  MOVFF  FEF,70F
06B7E:  MOVFF  FEC,710
06B82:  MOVFF  FEC,711
06B86:  MOVFF  FEC,712
06B8A:  MOVFF  70E,565
06B8E:  MOVFF  70D,564
06B92:  MOVFF  70B,734
06B96:  MOVLW  18
06B98:  MOVWF  x35
06B9A:  MOVLB  0
06B9C:  CALL   6078
06BA0:  MOVLW  2C
06BA2:  MOVLB  7
06BA4:  MOVWF  x50
06BA6:  MOVLB  0
06BA8:  CALL   55D8
06BAC:  MOVLW  89
06BAE:  MOVWF  FE9
06BB0:  MOVFF  712,746
06BB4:  MOVFF  711,745
06BB8:  MOVFF  710,744
06BBC:  MOVFF  70F,743
06BC0:  MOVLW  02
06BC2:  MOVLB  7
06BC4:  MOVWF  x47
06BC6:  MOVLB  0
06BC8:  CALL   5776
06BCC:  MOVLW  2C
06BCE:  MOVLB  7
06BD0:  MOVWF  x50
06BD2:  MOVLB  0
06BD4:  CALL   55D8
06BD8:  BRA    6D42
06BDA:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06BDC:  MOVF   x0C,W
06BDE:  SUBLW  41
06BE0:  BTFSS  FD8.2
06BE2:  BRA    6D3A
06BE4:  MOVLW  04
06BE6:  MOVWF  x42
06BE8:  MOVLW  C1
06BEA:  MOVWF  x41
06BEC:  MOVLB  0
06BEE:  CALL   55A0
06BF2:  MOVF   01,W
06BF4:  ADDLW  C1
06BF6:  MOVLB  7
06BF8:  MOVWF  x0D
06BFA:  MOVLW  04
06BFC:  ADDWFC 02,W
06BFE:  MOVWF  x0E
06C00:  MOVLW  01
06C02:  SUBWF  x0B,W
06C04:  MULLW  28
06C06:  MOVF   FF3,W
06C08:  CLRF   x10
06C0A:  MOVWF  x0F
06C0C:  MOVLW  20
06C0E:  ADDWF  x0F,W
06C10:  MOVWF  FE9
06C12:  MOVLW  00
06C14:  ADDWFC x10,W
06C16:  MOVWF  FEA
06C18:  MOVFF  FEF,711
06C1C:  MOVFF  FEC,712
06C20:  MOVFF  FEC,713
06C24:  MOVFF  FEC,714
06C28:  MOVLW  01
06C2A:  SUBWF  x0B,W
06C2C:  MULLW  28
06C2E:  MOVF   FF3,W
06C30:  CLRF   x16
06C32:  MOVWF  x15
06C34:  MOVLW  04
06C36:  ADDWF  x15,W
06C38:  MOVWF  01
06C3A:  MOVLW  00
06C3C:  ADDWFC x16,W
06C3E:  MOVWF  03
06C40:  MOVF   01,W
06C42:  ADDLW  20
06C44:  MOVWF  FE9
06C46:  MOVLW  00
06C48:  ADDWFC 03,W
06C4A:  MOVWF  FEA
06C4C:  MOVFF  FEF,715
06C50:  MOVFF  FEC,716
06C54:  MOVFF  FEC,717
06C58:  MOVFF  FEC,718
06C5C:  MOVLW  01
06C5E:  SUBWF  x0B,W
06C60:  MULLW  28
06C62:  MOVF   FF3,W
06C64:  CLRF   x1A
06C66:  MOVWF  x19
06C68:  MOVLW  08
06C6A:  ADDWF  x19,W
06C6C:  MOVWF  01
06C6E:  MOVLW  00
06C70:  ADDWFC x1A,W
06C72:  MOVWF  03
06C74:  MOVF   01,W
06C76:  ADDLW  20
06C78:  MOVWF  FE9
06C7A:  MOVLW  00
06C7C:  ADDWFC 03,W
06C7E:  MOVWF  FEA
06C80:  MOVFF  FEF,719
06C84:  MOVFF  FEC,71A
06C88:  MOVFF  FEC,71B
06C8C:  MOVFF  FEC,71C
06C90:  MOVFF  70E,565
06C94:  MOVFF  70D,564
06C98:  MOVFF  70B,734
06C9C:  MOVLW  18
06C9E:  MOVWF  x35
06CA0:  MOVLB  0
06CA2:  CALL   6078
06CA6:  MOVLW  2C
06CA8:  MOVLB  7
06CAA:  MOVWF  x50
06CAC:  MOVLB  0
06CAE:  CALL   55D8
06CB2:  MOVLW  89
06CB4:  MOVWF  FE9
06CB6:  MOVFF  714,746
06CBA:  MOVFF  713,745
06CBE:  MOVFF  712,744
06CC2:  MOVFF  711,743
06CC6:  MOVLW  02
06CC8:  MOVLB  7
06CCA:  MOVWF  x47
06CCC:  MOVLB  0
06CCE:  CALL   5776
06CD2:  MOVLW  2C
06CD4:  MOVLB  7
06CD6:  MOVWF  x50
06CD8:  MOVLB  0
06CDA:  CALL   55D8
06CDE:  MOVLW  89
06CE0:  MOVWF  FE9
06CE2:  MOVFF  718,746
06CE6:  MOVFF  717,745
06CEA:  MOVFF  716,744
06CEE:  MOVFF  715,743
06CF2:  MOVLW  02
06CF4:  MOVLB  7
06CF6:  MOVWF  x47
06CF8:  MOVLB  0
06CFA:  CALL   5776
06CFE:  MOVLW  2C
06D00:  MOVLB  7
06D02:  MOVWF  x50
06D04:  MOVLB  0
06D06:  CALL   55D8
06D0A:  MOVLW  89
06D0C:  MOVWF  FE9
06D0E:  MOVFF  71C,746
06D12:  MOVFF  71B,745
06D16:  MOVFF  71A,744
06D1A:  MOVFF  719,743
06D1E:  MOVLW  02
06D20:  MOVLB  7
06D22:  MOVWF  x47
06D24:  MOVLB  0
06D26:  CALL   5776
06D2A:  MOVLW  2C
06D2C:  MOVLB  7
06D2E:  MOVWF  x50
06D30:  MOVLB  0
06D32:  CALL   55D8
06D36:  BRA    6D42
06D38:  MOVLB  7
....................    else return INV_PARAM;
06D3A:  MOVLW  02
06D3C:  MOVWF  01
06D3E:  MOVLB  0
06D40:  BRA    6D46
....................    
....................    return SUCCESS;
06D42:  MOVLW  00
06D44:  MOVWF  01
06D46:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
07064:  MOVLB  7
07066:  CLRF   x42
07068:  MOVFF  690,741
0706C:  CLRF   x44
0706E:  MOVLW  B5
07070:  MOVWF  x43
07072:  MOVLB  0
07074:  CALL   08BE
07078:  MOVFF  02,712
0707C:  MOVFF  01,711
07080:  MOVLW  06
07082:  MOVLB  7
07084:  ADDWF  x11,F
07086:  MOVLW  00
07088:  ADDWFC x12,F
0708A:  MOVLW  32
0708C:  ADDWF  x11,W
0708E:  MOVWF  01
07090:  MOVLW  00
07092:  ADDWFC x12,W
07094:  MOVWF  03
07096:  MOVF   01,W
07098:  ADDLW  EB
0709A:  MOVWF  01
0709C:  MOVLW  01
0709E:  ADDWFC 03,F
070A0:  MOVFF  01,711
070A4:  MOVFF  03,712
070A8:  MOVFF  03,734
070AC:  MOVFF  01,733
070B0:  MOVLB  0
070B2:  CALL   5C34
070B6:  MOVF   01,F
070B8:  BNZ   70C2
070BA:  MOVLW  02
070BC:  MOVWF  01
070BE:  BRA    7342
070C0:  BRA    7120
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
070C2:  MOVLB  7
070C4:  CLRF   x42
070C6:  MOVFF  690,741
070CA:  CLRF   x44
070CC:  MOVLW  B5
070CE:  MOVWF  x43
070D0:  MOVLB  0
070D2:  CALL   08BE
070D6:  MOVFF  02,712
070DA:  MOVFF  01,711
070DE:  MOVLW  06
070E0:  MOVLB  7
070E2:  ADDWF  x11,F
070E4:  MOVLW  00
070E6:  ADDWFC x12,F
070E8:  MOVLW  32
070EA:  ADDWF  x11,W
070EC:  MOVWF  01
070EE:  MOVLW  00
070F0:  ADDWFC x12,W
070F2:  MOVWF  03
070F4:  MOVF   01,W
070F6:  ADDLW  EB
070F8:  MOVWF  01
070FA:  MOVLW  01
070FC:  ADDWFC 03,F
070FE:  MOVFF  01,711
07102:  MOVFF  03,712
07106:  MOVFF  03,734
0710A:  MOVFF  01,733
0710E:  CLRF   x36
07110:  CLRF   x35
07112:  MOVLW  0A
07114:  MOVWF  x37
07116:  MOVLB  0
07118:  CALL   5D24
0711C:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07120:  MOVLB  7
07122:  CLRF   x42
07124:  MOVFF  690,741
07128:  CLRF   x44
0712A:  MOVLW  B5
0712C:  MOVWF  x43
0712E:  MOVLB  0
07130:  CALL   08BE
07134:  MOVFF  02,712
07138:  MOVFF  01,711
0713C:  MOVLW  06
0713E:  MOVLB  7
07140:  ADDWF  x11,F
07142:  MOVLW  00
07144:  ADDWFC x12,F
07146:  MOVLW  4B
07148:  ADDWF  x11,W
0714A:  MOVWF  01
0714C:  MOVLW  00
0714E:  ADDWFC x12,W
07150:  MOVWF  03
07152:  MOVF   01,W
07154:  ADDLW  EB
07156:  MOVWF  01
07158:  MOVLW  01
0715A:  ADDWFC 03,F
0715C:  MOVFF  01,711
07160:  MOVFF  03,712
07164:  MOVFF  03,742
07168:  MOVFF  01,741
0716C:  MOVLB  0
0716E:  CALL   55A0
07172:  MOVFF  02,03
07176:  MOVF   01,W
07178:  SUBLW  01
0717A:  BNZ   7180
0717C:  MOVF   03,F
0717E:  BZ    7188
07180:  MOVLW  02
07182:  MOVWF  01
07184:  BRA    7342
07186:  BRA    71C8
....................    else arg2 = SERcmd[rec].p[3][0];
07188:  MOVLB  7
0718A:  CLRF   x42
0718C:  MOVFF  690,741
07190:  CLRF   x44
07192:  MOVLW  B5
07194:  MOVWF  x43
07196:  MOVLB  0
07198:  CALL   08BE
0719C:  MOVFF  02,712
071A0:  MOVFF  01,711
071A4:  MOVLW  06
071A6:  MOVLB  7
071A8:  ADDWF  x11,F
071AA:  MOVLW  00
071AC:  ADDWFC x12,F
071AE:  MOVLW  4B
071B0:  ADDWF  x11,F
071B2:  MOVLW  00
071B4:  ADDWFC x12,F
071B6:  MOVLW  EB
071B8:  ADDWF  x11,W
071BA:  MOVWF  FE9
071BC:  MOVLW  01
071BE:  ADDWFC x12,W
071C0:  MOVWF  FEA
071C2:  MOVFF  FEF,70C
071C6:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
071C8:  MOVLB  7
071CA:  CLRF   x42
071CC:  MOVFF  690,741
071D0:  CLRF   x44
071D2:  MOVLW  B5
071D4:  MOVWF  x43
071D6:  MOVLB  0
071D8:  CALL   08BE
071DC:  MOVFF  02,712
071E0:  MOVFF  01,711
071E4:  MOVLW  06
071E6:  MOVLB  7
071E8:  ADDWF  x11,F
071EA:  MOVLW  00
071EC:  ADDWFC x12,F
071EE:  MOVLW  64
071F0:  ADDWF  x11,W
071F2:  MOVWF  01
071F4:  MOVLW  00
071F6:  ADDWFC x12,W
071F8:  MOVWF  03
071FA:  MOVF   01,W
071FC:  ADDLW  EB
071FE:  MOVWF  01
07200:  MOVLW  01
07202:  ADDWFC 03,F
07204:  MOVFF  01,711
07208:  MOVFF  03,712
0720C:  MOVFF  03,715
07210:  MOVFF  01,714
07214:  MOVLB  0
07216:  RCALL  6D48
07218:  MOVF   01,F
0721A:  BNZ   7224
0721C:  MOVLW  02
0721E:  MOVWF  01
07220:  BRA    7342
07222:  BRA    7288
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07224:  MOVLB  7
07226:  CLRF   x42
07228:  MOVFF  690,741
0722C:  CLRF   x44
0722E:  MOVLW  B5
07230:  MOVWF  x43
07232:  MOVLB  0
07234:  CALL   08BE
07238:  MOVFF  02,712
0723C:  MOVFF  01,711
07240:  MOVLW  06
07242:  MOVLB  7
07244:  ADDWF  x11,F
07246:  MOVLW  00
07248:  ADDWFC x12,F
0724A:  MOVLW  64
0724C:  ADDWF  x11,W
0724E:  MOVWF  01
07250:  MOVLW  00
07252:  ADDWFC x12,W
07254:  MOVWF  03
07256:  MOVF   01,W
07258:  ADDLW  EB
0725A:  MOVWF  01
0725C:  MOVLW  01
0725E:  ADDWFC 03,F
07260:  MOVFF  01,711
07264:  MOVFF  03,712
07268:  MOVFF  03,715
0726C:  MOVFF  01,714
07270:  CLRF   x17
07272:  CLRF   x16
07274:  MOVLB  0
07276:  RCALL  6E0A
07278:  MOVFF  03,710
0727C:  MOVFF  02,70F
07280:  MOVFF  01,70E
07284:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07288:  MOVLB  7
0728A:  MOVF   x0C,W
0728C:  SUBLW  50
0728E:  BNZ   72BA
07290:  MOVLW  01
07292:  SUBWF  x0B,W
07294:  MULLW  28
07296:  MOVF   FF3,W
07298:  CLRF   x12
0729A:  MOVWF  x11
0729C:  MOVLW  20
0729E:  ADDWF  x11,W
072A0:  MOVWF  FE9
072A2:  MOVLW  00
072A4:  ADDWFC x12,W
072A6:  MOVWF  FEA
072A8:  MOVFF  70D,FEF
072AC:  MOVFF  70E,FEC
072B0:  MOVFF  70F,FEC
072B4:  MOVFF  710,FEC
072B8:  BRA    733C
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
072BA:  MOVF   x0C,W
072BC:  SUBLW  49
072BE:  BNZ   72F6
072C0:  MOVLW  01
072C2:  SUBWF  x0B,W
072C4:  MULLW  28
072C6:  MOVF   FF3,W
072C8:  CLRF   x12
072CA:  MOVWF  x11
072CC:  MOVLW  04
072CE:  ADDWF  x11,W
072D0:  MOVWF  01
072D2:  MOVLW  00
072D4:  ADDWFC x12,W
072D6:  MOVWF  03
072D8:  MOVF   01,W
072DA:  ADDLW  20
072DC:  MOVWF  FE9
072DE:  MOVLW  00
072E0:  ADDWFC 03,W
072E2:  MOVWF  FEA
072E4:  MOVFF  70D,FEF
072E8:  MOVFF  70E,FEC
072EC:  MOVFF  70F,FEC
072F0:  MOVFF  710,FEC
072F4:  BRA    733C
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
072F6:  MOVF   x0C,W
072F8:  SUBLW  44
072FA:  BNZ   7332
072FC:  MOVLW  01
072FE:  SUBWF  x0B,W
07300:  MULLW  28
07302:  MOVF   FF3,W
07304:  CLRF   x12
07306:  MOVWF  x11
07308:  MOVLW  08
0730A:  ADDWF  x11,W
0730C:  MOVWF  01
0730E:  MOVLW  00
07310:  ADDWFC x12,W
07312:  MOVWF  03
07314:  MOVF   01,W
07316:  ADDLW  20
07318:  MOVWF  FE9
0731A:  MOVLW  00
0731C:  ADDWFC 03,W
0731E:  MOVWF  FEA
07320:  MOVFF  70D,FEF
07324:  MOVFF  70E,FEC
07328:  MOVFF  70F,FEC
0732C:  MOVFF  710,FEC
07330:  BRA    733C
....................    else return INV_PARAM;
07332:  MOVLW  02
07334:  MOVWF  01
07336:  MOVLB  0
07338:  BRA    7342
0733A:  MOVLB  7
....................    
....................    return SUCCESS;
0733C:  MOVLW  00
0733E:  MOVWF  01
07340:  MOVLB  0
07342:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07344:  MOVLB  7
07346:  CLRF   x42
07348:  MOVFF  690,741
0734C:  CLRF   x44
0734E:  MOVLW  B5
07350:  MOVWF  x43
07352:  MOVLB  0
07354:  CALL   08BE
07358:  MOVFF  02,70D
0735C:  MOVFF  01,70C
07360:  MOVLW  06
07362:  MOVLB  7
07364:  ADDWF  x0C,F
07366:  MOVLW  00
07368:  ADDWFC x0D,F
0736A:  MOVLW  32
0736C:  ADDWF  x0C,W
0736E:  MOVWF  01
07370:  MOVLW  00
07372:  ADDWFC x0D,W
07374:  MOVWF  03
07376:  MOVF   01,W
07378:  ADDLW  EB
0737A:  MOVWF  01
0737C:  MOVLW  01
0737E:  ADDWFC 03,F
07380:  MOVFF  01,70C
07384:  MOVFF  03,70D
07388:  MOVFF  03,734
0738C:  MOVFF  01,733
07390:  MOVLB  0
07392:  CALL   5C34
07396:  MOVF   01,F
07398:  BNZ   73A2
0739A:  MOVLW  02
0739C:  MOVWF  01
0739E:  BRA    74A4
073A0:  BRA    7400
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
073A2:  MOVLB  7
073A4:  CLRF   x42
073A6:  MOVFF  690,741
073AA:  CLRF   x44
073AC:  MOVLW  B5
073AE:  MOVWF  x43
073B0:  MOVLB  0
073B2:  CALL   08BE
073B6:  MOVFF  02,70D
073BA:  MOVFF  01,70C
073BE:  MOVLW  06
073C0:  MOVLB  7
073C2:  ADDWF  x0C,F
073C4:  MOVLW  00
073C6:  ADDWFC x0D,F
073C8:  MOVLW  32
073CA:  ADDWF  x0C,W
073CC:  MOVWF  01
073CE:  MOVLW  00
073D0:  ADDWFC x0D,W
073D2:  MOVWF  03
073D4:  MOVF   01,W
073D6:  ADDLW  EB
073D8:  MOVWF  01
073DA:  MOVLW  01
073DC:  ADDWFC 03,F
073DE:  MOVFF  01,70C
073E2:  MOVFF  03,70D
073E6:  MOVFF  03,734
073EA:  MOVFF  01,733
073EE:  CLRF   x36
073F0:  CLRF   x35
073F2:  MOVLW  0A
073F4:  MOVWF  x37
073F6:  MOVLB  0
073F8:  CALL   5D24
073FC:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07400:  MOVLW  04
07402:  MOVLB  7
07404:  MOVWF  x42
07406:  MOVLW  C1
07408:  MOVWF  x41
0740A:  MOVLB  0
0740C:  CALL   55A0
07410:  MOVF   01,W
07412:  ADDLW  C1
07414:  MOVLB  7
07416:  MOVWF  x0C
07418:  MOVLW  04
0741A:  ADDWFC 02,W
0741C:  MOVWF  x0D
0741E:  MOVLW  01
07420:  SUBWF  x0B,W
07422:  MULLW  28
07424:  MOVF   FF3,W
07426:  CLRF   x0F
07428:  MOVWF  x0E
0742A:  MOVLW  0C
0742C:  ADDWF  x0E,W
0742E:  MOVWF  01
07430:  MOVLW  00
07432:  ADDWFC x0F,W
07434:  MOVWF  03
07436:  MOVF   01,W
07438:  ADDLW  20
0743A:  MOVWF  FE9
0743C:  MOVLW  00
0743E:  ADDWFC 03,W
07440:  MOVWF  FEA
07442:  MOVFF  FEF,70E
07446:  MOVFF  FEC,70F
0744A:  MOVFF  FEC,710
0744E:  MOVFF  FEC,711
07452:  MOVFF  70D,565
07456:  MOVFF  70C,564
0745A:  MOVFF  70B,734
0745E:  MOVLW  18
07460:  MOVWF  x35
07462:  MOVLB  0
07464:  CALL   6078
07468:  MOVLW  2C
0746A:  MOVLB  7
0746C:  MOVWF  x50
0746E:  MOVLB  0
07470:  CALL   55D8
07474:  MOVLW  89
07476:  MOVWF  FE9
07478:  MOVFF  711,746
0747C:  MOVFF  710,745
07480:  MOVFF  70F,744
07484:  MOVFF  70E,743
07488:  MOVLW  02
0748A:  MOVLB  7
0748C:  MOVWF  x47
0748E:  MOVLB  0
07490:  CALL   5776
07494:  MOVLW  2C
07496:  MOVLB  7
07498:  MOVWF  x50
0749A:  MOVLB  0
0749C:  CALL   55D8
....................    return SUCCESS;
074A0:  MOVLW  00
074A2:  MOVWF  01
074A4:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
074A6:  MOVLB  7
074A8:  CLRF   x42
074AA:  MOVFF  690,741
074AE:  CLRF   x44
074B0:  MOVLW  B5
074B2:  MOVWF  x43
074B4:  MOVLB  0
074B6:  CALL   08BE
074BA:  MOVFF  02,711
074BE:  MOVFF  01,710
074C2:  MOVLW  06
074C4:  MOVLB  7
074C6:  ADDWF  x10,F
074C8:  MOVLW  00
074CA:  ADDWFC x11,F
074CC:  MOVLW  32
074CE:  ADDWF  x10,W
074D0:  MOVWF  01
074D2:  MOVLW  00
074D4:  ADDWFC x11,W
074D6:  MOVWF  03
074D8:  MOVF   01,W
074DA:  ADDLW  EB
074DC:  MOVWF  01
074DE:  MOVLW  01
074E0:  ADDWFC 03,F
074E2:  MOVFF  01,710
074E6:  MOVFF  03,711
074EA:  MOVFF  03,734
074EE:  MOVFF  01,733
074F2:  MOVLB  0
074F4:  CALL   5C34
074F8:  MOVF   01,F
074FA:  BNZ   7504
074FC:  MOVLW  02
074FE:  MOVWF  01
07500:  BRA    7662
07502:  BRA    7562
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07504:  MOVLB  7
07506:  CLRF   x42
07508:  MOVFF  690,741
0750C:  CLRF   x44
0750E:  MOVLW  B5
07510:  MOVWF  x43
07512:  MOVLB  0
07514:  CALL   08BE
07518:  MOVFF  02,711
0751C:  MOVFF  01,710
07520:  MOVLW  06
07522:  MOVLB  7
07524:  ADDWF  x10,F
07526:  MOVLW  00
07528:  ADDWFC x11,F
0752A:  MOVLW  32
0752C:  ADDWF  x10,W
0752E:  MOVWF  01
07530:  MOVLW  00
07532:  ADDWFC x11,W
07534:  MOVWF  03
07536:  MOVF   01,W
07538:  ADDLW  EB
0753A:  MOVWF  01
0753C:  MOVLW  01
0753E:  ADDWFC 03,F
07540:  MOVFF  01,710
07544:  MOVFF  03,711
07548:  MOVFF  03,734
0754C:  MOVFF  01,733
07550:  CLRF   x36
07552:  CLRF   x35
07554:  MOVLW  0A
07556:  MOVWF  x37
07558:  MOVLB  0
0755A:  CALL   5D24
0755E:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07562:  MOVLB  7
07564:  CLRF   x42
07566:  MOVFF  690,741
0756A:  CLRF   x44
0756C:  MOVLW  B5
0756E:  MOVWF  x43
07570:  MOVLB  0
07572:  CALL   08BE
07576:  MOVFF  02,711
0757A:  MOVFF  01,710
0757E:  MOVLW  06
07580:  MOVLB  7
07582:  ADDWF  x10,F
07584:  MOVLW  00
07586:  ADDWFC x11,F
07588:  MOVLW  4B
0758A:  ADDWF  x10,W
0758C:  MOVWF  01
0758E:  MOVLW  00
07590:  ADDWFC x11,W
07592:  MOVWF  03
07594:  MOVF   01,W
07596:  ADDLW  EB
07598:  MOVWF  01
0759A:  MOVLW  01
0759C:  ADDWFC 03,F
0759E:  MOVFF  01,710
075A2:  MOVFF  03,711
075A6:  MOVFF  03,715
075AA:  MOVFF  01,714
075AE:  MOVLB  0
075B0:  CALL   6D48
075B4:  MOVF   01,F
075B6:  BNZ   75C0
075B8:  MOVLW  02
075BA:  MOVWF  01
075BC:  BRA    7662
075BE:  BRA    7626
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
075C0:  MOVLB  7
075C2:  CLRF   x42
075C4:  MOVFF  690,741
075C8:  CLRF   x44
075CA:  MOVLW  B5
075CC:  MOVWF  x43
075CE:  MOVLB  0
075D0:  CALL   08BE
075D4:  MOVFF  02,711
075D8:  MOVFF  01,710
075DC:  MOVLW  06
075DE:  MOVLB  7
075E0:  ADDWF  x10,F
075E2:  MOVLW  00
075E4:  ADDWFC x11,F
075E6:  MOVLW  4B
075E8:  ADDWF  x10,W
075EA:  MOVWF  01
075EC:  MOVLW  00
075EE:  ADDWFC x11,W
075F0:  MOVWF  03
075F2:  MOVF   01,W
075F4:  ADDLW  EB
075F6:  MOVWF  01
075F8:  MOVLW  01
075FA:  ADDWFC 03,F
075FC:  MOVFF  01,710
07600:  MOVFF  03,711
07604:  MOVFF  03,715
07608:  MOVFF  01,714
0760C:  CLRF   x17
0760E:  CLRF   x16
07610:  MOVLB  0
07612:  CALL   6E0A
07616:  MOVFF  03,70F
0761A:  MOVFF  02,70E
0761E:  MOVFF  01,70D
07622:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07626:  MOVLW  01
07628:  MOVLB  7
0762A:  SUBWF  x0B,W
0762C:  MULLW  28
0762E:  MOVF   FF3,W
07630:  CLRF   x11
07632:  MOVWF  x10
07634:  MOVLW  0C
07636:  ADDWF  x10,W
07638:  MOVWF  01
0763A:  MOVLW  00
0763C:  ADDWFC x11,W
0763E:  MOVWF  03
07640:  MOVF   01,W
07642:  ADDLW  20
07644:  MOVWF  FE9
07646:  MOVLW  00
07648:  ADDWFC 03,W
0764A:  MOVWF  FEA
0764C:  MOVFF  70C,FEF
07650:  MOVFF  70D,FEC
07654:  MOVFF  70E,FEC
07658:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
0765C:  MOVLW  00
0765E:  MOVWF  01
07660:  MOVLB  0
07662:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07664:  MOVLB  7
07666:  CLRF   x42
07668:  MOVFF  690,741
0766C:  CLRF   x44
0766E:  MOVLW  B5
07670:  MOVWF  x43
07672:  MOVLB  0
07674:  CALL   08BE
07678:  MOVFF  02,70D
0767C:  MOVFF  01,70C
07680:  MOVLW  06
07682:  MOVLB  7
07684:  ADDWF  x0C,F
07686:  MOVLW  00
07688:  ADDWFC x0D,F
0768A:  MOVLW  32
0768C:  ADDWF  x0C,W
0768E:  MOVWF  01
07690:  MOVLW  00
07692:  ADDWFC x0D,W
07694:  MOVWF  03
07696:  MOVF   01,W
07698:  ADDLW  EB
0769A:  MOVWF  01
0769C:  MOVLW  01
0769E:  ADDWFC 03,F
076A0:  MOVFF  01,70C
076A4:  MOVFF  03,70D
076A8:  MOVFF  03,734
076AC:  MOVFF  01,733
076B0:  MOVLB  0
076B2:  CALL   5C34
076B6:  MOVF   01,F
076B8:  BNZ   76C2
076BA:  MOVLW  02
076BC:  MOVWF  01
076BE:  BRA    7A18
076C0:  BRA    7720
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
076C2:  MOVLB  7
076C4:  CLRF   x42
076C6:  MOVFF  690,741
076CA:  CLRF   x44
076CC:  MOVLW  B5
076CE:  MOVWF  x43
076D0:  MOVLB  0
076D2:  CALL   08BE
076D6:  MOVFF  02,70D
076DA:  MOVFF  01,70C
076DE:  MOVLW  06
076E0:  MOVLB  7
076E2:  ADDWF  x0C,F
076E4:  MOVLW  00
076E6:  ADDWFC x0D,F
076E8:  MOVLW  32
076EA:  ADDWF  x0C,W
076EC:  MOVWF  01
076EE:  MOVLW  00
076F0:  ADDWFC x0D,W
076F2:  MOVWF  03
076F4:  MOVF   01,W
076F6:  ADDLW  EB
076F8:  MOVWF  01
076FA:  MOVLW  01
076FC:  ADDWFC 03,F
076FE:  MOVFF  01,70C
07702:  MOVFF  03,70D
07706:  MOVFF  03,734
0770A:  MOVFF  01,733
0770E:  CLRF   x36
07710:  CLRF   x35
07712:  MOVLW  0A
07714:  MOVWF  x37
07716:  MOVLB  0
07718:  CALL   5D24
0771C:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07720:  MOVLW  04
07722:  MOVLB  7
07724:  MOVWF  x42
07726:  MOVLW  C1
07728:  MOVWF  x41
0772A:  MOVLB  0
0772C:  CALL   55A0
07730:  MOVFF  02,03
07734:  MOVF   01,W
07736:  ADDLW  C1
07738:  MOVLB  7
0773A:  MOVWF  x0C
0773C:  MOVLW  04
0773E:  ADDWFC 02,W
07740:  MOVWF  x0D
07742:  MOVFF  FE8,565
07746:  MOVFF  70C,564
0774A:  MOVFF  70B,734
0774E:  MOVLW  18
07750:  MOVWF  x35
07752:  MOVLB  0
07754:  CALL   6078
07758:  MOVLW  2C
0775A:  MOVLB  7
0775C:  MOVWF  x50
0775E:  MOVLB  0
07760:  CALL   55D8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07764:  MOVLW  04
07766:  MOVLB  7
07768:  MOVWF  x42
0776A:  MOVLW  C1
0776C:  MOVWF  x41
0776E:  MOVLB  0
07770:  CALL   55A0
07774:  MOVFF  02,03
07778:  MOVF   01,W
0777A:  ADDLW  C1
0777C:  MOVLB  7
0777E:  MOVWF  x0C
07780:  MOVLW  04
07782:  ADDWFC 02,W
07784:  MOVWF  x0D
07786:  MOVLW  01
07788:  SUBWF  x0B,W
0778A:  MULLW  18
0778C:  MOVF   FF3,W
0778E:  CLRF   x0F
07790:  MOVWF  x0E
07792:  MOVLW  92
07794:  ADDWF  x0E,W
07796:  MOVWF  FE9
07798:  MOVLW  00
0779A:  ADDWFC x0F,W
0779C:  MOVWF  FEA
0779E:  MOVFF  FEF,743
077A2:  MOVFF  FEC,744
077A6:  MOVFF  FEC,745
077AA:  MOVFF  FEC,746
077AE:  MOVFF  70D,565
077B2:  MOVFF  70C,564
077B6:  MOVLW  89
077B8:  MOVWF  FE9
077BA:  MOVLW  02
077BC:  MOVWF  x47
077BE:  MOVLB  0
077C0:  CALL   5776
077C4:  MOVLW  2C
077C6:  MOVLB  7
077C8:  MOVWF  x50
077CA:  MOVLB  0
077CC:  CALL   55D8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
077D0:  MOVLW  04
077D2:  MOVLB  7
077D4:  MOVWF  x42
077D6:  MOVLW  C1
077D8:  MOVWF  x41
077DA:  MOVLB  0
077DC:  CALL   55A0
077E0:  MOVF   01,W
077E2:  ADDLW  C1
077E4:  MOVLB  7
077E6:  MOVWF  x0C
077E8:  MOVLW  04
077EA:  ADDWFC 02,W
077EC:  MOVWF  x0D
077EE:  MOVLW  01
077F0:  SUBWF  x0B,W
077F2:  MULLW  18
077F4:  MOVF   FF3,W
077F6:  CLRF   x0F
077F8:  MOVWF  x0E
077FA:  MOVLW  04
077FC:  ADDWF  x0E,W
077FE:  MOVWF  01
07800:  MOVLW  00
07802:  ADDWFC x0F,W
07804:  MOVWF  03
07806:  MOVF   01,W
07808:  ADDLW  92
0780A:  MOVWF  FE9
0780C:  MOVLW  00
0780E:  ADDWFC 03,W
07810:  MOVWF  FEA
07812:  MOVFF  FEF,743
07816:  MOVFF  FEC,744
0781A:  MOVFF  FEC,745
0781E:  MOVFF  FEC,746
07822:  MOVFF  70D,565
07826:  MOVFF  70C,564
0782A:  MOVLW  89
0782C:  MOVWF  FE9
0782E:  MOVLW  02
07830:  MOVWF  x47
07832:  MOVLB  0
07834:  CALL   5776
07838:  MOVLW  2C
0783A:  MOVLB  7
0783C:  MOVWF  x50
0783E:  MOVLB  0
07840:  CALL   55D8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07844:  MOVLW  04
07846:  MOVLB  7
07848:  MOVWF  x42
0784A:  MOVLW  C1
0784C:  MOVWF  x41
0784E:  MOVLB  0
07850:  CALL   55A0
07854:  MOVF   01,W
07856:  ADDLW  C1
07858:  MOVLB  7
0785A:  MOVWF  x0C
0785C:  MOVLW  04
0785E:  ADDWFC 02,W
07860:  MOVWF  x0D
07862:  MOVLW  01
07864:  SUBWF  x0B,W
07866:  MULLW  18
07868:  MOVF   FF3,W
0786A:  CLRF   x0F
0786C:  MOVWF  x0E
0786E:  MOVLW  08
07870:  ADDWF  x0E,W
07872:  MOVWF  01
07874:  MOVLW  00
07876:  ADDWFC x0F,W
07878:  MOVWF  03
0787A:  MOVF   01,W
0787C:  ADDLW  92
0787E:  MOVWF  FE9
07880:  MOVLW  00
07882:  ADDWFC 03,W
07884:  MOVWF  FEA
07886:  MOVFF  FEF,743
0788A:  MOVFF  FEC,744
0788E:  MOVFF  FEC,745
07892:  MOVFF  FEC,746
07896:  MOVFF  70D,565
0789A:  MOVFF  70C,564
0789E:  MOVLW  89
078A0:  MOVWF  FE9
078A2:  MOVLW  02
078A4:  MOVWF  x47
078A6:  MOVLB  0
078A8:  CALL   5776
078AC:  MOVLW  2C
078AE:  MOVLB  7
078B0:  MOVWF  x50
078B2:  MOVLB  0
078B4:  CALL   55D8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
078B8:  MOVLW  04
078BA:  MOVLB  7
078BC:  MOVWF  x42
078BE:  MOVLW  C1
078C0:  MOVWF  x41
078C2:  MOVLB  0
078C4:  CALL   55A0
078C8:  MOVF   01,W
078CA:  ADDLW  C1
078CC:  MOVLB  7
078CE:  MOVWF  x0C
078D0:  MOVLW  04
078D2:  ADDWFC 02,W
078D4:  MOVWF  x0D
078D6:  MOVLW  01
078D8:  SUBWF  x0B,W
078DA:  MULLW  18
078DC:  MOVF   FF3,W
078DE:  CLRF   x0F
078E0:  MOVWF  x0E
078E2:  MOVLW  0C
078E4:  ADDWF  x0E,W
078E6:  MOVWF  01
078E8:  MOVLW  00
078EA:  ADDWFC x0F,W
078EC:  MOVWF  03
078EE:  MOVF   01,W
078F0:  ADDLW  92
078F2:  MOVWF  FE9
078F4:  MOVLW  00
078F6:  ADDWFC 03,W
078F8:  MOVWF  FEA
078FA:  MOVFF  FEF,743
078FE:  MOVFF  FEC,744
07902:  MOVFF  FEC,745
07906:  MOVFF  FEC,746
0790A:  MOVFF  70D,565
0790E:  MOVFF  70C,564
07912:  MOVLW  89
07914:  MOVWF  FE9
07916:  MOVLW  02
07918:  MOVWF  x47
0791A:  MOVLB  0
0791C:  CALL   5776
07920:  MOVLW  2C
07922:  MOVLB  7
07924:  MOVWF  x50
07926:  MOVLB  0
07928:  CALL   55D8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
0792C:  MOVLW  04
0792E:  MOVLB  7
07930:  MOVWF  x42
07932:  MOVLW  C1
07934:  MOVWF  x41
07936:  MOVLB  0
07938:  CALL   55A0
0793C:  MOVF   01,W
0793E:  ADDLW  C1
07940:  MOVLB  7
07942:  MOVWF  x0C
07944:  MOVLW  04
07946:  ADDWFC 02,W
07948:  MOVWF  x0D
0794A:  MOVLW  01
0794C:  SUBWF  x0B,W
0794E:  MULLW  18
07950:  MOVF   FF3,W
07952:  CLRF   x0F
07954:  MOVWF  x0E
07956:  MOVLW  10
07958:  ADDWF  x0E,W
0795A:  MOVWF  01
0795C:  MOVLW  00
0795E:  ADDWFC x0F,W
07960:  MOVWF  03
07962:  MOVF   01,W
07964:  ADDLW  92
07966:  MOVWF  FE9
07968:  MOVLW  00
0796A:  ADDWFC 03,W
0796C:  MOVWF  FEA
0796E:  MOVFF  FEF,743
07972:  MOVFF  FEC,744
07976:  MOVFF  FEC,745
0797A:  MOVFF  FEC,746
0797E:  MOVFF  70D,565
07982:  MOVFF  70C,564
07986:  MOVLW  89
07988:  MOVWF  FE9
0798A:  MOVLW  02
0798C:  MOVWF  x47
0798E:  MOVLB  0
07990:  CALL   5776
07994:  MOVLW  2C
07996:  MOVLB  7
07998:  MOVWF  x50
0799A:  MOVLB  0
0799C:  CALL   55D8
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
079A0:  MOVLW  04
079A2:  MOVLB  7
079A4:  MOVWF  x42
079A6:  MOVLW  C1
079A8:  MOVWF  x41
079AA:  MOVLB  0
079AC:  CALL   55A0
079B0:  MOVF   01,W
079B2:  ADDLW  C1
079B4:  MOVLB  7
079B6:  MOVWF  x0C
079B8:  MOVLW  04
079BA:  ADDWFC 02,W
079BC:  MOVWF  x0D
079BE:  MOVLW  01
079C0:  SUBWF  x0B,W
079C2:  MULLW  18
079C4:  MOVF   FF3,W
079C6:  CLRF   x0F
079C8:  MOVWF  x0E
079CA:  MOVLW  14
079CC:  ADDWF  x0E,W
079CE:  MOVWF  01
079D0:  MOVLW  00
079D2:  ADDWFC x0F,W
079D4:  MOVWF  03
079D6:  MOVF   01,W
079D8:  ADDLW  92
079DA:  MOVWF  FE9
079DC:  MOVLW  00
079DE:  ADDWFC 03,W
079E0:  MOVWF  FEA
079E2:  MOVFF  FEF,743
079E6:  MOVFF  FEC,744
079EA:  MOVFF  FEC,745
079EE:  MOVFF  FEC,746
079F2:  MOVFF  70D,565
079F6:  MOVFF  70C,564
079FA:  MOVLW  89
079FC:  MOVWF  FE9
079FE:  MOVLW  02
07A00:  MOVWF  x47
07A02:  MOVLB  0
07A04:  CALL   5776
07A08:  MOVLW  2C
07A0A:  MOVLB  7
07A0C:  MOVWF  x50
07A0E:  MOVLB  0
07A10:  CALL   55D8
....................    
....................    return SUCCESS;
07A14:  MOVLW  00
07A16:  MOVWF  01
07A18:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07A1A:  MOVLB  7
07A1C:  CLRF   x42
07A1E:  MOVFF  690,741
07A22:  CLRF   x44
07A24:  MOVLW  B5
07A26:  MOVWF  x43
07A28:  MOVLB  0
07A2A:  CALL   08BE
07A2E:  MOVFF  02,70E
07A32:  MOVFF  01,70D
07A36:  MOVLW  06
07A38:  MOVLB  7
07A3A:  ADDWF  x0D,F
07A3C:  MOVLW  00
07A3E:  ADDWFC x0E,F
07A40:  MOVLW  32
07A42:  ADDWF  x0D,W
07A44:  MOVWF  01
07A46:  MOVLW  00
07A48:  ADDWFC x0E,W
07A4A:  MOVWF  03
07A4C:  MOVF   01,W
07A4E:  ADDLW  EB
07A50:  MOVWF  01
07A52:  MOVLW  01
07A54:  ADDWFC 03,F
07A56:  MOVFF  01,70D
07A5A:  MOVFF  03,70E
07A5E:  MOVFF  03,734
07A62:  MOVFF  01,733
07A66:  MOVLB  0
07A68:  CALL   5C34
07A6C:  MOVF   01,F
07A6E:  BNZ   7A78
07A70:  MOVLW  02
07A72:  MOVWF  01
07A74:  BRA    7F74
07A76:  BRA    7AD6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07A78:  MOVLB  7
07A7A:  CLRF   x42
07A7C:  MOVFF  690,741
07A80:  CLRF   x44
07A82:  MOVLW  B5
07A84:  MOVWF  x43
07A86:  MOVLB  0
07A88:  CALL   08BE
07A8C:  MOVFF  02,70E
07A90:  MOVFF  01,70D
07A94:  MOVLW  06
07A96:  MOVLB  7
07A98:  ADDWF  x0D,F
07A9A:  MOVLW  00
07A9C:  ADDWFC x0E,F
07A9E:  MOVLW  32
07AA0:  ADDWF  x0D,W
07AA2:  MOVWF  01
07AA4:  MOVLW  00
07AA6:  ADDWFC x0E,W
07AA8:  MOVWF  03
07AAA:  MOVF   01,W
07AAC:  ADDLW  EB
07AAE:  MOVWF  01
07AB0:  MOVLW  01
07AB2:  ADDWFC 03,F
07AB4:  MOVFF  01,70D
07AB8:  MOVFF  03,70E
07ABC:  MOVFF  03,734
07AC0:  MOVFF  01,733
07AC4:  CLRF   x36
07AC6:  CLRF   x35
07AC8:  MOVLW  0A
07ACA:  MOVWF  x37
07ACC:  MOVLB  0
07ACE:  CALL   5D24
07AD2:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07AD6:  MOVLB  7
07AD8:  CLRF   x42
07ADA:  MOVFF  690,741
07ADE:  CLRF   x44
07AE0:  MOVLW  B5
07AE2:  MOVWF  x43
07AE4:  MOVLB  0
07AE6:  CALL   08BE
07AEA:  MOVFF  02,70E
07AEE:  MOVFF  01,70D
07AF2:  MOVLW  06
07AF4:  MOVLB  7
07AF6:  ADDWF  x0D,F
07AF8:  MOVLW  00
07AFA:  ADDWFC x0E,F
07AFC:  MOVLW  4B
07AFE:  ADDWF  x0D,W
07B00:  MOVWF  01
07B02:  MOVLW  00
07B04:  ADDWFC x0E,W
07B06:  MOVWF  03
07B08:  MOVF   01,W
07B0A:  ADDLW  EB
07B0C:  MOVWF  01
07B0E:  MOVLW  01
07B10:  ADDWFC 03,F
07B12:  MOVFF  01,70D
07B16:  MOVFF  03,70E
07B1A:  MOVFF  03,742
07B1E:  MOVFF  01,741
07B22:  MOVLB  0
07B24:  CALL   55A0
07B28:  MOVFF  02,03
07B2C:  MOVF   01,W
07B2E:  SUBLW  01
07B30:  BNZ   7B36
07B32:  MOVF   03,F
07B34:  BZ    7B3E
07B36:  MOVLW  02
07B38:  MOVWF  01
07B3A:  BRA    7F74
07B3C:  BRA    7B7E
....................    else arg2 = SERcmd[rec].p[3][0];
07B3E:  MOVLB  7
07B40:  CLRF   x42
07B42:  MOVFF  690,741
07B46:  CLRF   x44
07B48:  MOVLW  B5
07B4A:  MOVWF  x43
07B4C:  MOVLB  0
07B4E:  CALL   08BE
07B52:  MOVFF  02,70E
07B56:  MOVFF  01,70D
07B5A:  MOVLW  06
07B5C:  MOVLB  7
07B5E:  ADDWF  x0D,F
07B60:  MOVLW  00
07B62:  ADDWFC x0E,F
07B64:  MOVLW  4B
07B66:  ADDWF  x0D,F
07B68:  MOVLW  00
07B6A:  ADDWFC x0E,F
07B6C:  MOVLW  EB
07B6E:  ADDWF  x0D,W
07B70:  MOVWF  FE9
07B72:  MOVLW  01
07B74:  ADDWFC x0E,W
07B76:  MOVWF  FEA
07B78:  MOVFF  FEF,70C
07B7C:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07B7E:  MOVLB  7
07B80:  MOVF   x0C,W
07B82:  SUBLW  30
07B84:  BNZ   7C20
07B86:  MOVLW  04
07B88:  MOVWF  x42
07B8A:  MOVLW  C1
07B8C:  MOVWF  x41
07B8E:  MOVLB  0
07B90:  CALL   55A0
07B94:  MOVFF  02,03
07B98:  MOVF   01,W
07B9A:  ADDLW  C1
07B9C:  MOVLB  7
07B9E:  MOVWF  x0D
07BA0:  MOVLW  04
07BA2:  ADDWFC 02,W
07BA4:  MOVWF  x0E
07BA6:  MOVLW  01
07BA8:  SUBWF  x0B,W
07BAA:  MULLW  18
07BAC:  MOVF   FF3,W
07BAE:  CLRF   x10
07BB0:  MOVWF  x0F
07BB2:  MOVLW  92
07BB4:  ADDWF  x0F,W
07BB6:  MOVWF  FE9
07BB8:  MOVLW  00
07BBA:  ADDWFC x10,W
07BBC:  MOVWF  FEA
07BBE:  MOVFF  FEF,711
07BC2:  MOVFF  FEC,712
07BC6:  MOVFF  FEC,713
07BCA:  MOVFF  FEC,714
07BCE:  MOVFF  70E,565
07BD2:  MOVFF  70D,564
07BD6:  MOVFF  70B,734
07BDA:  MOVLW  18
07BDC:  MOVWF  x35
07BDE:  MOVLB  0
07BE0:  CALL   6078
07BE4:  MOVLW  2C
07BE6:  MOVLB  7
07BE8:  MOVWF  x50
07BEA:  MOVLB  0
07BEC:  CALL   55D8
07BF0:  MOVLW  89
07BF2:  MOVWF  FE9
07BF4:  MOVFF  714,746
07BF8:  MOVFF  713,745
07BFC:  MOVFF  712,744
07C00:  MOVFF  711,743
07C04:  MOVLW  02
07C06:  MOVLB  7
07C08:  MOVWF  x47
07C0A:  MOVLB  0
07C0C:  CALL   5776
07C10:  MOVLW  2C
07C12:  MOVLB  7
07C14:  MOVWF  x50
07C16:  MOVLB  0
07C18:  CALL   55D8
07C1C:  BRA    7F70
07C1E:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07C20:  MOVF   x0C,W
07C22:  SUBLW  31
07C24:  BNZ   7CC8
07C26:  MOVLW  04
07C28:  MOVWF  x42
07C2A:  MOVLW  C1
07C2C:  MOVWF  x41
07C2E:  MOVLB  0
07C30:  CALL   55A0
07C34:  MOVF   01,W
07C36:  ADDLW  C1
07C38:  MOVLB  7
07C3A:  MOVWF  x0D
07C3C:  MOVLW  04
07C3E:  ADDWFC 02,W
07C40:  MOVWF  x0E
07C42:  MOVLW  01
07C44:  SUBWF  x0B,W
07C46:  MULLW  18
07C48:  MOVF   FF3,W
07C4A:  CLRF   x10
07C4C:  MOVWF  x0F
07C4E:  MOVLW  04
07C50:  ADDWF  x0F,W
07C52:  MOVWF  01
07C54:  MOVLW  00
07C56:  ADDWFC x10,W
07C58:  MOVWF  03
07C5A:  MOVF   01,W
07C5C:  ADDLW  92
07C5E:  MOVWF  FE9
07C60:  MOVLW  00
07C62:  ADDWFC 03,W
07C64:  MOVWF  FEA
07C66:  MOVFF  FEF,70F
07C6A:  MOVFF  FEC,710
07C6E:  MOVFF  FEC,711
07C72:  MOVFF  FEC,712
07C76:  MOVFF  70E,565
07C7A:  MOVFF  70D,564
07C7E:  MOVFF  70B,734
07C82:  MOVLW  18
07C84:  MOVWF  x35
07C86:  MOVLB  0
07C88:  CALL   6078
07C8C:  MOVLW  2C
07C8E:  MOVLB  7
07C90:  MOVWF  x50
07C92:  MOVLB  0
07C94:  CALL   55D8
07C98:  MOVLW  89
07C9A:  MOVWF  FE9
07C9C:  MOVFF  712,746
07CA0:  MOVFF  711,745
07CA4:  MOVFF  710,744
07CA8:  MOVFF  70F,743
07CAC:  MOVLW  02
07CAE:  MOVLB  7
07CB0:  MOVWF  x47
07CB2:  MOVLB  0
07CB4:  CALL   5776
07CB8:  MOVLW  2C
07CBA:  MOVLB  7
07CBC:  MOVWF  x50
07CBE:  MOVLB  0
07CC0:  CALL   55D8
07CC4:  BRA    7F70
07CC6:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07CC8:  MOVF   x0C,W
07CCA:  SUBLW  32
07CCC:  BNZ   7D70
07CCE:  MOVLW  04
07CD0:  MOVWF  x42
07CD2:  MOVLW  C1
07CD4:  MOVWF  x41
07CD6:  MOVLB  0
07CD8:  CALL   55A0
07CDC:  MOVF   01,W
07CDE:  ADDLW  C1
07CE0:  MOVLB  7
07CE2:  MOVWF  x0D
07CE4:  MOVLW  04
07CE6:  ADDWFC 02,W
07CE8:  MOVWF  x0E
07CEA:  MOVLW  01
07CEC:  SUBWF  x0B,W
07CEE:  MULLW  18
07CF0:  MOVF   FF3,W
07CF2:  CLRF   x10
07CF4:  MOVWF  x0F
07CF6:  MOVLW  08
07CF8:  ADDWF  x0F,W
07CFA:  MOVWF  01
07CFC:  MOVLW  00
07CFE:  ADDWFC x10,W
07D00:  MOVWF  03
07D02:  MOVF   01,W
07D04:  ADDLW  92
07D06:  MOVWF  FE9
07D08:  MOVLW  00
07D0A:  ADDWFC 03,W
07D0C:  MOVWF  FEA
07D0E:  MOVFF  FEF,70F
07D12:  MOVFF  FEC,710
07D16:  MOVFF  FEC,711
07D1A:  MOVFF  FEC,712
07D1E:  MOVFF  70E,565
07D22:  MOVFF  70D,564
07D26:  MOVFF  70B,734
07D2A:  MOVLW  18
07D2C:  MOVWF  x35
07D2E:  MOVLB  0
07D30:  CALL   6078
07D34:  MOVLW  2C
07D36:  MOVLB  7
07D38:  MOVWF  x50
07D3A:  MOVLB  0
07D3C:  CALL   55D8
07D40:  MOVLW  89
07D42:  MOVWF  FE9
07D44:  MOVFF  712,746
07D48:  MOVFF  711,745
07D4C:  MOVFF  710,744
07D50:  MOVFF  70F,743
07D54:  MOVLW  02
07D56:  MOVLB  7
07D58:  MOVWF  x47
07D5A:  MOVLB  0
07D5C:  CALL   5776
07D60:  MOVLW  2C
07D62:  MOVLB  7
07D64:  MOVWF  x50
07D66:  MOVLB  0
07D68:  CALL   55D8
07D6C:  BRA    7F70
07D6E:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07D70:  MOVF   x0C,W
07D72:  SUBLW  33
07D74:  BNZ   7E18
07D76:  MOVLW  04
07D78:  MOVWF  x42
07D7A:  MOVLW  C1
07D7C:  MOVWF  x41
07D7E:  MOVLB  0
07D80:  CALL   55A0
07D84:  MOVF   01,W
07D86:  ADDLW  C1
07D88:  MOVLB  7
07D8A:  MOVWF  x0D
07D8C:  MOVLW  04
07D8E:  ADDWFC 02,W
07D90:  MOVWF  x0E
07D92:  MOVLW  01
07D94:  SUBWF  x0B,W
07D96:  MULLW  18
07D98:  MOVF   FF3,W
07D9A:  CLRF   x10
07D9C:  MOVWF  x0F
07D9E:  MOVLW  0C
07DA0:  ADDWF  x0F,W
07DA2:  MOVWF  01
07DA4:  MOVLW  00
07DA6:  ADDWFC x10,W
07DA8:  MOVWF  03
07DAA:  MOVF   01,W
07DAC:  ADDLW  92
07DAE:  MOVWF  FE9
07DB0:  MOVLW  00
07DB2:  ADDWFC 03,W
07DB4:  MOVWF  FEA
07DB6:  MOVFF  FEF,70F
07DBA:  MOVFF  FEC,710
07DBE:  MOVFF  FEC,711
07DC2:  MOVFF  FEC,712
07DC6:  MOVFF  70E,565
07DCA:  MOVFF  70D,564
07DCE:  MOVFF  70B,734
07DD2:  MOVLW  18
07DD4:  MOVWF  x35
07DD6:  MOVLB  0
07DD8:  CALL   6078
07DDC:  MOVLW  2C
07DDE:  MOVLB  7
07DE0:  MOVWF  x50
07DE2:  MOVLB  0
07DE4:  CALL   55D8
07DE8:  MOVLW  89
07DEA:  MOVWF  FE9
07DEC:  MOVFF  712,746
07DF0:  MOVFF  711,745
07DF4:  MOVFF  710,744
07DF8:  MOVFF  70F,743
07DFC:  MOVLW  02
07DFE:  MOVLB  7
07E00:  MOVWF  x47
07E02:  MOVLB  0
07E04:  CALL   5776
07E08:  MOVLW  2C
07E0A:  MOVLB  7
07E0C:  MOVWF  x50
07E0E:  MOVLB  0
07E10:  CALL   55D8
07E14:  BRA    7F70
07E16:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07E18:  MOVF   x0C,W
07E1A:  SUBLW  34
07E1C:  BNZ   7EC0
07E1E:  MOVLW  04
07E20:  MOVWF  x42
07E22:  MOVLW  C1
07E24:  MOVWF  x41
07E26:  MOVLB  0
07E28:  CALL   55A0
07E2C:  MOVF   01,W
07E2E:  ADDLW  C1
07E30:  MOVLB  7
07E32:  MOVWF  x0D
07E34:  MOVLW  04
07E36:  ADDWFC 02,W
07E38:  MOVWF  x0E
07E3A:  MOVLW  01
07E3C:  SUBWF  x0B,W
07E3E:  MULLW  18
07E40:  MOVF   FF3,W
07E42:  CLRF   x10
07E44:  MOVWF  x0F
07E46:  MOVLW  10
07E48:  ADDWF  x0F,W
07E4A:  MOVWF  01
07E4C:  MOVLW  00
07E4E:  ADDWFC x10,W
07E50:  MOVWF  03
07E52:  MOVF   01,W
07E54:  ADDLW  92
07E56:  MOVWF  FE9
07E58:  MOVLW  00
07E5A:  ADDWFC 03,W
07E5C:  MOVWF  FEA
07E5E:  MOVFF  FEF,70F
07E62:  MOVFF  FEC,710
07E66:  MOVFF  FEC,711
07E6A:  MOVFF  FEC,712
07E6E:  MOVFF  70E,565
07E72:  MOVFF  70D,564
07E76:  MOVFF  70B,734
07E7A:  MOVLW  18
07E7C:  MOVWF  x35
07E7E:  MOVLB  0
07E80:  CALL   6078
07E84:  MOVLW  2C
07E86:  MOVLB  7
07E88:  MOVWF  x50
07E8A:  MOVLB  0
07E8C:  CALL   55D8
07E90:  MOVLW  89
07E92:  MOVWF  FE9
07E94:  MOVFF  712,746
07E98:  MOVFF  711,745
07E9C:  MOVFF  710,744
07EA0:  MOVFF  70F,743
07EA4:  MOVLW  02
07EA6:  MOVLB  7
07EA8:  MOVWF  x47
07EAA:  MOVLB  0
07EAC:  CALL   5776
07EB0:  MOVLW  2C
07EB2:  MOVLB  7
07EB4:  MOVWF  x50
07EB6:  MOVLB  0
07EB8:  CALL   55D8
07EBC:  BRA    7F70
07EBE:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07EC0:  MOVF   x0C,W
07EC2:  SUBLW  35
07EC4:  BNZ   7F68
07EC6:  MOVLW  04
07EC8:  MOVWF  x42
07ECA:  MOVLW  C1
07ECC:  MOVWF  x41
07ECE:  MOVLB  0
07ED0:  CALL   55A0
07ED4:  MOVF   01,W
07ED6:  ADDLW  C1
07ED8:  MOVLB  7
07EDA:  MOVWF  x0D
07EDC:  MOVLW  04
07EDE:  ADDWFC 02,W
07EE0:  MOVWF  x0E
07EE2:  MOVLW  01
07EE4:  SUBWF  x0B,W
07EE6:  MULLW  18
07EE8:  MOVF   FF3,W
07EEA:  CLRF   x10
07EEC:  MOVWF  x0F
07EEE:  MOVLW  14
07EF0:  ADDWF  x0F,W
07EF2:  MOVWF  01
07EF4:  MOVLW  00
07EF6:  ADDWFC x10,W
07EF8:  MOVWF  03
07EFA:  MOVF   01,W
07EFC:  ADDLW  92
07EFE:  MOVWF  FE9
07F00:  MOVLW  00
07F02:  ADDWFC 03,W
07F04:  MOVWF  FEA
07F06:  MOVFF  FEF,70F
07F0A:  MOVFF  FEC,710
07F0E:  MOVFF  FEC,711
07F12:  MOVFF  FEC,712
07F16:  MOVFF  70E,565
07F1A:  MOVFF  70D,564
07F1E:  MOVFF  70B,734
07F22:  MOVLW  18
07F24:  MOVWF  x35
07F26:  MOVLB  0
07F28:  CALL   6078
07F2C:  MOVLW  2C
07F2E:  MOVLB  7
07F30:  MOVWF  x50
07F32:  MOVLB  0
07F34:  CALL   55D8
07F38:  MOVLW  89
07F3A:  MOVWF  FE9
07F3C:  MOVFF  712,746
07F40:  MOVFF  711,745
07F44:  MOVFF  710,744
07F48:  MOVFF  70F,743
07F4C:  MOVLW  02
07F4E:  MOVLB  7
07F50:  MOVWF  x47
07F52:  MOVLB  0
07F54:  CALL   5776
07F58:  MOVLW  2C
07F5A:  MOVLB  7
07F5C:  MOVWF  x50
07F5E:  MOVLB  0
07F60:  CALL   55D8
07F64:  BRA    7F70
07F66:  MOVLB  7
....................    else return INV_PARAM;
07F68:  MOVLW  02
07F6A:  MOVWF  01
07F6C:  MOVLB  0
07F6E:  BRA    7F74
....................    
....................    return SUCCESS;
07F70:  MOVLW  00
07F72:  MOVWF  01
07F74:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07F76:  MOVLB  7
07F78:  CLRF   x42
07F7A:  MOVFF  690,741
07F7E:  CLRF   x44
07F80:  MOVLW  B5
07F82:  MOVWF  x43
07F84:  MOVLB  0
07F86:  CALL   08BE
07F8A:  MOVFF  02,712
07F8E:  MOVFF  01,711
07F92:  MOVLW  06
07F94:  MOVLB  7
07F96:  ADDWF  x11,F
07F98:  MOVLW  00
07F9A:  ADDWFC x12,F
07F9C:  MOVLW  32
07F9E:  ADDWF  x11,W
07FA0:  MOVWF  01
07FA2:  MOVLW  00
07FA4:  ADDWFC x12,W
07FA6:  MOVWF  03
07FA8:  MOVF   01,W
07FAA:  ADDLW  EB
07FAC:  MOVWF  01
07FAE:  MOVLW  01
07FB0:  ADDWFC 03,F
07FB2:  MOVFF  01,711
07FB6:  MOVFF  03,712
07FBA:  MOVFF  03,734
07FBE:  MOVFF  01,733
07FC2:  MOVLB  0
07FC4:  CALL   5C34
07FC8:  MOVF   01,F
07FCA:  BNZ   7FD4
07FCC:  MOVLW  02
07FCE:  MOVWF  01
07FD0:  BRA    830C
07FD2:  BRA    8032
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07FD4:  MOVLB  7
07FD6:  CLRF   x42
07FD8:  MOVFF  690,741
07FDC:  CLRF   x44
07FDE:  MOVLW  B5
07FE0:  MOVWF  x43
07FE2:  MOVLB  0
07FE4:  CALL   08BE
07FE8:  MOVFF  02,712
07FEC:  MOVFF  01,711
07FF0:  MOVLW  06
07FF2:  MOVLB  7
07FF4:  ADDWF  x11,F
07FF6:  MOVLW  00
07FF8:  ADDWFC x12,F
07FFA:  MOVLW  32
07FFC:  ADDWF  x11,W
07FFE:  MOVWF  01
08000:  MOVLW  00
08002:  ADDWFC x12,W
08004:  MOVWF  03
08006:  MOVF   01,W
08008:  ADDLW  EB
0800A:  MOVWF  01
0800C:  MOVLW  01
0800E:  ADDWFC 03,F
08010:  MOVFF  01,711
08014:  MOVFF  03,712
08018:  MOVFF  03,734
0801C:  MOVFF  01,733
08020:  CLRF   x36
08022:  CLRF   x35
08024:  MOVLW  0A
08026:  MOVWF  x37
08028:  MOVLB  0
0802A:  CALL   5D24
0802E:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08032:  MOVLB  7
08034:  CLRF   x42
08036:  MOVFF  690,741
0803A:  CLRF   x44
0803C:  MOVLW  B5
0803E:  MOVWF  x43
08040:  MOVLB  0
08042:  CALL   08BE
08046:  MOVFF  02,712
0804A:  MOVFF  01,711
0804E:  MOVLW  06
08050:  MOVLB  7
08052:  ADDWF  x11,F
08054:  MOVLW  00
08056:  ADDWFC x12,F
08058:  MOVLW  4B
0805A:  ADDWF  x11,W
0805C:  MOVWF  01
0805E:  MOVLW  00
08060:  ADDWFC x12,W
08062:  MOVWF  03
08064:  MOVF   01,W
08066:  ADDLW  EB
08068:  MOVWF  01
0806A:  MOVLW  01
0806C:  ADDWFC 03,F
0806E:  MOVFF  01,711
08072:  MOVFF  03,712
08076:  MOVFF  03,742
0807A:  MOVFF  01,741
0807E:  MOVLB  0
08080:  CALL   55A0
08084:  MOVFF  02,03
08088:  MOVF   01,W
0808A:  SUBLW  01
0808C:  BNZ   8092
0808E:  MOVF   03,F
08090:  BZ    809A
08092:  MOVLW  02
08094:  MOVWF  01
08096:  BRA    830C
08098:  BRA    80DA
....................    else arg2 = SERcmd[rec].p[3][0];
0809A:  MOVLB  7
0809C:  CLRF   x42
0809E:  MOVFF  690,741
080A2:  CLRF   x44
080A4:  MOVLW  B5
080A6:  MOVWF  x43
080A8:  MOVLB  0
080AA:  CALL   08BE
080AE:  MOVFF  02,712
080B2:  MOVFF  01,711
080B6:  MOVLW  06
080B8:  MOVLB  7
080BA:  ADDWF  x11,F
080BC:  MOVLW  00
080BE:  ADDWFC x12,F
080C0:  MOVLW  4B
080C2:  ADDWF  x11,F
080C4:  MOVLW  00
080C6:  ADDWFC x12,F
080C8:  MOVLW  EB
080CA:  ADDWF  x11,W
080CC:  MOVWF  FE9
080CE:  MOVLW  01
080D0:  ADDWFC x12,W
080D2:  MOVWF  FEA
080D4:  MOVFF  FEF,70C
080D8:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
080DA:  MOVLB  7
080DC:  CLRF   x42
080DE:  MOVFF  690,741
080E2:  CLRF   x44
080E4:  MOVLW  B5
080E6:  MOVWF  x43
080E8:  MOVLB  0
080EA:  CALL   08BE
080EE:  MOVFF  02,712
080F2:  MOVFF  01,711
080F6:  MOVLW  06
080F8:  MOVLB  7
080FA:  ADDWF  x11,F
080FC:  MOVLW  00
080FE:  ADDWFC x12,F
08100:  MOVLW  64
08102:  ADDWF  x11,W
08104:  MOVWF  01
08106:  MOVLW  00
08108:  ADDWFC x12,W
0810A:  MOVWF  03
0810C:  MOVF   01,W
0810E:  ADDLW  EB
08110:  MOVWF  01
08112:  MOVLW  01
08114:  ADDWFC 03,F
08116:  MOVFF  01,711
0811A:  MOVFF  03,712
0811E:  MOVFF  03,715
08122:  MOVFF  01,714
08126:  MOVLB  0
08128:  CALL   6D48
0812C:  MOVF   01,F
0812E:  BNZ   8138
08130:  MOVLW  02
08132:  MOVWF  01
08134:  BRA    830C
08136:  BRA    819E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
08138:  MOVLB  7
0813A:  CLRF   x42
0813C:  MOVFF  690,741
08140:  CLRF   x44
08142:  MOVLW  B5
08144:  MOVWF  x43
08146:  MOVLB  0
08148:  CALL   08BE
0814C:  MOVFF  02,712
08150:  MOVFF  01,711
08154:  MOVLW  06
08156:  MOVLB  7
08158:  ADDWF  x11,F
0815A:  MOVLW  00
0815C:  ADDWFC x12,F
0815E:  MOVLW  64
08160:  ADDWF  x11,W
08162:  MOVWF  01
08164:  MOVLW  00
08166:  ADDWFC x12,W
08168:  MOVWF  03
0816A:  MOVF   01,W
0816C:  ADDLW  EB
0816E:  MOVWF  01
08170:  MOVLW  01
08172:  ADDWFC 03,F
08174:  MOVFF  01,711
08178:  MOVFF  03,712
0817C:  MOVFF  03,715
08180:  MOVFF  01,714
08184:  CLRF   x17
08186:  CLRF   x16
08188:  MOVLB  0
0818A:  CALL   6E0A
0818E:  MOVFF  03,710
08192:  MOVFF  02,70F
08196:  MOVFF  01,70E
0819A:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
0819E:  MOVLB  7
081A0:  MOVF   x0C,W
081A2:  SUBLW  30
081A4:  BNZ   81D0
081A6:  MOVLW  01
081A8:  SUBWF  x0B,W
081AA:  MULLW  18
081AC:  MOVF   FF3,W
081AE:  CLRF   x12
081B0:  MOVWF  x11
081B2:  MOVLW  92
081B4:  ADDWF  x11,W
081B6:  MOVWF  FE9
081B8:  MOVLW  00
081BA:  ADDWFC x12,W
081BC:  MOVWF  FEA
081BE:  MOVFF  70D,FEF
081C2:  MOVFF  70E,FEC
081C6:  MOVFF  70F,FEC
081CA:  MOVFF  710,FEC
081CE:  BRA    8306
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
081D0:  MOVF   x0C,W
081D2:  SUBLW  31
081D4:  BNZ   820C
081D6:  MOVLW  01
081D8:  SUBWF  x0B,W
081DA:  MULLW  18
081DC:  MOVF   FF3,W
081DE:  CLRF   x12
081E0:  MOVWF  x11
081E2:  MOVLW  04
081E4:  ADDWF  x11,W
081E6:  MOVWF  01
081E8:  MOVLW  00
081EA:  ADDWFC x12,W
081EC:  MOVWF  03
081EE:  MOVF   01,W
081F0:  ADDLW  92
081F2:  MOVWF  FE9
081F4:  MOVLW  00
081F6:  ADDWFC 03,W
081F8:  MOVWF  FEA
081FA:  MOVFF  70D,FEF
081FE:  MOVFF  70E,FEC
08202:  MOVFF  70F,FEC
08206:  MOVFF  710,FEC
0820A:  BRA    8306
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
0820C:  MOVF   x0C,W
0820E:  SUBLW  32
08210:  BNZ   8248
08212:  MOVLW  01
08214:  SUBWF  x0B,W
08216:  MULLW  18
08218:  MOVF   FF3,W
0821A:  CLRF   x12
0821C:  MOVWF  x11
0821E:  MOVLW  08
08220:  ADDWF  x11,W
08222:  MOVWF  01
08224:  MOVLW  00
08226:  ADDWFC x12,W
08228:  MOVWF  03
0822A:  MOVF   01,W
0822C:  ADDLW  92
0822E:  MOVWF  FE9
08230:  MOVLW  00
08232:  ADDWFC 03,W
08234:  MOVWF  FEA
08236:  MOVFF  70D,FEF
0823A:  MOVFF  70E,FEC
0823E:  MOVFF  70F,FEC
08242:  MOVFF  710,FEC
08246:  BRA    8306
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08248:  MOVF   x0C,W
0824A:  SUBLW  33
0824C:  BNZ   8284
0824E:  MOVLW  01
08250:  SUBWF  x0B,W
08252:  MULLW  18
08254:  MOVF   FF3,W
08256:  CLRF   x12
08258:  MOVWF  x11
0825A:  MOVLW  0C
0825C:  ADDWF  x11,W
0825E:  MOVWF  01
08260:  MOVLW  00
08262:  ADDWFC x12,W
08264:  MOVWF  03
08266:  MOVF   01,W
08268:  ADDLW  92
0826A:  MOVWF  FE9
0826C:  MOVLW  00
0826E:  ADDWFC 03,W
08270:  MOVWF  FEA
08272:  MOVFF  70D,FEF
08276:  MOVFF  70E,FEC
0827A:  MOVFF  70F,FEC
0827E:  MOVFF  710,FEC
08282:  BRA    8306
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08284:  MOVF   x0C,W
08286:  SUBLW  34
08288:  BNZ   82C0
0828A:  MOVLW  01
0828C:  SUBWF  x0B,W
0828E:  MULLW  18
08290:  MOVF   FF3,W
08292:  CLRF   x12
08294:  MOVWF  x11
08296:  MOVLW  10
08298:  ADDWF  x11,W
0829A:  MOVWF  01
0829C:  MOVLW  00
0829E:  ADDWFC x12,W
082A0:  MOVWF  03
082A2:  MOVF   01,W
082A4:  ADDLW  92
082A6:  MOVWF  FE9
082A8:  MOVLW  00
082AA:  ADDWFC 03,W
082AC:  MOVWF  FEA
082AE:  MOVFF  70D,FEF
082B2:  MOVFF  70E,FEC
082B6:  MOVFF  70F,FEC
082BA:  MOVFF  710,FEC
082BE:  BRA    8306
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
082C0:  MOVF   x0C,W
082C2:  SUBLW  35
082C4:  BNZ   82FC
082C6:  MOVLW  01
082C8:  SUBWF  x0B,W
082CA:  MULLW  18
082CC:  MOVF   FF3,W
082CE:  CLRF   x12
082D0:  MOVWF  x11
082D2:  MOVLW  14
082D4:  ADDWF  x11,W
082D6:  MOVWF  01
082D8:  MOVLW  00
082DA:  ADDWFC x12,W
082DC:  MOVWF  03
082DE:  MOVF   01,W
082E0:  ADDLW  92
082E2:  MOVWF  FE9
082E4:  MOVLW  00
082E6:  ADDWFC 03,W
082E8:  MOVWF  FEA
082EA:  MOVFF  70D,FEF
082EE:  MOVFF  70E,FEC
082F2:  MOVFF  70F,FEC
082F6:  MOVFF  710,FEC
082FA:  BRA    8306
....................    else return INV_PARAM;
082FC:  MOVLW  02
082FE:  MOVWF  01
08300:  MOVLB  0
08302:  BRA    830C
08304:  MOVLB  7
....................    
....................    return SUCCESS;
08306:  MOVLW  00
08308:  MOVWF  01
0830A:  MOVLB  0
0830C:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0830E:  MOVLW  4E
08310:  MOVLB  7
08312:  MOVWF  x0F
08314:  MOVLW  31
08316:  MOVWF  x10
08318:  MOVLW  35
0831A:  MOVWF  x11
0831C:  CLRF   x12
0831E:  MOVLW  07
08320:  MOVWF  x0E
08322:  MOVLW  0F
08324:  MOVWF  x0D
....................    char *s_200 = "200";
08326:  MOVLW  32
08328:  MOVWF  x15
0832A:  MOVLW  30
0832C:  MOVWF  x16
0832E:  MOVWF  x17
08330:  CLRF   x18
08332:  MOVLW  07
08334:  MOVWF  x14
08336:  MOVLW  15
08338:  MOVWF  x13
....................    char *s_5V6 = "5V6";
0833A:  MOVLW  35
0833C:  MOVWF  x1B
0833E:  MOVLW  56
08340:  MOVWF  x1C
08342:  MOVLW  36
08344:  MOVWF  x1D
08346:  CLRF   x1E
08348:  MOVLW  07
0834A:  MOVWF  x1A
0834C:  MOVLW  1B
0834E:  MOVWF  x19
....................    char *s_5VA = "5VA";
08350:  MOVLW  35
08352:  MOVWF  x21
08354:  MOVLW  56
08356:  MOVWF  x22
08358:  MOVLW  41
0835A:  MOVWF  x23
0835C:  CLRF   x24
0835E:  MOVLW  07
08360:  MOVWF  x20
08362:  MOVLW  21
08364:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08366:  MOVLW  33
08368:  MOVWF  x27
0836A:  MOVLW  56
0836C:  MOVWF  x28
0836E:  MOVLW  36
08370:  MOVWF  x29
08372:  MOVLW  58
08374:  MOVWF  x2A
08376:  CLRF   x2B
08378:  MOVLW  07
0837A:  MOVWF  x26
0837C:  MOVLW  27
0837E:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
08380:  MOVLW  33
08382:  MOVWF  x2E
08384:  MOVLW  56
08386:  MOVWF  x2F
08388:  MOVLW  33
0838A:  MOVWF  x30
0838C:  MOVLW  41
0838E:  MOVWF  x31
08390:  CLRF   x32
08392:  MOVLW  07
08394:  MOVWF  x2D
08396:  MOVLW  2E
08398:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
0839A:  MOVLW  33
0839C:  MOVWF  x35
0839E:  MOVLW  56
083A0:  MOVWF  x36
083A2:  MOVLW  33
083A4:  MOVWF  x37
083A6:  MOVLW  44
083A8:  MOVWF  x38
083AA:  CLRF   x39
083AC:  MOVLW  07
083AE:  MOVWF  x34
083B0:  MOVLW  35
083B2:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
083B4:  CLRF   x42
083B6:  MOVFF  690,741
083BA:  CLRF   x44
083BC:  MOVLW  B5
083BE:  MOVWF  x43
083C0:  MOVLB  0
083C2:  CALL   08BE
083C6:  MOVFF  02,73B
083CA:  MOVFF  01,73A
083CE:  MOVLW  06
083D0:  MOVLB  7
083D2:  ADDWF  x3A,F
083D4:  MOVLW  00
083D6:  ADDWFC x3B,F
083D8:  MOVLW  32
083DA:  ADDWF  x3A,W
083DC:  MOVWF  01
083DE:  MOVLW  00
083E0:  ADDWFC x3B,W
083E2:  MOVWF  03
083E4:  MOVF   01,W
083E6:  ADDLW  EB
083E8:  MOVWF  01
083EA:  MOVLW  01
083EC:  ADDWFC 03,F
083EE:  MOVFF  01,70B
083F2:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
083F6:  MOVFF  70E,742
083FA:  MOVFF  70D,741
083FE:  MOVFF  70C,744
08402:  MOVFF  70B,743
08406:  MOVLB  0
08408:  CALL   5B14
0840C:  MOVF   01,F
0840E:  BNZ   8492
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08410:  MOVLW  04
08412:  MOVLB  7
08414:  MOVWF  x42
08416:  MOVLW  C1
08418:  MOVWF  x41
0841A:  MOVLB  0
0841C:  CALL   55A0
08420:  MOVFF  02,03
08424:  MOVF   01,W
08426:  ADDLW  C1
08428:  MOVLB  7
0842A:  MOVWF  x3A
0842C:  MOVLW  04
0842E:  ADDWFC 02,W
08430:  MOVWF  x3B
08432:  MOVFF  FE8,565
08436:  MOVFF  73A,564
0843A:  MOVLW  89
0843C:  MOVWF  FE9
0843E:  MOVFF  C5,746
08442:  MOVFF  C4,745
08446:  MOVFF  C3,744
0844A:  MOVFF  C2,743
0844E:  MOVLW  02
08450:  MOVWF  x47
08452:  MOVLB  0
08454:  CALL   5776
08458:  MOVLW  2C
0845A:  MOVLB  7
0845C:  MOVWF  x50
0845E:  MOVLB  0
08460:  CALL   55D8
08464:  MOVLW  89
08466:  MOVWF  FE9
08468:  MOVFF  C9,746
0846C:  MOVFF  C8,745
08470:  MOVFF  C7,744
08474:  MOVFF  C6,743
08478:  MOVLW  02
0847A:  MOVLB  7
0847C:  MOVWF  x47
0847E:  MOVLB  0
08480:  CALL   5776
08484:  MOVLW  2C
08486:  MOVLB  7
08488:  MOVWF  x50
0848A:  MOVLB  0
0848C:  CALL   55D8
....................    }
08490:  BRA    8834
....................    else if (0 == strcmp(s_200, arg1)) {
08492:  MOVFF  714,742
08496:  MOVFF  713,741
0849A:  MOVFF  70C,744
0849E:  MOVFF  70B,743
084A2:  CALL   5B14
084A6:  MOVF   01,F
084A8:  BNZ   852C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
084AA:  MOVLW  04
084AC:  MOVLB  7
084AE:  MOVWF  x42
084B0:  MOVLW  C1
084B2:  MOVWF  x41
084B4:  MOVLB  0
084B6:  CALL   55A0
084BA:  MOVFF  02,03
084BE:  MOVF   01,W
084C0:  ADDLW  C1
084C2:  MOVLB  7
084C4:  MOVWF  x3A
084C6:  MOVLW  04
084C8:  ADDWFC 02,W
084CA:  MOVWF  x3B
084CC:  MOVFF  FE8,565
084D0:  MOVFF  73A,564
084D4:  MOVLW  89
084D6:  MOVWF  FE9
084D8:  MOVFF  CD,746
084DC:  MOVFF  CC,745
084E0:  MOVFF  CB,744
084E4:  MOVFF  CA,743
084E8:  MOVLW  02
084EA:  MOVWF  x47
084EC:  MOVLB  0
084EE:  CALL   5776
084F2:  MOVLW  2C
084F4:  MOVLB  7
084F6:  MOVWF  x50
084F8:  MOVLB  0
084FA:  CALL   55D8
084FE:  MOVLW  89
08500:  MOVWF  FE9
08502:  MOVFF  D1,746
08506:  MOVFF  D0,745
0850A:  MOVFF  CF,744
0850E:  MOVFF  CE,743
08512:  MOVLW  02
08514:  MOVLB  7
08516:  MOVWF  x47
08518:  MOVLB  0
0851A:  CALL   5776
0851E:  MOVLW  2C
08520:  MOVLB  7
08522:  MOVWF  x50
08524:  MOVLB  0
08526:  CALL   55D8
....................    }
0852A:  BRA    8834
....................    else if (0 == strcmp(s_5V6, arg1)) {
0852C:  MOVFF  71A,742
08530:  MOVFF  719,741
08534:  MOVFF  70C,744
08538:  MOVFF  70B,743
0853C:  CALL   5B14
08540:  MOVF   01,F
08542:  BNZ   85C6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08544:  MOVLW  04
08546:  MOVLB  7
08548:  MOVWF  x42
0854A:  MOVLW  C1
0854C:  MOVWF  x41
0854E:  MOVLB  0
08550:  CALL   55A0
08554:  MOVFF  02,03
08558:  MOVF   01,W
0855A:  ADDLW  C1
0855C:  MOVLB  7
0855E:  MOVWF  x3A
08560:  MOVLW  04
08562:  ADDWFC 02,W
08564:  MOVWF  x3B
08566:  MOVFF  FE8,565
0856A:  MOVFF  73A,564
0856E:  MOVLW  89
08570:  MOVWF  FE9
08572:  MOVFF  D5,746
08576:  MOVFF  D4,745
0857A:  MOVFF  D3,744
0857E:  MOVFF  D2,743
08582:  MOVLW  02
08584:  MOVWF  x47
08586:  MOVLB  0
08588:  CALL   5776
0858C:  MOVLW  2C
0858E:  MOVLB  7
08590:  MOVWF  x50
08592:  MOVLB  0
08594:  CALL   55D8
08598:  MOVLW  89
0859A:  MOVWF  FE9
0859C:  MOVFF  D9,746
085A0:  MOVFF  D8,745
085A4:  MOVFF  D7,744
085A8:  MOVFF  D6,743
085AC:  MOVLW  02
085AE:  MOVLB  7
085B0:  MOVWF  x47
085B2:  MOVLB  0
085B4:  CALL   5776
085B8:  MOVLW  2C
085BA:  MOVLB  7
085BC:  MOVWF  x50
085BE:  MOVLB  0
085C0:  CALL   55D8
....................    }
085C4:  BRA    8834
....................    else if (0 == strcmp(s_5VA, arg1)) {
085C6:  MOVFF  720,742
085CA:  MOVFF  71F,741
085CE:  MOVFF  70C,744
085D2:  MOVFF  70B,743
085D6:  CALL   5B14
085DA:  MOVF   01,F
085DC:  BNZ   8660
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
085DE:  MOVLW  04
085E0:  MOVLB  7
085E2:  MOVWF  x42
085E4:  MOVLW  C1
085E6:  MOVWF  x41
085E8:  MOVLB  0
085EA:  CALL   55A0
085EE:  MOVFF  02,03
085F2:  MOVF   01,W
085F4:  ADDLW  C1
085F6:  MOVLB  7
085F8:  MOVWF  x3A
085FA:  MOVLW  04
085FC:  ADDWFC 02,W
085FE:  MOVWF  x3B
08600:  MOVFF  FE8,565
08604:  MOVFF  73A,564
08608:  MOVLW  89
0860A:  MOVWF  FE9
0860C:  MOVFF  DD,746
08610:  MOVFF  DC,745
08614:  MOVFF  DB,744
08618:  MOVFF  DA,743
0861C:  MOVLW  02
0861E:  MOVWF  x47
08620:  MOVLB  0
08622:  CALL   5776
08626:  MOVLW  2C
08628:  MOVLB  7
0862A:  MOVWF  x50
0862C:  MOVLB  0
0862E:  CALL   55D8
08632:  MOVLW  89
08634:  MOVWF  FE9
08636:  MOVFF  E1,746
0863A:  MOVFF  E0,745
0863E:  MOVFF  DF,744
08642:  MOVFF  DE,743
08646:  MOVLW  02
08648:  MOVLB  7
0864A:  MOVWF  x47
0864C:  MOVLB  0
0864E:  CALL   5776
08652:  MOVLW  2C
08654:  MOVLB  7
08656:  MOVWF  x50
08658:  MOVLB  0
0865A:  CALL   55D8
....................    }
0865E:  BRA    8834
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08660:  MOVFF  726,742
08664:  MOVFF  725,741
08668:  MOVFF  70C,744
0866C:  MOVFF  70B,743
08670:  CALL   5B14
08674:  MOVF   01,F
08676:  BNZ   86FA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08678:  MOVLW  04
0867A:  MOVLB  7
0867C:  MOVWF  x42
0867E:  MOVLW  C1
08680:  MOVWF  x41
08682:  MOVLB  0
08684:  CALL   55A0
08688:  MOVFF  02,03
0868C:  MOVF   01,W
0868E:  ADDLW  C1
08690:  MOVLB  7
08692:  MOVWF  x3A
08694:  MOVLW  04
08696:  ADDWFC 02,W
08698:  MOVWF  x3B
0869A:  MOVFF  FE8,565
0869E:  MOVFF  73A,564
086A2:  MOVLW  89
086A4:  MOVWF  FE9
086A6:  MOVFF  E5,746
086AA:  MOVFF  E4,745
086AE:  MOVFF  E3,744
086B2:  MOVFF  E2,743
086B6:  MOVLW  02
086B8:  MOVWF  x47
086BA:  MOVLB  0
086BC:  CALL   5776
086C0:  MOVLW  2C
086C2:  MOVLB  7
086C4:  MOVWF  x50
086C6:  MOVLB  0
086C8:  CALL   55D8
086CC:  MOVLW  89
086CE:  MOVWF  FE9
086D0:  MOVFF  E9,746
086D4:  MOVFF  E8,745
086D8:  MOVFF  E7,744
086DC:  MOVFF  E6,743
086E0:  MOVLW  02
086E2:  MOVLB  7
086E4:  MOVWF  x47
086E6:  MOVLB  0
086E8:  CALL   5776
086EC:  MOVLW  2C
086EE:  MOVLB  7
086F0:  MOVWF  x50
086F2:  MOVLB  0
086F4:  CALL   55D8
....................    }
086F8:  BRA    8834
....................    else if (0 == strcmp(s_3V3A, arg1)) {
086FA:  MOVFF  72D,742
086FE:  MOVFF  72C,741
08702:  MOVFF  70C,744
08706:  MOVFF  70B,743
0870A:  CALL   5B14
0870E:  MOVF   01,F
08710:  BNZ   8794
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08712:  MOVLW  04
08714:  MOVLB  7
08716:  MOVWF  x42
08718:  MOVLW  C1
0871A:  MOVWF  x41
0871C:  MOVLB  0
0871E:  CALL   55A0
08722:  MOVFF  02,03
08726:  MOVF   01,W
08728:  ADDLW  C1
0872A:  MOVLB  7
0872C:  MOVWF  x3A
0872E:  MOVLW  04
08730:  ADDWFC 02,W
08732:  MOVWF  x3B
08734:  MOVFF  FE8,565
08738:  MOVFF  73A,564
0873C:  MOVLW  89
0873E:  MOVWF  FE9
08740:  MOVFF  ED,746
08744:  MOVFF  EC,745
08748:  MOVFF  EB,744
0874C:  MOVFF  EA,743
08750:  MOVLW  02
08752:  MOVWF  x47
08754:  MOVLB  0
08756:  CALL   5776
0875A:  MOVLW  2C
0875C:  MOVLB  7
0875E:  MOVWF  x50
08760:  MOVLB  0
08762:  CALL   55D8
08766:  MOVLW  89
08768:  MOVWF  FE9
0876A:  MOVFF  F1,746
0876E:  MOVFF  F0,745
08772:  MOVFF  EF,744
08776:  MOVFF  EE,743
0877A:  MOVLW  02
0877C:  MOVLB  7
0877E:  MOVWF  x47
08780:  MOVLB  0
08782:  CALL   5776
08786:  MOVLW  2C
08788:  MOVLB  7
0878A:  MOVWF  x50
0878C:  MOVLB  0
0878E:  CALL   55D8
....................    }
08792:  BRA    8834
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08794:  MOVFF  734,742
08798:  MOVFF  733,741
0879C:  MOVFF  70C,744
087A0:  MOVFF  70B,743
087A4:  CALL   5B14
087A8:  MOVF   01,F
087AA:  BNZ   882E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
087AC:  MOVLW  04
087AE:  MOVLB  7
087B0:  MOVWF  x42
087B2:  MOVLW  C1
087B4:  MOVWF  x41
087B6:  MOVLB  0
087B8:  CALL   55A0
087BC:  MOVFF  02,03
087C0:  MOVF   01,W
087C2:  ADDLW  C1
087C4:  MOVLB  7
087C6:  MOVWF  x3A
087C8:  MOVLW  04
087CA:  ADDWFC 02,W
087CC:  MOVWF  x3B
087CE:  MOVFF  FE8,565
087D2:  MOVFF  73A,564
087D6:  MOVLW  89
087D8:  MOVWF  FE9
087DA:  MOVFF  F5,746
087DE:  MOVFF  F4,745
087E2:  MOVFF  F3,744
087E6:  MOVFF  F2,743
087EA:  MOVLW  02
087EC:  MOVWF  x47
087EE:  MOVLB  0
087F0:  CALL   5776
087F4:  MOVLW  2C
087F6:  MOVLB  7
087F8:  MOVWF  x50
087FA:  MOVLB  0
087FC:  CALL   55D8
08800:  MOVLW  89
08802:  MOVWF  FE9
08804:  MOVFF  F9,746
08808:  MOVFF  F8,745
0880C:  MOVFF  F7,744
08810:  MOVFF  F6,743
08814:  MOVLW  02
08816:  MOVLB  7
08818:  MOVWF  x47
0881A:  MOVLB  0
0881C:  CALL   5776
08820:  MOVLW  2C
08822:  MOVLB  7
08824:  MOVWF  x50
08826:  MOVLB  0
08828:  CALL   55D8
....................    }
0882C:  BRA    8834
....................    else return INV_PARAM;
0882E:  MOVLW  02
08830:  MOVWF  01
08832:  BRA    8838
....................    
....................    return SUCCESS;
08834:  MOVLW  00
08836:  MOVWF  01
08838:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
0883A:  MOVLW  00
0883C:  MOVWF  01
0883E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08840:  MOVLW  4E
08842:  MOVLB  7
08844:  MOVWF  x0F
08846:  MOVLW  31
08848:  MOVWF  x10
0884A:  MOVLW  35
0884C:  MOVWF  x11
0884E:  CLRF   x12
08850:  MOVLW  07
08852:  MOVWF  x0E
08854:  MOVLW  0F
08856:  MOVWF  x0D
....................    char *s_200 = "200";
08858:  MOVLW  32
0885A:  MOVWF  x15
0885C:  MOVLW  30
0885E:  MOVWF  x16
08860:  MOVWF  x17
08862:  CLRF   x18
08864:  MOVLW  07
08866:  MOVWF  x14
08868:  MOVLW  15
0886A:  MOVWF  x13
....................    char *s_5V6 = "5V6";
0886C:  MOVLW  35
0886E:  MOVWF  x1B
08870:  MOVLW  56
08872:  MOVWF  x1C
08874:  MOVLW  36
08876:  MOVWF  x1D
08878:  CLRF   x1E
0887A:  MOVLW  07
0887C:  MOVWF  x1A
0887E:  MOVLW  1B
08880:  MOVWF  x19
....................    char *s_5VA = "5VA";
08882:  MOVLW  35
08884:  MOVWF  x21
08886:  MOVLW  56
08888:  MOVWF  x22
0888A:  MOVLW  41
0888C:  MOVWF  x23
0888E:  CLRF   x24
08890:  MOVLW  07
08892:  MOVWF  x20
08894:  MOVLW  21
08896:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08898:  MOVLW  33
0889A:  MOVWF  x27
0889C:  MOVLW  56
0889E:  MOVWF  x28
088A0:  MOVLW  36
088A2:  MOVWF  x29
088A4:  MOVLW  58
088A6:  MOVWF  x2A
088A8:  CLRF   x2B
088AA:  MOVLW  07
088AC:  MOVWF  x26
088AE:  MOVLW  27
088B0:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
088B2:  MOVLW  33
088B4:  MOVWF  x2E
088B6:  MOVLW  56
088B8:  MOVWF  x2F
088BA:  MOVLW  33
088BC:  MOVWF  x30
088BE:  MOVLW  41
088C0:  MOVWF  x31
088C2:  CLRF   x32
088C4:  MOVLW  07
088C6:  MOVWF  x2D
088C8:  MOVLW  2E
088CA:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
088CC:  MOVLW  33
088CE:  MOVWF  x35
088D0:  MOVLW  56
088D2:  MOVWF  x36
088D4:  MOVLW  33
088D6:  MOVWF  x37
088D8:  MOVLW  44
088DA:  MOVWF  x38
088DC:  CLRF   x39
088DE:  MOVLW  07
088E0:  MOVWF  x34
088E2:  MOVLW  35
088E4:  MOVWF  x33
....................    char *s_all = "all";
088E6:  MOVLW  61
088E8:  MOVWF  x3C
088EA:  MOVLW  6C
088EC:  MOVWF  x3D
088EE:  MOVWF  x3E
088F0:  CLRF   x3F
088F2:  MOVLW  07
088F4:  MOVWF  x3B
088F6:  MOVLW  3C
088F8:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
088FA:  CLRF   x42
088FC:  MOVFF  690,741
08900:  CLRF   x44
08902:  MOVLW  B5
08904:  MOVWF  x43
08906:  MOVLB  0
08908:  CALL   08BE
0890C:  MOVFF  02,741
08910:  MOVFF  01,740
08914:  MOVLW  06
08916:  MOVLB  7
08918:  ADDWF  x40,F
0891A:  MOVLW  00
0891C:  ADDWFC x41,F
0891E:  MOVLW  32
08920:  ADDWF  x40,W
08922:  MOVWF  01
08924:  MOVLW  00
08926:  ADDWFC x41,W
08928:  MOVWF  03
0892A:  MOVF   01,W
0892C:  ADDLW  EB
0892E:  MOVWF  01
08930:  MOVLW  01
08932:  ADDWFC 03,F
08934:  MOVFF  01,70B
08938:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0893C:  MOVFF  70E,742
08940:  MOVFF  70D,741
08944:  MOVFF  70C,744
08948:  MOVFF  70B,743
0894C:  MOVLB  0
0894E:  CALL   5B14
08952:  MOVF   01,F
08954:  BNZ   89AC
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08956:  MOVLW  04
08958:  MOVLB  7
0895A:  MOVWF  x42
0895C:  MOVLW  C1
0895E:  MOVWF  x41
08960:  MOVLB  0
08962:  CALL   55A0
08966:  MOVFF  02,03
0896A:  MOVF   01,W
0896C:  ADDLW  C1
0896E:  MOVLB  7
08970:  MOVWF  x40
08972:  MOVLW  04
08974:  ADDWFC 02,W
08976:  MOVWF  x41
08978:  MOVFF  FE8,565
0897C:  MOVFF  740,564
08980:  MOVLW  89
08982:  MOVWF  FE9
08984:  MOVFF  FE,746
08988:  MOVFF  FD,745
0898C:  MOVFF  FC,744
08990:  MOVFF  FB,743
08994:  MOVLW  02
08996:  MOVWF  x47
08998:  MOVLB  0
0899A:  CALL   5776
0899E:  MOVLW  2C
089A0:  MOVLB  7
089A2:  MOVWF  x50
089A4:  MOVLB  0
089A6:  CALL   55D8
....................    }
089AA:  BRA    8EAE
....................    else if (0 == strcmp(s_200, arg1)) {
089AC:  MOVFF  714,742
089B0:  MOVFF  713,741
089B4:  MOVFF  70C,744
089B8:  MOVFF  70B,743
089BC:  CALL   5B14
089C0:  MOVF   01,F
089C2:  BNZ   8A1A
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
089C4:  MOVLW  04
089C6:  MOVLB  7
089C8:  MOVWF  x42
089CA:  MOVLW  C1
089CC:  MOVWF  x41
089CE:  MOVLB  0
089D0:  CALL   55A0
089D4:  MOVFF  02,03
089D8:  MOVF   01,W
089DA:  ADDLW  C1
089DC:  MOVLB  7
089DE:  MOVWF  x40
089E0:  MOVLW  04
089E2:  ADDWFC 02,W
089E4:  MOVWF  x41
089E6:  MOVFF  FE8,565
089EA:  MOVFF  740,564
089EE:  MOVLW  89
089F0:  MOVWF  FE9
089F2:  MOVFF  102,746
089F6:  MOVFF  101,745
089FA:  MOVFF  100,744
089FE:  MOVFF  FF,743
08A02:  MOVLW  01
08A04:  MOVWF  x47
08A06:  MOVLB  0
08A08:  CALL   5776
08A0C:  MOVLW  2C
08A0E:  MOVLB  7
08A10:  MOVWF  x50
08A12:  MOVLB  0
08A14:  CALL   55D8
....................    }
08A18:  BRA    8EAE
....................    else if (0 == strcmp(s_5V6, arg1)) {
08A1A:  MOVFF  71A,742
08A1E:  MOVFF  719,741
08A22:  MOVFF  70C,744
08A26:  MOVFF  70B,743
08A2A:  CALL   5B14
08A2E:  MOVF   01,F
08A30:  BNZ   8A88
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08A32:  MOVLW  04
08A34:  MOVLB  7
08A36:  MOVWF  x42
08A38:  MOVLW  C1
08A3A:  MOVWF  x41
08A3C:  MOVLB  0
08A3E:  CALL   55A0
08A42:  MOVFF  02,03
08A46:  MOVF   01,W
08A48:  ADDLW  C1
08A4A:  MOVLB  7
08A4C:  MOVWF  x40
08A4E:  MOVLW  04
08A50:  ADDWFC 02,W
08A52:  MOVWF  x41
08A54:  MOVFF  FE8,565
08A58:  MOVFF  740,564
08A5C:  MOVLW  89
08A5E:  MOVWF  FE9
08A60:  MOVFF  106,746
08A64:  MOVFF  105,745
08A68:  MOVFF  104,744
08A6C:  MOVFF  103,743
08A70:  MOVLW  03
08A72:  MOVWF  x47
08A74:  MOVLB  0
08A76:  CALL   5776
08A7A:  MOVLW  2C
08A7C:  MOVLB  7
08A7E:  MOVWF  x50
08A80:  MOVLB  0
08A82:  CALL   55D8
....................    }
08A86:  BRA    8EAE
....................    else if (0 == strcmp(s_5VA, arg1)) {
08A88:  MOVFF  720,742
08A8C:  MOVFF  71F,741
08A90:  MOVFF  70C,744
08A94:  MOVFF  70B,743
08A98:  CALL   5B14
08A9C:  MOVF   01,F
08A9E:  BNZ   8AF6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08AA0:  MOVLW  04
08AA2:  MOVLB  7
08AA4:  MOVWF  x42
08AA6:  MOVLW  C1
08AA8:  MOVWF  x41
08AAA:  MOVLB  0
08AAC:  CALL   55A0
08AB0:  MOVFF  02,03
08AB4:  MOVF   01,W
08AB6:  ADDLW  C1
08AB8:  MOVLB  7
08ABA:  MOVWF  x40
08ABC:  MOVLW  04
08ABE:  ADDWFC 02,W
08AC0:  MOVWF  x41
08AC2:  MOVFF  FE8,565
08AC6:  MOVFF  740,564
08ACA:  MOVLW  89
08ACC:  MOVWF  FE9
08ACE:  MOVFF  10A,746
08AD2:  MOVFF  109,745
08AD6:  MOVFF  108,744
08ADA:  MOVFF  107,743
08ADE:  MOVLW  03
08AE0:  MOVWF  x47
08AE2:  MOVLB  0
08AE4:  CALL   5776
08AE8:  MOVLW  2C
08AEA:  MOVLB  7
08AEC:  MOVWF  x50
08AEE:  MOVLB  0
08AF0:  CALL   55D8
....................    }
08AF4:  BRA    8EAE
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08AF6:  MOVFF  726,742
08AFA:  MOVFF  725,741
08AFE:  MOVFF  70C,744
08B02:  MOVFF  70B,743
08B06:  CALL   5B14
08B0A:  MOVF   01,F
08B0C:  BNZ   8B64
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08B0E:  MOVLW  04
08B10:  MOVLB  7
08B12:  MOVWF  x42
08B14:  MOVLW  C1
08B16:  MOVWF  x41
08B18:  MOVLB  0
08B1A:  CALL   55A0
08B1E:  MOVFF  02,03
08B22:  MOVF   01,W
08B24:  ADDLW  C1
08B26:  MOVLB  7
08B28:  MOVWF  x40
08B2A:  MOVLW  04
08B2C:  ADDWFC 02,W
08B2E:  MOVWF  x41
08B30:  MOVFF  FE8,565
08B34:  MOVFF  740,564
08B38:  MOVLW  89
08B3A:  MOVWF  FE9
08B3C:  MOVFF  10E,746
08B40:  MOVFF  10D,745
08B44:  MOVFF  10C,744
08B48:  MOVFF  10B,743
08B4C:  MOVLW  03
08B4E:  MOVWF  x47
08B50:  MOVLB  0
08B52:  CALL   5776
08B56:  MOVLW  2C
08B58:  MOVLB  7
08B5A:  MOVWF  x50
08B5C:  MOVLB  0
08B5E:  CALL   55D8
....................    }
08B62:  BRA    8EAE
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08B64:  MOVFF  72D,742
08B68:  MOVFF  72C,741
08B6C:  MOVFF  70C,744
08B70:  MOVFF  70B,743
08B74:  CALL   5B14
08B78:  MOVF   01,F
08B7A:  BNZ   8BD2
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08B7C:  MOVLW  04
08B7E:  MOVLB  7
08B80:  MOVWF  x42
08B82:  MOVLW  C1
08B84:  MOVWF  x41
08B86:  MOVLB  0
08B88:  CALL   55A0
08B8C:  MOVFF  02,03
08B90:  MOVF   01,W
08B92:  ADDLW  C1
08B94:  MOVLB  7
08B96:  MOVWF  x40
08B98:  MOVLW  04
08B9A:  ADDWFC 02,W
08B9C:  MOVWF  x41
08B9E:  MOVFF  FE8,565
08BA2:  MOVFF  740,564
08BA6:  MOVLW  89
08BA8:  MOVWF  FE9
08BAA:  MOVFF  112,746
08BAE:  MOVFF  111,745
08BB2:  MOVFF  110,744
08BB6:  MOVFF  10F,743
08BBA:  MOVLW  03
08BBC:  MOVWF  x47
08BBE:  MOVLB  0
08BC0:  CALL   5776
08BC4:  MOVLW  2C
08BC6:  MOVLB  7
08BC8:  MOVWF  x50
08BCA:  MOVLB  0
08BCC:  CALL   55D8
....................    }
08BD0:  BRA    8EAE
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08BD2:  MOVFF  734,742
08BD6:  MOVFF  733,741
08BDA:  MOVFF  70C,744
08BDE:  MOVFF  70B,743
08BE2:  CALL   5B14
08BE6:  MOVF   01,F
08BE8:  BNZ   8C40
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08BEA:  MOVLW  04
08BEC:  MOVLB  7
08BEE:  MOVWF  x42
08BF0:  MOVLW  C1
08BF2:  MOVWF  x41
08BF4:  MOVLB  0
08BF6:  CALL   55A0
08BFA:  MOVFF  02,03
08BFE:  MOVF   01,W
08C00:  ADDLW  C1
08C02:  MOVLB  7
08C04:  MOVWF  x40
08C06:  MOVLW  04
08C08:  ADDWFC 02,W
08C0A:  MOVWF  x41
08C0C:  MOVFF  FE8,565
08C10:  MOVFF  740,564
08C14:  MOVLW  89
08C16:  MOVWF  FE9
08C18:  MOVFF  116,746
08C1C:  MOVFF  115,745
08C20:  MOVFF  114,744
08C24:  MOVFF  113,743
08C28:  MOVLW  03
08C2A:  MOVWF  x47
08C2C:  MOVLB  0
08C2E:  CALL   5776
08C32:  MOVLW  2C
08C34:  MOVLB  7
08C36:  MOVWF  x50
08C38:  MOVLB  0
08C3A:  CALL   55D8
....................    }
08C3E:  BRA    8EAE
....................    else if (0 == strcmp(s_all, arg1)) {
08C40:  MOVFF  73B,742
08C44:  MOVFF  73A,741
08C48:  MOVFF  70C,744
08C4C:  MOVFF  70B,743
08C50:  CALL   5B14
08C54:  MOVF   01,F
08C56:  BTFSS  FD8.2
08C58:  BRA    8EA8
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08C5A:  MOVLW  04
08C5C:  MOVLB  7
08C5E:  MOVWF  x42
08C60:  MOVLW  C1
08C62:  MOVWF  x41
08C64:  MOVLB  0
08C66:  CALL   55A0
08C6A:  MOVFF  02,03
08C6E:  MOVF   01,W
08C70:  ADDLW  C1
08C72:  MOVLB  7
08C74:  MOVWF  x40
08C76:  MOVLW  04
08C78:  ADDWFC 02,W
08C7A:  MOVWF  x41
08C7C:  MOVFF  FE8,565
08C80:  MOVFF  740,564
08C84:  MOVLW  89
08C86:  MOVWF  FE9
08C88:  MOVFF  FE,746
08C8C:  MOVFF  FD,745
08C90:  MOVFF  FC,744
08C94:  MOVFF  FB,743
08C98:  MOVLW  02
08C9A:  MOVWF  x47
08C9C:  MOVLB  0
08C9E:  CALL   5776
08CA2:  MOVLW  2C
08CA4:  MOVLB  7
08CA6:  MOVWF  x50
08CA8:  MOVLB  0
08CAA:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08CAE:  MOVLW  04
08CB0:  MOVLB  7
08CB2:  MOVWF  x42
08CB4:  MOVLW  C1
08CB6:  MOVWF  x41
08CB8:  MOVLB  0
08CBA:  CALL   55A0
08CBE:  MOVFF  02,03
08CC2:  MOVF   01,W
08CC4:  ADDLW  C1
08CC6:  MOVLB  7
08CC8:  MOVWF  x40
08CCA:  MOVLW  04
08CCC:  ADDWFC 02,W
08CCE:  MOVWF  x41
08CD0:  MOVFF  FE8,565
08CD4:  MOVFF  740,564
08CD8:  MOVLW  89
08CDA:  MOVWF  FE9
08CDC:  MOVFF  102,746
08CE0:  MOVFF  101,745
08CE4:  MOVFF  100,744
08CE8:  MOVFF  FF,743
08CEC:  MOVLW  01
08CEE:  MOVWF  x47
08CF0:  MOVLB  0
08CF2:  CALL   5776
08CF6:  MOVLW  2C
08CF8:  MOVLB  7
08CFA:  MOVWF  x50
08CFC:  MOVLB  0
08CFE:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08D02:  MOVLW  04
08D04:  MOVLB  7
08D06:  MOVWF  x42
08D08:  MOVLW  C1
08D0A:  MOVWF  x41
08D0C:  MOVLB  0
08D0E:  CALL   55A0
08D12:  MOVFF  02,03
08D16:  MOVF   01,W
08D18:  ADDLW  C1
08D1A:  MOVLB  7
08D1C:  MOVWF  x40
08D1E:  MOVLW  04
08D20:  ADDWFC 02,W
08D22:  MOVWF  x41
08D24:  MOVFF  FE8,565
08D28:  MOVFF  740,564
08D2C:  MOVLW  89
08D2E:  MOVWF  FE9
08D30:  MOVFF  106,746
08D34:  MOVFF  105,745
08D38:  MOVFF  104,744
08D3C:  MOVFF  103,743
08D40:  MOVLW  03
08D42:  MOVWF  x47
08D44:  MOVLB  0
08D46:  CALL   5776
08D4A:  MOVLW  2C
08D4C:  MOVLB  7
08D4E:  MOVWF  x50
08D50:  MOVLB  0
08D52:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08D56:  MOVLW  04
08D58:  MOVLB  7
08D5A:  MOVWF  x42
08D5C:  MOVLW  C1
08D5E:  MOVWF  x41
08D60:  MOVLB  0
08D62:  CALL   55A0
08D66:  MOVFF  02,03
08D6A:  MOVF   01,W
08D6C:  ADDLW  C1
08D6E:  MOVLB  7
08D70:  MOVWF  x40
08D72:  MOVLW  04
08D74:  ADDWFC 02,W
08D76:  MOVWF  x41
08D78:  MOVFF  FE8,565
08D7C:  MOVFF  740,564
08D80:  MOVLW  89
08D82:  MOVWF  FE9
08D84:  MOVFF  10A,746
08D88:  MOVFF  109,745
08D8C:  MOVFF  108,744
08D90:  MOVFF  107,743
08D94:  MOVLW  03
08D96:  MOVWF  x47
08D98:  MOVLB  0
08D9A:  CALL   5776
08D9E:  MOVLW  2C
08DA0:  MOVLB  7
08DA2:  MOVWF  x50
08DA4:  MOVLB  0
08DA6:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08DAA:  MOVLW  04
08DAC:  MOVLB  7
08DAE:  MOVWF  x42
08DB0:  MOVLW  C1
08DB2:  MOVWF  x41
08DB4:  MOVLB  0
08DB6:  CALL   55A0
08DBA:  MOVFF  02,03
08DBE:  MOVF   01,W
08DC0:  ADDLW  C1
08DC2:  MOVLB  7
08DC4:  MOVWF  x40
08DC6:  MOVLW  04
08DC8:  ADDWFC 02,W
08DCA:  MOVWF  x41
08DCC:  MOVFF  FE8,565
08DD0:  MOVFF  740,564
08DD4:  MOVLW  89
08DD6:  MOVWF  FE9
08DD8:  MOVFF  10E,746
08DDC:  MOVFF  10D,745
08DE0:  MOVFF  10C,744
08DE4:  MOVFF  10B,743
08DE8:  MOVLW  03
08DEA:  MOVWF  x47
08DEC:  MOVLB  0
08DEE:  CALL   5776
08DF2:  MOVLW  2C
08DF4:  MOVLB  7
08DF6:  MOVWF  x50
08DF8:  MOVLB  0
08DFA:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08DFE:  MOVLW  04
08E00:  MOVLB  7
08E02:  MOVWF  x42
08E04:  MOVLW  C1
08E06:  MOVWF  x41
08E08:  MOVLB  0
08E0A:  CALL   55A0
08E0E:  MOVFF  02,03
08E12:  MOVF   01,W
08E14:  ADDLW  C1
08E16:  MOVLB  7
08E18:  MOVWF  x40
08E1A:  MOVLW  04
08E1C:  ADDWFC 02,W
08E1E:  MOVWF  x41
08E20:  MOVFF  FE8,565
08E24:  MOVFF  740,564
08E28:  MOVLW  89
08E2A:  MOVWF  FE9
08E2C:  MOVFF  112,746
08E30:  MOVFF  111,745
08E34:  MOVFF  110,744
08E38:  MOVFF  10F,743
08E3C:  MOVLW  03
08E3E:  MOVWF  x47
08E40:  MOVLB  0
08E42:  CALL   5776
08E46:  MOVLW  2C
08E48:  MOVLB  7
08E4A:  MOVWF  x50
08E4C:  MOVLB  0
08E4E:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08E52:  MOVLW  04
08E54:  MOVLB  7
08E56:  MOVWF  x42
08E58:  MOVLW  C1
08E5A:  MOVWF  x41
08E5C:  MOVLB  0
08E5E:  CALL   55A0
08E62:  MOVFF  02,03
08E66:  MOVF   01,W
08E68:  ADDLW  C1
08E6A:  MOVLB  7
08E6C:  MOVWF  x40
08E6E:  MOVLW  04
08E70:  ADDWFC 02,W
08E72:  MOVWF  x41
08E74:  MOVFF  FE8,565
08E78:  MOVFF  740,564
08E7C:  MOVLW  89
08E7E:  MOVWF  FE9
08E80:  MOVFF  116,746
08E84:  MOVFF  115,745
08E88:  MOVFF  114,744
08E8C:  MOVFF  113,743
08E90:  MOVLW  03
08E92:  MOVWF  x47
08E94:  MOVLB  0
08E96:  CALL   5776
08E9A:  MOVLW  2C
08E9C:  MOVLB  7
08E9E:  MOVWF  x50
08EA0:  MOVLB  0
08EA2:  CALL   55D8
....................    }
08EA6:  BRA    8EAE
....................    else return INV_PARAM;
08EA8:  MOVLW  02
08EAA:  MOVWF  01
08EAC:  BRA    8EB2
....................    
....................    return SUCCESS;
08EAE:  MOVLW  00
08EB0:  MOVWF  01
08EB2:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08EB4:  MOVLW  50
08EB6:  MOVLB  7
08EB8:  MOVWF  x10
08EBA:  MOVLW  56
08EBC:  MOVWF  x11
08EBE:  CLRF   x12
08EC0:  MOVLW  07
08EC2:  MOVWF  x0F
08EC4:  MOVLW  10
08EC6:  MOVWF  x0E
....................    char *s_CV = "CV";
08EC8:  MOVLW  43
08ECA:  MOVWF  x15
08ECC:  MOVLW  56
08ECE:  MOVWF  x16
08ED0:  CLRF   x17
08ED2:  MOVLW  07
08ED4:  MOVWF  x14
08ED6:  MOVLW  15
08ED8:  MOVWF  x13
....................    char *s_PVold = "PVold";
08EDA:  MOVLW  50
08EDC:  MOVWF  x1A
08EDE:  MOVLW  56
08EE0:  MOVWF  x1B
08EE2:  MOVLW  6F
08EE4:  MOVWF  x1C
08EE6:  MOVLW  6C
08EE8:  MOVWF  x1D
08EEA:  MOVLW  64
08EEC:  MOVWF  x1E
08EEE:  CLRF   x1F
08EF0:  MOVLW  07
08EF2:  MOVWF  x19
08EF4:  MOVLW  1A
08EF6:  MOVWF  x18
....................    char *s_I = "I";
08EF8:  MOVLW  49
08EFA:  MOVWF  x22
08EFC:  CLRF   x23
08EFE:  MOVLW  07
08F00:  MOVWF  x21
08F02:  MOVLW  22
08F04:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08F06:  CLRF   x42
08F08:  MOVFF  690,741
08F0C:  CLRF   x44
08F0E:  MOVLW  B5
08F10:  MOVWF  x43
08F12:  MOVLB  0
08F14:  CALL   08BE
08F18:  MOVFF  02,725
08F1C:  MOVFF  01,724
08F20:  MOVLW  06
08F22:  MOVLB  7
08F24:  ADDWF  x24,F
08F26:  MOVLW  00
08F28:  ADDWFC x25,F
08F2A:  MOVLW  32
08F2C:  ADDWF  x24,W
08F2E:  MOVWF  01
08F30:  MOVLW  00
08F32:  ADDWFC x25,W
08F34:  MOVWF  03
08F36:  MOVF   01,W
08F38:  ADDLW  EB
08F3A:  MOVWF  01
08F3C:  MOVLW  01
08F3E:  ADDWFC 03,F
08F40:  MOVFF  01,724
08F44:  MOVFF  03,725
08F48:  MOVFF  03,734
08F4C:  MOVFF  01,733
08F50:  MOVLB  0
08F52:  CALL   5C34
08F56:  MOVF   01,F
08F58:  BNZ   8F62
08F5A:  MOVLW  02
08F5C:  MOVWF  01
08F5E:  BRA    92F8
08F60:  BRA    8FC0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08F62:  MOVLB  7
08F64:  CLRF   x42
08F66:  MOVFF  690,741
08F6A:  CLRF   x44
08F6C:  MOVLW  B5
08F6E:  MOVWF  x43
08F70:  MOVLB  0
08F72:  CALL   08BE
08F76:  MOVFF  02,725
08F7A:  MOVFF  01,724
08F7E:  MOVLW  06
08F80:  MOVLB  7
08F82:  ADDWF  x24,F
08F84:  MOVLW  00
08F86:  ADDWFC x25,F
08F88:  MOVLW  32
08F8A:  ADDWF  x24,W
08F8C:  MOVWF  01
08F8E:  MOVLW  00
08F90:  ADDWFC x25,W
08F92:  MOVWF  03
08F94:  MOVF   01,W
08F96:  ADDLW  EB
08F98:  MOVWF  01
08F9A:  MOVLW  01
08F9C:  ADDWFC 03,F
08F9E:  MOVFF  01,724
08FA2:  MOVFF  03,725
08FA6:  MOVFF  03,734
08FAA:  MOVFF  01,733
08FAE:  CLRF   x36
08FB0:  CLRF   x35
08FB2:  MOVLW  0A
08FB4:  MOVWF  x37
08FB6:  MOVLB  0
08FB8:  CALL   5D24
08FBC:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
08FC0:  MOVLB  7
08FC2:  CLRF   x42
08FC4:  MOVFF  690,741
08FC8:  CLRF   x44
08FCA:  MOVLW  B5
08FCC:  MOVWF  x43
08FCE:  MOVLB  0
08FD0:  CALL   08BE
08FD4:  MOVFF  02,725
08FD8:  MOVFF  01,724
08FDC:  MOVLW  06
08FDE:  MOVLB  7
08FE0:  ADDWF  x24,F
08FE2:  MOVLW  00
08FE4:  ADDWFC x25,F
08FE6:  MOVLW  4B
08FE8:  ADDWF  x24,W
08FEA:  MOVWF  01
08FEC:  MOVLW  00
08FEE:  ADDWFC x25,W
08FF0:  MOVWF  03
08FF2:  MOVF   01,W
08FF4:  ADDLW  EB
08FF6:  MOVWF  01
08FF8:  MOVLW  01
08FFA:  ADDWFC 03,F
08FFC:  MOVFF  01,70C
09000:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09004:  MOVFF  70F,742
09008:  MOVFF  70E,741
0900C:  MOVFF  70D,744
09010:  MOVFF  70C,743
09014:  MOVLB  0
09016:  CALL   5B14
0901A:  MOVF   01,F
0901C:  BNZ   90C0
0901E:  MOVLW  04
09020:  MOVLB  7
09022:  MOVWF  x42
09024:  MOVLW  C1
09026:  MOVWF  x41
09028:  MOVLB  0
0902A:  CALL   55A0
0902E:  MOVF   01,W
09030:  ADDLW  C1
09032:  MOVLB  7
09034:  MOVWF  x24
09036:  MOVLW  04
09038:  ADDWFC 02,W
0903A:  MOVWF  x25
0903C:  MOVLW  01
0903E:  SUBWF  x0B,W
09040:  MULLW  28
09042:  MOVF   FF3,W
09044:  CLRF   x27
09046:  MOVWF  x26
09048:  MOVLW  10
0904A:  ADDWF  x26,W
0904C:  MOVWF  01
0904E:  MOVLW  00
09050:  ADDWFC x27,W
09052:  MOVWF  03
09054:  MOVF   01,W
09056:  ADDLW  20
09058:  MOVWF  FE9
0905A:  MOVLW  00
0905C:  ADDWFC 03,W
0905E:  MOVWF  FEA
09060:  MOVFF  FEF,726
09064:  MOVFF  FEC,727
09068:  MOVFF  FEC,728
0906C:  MOVFF  FEC,729
09070:  MOVFF  725,565
09074:  MOVFF  724,564
09078:  MOVFF  70B,734
0907C:  MOVLW  18
0907E:  MOVWF  x35
09080:  MOVLB  0
09082:  CALL   6078
09086:  MOVLW  2C
09088:  MOVLB  7
0908A:  MOVWF  x50
0908C:  MOVLB  0
0908E:  CALL   55D8
09092:  MOVLW  89
09094:  MOVWF  FE9
09096:  MOVFF  729,746
0909A:  MOVFF  728,745
0909E:  MOVFF  727,744
090A2:  MOVFF  726,743
090A6:  MOVLW  02
090A8:  MOVLB  7
090AA:  MOVWF  x47
090AC:  MOVLB  0
090AE:  CALL   5776
090B2:  MOVLW  2C
090B4:  MOVLB  7
090B6:  MOVWF  x50
090B8:  MOVLB  0
090BA:  CALL   55D8
090BE:  BRA    92F4
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
090C0:  MOVFF  714,742
090C4:  MOVFF  713,741
090C8:  MOVFF  70D,744
090CC:  MOVFF  70C,743
090D0:  CALL   5B14
090D4:  MOVF   01,F
090D6:  BNZ   917A
090D8:  MOVLW  04
090DA:  MOVLB  7
090DC:  MOVWF  x42
090DE:  MOVLW  C1
090E0:  MOVWF  x41
090E2:  MOVLB  0
090E4:  CALL   55A0
090E8:  MOVF   01,W
090EA:  ADDLW  C1
090EC:  MOVLB  7
090EE:  MOVWF  x24
090F0:  MOVLW  04
090F2:  ADDWFC 02,W
090F4:  MOVWF  x25
090F6:  MOVLW  01
090F8:  SUBWF  x0B,W
090FA:  MULLW  28
090FC:  MOVF   FF3,W
090FE:  CLRF   x27
09100:  MOVWF  x26
09102:  MOVLW  18
09104:  ADDWF  x26,W
09106:  MOVWF  01
09108:  MOVLW  00
0910A:  ADDWFC x27,W
0910C:  MOVWF  03
0910E:  MOVF   01,W
09110:  ADDLW  20
09112:  MOVWF  FE9
09114:  MOVLW  00
09116:  ADDWFC 03,W
09118:  MOVWF  FEA
0911A:  MOVFF  FEF,726
0911E:  MOVFF  FEC,727
09122:  MOVFF  FEC,728
09126:  MOVFF  FEC,729
0912A:  MOVFF  725,565
0912E:  MOVFF  724,564
09132:  MOVFF  70B,734
09136:  MOVLW  18
09138:  MOVWF  x35
0913A:  MOVLB  0
0913C:  CALL   6078
09140:  MOVLW  2C
09142:  MOVLB  7
09144:  MOVWF  x50
09146:  MOVLB  0
09148:  CALL   55D8
0914C:  MOVLW  89
0914E:  MOVWF  FE9
09150:  MOVFF  729,746
09154:  MOVFF  728,745
09158:  MOVFF  727,744
0915C:  MOVFF  726,743
09160:  MOVLW  02
09162:  MOVLB  7
09164:  MOVWF  x47
09166:  MOVLB  0
09168:  CALL   5776
0916C:  MOVLW  2C
0916E:  MOVLB  7
09170:  MOVWF  x50
09172:  MOVLB  0
09174:  CALL   55D8
09178:  BRA    92F4
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
0917A:  MOVFF  719,742
0917E:  MOVFF  718,741
09182:  MOVFF  70D,744
09186:  MOVFF  70C,743
0918A:  CALL   5B14
0918E:  MOVF   01,F
09190:  BNZ   9234
09192:  MOVLW  04
09194:  MOVLB  7
09196:  MOVWF  x42
09198:  MOVLW  C1
0919A:  MOVWF  x41
0919C:  MOVLB  0
0919E:  CALL   55A0
091A2:  MOVF   01,W
091A4:  ADDLW  C1
091A6:  MOVLB  7
091A8:  MOVWF  x24
091AA:  MOVLW  04
091AC:  ADDWFC 02,W
091AE:  MOVWF  x25
091B0:  MOVLW  01
091B2:  SUBWF  x0B,W
091B4:  MULLW  28
091B6:  MOVF   FF3,W
091B8:  CLRF   x27
091BA:  MOVWF  x26
091BC:  MOVLW  14
091BE:  ADDWF  x26,W
091C0:  MOVWF  01
091C2:  MOVLW  00
091C4:  ADDWFC x27,W
091C6:  MOVWF  03
091C8:  MOVF   01,W
091CA:  ADDLW  20
091CC:  MOVWF  FE9
091CE:  MOVLW  00
091D0:  ADDWFC 03,W
091D2:  MOVWF  FEA
091D4:  MOVFF  FEF,726
091D8:  MOVFF  FEC,727
091DC:  MOVFF  FEC,728
091E0:  MOVFF  FEC,729
091E4:  MOVFF  725,565
091E8:  MOVFF  724,564
091EC:  MOVFF  70B,734
091F0:  MOVLW  18
091F2:  MOVWF  x35
091F4:  MOVLB  0
091F6:  CALL   6078
091FA:  MOVLW  2C
091FC:  MOVLB  7
091FE:  MOVWF  x50
09200:  MOVLB  0
09202:  CALL   55D8
09206:  MOVLW  89
09208:  MOVWF  FE9
0920A:  MOVFF  729,746
0920E:  MOVFF  728,745
09212:  MOVFF  727,744
09216:  MOVFF  726,743
0921A:  MOVLW  02
0921C:  MOVLB  7
0921E:  MOVWF  x47
09220:  MOVLB  0
09222:  CALL   5776
09226:  MOVLW  2C
09228:  MOVLB  7
0922A:  MOVWF  x50
0922C:  MOVLB  0
0922E:  CALL   55D8
09232:  BRA    92F4
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09234:  MOVFF  721,742
09238:  MOVFF  720,741
0923C:  MOVFF  70D,744
09240:  MOVFF  70C,743
09244:  CALL   5B14
09248:  MOVF   01,F
0924A:  BNZ   92EE
0924C:  MOVLW  04
0924E:  MOVLB  7
09250:  MOVWF  x42
09252:  MOVLW  C1
09254:  MOVWF  x41
09256:  MOVLB  0
09258:  CALL   55A0
0925C:  MOVF   01,W
0925E:  ADDLW  C1
09260:  MOVLB  7
09262:  MOVWF  x24
09264:  MOVLW  04
09266:  ADDWFC 02,W
09268:  MOVWF  x25
0926A:  MOVLW  01
0926C:  SUBWF  x0B,W
0926E:  MULLW  28
09270:  MOVF   FF3,W
09272:  CLRF   x27
09274:  MOVWF  x26
09276:  MOVLW  1C
09278:  ADDWF  x26,W
0927A:  MOVWF  01
0927C:  MOVLW  00
0927E:  ADDWFC x27,W
09280:  MOVWF  03
09282:  MOVF   01,W
09284:  ADDLW  20
09286:  MOVWF  FE9
09288:  MOVLW  00
0928A:  ADDWFC 03,W
0928C:  MOVWF  FEA
0928E:  MOVFF  FEF,726
09292:  MOVFF  FEC,727
09296:  MOVFF  FEC,728
0929A:  MOVFF  FEC,729
0929E:  MOVFF  725,565
092A2:  MOVFF  724,564
092A6:  MOVFF  70B,734
092AA:  MOVLW  18
092AC:  MOVWF  x35
092AE:  MOVLB  0
092B0:  CALL   6078
092B4:  MOVLW  2C
092B6:  MOVLB  7
092B8:  MOVWF  x50
092BA:  MOVLB  0
092BC:  CALL   55D8
092C0:  MOVLW  89
092C2:  MOVWF  FE9
092C4:  MOVFF  729,746
092C8:  MOVFF  728,745
092CC:  MOVFF  727,744
092D0:  MOVFF  726,743
092D4:  MOVLW  02
092D6:  MOVLB  7
092D8:  MOVWF  x47
092DA:  MOVLB  0
092DC:  CALL   5776
092E0:  MOVLW  2C
092E2:  MOVLB  7
092E4:  MOVWF  x50
092E6:  MOVLB  0
092E8:  CALL   55D8
092EC:  BRA    92F4
....................    else return INV_PARAM;
092EE:  MOVLW  02
092F0:  MOVWF  01
092F2:  BRA    92F8
....................    
....................    return SUCCESS;
092F4:  MOVLW  00
092F6:  MOVWF  01
092F8:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
09418:  MOVLW  72
0941A:  MOVLB  7
0941C:  MOVWF  x10
0941E:  MOVLW  61
09420:  MOVWF  x11
09422:  MOVLW  77
09424:  MOVWF  x12
09426:  CLRF   x13
09428:  MOVLW  07
0942A:  MOVWF  x0F
0942C:  MOVLW  10
0942E:  MOVWF  x0E
....................    char *s_calibrated = "calib";
09430:  MOVLW  63
09432:  MOVWF  x16
09434:  MOVLW  61
09436:  MOVWF  x17
09438:  MOVLW  6C
0943A:  MOVWF  x18
0943C:  MOVLW  69
0943E:  MOVWF  x19
09440:  MOVLW  62
09442:  MOVWF  x1A
09444:  CLRF   x1B
09446:  MOVLW  07
09448:  MOVWF  x15
0944A:  MOVLW  16
0944C:  MOVWF  x14
....................    char *s_p0 = "p0";
0944E:  MOVLW  70
09450:  MOVWF  x1E
09452:  MOVLW  30
09454:  MOVWF  x1F
09456:  CLRF   x20
09458:  MOVLW  07
0945A:  MOVWF  x1D
0945C:  MOVLW  1E
0945E:  MOVWF  x1C
....................    char *s_poles = "poles";
09460:  MOVLW  70
09462:  MOVWF  x23
09464:  MOVLW  6F
09466:  MOVWF  x24
09468:  MOVLW  6C
0946A:  MOVWF  x25
0946C:  MOVLW  65
0946E:  MOVWF  x26
09470:  MOVLW  73
09472:  MOVWF  x27
09474:  CLRF   x28
09476:  MOVLW  07
09478:  MOVWF  x22
0947A:  MOVLW  23
0947C:  MOVWF  x21
....................    char *s_real = "real";
0947E:  MOVLW  72
09480:  MOVWF  x2B
09482:  MOVLW  65
09484:  MOVWF  x2C
09486:  MOVLW  61
09488:  MOVWF  x2D
0948A:  MOVLW  6C
0948C:  MOVWF  x2E
0948E:  CLRF   x2F
09490:  MOVLW  07
09492:  MOVWF  x2A
09494:  MOVLW  2B
09496:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09498:  CLRF   x42
0949A:  MOVFF  690,741
0949E:  CLRF   x44
094A0:  MOVLW  B5
094A2:  MOVWF  x43
094A4:  MOVLB  0
094A6:  CALL   08BE
094AA:  MOVFF  02,731
094AE:  MOVFF  01,730
094B2:  MOVLW  06
094B4:  MOVLB  7
094B6:  ADDWF  x30,F
094B8:  MOVLW  00
094BA:  ADDWFC x31,F
094BC:  MOVLW  32
094BE:  ADDWF  x30,W
094C0:  MOVWF  01
094C2:  MOVLW  00
094C4:  ADDWFC x31,W
094C6:  MOVWF  03
094C8:  MOVF   01,W
094CA:  ADDLW  EB
094CC:  MOVWF  01
094CE:  MOVLW  01
094D0:  ADDWFC 03,F
094D2:  MOVFF  01,730
094D6:  MOVFF  03,731
094DA:  MOVFF  03,734
094DE:  MOVFF  01,733
094E2:  MOVLB  0
094E4:  CALL   5C34
094E8:  MOVF   01,F
094EA:  BNZ   94F4
094EC:  MOVLW  02
094EE:  MOVWF  01
094F0:  BRA    9B38
094F2:  BRA    9552
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094F4:  MOVLB  7
094F6:  CLRF   x42
094F8:  MOVFF  690,741
094FC:  CLRF   x44
094FE:  MOVLW  B5
09500:  MOVWF  x43
09502:  MOVLB  0
09504:  CALL   08BE
09508:  MOVFF  02,731
0950C:  MOVFF  01,730
09510:  MOVLW  06
09512:  MOVLB  7
09514:  ADDWF  x30,F
09516:  MOVLW  00
09518:  ADDWFC x31,F
0951A:  MOVLW  32
0951C:  ADDWF  x30,W
0951E:  MOVWF  01
09520:  MOVLW  00
09522:  ADDWFC x31,W
09524:  MOVWF  03
09526:  MOVF   01,W
09528:  ADDLW  EB
0952A:  MOVWF  01
0952C:  MOVLW  01
0952E:  ADDWFC 03,F
09530:  MOVFF  01,730
09534:  MOVFF  03,731
09538:  MOVFF  03,734
0953C:  MOVFF  01,733
09540:  CLRF   x36
09542:  CLRF   x35
09544:  MOVLW  0A
09546:  MOVWF  x37
09548:  MOVLB  0
0954A:  CALL   5D24
0954E:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
09552:  MOVLB  7
09554:  CLRF   x42
09556:  MOVFF  690,741
0955A:  CLRF   x44
0955C:  MOVLW  B5
0955E:  MOVWF  x43
09560:  MOVLB  0
09562:  CALL   08BE
09566:  MOVFF  02,731
0956A:  MOVFF  01,730
0956E:  MOVLW  06
09570:  MOVLB  7
09572:  ADDWF  x30,F
09574:  MOVLW  00
09576:  ADDWFC x31,F
09578:  MOVLW  4B
0957A:  ADDWF  x30,W
0957C:  MOVWF  01
0957E:  MOVLW  00
09580:  ADDWFC x31,W
09582:  MOVWF  03
09584:  MOVF   01,W
09586:  ADDLW  EB
09588:  MOVWF  01
0958A:  MOVLW  01
0958C:  ADDWFC 03,F
0958E:  MOVFF  01,70C
09592:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09596:  MOVFF  70F,742
0959A:  MOVFF  70E,741
0959E:  MOVFF  70D,744
095A2:  MOVFF  70C,743
095A6:  MOVLB  0
095A8:  CALL   5B14
095AC:  MOVF   01,F
095AE:  BTFSS  FD8.2
095B0:  BRA    972C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
095B2:  MOVLW  04
095B4:  MOVLB  7
095B6:  MOVWF  x42
095B8:  MOVLW  C1
095BA:  MOVWF  x41
095BC:  MOVLB  0
095BE:  CALL   55A0
095C2:  MOVFF  02,03
095C6:  MOVF   01,W
095C8:  ADDLW  C1
095CA:  MOVLB  7
095CC:  MOVWF  x30
095CE:  MOVLW  04
095D0:  ADDWFC 02,W
095D2:  MOVWF  x31
095D4:  MOVFF  FE8,565
095D8:  MOVFF  730,564
095DC:  MOVFF  70B,734
095E0:  MOVLW  18
095E2:  MOVWF  x35
095E4:  MOVLB  0
095E6:  CALL   6078
095EA:  MOVLW  2C
095EC:  MOVLB  7
095EE:  MOVWF  x50
095F0:  MOVLB  0
095F2:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
095F6:  MOVLW  04
095F8:  MOVLB  7
095FA:  MOVWF  x42
095FC:  MOVLW  C1
095FE:  MOVWF  x41
09600:  MOVLB  0
09602:  CALL   55A0
09606:  MOVFF  02,03
0960A:  MOVF   01,W
0960C:  ADDLW  C1
0960E:  MOVLB  7
09610:  MOVWF  x30
09612:  MOVLW  04
09614:  ADDWFC 02,W
09616:  MOVWF  x31
09618:  MOVLW  01
0961A:  SUBWF  x0B,W
0961C:  MULLW  26
0961E:  MOVF   FF3,W
09620:  CLRF   x33
09622:  MOVWF  x32
09624:  MOVLW  17
09626:  ADDWF  x32,W
09628:  MOVWF  FE9
0962A:  MOVLW  01
0962C:  ADDWFC x33,W
0962E:  MOVWF  FEA
09630:  MOVFF  FEF,750
09634:  MOVFF  FEC,01
09638:  MOVFF  FEC,02
0963C:  MOVFF  FEC,03
09640:  MOVFF  03,753
09644:  MOVFF  02,752
09648:  MOVFF  01,751
0964C:  MOVLB  0
0964E:  CALL   56A0
09652:  MOVFF  03,737
09656:  MOVFF  02,736
0965A:  MOVFF  01,735
0965E:  MOVFF  00,734
09662:  MOVFF  731,565
09666:  MOVFF  730,564
0966A:  MOVLW  41
0966C:  MOVWF  FE9
0966E:  MOVFF  03,73C
09672:  MOVFF  02,73B
09676:  MOVFF  01,73A
0967A:  MOVFF  00,739
0967E:  RCALL  92FA
09680:  MOVLW  2C
09682:  MOVLB  7
09684:  MOVWF  x50
09686:  MOVLB  0
09688:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0968C:  MOVLW  04
0968E:  MOVLB  7
09690:  MOVWF  x42
09692:  MOVLW  C1
09694:  MOVWF  x41
09696:  MOVLB  0
09698:  CALL   55A0
0969C:  MOVF   01,W
0969E:  ADDLW  C1
096A0:  MOVLB  7
096A2:  MOVWF  x30
096A4:  MOVLW  04
096A6:  ADDWFC 02,W
096A8:  MOVWF  x31
096AA:  MOVLW  01
096AC:  SUBWF  x0B,W
096AE:  MULLW  26
096B0:  MOVF   FF3,W
096B2:  CLRF   x33
096B4:  MOVWF  x32
096B6:  MOVLW  04
096B8:  ADDWF  x32,W
096BA:  MOVWF  01
096BC:  MOVLW  00
096BE:  ADDWFC x33,W
096C0:  MOVWF  03
096C2:  MOVF   01,W
096C4:  ADDLW  17
096C6:  MOVWF  FE9
096C8:  MOVLW  01
096CA:  ADDWFC 03,W
096CC:  MOVWF  FEA
096CE:  MOVFF  FEF,750
096D2:  MOVFF  FEC,01
096D6:  MOVFF  FEC,02
096DA:  MOVFF  FEC,03
096DE:  MOVFF  03,753
096E2:  MOVFF  02,752
096E6:  MOVFF  01,751
096EA:  MOVLB  0
096EC:  CALL   56A0
096F0:  MOVFF  03,735
096F4:  MOVFF  02,734
096F8:  MOVFF  01,733
096FC:  MOVFF  00,732
09700:  MOVFF  731,565
09704:  MOVFF  730,564
09708:  MOVLW  41
0970A:  MOVWF  FE9
0970C:  MOVFF  03,73C
09710:  MOVFF  02,73B
09714:  MOVFF  01,73A
09718:  MOVFF  00,739
0971C:  RCALL  92FA
0971E:  MOVLW  2C
09720:  MOVLB  7
09722:  MOVWF  x50
09724:  MOVLB  0
09726:  CALL   55D8
....................    }
0972A:  BRA    9B34
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0972C:  MOVFF  715,742
09730:  MOVFF  714,741
09734:  MOVFF  70D,744
09738:  MOVFF  70C,743
0973C:  CALL   5B14
09740:  MOVF   01,F
09742:  BTFSS  FD8.2
09744:  BRA    98C8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09746:  MOVLW  04
09748:  MOVLB  7
0974A:  MOVWF  x42
0974C:  MOVLW  C1
0974E:  MOVWF  x41
09750:  MOVLB  0
09752:  CALL   55A0
09756:  MOVFF  02,03
0975A:  MOVF   01,W
0975C:  ADDLW  C1
0975E:  MOVLB  7
09760:  MOVWF  x30
09762:  MOVLW  04
09764:  ADDWFC 02,W
09766:  MOVWF  x31
09768:  MOVFF  FE8,565
0976C:  MOVFF  730,564
09770:  MOVFF  70B,734
09774:  MOVLW  18
09776:  MOVWF  x35
09778:  MOVLB  0
0977A:  CALL   6078
0977E:  MOVLW  2C
09780:  MOVLB  7
09782:  MOVWF  x50
09784:  MOVLB  0
09786:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0978A:  MOVLW  04
0978C:  MOVLB  7
0978E:  MOVWF  x42
09790:  MOVLW  C1
09792:  MOVWF  x41
09794:  MOVLB  0
09796:  CALL   55A0
0979A:  MOVF   01,W
0979C:  ADDLW  C1
0979E:  MOVLB  7
097A0:  MOVWF  x30
097A2:  MOVLW  04
097A4:  ADDWFC 02,W
097A6:  MOVWF  x31
097A8:  MOVLW  01
097AA:  SUBWF  x0B,W
097AC:  MULLW  26
097AE:  MOVF   FF3,W
097B0:  CLRF   x33
097B2:  MOVWF  x32
097B4:  MOVLW  08
097B6:  ADDWF  x32,W
097B8:  MOVWF  01
097BA:  MOVLW  00
097BC:  ADDWFC x33,W
097BE:  MOVWF  03
097C0:  MOVF   01,W
097C2:  ADDLW  17
097C4:  MOVWF  FE9
097C6:  MOVLW  01
097C8:  ADDWFC 03,W
097CA:  MOVWF  FEA
097CC:  MOVFF  FEF,750
097D0:  MOVFF  FEC,01
097D4:  MOVFF  FEC,02
097D8:  MOVFF  FEC,03
097DC:  MOVFF  03,753
097E0:  MOVFF  02,752
097E4:  MOVFF  01,751
097E8:  MOVLB  0
097EA:  CALL   56A0
097EE:  MOVFF  03,735
097F2:  MOVFF  02,734
097F6:  MOVFF  01,733
097FA:  MOVFF  00,732
097FE:  MOVFF  731,565
09802:  MOVFF  730,564
09806:  MOVLW  41
09808:  MOVWF  FE9
0980A:  MOVFF  03,73C
0980E:  MOVFF  02,73B
09812:  MOVFF  01,73A
09816:  MOVFF  00,739
0981A:  RCALL  92FA
0981C:  MOVLW  2C
0981E:  MOVLB  7
09820:  MOVWF  x50
09822:  MOVLB  0
09824:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09828:  MOVLW  04
0982A:  MOVLB  7
0982C:  MOVWF  x42
0982E:  MOVLW  C1
09830:  MOVWF  x41
09832:  MOVLB  0
09834:  CALL   55A0
09838:  MOVF   01,W
0983A:  ADDLW  C1
0983C:  MOVLB  7
0983E:  MOVWF  x30
09840:  MOVLW  04
09842:  ADDWFC 02,W
09844:  MOVWF  x31
09846:  MOVLW  01
09848:  SUBWF  x0B,W
0984A:  MULLW  26
0984C:  MOVF   FF3,W
0984E:  CLRF   x33
09850:  MOVWF  x32
09852:  MOVLW  0C
09854:  ADDWF  x32,W
09856:  MOVWF  01
09858:  MOVLW  00
0985A:  ADDWFC x33,W
0985C:  MOVWF  03
0985E:  MOVF   01,W
09860:  ADDLW  17
09862:  MOVWF  FE9
09864:  MOVLW  01
09866:  ADDWFC 03,W
09868:  MOVWF  FEA
0986A:  MOVFF  FEF,750
0986E:  MOVFF  FEC,01
09872:  MOVFF  FEC,02
09876:  MOVFF  FEC,03
0987A:  MOVFF  03,753
0987E:  MOVFF  02,752
09882:  MOVFF  01,751
09886:  MOVLB  0
09888:  CALL   56A0
0988C:  MOVFF  03,735
09890:  MOVFF  02,734
09894:  MOVFF  01,733
09898:  MOVFF  00,732
0989C:  MOVFF  731,565
098A0:  MOVFF  730,564
098A4:  MOVLW  41
098A6:  MOVWF  FE9
098A8:  MOVFF  03,73C
098AC:  MOVFF  02,73B
098B0:  MOVFF  01,73A
098B4:  MOVFF  00,739
098B8:  RCALL  92FA
098BA:  MOVLW  2C
098BC:  MOVLB  7
098BE:  MOVWF  x50
098C0:  MOVLB  0
098C2:  CALL   55D8
....................    }
098C6:  BRA    9B34
....................    else if (0 == strcmp(s_p0, arg2)) {
098C8:  MOVFF  71D,742
098CC:  MOVFF  71C,741
098D0:  MOVFF  70D,744
098D4:  MOVFF  70C,743
098D8:  CALL   5B14
098DC:  MOVF   01,F
098DE:  BNZ   999A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098E0:  MOVLW  04
098E2:  MOVLB  7
098E4:  MOVWF  x42
098E6:  MOVLW  C1
098E8:  MOVWF  x41
098EA:  MOVLB  0
098EC:  CALL   55A0
098F0:  MOVFF  02,03
098F4:  MOVF   01,W
098F6:  ADDLW  C1
098F8:  MOVLB  7
098FA:  MOVWF  x30
098FC:  MOVLW  04
098FE:  ADDWFC 02,W
09900:  MOVWF  x31
09902:  MOVFF  FE8,565
09906:  MOVFF  730,564
0990A:  MOVFF  70B,734
0990E:  MOVLW  18
09910:  MOVWF  x35
09912:  MOVLB  0
09914:  CALL   6078
09918:  MOVLW  2C
0991A:  MOVLB  7
0991C:  MOVWF  x50
0991E:  MOVLB  0
09920:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09924:  MOVLW  04
09926:  MOVLB  7
09928:  MOVWF  x42
0992A:  MOVLW  C1
0992C:  MOVWF  x41
0992E:  MOVLB  0
09930:  CALL   55A0
09934:  MOVF   01,W
09936:  ADDLW  C1
09938:  MOVLB  7
0993A:  MOVWF  x30
0993C:  MOVLW  04
0993E:  ADDWFC 02,W
09940:  MOVWF  x31
09942:  MOVLW  01
09944:  SUBWF  x0B,W
09946:  MULLW  26
09948:  MOVF   FF3,W
0994A:  CLRF   x33
0994C:  MOVWF  x32
0994E:  MOVLW  18
09950:  ADDWF  x32,W
09952:  MOVWF  01
09954:  MOVLW  00
09956:  ADDWFC x33,W
09958:  MOVWF  03
0995A:  MOVF   01,W
0995C:  ADDLW  17
0995E:  MOVWF  FE9
09960:  MOVLW  01
09962:  ADDWFC 03,W
09964:  MOVWF  FEA
09966:  MOVFF  FEF,743
0996A:  MOVFF  FEC,744
0996E:  MOVFF  FEC,745
09972:  MOVFF  FEC,746
09976:  MOVFF  731,565
0997A:  MOVFF  730,564
0997E:  MOVLW  89
09980:  MOVWF  FE9
09982:  MOVLW  02
09984:  MOVWF  x47
09986:  MOVLB  0
09988:  CALL   5776
0998C:  MOVLW  2C
0998E:  MOVLB  7
09990:  MOVWF  x50
09992:  MOVLB  0
09994:  CALL   55D8
....................    }
09998:  BRA    9B34
....................    else if (0 == strcmp(s_poles, arg2)) {
0999A:  MOVFF  722,742
0999E:  MOVFF  721,741
099A2:  MOVFF  70D,744
099A6:  MOVFF  70C,743
099AA:  CALL   5B14
099AE:  MOVF   01,F
099B0:  BNZ   9A5C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
099B2:  MOVLW  04
099B4:  MOVLB  7
099B6:  MOVWF  x42
099B8:  MOVLW  C1
099BA:  MOVWF  x41
099BC:  MOVLB  0
099BE:  CALL   55A0
099C2:  MOVFF  02,03
099C6:  MOVF   01,W
099C8:  ADDLW  C1
099CA:  MOVLB  7
099CC:  MOVWF  x30
099CE:  MOVLW  04
099D0:  ADDWFC 02,W
099D2:  MOVWF  x31
099D4:  MOVFF  FE8,565
099D8:  MOVFF  730,564
099DC:  MOVFF  70B,734
099E0:  MOVLW  18
099E2:  MOVWF  x35
099E4:  MOVLB  0
099E6:  CALL   6078
099EA:  MOVLW  2C
099EC:  MOVLB  7
099EE:  MOVWF  x50
099F0:  MOVLB  0
099F2:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
099F6:  MOVLW  04
099F8:  MOVLB  7
099FA:  MOVWF  x42
099FC:  MOVLW  C1
099FE:  MOVWF  x41
09A00:  MOVLB  0
09A02:  CALL   55A0
09A06:  MOVF   01,W
09A08:  ADDLW  C1
09A0A:  MOVLB  7
09A0C:  MOVWF  x30
09A0E:  MOVLW  04
09A10:  ADDWFC 02,W
09A12:  MOVWF  x31
09A14:  MOVLW  01
09A16:  SUBWF  x0B,W
09A18:  MULLW  26
09A1A:  MOVF   FF3,W
09A1C:  CLRF   x33
09A1E:  MOVWF  x32
09A20:  MOVLW  1C
09A22:  ADDWF  x32,W
09A24:  MOVWF  01
09A26:  MOVLW  00
09A28:  ADDWFC x33,W
09A2A:  MOVWF  03
09A2C:  MOVF   01,W
09A2E:  ADDLW  17
09A30:  MOVWF  FE9
09A32:  MOVLW  01
09A34:  ADDWFC 03,W
09A36:  MOVWF  FEA
09A38:  MOVFF  FEF,734
09A3C:  MOVFF  731,565
09A40:  MOVFF  730,564
09A44:  MOVLW  18
09A46:  MOVWF  x35
09A48:  MOVLB  0
09A4A:  CALL   6078
09A4E:  MOVLW  2C
09A50:  MOVLB  7
09A52:  MOVWF  x50
09A54:  MOVLB  0
09A56:  CALL   55D8
....................    }
09A5A:  BRA    9B34
....................    else if (0 == strcmp(s_real, arg2)) {
09A5C:  MOVFF  72A,742
09A60:  MOVFF  729,741
09A64:  MOVFF  70D,744
09A68:  MOVFF  70C,743
09A6C:  CALL   5B14
09A70:  MOVF   01,F
09A72:  BNZ   9B2E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A74:  MOVLW  04
09A76:  MOVLB  7
09A78:  MOVWF  x42
09A7A:  MOVLW  C1
09A7C:  MOVWF  x41
09A7E:  MOVLB  0
09A80:  CALL   55A0
09A84:  MOVFF  02,03
09A88:  MOVF   01,W
09A8A:  ADDLW  C1
09A8C:  MOVLB  7
09A8E:  MOVWF  x30
09A90:  MOVLW  04
09A92:  ADDWFC 02,W
09A94:  MOVWF  x31
09A96:  MOVFF  FE8,565
09A9A:  MOVFF  730,564
09A9E:  MOVFF  70B,734
09AA2:  MOVLW  18
09AA4:  MOVWF  x35
09AA6:  MOVLB  0
09AA8:  CALL   6078
09AAC:  MOVLW  2C
09AAE:  MOVLB  7
09AB0:  MOVWF  x50
09AB2:  MOVLB  0
09AB4:  CALL   55D8
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09AB8:  MOVLW  04
09ABA:  MOVLB  7
09ABC:  MOVWF  x42
09ABE:  MOVLW  C1
09AC0:  MOVWF  x41
09AC2:  MOVLB  0
09AC4:  CALL   55A0
09AC8:  MOVF   01,W
09ACA:  ADDLW  C1
09ACC:  MOVLB  7
09ACE:  MOVWF  x30
09AD0:  MOVLW  04
09AD2:  ADDWFC 02,W
09AD4:  MOVWF  x31
09AD6:  MOVLW  01
09AD8:  SUBWF  x0B,W
09ADA:  MULLW  26
09ADC:  MOVF   FF3,W
09ADE:  CLRF   x33
09AE0:  MOVWF  x32
09AE2:  MOVLW  1D
09AE4:  ADDWF  x32,W
09AE6:  MOVWF  01
09AE8:  MOVLW  00
09AEA:  ADDWFC x33,W
09AEC:  MOVWF  03
09AEE:  MOVF   01,W
09AF0:  ADDLW  17
09AF2:  MOVWF  FE9
09AF4:  MOVLW  01
09AF6:  ADDWFC 03,W
09AF8:  MOVWF  FEA
09AFA:  MOVFF  FEF,743
09AFE:  MOVFF  FEC,744
09B02:  MOVFF  FEC,745
09B06:  MOVFF  FEC,746
09B0A:  MOVFF  731,565
09B0E:  MOVFF  730,564
09B12:  MOVLW  89
09B14:  MOVWF  FE9
09B16:  MOVLW  02
09B18:  MOVWF  x47
09B1A:  MOVLB  0
09B1C:  CALL   5776
09B20:  MOVLW  2C
09B22:  MOVLB  7
09B24:  MOVWF  x50
09B26:  MOVLB  0
09B28:  CALL   55D8
....................    }
09B2C:  BRA    9B34
....................    else return INV_PARAM;
09B2E:  MOVLW  02
09B30:  MOVWF  01
09B32:  BRA    9B38
....................    
....................    return SUCCESS;
09B34:  MOVLW  00
09B36:  MOVWF  01
09B38:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09B3A:  MOVLB  7
09B3C:  CLRF   x42
09B3E:  MOVFF  690,741
09B42:  CLRF   x44
09B44:  MOVLW  B5
09B46:  MOVWF  x43
09B48:  MOVLB  0
09B4A:  CALL   08BE
09B4E:  MOVFF  02,70D
09B52:  MOVFF  01,70C
09B56:  MOVLW  06
09B58:  MOVLB  7
09B5A:  ADDWF  x0C,F
09B5C:  MOVLW  00
09B5E:  ADDWFC x0D,F
09B60:  MOVLW  32
09B62:  ADDWF  x0C,W
09B64:  MOVWF  01
09B66:  MOVLW  00
09B68:  ADDWFC x0D,W
09B6A:  MOVWF  03
09B6C:  MOVF   01,W
09B6E:  ADDLW  EB
09B70:  MOVWF  01
09B72:  MOVLW  01
09B74:  ADDWFC 03,F
09B76:  MOVFF  01,70C
09B7A:  MOVFF  03,70D
09B7E:  MOVFF  03,734
09B82:  MOVFF  01,733
09B86:  MOVLB  0
09B88:  CALL   5C34
09B8C:  MOVF   01,F
09B8E:  BNZ   9B98
09B90:  MOVLW  02
09B92:  MOVWF  01
09B94:  BRA    9C9A
09B96:  BRA    9BF6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B98:  MOVLB  7
09B9A:  CLRF   x42
09B9C:  MOVFF  690,741
09BA0:  CLRF   x44
09BA2:  MOVLW  B5
09BA4:  MOVWF  x43
09BA6:  MOVLB  0
09BA8:  CALL   08BE
09BAC:  MOVFF  02,70D
09BB0:  MOVFF  01,70C
09BB4:  MOVLW  06
09BB6:  MOVLB  7
09BB8:  ADDWF  x0C,F
09BBA:  MOVLW  00
09BBC:  ADDWFC x0D,F
09BBE:  MOVLW  32
09BC0:  ADDWF  x0C,W
09BC2:  MOVWF  01
09BC4:  MOVLW  00
09BC6:  ADDWFC x0D,W
09BC8:  MOVWF  03
09BCA:  MOVF   01,W
09BCC:  ADDLW  EB
09BCE:  MOVWF  01
09BD0:  MOVLW  01
09BD2:  ADDWFC 03,F
09BD4:  MOVFF  01,70C
09BD8:  MOVFF  03,70D
09BDC:  MOVFF  03,734
09BE0:  MOVFF  01,733
09BE4:  CLRF   x36
09BE6:  CLRF   x35
09BE8:  MOVLW  0A
09BEA:  MOVWF  x37
09BEC:  MOVLB  0
09BEE:  CALL   5D24
09BF2:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
09BF6:  MOVLW  04
09BF8:  MOVLB  7
09BFA:  MOVWF  x42
09BFC:  MOVLW  C1
09BFE:  MOVWF  x41
09C00:  MOVLB  0
09C02:  CALL   55A0
09C06:  MOVF   01,W
09C08:  ADDLW  C1
09C0A:  MOVLB  7
09C0C:  MOVWF  x0C
09C0E:  MOVLW  04
09C10:  ADDWFC 02,W
09C12:  MOVWF  x0D
09C14:  MOVLW  01
09C16:  SUBWF  x0B,W
09C18:  MULLW  07
09C1A:  MOVF   FF3,W
09C1C:  CLRF   x0F
09C1E:  MOVWF  x0E
09C20:  MOVLW  03
09C22:  ADDWF  x0E,W
09C24:  MOVWF  01
09C26:  MOVLW  00
09C28:  ADDWFC x0F,W
09C2A:  MOVWF  03
09C2C:  MOVF   01,W
09C2E:  ADDLW  64
09C30:  MOVWF  FE9
09C32:  MOVLW  01
09C34:  ADDWFC 03,W
09C36:  MOVWF  FEA
09C38:  MOVFF  FEF,70E
09C3C:  MOVFF  FEC,70F
09C40:  MOVFF  FEC,710
09C44:  MOVFF  FEC,711
09C48:  MOVFF  70D,565
09C4C:  MOVFF  70C,564
09C50:  MOVFF  70B,734
09C54:  MOVLW  18
09C56:  MOVWF  x35
09C58:  MOVLB  0
09C5A:  CALL   6078
09C5E:  MOVLW  2C
09C60:  MOVLB  7
09C62:  MOVWF  x50
09C64:  MOVLB  0
09C66:  CALL   55D8
09C6A:  MOVLW  89
09C6C:  MOVWF  FE9
09C6E:  MOVFF  711,746
09C72:  MOVFF  710,745
09C76:  MOVFF  70F,744
09C7A:  MOVFF  70E,743
09C7E:  MOVLW  02
09C80:  MOVLB  7
09C82:  MOVWF  x47
09C84:  MOVLB  0
09C86:  CALL   5776
09C8A:  MOVLW  2C
09C8C:  MOVLB  7
09C8E:  MOVWF  x50
09C90:  MOVLB  0
09C92:  CALL   55D8
....................    
....................    return SUCCESS;
09C96:  MOVLW  00
09C98:  MOVWF  01
09C9A:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C9C:  MOVLB  7
09C9E:  CLRF   x42
09CA0:  MOVFF  690,741
09CA4:  CLRF   x44
09CA6:  MOVLW  B5
09CA8:  MOVWF  x43
09CAA:  MOVLB  0
09CAC:  CALL   08BE
09CB0:  MOVFF  02,711
09CB4:  MOVFF  01,710
09CB8:  MOVLW  06
09CBA:  MOVLB  7
09CBC:  ADDWF  x10,F
09CBE:  MOVLW  00
09CC0:  ADDWFC x11,F
09CC2:  MOVLW  32
09CC4:  ADDWF  x10,W
09CC6:  MOVWF  01
09CC8:  MOVLW  00
09CCA:  ADDWFC x11,W
09CCC:  MOVWF  03
09CCE:  MOVF   01,W
09CD0:  ADDLW  EB
09CD2:  MOVWF  01
09CD4:  MOVLW  01
09CD6:  ADDWFC 03,F
09CD8:  MOVFF  01,710
09CDC:  MOVFF  03,711
09CE0:  MOVFF  03,734
09CE4:  MOVFF  01,733
09CE8:  MOVLB  0
09CEA:  CALL   5C34
09CEE:  MOVF   01,F
09CF0:  BNZ   9CFA
09CF2:  MOVLW  02
09CF4:  MOVWF  01
09CF6:  BRA    9F0C
09CF8:  BRA    9D58
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CFA:  MOVLB  7
09CFC:  CLRF   x42
09CFE:  MOVFF  690,741
09D02:  CLRF   x44
09D04:  MOVLW  B5
09D06:  MOVWF  x43
09D08:  MOVLB  0
09D0A:  CALL   08BE
09D0E:  MOVFF  02,711
09D12:  MOVFF  01,710
09D16:  MOVLW  06
09D18:  MOVLB  7
09D1A:  ADDWF  x10,F
09D1C:  MOVLW  00
09D1E:  ADDWFC x11,F
09D20:  MOVLW  32
09D22:  ADDWF  x10,W
09D24:  MOVWF  01
09D26:  MOVLW  00
09D28:  ADDWFC x11,W
09D2A:  MOVWF  03
09D2C:  MOVF   01,W
09D2E:  ADDLW  EB
09D30:  MOVWF  01
09D32:  MOVLW  01
09D34:  ADDWFC 03,F
09D36:  MOVFF  01,710
09D3A:  MOVFF  03,711
09D3E:  MOVFF  03,734
09D42:  MOVFF  01,733
09D46:  CLRF   x36
09D48:  CLRF   x35
09D4A:  MOVLW  0A
09D4C:  MOVWF  x37
09D4E:  MOVLB  0
09D50:  CALL   5D24
09D54:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09D58:  MOVLB  7
09D5A:  CLRF   x42
09D5C:  MOVFF  690,741
09D60:  CLRF   x44
09D62:  MOVLW  B5
09D64:  MOVWF  x43
09D66:  MOVLB  0
09D68:  CALL   08BE
09D6C:  MOVFF  02,711
09D70:  MOVFF  01,710
09D74:  MOVLW  06
09D76:  MOVLB  7
09D78:  ADDWF  x10,F
09D7A:  MOVLW  00
09D7C:  ADDWFC x11,F
09D7E:  MOVLW  4B
09D80:  ADDWF  x10,W
09D82:  MOVWF  01
09D84:  MOVLW  00
09D86:  ADDWFC x11,W
09D88:  MOVWF  03
09D8A:  MOVF   01,W
09D8C:  ADDLW  EB
09D8E:  MOVWF  01
09D90:  MOVLW  01
09D92:  ADDWFC 03,F
09D94:  MOVFF  01,710
09D98:  MOVFF  03,711
09D9C:  MOVFF  03,715
09DA0:  MOVFF  01,714
09DA4:  MOVLB  0
09DA6:  CALL   6D48
09DAA:  MOVF   01,F
09DAC:  BNZ   9DB6
09DAE:  MOVLW  02
09DB0:  MOVWF  01
09DB2:  BRA    9F0C
09DB4:  BRA    9E1C
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09DB6:  MOVLB  7
09DB8:  CLRF   x42
09DBA:  MOVFF  690,741
09DBE:  CLRF   x44
09DC0:  MOVLW  B5
09DC2:  MOVWF  x43
09DC4:  MOVLB  0
09DC6:  CALL   08BE
09DCA:  MOVFF  02,711
09DCE:  MOVFF  01,710
09DD2:  MOVLW  06
09DD4:  MOVLB  7
09DD6:  ADDWF  x10,F
09DD8:  MOVLW  00
09DDA:  ADDWFC x11,F
09DDC:  MOVLW  4B
09DDE:  ADDWF  x10,W
09DE0:  MOVWF  01
09DE2:  MOVLW  00
09DE4:  ADDWFC x11,W
09DE6:  MOVWF  03
09DE8:  MOVF   01,W
09DEA:  ADDLW  EB
09DEC:  MOVWF  01
09DEE:  MOVLW  01
09DF0:  ADDWFC 03,F
09DF2:  MOVFF  01,710
09DF6:  MOVFF  03,711
09DFA:  MOVFF  03,715
09DFE:  MOVFF  01,714
09E02:  CLRF   x17
09E04:  CLRF   x16
09E06:  MOVLB  0
09E08:  CALL   6E0A
09E0C:  MOVFF  03,70F
09E10:  MOVFF  02,70E
09E14:  MOVFF  01,70D
09E18:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09E1C:  MOVLB  7
09E1E:  CLRF   x49
09E20:  CLRF   x48
09E22:  MOVLW  7C
09E24:  MOVWF  x47
09E26:  MOVLW  84
09E28:  MOVWF  x46
09E2A:  MOVFF  70F,74D
09E2E:  MOVFF  70E,74C
09E32:  MOVFF  70D,74B
09E36:  MOVFF  70C,74A
09E3A:  MOVLB  0
09E3C:  CALL   1D34
09E40:  BNC   9E76
09E42:  MOVLW  01
09E44:  MOVLB  7
09E46:  SUBWF  x0B,W
09E48:  MULLW  07
09E4A:  MOVF   FF3,W
09E4C:  CLRF   x11
09E4E:  MOVWF  x10
09E50:  MOVLW  03
09E52:  ADDWF  x10,W
09E54:  MOVWF  01
09E56:  MOVLW  00
09E58:  ADDWFC x11,W
09E5A:  MOVWF  03
09E5C:  MOVF   01,W
09E5E:  ADDLW  64
09E60:  MOVWF  FE9
09E62:  MOVLW  01
09E64:  ADDWFC 03,W
09E66:  MOVWF  FEA
09E68:  MOVLW  84
09E6A:  MOVWF  FEF
09E6C:  MOVLW  7C
09E6E:  MOVWF  FEC
09E70:  CLRF   FEC
09E72:  CLRF   FEC
09E74:  BRA    9F06
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09E76:  MOVFF  70F,749
09E7A:  MOVFF  70E,748
09E7E:  MOVFF  70D,747
09E82:  MOVFF  70C,746
09E86:  MOVLB  7
09E88:  CLRF   x4D
09E8A:  CLRF   x4C
09E8C:  MOVLW  C0
09E8E:  MOVWF  x4B
09E90:  MOVLW  82
09E92:  MOVWF  x4A
09E94:  MOVLB  0
09E96:  CALL   1D34
09E9A:  BNC   9ED0
09E9C:  MOVLW  01
09E9E:  MOVLB  7
09EA0:  SUBWF  x0B,W
09EA2:  MULLW  07
09EA4:  MOVF   FF3,W
09EA6:  CLRF   x11
09EA8:  MOVWF  x10
09EAA:  MOVLW  03
09EAC:  ADDWF  x10,W
09EAE:  MOVWF  01
09EB0:  MOVLW  00
09EB2:  ADDWFC x11,W
09EB4:  MOVWF  03
09EB6:  MOVF   01,W
09EB8:  ADDLW  64
09EBA:  MOVWF  FE9
09EBC:  MOVLW  01
09EBE:  ADDWFC 03,W
09EC0:  MOVWF  FEA
09EC2:  MOVLW  82
09EC4:  MOVWF  FEF
09EC6:  MOVLW  C0
09EC8:  MOVWF  FEC
09ECA:  CLRF   FEC
09ECC:  CLRF   FEC
09ECE:  BRA    9F06
....................    else dacVals[arg1-1].opPcnt = arg2;
09ED0:  MOVLW  01
09ED2:  MOVLB  7
09ED4:  SUBWF  x0B,W
09ED6:  MULLW  07
09ED8:  MOVF   FF3,W
09EDA:  CLRF   x11
09EDC:  MOVWF  x10
09EDE:  MOVLW  03
09EE0:  ADDWF  x10,W
09EE2:  MOVWF  01
09EE4:  MOVLW  00
09EE6:  ADDWFC x11,W
09EE8:  MOVWF  03
09EEA:  MOVF   01,W
09EEC:  ADDLW  64
09EEE:  MOVWF  FE9
09EF0:  MOVLW  01
09EF2:  ADDWFC 03,W
09EF4:  MOVWF  FEA
09EF6:  MOVFF  70C,FEF
09EFA:  MOVFF  70D,FEC
09EFE:  MOVFF  70E,FEC
09F02:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
09F06:  MOVLW  00
09F08:  MOVWF  01
09F0A:  MOVLB  0
09F0C:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09F0E:  MOVLB  1
09F10:  BSF    x63.0
....................    return SUCCESS;
09F12:  MOVLW  00
09F14:  MOVWF  01
09F16:  MOVLB  0
09F18:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09F1A:  MOVLB  1
09F1C:  BCF    x63.0
....................    return SUCCESS;
09F1E:  MOVLW  00
09F20:  MOVWF  01
09F22:  MOVLB  0
09F24:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09F26:  MOVLB  7
09F28:  CLRF   x42
09F2A:  MOVFF  690,741
09F2E:  CLRF   x44
09F30:  MOVLW  B5
09F32:  MOVWF  x43
09F34:  MOVLB  0
09F36:  CALL   08BE
09F3A:  MOVFF  02,70D
09F3E:  MOVFF  01,70C
09F42:  MOVLW  06
09F44:  MOVLB  7
09F46:  ADDWF  x0C,F
09F48:  MOVLW  00
09F4A:  ADDWFC x0D,F
09F4C:  MOVLW  32
09F4E:  ADDWF  x0C,W
09F50:  MOVWF  01
09F52:  MOVLW  00
09F54:  ADDWFC x0D,W
09F56:  MOVWF  03
09F58:  MOVF   01,W
09F5A:  ADDLW  EB
09F5C:  MOVWF  01
09F5E:  MOVLW  01
09F60:  ADDWFC 03,F
09F62:  MOVFF  01,70C
09F66:  MOVFF  03,70D
09F6A:  MOVFF  03,734
09F6E:  MOVFF  01,733
09F72:  MOVLB  0
09F74:  CALL   5C34
09F78:  MOVF   01,F
09F7A:  BNZ   9F84
09F7C:  MOVLW  02
09F7E:  MOVWF  01
09F80:  BRA    A010
09F82:  BRA    9FE2
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09F84:  MOVLB  7
09F86:  CLRF   x42
09F88:  MOVFF  690,741
09F8C:  CLRF   x44
09F8E:  MOVLW  B5
09F90:  MOVWF  x43
09F92:  MOVLB  0
09F94:  CALL   08BE
09F98:  MOVFF  02,70D
09F9C:  MOVFF  01,70C
09FA0:  MOVLW  06
09FA2:  MOVLB  7
09FA4:  ADDWF  x0C,F
09FA6:  MOVLW  00
09FA8:  ADDWFC x0D,F
09FAA:  MOVLW  32
09FAC:  ADDWF  x0C,W
09FAE:  MOVWF  01
09FB0:  MOVLW  00
09FB2:  ADDWFC x0D,W
09FB4:  MOVWF  03
09FB6:  MOVF   01,W
09FB8:  ADDLW  EB
09FBA:  MOVWF  01
09FBC:  MOVLW  01
09FBE:  ADDWFC 03,F
09FC0:  MOVFF  01,70C
09FC4:  MOVFF  03,70D
09FC8:  MOVFF  03,734
09FCC:  MOVFF  01,733
09FD0:  CLRF   x36
09FD2:  CLRF   x35
09FD4:  MOVLW  0A
09FD6:  MOVWF  x37
09FD8:  MOVLB  0
09FDA:  CALL   5D24
09FDE:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09FE2:  MOVLW  01
09FE4:  MOVLB  7
09FE6:  SUBWF  x0B,W
09FE8:  MULLW  26
09FEA:  MOVF   FF3,W
09FEC:  CLRF   x0D
09FEE:  MOVWF  x0C
09FF0:  MOVLW  25
09FF2:  ADDWF  x0C,W
09FF4:  MOVWF  01
09FF6:  MOVLW  00
09FF8:  ADDWFC x0D,W
09FFA:  MOVWF  03
09FFC:  MOVF   01,W
09FFE:  ADDLW  17
0A000:  MOVWF  FE9
0A002:  MOVLW  01
0A004:  ADDWFC 03,W
0A006:  MOVWF  FEA
0A008:  BSF    FEF.0
....................     
....................     return SUCCESS;
0A00A:  MOVLW  00
0A00C:  MOVWF  01
0A00E:  MOVLB  0
0A010:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A012:  MOVLW  01
0A014:  MOVWF  01
0A016:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06D48:  MOVLB  7
06D4A:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06D4C:  CLRF   x17
06D4E:  MOVFF  715,742
06D52:  MOVFF  714,741
06D56:  MOVLB  0
06D58:  CALL   55A0
06D5C:  MOVFF  02,03
06D60:  MOVF   01,W
06D62:  MOVF   03,F
06D64:  BNZ   6D70
06D66:  MOVF   01,W
06D68:  MOVLB  7
06D6A:  SUBWF  x17,W
06D6C:  BC    6E02
06D6E:  MOVLB  0
....................       if (!isdigit(arg[i])){
06D70:  MOVLB  7
06D72:  MOVF   x17,W
06D74:  ADDWF  x14,W
06D76:  MOVWF  FE9
06D78:  MOVLW  00
06D7A:  ADDWFC x15,W
06D7C:  MOVWF  FEA
06D7E:  MOVFF  FEF,718
06D82:  MOVF   x18,W
06D84:  SUBLW  2F
06D86:  BC    6D8E
06D88:  MOVF   x18,W
06D8A:  SUBLW  39
06D8C:  BC    6DFA
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06D8E:  MOVF   x17,W
06D90:  ADDWF  x14,W
06D92:  MOVWF  FE9
06D94:  MOVLW  00
06D96:  ADDWFC x15,W
06D98:  MOVWF  FEA
06D9A:  MOVF   FEF,W
06D9C:  SUBLW  2D
06D9E:  BZ    6DCA
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06DA0:  MOVF   x17,W
06DA2:  ADDWF  x14,W
06DA4:  MOVWF  FE9
06DA6:  MOVLW  00
06DA8:  ADDWFC x15,W
06DAA:  MOVWF  FEA
06DAC:  MOVF   FEF,W
06DAE:  SUBLW  2E
06DB0:  BZ    6DBA
06DB2:  MOVLW  00
06DB4:  MOVWF  01
06DB6:  BRA    6E06
06DB8:  BRA    6DC8
....................             else if  (decimal) return FALSE;
06DBA:  BTFSS  x16.0
06DBC:  BRA    6DC6
06DBE:  MOVLW  00
06DC0:  MOVWF  01
06DC2:  BRA    6E06
06DC4:  BRA    6DC8
....................             else decimal = TRUE;
06DC6:  BSF    x16.0
....................          }
06DC8:  BRA    6DFA
....................          else if (0 != i) return FALSE;
06DCA:  MOVF   x17,F
06DCC:  BZ    6DD6
06DCE:  MOVLW  00
06DD0:  MOVWF  01
06DD2:  BRA    6E06
06DD4:  BRA    6DFA
....................          else if (1 == strlen(arg)) return FALSE;
06DD6:  MOVFF  715,742
06DDA:  MOVFF  714,741
06DDE:  MOVLB  0
06DE0:  CALL   55A0
06DE4:  MOVFF  02,03
06DE8:  MOVF   01,W
06DEA:  SUBLW  01
06DEC:  BNZ   6DFC
06DEE:  MOVF   03,F
06DF0:  BNZ   6DFC
06DF2:  MOVLW  00
06DF4:  MOVWF  01
06DF6:  MOVLB  7
06DF8:  BRA    6E06
06DFA:  MOVLB  0
....................       }
06DFC:  MOVLB  7
06DFE:  INCF   x17,F
06E00:  BRA    6D4E
....................    }
....................    return TRUE;
06E02:  MOVLW  01
06E04:  MOVWF  01
06E06:  MOVLB  0
06E08:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05C34:  MOVFF  734,742
05C38:  MOVFF  733,741
05C3C:  RCALL  55A0
05C3E:  MOVFF  02,03
05C42:  MOVF   01,W
05C44:  SUBLW  01
05C46:  BNZ   5C4C
05C48:  MOVF   03,F
05C4A:  BZ    5C54
05C4C:  MOVLW  00
05C4E:  MOVWF  01
05C50:  BRA    5C82
05C52:  BRA    5C7A
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05C54:  MOVLB  7
05C56:  MOVFF  733,FE9
05C5A:  MOVFF  734,FEA
05C5E:  MOVF   FEF,W
05C60:  SUBLW  31
05C62:  BZ    5C7C
05C64:  MOVFF  733,FE9
05C68:  MOVFF  734,FEA
05C6C:  MOVF   FEF,W
05C6E:  SUBLW  32
05C70:  BZ    5C7C
05C72:  MOVLW  00
05C74:  MOVWF  01
05C76:  MOVLB  0
05C78:  BRA    5C82
05C7A:  MOVLB  7
....................     return TRUE;
05C7C:  MOVLW  01
05C7E:  MOVWF  01
05C80:  MOVLB  0
05C82:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05ADA:  MOVLB  7
05ADC:  MOVF   x0A,W
05ADE:  SUBLW  2F
05AE0:  BC    5AF2
05AE2:  MOVF   x0A,W
05AE4:  SUBLW  39
05AE6:  BNC   5AF2
05AE8:  MOVLW  30
05AEA:  SUBWF  x0A,W
05AEC:  MOVWF  01
05AEE:  BRA    5B0E
05AF0:  BRA    5B0E
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05AF2:  MOVF   x0A,W
05AF4:  SUBLW  40
05AF6:  BC    5B0A
05AF8:  MOVF   x0A,W
05AFA:  SUBLW  46
05AFC:  BNC   5B0A
05AFE:  MOVLW  41
05B00:  SUBWF  x0A,W
05B02:  ADDLW  0A
05B04:  MOVWF  01
05B06:  BRA    5B0E
05B08:  BRA    5B0E
....................    else return 0xFF;
05B0A:  MOVLW  FF
05B0C:  MOVWF  01
05B0E:  MOVLB  0
05B10:  GOTO   A0BC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A018:  MOVLB  7
0A01A:  CLRF   x42
0A01C:  MOVFF  701,741
0A020:  CLRF   x44
0A022:  MOVLW  B5
0A024:  MOVWF  x43
0A026:  MOVLB  0
0A028:  CALL   08BE
0A02C:  MOVFF  02,70A
0A030:  MOVFF  01,709
0A034:  MOVLW  06
0A036:  MOVLB  7
0A038:  ADDWF  x09,F
0A03A:  MOVLW  00
0A03C:  ADDWFC x0A,F
0A03E:  MOVLW  EB
0A040:  ADDWF  x09,W
0A042:  MOVWF  01
0A044:  MOVLW  01
0A046:  ADDWFC x0A,W
0A048:  MOVWF  03
0A04A:  MOVFF  01,702
0A04E:  MOVWF  x03
0A050:  CLRF   x42
0A052:  MOVFF  701,741
0A056:  CLRF   x44
0A058:  MOVLW  B5
0A05A:  MOVWF  x43
0A05C:  MOVLB  0
0A05E:  CALL   08BE
0A062:  MOVFF  02,70C
0A066:  MOVFF  01,70B
0A06A:  MOVLW  06
0A06C:  MOVLB  7
0A06E:  ADDWF  x0B,F
0A070:  MOVLW  00
0A072:  ADDWFC x0C,F
0A074:  MOVLW  19
0A076:  ADDWF  x0B,W
0A078:  MOVWF  01
0A07A:  MOVLW  00
0A07C:  ADDWFC x0C,W
0A07E:  MOVWF  03
0A080:  MOVF   01,W
0A082:  ADDLW  EB
0A084:  MOVWF  01
0A086:  MOVLW  01
0A088:  ADDWFC 03,F
0A08A:  MOVFF  01,704
0A08E:  MOVFF  03,705
0A092:  CLRF   x06
0A094:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A096:  MOVFF  702,FE9
0A09A:  MOVFF  703,FEA
0A09E:  MOVF   FEF,W
0A0A0:  SUBLW  44
0A0A2:  BTFSS  FD8.2
0A0A4:  BRA    A194
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A0A6:  MOVLW  01
0A0A8:  ADDWF  x02,W
0A0AA:  MOVWF  FE9
0A0AC:  MOVLW  00
0A0AE:  ADDWFC x03,W
0A0B0:  MOVWF  FEA
0A0B2:  MOVFF  FEF,70A
0A0B6:  MOVLB  0
0A0B8:  GOTO   5ADA
0A0BC:  MOVFF  01,709
0A0C0:  MOVLB  7
0A0C2:  MOVF   x06,W
0A0C4:  ANDLW  0F
0A0C6:  SUBWF  01,W
0A0C8:  BNZ   A18C
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A0CA:  MOVF   x07,W
0A0CC:  MULLW  04
0A0CE:  MOVF   FF3,W
0A0D0:  CLRF   x0A
0A0D2:  MOVWF  x09
0A0D4:  MOVLW  6A
0A0D6:  ADDWF  x09,W
0A0D8:  MOVWF  FE9
0A0DA:  MOVLW  05
0A0DC:  ADDWFC x0A,W
0A0DE:  MOVWF  FEA
0A0E0:  MOVFF  FEC,742
0A0E4:  MOVF   FED,F
0A0E6:  MOVFF  FEF,741
0A0EA:  MOVLB  0
0A0EC:  CALL   55A0
0A0F0:  MOVFF  02,03
0A0F4:  MOVF   01,W
0A0F6:  BNZ   A0FC
0A0F8:  MOVF   03,F
0A0FA:  BZ    A182
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A0FC:  MOVLB  7
0A0FE:  MOVF   x07,W
0A100:  MULLW  04
0A102:  MOVF   FF3,W
0A104:  CLRF   x0A
0A106:  MOVWF  x09
0A108:  MOVLW  6A
0A10A:  ADDWF  x09,W
0A10C:  MOVWF  FE9
0A10E:  MOVLW  05
0A110:  ADDWFC x0A,W
0A112:  MOVWF  FEA
0A114:  MOVFF  FEC,744
0A118:  MOVF   FED,F
0A11A:  MOVFF  FEF,743
0A11E:  MOVFF  705,742
0A122:  MOVFF  704,741
0A126:  MOVLB  0
0A128:  CALL   5B14
0A12C:  MOVF   01,F
0A12E:  BNZ   A17A
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A130:  MOVLB  7
0A132:  MOVF   x07,W
0A134:  MULLW  04
0A136:  MOVF   FF3,W
0A138:  CLRF   x0A
0A13A:  MOVWF  x09
0A13C:  MOVLW  02
0A13E:  ADDWF  x09,W
0A140:  MOVWF  01
0A142:  MOVLW  00
0A144:  ADDWFC x0A,W
0A146:  MOVWF  03
0A148:  MOVF   01,W
0A14A:  ADDLW  6A
0A14C:  MOVWF  01
0A14E:  MOVLW  05
0A150:  ADDWFC 03,F
0A152:  MOVFF  01,709
0A156:  MOVFF  03,70A
0A15A:  MOVFF  03,FEA
0A15E:  MOVFF  01,FE9
0A162:  MOVFF  701,690
0A166:  MOVLB  0
0A168:  CALL   00BC
0A16C:  MOVFF  01,708
....................                return return_code;
0A170:  MOVLB  7
0A172:  MOVFF  708,01
0A176:  BRA    A198
0A178:  MOVLB  0
....................             }
....................             i++;
0A17A:  MOVLB  7
0A17C:  INCF   x07,F
0A17E:  BRA    A0CA
0A180:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A182:  MOVLW  01
0A184:  MOVWF  01
0A186:  MOVLB  7
0A188:  BRA    A198
....................       } else return 254; // NOT THIS ADDRESS
0A18A:  BRA    A192
0A18C:  MOVLW  FE
0A18E:  MOVWF  01
0A190:  BRA    A198
....................    } else return 255; // NOT THIS DEVICE TYPE
0A192:  BRA    A198
0A194:  MOVLW  FF
0A196:  MOVWF  01
0A198:  MOVLB  0
0A19A:  GOTO   A286 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A1EA:  GOTO   5A5C
0A1EE:  MOVF   01,F
0A1F0:  BTFSC  FD8.2
0A1F2:  BRA    A310
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A1F4:  MOVLW  04
0A1F6:  MOVLB  7
0A1F8:  MOVWF  x42
0A1FA:  MOVLW  C1
0A1FC:  MOVWF  x41
0A1FE:  MOVLB  0
0A200:  CALL   55A0
0A204:  MOVFF  02,03
0A208:  MOVF   01,W
0A20A:  ADDLW  C1
0A20C:  MOVLB  7
0A20E:  MOVWF  x00
0A210:  MOVLW  04
0A212:  ADDWFC 02,W
0A214:  MOVWF  x01
0A216:  CLRF   x42
0A218:  MOVFF  4BF,741
0A21C:  CLRF   x44
0A21E:  MOVLW  B5
0A220:  MOVWF  x43
0A222:  MOVLB  0
0A224:  CALL   08BE
0A228:  MOVFF  02,703
0A22C:  MOVFF  01,702
0A230:  MOVLW  06
0A232:  MOVLB  7
0A234:  ADDWF  x02,F
0A236:  MOVLW  00
0A238:  ADDWFC x03,F
0A23A:  MOVLW  EB
0A23C:  ADDWF  x02,W
0A23E:  MOVWF  01
0A240:  MOVLW  01
0A242:  ADDWFC x03,W
0A244:  MOVWF  03
0A246:  MOVFF  01,704
0A24A:  MOVWF  x05
0A24C:  MOVFF  701,565
0A250:  MOVFF  700,564
0A254:  MOVLW  24
0A256:  MOVWF  x50
0A258:  MOVLB  0
0A25A:  CALL   55D8
0A25E:  MOVFF  565,FEA
0A262:  MOVFF  564,FE9
0A266:  CLRF   FEF
0A268:  MOVFF  705,FEA
0A26C:  MOVFF  704,FE9
0A270:  CALL   5AB6
0A274:  MOVLW  2C
0A276:  MOVLB  7
0A278:  MOVWF  x50
0A27A:  MOVLB  0
0A27C:  CALL   55D8
....................       
....................       return_code = command_parser(SRI);
0A280:  MOVFF  4BF,701
0A284:  BRA    A018
0A286:  MOVFF  01,6FB
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A28A:  MOVLW  04
0A28C:  MOVLB  7
0A28E:  MOVWF  x42
0A290:  MOVLW  C1
0A292:  MOVWF  x41
0A294:  MOVLB  0
0A296:  CALL   55A0
0A29A:  MOVF   01,W
0A29C:  ADDLW  C1
0A29E:  MOVLB  7
0A2A0:  MOVWF  x00
0A2A2:  MOVLW  04
0A2A4:  ADDWFC 02,W
0A2A6:  MOVWF  x01
0A2A8:  MOVLB  6
0A2AA:  MOVF   xFB,W
0A2AC:  MULLW  03
0A2AE:  MOVF   FF3,W
0A2B0:  MOVLB  7
0A2B2:  CLRF   x03
0A2B4:  MOVWF  x02
0A2B6:  MOVLW  01
0A2B8:  ADDWF  x02,W
0A2BA:  MOVWF  01
0A2BC:  MOVLW  00
0A2BE:  ADDWFC x03,W
0A2C0:  MOVWF  03
0A2C2:  MOVF   01,W
0A2C4:  ADDLW  5C
0A2C6:  MOVWF  FE9
0A2C8:  MOVLW  06
0A2CA:  ADDWFC 03,W
0A2CC:  MOVWF  FEA
0A2CE:  MOVFF  FEC,703
0A2D2:  MOVF   FED,F
0A2D4:  MOVFF  FEF,702
0A2D8:  MOVFF  701,565
0A2DC:  MOVFF  700,564
0A2E0:  MOVFF  565,FEA
0A2E4:  MOVFF  564,FE9
0A2E8:  CLRF   FEF
0A2EA:  MOVFF  703,FEA
0A2EE:  MOVFF  702,FE9
0A2F2:  MOVLB  0
0A2F4:  CALL   5AB6
....................       serial_out(retData);
0A2F8:  MOVLW  04
0A2FA:  MOVLB  7
0A2FC:  MOVWF  x02
0A2FE:  MOVLW  C1
0A300:  MOVWF  x01
0A302:  MOVLB  0
0A304:  BRA    A19E
....................       resetSERcmd(SRI);
0A306:  MOVFF  4BF,701
0A30A:  CALL   0BA2
0A30E:  BRA    A1EA
....................    }
0A310:  GOTO   AB06 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A314:  CLRF   FF8
0A316:  BCF    FF2.5
0A318:  BSF    07.7
0A31A:  MOVLB  E
0A31C:  MOVLW  55
0A31E:  MOVWF  x9B
0A320:  MOVLW  AA
0A322:  MOVWF  x9B
0A324:  BCF    x9B.0
0A326:  MOVLW  17
0A328:  MOVWF  xB0
0A32A:  MOVLW  13
0A32C:  MOVWF  xB2
0A32E:  MOVLW  09
0A330:  MOVWF  x8A
0A332:  MOVLW  0A
0A334:  MOVWF  x8B
0A336:  MOVLW  11
0A338:  MOVWF  xEB
0A33A:  MOVLW  12
0A33C:  MOVWF  xED
0A33E:  MOVLW  10
0A340:  MOVWF  xF4
0A342:  MOVLW  0F
0A344:  MOVWF  xF5
0A346:  MOVLW  09
0A348:  MOVWF  xF8
0A34A:  MOVLW  55
0A34C:  MOVWF  x9B
0A34E:  MOVLW  AA
0A350:  MOVWF  x9B
0A352:  BSF    x9B.0
0A354:  CLRF   xD8
0A356:  CLRF   xD5
0A358:  CLRF   xD7
0A35A:  MOVLW  08
0A35C:  MOVWF  xD9
0A35E:  MOVLW  60
0A360:  MOVWF  xD3
0A362:  BCF    F88.7
0A364:  BSF    F83.7
0A366:  MOVLW  12
0A368:  MOVWF  03
0A36A:  MOVLW  FA
0A36C:  MOVLB  7
0A36E:  MOVWF  x01
0A370:  MOVLB  0
0A372:  CALL   03D2
0A376:  DECFSZ 03,F
0A378:  BRA    A37C
0A37A:  BRA    A380
0A37C:  MOVLB  E
0A37E:  BRA    A36A
0A380:  MOVLW  AA
0A382:  MOVWF  xFA
0A384:  MOVLB  1
0A386:  BCF    x63.0
0A388:  CLRF   x75
0A38A:  CLRF   x74
0A38C:  CLRF   x73
0A38E:  CLRF   x72
0A390:  CLRF   x79
0A392:  CLRF   x78
0A394:  CLRF   x77
0A396:  CLRF   x76
0A398:  CLRF   x7D
0A39A:  CLRF   x7C
0A39C:  CLRF   x7B
0A39E:  CLRF   x7A
0A3A0:  CLRF   x7F
0A3A2:  CLRF   x7E
0A3A4:  MOVLB  E
0A3A6:  BCF    x91.5
0A3A8:  MOVLW  00
0A3AA:  MOVWF  x90
0A3AC:  MOVLW  03
0A3AE:  MOVWF  x8E
0A3B0:  MOVLW  2A
0A3B2:  MOVWF  x91
0A3B4:  MOVLW  04
0A3B6:  MOVWF  F88
0A3B8:  MOVWF  F88
0A3BA:  MOVWF  F88
0A3BC:  MOVLB  1
0A3BE:  CLRF   xD0
0A3C0:  CLRF   xD1
0A3C2:  CLRF   xD2
0A3C4:  CLRF   xD3
0A3C6:  BCF    F95.5
0A3C8:  MOVLW  40
0A3CA:  MOVWF  F94
0A3CC:  MOVLW  9F
0A3CE:  MOVWF  F92
0A3D0:  MOVLW  3A
0A3D2:  MOVWF  F95
0A3D4:  MOVLW  93
0A3D6:  MOVWF  F89
0A3D8:  MOVWF  F89
0A3DA:  MOVLB  4
0A3DC:  CLRF   xBF
0A3DE:  CLRF   xC0
0A3E0:  MOVLB  5
0A3E2:  CLRF   x61
0A3E4:  CLRF   x62
0A3E6:  MOVLB  1
0A3E8:  BCF    x63.1
0A3EA:  MOVLB  5
0A3EC:  CLRF   x63
0A3EE:  BSF    F9E.3
0A3F0:  MOVLW  7C
0A3F2:  MOVWF  F9A
0A3F4:  MOVLW  00
0A3F6:  MOVWF  F9B
0A3F8:  MOVLW  A6
0A3FA:  MOVWF  F9D
0A3FC:  MOVLW  90
0A3FE:  MOVWF  F9C
0A400:  CLRF   x65
0A402:  CLRF   x64
0A404:  CLRF   x69
0A406:  CLRF   x68
0A408:  CLRF   x67
0A40A:  CLRF   x66
0A40C:  MOVLB  F
0A40E:  CLRF   x0C
0A410:  CLRF   x14
0A412:  CLRF   x1C
0A414:  CLRF   x21
0A416:  CLRF   x29
0A418:  CLRF   x35
0A41A:  CLRF   x36
0A41C:  CLRF   x37
0A41E:  CLRF   x34
0A420:  CLRF   x31
0A422:  CLRF   x32
0A424:  CLRF   x33
0A426:  CLRF   x30
0A428:  MOVLW  5B
0A42A:  MOVLB  5
0A42C:  MOVWF  x6D
0A42E:  MOVLW  AC
0A430:  MOVWF  x6C
0A432:  MOVLW  5B
0A434:  MOVWF  x71
0A436:  MOVLW  F0
0A438:  MOVWF  x70
0A43A:  MOVLW  61
0A43C:  MOVWF  x75
0A43E:  MOVLW  40
0A440:  MOVWF  x74
0A442:  MOVLW  63
0A444:  MOVWF  x79
0A446:  MOVLW  2E
0A448:  MOVWF  x78
0A44A:  MOVLW  64
0A44C:  MOVWF  x7D
0A44E:  MOVLW  DC
0A450:  MOVWF  x7C
0A452:  MOVLW  66
0A454:  MOVWF  x81
0A456:  MOVLW  6C
0A458:  MOVWF  x80
0A45A:  MOVLW  68
0A45C:  MOVWF  x85
0A45E:  MOVLW  86
0A460:  MOVWF  x84
0A462:  MOVLW  70
0A464:  MOVWF  x89
0A466:  MOVLW  64
0A468:  MOVWF  x88
0A46A:  MOVLW  73
0A46C:  MOVWF  x8D
0A46E:  MOVLW  44
0A470:  MOVWF  x8C
0A472:  MOVLW  74
0A474:  MOVWF  x91
0A476:  MOVLW  A6
0A478:  MOVWF  x90
0A47A:  MOVLW  76
0A47C:  MOVWF  x95
0A47E:  MOVLW  64
0A480:  MOVWF  x94
0A482:  MOVLW  7A
0A484:  MOVWF  x99
0A486:  MOVLW  1A
0A488:  MOVWF  x98
0A48A:  MOVLW  7F
0A48C:  MOVWF  x9D
0A48E:  MOVLW  76
0A490:  MOVWF  x9C
0A492:  MOVLW  83
0A494:  MOVWF  xA1
0A496:  MOVLW  0E
0A498:  MOVWF  xA0
0A49A:  MOVLW  88
0A49C:  MOVWF  xA5
0A49E:  MOVLW  3A
0A4A0:  MOVWF  xA4
0A4A2:  MOVLW  88
0A4A4:  MOVWF  xA9
0A4A6:  MOVLW  40
0A4A8:  MOVWF  xA8
0A4AA:  MOVLW  8E
0A4AC:  MOVWF  xAD
0A4AE:  MOVLW  B4
0A4B0:  MOVWF  xAC
0A4B2:  MOVLW  94
0A4B4:  MOVWF  xB1
0A4B6:  MOVLW  18
0A4B8:  MOVWF  xB0
0A4BA:  MOVLW  9B
0A4BC:  MOVWF  xB5
0A4BE:  MOVLW  3A
0A4C0:  MOVWF  xB4
0A4C2:  MOVLW  9C
0A4C4:  MOVWF  xB9
0A4C6:  MOVLW  9C
0A4C8:  MOVWF  xB8
0A4CA:  MOVLW  9F
0A4CC:  MOVWF  xBD
0A4CE:  MOVLW  0E
0A4D0:  MOVWF  xBC
0A4D2:  MOVLW  9F
0A4D4:  MOVWF  xC1
0A4D6:  MOVLW  1A
0A4D8:  MOVWF  xC0
0A4DA:  MOVLW  9F
0A4DC:  MOVWF  xC5
0A4DE:  MOVLW  26
0A4E0:  MOVWF  xC4
0A4E2:  MOVLW  A0
0A4E4:  MOVWF  xC9
0A4E6:  MOVLW  12
0A4E8:  MOVWF  xC8
0A4EA:  BRA    A6CA
0A4EC:  DATA 02,00
0A4EE:  DATA 1A,00
0A4F0:  DATA 00,0C
0A4F2:  DATA 00,20
0A4F4:  DATA 78,23
0A4F6:  DATA D7,0A
0A4F8:  DATA 7D,19
0A4FA:  DATA 99,9A
0A4FC:  DATA 7B,4C
0A4FE:  DATA CC,CD
0A500:  DATA 1C,C0
0A502:  DATA 00,0C
0A504:  DATA 80,78
0A506:  DATA 23,D7
0A508:  DATA 0A,7D
0A50A:  DATA 19,99
0A50C:  DATA 9A,7B
0A50E:  DATA 4C,CC
0A510:  DATA CD,1C
0A512:  DATA C0,00
0A514:  DATA 01,80
0A516:  DATA 02,09
0A518:  DATA C0,00
0A51A:  DATA 05,80
0A51C:  DATA 7F,00
0A51E:  DATA 00,00
0A520:  DATA 7F,0B
0A522:  DATA C0,00
0A524:  DATA 05,80
0A526:  DATA 7F,00
0A528:  DATA 00,00
0A52A:  DATA 7F,07
0A52C:  DATA C0,00
0A52E:  DATA 01,80
0A530:  DATA 7F,17
0A532:  DATA C0,00
0A534:  DATA 01,80
0A536:  DATA 7F,17
0A538:  DATA C0,00
0A53A:  DATA 04,80
0A53C:  DATA 79,B7
0A53E:  DATA F3,BD
0A540:  DATA 04,C0
0A542:  DATA 00,04
0A544:  DATA 80,7C
0A546:  DATA 59,DF
0A548:  DATA 4E,04
0A54A:  DATA C0,00
0A54C:  DATA 04,80
0A54E:  DATA 78,0A
0A550:  DATA 28,88
0A552:  DATA 04,C0
0A554:  DATA 00,04
0A556:  DATA 80,78
0A558:  DATA 05,EA
0A55A:  DATA 16,04
0A55C:  DATA C0,00
0A55E:  DATA 04,80
0A560:  DATA 78,1E
0A562:  DATA 33,D7
0A564:  DATA 04,C0
0A566:  DATA 00,04
0A568:  DATA 80,77
0A56A:  DATA 68,7B
0A56C:  DATA BB,04
0A56E:  DATA C0,00
0A570:  DATA 04,80
0A572:  DATA 77,68
0A574:  DATA 0D,C6
0A576:  DATA 68,40
0A578:  DATA FB,00
0A57A:  DATA 0E,41
0A57C:  DATA 64,00
0A57E:  DATA 17,41
0A580:  DATA D4,00
0A582:  DATA 3C,45
0A584:  DATA 25,00
0A586:  DATA 02,05
0A588:  DATA 6A,CA
0A58A:  DATA 05,02
0A58C:  DATA 05,6E
0A58E:  DATA CD,05
0A590:  DATA 02,05
0A592:  DATA 72,D0
0A594:  DATA 05,02
0A596:  DATA 05,76
0A598:  DATA D7,05
0A59A:  DATA 02,05
0A59C:  DATA 7A,DE
0A59E:  DATA 05,02
0A5A0:  DATA 05,7E
0A5A2:  DATA E6,05
0A5A4:  DATA 02,05
0A5A6:  DATA 82,EE
0A5A8:  DATA 05,02
0A5AA:  DATA 05,86
0A5AC:  DATA F3,05
0A5AE:  DATA 02,05
0A5B0:  DATA 8A,F8
0A5B2:  DATA 05,02
0A5B4:  DATA 05,8E
0A5B6:  DATA FC,05
0A5B8:  DATA 02,05
0A5BA:  DATA 92,00
0A5BC:  DATA 06,02
0A5BE:  DATA 05,96
0A5C0:  DATA 07,06
0A5C2:  DATA 02,05
0A5C4:  DATA 9A,0D
0A5C6:  DATA 06,02
0A5C8:  DATA 05,9E
0A5CA:  DATA 13,06
0A5CC:  DATA 02,05
0A5CE:  DATA A2,19
0A5D0:  DATA 06,02
0A5D2:  DATA 05,A6
0A5D4:  DATA 1F,06
0A5D6:  DATA 02,05
0A5D8:  DATA AA,24
0A5DA:  DATA 06,02
0A5DC:  DATA 05,AE
0A5DE:  DATA 2D,06
0A5E0:  DATA 02,05
0A5E2:  DATA B2,35
0A5E4:  DATA 06,02
0A5E6:  DATA 05,B6
0A5E8:  DATA 3C,06
0A5EA:  DATA 02,05
0A5EC:  DATA BA,43
0A5EE:  DATA 06,02
0A5F0:  DATA 05,BE
0A5F2:  DATA 4B,06
0A5F4:  DATA 02,05
0A5F6:  DATA C2,54
0A5F8:  DATA 06,02
0A5FA:  DATA 05,C6
0A5FC:  DATA 5A,06
0A5FE:  DATA 8F,05
0A600:  DATA CA,67
0A602:  DATA 72,00
0A604:  DATA 67,73
0A606:  DATA 00,67
0A608:  DATA 43,68
0A60A:  DATA 4D,61
0A60C:  DATA 70,00
0A60E:  DATA 73,43
0A610:  DATA 68,4D
0A612:  DATA 61,70
0A614:  DATA 00,67
0A616:  DATA 43,68
0A618:  DATA 4D,6F
0A61A:  DATA 64,65
0A61C:  DATA 00,73
0A61E:  DATA 43,68
0A620:  DATA 4D,6F
0A622:  DATA 64,65
0A624:  DATA 00,67
0A626:  DATA 50,49
0A628:  DATA 44,00
0A62A:  DATA 73,50
0A62C:  DATA 49,44
0A62E:  DATA 00,67
0A630:  DATA 53,50
0A632:  DATA 00,73
0A634:  DATA 53,50
0A636:  DATA 00,67
0A638:  DATA 53,43
0A63A:  DATA 61,6C
0A63C:  DATA 73,00
0A63E:  DATA 67,53
0A640:  DATA 43,61
0A642:  DATA 6C,00
0A644:  DATA 73,53
0A646:  DATA 43,61
0A648:  DATA 6C,00
0A64A:  DATA 67,4D
0A64C:  DATA 43,61
0A64E:  DATA 6C,00
0A650:  DATA 73,4D
0A652:  DATA 43,61
0A654:  DATA 6C,00
0A656:  DATA 67,4D
0A658:  DATA 6F,6E
0A65A:  DATA 00,67
0A65C:  DATA 50,49
0A65E:  DATA 44,64
0A660:  DATA 61,74
0A662:  DATA 61,00
0A664:  DATA 67,49
0A666:  DATA 50,64
0A668:  DATA 61,74
0A66A:  DATA 61,00
0A66C:  DATA 67,4D
0A66E:  DATA 61,6E
0A670:  DATA 4F,50
0A672:  DATA 00,73
0A674:  DATA 4D,61
0A676:  DATA 6E,4F
0A678:  DATA 50,00
0A67A:  DATA 73,46
0A67C:  DATA 69,6C
0A67E:  DATA 74,4F
0A680:  DATA 6E,00
0A682:  DATA 73,46
0A684:  DATA 69,6C
0A686:  DATA 74,4F
0A688:  DATA 66,66
0A68A:  DATA 00,73
0A68C:  DATA 48,6F
0A68E:  DATA 6D,65
0A690:  DATA 04,C0
0A692:  DATA 00,33
0A694:  DATA 80,65
0A696:  DATA 06,01
0A698:  DATA 6D,06
0A69A:  DATA 02,7D
0A69C:  DATA 06,53
0A69E:  DATA 55,43
0A6A0:  DATA 43,45
0A6A2:  DATA 53,53
0A6A4:  DATA 00,49
0A6A6:  DATA 4E,56
0A6A8:  DATA 41,4C
0A6AA:  DATA 49,44
0A6AC:  DATA 20,43
0A6AE:  DATA 4F,4D
0A6B0:  DATA 4D,41
0A6B2:  DATA 4E,44
0A6B4:  DATA 00,49
0A6B6:  DATA 4E,56
0A6B8:  DATA 41,4C
0A6BA:  DATA 49,44
0A6BC:  DATA 20,50
0A6BE:  DATA 41,52
0A6C0:  DATA 41,4D
0A6C2:  DATA 45,54
0A6C4:  DATA 45,52
0A6C6:  DATA 00,00
0A6C8:  DATA 00,00
0A6CA:  MOVLW  00
0A6CC:  MOVWF  FF8
0A6CE:  MOVLW  A4
0A6D0:  MOVWF  FF7
0A6D2:  MOVLW  EC
0A6D4:  MOVWF  FF6
0A6D6:  TBLRD*+
0A6D8:  MOVF   FF5,W
0A6DA:  MOVWF  00
0A6DC:  XORLW  00
0A6DE:  BZ    A706
0A6E0:  TBLRD*+
0A6E2:  MOVF   FF5,W
0A6E4:  MOVWF  01
0A6E6:  BTFSC  FE8.7
0A6E8:  BRA    A6F4
0A6EA:  ANDLW  3F
0A6EC:  MOVWF  FEA
0A6EE:  TBLRD*+
0A6F0:  MOVFF  FF5,FE9
0A6F4:  BTFSC  01.6
0A6F6:  TBLRD*+
0A6F8:  BTFSS  01.6
0A6FA:  TBLRD*+
0A6FC:  MOVFF  FF5,FEE
0A700:  DCFSNZ 00,F
0A702:  BRA    A6D6
0A704:  BRA    A6F8
0A706:  CLRF   FF8
0A708:  MOVLW  03
0A70A:  MOVLB  6
0A70C:  MOVWF  x92
0A70E:  MOVLW  E8
0A710:  MOVWF  x91
0A712:  CLRF   x94
0A714:  CLRF   x93
0A716:  CLRF   x96
0A718:  CLRF   x95
.................... {
....................     int16 loopDelay = 1000;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A71A:  MOVLB  0
0A71C:  GOTO   03FC
....................     params_init();                // load parameters
0A720:  GOTO   0698
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A724:  GOTO   0AE4
....................     control_init();               // initialize the output control DACs
0A728:  GOTO   0B7C
....................     serial_init();                // setup the serial port
0A72C:  GOTO   0D1C
....................     event_timer_init();
0A730:  GOTO   0D3E
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A734:  MOVLW  C0
0A736:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A738:  MOVLB  6
0A73A:  CLRF   x97
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A73C:  MOVLB  0
0A73E:  GOTO   1116
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A742:  GOTO   4466
....................       
....................         if (controlCounter >= 2){
0A746:  MOVLB  6
0A748:  MOVF   x94,F
0A74A:  BNZ   A752
0A74C:  MOVF   x93,W
0A74E:  SUBLW  01
0A750:  BC    A760
....................             control_task();
0A752:  MOVLB  0
0A754:  GOTO   4FDE
....................             controlCounter = 0;
0A758:  MOVLB  6
0A75A:  CLRF   x94
0A75C:  CLRF   x93
....................         }else controlCounter++;
0A75E:  BRA    A766
0A760:  INCF   x93,F
0A762:  BTFSC  FD8.2
0A764:  INCF   x94,F
....................       
....................         serial_task();             
0A766:  MOVLB  0
0A768:  GOTO   5088
....................       
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f\r\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A76C:  MOVLW  06
0A76E:  MOVLB  7
0A770:  MOVWF  x42
0A772:  MOVLW  97
0A774:  MOVWF  x41
0A776:  MOVLB  0
0A778:  CALL   55A0
0A77C:  MOVF   01,W
0A77E:  ADDLW  97
0A780:  MOVLB  6
0A782:  MOVWF  xFB
0A784:  MOVLW  06
0A786:  ADDWFC 02,W
0A788:  MOVWF  xFC
0A78A:  MOVLW  01
0A78C:  ADDWF  x8F,W
0A78E:  MOVWF  xFD
0A790:  MOVF   x8F,W
0A792:  MULLW  26
0A794:  MOVF   FF3,W
0A796:  CLRF   xFF
0A798:  MOVWF  xFE
0A79A:  MOVLW  08
0A79C:  ADDWF  xFE,W
0A79E:  MOVWF  01
0A7A0:  MOVLW  00
0A7A2:  ADDWFC xFF,W
0A7A4:  MOVWF  03
0A7A6:  MOVF   01,W
0A7A8:  ADDLW  17
0A7AA:  MOVWF  FE9
0A7AC:  MOVLW  01
0A7AE:  ADDWFC 03,W
0A7B0:  MOVWF  FEA
0A7B2:  MOVFF  FEF,6FE
0A7B6:  MOVFF  FEC,6FF
0A7BA:  MOVFF  FEC,700
0A7BE:  MOVFF  FEC,701
0A7C2:  MOVF   x8F,W
0A7C4:  MULLW  26
0A7C6:  MOVF   FF3,W
0A7C8:  MOVLB  7
0A7CA:  CLRF   x03
0A7CC:  MOVWF  x02
0A7CE:  MOVLW  0C
0A7D0:  ADDWF  x02,W
0A7D2:  MOVWF  01
0A7D4:  MOVLW  00
0A7D6:  ADDWFC x03,W
0A7D8:  MOVWF  03
0A7DA:  MOVF   01,W
0A7DC:  ADDLW  17
0A7DE:  MOVWF  FE9
0A7E0:  MOVLW  01
0A7E2:  ADDWFC 03,W
0A7E4:  MOVWF  FEA
0A7E6:  MOVFF  FEF,702
0A7EA:  MOVFF  FEC,703
0A7EE:  MOVFF  FEC,704
0A7F2:  MOVFF  FEC,705
0A7F6:  MOVFF  6FC,565
0A7FA:  MOVFF  6FB,564
0A7FE:  MOVLW  8E
0A800:  MOVWF  FF6
0A802:  MOVLW  03
0A804:  MOVWF  FF7
0A806:  MOVLW  04
0A808:  MOVWF  x0F
0A80A:  MOVLB  0
0A80C:  CALL   55F8
0A810:  MOVFF  6FD,706
0A814:  MOVLW  1B
0A816:  MOVLB  7
0A818:  MOVWF  x07
0A81A:  MOVLB  0
0A81C:  CALL   5620
0A820:  MOVLW  2C
0A822:  MOVLB  7
0A824:  MOVWF  x50
0A826:  MOVLB  0
0A828:  CALL   55D8
0A82C:  MOVLW  89
0A82E:  MOVWF  FE9
0A830:  MOVFF  701,746
0A834:  MOVFF  700,745
0A838:  MOVFF  6FF,744
0A83C:  MOVFF  6FE,743
0A840:  MOVLB  7
0A842:  CLRF   x47
0A844:  MOVLB  0
0A846:  CALL   5776
0A84A:  MOVLW  2C
0A84C:  MOVLB  7
0A84E:  MOVWF  x50
0A850:  MOVLB  0
0A852:  CALL   55D8
0A856:  MOVLW  89
0A858:  MOVWF  FE9
0A85A:  MOVFF  705,746
0A85E:  MOVFF  704,745
0A862:  MOVFF  703,744
0A866:  MOVFF  702,743
0A86A:  MOVLB  7
0A86C:  CLRF   x47
0A86E:  MOVLB  0
0A870:  CALL   5776
0A874:  MOVLW  0D
0A876:  MOVLB  7
0A878:  MOVWF  x50
0A87A:  MOVLB  0
0A87C:  CALL   55D8
0A880:  MOVLW  0A
0A882:  MOVLB  7
0A884:  MOVWF  x50
0A886:  MOVLB  0
0A888:  CALL   55D8
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f\r\n", ch+1, adcVals[ch].pReal);
0A88C:  MOVLW  06
0A88E:  MOVLB  7
0A890:  MOVWF  x42
0A892:  MOVLW  97
0A894:  MOVWF  x41
0A896:  MOVLB  0
0A898:  CALL   55A0
0A89C:  MOVF   01,W
0A89E:  ADDLW  97
0A8A0:  MOVLB  6
0A8A2:  MOVWF  xFB
0A8A4:  MOVLW  06
0A8A6:  ADDWFC 02,W
0A8A8:  MOVWF  xFC
0A8AA:  MOVLW  01
0A8AC:  ADDWF  x8F,W
0A8AE:  MOVWF  xFD
0A8B0:  MOVF   x8F,W
0A8B2:  MULLW  26
0A8B4:  MOVF   FF3,W
0A8B6:  CLRF   xFF
0A8B8:  MOVWF  xFE
0A8BA:  MOVLW  1D
0A8BC:  ADDWF  xFE,W
0A8BE:  MOVWF  01
0A8C0:  MOVLW  00
0A8C2:  ADDWFC xFF,W
0A8C4:  MOVWF  03
0A8C6:  MOVF   01,W
0A8C8:  ADDLW  17
0A8CA:  MOVWF  FE9
0A8CC:  MOVLW  01
0A8CE:  ADDWFC 03,W
0A8D0:  MOVWF  FEA
0A8D2:  MOVFF  FEF,6FE
0A8D6:  MOVFF  FEC,6FF
0A8DA:  MOVFF  FEC,700
0A8DE:  MOVFF  FEC,701
0A8E2:  MOVFF  6FC,565
0A8E6:  MOVFF  6FB,564
0A8EA:  MOVLW  A2
0A8EC:  MOVWF  FF6
0A8EE:  MOVLW  03
0A8F0:  MOVWF  FF7
0A8F2:  MOVLW  04
0A8F4:  MOVLB  7
0A8F6:  MOVWF  x0F
0A8F8:  MOVLB  0
0A8FA:  CALL   55F8
0A8FE:  MOVFF  6FD,706
0A902:  MOVLW  1B
0A904:  MOVLB  7
0A906:  MOVWF  x07
0A908:  MOVLB  0
0A90A:  CALL   5620
0A90E:  MOVLW  2C
0A910:  MOVLB  7
0A912:  MOVWF  x50
0A914:  MOVLB  0
0A916:  CALL   55D8
0A91A:  MOVLW  89
0A91C:  MOVWF  FE9
0A91E:  MOVFF  701,746
0A922:  MOVFF  700,745
0A926:  MOVFF  6FF,744
0A92A:  MOVFF  6FE,743
0A92E:  MOVLW  03
0A930:  MOVLB  7
0A932:  MOVWF  x47
0A934:  MOVLB  0
0A936:  CALL   5776
0A93A:  MOVLW  0D
0A93C:  MOVLB  7
0A93E:  MOVWF  x50
0A940:  MOVLB  0
0A942:  CALL   55D8
0A946:  MOVLW  0A
0A948:  MOVLB  7
0A94A:  MOVWF  x50
0A94C:  MOVLB  0
0A94E:  CALL   55D8
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu\r\n", ch+1, dacVals[ch].ipVal);
0A952:  MOVLB  6
0A954:  MOVF   x8F,W
0A956:  MULLW  07
0A958:  MOVF   FF3,W
0A95A:  CLRF   xFC
0A95C:  MOVWF  xFB
0A95E:  MOVLW  64
0A960:  ADDWF  xFB,W
0A962:  MOVWF  FE9
0A964:  MOVLW  01
0A966:  ADDWFC xFC,W
0A968:  MOVWF  FEA
0A96A:  BTFSS  FEF.0
0A96C:  BRA    AA28
0A96E:  MOVLW  06
0A970:  MOVLB  7
0A972:  MOVWF  x42
0A974:  MOVLW  97
0A976:  MOVWF  x41
0A978:  MOVLB  0
0A97A:  CALL   55A0
0A97E:  MOVF   01,W
0A980:  ADDLW  97
0A982:  MOVLB  6
0A984:  MOVWF  xFB
0A986:  MOVLW  06
0A988:  ADDWFC 02,W
0A98A:  MOVWF  xFC
0A98C:  MOVLW  01
0A98E:  ADDWF  x8F,W
0A990:  MOVWF  xFD
0A992:  MOVF   x8F,W
0A994:  MULLW  07
0A996:  MOVF   FF3,W
0A998:  CLRF   xFF
0A99A:  MOVWF  xFE
0A99C:  MOVLW  01
0A99E:  ADDWF  xFE,W
0A9A0:  MOVWF  01
0A9A2:  MOVLW  00
0A9A4:  ADDWFC xFF,W
0A9A6:  MOVWF  03
0A9A8:  MOVF   01,W
0A9AA:  ADDLW  64
0A9AC:  MOVWF  FE9
0A9AE:  MOVLW  01
0A9B0:  ADDWFC 03,W
0A9B2:  MOVWF  FEA
0A9B4:  MOVFF  FEC,6FF
0A9B8:  MOVF   FED,F
0A9BA:  MOVFF  FEF,6FE
0A9BE:  MOVFF  6FC,565
0A9C2:  MOVFF  6FB,564
0A9C6:  MOVLW  B2
0A9C8:  MOVWF  FF6
0A9CA:  MOVLW  03
0A9CC:  MOVWF  FF7
0A9CE:  MOVLW  04
0A9D0:  MOVLB  7
0A9D2:  MOVWF  x0F
0A9D4:  MOVLB  0
0A9D6:  CALL   55F8
0A9DA:  MOVFF  6FD,706
0A9DE:  MOVLW  1B
0A9E0:  MOVLB  7
0A9E2:  MOVWF  x07
0A9E4:  MOVLB  0
0A9E6:  CALL   5620
0A9EA:  MOVLW  B8
0A9EC:  MOVWF  FF6
0A9EE:  MOVLW  03
0A9F0:  MOVWF  FF7
0A9F2:  MOVLW  03
0A9F4:  MOVLB  7
0A9F6:  MOVWF  x0F
0A9F8:  MOVLB  0
0A9FA:  CALL   55F8
0A9FE:  MOVLW  10
0AA00:  MOVWF  FE9
0AA02:  MOVFF  6FF,701
0AA06:  MOVFF  6FE,700
0AA0A:  CALL   591E
0AA0E:  MOVLW  0D
0AA10:  MOVLB  7
0AA12:  MOVWF  x50
0AA14:  MOVLB  0
0AA16:  CALL   55D8
0AA1A:  MOVLW  0A
0AA1C:  MOVLB  7
0AA1E:  MOVWF  x50
0AA20:  MOVLB  0
0AA22:  CALL   55D8
0AA26:  BRA    AAE0
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu\r\n", ch+1, dacVals[ch].ipVal);
0AA28:  MOVLW  06
0AA2A:  MOVLB  7
0AA2C:  MOVWF  x42
0AA2E:  MOVLW  97
0AA30:  MOVWF  x41
0AA32:  MOVLB  0
0AA34:  CALL   55A0
0AA38:  MOVF   01,W
0AA3A:  ADDLW  97
0AA3C:  MOVLB  6
0AA3E:  MOVWF  xFB
0AA40:  MOVLW  06
0AA42:  ADDWFC 02,W
0AA44:  MOVWF  xFC
0AA46:  MOVLW  01
0AA48:  ADDWF  x8F,W
0AA4A:  MOVWF  xFD
0AA4C:  MOVF   x8F,W
0AA4E:  MULLW  07
0AA50:  MOVF   FF3,W
0AA52:  CLRF   xFF
0AA54:  MOVWF  xFE
0AA56:  MOVLW  01
0AA58:  ADDWF  xFE,W
0AA5A:  MOVWF  01
0AA5C:  MOVLW  00
0AA5E:  ADDWFC xFF,W
0AA60:  MOVWF  03
0AA62:  MOVF   01,W
0AA64:  ADDLW  64
0AA66:  MOVWF  FE9
0AA68:  MOVLW  01
0AA6A:  ADDWFC 03,W
0AA6C:  MOVWF  FEA
0AA6E:  MOVFF  FEC,6FF
0AA72:  MOVF   FED,F
0AA74:  MOVFF  FEF,6FE
0AA78:  MOVFF  6FC,565
0AA7C:  MOVFF  6FB,564
0AA80:  MOVLW  C2
0AA82:  MOVWF  FF6
0AA84:  MOVLW  03
0AA86:  MOVWF  FF7
0AA88:  MOVLW  04
0AA8A:  MOVLB  7
0AA8C:  MOVWF  x0F
0AA8E:  MOVLB  0
0AA90:  CALL   55F8
0AA94:  MOVFF  6FD,706
0AA98:  MOVLW  1B
0AA9A:  MOVLB  7
0AA9C:  MOVWF  x07
0AA9E:  MOVLB  0
0AAA0:  CALL   5620
0AAA4:  MOVLW  C8
0AAA6:  MOVWF  FF6
0AAA8:  MOVLW  03
0AAAA:  MOVWF  FF7
0AAAC:  MOVLW  03
0AAAE:  MOVLB  7
0AAB0:  MOVWF  x0F
0AAB2:  MOVLB  0
0AAB4:  CALL   55F8
0AAB8:  MOVLW  10
0AABA:  MOVWF  FE9
0AABC:  MOVFF  6FF,701
0AAC0:  MOVFF  6FE,700
0AAC4:  CALL   591E
0AAC8:  MOVLW  0D
0AACA:  MOVLB  7
0AACC:  MOVWF  x50
0AACE:  MOVLB  0
0AAD0:  CALL   55D8
0AAD4:  MOVLW  0A
0AAD6:  MOVLB  7
0AAD8:  MOVWF  x50
0AADA:  MOVLB  0
0AADC:  CALL   55D8
....................             ch = !ch;
0AAE0:  MOVLB  6
0AAE2:  MOVF   x8F,F
0AAE4:  BTFSC  FD8.2
0AAE6:  BRA    AAEC
0AAE8:  MOVLW  00
0AAEA:  BRA    AAEE
0AAEC:  MOVLW  01
0AAEE:  MOVWF  x8F
....................             debugCounter = 0;
0AAF0:  CLRF   x96
0AAF2:  CLRF   x95
....................         }else debugCounter++;
....................         fprintf(ICD_STREAM, "%s", pBuff);
0AAF4:  MOVLW  06
0AAF6:  MOVWF  FEA
0AAF8:  MOVLW  97
0AAFA:  MOVWF  FE9
0AAFC:  MOVLB  0
0AAFE:  GOTO   5A36
....................         #endif
....................       
....................         command_handler_task();    //execute commands
0AB02:  GOTO   A1EA
....................       
....................         delay_ms(loopDelay);
0AB06:  MOVFF  692,6FB
0AB0A:  MOVLB  6
0AB0C:  INCF   xFB,F
0AB0E:  DECF   xFB,F
0AB10:  BTFSC  FD8.2
0AB12:  BRA    AB22
0AB14:  MOVLB  7
0AB16:  SETF   x01
0AB18:  MOVLB  0
0AB1A:  CALL   03D2
0AB1E:  MOVLB  6
0AB20:  BRA    AB0E
0AB22:  MOVFF  691,701
0AB26:  MOVLB  0
0AB28:  CALL   03D2
0AB2C:  BRA    A738
....................     }
.................... }
0AB2E:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
