CCS PCH C Compiler, Version 5.117, 2138               02-Dec-25 20:35

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   41704 bytes (64%)
                           Largest free fragment is 23830
               RAM used:   1689 (47%) at main() level
                           1796 (50%) worst case
               Stack used: 11 locations (5 in main + 6 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   9C52
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0252
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00326:  DATA 32,30
00328:  DATA 32,35
0032A:  DATA 31,31
0032C:  DATA 30,34
0032E:  DATA 00,00
00330:  DATA 30,30
00332:  DATA 30,30
00334:  DATA 00,00
00336:  DATA 25,64
00338:  DATA 2C,4D
0033A:  DATA 41,4E
0033C:  DATA 55,41
0033E:  DATA 4C,2C
00340:  DATA 00,00
00342:  DATA 25,64
00344:  DATA 2C,4D
00346:  DATA 41,47
00348:  DATA 53,4E
0034A:  DATA 53,2C
0034C:  DATA 00,00
0034E:  DATA 23,44
00350:  DATA 30,2C
00352:  DATA 43,4E
00354:  DATA 54,2C
00356:  DATA 25,75
00358:  DATA 2C,25
0035A:  DATA 2E,30
0035C:  DATA 66,2C
0035E:  DATA 25,2E
00360:  DATA 30,66
00362:  DATA 0A,00
00364:  DATA 23,44
00366:  DATA 30,2C
00368:  DATA 50,4F
0036A:  DATA 53,2C
0036C:  DATA 25,75
0036E:  DATA 2C,25
00370:  DATA 33,2E
00372:  DATA 33,66
00374:  DATA 0A,00
00376:  DATA 23,44
00378:  DATA 30,2C
0037A:  DATA 4F,55
0037C:  DATA 54,2C
0037E:  DATA 25,75
00380:  DATA 2C,2D
00382:  DATA 2C,25
00384:  DATA 4C,75
00386:  DATA 0A,00
00388:  DATA 23,44
0038A:  DATA 30,2C
0038C:  DATA 4F,55
0038E:  DATA 54,2C
00390:  DATA 25,75
00392:  DATA 2C,2B
00394:  DATA 2C,25
00396:  DATA 4C,75
00398:  DATA 0A,00
*
006C0:  ADDWF  FE8,W
006C2:  CLRF   FF7
006C4:  RLCF   FF7,F
006C6:  ADDLW  DB
006C8:  MOVWF  FF6
006CA:  MOVLW  06
006CC:  ADDWFC FF7,F
006CE:  TBLRD*-
006D0:  MOVF   FF5,W
006D2:  MOVWF  FFA
006D4:  TBLRD*
006D6:  MOVF   FF5,W
006D8:  MOVWF  FF9
006DA:  DATA 8A,06
006DC:  DATA 94,06
006DE:  DATA 9E,06
006E0:  DATA A8,06
*
00860:  MOVLB  6
00862:  MOVF   xF8,W
00864:  XORWF  xFA,W
00866:  ANDLW  80
00868:  MOVWF  xFC
0086A:  BTFSS  xF8.7
0086C:  BRA    0878
0086E:  COMF   xF7,F
00870:  COMF   xF8,F
00872:  INCF   xF7,F
00874:  BTFSC  FD8.2
00876:  INCF   xF8,F
00878:  BTFSS  xFA.7
0087A:  BRA    0886
0087C:  COMF   xF9,F
0087E:  COMF   xFA,F
00880:  INCF   xF9,F
00882:  BTFSC  FD8.2
00884:  INCF   xFA,F
00886:  MOVF   xF7,W
00888:  MULWF  xF9
0088A:  MOVFF  FF3,01
0088E:  MOVFF  FF4,00
00892:  MULWF  xFA
00894:  MOVF   FF3,W
00896:  ADDWF  00,F
00898:  MOVF   xF8,W
0089A:  MULWF  xF9
0089C:  MOVF   FF3,W
0089E:  ADDWFC 00,W
008A0:  MOVWF  02
008A2:  BTFSS  xFC.7
008A4:  BRA    08B0
008A6:  COMF   01,F
008A8:  COMF   02,F
008AA:  INCF   01,F
008AC:  BTFSC  FD8.2
008AE:  INCF   02,F
008B0:  MOVLB  0
008B2:  RETURN 0
008B4:  MOVLB  6
008B6:  MOVF   xA7,W
008B8:  XORWF  xA8,W
008BA:  ANDLW  80
008BC:  MOVWF  xAA
008BE:  BTFSS  xA7.7
008C0:  BRA    08C6
008C2:  COMF   xA7,F
008C4:  INCF   xA7,F
008C6:  BTFSS  xA8.7
008C8:  BRA    08CE
008CA:  COMF   xA8,F
008CC:  INCF   xA8,F
008CE:  MOVF   xA8,W
008D0:  CLRF   01
008D2:  SUBWF  xA7,W
008D4:  BC    08DC
008D6:  MOVFF  6A7,00
008DA:  BRA    08F4
008DC:  CLRF   00
008DE:  MOVLW  08
008E0:  MOVWF  xA9
008E2:  RLCF   xA7,F
008E4:  RLCF   00,F
008E6:  MOVF   xA8,W
008E8:  SUBWF  00,W
008EA:  BTFSC  FD8.0
008EC:  MOVWF  00
008EE:  RLCF   01,F
008F0:  DECFSZ xA9,F
008F2:  BRA    08E2
008F4:  BTFSS  xAA.7
008F6:  BRA    08FC
008F8:  COMF   01,F
008FA:  INCF   01,F
008FC:  MOVLB  0
008FE:  GOTO   0974 (RETURN)
*
00C04:  MOVLB  6
00C06:  MOVF   xD1,W
00C08:  MULWF  xD3
00C0A:  MOVFF  FF3,01
00C0E:  MOVFF  FF4,00
00C12:  MULWF  xD4
00C14:  MOVF   FF3,W
00C16:  ADDWF  00,F
00C18:  MOVF   xD2,W
00C1A:  MULWF  xD3
00C1C:  MOVF   FF3,W
00C1E:  ADDWFC 00,W
00C20:  MOVWF  02
00C22:  MOVLB  0
00C24:  RETURN 0
*
00DFC:  MOVLW  8E
00DFE:  MOVWF  00
00E00:  MOVFF  6E0,01
00E04:  MOVFF  6DF,02
00E08:  CLRF   03
00E0A:  MOVF   01,F
00E0C:  BNZ   0E20
00E0E:  MOVFF  02,01
00E12:  CLRF   02
00E14:  MOVLW  08
00E16:  SUBWF  00,F
00E18:  MOVF   01,F
00E1A:  BNZ   0E20
00E1C:  CLRF   00
00E1E:  BRA    0E30
00E20:  BCF    FD8.0
00E22:  BTFSC  01.7
00E24:  BRA    0E2E
00E26:  RLCF   02,F
00E28:  RLCF   01,F
00E2A:  DECF   00,F
00E2C:  BRA    0E20
00E2E:  BCF    01.7
00E30:  RETURN 0
00E32:  MOVLB  6
00E34:  MOVF   xE0,W
00E36:  BTFSC  FD8.2
00E38:  BRA    0F1C
00E3A:  MOVWF  00
00E3C:  MOVF   xE4,W
00E3E:  BTFSC  FD8.2
00E40:  BRA    0F1C
00E42:  ADDWF  00,F
00E44:  BNC   0E4E
00E46:  MOVLW  81
00E48:  ADDWF  00,F
00E4A:  BC    0F1C
00E4C:  BRA    0E56
00E4E:  MOVLW  7F
00E50:  SUBWF  00,F
00E52:  BNC   0F1C
00E54:  BZ    0F1C
00E56:  MOVFF  6E1,6E8
00E5A:  MOVF   xE5,W
00E5C:  XORWF  xE8,F
00E5E:  BSF    xE1.7
00E60:  BSF    xE5.7
00E62:  MOVF   xE3,W
00E64:  MULWF  xE7
00E66:  MOVFF  FF4,6EA
00E6A:  MOVF   xE2,W
00E6C:  MULWF  xE6
00E6E:  MOVFF  FF4,03
00E72:  MOVFF  FF3,6E9
00E76:  MULWF  xE7
00E78:  MOVF   FF3,W
00E7A:  ADDWF  xEA,F
00E7C:  MOVF   FF4,W
00E7E:  ADDWFC xE9,F
00E80:  MOVLW  00
00E82:  ADDWFC 03,F
00E84:  MOVF   xE3,W
00E86:  MULWF  xE6
00E88:  MOVF   FF3,W
00E8A:  ADDWF  xEA,F
00E8C:  MOVF   FF4,W
00E8E:  ADDWFC xE9,F
00E90:  MOVLW  00
00E92:  CLRF   02
00E94:  ADDWFC 03,F
00E96:  ADDWFC 02,F
00E98:  MOVF   xE1,W
00E9A:  MULWF  xE7
00E9C:  MOVF   FF3,W
00E9E:  ADDWF  xE9,F
00EA0:  MOVF   FF4,W
00EA2:  ADDWFC 03,F
00EA4:  MOVLW  00
00EA6:  ADDWFC 02,F
00EA8:  MOVF   xE1,W
00EAA:  MULWF  xE6
00EAC:  MOVF   FF3,W
00EAE:  ADDWF  03,F
00EB0:  MOVF   FF4,W
00EB2:  ADDWFC 02,F
00EB4:  MOVLW  00
00EB6:  CLRF   01
00EB8:  ADDWFC 01,F
00EBA:  MOVF   xE3,W
00EBC:  MULWF  xE5
00EBE:  MOVF   FF3,W
00EC0:  ADDWF  xE9,F
00EC2:  MOVF   FF4,W
00EC4:  ADDWFC 03,F
00EC6:  MOVLW  00
00EC8:  ADDWFC 02,F
00ECA:  ADDWFC 01,F
00ECC:  MOVF   xE2,W
00ECE:  MULWF  xE5
00ED0:  MOVF   FF3,W
00ED2:  ADDWF  03,F
00ED4:  MOVF   FF4,W
00ED6:  ADDWFC 02,F
00ED8:  MOVLW  00
00EDA:  ADDWFC 01,F
00EDC:  MOVF   xE1,W
00EDE:  MULWF  xE5
00EE0:  MOVF   FF3,W
00EE2:  ADDWF  02,F
00EE4:  MOVF   FF4,W
00EE6:  ADDWFC 01,F
00EE8:  INCF   00,F
00EEA:  BTFSC  01.7
00EEC:  BRA    0EF8
00EEE:  RLCF   xE9,F
00EF0:  RLCF   03,F
00EF2:  RLCF   02,F
00EF4:  RLCF   01,F
00EF6:  DECF   00,F
00EF8:  MOVLW  00
00EFA:  BTFSS  xE9.7
00EFC:  BRA    0F12
00EFE:  INCF   03,F
00F00:  ADDWFC 02,F
00F02:  ADDWFC 01,F
00F04:  MOVF   01,W
00F06:  BNZ   0F12
00F08:  MOVF   02,W
00F0A:  BNZ   0F12
00F0C:  MOVF   03,W
00F0E:  BNZ   0F12
00F10:  INCF   00,F
00F12:  BTFSC  xE8.7
00F14:  BSF    01.7
00F16:  BTFSS  xE8.7
00F18:  BCF    01.7
00F1A:  BRA    0F24
00F1C:  CLRF   00
00F1E:  CLRF   01
00F20:  CLRF   02
00F22:  CLRF   03
00F24:  MOVLB  0
00F26:  RETURN 0
00F28:  MOVLW  80
00F2A:  BTFSS  FD8.1
00F2C:  BRA    0F32
00F2E:  MOVLB  6
00F30:  XORWF  xE4,F
00F32:  MOVLB  6
00F34:  CLRF   xE9
00F36:  CLRF   xEA
00F38:  MOVFF  6E0,6E8
00F3C:  MOVF   xE4,W
00F3E:  XORWF  xE8,F
00F40:  MOVF   xDF,W
00F42:  BTFSC  FD8.2
00F44:  BRA    1104
00F46:  MOVWF  xE7
00F48:  MOVWF  00
00F4A:  MOVF   xE3,W
00F4C:  BTFSC  FD8.2
00F4E:  BRA    1116
00F50:  SUBWF  xE7,F
00F52:  BTFSC  FD8.2
00F54:  BRA    105C
00F56:  BNC   0FD4
00F58:  MOVFF  6E4,6ED
00F5C:  BSF    xED.7
00F5E:  MOVFF  6E5,6EC
00F62:  MOVFF  6E6,6EB
00F66:  CLRF   xEA
00F68:  BCF    FD8.0
00F6A:  RRCF   xED,F
00F6C:  RRCF   xEC,F
00F6E:  RRCF   xEB,F
00F70:  RRCF   xEA,F
00F72:  DECFSZ xE7,F
00F74:  BRA    0F66
00F76:  BTFSS  xE8.7
00F78:  BRA    0F80
00F7A:  BSF    xE9.0
00F7C:  BRA    113E
00F7E:  BCF    xE9.0
00F80:  BCF    xE7.0
00F82:  BSF    xE9.4
00F84:  MOVLW  06
00F86:  MOVWF  FEA
00F88:  MOVLW  E2
00F8A:  MOVWF  FE9
00F8C:  BRA    1164
00F8E:  BCF    xE9.4
00F90:  BTFSC  xE8.7
00F92:  BRA    0FA8
00F94:  BTFSS  xE7.0
00F96:  BRA    0FBE
00F98:  RRCF   xED,F
00F9A:  RRCF   xEC,F
00F9C:  RRCF   xEB,F
00F9E:  RRCF   xEA,F
00FA0:  INCF   00,F
00FA2:  BTFSC  FD8.2
00FA4:  BRA    1134
00FA6:  BRA    0FBE
00FA8:  BTFSC  xED.7
00FAA:  BRA    0FC4
00FAC:  BCF    FD8.0
00FAE:  RLCF   xEA,F
00FB0:  RLCF   xEB,F
00FB2:  RLCF   xEC,F
00FB4:  RLCF   xED,F
00FB6:  DECF   00,F
00FB8:  BTFSC  FD8.2
00FBA:  BRA    1134
00FBC:  BRA    0FA8
00FBE:  BSF    xE9.6
00FC0:  BRA    109C
00FC2:  BCF    xE9.6
00FC4:  MOVFF  6E0,6E8
00FC8:  BTFSS  xE0.7
00FCA:  BRA    0FD0
00FCC:  BSF    xED.7
00FCE:  BRA    1126
00FD0:  BCF    xED.7
00FD2:  BRA    1126
00FD4:  MOVFF  6E3,6E7
00FD8:  MOVFF  6E3,00
00FDC:  MOVF   xDF,W
00FDE:  SUBWF  xE7,F
00FE0:  MOVFF  6E0,6ED
00FE4:  BSF    xED.7
00FE6:  MOVFF  6E1,6EC
00FEA:  MOVFF  6E2,6EB
00FEE:  CLRF   xEA
00FF0:  BCF    FD8.0
00FF2:  RRCF   xED,F
00FF4:  RRCF   xEC,F
00FF6:  RRCF   xEB,F
00FF8:  RRCF   xEA,F
00FFA:  DECFSZ xE7,F
00FFC:  BRA    0FEE
00FFE:  BTFSS  xE8.7
01000:  BRA    1008
01002:  BSF    xE9.1
01004:  BRA    113E
01006:  BCF    xE9.1
01008:  BCF    xE7.0
0100A:  BSF    xE9.5
0100C:  MOVLW  06
0100E:  MOVWF  FEA
01010:  MOVLW  E6
01012:  MOVWF  FE9
01014:  BRA    1164
01016:  BCF    xE9.5
01018:  BTFSC  xE8.7
0101A:  BRA    1030
0101C:  BTFSS  xE7.0
0101E:  BRA    1046
01020:  RRCF   xED,F
01022:  RRCF   xEC,F
01024:  RRCF   xEB,F
01026:  RRCF   xEA,F
01028:  INCF   00,F
0102A:  BTFSC  FD8.2
0102C:  BRA    1134
0102E:  BRA    1046
01030:  BTFSC  xED.7
01032:  BRA    104C
01034:  BCF    FD8.0
01036:  RLCF   xEA,F
01038:  RLCF   xEB,F
0103A:  RLCF   xEC,F
0103C:  RLCF   xED,F
0103E:  DECF   00,F
01040:  BTFSC  FD8.2
01042:  BRA    1134
01044:  BRA    1030
01046:  BSF    xE9.7
01048:  BRA    109C
0104A:  BCF    xE9.7
0104C:  MOVFF  6E4,6E8
01050:  BTFSS  xE4.7
01052:  BRA    1058
01054:  BSF    xED.7
01056:  BRA    1126
01058:  BCF    xED.7
0105A:  BRA    1126
0105C:  MOVFF  6E4,6ED
01060:  BSF    xED.7
01062:  MOVFF  6E5,6EC
01066:  MOVFF  6E6,6EB
0106A:  BTFSS  xE8.7
0106C:  BRA    1076
0106E:  BCF    xED.7
01070:  BSF    xE9.2
01072:  BRA    113E
01074:  BCF    xE9.2
01076:  CLRF   xEA
01078:  BCF    xE7.0
0107A:  MOVLW  06
0107C:  MOVWF  FEA
0107E:  MOVLW  E2
01080:  MOVWF  FE9
01082:  BRA    1164
01084:  BTFSC  xE8.7
01086:  BRA    10C0
01088:  MOVFF  6E0,6E8
0108C:  BTFSS  xE7.0
0108E:  BRA    109C
01090:  RRCF   xED,F
01092:  RRCF   xEC,F
01094:  RRCF   xEB,F
01096:  RRCF   xEA,F
01098:  INCF   00,F
0109A:  BZ    1134
0109C:  BTFSS  xEA.7
0109E:  BRA    10B6
010A0:  INCF   xEB,F
010A2:  BNZ   10B6
010A4:  INCF   xEC,F
010A6:  BNZ   10B6
010A8:  INCF   xED,F
010AA:  BNZ   10B6
010AC:  RRCF   xED,F
010AE:  RRCF   xEC,F
010B0:  RRCF   xEB,F
010B2:  INCF   00,F
010B4:  BZ    1134
010B6:  BTFSC  xE9.6
010B8:  BRA    0FC2
010BA:  BTFSC  xE9.7
010BC:  BRA    104A
010BE:  BRA    10F8
010C0:  MOVLW  80
010C2:  XORWF  xED,F
010C4:  BTFSS  xED.7
010C6:  BRA    10D0
010C8:  BRA    113E
010CA:  MOVFF  6E4,6E8
010CE:  BRA    10E4
010D0:  MOVFF  6E0,6E8
010D4:  MOVF   xED,F
010D6:  BNZ   10E4
010D8:  MOVF   xEC,F
010DA:  BNZ   10E4
010DC:  MOVF   xEB,F
010DE:  BNZ   10E4
010E0:  CLRF   00
010E2:  BRA    1126
010E4:  BTFSC  xED.7
010E6:  BRA    10F8
010E8:  BCF    FD8.0
010EA:  RLCF   xEA,F
010EC:  RLCF   xEB,F
010EE:  RLCF   xEC,F
010F0:  RLCF   xED,F
010F2:  DECFSZ 00,F
010F4:  BRA    10E4
010F6:  BRA    1134
010F8:  BTFSS  xE8.7
010FA:  BRA    1100
010FC:  BSF    xED.7
010FE:  BRA    1126
01100:  BCF    xED.7
01102:  BRA    1126
01104:  MOVFF  6E3,00
01108:  MOVFF  6E4,6ED
0110C:  MOVFF  6E5,6EC
01110:  MOVFF  6E6,6EB
01114:  BRA    1126
01116:  MOVFF  6DF,00
0111A:  MOVFF  6E0,6ED
0111E:  MOVFF  6E1,6EC
01122:  MOVFF  6E2,6EB
01126:  MOVFF  6ED,01
0112A:  MOVFF  6EC,02
0112E:  MOVFF  6EB,03
01132:  BRA    119C
01134:  CLRF   00
01136:  CLRF   01
01138:  CLRF   02
0113A:  CLRF   03
0113C:  BRA    119C
0113E:  CLRF   xEA
01140:  COMF   xEB,F
01142:  COMF   xEC,F
01144:  COMF   xED,F
01146:  COMF   xEA,F
01148:  INCF   xEA,F
0114A:  BNZ   1156
0114C:  INCF   xEB,F
0114E:  BNZ   1156
01150:  INCF   xEC,F
01152:  BNZ   1156
01154:  INCF   xED,F
01156:  BTFSC  xE9.0
01158:  BRA    0F7E
0115A:  BTFSC  xE9.1
0115C:  BRA    1006
0115E:  BTFSC  xE9.2
01160:  BRA    1074
01162:  BRA    10CA
01164:  MOVF   FEF,W
01166:  ADDWF  xEB,F
01168:  BNC   1174
0116A:  INCF   xEC,F
0116C:  BNZ   1174
0116E:  INCF   xED,F
01170:  BTFSC  FD8.2
01172:  BSF    xE7.0
01174:  MOVF   FED,F
01176:  MOVF   FEF,W
01178:  ADDWF  xEC,F
0117A:  BNC   1182
0117C:  INCF   xED,F
0117E:  BTFSC  FD8.2
01180:  BSF    xE7.0
01182:  MOVF   FED,F
01184:  MOVF   FEF,W
01186:  BTFSC  FEF.7
01188:  BRA    118C
0118A:  XORLW  80
0118C:  ADDWF  xED,F
0118E:  BTFSC  FD8.0
01190:  BSF    xE7.0
01192:  BTFSC  xE9.4
01194:  BRA    0F8E
01196:  BTFSC  xE9.5
01198:  BRA    1016
0119A:  BRA    1084
0119C:  MOVLB  0
0119E:  RETURN 0
*
016F6:  ADDWF  FE8,W
016F8:  CLRF   FF7
016FA:  RLCF   FF7,F
016FC:  ADDLW  11
016FE:  MOVWF  FF6
01700:  MOVLW  17
01702:  ADDWFC FF7,F
01704:  TBLRD*-
01706:  MOVF   FF5,W
01708:  MOVWF  FFA
0170A:  TBLRD*
0170C:  MOVF   FF5,W
0170E:  MOVWF  FF9
01710:  DATA B8,11
01712:  DATA 78,12
01714:  DATA 38,13
01716:  DATA F8,13
01718:  DATA B8,14
0171A:  DATA 78,15
0171C:  DATA 38,16
0171E:  MOVLW  B6
01720:  MOVWF  00
01722:  CLRF   03
01724:  CLRF   02
01726:  CLRF   01
01728:  MOVLB  6
0172A:  BCF    xA9.0
0172C:  BTFSS  xA8.7
0172E:  BRA    1748
01730:  BSF    xA9.0
01732:  COMF   xA5,F
01734:  COMF   xA6,F
01736:  COMF   xA7,F
01738:  COMF   xA8,F
0173A:  INCF   xA5,F
0173C:  BNZ   1748
0173E:  INCF   xA6,F
01740:  BNZ   1748
01742:  INCF   xA7,F
01744:  BTFSC  FD8.2
01746:  INCF   xA8,F
01748:  MOVF   xA5,W
0174A:  IORWF  xA6,W
0174C:  IORWF  xA7,W
0174E:  IORWF  xA8,W
01750:  BNZ   1756
01752:  CLRF   00
01754:  BRA    1774
01756:  BCF    FD8.0
01758:  BTFSC  01.7
0175A:  BRA    176E
0175C:  RLCF   xA5,F
0175E:  RLCF   xA6,F
01760:  RLCF   xA7,F
01762:  RLCF   xA8,F
01764:  RLCF   03,F
01766:  RLCF   02,F
01768:  RLCF   01,F
0176A:  DECFSZ 00,F
0176C:  BRA    1756
0176E:  BCF    01.7
01770:  BTFSC  xA9.0
01772:  BSF    01.7
01774:  MOVLB  0
01776:  RETURN 0
01778:  MOVFF  6DC,6E3
0177C:  MOVLB  6
0177E:  MOVF   xE0,W
01780:  XORWF  xE3,F
01782:  BTFSS  xE3.7
01784:  BRA    1790
01786:  BCF    FD8.2
01788:  BCF    FD8.0
0178A:  BTFSC  xDC.7
0178C:  BSF    FD8.0
0178E:  BRA    17EE
01790:  MOVFF  6DC,6E3
01794:  MOVFF  6DF,6E4
01798:  MOVF   xDB,W
0179A:  SUBWF  xE4,F
0179C:  BZ    17AA
0179E:  BTFSS  xE3.7
017A0:  BRA    17EE
017A2:  MOVF   FD8,W
017A4:  XORLW  01
017A6:  MOVWF  FD8
017A8:  BRA    17EE
017AA:  MOVFF  6E0,6E4
017AE:  MOVF   xDC,W
017B0:  SUBWF  xE4,F
017B2:  BZ    17C0
017B4:  BTFSS  xE3.7
017B6:  BRA    17EE
017B8:  MOVF   FD8,W
017BA:  XORLW  01
017BC:  MOVWF  FD8
017BE:  BRA    17EE
017C0:  MOVFF  6E1,6E4
017C4:  MOVF   xDD,W
017C6:  SUBWF  xE4,F
017C8:  BZ    17D6
017CA:  BTFSS  xE3.7
017CC:  BRA    17EE
017CE:  MOVF   FD8,W
017D0:  XORLW  01
017D2:  MOVWF  FD8
017D4:  BRA    17EE
017D6:  MOVFF  6E2,6E4
017DA:  MOVF   xDE,W
017DC:  SUBWF  xE4,F
017DE:  BZ    17EC
017E0:  BTFSS  xE3.7
017E2:  BRA    17EE
017E4:  MOVF   FD8,W
017E6:  XORLW  01
017E8:  MOVWF  FD8
017EA:  BRA    17EE
017EC:  BCF    FD8.0
017EE:  MOVLB  0
017F0:  RETURN 0
017F2:  MOVLB  6
017F4:  MOVF   xD4,W
017F6:  BTFSC  FD8.2
017F8:  BRA    1944
017FA:  MOVWF  xE0
017FC:  MOVF   xD8,W
017FE:  BTFSC  FD8.2
01800:  BRA    1944
01802:  SUBWF  xE0,F
01804:  BNC   1810
01806:  MOVLW  7F
01808:  ADDWF  xE0,F
0180A:  BTFSC  FD8.0
0180C:  BRA    1944
0180E:  BRA    181C
01810:  MOVLW  81
01812:  SUBWF  xE0,F
01814:  BTFSS  FD8.0
01816:  BRA    1944
01818:  BTFSC  FD8.2
0181A:  BRA    1944
0181C:  MOVFF  6E0,00
01820:  CLRF   01
01822:  CLRF   02
01824:  CLRF   03
01826:  CLRF   xDF
01828:  MOVFF  6D5,6DE
0182C:  BSF    xDE.7
0182E:  MOVFF  6D6,6DD
01832:  MOVFF  6D7,6DC
01836:  MOVLW  19
01838:  MOVWF  xE0
0183A:  MOVF   xDB,W
0183C:  SUBWF  xDC,F
0183E:  BC    185A
01840:  MOVLW  01
01842:  SUBWF  xDD,F
01844:  BC    185A
01846:  SUBWF  xDE,F
01848:  BC    185A
0184A:  SUBWF  xDF,F
0184C:  BC    185A
0184E:  INCF   xDF,F
01850:  INCF   xDE,F
01852:  INCF   xDD,F
01854:  MOVF   xDB,W
01856:  ADDWF  xDC,F
01858:  BRA    18AA
0185A:  MOVF   xDA,W
0185C:  SUBWF  xDD,F
0185E:  BC    1884
01860:  MOVLW  01
01862:  SUBWF  xDE,F
01864:  BC    1884
01866:  SUBWF  xDF,F
01868:  BC    1884
0186A:  INCF   xDF,F
0186C:  INCF   xDE,F
0186E:  MOVF   xDA,W
01870:  ADDWF  xDD,F
01872:  MOVF   xDB,W
01874:  ADDWF  xDC,F
01876:  BNC   18AA
01878:  INCF   xDD,F
0187A:  BNZ   18AA
0187C:  INCF   xDE,F
0187E:  BNZ   18AA
01880:  INCF   xDF,F
01882:  BRA    18AA
01884:  MOVF   xD9,W
01886:  IORLW  80
01888:  SUBWF  xDE,F
0188A:  BC    18A8
0188C:  MOVLW  01
0188E:  SUBWF  xDF,F
01890:  BC    18A8
01892:  INCF   xDF,F
01894:  MOVF   xD9,W
01896:  IORLW  80
01898:  ADDWF  xDE,F
0189A:  MOVF   xDA,W
0189C:  ADDWF  xDD,F
0189E:  BNC   1872
018A0:  INCF   xDE,F
018A2:  BNZ   1872
018A4:  INCF   xDF,F
018A6:  BRA    1872
018A8:  BSF    03.0
018AA:  DECFSZ xE0,F
018AC:  BRA    18B0
018AE:  BRA    18C6
018B0:  BCF    FD8.0
018B2:  RLCF   xDC,F
018B4:  RLCF   xDD,F
018B6:  RLCF   xDE,F
018B8:  RLCF   xDF,F
018BA:  BCF    FD8.0
018BC:  RLCF   03,F
018BE:  RLCF   02,F
018C0:  RLCF   01,F
018C2:  RLCF   xE1,F
018C4:  BRA    183A
018C6:  BTFSS  xE1.0
018C8:  BRA    18D6
018CA:  BCF    FD8.0
018CC:  RRCF   01,F
018CE:  RRCF   02,F
018D0:  RRCF   03,F
018D2:  RRCF   xE1,F
018D4:  BRA    18DA
018D6:  DECF   00,F
018D8:  BZ    1944
018DA:  BTFSC  xE1.7
018DC:  BRA    191A
018DE:  BCF    FD8.0
018E0:  RLCF   xDC,F
018E2:  RLCF   xDD,F
018E4:  RLCF   xDE,F
018E6:  RLCF   xDF,F
018E8:  MOVF   xDB,W
018EA:  SUBWF  xDC,F
018EC:  BC    18FC
018EE:  MOVLW  01
018F0:  SUBWF  xDD,F
018F2:  BC    18FC
018F4:  SUBWF  xDE,F
018F6:  BC    18FC
018F8:  SUBWF  xDF,F
018FA:  BNC   1930
018FC:  MOVF   xDA,W
018FE:  SUBWF  xDD,F
01900:  BC    190C
01902:  MOVLW  01
01904:  SUBWF  xDE,F
01906:  BC    190C
01908:  SUBWF  xDF,F
0190A:  BNC   1930
0190C:  MOVF   xD9,W
0190E:  IORLW  80
01910:  SUBWF  xDE,F
01912:  BC    191A
01914:  MOVLW  01
01916:  SUBWF  xDF,F
01918:  BNC   1930
0191A:  INCF   03,F
0191C:  BNZ   1930
0191E:  INCF   02,F
01920:  BNZ   1930
01922:  INCF   01,F
01924:  BNZ   1930
01926:  INCF   00,F
01928:  BZ    1944
0192A:  RRCF   01,F
0192C:  RRCF   02,F
0192E:  RRCF   03,F
01930:  MOVFF  6D5,6E0
01934:  MOVF   xD9,W
01936:  XORWF  xE0,F
01938:  BTFSS  xE0.7
0193A:  BRA    1940
0193C:  BSF    01.7
0193E:  BRA    194C
01940:  BCF    01.7
01942:  BRA    194C
01944:  CLRF   00
01946:  CLRF   01
01948:  CLRF   02
0194A:  CLRF   03
0194C:  MOVLB  0
0194E:  RETURN 0
*
020FA:  ADDWF  FE8,W
020FC:  CLRF   FF7
020FE:  RLCF   FF7,F
02100:  ADDLW  15
02102:  MOVWF  FF6
02104:  MOVLW  21
02106:  ADDWFC FF7,F
02108:  TBLRD*-
0210A:  MOVF   FF5,W
0210C:  MOVWF  FFA
0210E:  TBLRD*
02110:  MOVF   FF5,W
02112:  MOVWF  FF9
02114:  DATA 02,20
02116:  DATA 1C,20
02118:  DATA 70,20
0211A:  DATA D4,20
0211C:  MOVLW  8E
0211E:  MOVWF  00
02120:  MOVFF  6D2,01
02124:  MOVFF  6D1,02
02128:  CLRF   03
0212A:  BTFSS  01.7
0212C:  BRA    2138
0212E:  COMF   01,F
02130:  COMF   02,F
02132:  INCF   02,F
02134:  BNZ   2138
02136:  INCF   01,F
02138:  MOVF   01,F
0213A:  BNZ   214E
0213C:  MOVFF  02,01
02140:  CLRF   02
02142:  MOVLW  08
02144:  SUBWF  00,F
02146:  MOVF   01,F
02148:  BNZ   214E
0214A:  CLRF   00
0214C:  BRA    216A
0214E:  BCF    FD8.0
02150:  BTFSC  01.7
02152:  BRA    215C
02154:  RLCF   02,F
02156:  RLCF   01,F
02158:  DECF   00,F
0215A:  BRA    214E
0215C:  MOVLB  6
0215E:  BTFSS  xD2.7
02160:  BRA    2166
02162:  MOVLB  0
02164:  BRA    216A
02166:  BCF    01.7
02168:  MOVLB  0
0216A:  RETURN 0
0216C:  MOVLW  8E
0216E:  MOVWF  00
02170:  MOVLB  6
02172:  MOVF   xDB,W
02174:  SUBWF  00,F
02176:  MOVFF  6DC,02
0217A:  MOVFF  6DD,01
0217E:  BSF    02.7
02180:  MOVF   00,F
02182:  BZ    2196
02184:  BCF    FD8.0
02186:  MOVF   02,F
02188:  BNZ   218E
0218A:  MOVF   01,F
0218C:  BZ    2196
0218E:  RRCF   02,F
02190:  RRCF   01,F
02192:  DECFSZ 00,F
02194:  BRA    2184
02196:  BTFSS  xDC.7
02198:  BRA    21A4
0219A:  COMF   01,F
0219C:  COMF   02,F
0219E:  INCF   01,F
021A0:  BTFSC  FD8.2
021A2:  INCF   02,F
021A4:  MOVLB  0
021A6:  RETURN 0
*
0402A:  MOVLB  6
0402C:  MOVF   x9D,W
0402E:  ANDLW  07
04030:  MOVWF  00
04032:  RRCF   x9D,W
04034:  MOVWF  01
04036:  RRCF   01,F
04038:  RRCF   01,F
0403A:  MOVLW  1F
0403C:  ANDWF  01,F
0403E:  MOVF   01,W
04040:  ADDWF  x9E,W
04042:  MOVWF  FE9
04044:  MOVLW  00
04046:  ADDWFC x9F,W
04048:  MOVWF  FEA
0404A:  MOVFF  FEF,01
0404E:  INCF   00,F
04050:  BRA    4054
04052:  RRCF   01,F
04054:  DECFSZ 00,F
04056:  BRA    4052
04058:  MOVLW  01
0405A:  ANDWF  01,F
0405C:  MOVLB  0
0405E:  RETURN 0
*
04A60:  MOVF   FEF,F
04A62:  BZ    4A82
04A64:  MOVFF  FEA,696
04A68:  MOVFF  FE9,695
04A6C:  MOVFF  FEF,6A6
04A70:  RCALL  4A38
04A72:  MOVFF  696,FEA
04A76:  MOVFF  695,FE9
04A7A:  INCF   FE9,F
04A7C:  BTFSC  FD8.2
04A7E:  INCF   FEA,F
04A80:  BRA    4A60
04A82:  RETURN 0
*
04F7C:  TBLRD*+
04F7E:  MOVFF  FF6,69A
04F82:  MOVFF  FF7,69B
04F86:  MOVFF  FF5,6A6
04F8A:  RCALL  4A38
04F8C:  MOVFF  69A,FF6
04F90:  MOVFF  69B,FF7
04F94:  MOVLB  6
04F96:  DECFSZ x99,F
04F98:  BRA    4F9C
04F9A:  BRA    4FA0
04F9C:  MOVLB  0
04F9E:  BRA    4F7C
04FA0:  MOVLB  0
04FA2:  RETURN 0
04FA4:  MOVLB  6
04FA6:  MOVF   xCB,W
04FA8:  CLRF   01
04FAA:  SUBWF  xCA,W
04FAC:  BC    4FB4
04FAE:  MOVFF  6CA,00
04FB2:  BRA    4FCC
04FB4:  CLRF   00
04FB6:  MOVLW  08
04FB8:  MOVWF  xCC
04FBA:  RLCF   xCA,F
04FBC:  RLCF   00,F
04FBE:  MOVF   xCB,W
04FC0:  SUBWF  00,W
04FC2:  BTFSC  FD8.0
04FC4:  MOVWF  00
04FC6:  RLCF   01,F
04FC8:  DECFSZ xCC,F
04FCA:  BRA    4FBA
04FCC:  MOVLB  0
04FCE:  RETURN 0
04FD0:  MOVF   01,W
04FD2:  MOVFF  699,6CA
04FD6:  MOVLW  64
04FD8:  MOVLB  6
04FDA:  MOVWF  xCB
04FDC:  MOVLB  0
04FDE:  RCALL  4FA4
04FE0:  MOVFF  00,699
04FE4:  MOVF   01,W
04FE6:  MOVLW  30
04FE8:  BNZ   4FFA
04FEA:  MOVLB  6
04FEC:  BTFSS  x9A.1
04FEE:  BRA    500E
04FF0:  BTFSC  x9A.3
04FF2:  BRA    500E
04FF4:  BTFSC  x9A.4
04FF6:  MOVLW  20
04FF8:  BRA    5002
04FFA:  MOVLB  6
04FFC:  BCF    x9A.3
04FFE:  BCF    x9A.4
05000:  BSF    x9A.0
05002:  ADDWF  01,F
05004:  MOVFF  01,6A6
05008:  MOVLB  0
0500A:  RCALL  4A38
0500C:  MOVLB  6
0500E:  MOVFF  699,6CA
05012:  MOVLW  0A
05014:  MOVWF  xCB
05016:  MOVLB  0
05018:  RCALL  4FA4
0501A:  MOVFF  00,699
0501E:  MOVF   01,W
05020:  MOVLW  30
05022:  BNZ   5034
05024:  MOVLB  6
05026:  BTFSC  x9A.3
05028:  BRA    503E
0502A:  BTFSS  x9A.0
0502C:  BRA    503E
0502E:  BTFSC  x9A.4
05030:  MOVLW  20
05032:  MOVLB  0
05034:  ADDWF  01,F
05036:  MOVFF  01,6A6
0503A:  RCALL  4A38
0503C:  MOVLB  6
0503E:  MOVLW  30
05040:  ADDWF  x99,F
05042:  MOVFF  699,6A6
05046:  MOVLB  0
05048:  RCALL  4A38
0504A:  RETURN 0
0504C:  MOVLB  6
0504E:  MOVF   xE0,W
05050:  SUBLW  B6
05052:  MOVWF  xE0
05054:  CLRF   03
05056:  MOVFF  6E1,6E4
0505A:  BSF    xE1.7
0505C:  BCF    FD8.0
0505E:  RRCF   xE1,F
05060:  RRCF   xE2,F
05062:  RRCF   xE3,F
05064:  RRCF   03,F
05066:  RRCF   02,F
05068:  RRCF   01,F
0506A:  RRCF   00,F
0506C:  DECFSZ xE0,F
0506E:  BRA    505C
05070:  BTFSS  xE4.7
05072:  BRA    508A
05074:  COMF   00,F
05076:  COMF   01,F
05078:  COMF   02,F
0507A:  COMF   03,F
0507C:  INCF   00,F
0507E:  BTFSC  FD8.2
05080:  INCF   01,F
05082:  BTFSC  FD8.2
05084:  INCF   02,F
05086:  BTFSC  FD8.2
05088:  INCF   03,F
0508A:  MOVLB  0
0508C:  RETURN 0
0508E:  BTFSC  FD8.1
05090:  BRA    509A
05092:  MOVLW  06
05094:  MOVWF  FEA
05096:  MOVLW  E8
05098:  MOVWF  FE9
0509A:  CLRF   00
0509C:  CLRF   01
0509E:  CLRF   02
050A0:  CLRF   03
050A2:  MOVLB  6
050A4:  CLRF   xE8
050A6:  CLRF   xE9
050A8:  CLRF   xEA
050AA:  CLRF   xEB
050AC:  MOVF   xE7,W
050AE:  IORWF  xE6,W
050B0:  IORWF  xE5,W
050B2:  IORWF  xE4,W
050B4:  BZ    510E
050B6:  MOVLW  20
050B8:  MOVWF  xEC
050BA:  BCF    FD8.0
050BC:  RLCF   xE0,F
050BE:  RLCF   xE1,F
050C0:  RLCF   xE2,F
050C2:  RLCF   xE3,F
050C4:  RLCF   xE8,F
050C6:  RLCF   xE9,F
050C8:  RLCF   xEA,F
050CA:  RLCF   xEB,F
050CC:  MOVF   xE7,W
050CE:  SUBWF  xEB,W
050D0:  BNZ   50E2
050D2:  MOVF   xE6,W
050D4:  SUBWF  xEA,W
050D6:  BNZ   50E2
050D8:  MOVF   xE5,W
050DA:  SUBWF  xE9,W
050DC:  BNZ   50E2
050DE:  MOVF   xE4,W
050E0:  SUBWF  xE8,W
050E2:  BNC   5102
050E4:  MOVF   xE4,W
050E6:  SUBWF  xE8,F
050E8:  MOVF   xE5,W
050EA:  BTFSS  FD8.0
050EC:  INCFSZ xE5,W
050EE:  SUBWF  xE9,F
050F0:  MOVF   xE6,W
050F2:  BTFSS  FD8.0
050F4:  INCFSZ xE6,W
050F6:  SUBWF  xEA,F
050F8:  MOVF   xE7,W
050FA:  BTFSS  FD8.0
050FC:  INCFSZ xE7,W
050FE:  SUBWF  xEB,F
05100:  BSF    FD8.0
05102:  RLCF   00,F
05104:  RLCF   01,F
05106:  RLCF   02,F
05108:  RLCF   03,F
0510A:  DECFSZ xEC,F
0510C:  BRA    50BA
0510E:  MOVFF  6E8,FEF
05112:  MOVFF  6E9,FEC
05116:  MOVFF  6EA,FEC
0511A:  MOVFF  6EB,FEC
0511E:  MOVLB  0
05120:  RETURN 0
05122:  MOVF   FE9,W
05124:  MOVLB  6
05126:  MOVWF  x9E
05128:  MOVF   x9D,W
0512A:  MOVWF  xA0
0512C:  BZ    5166
0512E:  MOVFF  69C,6E3
05132:  MOVFF  69B,6E2
05136:  MOVFF  69A,6E1
0513A:  MOVFF  699,6E0
0513E:  CLRF   xE7
05140:  CLRF   xE6
05142:  MOVLW  20
05144:  MOVWF  xE5
05146:  MOVLW  82
05148:  MOVWF  xE4
0514A:  MOVLB  0
0514C:  CALL   0E32
05150:  MOVFF  03,69C
05154:  MOVFF  02,69B
05158:  MOVFF  01,69A
0515C:  MOVFF  00,699
05160:  MOVLB  6
05162:  DECFSZ xA0,F
05164:  BRA    512E
05166:  MOVFF  69C,6E3
0516A:  MOVFF  69B,6E2
0516E:  MOVFF  69A,6E1
05172:  MOVFF  699,6E0
05176:  MOVLB  0
05178:  RCALL  504C
0517A:  MOVFF  03,69C
0517E:  MOVFF  02,69B
05182:  MOVFF  01,69A
05186:  MOVFF  00,699
0518A:  MOVLB  6
0518C:  BTFSS  x9C.7
0518E:  BRA    51AA
05190:  DECF   x9E,F
05192:  BSF    x9E.5
05194:  COMF   x99,F
05196:  COMF   x9A,F
05198:  COMF   x9B,F
0519A:  COMF   x9C,F
0519C:  INCF   x99,F
0519E:  BTFSC  FD8.2
051A0:  INCF   x9A,F
051A2:  BTFSC  FD8.2
051A4:  INCF   x9B,F
051A6:  BTFSC  FD8.2
051A8:  INCF   x9C,F
051AA:  MOVLW  3B
051AC:  MOVWF  xA5
051AE:  MOVLW  9A
051B0:  MOVWF  xA4
051B2:  MOVLW  CA
051B4:  MOVWF  xA3
051B6:  CLRF   xA2
051B8:  MOVLW  0A
051BA:  MOVWF  xA0
051BC:  MOVF   x9D,W
051BE:  BTFSC  FD8.2
051C0:  INCF   x9E,F
051C2:  BSF    FD8.1
051C4:  MOVLW  06
051C6:  MOVWF  FEA
051C8:  MOVLW  99
051CA:  MOVWF  FE9
051CC:  MOVFF  69C,6E3
051D0:  MOVFF  69B,6E2
051D4:  MOVFF  69A,6E1
051D8:  MOVFF  699,6E0
051DC:  MOVFF  6A5,6E7
051E0:  MOVFF  6A4,6E6
051E4:  MOVFF  6A3,6E5
051E8:  MOVFF  6A2,6E4
051EC:  MOVLB  0
051EE:  RCALL  508E
051F0:  MOVF   01,W
051F2:  MOVF   00,F
051F4:  BNZ   521C
051F6:  MOVLB  6
051F8:  INCF   x9D,W
051FA:  SUBWF  xA0,W
051FC:  BTFSS  FD8.2
051FE:  BRA    5204
05200:  MOVLB  0
05202:  BRA    521C
05204:  MOVF   x9E,W
05206:  BZ    5222
05208:  ANDLW  0F
0520A:  SUBWF  xA0,W
0520C:  BZ    5210
0520E:  BC    5298
05210:  BTFSC  x9E.7
05212:  BRA    5298
05214:  BTFSC  x9E.6
05216:  BRA    5222
05218:  MOVLW  20
0521A:  BRA    528A
0521C:  MOVLW  20
0521E:  MOVLB  6
05220:  ANDWF  x9E,F
05222:  BTFSS  x9E.5
05224:  BRA    5244
05226:  BCF    x9E.5
05228:  MOVF   x9D,W
0522A:  BTFSS  FD8.2
0522C:  DECF   x9E,F
0522E:  MOVF   00,W
05230:  MOVWF  x9E
05232:  MOVLW  2D
05234:  MOVWF  xA6
05236:  MOVLB  0
05238:  CALL   4A38
0523C:  MOVLB  6
0523E:  MOVF   x9E,W
05240:  MOVWF  00
05242:  CLRF   x9E
05244:  MOVF   x9D,W
05246:  SUBWF  xA0,W
05248:  BNZ   5264
0524A:  MOVF   00,W
0524C:  MOVWF  x9E
0524E:  MOVLW  2E
05250:  MOVWF  xA6
05252:  MOVLB  0
05254:  CALL   4A38
05258:  MOVLB  6
0525A:  MOVF   x9E,W
0525C:  MOVWF  00
0525E:  MOVLW  20
05260:  ANDWF  x9E,F
05262:  MOVLW  00
05264:  MOVLW  30
05266:  BTFSS  x9E.5
05268:  BRA    528A
0526A:  BCF    x9E.5
0526C:  MOVF   x9D,W
0526E:  BTFSS  FD8.2
05270:  DECF   x9E,F
05272:  MOVF   00,W
05274:  MOVWF  x9E
05276:  MOVLW  2D
05278:  MOVWF  xA6
0527A:  MOVLB  0
0527C:  CALL   4A38
05280:  MOVLB  6
05282:  MOVF   x9E,W
05284:  MOVWF  00
05286:  CLRF   x9E
05288:  MOVLW  30
0528A:  ADDWF  00,F
0528C:  MOVFF  00,6A6
05290:  MOVLB  0
05292:  CALL   4A38
05296:  MOVLB  6
05298:  BCF    FD8.1
0529A:  MOVFF  6A5,6E3
0529E:  MOVFF  6A4,6E2
052A2:  MOVFF  6A3,6E1
052A6:  MOVFF  6A2,6E0
052AA:  CLRF   xE7
052AC:  CLRF   xE6
052AE:  CLRF   xE5
052B0:  MOVLW  0A
052B2:  MOVWF  xE4
052B4:  MOVLB  0
052B6:  RCALL  508E
052B8:  MOVFF  03,6A5
052BC:  MOVFF  02,6A4
052C0:  MOVFF  01,6A3
052C4:  MOVFF  00,6A2
052C8:  MOVLB  6
052CA:  DECFSZ xA0,F
052CC:  BRA    51C2
052CE:  MOVLB  0
052D0:  RETURN 0
052D2:  MOVFF  FEA,69D
052D6:  MOVFF  FE9,69C
052DA:  MOVLB  6
052DC:  SWAPF  x96,W
052DE:  IORLW  F0
052E0:  MOVWF  x98
052E2:  ADDWF  x98,F
052E4:  ADDLW  E2
052E6:  MOVWF  x99
052E8:  ADDLW  32
052EA:  MOVWF  x9B
052EC:  MOVF   x96,W
052EE:  ANDLW  0F
052F0:  ADDWF  x99,F
052F2:  ADDWF  x99,F
052F4:  ADDWF  x9B,F
052F6:  ADDLW  E9
052F8:  MOVWF  x9A
052FA:  ADDWF  x9A,F
052FC:  ADDWF  x9A,F
052FE:  SWAPF  x95,W
05300:  ANDLW  0F
05302:  ADDWF  x9A,F
05304:  ADDWF  x9B,F
05306:  RLCF   x9A,F
05308:  RLCF   x9B,F
0530A:  COMF   x9B,F
0530C:  RLCF   x9B,F
0530E:  MOVF   x95,W
05310:  ANDLW  0F
05312:  ADDWF  x9B,F
05314:  RLCF   x98,F
05316:  MOVLW  07
05318:  MOVWF  x97
0531A:  MOVLW  0A
0531C:  DECF   x9A,F
0531E:  ADDWF  x9B,F
05320:  BNC   531C
05322:  DECF   x99,F
05324:  ADDWF  x9A,F
05326:  BNC   5322
05328:  DECF   x98,F
0532A:  ADDWF  x99,F
0532C:  BNC   5328
0532E:  DECF   x97,F
05330:  ADDWF  x98,F
05332:  BNC   532E
05334:  MOVLW  06
05336:  MOVWF  FEA
05338:  MOVLW  97
0533A:  MOVWF  FE9
0533C:  MOVLW  07
0533E:  ANDWF  x9C,W
05340:  BCF    x9C.6
05342:  ADDWF  FE9,F
05344:  MOVLW  00
05346:  ADDWFC FEA,F
05348:  MOVF   FE9,W
0534A:  SUBLW  9B
0534C:  BNZ   5356
0534E:  MOVF   FEA,W
05350:  SUBLW  06
05352:  BNZ   5356
05354:  BSF    x9C.6
05356:  MOVF   FEF,W
05358:  MOVWF  00
0535A:  BNZ   536C
0535C:  BTFSC  x9C.6
0535E:  BRA    536C
05360:  BTFSC  x9C.4
05362:  BRA    5390
05364:  BTFSC  x9C.3
05366:  BRA    536C
05368:  MOVLW  20
0536A:  BRA    5372
0536C:  BSF    x9C.3
0536E:  BCF    x9C.4
05370:  MOVLW  30
05372:  ADDWF  00,F
05374:  MOVFF  FEA,696
05378:  MOVFF  FE9,695
0537C:  MOVFF  00,6A6
05380:  MOVLB  0
05382:  CALL   4A38
05386:  MOVFF  696,FEA
0538A:  MOVFF  695,FE9
0538E:  MOVLB  6
05390:  MOVF   FEE,W
05392:  BTFSS  x9C.6
05394:  BRA    5348
05396:  MOVLB  0
05398:  RETURN 0
*
054DE:  MOVFF  583,FEA
054E2:  MOVFF  582,FE9
054E6:  MOVFF  6E0,FEF
054EA:  INCF   FE9,F
054EC:  BTFSC  FD8.2
054EE:  INCF   FEA,F
054F0:  CLRF   FEF
054F2:  MOVLB  5
054F4:  INCF   x82,F
054F6:  BTFSC  FD8.2
054F8:  INCF   x83,F
054FA:  MOVLB  0
054FC:  RETURN 0
054FE:  TBLRD*+
05500:  MOVF   FF5,F
05502:  BZ    551C
05504:  MOVFF  FF6,69E
05508:  MOVFF  FF7,69F
0550C:  MOVFF  FF5,6E0
05510:  RCALL  54DE
05512:  MOVFF  69E,FF6
05516:  MOVFF  69F,FF7
0551A:  BRA    54FE
0551C:  RETURN 0
*
05996:  MOVLW  20
05998:  MOVLB  6
0599A:  BTFSS  xC5.4
0599C:  MOVLW  30
0599E:  MOVWF  xC6
059A0:  MOVFF  6C4,00
059A4:  BTFSS  00.7
059A6:  BRA    59B8
059A8:  COMF   00,F
059AA:  INCF   00,F
059AC:  MOVFF  00,6C4
059B0:  MOVLW  2D
059B2:  MOVWF  xC6
059B4:  BSF    xC5.7
059B6:  BSF    xC5.0
059B8:  MOVF   01,W
059BA:  MOVFF  6C4,6CA
059BE:  MOVLW  64
059C0:  MOVWF  xCB
059C2:  MOVLB  0
059C4:  CALL   4FA4
059C8:  MOVFF  00,6C4
059CC:  MOVLW  30
059CE:  ADDWF  01,W
059D0:  MOVLB  6
059D2:  MOVWF  xC7
059D4:  MOVFF  6C4,6CA
059D8:  MOVLW  0A
059DA:  MOVWF  xCB
059DC:  MOVLB  0
059DE:  CALL   4FA4
059E2:  MOVLW  30
059E4:  ADDWF  00,W
059E6:  MOVLB  6
059E8:  MOVWF  xC9
059EA:  MOVLW  30
059EC:  ADDWF  01,W
059EE:  MOVWF  xC8
059F0:  MOVFF  6C6,00
059F4:  MOVLW  30
059F6:  SUBWF  xC7,W
059F8:  BZ    5A02
059FA:  BSF    xC5.1
059FC:  BTFSC  xC5.7
059FE:  BSF    xC5.2
05A00:  BRA    5A26
05A02:  MOVFF  6C6,6C7
05A06:  MOVLW  20
05A08:  MOVWF  xC6
05A0A:  MOVLW  30
05A0C:  SUBWF  xC8,W
05A0E:  BZ    5A18
05A10:  BSF    xC5.0
05A12:  BTFSC  xC5.7
05A14:  BSF    xC5.1
05A16:  BRA    5A26
05A18:  BTFSS  FD8.2
05A1A:  BSF    xC5.0
05A1C:  BNZ   5A26
05A1E:  MOVFF  6C7,6C8
05A22:  MOVLW  20
05A24:  MOVWF  xC7
05A26:  BTFSC  xC5.2
05A28:  BRA    5A34
05A2A:  BTFSC  xC5.1
05A2C:  BRA    5A3C
05A2E:  BTFSC  xC5.0
05A30:  BRA    5A44
05A32:  BRA    5A4C
05A34:  MOVFF  6C6,6E0
05A38:  MOVLB  0
05A3A:  RCALL  54DE
05A3C:  MOVFF  6C7,6E0
05A40:  MOVLB  0
05A42:  RCALL  54DE
05A44:  MOVFF  6C8,6E0
05A48:  MOVLB  0
05A4A:  RCALL  54DE
05A4C:  MOVFF  6C9,6E0
05A50:  MOVLB  0
05A52:  RCALL  54DE
05A54:  RETURN 0
*
05BF2:  MOVLB  6
05BF4:  MOVF   xB2,W
05BF6:  ANDLW  07
05BF8:  MOVWF  00
05BFA:  RRCF   xB2,W
05BFC:  MOVWF  01
05BFE:  RRCF   01,F
05C00:  RRCF   01,F
05C02:  MOVLW  1F
05C04:  ANDWF  01,F
05C06:  MOVF   01,W
05C08:  ADDWF  xB4,W
05C0A:  MOVWF  FE9
05C0C:  MOVLW  00
05C0E:  ADDWFC xB5,W
05C10:  MOVWF  FEA
05C12:  CLRF   01
05C14:  INCF   01,F
05C16:  INCF   00,F
05C18:  BRA    5C1C
05C1A:  RLCF   01,F
05C1C:  DECFSZ 00,F
05C1E:  BRA    5C1A
05C20:  MOVF   xB3,F
05C22:  BZ    5C2A
05C24:  MOVF   01,W
05C26:  IORWF  FEF,F
05C28:  BRA    5C30
05C2A:  COMF   01,F
05C2C:  MOVF   01,W
05C2E:  ANDWF  FEF,F
05C30:  MOVLB  0
05C32:  RETURN 0
*
05DE2:  TBLRD*+
05DE4:  MOVFF  FF6,6A0
05DE8:  MOVFF  FF7,6A1
05DEC:  MOVFF  FF5,6E0
05DF0:  CALL   54DE
05DF4:  MOVFF  6A0,FF6
05DF8:  MOVFF  6A1,FF7
05DFC:  MOVLB  6
05DFE:  DECFSZ x9F,F
05E00:  BRA    5E04
05E02:  BRA    5E08
05E04:  MOVLB  0
05E06:  BRA    5DE2
05E08:  MOVLB  0
05E0A:  RETURN 0
*
061B2:  MOVF   FE9,W
061B4:  MOVLB  6
061B6:  MOVWF  xD8
061B8:  MOVF   xD7,W
061BA:  MOVWF  xDA
061BC:  BZ    61F6
061BE:  MOVFF  6D6,6E3
061C2:  MOVFF  6D5,6E2
061C6:  MOVFF  6D4,6E1
061CA:  MOVFF  6D3,6E0
061CE:  CLRF   xE7
061D0:  CLRF   xE6
061D2:  MOVLW  20
061D4:  MOVWF  xE5
061D6:  MOVLW  82
061D8:  MOVWF  xE4
061DA:  MOVLB  0
061DC:  CALL   0E32
061E0:  MOVFF  03,6D6
061E4:  MOVFF  02,6D5
061E8:  MOVFF  01,6D4
061EC:  MOVFF  00,6D3
061F0:  MOVLB  6
061F2:  DECFSZ xDA,F
061F4:  BRA    61BE
061F6:  MOVFF  6D6,6E3
061FA:  MOVFF  6D5,6E2
061FE:  MOVFF  6D4,6E1
06202:  MOVFF  6D3,6E0
06206:  MOVLB  0
06208:  CALL   504C
0620C:  MOVFF  03,6D6
06210:  MOVFF  02,6D5
06214:  MOVFF  01,6D4
06218:  MOVFF  00,6D3
0621C:  MOVLB  6
0621E:  BTFSS  xD6.7
06220:  BRA    623C
06222:  DECF   xD8,F
06224:  BSF    xD8.5
06226:  COMF   xD3,F
06228:  COMF   xD4,F
0622A:  COMF   xD5,F
0622C:  COMF   xD6,F
0622E:  INCF   xD3,F
06230:  BTFSC  FD8.2
06232:  INCF   xD4,F
06234:  BTFSC  FD8.2
06236:  INCF   xD5,F
06238:  BTFSC  FD8.2
0623A:  INCF   xD6,F
0623C:  MOVLW  3B
0623E:  MOVWF  xDF
06240:  MOVLW  9A
06242:  MOVWF  xDE
06244:  MOVLW  CA
06246:  MOVWF  xDD
06248:  CLRF   xDC
0624A:  MOVLW  0A
0624C:  MOVWF  xDA
0624E:  MOVF   xD7,W
06250:  BTFSC  FD8.2
06252:  INCF   xD8,F
06254:  BSF    FD8.1
06256:  MOVLW  06
06258:  MOVWF  FEA
0625A:  MOVLW  D3
0625C:  MOVWF  FE9
0625E:  MOVFF  6D6,6E3
06262:  MOVFF  6D5,6E2
06266:  MOVFF  6D4,6E1
0626A:  MOVFF  6D3,6E0
0626E:  MOVFF  6DF,6E7
06272:  MOVFF  6DE,6E6
06276:  MOVFF  6DD,6E5
0627A:  MOVFF  6DC,6E4
0627E:  MOVLB  0
06280:  CALL   508E
06284:  MOVF   01,W
06286:  MOVF   00,F
06288:  BNZ   62B0
0628A:  MOVLB  6
0628C:  INCF   xD7,W
0628E:  SUBWF  xDA,W
06290:  BTFSS  FD8.2
06292:  BRA    6298
06294:  MOVLB  0
06296:  BRA    62B0
06298:  MOVF   xD8,W
0629A:  BZ    62B6
0629C:  ANDLW  0F
0629E:  SUBWF  xDA,W
062A0:  BZ    62A4
062A2:  BC    632C
062A4:  BTFSC  xD8.7
062A6:  BRA    632C
062A8:  BTFSC  xD8.6
062AA:  BRA    62B6
062AC:  MOVLW  20
062AE:  BRA    631E
062B0:  MOVLW  20
062B2:  MOVLB  6
062B4:  ANDWF  xD8,F
062B6:  BTFSS  xD8.5
062B8:  BRA    62D8
062BA:  BCF    xD8.5
062BC:  MOVF   xD7,W
062BE:  BTFSS  FD8.2
062C0:  DECF   xD8,F
062C2:  MOVF   00,W
062C4:  MOVWF  xD8
062C6:  MOVLW  2D
062C8:  MOVWF  xE0
062CA:  MOVLB  0
062CC:  CALL   54DE
062D0:  MOVLB  6
062D2:  MOVF   xD8,W
062D4:  MOVWF  00
062D6:  CLRF   xD8
062D8:  MOVF   xD7,W
062DA:  SUBWF  xDA,W
062DC:  BNZ   62F8
062DE:  MOVF   00,W
062E0:  MOVWF  xD8
062E2:  MOVLW  2E
062E4:  MOVWF  xE0
062E6:  MOVLB  0
062E8:  CALL   54DE
062EC:  MOVLB  6
062EE:  MOVF   xD8,W
062F0:  MOVWF  00
062F2:  MOVLW  20
062F4:  ANDWF  xD8,F
062F6:  MOVLW  00
062F8:  MOVLW  30
062FA:  BTFSS  xD8.5
062FC:  BRA    631E
062FE:  BCF    xD8.5
06300:  MOVF   xD7,W
06302:  BTFSS  FD8.2
06304:  DECF   xD8,F
06306:  MOVF   00,W
06308:  MOVWF  xD8
0630A:  MOVLW  2D
0630C:  MOVWF  xE0
0630E:  MOVLB  0
06310:  CALL   54DE
06314:  MOVLB  6
06316:  MOVF   xD8,W
06318:  MOVWF  00
0631A:  CLRF   xD8
0631C:  MOVLW  30
0631E:  ADDWF  00,F
06320:  MOVFF  00,6E0
06324:  MOVLB  0
06326:  CALL   54DE
0632A:  MOVLB  6
0632C:  BCF    FD8.1
0632E:  MOVFF  6DF,6E3
06332:  MOVFF  6DE,6E2
06336:  MOVFF  6DD,6E1
0633A:  MOVFF  6DC,6E0
0633E:  CLRF   xE7
06340:  CLRF   xE6
06342:  CLRF   xE5
06344:  MOVLW  0A
06346:  MOVWF  xE4
06348:  MOVLB  0
0634A:  CALL   508E
0634E:  MOVFF  03,6DF
06352:  MOVFF  02,6DE
06356:  MOVFF  01,6DD
0635A:  MOVFF  00,6DC
0635E:  MOVLB  6
06360:  DECFSZ xDA,F
06362:  BRA    6254
06364:  MOVLB  0
06366:  RETURN 0
*
08DD0:  MOVF   FE9,W
08DD2:  MOVLB  6
08DD4:  MOVWF  xCD
08DD6:  BTFSS  xCC.7
08DD8:  BRA    8DF4
08DDA:  DECF   xCD,F
08DDC:  BSF    xCD.5
08DDE:  COMF   xC9,F
08DE0:  COMF   xCA,F
08DE2:  COMF   xCB,F
08DE4:  COMF   xCC,F
08DE6:  INCF   xC9,F
08DE8:  BTFSC  FD8.2
08DEA:  INCF   xCA,F
08DEC:  BTFSC  FD8.2
08DEE:  INCF   xCB,F
08DF0:  BTFSC  FD8.2
08DF2:  INCF   xCC,F
08DF4:  MOVLW  3B
08DF6:  MOVWF  xD4
08DF8:  MOVLW  9A
08DFA:  MOVWF  xD3
08DFC:  MOVLW  CA
08DFE:  MOVWF  xD2
08E00:  CLRF   xD1
08E02:  MOVLW  0A
08E04:  MOVWF  xCF
08E06:  BSF    FD8.1
08E08:  MOVLW  06
08E0A:  MOVWF  FEA
08E0C:  MOVLW  C9
08E0E:  MOVWF  FE9
08E10:  MOVFF  6CC,6E3
08E14:  MOVFF  6CB,6E2
08E18:  MOVFF  6CA,6E1
08E1C:  MOVFF  6C9,6E0
08E20:  MOVFF  6D4,6E7
08E24:  MOVFF  6D3,6E6
08E28:  MOVFF  6D2,6E5
08E2C:  MOVFF  6D1,6E4
08E30:  MOVLB  0
08E32:  CALL   508E
08E36:  MOVF   01,W
08E38:  MOVF   00,F
08E3A:  BNZ   8E62
08E3C:  MOVLB  6
08E3E:  MOVF   xCF,W
08E40:  XORLW  01
08E42:  BTFSS  FD8.2
08E44:  BRA    8E4A
08E46:  MOVLB  0
08E48:  BRA    8E62
08E4A:  MOVF   xCD,W
08E4C:  BZ    8E68
08E4E:  ANDLW  0F
08E50:  SUBWF  xCF,W
08E52:  BZ    8E56
08E54:  BC    8EB2
08E56:  BTFSC  xCD.7
08E58:  BRA    8EB2
08E5A:  BTFSC  xCD.6
08E5C:  BRA    8E68
08E5E:  MOVLW  20
08E60:  BRA    8EA4
08E62:  MOVLW  20
08E64:  MOVLB  6
08E66:  ANDWF  xCD,F
08E68:  BTFSS  xCD.5
08E6A:  BRA    8E84
08E6C:  BCF    xCD.5
08E6E:  MOVFF  00,6CD
08E72:  MOVLW  2D
08E74:  MOVWF  xE0
08E76:  MOVLB  0
08E78:  CALL   54DE
08E7C:  MOVLB  6
08E7E:  MOVFF  6CD,00
08E82:  CLRF   xCD
08E84:  MOVLW  30
08E86:  BTFSS  xCD.5
08E88:  BRA    8EA4
08E8A:  BCF    xCD.5
08E8C:  MOVFF  00,6CD
08E90:  MOVLW  2D
08E92:  MOVWF  xE0
08E94:  MOVLB  0
08E96:  CALL   54DE
08E9A:  MOVLB  6
08E9C:  MOVFF  6CD,00
08EA0:  CLRF   xCD
08EA2:  MOVLW  30
08EA4:  ADDWF  00,F
08EA6:  MOVFF  00,6E0
08EAA:  MOVLB  0
08EAC:  CALL   54DE
08EB0:  MOVLB  6
08EB2:  BCF    FD8.1
08EB4:  MOVFF  6D4,6E3
08EB8:  MOVFF  6D3,6E2
08EBC:  MOVFF  6D2,6E1
08EC0:  MOVFF  6D1,6E0
08EC4:  CLRF   xE7
08EC6:  CLRF   xE6
08EC8:  CLRF   xE5
08ECA:  MOVLW  0A
08ECC:  MOVWF  xE4
08ECE:  MOVLB  0
08ED0:  CALL   508E
08ED4:  MOVFF  03,6D4
08ED8:  MOVFF  02,6D3
08EDC:  MOVFF  01,6D2
08EE0:  MOVFF  00,6D1
08EE4:  MOVLB  6
08EE6:  DECFSZ xCF,F
08EE8:  BRA    8E06
08EEA:  MOVLB  0
08EEC:  RETURN 0
*
09B30:  MOVF   FEF,F
09B32:  BZ    9B54
09B34:  MOVFF  FEA,696
09B38:  MOVFF  FE9,695
09B3C:  MOVFF  FEF,6E0
09B40:  CALL   54DE
09B44:  MOVFF  696,FEA
09B48:  MOVFF  695,FE9
09B4C:  INCF   FE9,F
09B4E:  BTFSC  FD8.2
09B50:  INCF   FEA,F
09B52:  BRA    9B30
09B54:  GOTO   9BD2 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00430:  MOVLW  06
00432:  MOVWF  FEA
00434:  MOVLW  98
00436:  MOVWF  FE9
00438:  MOVF   FEF,W
0043A:  BZ    0458
0043C:  MOVLW  14
0043E:  MOVWF  01
00440:  CLRF   00
00442:  DECFSZ 00,F
00444:  BRA    0442
00446:  DECFSZ 01,F
00448:  BRA    0440
0044A:  MOVLW  BF
0044C:  MOVWF  00
0044E:  DECFSZ 00,F
00450:  BRA    044E
00452:  BRA    0454
00454:  DECFSZ FEF,F
00456:  BRA    043C
00458:  RETURN 0
*
006F8:  MOVLW  01
006FA:  MOVLB  6
006FC:  SUBWF  x9D,F
006FE:  BNC   0718
00700:  MOVLW  06
00702:  MOVWF  FEA
00704:  MOVLW  9D
00706:  MOVWF  FE9
00708:  MOVF   FEF,W
0070A:  BZ    0718
0070C:  MOVLW  04
0070E:  MOVWF  00
00710:  DECFSZ 00,F
00712:  BRA    0710
00714:  DECFSZ FEF,F
00716:  BRA    070C
00718:  MOVLB  0
0071A:  GOTO   0760 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
0039A:  MOVLW  CF
0039C:  MOVWF  F87
0039E:  CLRF   F82
....................    output_b(portB_reset);
003A0:  MOVLW  C4
003A2:  MOVWF  F88
003A4:  CLRF   F83
....................    output_c(portC_reset);
003A6:  MOVLW  93
003A8:  MOVWF  F89
003AA:  CLRF   F84
....................    output_d(portD_reset);
003AC:  MOVLW  1F
003AE:  MOVWF  F8A
003B0:  CLRF   F85
....................    output_e(portE_reset);
003B2:  BCF    F8B.0
003B4:  BCF    F8B.1
003B6:  BCF    F8B.2
003B8:  BCF    F8B.3
003BA:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003BC:  MOVLB  F
003BE:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003C0:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003C2:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003C4:  SETF   x20
....................    port_e_pullups(portE_pullups);
003C6:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003C8:  MOVLW  40
003CA:  MOVWF  x0C
003CC:  CLRF   x14
003CE:  MOVLW  03
003D0:  MOVWF  x1C
003D2:  MOVLW  0F
003D4:  MOVWF  x21
003D6:  CLRF   x29
003D8:  MOVLB  0
003DA:  GOTO   9FF6 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05466:  MOVFF  6D2,FEA
0546A:  MOVLB  6
0546C:  MOVFF  6D1,FE9
05470:  MOVFF  FEF,6D5
05474:  MOVFF  6D4,FEA
05478:  MOVFF  6D3,FE9
0547C:  MOVF   FEF,W
0547E:  SUBWF  xD5,W
05480:  BNZ   54B0
....................       if (*s1 == '\0')
05482:  MOVFF  6D2,03
05486:  MOVFF  6D1,FE9
0548A:  MOVFF  03,FEA
0548E:  MOVF   FEF,F
05490:  BNZ   5498
....................          return(0);
05492:  MOVLW  00
05494:  MOVWF  01
05496:  BRA    54DA
05498:  MOVFF  6D2,03
0549C:  MOVF   xD1,W
0549E:  INCF   xD1,F
054A0:  BTFSC  FD8.2
054A2:  INCF   xD2,F
054A4:  INCF   xD3,F
054A6:  BTFSC  FD8.2
054A8:  INCF   xD4,F
054AA:  MOVLB  0
054AC:  BRA    5466
054AE:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
054B0:  MOVFF  6D2,03
054B4:  MOVFF  6D1,FE9
054B8:  MOVFF  03,FEA
054BC:  MOVFF  FEF,6D5
054C0:  MOVFF  6D4,03
054C4:  MOVFF  6D3,FE9
054C8:  MOVFF  03,FEA
054CC:  MOVF   FEF,W
054CE:  SUBWF  xD5,W
054D0:  BC    54D6
054D2:  MOVLW  FF
054D4:  BRA    54D8
054D6:  MOVLW  01
054D8:  MOVWF  01
054DA:  MOVLB  0
054DC:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
055F6:  MOVFF  6F8,6FB
....................    for(su=s;0<n;++su,--n)
055FA:  MOVFF  6F7,6FD
055FE:  MOVFF  6F6,6FC
05602:  MOVLB  6
05604:  MOVF   xFA,F
05606:  BNZ   560E
05608:  MOVF   xF9,W
0560A:  SUBLW  00
0560C:  BC    5636
....................       if(*su==uc)
0560E:  MOVFF  6FD,FEA
05612:  MOVFF  6FC,FE9
05616:  MOVF   xFB,W
05618:  SUBWF  FEF,W
0561A:  BNZ   5626
....................       return su;
0561C:  MOVFF  6FC,01
05620:  MOVFF  6FD,02
05624:  BRA    563C
05626:  INCF   xFC,F
05628:  BTFSC  FD8.2
0562A:  INCF   xFD,F
0562C:  MOVF   xF9,W
0562E:  BTFSC  FD8.2
05630:  DECF   xFA,F
05632:  DECF   xF9,F
05634:  BRA    5604
....................    return NULL;
05636:  MOVLW  00
05638:  MOVWF  01
0563A:  MOVWF  02
0563C:  MOVLB  0
0563E:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0542E:  MOVFF  6D2,6D4
05432:  MOVFF  6D1,6D3
05436:  MOVFF  6D4,FEA
0543A:  MOVLB  6
0543C:  MOVFF  6D3,FE9
05440:  MOVF   FEF,F
05442:  BZ    5450
05444:  INCF   xD3,F
05446:  BTFSC  FD8.2
05448:  INCF   xD4,F
0544A:  MOVLB  0
0544C:  BRA    5436
0544E:  MOVLB  6
....................    return(sc - s);
05450:  MOVF   xD1,W
05452:  SUBWF  xD3,W
05454:  MOVWF  00
05456:  MOVF   xD2,W
05458:  SUBWFB xD4,W
0545A:  MOVWF  03
0545C:  MOVFF  00,01
05460:  MOVWF  02
05462:  MOVLB  0
05464:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
068E0:  MOVLB  6
068E2:  CLRF   xAB
068E4:  CLRF   xAA
068E6:  CLRF   xA9
068E8:  MOVLW  7F
068EA:  MOVWF  xA8
068EC:  CLRF   xAF
068EE:  CLRF   xAE
068F0:  CLRF   xAD
068F2:  CLRF   xAC
068F4:  BSF    xB0.0
068F6:  BCF    xB0.1
068F8:  BCF    xB0.2
068FA:  CLRF   xB2
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
068FC:  MOVF   xA4,W
068FE:  IORWF  xA5,W
06900:  BNZ   690C
....................       return 0;
06902:  CLRF   00
06904:  CLRF   01
06906:  CLRF   02
06908:  CLRF   03
0690A:  BRA    6B36
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
0690C:  MOVF   xB2,W
0690E:  INCF   xB2,F
06910:  ADDWF  xA4,W
06912:  MOVWF  FE9
06914:  MOVLW  00
06916:  ADDWFC xA5,W
06918:  MOVWF  FEA
0691A:  MOVFF  FEF,6B1
0691E:  MOVF   xB1,F
06920:  BTFSC  FD8.2
06922:  BRA    6ABA
....................    {
....................       if (skip && !isspace(c))
06924:  BTFSS  xB0.0
06926:  BRA    6946
06928:  MOVF   xB1,W
0692A:  SUBLW  20
0692C:  BZ    6946
....................       {
....................          skip = 0;
0692E:  BCF    xB0.0
....................          if (c == '+')
06930:  MOVF   xB1,W
06932:  SUBLW  2B
06934:  BNZ   693C
....................          {
....................             sign = 0;
06936:  BCF    xB0.1
....................             continue;
06938:  BRA    6AA2
....................          }            
0693A:  BRA    6946
....................          else if (c == '-')
0693C:  MOVF   xB1,W
0693E:  SUBLW  2D
06940:  BNZ   6946
....................          {
....................             sign = 1;
06942:  BSF    xB0.1
....................             continue;
06944:  BRA    6AA2
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06946:  BTFSC  xB0.0
06948:  BRA    6958
0694A:  MOVF   xB1,W
0694C:  SUBLW  2E
0694E:  BNZ   6958
06950:  BTFSC  xB0.2
06952:  BRA    6958
....................          point = 1;
06954:  BSF    xB0.2
06956:  BRA    6AA2
....................       else if (!skip && isdigit(c))
06958:  BTFSC  xB0.0
0695A:  BRA    6A9C
0695C:  MOVF   xB1,W
0695E:  SUBLW  2F
06960:  BTFSC  FD8.0
06962:  BRA    6A9C
06964:  MOVF   xB1,W
06966:  SUBLW  39
06968:  BTFSS  FD8.0
0696A:  BRA    6A9C
....................       {
....................          c -= '0';
0696C:  MOVLW  30
0696E:  SUBWF  xB1,F
....................          if (point)
06970:  BTFSS  xB0.2
06972:  BRA    6A22
....................          {
....................             pow10 = pow10 * 10.0;
06974:  MOVFF  6AB,6E3
06978:  MOVFF  6AA,6E2
0697C:  MOVFF  6A9,6E1
06980:  MOVFF  6A8,6E0
06984:  CLRF   xE7
06986:  CLRF   xE6
06988:  MOVLW  20
0698A:  MOVWF  xE5
0698C:  MOVLW  82
0698E:  MOVWF  xE4
06990:  MOVLB  0
06992:  CALL   0E32
06996:  MOVFF  03,6AB
0699A:  MOVFF  02,6AA
0699E:  MOVFF  01,6A9
069A2:  MOVFF  00,6A8
....................             result += (float)c / pow10;   
069A6:  MOVLB  6
069A8:  CLRF   xE0
069AA:  MOVFF  6B1,6DF
069AE:  MOVLB  0
069B0:  CALL   0DFC
069B4:  MOVFF  03,6B6
069B8:  MOVFF  02,6B5
069BC:  MOVFF  01,6B4
069C0:  MOVFF  00,6B3
069C4:  MOVFF  03,6D7
069C8:  MOVFF  02,6D6
069CC:  MOVFF  01,6D5
069D0:  MOVFF  00,6D4
069D4:  MOVFF  6AB,6DB
069D8:  MOVFF  6AA,6DA
069DC:  MOVFF  6A9,6D9
069E0:  MOVFF  6A8,6D8
069E4:  CALL   17F2
069E8:  BCF    FD8.1
069EA:  MOVFF  6AF,6E2
069EE:  MOVFF  6AE,6E1
069F2:  MOVFF  6AD,6E0
069F6:  MOVFF  6AC,6DF
069FA:  MOVFF  03,6E6
069FE:  MOVFF  02,6E5
06A02:  MOVFF  01,6E4
06A06:  MOVFF  00,6E3
06A0A:  CALL   0F28
06A0E:  MOVFF  03,6AF
06A12:  MOVFF  02,6AE
06A16:  MOVFF  01,6AD
06A1A:  MOVFF  00,6AC
....................          }
06A1E:  BRA    6A98
06A20:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06A22:  CLRF   xE3
06A24:  CLRF   xE2
06A26:  MOVLW  20
06A28:  MOVWF  xE1
06A2A:  MOVLW  82
06A2C:  MOVWF  xE0
06A2E:  MOVFF  6AF,6E7
06A32:  MOVFF  6AE,6E6
06A36:  MOVFF  6AD,6E5
06A3A:  MOVFF  6AC,6E4
06A3E:  MOVLB  0
06A40:  CALL   0E32
06A44:  MOVFF  03,6B6
06A48:  MOVFF  02,6B5
06A4C:  MOVFF  01,6B4
06A50:  MOVFF  00,6B3
06A54:  MOVLB  6
06A56:  CLRF   xE0
06A58:  MOVFF  6B1,6DF
06A5C:  MOVLB  0
06A5E:  CALL   0DFC
06A62:  BCF    FD8.1
06A64:  MOVFF  6B6,6E2
06A68:  MOVFF  6B5,6E1
06A6C:  MOVFF  6B4,6E0
06A70:  MOVFF  6B3,6DF
06A74:  MOVFF  03,6E6
06A78:  MOVFF  02,6E5
06A7C:  MOVFF  01,6E4
06A80:  MOVFF  00,6E3
06A84:  CALL   0F28
06A88:  MOVFF  03,6AF
06A8C:  MOVFF  02,6AE
06A90:  MOVFF  01,6AD
06A94:  MOVFF  00,6AC
....................          }
....................       }
06A98:  BRA    6AA4
06A9A:  MOVLB  6
....................       else if (!skip)
06A9C:  BTFSC  xB0.0
06A9E:  BRA    6AA2
....................          break;
06AA0:  BRA    6ABA
06AA2:  MOVLB  0
06AA4:  MOVLB  6
06AA6:  MOVF   xB2,W
06AA8:  INCF   xB2,F
06AAA:  ADDWF  xA4,W
06AAC:  MOVWF  FE9
06AAE:  MOVLW  00
06AB0:  ADDWFC xA5,W
06AB2:  MOVWF  FEA
06AB4:  MOVFF  FEF,6B1
06AB8:  BRA    691E
....................    }
.................... 
....................    if (sign)
06ABA:  BTFSS  xB0.1
06ABC:  BRA    6AF2
....................       result = -1*result;
06ABE:  CLRF   xE3
06AC0:  CLRF   xE2
06AC2:  MOVLW  80
06AC4:  MOVWF  xE1
06AC6:  MOVLW  7F
06AC8:  MOVWF  xE0
06ACA:  MOVFF  6AF,6E7
06ACE:  MOVFF  6AE,6E6
06AD2:  MOVFF  6AD,6E5
06AD6:  MOVFF  6AC,6E4
06ADA:  MOVLB  0
06ADC:  CALL   0E32
06AE0:  MOVFF  03,6AF
06AE4:  MOVFF  02,6AE
06AE8:  MOVFF  01,6AD
06AEC:  MOVFF  00,6AC
06AF0:  MOVLB  6
....................       
....................    if(endptr)
06AF2:  MOVF   xA6,W
06AF4:  IORWF  xA7,W
06AF6:  BZ    6B26
....................    {
....................       if (ptr) {
06AF8:  MOVF   xB2,F
06AFA:  BZ    6B14
....................          ptr--;
06AFC:  DECF   xB2,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06AFE:  MOVFF  6A7,FEA
06B02:  MOVFF  6A6,FE9
06B06:  MOVF   xB2,W
06B08:  ADDWF  xA4,W
06B0A:  MOVWF  FEF
06B0C:  MOVLW  00
06B0E:  ADDWFC xA5,W
06B10:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06B12:  BRA    6B26
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
06B14:  MOVFF  6A7,FEA
06B18:  MOVFF  6A6,FE9
06B1C:  MOVFF  6A5,FEC
06B20:  MOVF   FED,F
06B22:  MOVFF  6A4,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
06B26:  MOVFF  6AC,00
06B2A:  MOVFF  6AD,01
06B2E:  MOVFF  6AE,02
06B32:  MOVFF  6AF,03
06B36:  MOVLB  0
06B38:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05640:  MOVLB  6
05642:  CLRF   xCF
05644:  CLRF   xCE
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05646:  MOVLW  30
05648:  MOVWF  xD1
0564A:  MOVLW  31
0564C:  MOVWF  xD2
0564E:  MOVLW  32
05650:  MOVWF  xD3
05652:  MOVLW  33
05654:  MOVWF  xD4
05656:  MOVLW  34
05658:  MOVWF  xD5
0565A:  MOVLW  35
0565C:  MOVWF  xD6
0565E:  MOVLW  36
05660:  MOVWF  xD7
05662:  MOVLW  37
05664:  MOVWF  xD8
05666:  MOVLW  38
05668:  MOVWF  xD9
0566A:  MOVLW  39
0566C:  MOVWF  xDA
0566E:  MOVLW  61
05670:  MOVWF  xDB
05672:  MOVLW  62
05674:  MOVWF  xDC
05676:  MOVLW  63
05678:  MOVWF  xDD
0567A:  MOVLW  64
0567C:  MOVWF  xDE
0567E:  MOVLW  65
05680:  MOVWF  xDF
05682:  MOVLW  66
05684:  MOVWF  xE0
05686:  MOVLW  67
05688:  MOVWF  xE1
0568A:  MOVLW  68
0568C:  MOVWF  xE2
0568E:  MOVLW  69
05690:  MOVWF  xE3
05692:  MOVLW  6A
05694:  MOVWF  xE4
05696:  MOVLW  6B
05698:  MOVWF  xE5
0569A:  MOVLW  6C
0569C:  MOVWF  xE6
0569E:  MOVLW  6D
056A0:  MOVWF  xE7
056A2:  MOVLW  6E
056A4:  MOVWF  xE8
056A6:  MOVLW  6F
056A8:  MOVWF  xE9
056AA:  MOVLW  70
056AC:  MOVWF  xEA
056AE:  MOVLW  71
056B0:  MOVWF  xEB
056B2:  MOVLW  73
056B4:  MOVWF  xEC
056B6:  MOVLW  74
056B8:  MOVWF  xED
056BA:  MOVLW  75
056BC:  MOVWF  xEE
056BE:  MOVLW  76
056C0:  MOVWF  xEF
056C2:  MOVLW  77
056C4:  MOVWF  xF0
056C6:  MOVLW  78
056C8:  MOVWF  xF1
056CA:  MOVLW  79
056CC:  MOVWF  xF2
056CE:  MOVLW  7A
056D0:  MOVWF  xF3
056D2:  CLRF   xF4
....................    for(sc=s;isspace(*sc);++sc);
056D4:  MOVFF  6C4,6C9
056D8:  MOVFF  6C3,6C8
056DC:  MOVFF  6C9,FEA
056E0:  MOVFF  6C8,FE9
056E4:  MOVF   FEF,W
056E6:  SUBLW  20
056E8:  BNZ   56F2
056EA:  INCF   xC8,F
056EC:  BTFSC  FD8.2
056EE:  INCF   xC9,F
056F0:  BRA    56DC
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
056F2:  MOVFF  6C9,03
056F6:  MOVFF  6C8,FE9
056FA:  MOVFF  03,FEA
056FE:  MOVF   FEF,W
05700:  SUBLW  2D
05702:  BZ    5712
05704:  MOVFF  6C9,FEA
05708:  MOVFF  6C8,FE9
0570C:  MOVF   FEF,W
0570E:  SUBLW  2B
05710:  BNZ   5724
05712:  MOVFF  6C9,FEA
05716:  MOVF   xC8,W
05718:  INCF   xC8,F
0571A:  BTFSC  FD8.2
0571C:  INCF   xC9,F
0571E:  MOVWF  FE9
05720:  MOVF   FEF,W
05722:  BRA    5726
05724:  MOVLW  2B
05726:  MOVWF  xD0
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05728:  MOVF   xD0,W
0572A:  SUBLW  2D
0572C:  BZ    5742
0572E:  BTFSC  xC7.7
05730:  BRA    5742
05732:  DECFSZ xC7,W
05734:  BRA    5738
05736:  BRA    5742
05738:  BTFSC  xC7.7
0573A:  BRA    5746
0573C:  MOVF   xC7,W
0573E:  SUBLW  24
05740:  BC    5746
....................    goto StrtoulGO;
05742:  BRA    5950
05744:  BRA    583E
.................... 
....................    else if (base)
05746:  MOVF   xC7,F
05748:  BZ    57D6
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
0574A:  MOVF   xC7,W
0574C:  SUBLW  10
0574E:  BNZ   578A
05750:  MOVFF  6C9,FEA
05754:  MOVFF  6C8,FE9
05758:  MOVF   FEF,W
0575A:  SUBLW  30
0575C:  BNZ   578A
0575E:  MOVLW  01
05760:  ADDWF  xC8,W
05762:  MOVWF  FE9
05764:  MOVLW  00
05766:  ADDWFC xC9,W
05768:  MOVWF  FEA
0576A:  MOVF   FEF,W
0576C:  SUBLW  78
0576E:  BZ    5782
05770:  MOVLW  01
05772:  ADDWF  xC8,W
05774:  MOVWF  FE9
05776:  MOVLW  00
05778:  ADDWFC xC9,W
0577A:  MOVWF  FEA
0577C:  MOVF   FEF,W
0577E:  SUBLW  58
05780:  BNZ   578A
....................          sc+=2;
05782:  MOVLW  02
05784:  ADDWF  xC8,F
05786:  MOVLW  00
05788:  ADDWFC xC9,F
....................       if(base==8 && *sc =='0')
0578A:  MOVF   xC7,W
0578C:  SUBLW  08
0578E:  BNZ   57A6
05790:  MOVFF  6C9,FEA
05794:  MOVFF  6C8,FE9
05798:  MOVF   FEF,W
0579A:  SUBLW  30
0579C:  BNZ   57A6
....................          sc+=1;
0579E:  MOVLW  01
057A0:  ADDWF  xC8,F
057A2:  MOVLW  00
057A4:  ADDWFC xC9,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
057A6:  MOVF   xC7,W
057A8:  SUBLW  02
057AA:  BNZ   57D4
057AC:  MOVFF  6C9,FEA
057B0:  MOVFF  6C8,FE9
057B4:  MOVF   FEF,W
057B6:  SUBLW  30
057B8:  BNZ   57D4
057BA:  MOVLW  01
057BC:  ADDWF  xC8,W
057BE:  MOVWF  FE9
057C0:  MOVLW  00
057C2:  ADDWFC xC9,W
057C4:  MOVWF  FEA
057C6:  MOVF   FEF,W
057C8:  SUBLW  62
057CA:  BNZ   57D4
....................          sc+=2;
057CC:  MOVLW  02
057CE:  ADDWF  xC8,F
057D0:  MOVLW  00
057D2:  ADDWFC xC9,F
.................... 
....................    }
057D4:  BRA    583E
....................    else if(*sc!='0') // base is 0, find base
057D6:  MOVFF  6C9,FEA
057DA:  MOVFF  6C8,FE9
057DE:  MOVF   FEF,W
057E0:  SUBLW  30
057E2:  BZ    57EA
....................       base=10;
057E4:  MOVLW  0A
057E6:  MOVWF  xC7
057E8:  BRA    583E
....................    else if (sc[1]=='x' || sc[1]=='X')
057EA:  MOVLW  01
057EC:  ADDWF  xC8,W
057EE:  MOVWF  FE9
057F0:  MOVLW  00
057F2:  ADDWFC xC9,W
057F4:  MOVWF  FEA
057F6:  MOVF   FEF,W
057F8:  SUBLW  78
057FA:  BZ    580E
057FC:  MOVLW  01
057FE:  ADDWF  xC8,W
05800:  MOVWF  FE9
05802:  MOVLW  00
05804:  ADDWFC xC9,W
05806:  MOVWF  FEA
05808:  MOVF   FEF,W
0580A:  SUBLW  58
0580C:  BNZ   581C
....................       base =16,sc+=2;
0580E:  MOVLW  10
05810:  MOVWF  xC7
05812:  MOVLW  02
05814:  ADDWF  xC8,F
05816:  MOVLW  00
05818:  ADDWFC xC9,F
0581A:  BRA    583E
....................    else if(sc[1]=='b')
0581C:  MOVLW  01
0581E:  ADDWF  xC8,W
05820:  MOVWF  FE9
05822:  MOVLW  00
05824:  ADDWFC xC9,W
05826:  MOVWF  FEA
05828:  MOVF   FEF,W
0582A:  SUBLW  62
0582C:  BNZ   583A
....................       base=2,sc+=2;
0582E:  MOVLW  02
05830:  MOVWF  xC7
05832:  ADDWF  xC8,F
05834:  MOVLW  00
05836:  ADDWFC xC9,F
05838:  BRA    583E
....................    else
....................       base=8;
0583A:  MOVLW  08
0583C:  MOVWF  xC7
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0583E:  MOVFF  6C9,6CB
05842:  MOVFF  6C8,6CA
05846:  MOVFF  6C9,FEA
0584A:  MOVFF  6C8,FE9
0584E:  MOVF   FEF,W
05850:  SUBLW  30
05852:  BNZ   585C
05854:  INCF   xC8,F
05856:  BTFSC  FD8.2
05858:  INCF   xC9,F
0585A:  BRA    5846
....................    sd=memchr(digits,tolower(*sc),base);
0585C:  MOVFF  6C9,03
05860:  MOVFF  6C8,FE9
05864:  MOVFF  03,FEA
05868:  MOVFF  FEF,6F5
0586C:  MOVF   xF5,W
0586E:  SUBLW  40
05870:  BC    587E
05872:  MOVF   xF5,W
05874:  SUBLW  5A
05876:  BNC   587E
05878:  MOVF   xF5,W
0587A:  IORLW  20
0587C:  BRA    5880
0587E:  MOVF   xF5,W
05880:  MOVWF  xF5
05882:  MOVLW  06
05884:  MOVWF  xF7
05886:  MOVLW  D1
05888:  MOVWF  xF6
0588A:  MOVFF  6F5,6F8
0588E:  CLRF   xFA
05890:  MOVFF  6C7,6F9
05894:  BTFSC  xF9.7
05896:  DECF   xFA,F
05898:  MOVLB  0
0589A:  RCALL  55F6
0589C:  MOVFF  02,6CD
058A0:  MOVFF  01,6CC
....................    for(; sd!=0; )
058A4:  MOVLB  6
058A6:  MOVF   xCC,F
058A8:  BNZ   58AE
058AA:  MOVF   xCD,F
058AC:  BZ    5944
....................    {
....................       x=x*base+(int16)(sd-digits);
058AE:  CLRF   03
058B0:  MOVF   xC7,W
058B2:  MOVWF  00
058B4:  BTFSC  FE8.7
058B6:  DECF   03,F
058B8:  MOVWF  xF5
058BA:  MOVFF  03,6F6
058BE:  MOVFF  6CF,6F8
058C2:  MOVFF  6CE,6F7
058C6:  MOVFF  03,6FA
058CA:  MOVWF  xF9
058CC:  MOVLB  0
058CE:  CALL   0860
058D2:  MOVFF  01,6F5
058D6:  MOVLW  D1
058D8:  MOVLB  6
058DA:  SUBWF  xCC,W
058DC:  MOVWF  00
058DE:  MOVLW  06
058E0:  SUBWFB xCD,W
058E2:  MOVWF  03
058E4:  MOVF   00,W
058E6:  ADDWF  01,W
058E8:  MOVWF  01
058EA:  MOVF   02,W
058EC:  ADDWFC 03,F
058EE:  MOVFF  01,6CE
058F2:  MOVFF  03,6CF
....................       ++sc;
058F6:  INCF   xC8,F
058F8:  BTFSC  FD8.2
058FA:  INCF   xC9,F
....................       sd=memchr(digits,tolower(*sc),base);
058FC:  MOVFF  6C9,FEA
05900:  MOVFF  6C8,FE9
05904:  MOVFF  FEF,6F5
05908:  MOVF   xF5,W
0590A:  SUBLW  40
0590C:  BC    591A
0590E:  MOVF   xF5,W
05910:  SUBLW  5A
05912:  BNC   591A
05914:  MOVF   xF5,W
05916:  IORLW  20
05918:  BRA    591C
0591A:  MOVF   xF5,W
0591C:  MOVWF  xF5
0591E:  MOVLW  06
05920:  MOVWF  xF7
05922:  MOVLW  D1
05924:  MOVWF  xF6
05926:  MOVFF  6F5,6F8
0592A:  CLRF   xFA
0592C:  MOVFF  6C7,6F9
05930:  BTFSC  xF9.7
05932:  DECF   xFA,F
05934:  MOVLB  0
05936:  RCALL  55F6
05938:  MOVFF  02,6CD
0593C:  MOVFF  01,6CC
05940:  BRA    58A4
05942:  MOVLB  6
....................    }
....................    if(s1==sc)
05944:  MOVF   xC8,W
05946:  SUBWF  xCA,W
05948:  BNZ   5972
0594A:  MOVF   xC9,W
0594C:  SUBWF  xCB,W
0594E:  BNZ   5972
....................    {
....................    StrtoulGO:
....................       if (endptr)
05950:  MOVLB  6
05952:  MOVF   xC5,W
05954:  IORWF  xC6,W
05956:  BZ    596A
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05958:  MOVFF  6C6,FEA
0595C:  MOVFF  6C5,FE9
05960:  MOVFF  6C4,FEC
05964:  MOVF   FED,F
05966:  MOVFF  6C3,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
0596A:  MOVLW  00
0596C:  MOVWF  01
0596E:  MOVWF  02
05970:  BRA    5992
....................    }
....................    if (endptr)
05972:  MOVF   xC5,W
05974:  IORWF  xC6,W
05976:  BZ    598A
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05978:  MOVFF  6C6,FEA
0597C:  MOVFF  6C5,FE9
05980:  MOVFF  6C9,FEC
05984:  MOVF   FED,F
05986:  MOVFF  6C8,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
0598A:  MOVFF  6CE,01
0598E:  MOVFF  6CF,02
05992:  MOVLB  0
05994:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0045A:  MOVLB  6
0045C:  CLRF   x95
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0045E:  CLRF   x95
00460:  MOVF   x94,W
00462:  SUBWF  x95,W
00464:  BC    04BC
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00466:  MOVF   x95,W
00468:  ADDWF  x92,W
0046A:  MOVWF  x96
0046C:  MOVLW  00
0046E:  ADDWFC x93,W
00470:  MOVWF  x97
00472:  MOVF   x95,W
00474:  ADDWF  x90,W
00476:  MOVWF  01
00478:  MOVLW  00
0047A:  ADDWFC x91,W
0047C:  MOVWF  03
0047E:  MOVF   01,W
00480:  MOVWF  FE9
00482:  MOVFF  03,FEA
00486:  MOVFF  FEF,698
0048A:  BSF    F7F.7
0048C:  MOVF   FF2,W
0048E:  MOVWF  00
00490:  BCF    FF2.7
00492:  MOVFF  697,F7A
00496:  MOVFF  696,F79
0049A:  MOVLW  31
0049C:  MOVWF  F7B
0049E:  MOVFF  698,F7C
004A2:  MOVLB  F
004A4:  MOVLW  55
004A6:  MOVWF  F81
004A8:  MOVLW  AA
004AA:  MOVWF  F81
004AC:  BSF    F80.4
004AE:  BTFSC  F80.4
004B0:  BRA    04AE
004B2:  MOVF   00,W
004B4:  IORWF  FF2,F
004B6:  MOVLB  6
004B8:  INCF   x95,F
004BA:  BRA    0460
....................    }
004BC:  MOVLB  0
004BE:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003DE:  MOVLB  6
003E0:  CLRF   x95
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003E2:  CLRF   x95
003E4:  MOVF   x94,W
003E6:  SUBWF  x95,W
003E8:  BC    042C
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003EA:  MOVF   x95,W
003EC:  ADDWF  x90,W
003EE:  MOVWF  01
003F0:  MOVLW  00
003F2:  ADDWFC x91,W
003F4:  MOVWF  03
003F6:  MOVF   01,W
003F8:  MOVWF  FE9
003FA:  MOVFF  03,FEA
003FE:  MOVF   x95,W
00400:  ADDWF  x92,W
00402:  MOVWF  x98
00404:  MOVLW  00
00406:  ADDWFC x93,W
00408:  MOVWF  x99
0040A:  BSF    F7F.7
0040C:  MOVFF  FF2,69A
00410:  BCF    FF2.7
00412:  MOVFF  699,F7A
00416:  MOVFF  698,F79
0041A:  MOVLW  31
0041C:  MOVWF  F7B
0041E:  BSF    F80.0
00420:  MOVF   F7C,W
00422:  BTFSC  x9A.7
00424:  BSF    FF2.7
00426:  MOVWF  FEF
00428:  INCF   x95,F
0042A:  BRA    03E4
....................    }
0042C:  MOVLB  0
0042E:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004C0:  MOVLB  6
004C2:  CLRF   x91
004C4:  MOVLW  20
004C6:  MOVWF  x90
004C8:  CLRF   x93
004CA:  CLRF   x92
004CC:  MOVLW  80
004CE:  MOVWF  x94
004D0:  MOVLB  0
004D2:  RCALL  045A
....................    delay_ms(1);
004D4:  MOVLW  01
004D6:  MOVLB  6
004D8:  MOVWF  x98
004DA:  MOVLB  0
004DC:  RCALL  0430
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004DE:  MOVLB  6
004E0:  CLRF   x91
004E2:  MOVLW  60
004E4:  MOVWF  x90
004E6:  CLRF   x93
004E8:  MOVLW  80
004EA:  MOVWF  x92
004EC:  MOVLW  02
004EE:  MOVWF  x94
004F0:  MOVLB  0
004F2:  RCALL  045A
....................    delay_ms(1);
004F4:  MOVLW  01
004F6:  MOVLB  6
004F8:  MOVWF  x98
004FA:  MOVLB  0
004FC:  RCALL  0430
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004FE:  MOVLB  6
00500:  CLRF   x91
00502:  MOVLW  61
00504:  MOVWF  x90
00506:  CLRF   x93
00508:  MOVLW  90
0050A:  MOVWF  x92
0050C:  MOVLW  02
0050E:  MOVWF  x94
00510:  MOVLB  0
00512:  RCALL  045A
....................    delay_ms(1);
00514:  MOVLW  01
00516:  MOVLB  6
00518:  MOVWF  x98
0051A:  MOVLB  0
0051C:  RCALL  0430
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0051E:  MOVLB  6
00520:  CLRF   x91
00522:  MOVLW  62
00524:  MOVWF  x90
00526:  CLRF   x93
00528:  MOVLW  A0
0052A:  MOVWF  x92
0052C:  MOVLW  20
0052E:  MOVWF  x94
00530:  MOVLB  0
00532:  RCALL  045A
....................    delay_ms(1);
00534:  MOVLW  01
00536:  MOVLB  6
00538:  MOVWF  x98
0053A:  MOVLB  0
0053C:  RCALL  0430
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
0053E:  MOVLB  6
00540:  CLRF   x91
00542:  MOVLW  82
00544:  MOVWF  x90
00546:  CLRF   x93
00548:  MOVLW  C0
0054A:  MOVWF  x92
0054C:  MOVLW  30
0054E:  MOVWF  x94
00550:  MOVLB  0
00552:  RCALL  045A
....................    delay_ms(1);
00554:  MOVLW  01
00556:  MOVLB  6
00558:  MOVWF  x98
0055A:  MOVLB  0
0055C:  RCALL  0430
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0055E:  MOVLB  6
00560:  CLRF   x91
00562:  MOVLW  B2
00564:  MOVWF  x90
00566:  CLRF   x93
00568:  MOVLW  F0
0056A:  MOVWF  x92
0056C:  MOVLW  38
0056E:  MOVWF  x94
00570:  MOVLB  0
00572:  RCALL  045A
....................    delay_ms(1);
00574:  MOVLW  01
00576:  MOVLB  6
00578:  MOVWF  x98
0057A:  MOVLB  0
0057C:  RCALL  0430
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0057E:  MOVLB  6
00580:  CLRF   x91
00582:  MOVLW  F2
00584:  MOVWF  x90
00586:  MOVLW  01
00588:  MOVWF  x93
0058A:  MOVLW  40
0058C:  MOVWF  x92
0058E:  MOVLW  01
00590:  MOVWF  x94
00592:  MOVLB  0
00594:  RCALL  045A
....................    delay_ms(1);
00596:  MOVLW  01
00598:  MOVLB  6
0059A:  MOVWF  x98
0059C:  MOVLB  0
0059E:  RCALL  0430
005A0:  GOTO   0670 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005A4:  MOVLB  6
005A6:  CLRF   x91
005A8:  MOVLW  20
005AA:  MOVWF  x90
005AC:  CLRF   x93
005AE:  CLRF   x92
005B0:  MOVLW  80
005B2:  MOVWF  x94
005B4:  MOVLB  0
005B6:  RCALL  03DE
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005B8:  MOVLB  6
005BA:  CLRF   x91
005BC:  MOVLW  60
005BE:  MOVWF  x90
005C0:  CLRF   x93
005C2:  MOVLW  80
005C4:  MOVWF  x92
005C6:  MOVLW  02
005C8:  MOVWF  x94
005CA:  MOVLB  0
005CC:  RCALL  03DE
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005CE:  MOVLB  6
005D0:  CLRF   x91
005D2:  MOVLW  61
005D4:  MOVWF  x90
005D6:  CLRF   x93
005D8:  MOVLW  90
005DA:  MOVWF  x92
005DC:  MOVLW  02
005DE:  MOVWF  x94
005E0:  MOVLB  0
005E2:  RCALL  03DE
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005E4:  MOVLB  6
005E6:  CLRF   x91
005E8:  MOVLW  62
005EA:  MOVWF  x90
005EC:  CLRF   x93
005EE:  MOVLW  A0
005F0:  MOVWF  x92
005F2:  MOVLW  20
005F4:  MOVWF  x94
005F6:  MOVLB  0
005F8:  RCALL  03DE
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005FA:  MOVLB  6
005FC:  CLRF   x91
005FE:  MOVLW  82
00600:  MOVWF  x90
00602:  CLRF   x93
00604:  MOVLW  C0
00606:  MOVWF  x92
00608:  MOVLW  30
0060A:  MOVWF  x94
0060C:  MOVLB  0
0060E:  RCALL  03DE
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00610:  MOVLB  6
00612:  CLRF   x91
00614:  MOVLW  B2
00616:  MOVWF  x90
00618:  CLRF   x93
0061A:  MOVLW  F0
0061C:  MOVWF  x92
0061E:  MOVLW  38
00620:  MOVWF  x94
00622:  MOVLB  0
00624:  RCALL  03DE
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00626:  MOVLB  6
00628:  CLRF   x91
0062A:  MOVLW  F2
0062C:  MOVWF  x90
0062E:  MOVLW  01
00630:  MOVWF  x93
00632:  MOVLW  40
00634:  MOVWF  x92
00636:  MOVLW  01
00638:  MOVWF  x94
0063A:  MOVLB  0
0063C:  RCALL  03DE
0063E:  GOTO   0674 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00642:  MOVLB  6
00644:  CLRF   x91
00646:  MOVLW  F2
00648:  MOVWF  x90
0064A:  MOVLW  01
0064C:  MOVWF  x93
0064E:  MOVLW  40
00650:  MOVWF  x92
00652:  MOVLW  01
00654:  MOVWF  x94
00656:  MOVLB  0
00658:  RCALL  03DE
....................    delay_ms(1);
0065A:  MOVLW  01
0065C:  MOVLB  6
0065E:  MOVWF  x98
00660:  MOVLB  0
00662:  RCALL  0430
....................    if (paramsValid != isValid)
00664:  MOVF   xF2,W
00666:  SUBLW  AA
00668:  BZ    0672
....................    {
....................       paramsValid = isValid;
0066A:  MOVLW  AA
0066C:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
0066E:  BRA    04C0
....................    }
00670:  BRA    0674
....................    else
....................    {
....................       params_load_from_ee();
00672:  BRA    05A4
....................    }
00674:  GOTO   9FFA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00678:  RCALL  0136
....................    switch(ch)
0067A:  MOVLB  6
0067C:  MOVF   xA2,W
0067E:  ADDLW  FC
00680:  BC    06B4
00682:  ADDLW  04
00684:  MOVLB  0
00686:  GOTO   06C0
....................    {
....................       case 0:
....................          output_low(_CS0);
0068A:  MOVLW  1F
0068C:  MOVWF  F8A
0068E:  BCF    F85.5
....................       break; 
00690:  MOVLB  6
00692:  BRA    06B4
....................       case 1:
....................          output_low(_CS1);
00694:  MOVLW  1F
00696:  MOVWF  F8A
00698:  BCF    F85.6
....................       break;   
0069A:  MOVLB  6
0069C:  BRA    06B4
....................       case 2:
....................          output_low(_CS2);
0069E:  MOVLW  1F
006A0:  MOVWF  F8A
006A2:  BCF    F85.7
....................       break;
006A4:  MOVLB  6
006A6:  BRA    06B4
....................       case 3:
....................          output_low(_CS3);
006A8:  MOVLW  C4
006AA:  MOVWF  F88
006AC:  BCF    F83.0
....................       break;              
006AE:  MOVLB  6
006B0:  BRA    06B4
006B2:  MOVLB  6
....................    }
....................    delay_us(10);
006B4:  MOVLW  35
006B6:  MOVWF  00
006B8:  DECFSZ 00,F
006BA:  BRA    06B8
006BC:  MOVLB  0
006BE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  7
00158:  MOVF   x03,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007AE:  MOVLW  1F
007B0:  MOVWF  F8A
007B2:  BCF    F85.5
....................    output_low(_CS1);
007B4:  MOVWF  F8A
007B6:  BCF    F85.6
....................    output_low(_CS2);
007B8:  MOVWF  F8A
007BA:  BCF    F85.7
....................    output_low(_CS3);
007BC:  MOVLW  C4
007BE:  MOVWF  F88
007C0:  BCF    F83.0
....................    delay_us(10);
007C2:  MOVLW  35
007C4:  MOVWF  00
007C6:  DECFSZ 00,F
007C8:  BRA    07C6
007CA:  GOTO   07D0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006E2:  MOVFF  6A0,6A2
006E6:  RCALL  0678
....................    spi_write2(command);
006E8:  MOVLB  E
006EA:  MOVF   x8D,W
006EC:  MOVFF  6A1,E8D
006F0:  RRCF   x90,W
006F2:  BNC   06F0
006F4:  MOVLB  0
006F6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
00188:  MOVFF  701,703
0018C:  RCALL  0154
....................    spi_write2(command);
0018E:  MOVLB  E
00190:  MOVF   x8D,W
00192:  MOVFF  702,E8D
00196:  RRCF   x90,W
00198:  BNC   0196
0019A:  MOVLB  0
0019C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007CE:  BRA    07AE
....................    spi_write2(command);
007D0:  MOVLB  E
007D2:  MOVF   x8D,W
007D4:  MOVFF  697,E8D
007D8:  RRCF   x90,W
007DA:  BNC   07D8
007DC:  MOVLB  0
007DE:  GOTO   07EC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
007FA:  MOVFF  69F,6A2
007FE:  RCALL  0678
....................    spi_read2(command);
00800:  MOVLB  E
00802:  MOVF   x8D,W
00804:  MOVFF  6A0,E8D
00808:  RRCF   x90,W
0080A:  BNC   0808
0080C:  MOVLB  0
0080E:  GOTO   0820 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
0071E:  MOVLB  6
00720:  MOVF   x9D,W
00722:  IORLW  40
00724:  MOVWF  x9F
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00726:  MOVFF  69C,6A0
0072A:  MOVFF  69F,6A1
0072E:  MOVLB  0
00730:  RCALL  06E2
....................    spi_write2(data);
00732:  MOVLB  E
00734:  MOVF   x8D,W
00736:  MOVFF  69E,E8D
0073A:  RRCF   x90,W
0073C:  BNC   073A
....................    ads_deselect_all();
0073E:  MOVLB  0
00740:  RCALL  0136
00742:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
0019E:  MOVFF  6FF,701
001A2:  MOVLW  08
001A4:  MOVLB  7
001A6:  MOVWF  x02
001A8:  MOVLB  0
001AA:  RCALL  0188
....................    delay_us(10);
001AC:  MOVLW  35
001AE:  MOVWF  00
001B0:  DECFSZ 00,F
001B2:  BRA    01B0
....................    ads_deselect_all();
001B4:  RCALL  0136
001B6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007E2:  MOVLW  08
007E4:  MOVLB  6
007E6:  MOVWF  x97
007E8:  MOVLB  0
007EA:  BRA    07CE
....................    delay_us(10);
007EC:  MOVLW  35
007EE:  MOVWF  00
007F0:  DECFSZ 00,F
007F2:  BRA    07F0
....................    ads_deselect_all();
007F4:  RCALL  0136
007F6:  GOTO   09DA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00812:  MOVFF  69A,69F
00816:  MOVLW  10
00818:  MOVLB  6
0081A:  MOVWF  xA0
0081C:  MOVLB  0
0081E:  BRA    07FA
....................    data.dBytes[0] = 0;
00820:  MOVLB  6
00822:  CLRF   x9B
....................    data.dBytes[3] = spi_read2(0);
00824:  MOVLB  E
00826:  MOVF   x8D,W
00828:  CLRF   x8D
0082A:  RRCF   x90,W
0082C:  BNC   082A
0082E:  MOVFF  E8D,69E
....................    data.dBytes[2] = spi_read2(0);
00832:  MOVF   x8D,W
00834:  CLRF   x8D
00836:  RRCF   x90,W
00838:  BNC   0836
0083A:  MOVFF  E8D,69D
....................    data.dBytes[1] = spi_read2(0);
0083E:  MOVF   x8D,W
00840:  CLRF   x8D
00842:  RRCF   x90,W
00844:  BNC   0842
00846:  MOVFF  E8D,69C
....................    
....................    ads_deselect_all();
0084A:  MOVLB  0
0084C:  RCALL  0136
....................    return data.dWord;
0084E:  MOVFF  69B,00
00852:  MOVFF  69C,01
00856:  MOVFF  69D,02
0085A:  MOVFF  69E,03
0085E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00744:  MOVFF  697,6A0
00748:  MOVLW  06
0074A:  MOVLB  6
0074C:  MOVWF  xA1
0074E:  MOVLB  0
00750:  RCALL  06E2
....................    delay_us(300);                    
00752:  MOVLW  02
00754:  MOVLB  6
00756:  MOVWF  x9C
00758:  MOVLW  96
0075A:  MOVWF  x9D
0075C:  MOVLB  0
0075E:  BRA    06F8
00760:  MOVLB  6
00762:  DECFSZ x9C,F
00764:  BRA    0758
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00766:  MOVFF  697,69C
0076A:  CLRF   x9D
0076C:  MOVFF  698,69E
00770:  MOVLB  0
00772:  RCALL  071E
....................    ads_write_reg(ch, reg1, rc1);
00774:  MOVFF  697,69C
00778:  MOVLW  04
0077A:  MOVLB  6
0077C:  MOVWF  x9D
0077E:  MOVFF  699,69E
00782:  MOVLB  0
00784:  RCALL  071E
....................    ads_write_reg(ch, reg2, rc2);
00786:  MOVFF  697,69C
0078A:  MOVLW  08
0078C:  MOVLB  6
0078E:  MOVWF  x9D
00790:  MOVFF  69A,69E
00794:  MOVLB  0
00796:  RCALL  071E
....................    ads_write_reg(ch, reg3, rc3);  
00798:  MOVFF  697,69C
0079C:  MOVLW  0C
0079E:  MOVLB  6
007A0:  MOVWF  x9D
007A2:  MOVFF  69B,69E
007A6:  MOVLB  0
007A8:  RCALL  071E
007AA:  GOTO   09BC (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
021A8:  MOVLB  6
021AA:  BCF    xDA.0
....................    y = x;
021AC:  MOVFF  6CE,6D3
021B0:  MOVFF  6CD,6D2
021B4:  MOVFF  6CC,6D1
021B8:  MOVFF  6CB,6D0
.................... 
....................    if (x < 0)
021BC:  MOVFF  6CE,6DE
021C0:  MOVFF  6CD,6DD
021C4:  MOVFF  6CC,6DC
021C8:  MOVFF  6CB,6DB
021CC:  CLRF   xE2
021CE:  CLRF   xE1
021D0:  CLRF   xE0
021D2:  CLRF   xDF
021D4:  MOVLB  0
021D6:  CALL   1778
021DA:  BNC   21E8
....................    {
....................       s = 1;
021DC:  MOVLB  6
021DE:  BSF    xDA.0
....................       y = -y;
021E0:  MOVF   xD1,W
021E2:  XORLW  80
021E4:  MOVWF  xD1
021E6:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
021E8:  MOVFF  6D3,6DE
021EC:  MOVFF  6D2,6DD
021F0:  MOVFF  6D1,6DC
021F4:  MOVFF  6D0,6DB
021F8:  MOVLB  6
021FA:  CLRF   xE2
021FC:  CLRF   xE1
021FE:  CLRF   xE0
02200:  MOVLW  8E
02202:  MOVWF  xDF
02204:  MOVLB  0
02206:  CALL   1778
0220A:  BC    220E
0220C:  BNZ   223E
....................       res = (float32)(unsigned int16)y;
0220E:  MOVFF  6D3,6DE
02212:  MOVFF  6D2,6DD
02216:  MOVFF  6D1,6DC
0221A:  MOVFF  6D0,6DB
0221E:  RCALL  216C
02220:  MOVFF  02,6E0
02224:  MOVFF  01,6DF
02228:  CALL   0DFC
0222C:  MOVFF  03,6D7
02230:  MOVFF  02,6D6
02234:  MOVFF  01,6D5
02238:  MOVFF  00,6D4
0223C:  BRA    23E0
.................... 
....................  else if (y < 10000000.0)
0223E:  MOVFF  6D3,6DE
02242:  MOVFF  6D2,6DD
02246:  MOVFF  6D1,6DC
0224A:  MOVFF  6D0,6DB
0224E:  MOVLW  80
02250:  MOVLB  6
02252:  MOVWF  xE2
02254:  MOVLW  96
02256:  MOVWF  xE1
02258:  MOVLW  18
0225A:  MOVWF  xE0
0225C:  MOVLW  96
0225E:  MOVWF  xDF
02260:  MOVLB  0
02262:  CALL   1778
02266:  BTFSS  FD8.0
02268:  BRA    23D0
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
0226A:  MOVFF  6D3,6E3
0226E:  MOVFF  6D2,6E2
02272:  MOVFF  6D1,6E1
02276:  MOVFF  6D0,6E0
0227A:  MOVLB  6
0227C:  CLRF   xE7
0227E:  CLRF   xE6
02280:  CLRF   xE5
02282:  MOVLW  70
02284:  MOVWF  xE4
02286:  MOVLB  0
02288:  CALL   0E32
0228C:  MOVFF  03,6DE
02290:  MOVFF  02,6DD
02294:  MOVFF  01,6DC
02298:  MOVFF  00,6DB
0229C:  RCALL  216C
0229E:  MOVFF  02,6D9
022A2:  MOVFF  01,6D8
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
022A6:  MOVFF  6D3,6E3
022AA:  MOVFF  6D2,6E2
022AE:  MOVFF  6D1,6E1
022B2:  MOVFF  6D0,6E0
022B6:  MOVLB  6
022B8:  CLRF   xE7
022BA:  CLRF   xE6
022BC:  CLRF   xE5
022BE:  MOVLW  70
022C0:  MOVWF  xE4
022C2:  MOVLB  0
022C4:  CALL   0E32
022C8:  MOVFF  03,6DE
022CC:  MOVFF  02,6DD
022D0:  MOVFF  01,6DC
022D4:  MOVFF  00,6DB
022D8:  MOVFF  6D9,6E0
022DC:  MOVFF  6D8,6DF
022E0:  CALL   0DFC
022E4:  BSF    FD8.1
022E6:  MOVFF  6DE,6E2
022EA:  MOVFF  6DD,6E1
022EE:  MOVFF  6DC,6E0
022F2:  MOVFF  6DB,6DF
022F6:  MOVFF  03,6E6
022FA:  MOVFF  02,6E5
022FE:  MOVFF  01,6E4
02302:  MOVFF  00,6E3
02306:  CALL   0F28
0230A:  MOVLB  6
0230C:  CLRF   xE3
0230E:  CLRF   xE2
02310:  CLRF   xE1
02312:  MOVLW  8E
02314:  MOVWF  xE0
02316:  MOVFF  03,6E7
0231A:  MOVFF  02,6E6
0231E:  MOVFF  01,6E5
02322:  MOVFF  00,6E4
02326:  MOVLB  0
02328:  CALL   0E32
0232C:  MOVFF  03,6D3
02330:  MOVFF  02,6D2
02334:  MOVFF  01,6D1
02338:  MOVFF  00,6D0
....................       res = 32768.0*(float32)l;
0233C:  MOVFF  6D9,6E0
02340:  MOVFF  6D8,6DF
02344:  CALL   0DFC
02348:  MOVLB  6
0234A:  CLRF   xE3
0234C:  CLRF   xE2
0234E:  CLRF   xE1
02350:  MOVLW  8E
02352:  MOVWF  xE0
02354:  MOVFF  03,6E7
02358:  MOVFF  02,6E6
0235C:  MOVFF  01,6E5
02360:  MOVFF  00,6E4
02364:  MOVLB  0
02366:  CALL   0E32
0236A:  MOVFF  03,6D7
0236E:  MOVFF  02,6D6
02372:  MOVFF  01,6D5
02376:  MOVFF  00,6D4
....................       res += (float32)(unsigned int16)y;
0237A:  MOVFF  6D3,6DE
0237E:  MOVFF  6D2,6DD
02382:  MOVFF  6D1,6DC
02386:  MOVFF  6D0,6DB
0238A:  RCALL  216C
0238C:  MOVFF  02,6E0
02390:  MOVFF  01,6DF
02394:  CALL   0DFC
02398:  BCF    FD8.1
0239A:  MOVFF  6D7,6E2
0239E:  MOVFF  6D6,6E1
023A2:  MOVFF  6D5,6E0
023A6:  MOVFF  6D4,6DF
023AA:  MOVFF  03,6E6
023AE:  MOVFF  02,6E5
023B2:  MOVFF  01,6E4
023B6:  MOVFF  00,6E3
023BA:  CALL   0F28
023BE:  MOVFF  03,6D7
023C2:  MOVFF  02,6D6
023C6:  MOVFF  01,6D5
023CA:  MOVFF  00,6D4
....................    }
023CE:  BRA    23E0
.................... 
....................  else
....................   res = y;
023D0:  MOVFF  6D3,6D7
023D4:  MOVFF  6D2,6D6
023D8:  MOVFF  6D1,6D5
023DC:  MOVFF  6D0,6D4
.................... 
....................  y = y - (float32)(unsigned int16)y;
023E0:  MOVFF  6D3,6DE
023E4:  MOVFF  6D2,6DD
023E8:  MOVFF  6D1,6DC
023EC:  MOVFF  6D0,6DB
023F0:  RCALL  216C
023F2:  MOVFF  02,6E0
023F6:  MOVFF  01,6DF
023FA:  CALL   0DFC
023FE:  BSF    FD8.1
02400:  MOVFF  6D3,6E2
02404:  MOVFF  6D2,6E1
02408:  MOVFF  6D1,6E0
0240C:  MOVFF  6D0,6DF
02410:  MOVFF  03,6E6
02414:  MOVFF  02,6E5
02418:  MOVFF  01,6E4
0241C:  MOVFF  00,6E3
02420:  CALL   0F28
02424:  MOVFF  03,6D3
02428:  MOVFF  02,6D2
0242C:  MOVFF  01,6D1
02430:  MOVFF  00,6D0
.................... 
....................  if (s)
02434:  MOVLB  6
02436:  BTFSS  xDA.0
02438:  BRA    2440
....................   res = -res;
0243A:  MOVF   xD5,W
0243C:  XORLW  80
0243E:  MOVWF  xD5
.................... 
....................  if (y != 0)
02440:  MOVFF  6D3,6DE
02444:  MOVFF  6D2,6DD
02448:  MOVFF  6D1,6DC
0244C:  MOVFF  6D0,6DB
02450:  CLRF   xE2
02452:  CLRF   xE1
02454:  CLRF   xE0
02456:  CLRF   xDF
02458:  MOVLB  0
0245A:  CALL   1778
0245E:  BZ    24D8
....................  {
....................   if (s == 1 && n == 0)
02460:  MOVLB  6
02462:  BTFSS  xDA.0
02464:  BRA    249E
02466:  MOVF   xCF,F
02468:  BNZ   249E
....................    res -= 1.0;
0246A:  BSF    FD8.1
0246C:  MOVFF  6D7,6E2
02470:  MOVFF  6D6,6E1
02474:  MOVFF  6D5,6E0
02478:  MOVFF  6D4,6DF
0247C:  CLRF   xE6
0247E:  CLRF   xE5
02480:  CLRF   xE4
02482:  MOVLW  7F
02484:  MOVWF  xE3
02486:  MOVLB  0
02488:  CALL   0F28
0248C:  MOVFF  03,6D7
02490:  MOVFF  02,6D6
02494:  MOVFF  01,6D5
02498:  MOVFF  00,6D4
0249C:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
0249E:  BTFSC  xDA.0
024A0:  BRA    24DA
024A2:  DECFSZ xCF,W
024A4:  BRA    24DA
....................    res += 1.0;
024A6:  BCF    FD8.1
024A8:  MOVFF  6D7,6E2
024AC:  MOVFF  6D6,6E1
024B0:  MOVFF  6D5,6E0
024B4:  MOVFF  6D4,6DF
024B8:  CLRF   xE6
024BA:  CLRF   xE5
024BC:  CLRF   xE4
024BE:  MOVLW  7F
024C0:  MOVWF  xE3
024C2:  MOVLB  0
024C4:  CALL   0F28
024C8:  MOVFF  03,6D7
024CC:  MOVFF  02,6D6
024D0:  MOVFF  01,6D5
024D4:  MOVFF  00,6D4
024D8:  MOVLB  6
....................  }
....................  if (x == 0)
024DA:  MOVFF  6CE,6DE
024DE:  MOVFF  6CD,6DD
024E2:  MOVFF  6CC,6DC
024E6:  MOVFF  6CB,6DB
024EA:  CLRF   xE2
024EC:  CLRF   xE1
024EE:  CLRF   xE0
024F0:  CLRF   xDF
024F2:  MOVLB  0
024F4:  CALL   1778
024F8:  BNZ   2506
....................     res = 0;
024FA:  MOVLB  6
024FC:  CLRF   xD7
024FE:  CLRF   xD6
02500:  CLRF   xD5
02502:  CLRF   xD4
02504:  MOVLB  0
.................... 
....................  return (res);
02506:  MOVFF  6D4,00
0250A:  MOVFF  6D5,01
0250E:  MOVFF  6D6,02
02512:  MOVFF  6D7,03
02516:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02536:  MOVFF  6CA,6CE
0253A:  MOVFF  6C9,6CD
0253E:  MOVFF  6C8,6CC
02542:  MOVFF  6C7,6CB
02546:  MOVLB  6
02548:  CLRF   xCF
0254A:  MOVLB  0
0254C:  RCALL  21A8
0254E:  GOTO   265A (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02518:  MOVFF  6CA,6CE
0251C:  MOVFF  6C9,6CD
02520:  MOVFF  6C8,6CC
02524:  MOVFF  6C7,6CB
02528:  MOVLW  01
0252A:  MOVLB  6
0252C:  MOVWF  xCF
0252E:  MOVLB  0
02530:  RCALL  21A8
02532:  GOTO   2612 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02552:  MOVFF  6BE,6DE
02556:  MOVFF  6BD,6DD
0255A:  MOVFF  6BC,6DC
0255E:  MOVFF  6BB,6DB
02562:  MOVLB  6
02564:  CLRF   xE2
02566:  CLRF   xE1
02568:  CLRF   xE0
0256A:  CLRF   xDF
0256C:  MOVLB  0
0256E:  CALL   1778
02572:  BTFSC  FD8.2
02574:  BRA    26B6
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02576:  MOVFF  6BA,6D7
0257A:  MOVFF  6B9,6D6
0257E:  MOVFF  6B8,6D5
02582:  MOVFF  6B7,6D4
02586:  MOVFF  6BE,6DB
0258A:  MOVFF  6BD,6DA
0258E:  MOVFF  6BC,6D9
02592:  MOVFF  6BB,6D8
02596:  CALL   17F2
0259A:  MOVFF  03,6C6
0259E:  MOVFF  02,6C5
025A2:  MOVFF  01,6C4
025A6:  MOVFF  00,6C3
025AA:  MOVFF  03,6DE
025AE:  MOVFF  02,6DD
025B2:  MOVFF  01,6DC
025B6:  MOVFF  00,6DB
025BA:  MOVLB  6
025BC:  CLRF   xE2
025BE:  CLRF   xE1
025C0:  CLRF   xE0
025C2:  CLRF   xDF
025C4:  MOVLB  0
025C6:  CALL   1778
025CA:  BNC   2614
025CC:  MOVFF  6BA,6D7
025D0:  MOVFF  6B9,6D6
025D4:  MOVFF  6B8,6D5
025D8:  MOVFF  6B7,6D4
025DC:  MOVFF  6BE,6DB
025E0:  MOVFF  6BD,6DA
025E4:  MOVFF  6BC,6D9
025E8:  MOVFF  6BB,6D8
025EC:  CALL   17F2
025F0:  MOVFF  03,6C6
025F4:  MOVFF  02,6C5
025F8:  MOVFF  01,6C4
025FC:  MOVFF  00,6C3
02600:  MOVFF  03,6CA
02604:  MOVFF  02,6C9
02608:  MOVFF  01,6C8
0260C:  MOVFF  00,6C7
02610:  BRA    2518
02612:  BRA    265A
02614:  MOVFF  6BA,6D7
02618:  MOVFF  6B9,6D6
0261C:  MOVFF  6B8,6D5
02620:  MOVFF  6B7,6D4
02624:  MOVFF  6BE,6DB
02628:  MOVFF  6BD,6DA
0262C:  MOVFF  6BC,6D9
02630:  MOVFF  6BB,6D8
02634:  CALL   17F2
02638:  MOVFF  03,6C6
0263C:  MOVFF  02,6C5
02640:  MOVFF  01,6C4
02644:  MOVFF  00,6C3
02648:  MOVFF  03,6CA
0264C:  MOVFF  02,6C9
02650:  MOVFF  01,6C8
02654:  MOVFF  00,6C7
02658:  BRA    2536
0265A:  MOVFF  03,6C2
0265E:  MOVFF  02,6C1
02662:  MOVFF  01,6C0
02666:  MOVFF  00,6BF
....................       return(x-(i*y));
0266A:  MOVFF  6C2,6E3
0266E:  MOVFF  6C1,6E2
02672:  MOVFF  6C0,6E1
02676:  MOVFF  6BF,6E0
0267A:  MOVFF  6BE,6E7
0267E:  MOVFF  6BD,6E6
02682:  MOVFF  6BC,6E5
02686:  MOVFF  6BB,6E4
0268A:  CALL   0E32
0268E:  BSF    FD8.1
02690:  MOVFF  6BA,6E2
02694:  MOVFF  6B9,6E1
02698:  MOVFF  6B8,6E0
0269C:  MOVFF  6B7,6DF
026A0:  MOVFF  03,6E6
026A4:  MOVFF  02,6E5
026A8:  MOVFF  01,6E4
026AC:  MOVFF  00,6E3
026B0:  CALL   0F28
026B4:  BRA    26B6
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
026B6:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02A4C:  MOVFF  6BE,6E3
02A50:  MOVFF  6BD,6E2
02A54:  MOVFF  6BC,6E1
02A58:  MOVFF  6BB,6E0
02A5C:  MOVLW  3B
02A5E:  MOVLB  6
02A60:  MOVWF  xE7
02A62:  MOVLW  AA
02A64:  MOVWF  xE6
02A66:  MOVLW  38
02A68:  MOVWF  xE5
02A6A:  MOVLW  7F
02A6C:  MOVWF  xE4
02A6E:  MOVLB  0
02A70:  CALL   0E32
02A74:  MOVFF  03,6DE
02A78:  MOVFF  02,6DD
02A7C:  MOVFF  01,6DC
02A80:  MOVFF  00,6DB
02A84:  CALL   216C
02A88:  MOVFF  01,6CB
....................    s = 0;
02A8C:  MOVLB  6
02A8E:  BCF    xCC.0
....................    y = x;
02A90:  MOVFF  6BE,6C2
02A94:  MOVFF  6BD,6C1
02A98:  MOVFF  6BC,6C0
02A9C:  MOVFF  6BB,6BF
.................... 
....................    if (x < 0)
02AA0:  MOVFF  6BE,6DE
02AA4:  MOVFF  6BD,6DD
02AA8:  MOVFF  6BC,6DC
02AAC:  MOVFF  6BB,6DB
02AB0:  CLRF   xE2
02AB2:  CLRF   xE1
02AB4:  CLRF   xE0
02AB6:  CLRF   xDF
02AB8:  MOVLB  0
02ABA:  CALL   1778
02ABE:  BNC   2ACE
....................    {
....................       s = 1;
02AC0:  MOVLB  6
02AC2:  BSF    xCC.0
....................       n = -n;
02AC4:  NEGF   xCB
....................       y = -y;
02AC6:  MOVF   xC0,W
02AC8:  XORLW  80
02ACA:  MOVWF  xC0
02ACC:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
02ACE:  MOVLB  6
02AD0:  CLRF   xC6
02AD2:  CLRF   xC5
02AD4:  CLRF   xC4
02AD6:  CLRF   xC3
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
02AD8:  MOVLW  06
02ADA:  MOVWF  xCE
02ADC:  MOVLW  C3
02ADE:  MOVFF  6CE,FEA
02AE2:  MOVWF  FE9
02AE4:  MOVLW  7F
02AE6:  ADDWF  xCB,W
02AE8:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
02AEA:  MOVFF  6C2,6E3
02AEE:  MOVFF  6C1,6E2
02AF2:  MOVFF  6C0,6E1
02AF6:  MOVFF  6BF,6E0
02AFA:  MOVLW  3B
02AFC:  MOVWF  xE7
02AFE:  MOVLW  AA
02B00:  MOVWF  xE6
02B02:  MOVLW  38
02B04:  MOVWF  xE5
02B06:  MOVLW  7F
02B08:  MOVWF  xE4
02B0A:  MOVLB  0
02B0C:  CALL   0E32
02B10:  MOVFF  03,6D0
02B14:  MOVFF  02,6CF
02B18:  MOVFF  01,6CE
02B1C:  MOVFF  00,6CD
02B20:  MOVLB  6
02B22:  CLRF   xD2
02B24:  MOVFF  6CB,6D1
02B28:  BTFSC  xD1.7
02B2A:  DECF   xD2,F
02B2C:  MOVLB  0
02B2E:  CALL   211C
02B32:  BSF    FD8.1
02B34:  MOVFF  6D0,6E2
02B38:  MOVFF  6CF,6E1
02B3C:  MOVFF  6CE,6E0
02B40:  MOVFF  6CD,6DF
02B44:  MOVFF  03,6E6
02B48:  MOVFF  02,6E5
02B4C:  MOVFF  01,6E4
02B50:  MOVFF  00,6E3
02B54:  CALL   0F28
02B58:  MOVFF  03,6C2
02B5C:  MOVFF  02,6C1
02B60:  MOVFF  01,6C0
02B64:  MOVFF  00,6BF
.................... 
....................    r = pe[0]*y + pe[1];
02B68:  MOVLW  7C
02B6A:  MOVLB  6
02B6C:  MOVWF  xE3
02B6E:  MOVLW  88
02B70:  MOVWF  xE2
02B72:  MOVLW  59
02B74:  MOVWF  xE1
02B76:  MOVLW  72
02B78:  MOVWF  xE0
02B7A:  MOVFF  6C2,6E7
02B7E:  MOVFF  6C1,6E6
02B82:  MOVFF  6C0,6E5
02B86:  MOVFF  6BF,6E4
02B8A:  MOVLB  0
02B8C:  CALL   0E32
02B90:  MOVFF  03,6D0
02B94:  MOVFF  02,6CF
02B98:  MOVFF  01,6CE
02B9C:  MOVFF  00,6CD
02BA0:  BCF    FD8.1
02BA2:  MOVFF  03,6E2
02BA6:  MOVFF  02,6E1
02BAA:  MOVFF  01,6E0
02BAE:  MOVFF  00,6DF
02BB2:  MOVLW  E0
02BB4:  MOVLB  6
02BB6:  MOVWF  xE6
02BB8:  MOVLW  97
02BBA:  MOVWF  xE5
02BBC:  MOVLW  26
02BBE:  MOVWF  xE4
02BC0:  MOVLW  75
02BC2:  MOVWF  xE3
02BC4:  MOVLB  0
02BC6:  CALL   0F28
02BCA:  MOVFF  03,6CA
02BCE:  MOVFF  02,6C9
02BD2:  MOVFF  01,6C8
02BD6:  MOVFF  00,6C7
....................    r = r*y + pe[2];
02BDA:  MOVFF  6CA,6E3
02BDE:  MOVFF  6C9,6E2
02BE2:  MOVFF  6C8,6E1
02BE6:  MOVFF  6C7,6E0
02BEA:  MOVFF  6C2,6E7
02BEE:  MOVFF  6C1,6E6
02BF2:  MOVFF  6C0,6E5
02BF6:  MOVFF  6BF,6E4
02BFA:  CALL   0E32
02BFE:  MOVFF  03,6D0
02C02:  MOVFF  02,6CF
02C06:  MOVFF  01,6CE
02C0A:  MOVFF  00,6CD
02C0E:  BCF    FD8.1
02C10:  MOVFF  03,6E2
02C14:  MOVFF  02,6E1
02C18:  MOVFF  01,6E0
02C1C:  MOVFF  00,6DF
02C20:  MOVLW  C4
02C22:  MOVLB  6
02C24:  MOVWF  xE6
02C26:  MOVLW  1D
02C28:  MOVWF  xE5
02C2A:  MOVLW  1E
02C2C:  MOVWF  xE4
02C2E:  MOVLW  78
02C30:  MOVWF  xE3
02C32:  MOVLB  0
02C34:  CALL   0F28
02C38:  MOVFF  03,6CA
02C3C:  MOVFF  02,6C9
02C40:  MOVFF  01,6C8
02C44:  MOVFF  00,6C7
....................    r = r*y + pe[3];
02C48:  MOVFF  6CA,6E3
02C4C:  MOVFF  6C9,6E2
02C50:  MOVFF  6C8,6E1
02C54:  MOVFF  6C7,6E0
02C58:  MOVFF  6C2,6E7
02C5C:  MOVFF  6C1,6E6
02C60:  MOVFF  6C0,6E5
02C64:  MOVFF  6BF,6E4
02C68:  CALL   0E32
02C6C:  MOVFF  03,6D0
02C70:  MOVFF  02,6CF
02C74:  MOVFF  01,6CE
02C78:  MOVFF  00,6CD
02C7C:  BCF    FD8.1
02C7E:  MOVFF  03,6E2
02C82:  MOVFF  02,6E1
02C86:  MOVFF  01,6E0
02C8A:  MOVFF  00,6DF
02C8E:  MOVLW  5E
02C90:  MOVLB  6
02C92:  MOVWF  xE6
02C94:  MOVLW  50
02C96:  MOVWF  xE5
02C98:  MOVLW  63
02C9A:  MOVWF  xE4
02C9C:  MOVLW  7A
02C9E:  MOVWF  xE3
02CA0:  MOVLB  0
02CA2:  CALL   0F28
02CA6:  MOVFF  03,6CA
02CAA:  MOVFF  02,6C9
02CAE:  MOVFF  01,6C8
02CB2:  MOVFF  00,6C7
....................    r = r*y + pe[4];
02CB6:  MOVFF  6CA,6E3
02CBA:  MOVFF  6C9,6E2
02CBE:  MOVFF  6C8,6E1
02CC2:  MOVFF  6C7,6E0
02CC6:  MOVFF  6C2,6E7
02CCA:  MOVFF  6C1,6E6
02CCE:  MOVFF  6C0,6E5
02CD2:  MOVFF  6BF,6E4
02CD6:  CALL   0E32
02CDA:  MOVFF  03,6D0
02CDE:  MOVFF  02,6CF
02CE2:  MOVFF  01,6CE
02CE6:  MOVFF  00,6CD
02CEA:  BCF    FD8.1
02CEC:  MOVFF  03,6E2
02CF0:  MOVFF  02,6E1
02CF4:  MOVFF  01,6E0
02CF8:  MOVFF  00,6DF
02CFC:  MOVLW  1A
02CFE:  MOVLB  6
02D00:  MOVWF  xE6
02D02:  MOVLW  FE
02D04:  MOVWF  xE5
02D06:  MOVLW  75
02D08:  MOVWF  xE4
02D0A:  MOVLW  7C
02D0C:  MOVWF  xE3
02D0E:  MOVLB  0
02D10:  CALL   0F28
02D14:  MOVFF  03,6CA
02D18:  MOVFF  02,6C9
02D1C:  MOVFF  01,6C8
02D20:  MOVFF  00,6C7
....................    r = r*y + pe[5];
02D24:  MOVFF  6CA,6E3
02D28:  MOVFF  6C9,6E2
02D2C:  MOVFF  6C8,6E1
02D30:  MOVFF  6C7,6E0
02D34:  MOVFF  6C2,6E7
02D38:  MOVFF  6C1,6E6
02D3C:  MOVFF  6C0,6E5
02D40:  MOVFF  6BF,6E4
02D44:  CALL   0E32
02D48:  MOVFF  03,6D0
02D4C:  MOVFF  02,6CF
02D50:  MOVFF  01,6CE
02D54:  MOVFF  00,6CD
02D58:  BCF    FD8.1
02D5A:  MOVFF  03,6E2
02D5E:  MOVFF  02,6E1
02D62:  MOVFF  01,6E0
02D66:  MOVFF  00,6DF
02D6A:  MOVLW  18
02D6C:  MOVLB  6
02D6E:  MOVWF  xE6
02D70:  MOVLW  72
02D72:  MOVWF  xE5
02D74:  MOVLW  31
02D76:  MOVWF  xE4
02D78:  MOVLW  7E
02D7A:  MOVWF  xE3
02D7C:  MOVLB  0
02D7E:  CALL   0F28
02D82:  MOVFF  03,6CA
02D86:  MOVFF  02,6C9
02D8A:  MOVFF  01,6C8
02D8E:  MOVFF  00,6C7
.................... 
....................    res = res*(1.0 + y*r);
02D92:  MOVFF  6C2,6E3
02D96:  MOVFF  6C1,6E2
02D9A:  MOVFF  6C0,6E1
02D9E:  MOVFF  6BF,6E0
02DA2:  MOVFF  6CA,6E7
02DA6:  MOVFF  6C9,6E6
02DAA:  MOVFF  6C8,6E5
02DAE:  MOVFF  6C7,6E4
02DB2:  CALL   0E32
02DB6:  BCF    FD8.1
02DB8:  MOVLB  6
02DBA:  CLRF   xE2
02DBC:  CLRF   xE1
02DBE:  CLRF   xE0
02DC0:  MOVLW  7F
02DC2:  MOVWF  xDF
02DC4:  MOVFF  03,6E6
02DC8:  MOVFF  02,6E5
02DCC:  MOVFF  01,6E4
02DD0:  MOVFF  00,6E3
02DD4:  MOVLB  0
02DD6:  CALL   0F28
02DDA:  MOVFF  6C6,6E3
02DDE:  MOVFF  6C5,6E2
02DE2:  MOVFF  6C4,6E1
02DE6:  MOVFF  6C3,6E0
02DEA:  MOVFF  03,6E7
02DEE:  MOVFF  02,6E6
02DF2:  MOVFF  01,6E5
02DF6:  MOVFF  00,6E4
02DFA:  CALL   0E32
02DFE:  MOVFF  03,6C6
02E02:  MOVFF  02,6C5
02E06:  MOVFF  01,6C4
02E0A:  MOVFF  00,6C3
.................... 
....................    if (s)
02E0E:  MOVLB  6
02E10:  BTFSS  xCC.0
02E12:  BRA    2E46
....................       res = 1.0/res;
02E14:  CLRF   xD7
02E16:  CLRF   xD6
02E18:  CLRF   xD5
02E1A:  MOVLW  7F
02E1C:  MOVWF  xD4
02E1E:  MOVFF  6C6,6DB
02E22:  MOVFF  6C5,6DA
02E26:  MOVFF  6C4,6D9
02E2A:  MOVFF  6C3,6D8
02E2E:  MOVLB  0
02E30:  CALL   17F2
02E34:  MOVFF  03,6C6
02E38:  MOVFF  02,6C5
02E3C:  MOVFF  01,6C4
02E40:  MOVFF  00,6C3
02E44:  MOVLB  6
....................    return(res);
02E46:  MOVFF  6C3,00
02E4A:  MOVFF  6C4,01
02E4E:  MOVFF  6C5,02
02E52:  MOVFF  6C6,03
02E56:  MOVLB  0
02E58:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
026B8:  MOVFF  6BE,6C2
026BC:  MOVFF  6BD,6C1
026C0:  MOVFF  6BC,6C0
026C4:  MOVFF  6BB,6BF
.................... 
....................    if (y != 1.0)
026C8:  MOVFF  6C2,6DE
026CC:  MOVFF  6C1,6DD
026D0:  MOVFF  6C0,6DC
026D4:  MOVFF  6BF,6DB
026D8:  MOVLB  6
026DA:  CLRF   xE2
026DC:  CLRF   xE1
026DE:  CLRF   xE0
026E0:  MOVLW  7F
026E2:  MOVWF  xDF
026E4:  MOVLB  0
026E6:  CALL   1778
026EA:  BTFSC  FD8.2
026EC:  BRA    2A2E
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
026EE:  MOVLW  06
026F0:  MOVLB  6
026F2:  MOVWF  xD1
026F4:  MOVLW  BF
026F6:  MOVFF  6D1,FEA
026FA:  MOVWF  FE9
026FC:  MOVLW  7E
026FE:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02700:  BSF    FD8.1
02702:  MOVFF  6C2,6E2
02706:  MOVFF  6C1,6E1
0270A:  MOVFF  6C0,6E0
0270E:  MOVFF  6BF,6DF
02712:  CLRF   xE6
02714:  CLRF   xE5
02716:  CLRF   xE4
02718:  MOVLW  7F
0271A:  MOVWF  xE3
0271C:  MOVLB  0
0271E:  CALL   0F28
02722:  MOVFF  03,6D3
02726:  MOVFF  02,6D2
0272A:  MOVFF  01,6D1
0272E:  MOVFF  00,6D0
02732:  BCF    FD8.1
02734:  MOVFF  6C2,6E2
02738:  MOVFF  6C1,6E1
0273C:  MOVFF  6C0,6E0
02740:  MOVFF  6BF,6DF
02744:  MOVLB  6
02746:  CLRF   xE6
02748:  CLRF   xE5
0274A:  CLRF   xE4
0274C:  MOVLW  7F
0274E:  MOVWF  xE3
02750:  MOVLB  0
02752:  CALL   0F28
02756:  MOVFF  6D3,6D7
0275A:  MOVFF  6D2,6D6
0275E:  MOVFF  6D1,6D5
02762:  MOVFF  6D0,6D4
02766:  MOVFF  03,6DB
0276A:  MOVFF  02,6DA
0276E:  MOVFF  01,6D9
02772:  MOVFF  00,6D8
02776:  CALL   17F2
0277A:  MOVFF  03,6C2
0277E:  MOVFF  02,6C1
02782:  MOVFF  01,6C0
02786:  MOVFF  00,6BF
.................... 
....................       y2=y*y;
0278A:  MOVFF  6C2,6E3
0278E:  MOVFF  6C1,6E2
02792:  MOVFF  6C0,6E1
02796:  MOVFF  6BF,6E0
0279A:  MOVFF  6C2,6E7
0279E:  MOVFF  6C1,6E6
027A2:  MOVFF  6C0,6E5
027A6:  MOVFF  6BF,6E4
027AA:  CALL   0E32
027AE:  MOVFF  03,6CE
027B2:  MOVFF  02,6CD
027B6:  MOVFF  01,6CC
027BA:  MOVFF  00,6CB
.................... 
....................       res = pl[0]*y2 + pl[1];
027BE:  MOVLW  99
027C0:  MOVLB  6
027C2:  MOVWF  xE3
027C4:  MOVLW  47
027C6:  MOVWF  xE2
027C8:  MOVLW  8A
027CA:  MOVWF  xE1
027CC:  MOVLW  7F
027CE:  MOVWF  xE0
027D0:  MOVFF  6CE,6E7
027D4:  MOVFF  6CD,6E6
027D8:  MOVFF  6CC,6E5
027DC:  MOVFF  6CB,6E4
027E0:  MOVLB  0
027E2:  CALL   0E32
027E6:  MOVFF  03,6D3
027EA:  MOVFF  02,6D2
027EE:  MOVFF  01,6D1
027F2:  MOVFF  00,6D0
027F6:  BCF    FD8.1
027F8:  MOVFF  03,6E2
027FC:  MOVFF  02,6E1
02800:  MOVFF  01,6E0
02804:  MOVFF  00,6DF
02808:  MOVLB  6
0280A:  CLRF   xE6
0280C:  CLRF   xE5
0280E:  CLRF   xE4
02810:  MOVLW  80
02812:  MOVWF  xE3
02814:  MOVLB  0
02816:  CALL   0F28
0281A:  MOVFF  03,6C6
0281E:  MOVFF  02,6C5
02822:  MOVFF  01,6C4
02826:  MOVFF  00,6C3
.................... 
....................       r = ql[0]*y2 + ql[1];
0282A:  MOVLW  4C
0282C:  MOVLB  6
0282E:  MOVWF  xE3
02830:  MOVLW  F3
02832:  MOVWF  xE2
02834:  MOVLW  3A
02836:  MOVWF  xE1
02838:  MOVLW  7B
0283A:  MOVWF  xE0
0283C:  MOVFF  6CE,6E7
02840:  MOVFF  6CD,6E6
02844:  MOVFF  6CC,6E5
02848:  MOVFF  6CB,6E4
0284C:  MOVLB  0
0284E:  CALL   0E32
02852:  MOVFF  03,6D3
02856:  MOVFF  02,6D2
0285A:  MOVFF  01,6D1
0285E:  MOVFF  00,6D0
02862:  BCF    FD8.1
02864:  MOVFF  03,6E2
02868:  MOVFF  02,6E1
0286C:  MOVFF  01,6E0
02870:  MOVFF  00,6DF
02874:  MOVLW  2B
02876:  MOVLB  6
02878:  MOVWF  xE6
0287A:  MOVLW  9D
0287C:  MOVWF  xE5
0287E:  MOVLW  DF
02880:  MOVWF  xE4
02882:  MOVLW  7E
02884:  MOVWF  xE3
02886:  MOVLB  0
02888:  CALL   0F28
0288C:  MOVFF  03,6CA
02890:  MOVFF  02,6C9
02894:  MOVFF  01,6C8
02898:  MOVFF  00,6C7
....................       r = r*y2 + 1.0;
0289C:  MOVFF  6CA,6E3
028A0:  MOVFF  6C9,6E2
028A4:  MOVFF  6C8,6E1
028A8:  MOVFF  6C7,6E0
028AC:  MOVFF  6CE,6E7
028B0:  MOVFF  6CD,6E6
028B4:  MOVFF  6CC,6E5
028B8:  MOVFF  6CB,6E4
028BC:  CALL   0E32
028C0:  MOVFF  03,6D3
028C4:  MOVFF  02,6D2
028C8:  MOVFF  01,6D1
028CC:  MOVFF  00,6D0
028D0:  BCF    FD8.1
028D2:  MOVFF  03,6E2
028D6:  MOVFF  02,6E1
028DA:  MOVFF  01,6E0
028DE:  MOVFF  00,6DF
028E2:  MOVLB  6
028E4:  CLRF   xE6
028E6:  CLRF   xE5
028E8:  CLRF   xE4
028EA:  MOVLW  7F
028EC:  MOVWF  xE3
028EE:  MOVLB  0
028F0:  CALL   0F28
028F4:  MOVFF  03,6CA
028F8:  MOVFF  02,6C9
028FC:  MOVFF  01,6C8
02900:  MOVFF  00,6C7
.................... 
....................       res = y*res/r;
02904:  MOVFF  6C2,6E3
02908:  MOVFF  6C1,6E2
0290C:  MOVFF  6C0,6E1
02910:  MOVFF  6BF,6E0
02914:  MOVFF  6C6,6E7
02918:  MOVFF  6C5,6E6
0291C:  MOVFF  6C4,6E5
02920:  MOVFF  6C3,6E4
02924:  CALL   0E32
02928:  MOVFF  03,6D3
0292C:  MOVFF  02,6D2
02930:  MOVFF  01,6D1
02934:  MOVFF  00,6D0
02938:  MOVFF  03,6D7
0293C:  MOVFF  02,6D6
02940:  MOVFF  01,6D5
02944:  MOVFF  00,6D4
02948:  MOVFF  6CA,6DB
0294C:  MOVFF  6C9,6DA
02950:  MOVFF  6C8,6D9
02954:  MOVFF  6C7,6D8
02958:  CALL   17F2
0295C:  MOVFF  03,6C6
02960:  MOVFF  02,6C5
02964:  MOVFF  01,6C4
02968:  MOVFF  00,6C3
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0296C:  MOVLW  06
0296E:  MOVLB  6
02970:  MOVWF  xD1
02972:  MOVLW  BB
02974:  MOVFF  6D1,FEA
02978:  MOVWF  FE9
0297A:  MOVLW  7E
0297C:  SUBWF  FEF,W
0297E:  MOVWF  xCF
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02980:  BTFSS  xCF.7
02982:  BRA    29AE
....................          r = -(float32)-n;
02984:  MOVLW  00
02986:  BSF    FD8.0
02988:  SUBFWB xCF,W
0298A:  CLRF   xD2
0298C:  MOVWF  xD1
0298E:  BTFSC  xD1.7
02990:  DECF   xD2,F
02992:  MOVLB  0
02994:  CALL   211C
02998:  MOVFF  00,6C7
0299C:  MOVF   01,W
0299E:  XORLW  80
029A0:  MOVLB  6
029A2:  MOVWF  xC8
029A4:  MOVFF  02,6C9
029A8:  MOVFF  03,6CA
029AC:  BRA    29D0
....................       else
....................          r = (float32)n;
029AE:  CLRF   xD2
029B0:  MOVFF  6CF,6D1
029B4:  BTFSC  xD1.7
029B6:  DECF   xD2,F
029B8:  MOVLB  0
029BA:  CALL   211C
029BE:  MOVFF  03,6CA
029C2:  MOVFF  02,6C9
029C6:  MOVFF  01,6C8
029CA:  MOVFF  00,6C7
029CE:  MOVLB  6
.................... 
....................       res += r*LN2;
029D0:  MOVFF  6CA,6E3
029D4:  MOVFF  6C9,6E2
029D8:  MOVFF  6C8,6E1
029DC:  MOVFF  6C7,6E0
029E0:  MOVLW  18
029E2:  MOVWF  xE7
029E4:  MOVLW  72
029E6:  MOVWF  xE6
029E8:  MOVLW  31
029EA:  MOVWF  xE5
029EC:  MOVLW  7E
029EE:  MOVWF  xE4
029F0:  MOVLB  0
029F2:  CALL   0E32
029F6:  BCF    FD8.1
029F8:  MOVFF  6C6,6E2
029FC:  MOVFF  6C5,6E1
02A00:  MOVFF  6C4,6E0
02A04:  MOVFF  6C3,6DF
02A08:  MOVFF  03,6E6
02A0C:  MOVFF  02,6E5
02A10:  MOVFF  01,6E4
02A14:  MOVFF  00,6E3
02A18:  CALL   0F28
02A1C:  MOVFF  03,6C6
02A20:  MOVFF  02,6C5
02A24:  MOVFF  01,6C4
02A28:  MOVFF  00,6C3
....................    }
02A2C:  BRA    2A3A
.................... 
....................    else
....................       res = 0.0;
02A2E:  MOVLB  6
02A30:  CLRF   xC6
02A32:  CLRF   xC5
02A34:  CLRF   xC4
02A36:  CLRF   xC3
02A38:  MOVLB  0
.................... 
....................    return(res);
02A3A:  MOVFF  6C3,00
02A3E:  MOVFF  6C4,01
02A42:  MOVFF  6C5,02
02A46:  MOVFF  6C6,03
02A4A:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02E5A:  MOVFF  6B2,6DE
02E5E:  MOVFF  6B1,6DD
02E62:  MOVFF  6B0,6DC
02E66:  MOVFF  6AF,6DB
02E6A:  MOVLB  6
02E6C:  CLRF   xE2
02E6E:  CLRF   xE1
02E70:  CLRF   xE0
02E72:  CLRF   xDF
02E74:  MOVLB  0
02E76:  CALL   1778
02E7A:  BTFSS  FD8.0
02E7C:  BRA    3018
02E7E:  MOVFF  6B6,6BA
02E82:  MOVFF  6B5,6B9
02E86:  MOVFF  6B4,6B8
02E8A:  MOVFF  6B3,6B7
02E8E:  MOVLB  6
02E90:  CLRF   xBE
02E92:  CLRF   xBD
02E94:  CLRF   xBC
02E96:  MOVLW  7F
02E98:  MOVWF  xBB
02E9A:  MOVLB  0
02E9C:  CALL   2552
02EA0:  MOVFF  03,6BA
02EA4:  MOVFF  02,6B9
02EA8:  MOVFF  01,6B8
02EAC:  MOVFF  00,6B7
02EB0:  MOVFF  03,6DE
02EB4:  MOVFF  02,6DD
02EB8:  MOVFF  01,6DC
02EBC:  MOVFF  00,6DB
02EC0:  MOVLB  6
02EC2:  CLRF   xE2
02EC4:  CLRF   xE1
02EC6:  CLRF   xE0
02EC8:  CLRF   xDF
02ECA:  MOVLB  0
02ECC:  CALL   1778
02ED0:  BTFSS  FD8.2
02ED2:  BRA    3018
....................       if(fmod(y, 2) == 0) {
02ED4:  MOVFF  6B6,6BA
02ED8:  MOVFF  6B5,6B9
02EDC:  MOVFF  6B4,6B8
02EE0:  MOVFF  6B3,6B7
02EE4:  MOVLB  6
02EE6:  CLRF   xBE
02EE8:  CLRF   xBD
02EEA:  CLRF   xBC
02EEC:  MOVLW  80
02EEE:  MOVWF  xBB
02EF0:  MOVLB  0
02EF2:  CALL   2552
02EF6:  MOVFF  03,6BA
02EFA:  MOVFF  02,6B9
02EFE:  MOVFF  01,6B8
02F02:  MOVFF  00,6B7
02F06:  MOVFF  03,6DE
02F0A:  MOVFF  02,6DD
02F0E:  MOVFF  01,6DC
02F12:  MOVFF  00,6DB
02F16:  MOVLB  6
02F18:  CLRF   xE2
02F1A:  CLRF   xE1
02F1C:  CLRF   xE0
02F1E:  CLRF   xDF
02F20:  MOVLB  0
02F22:  CALL   1778
02F26:  BNZ   2F9E
....................          return (exp(log(-x) * y));
02F28:  MOVLB  6
02F2A:  MOVF   xB0,W
02F2C:  XORLW  80
02F2E:  MOVWF  xB8
02F30:  MOVFF  6B2,6BE
02F34:  MOVFF  6B1,6BD
02F38:  MOVWF  xBC
02F3A:  MOVFF  6AF,6BB
02F3E:  MOVLB  0
02F40:  CALL   26B8
02F44:  MOVFF  03,6BA
02F48:  MOVFF  02,6B9
02F4C:  MOVFF  01,6B8
02F50:  MOVFF  00,6B7
02F54:  MOVFF  03,6E3
02F58:  MOVFF  02,6E2
02F5C:  MOVFF  01,6E1
02F60:  MOVFF  00,6E0
02F64:  MOVFF  6B6,6E7
02F68:  MOVFF  6B5,6E6
02F6C:  MOVFF  6B4,6E5
02F70:  MOVFF  6B3,6E4
02F74:  CALL   0E32
02F78:  MOVFF  03,6BA
02F7C:  MOVFF  02,6B9
02F80:  MOVFF  01,6B8
02F84:  MOVFF  00,6B7
02F88:  MOVFF  03,6BE
02F8C:  MOVFF  02,6BD
02F90:  MOVFF  01,6BC
02F94:  MOVFF  00,6BB
02F98:  RCALL  2A4C
02F9A:  BRA    3156
....................       } else {
02F9C:  BRA    3016
....................          return (-exp(log(-x) * y));
02F9E:  MOVLB  6
02FA0:  MOVF   xB0,W
02FA2:  XORLW  80
02FA4:  MOVWF  xB8
02FA6:  MOVFF  6B2,6BE
02FAA:  MOVFF  6B1,6BD
02FAE:  MOVWF  xBC
02FB0:  MOVFF  6AF,6BB
02FB4:  MOVLB  0
02FB6:  CALL   26B8
02FBA:  MOVFF  03,6BA
02FBE:  MOVFF  02,6B9
02FC2:  MOVFF  01,6B8
02FC6:  MOVFF  00,6B7
02FCA:  MOVFF  03,6E3
02FCE:  MOVFF  02,6E2
02FD2:  MOVFF  01,6E1
02FD6:  MOVFF  00,6E0
02FDA:  MOVFF  6B6,6E7
02FDE:  MOVFF  6B5,6E6
02FE2:  MOVFF  6B4,6E5
02FE6:  MOVFF  6B3,6E4
02FEA:  CALL   0E32
02FEE:  MOVFF  03,6BA
02FF2:  MOVFF  02,6B9
02FF6:  MOVFF  01,6B8
02FFA:  MOVFF  00,6B7
02FFE:  MOVFF  03,6BE
03002:  MOVFF  02,6BD
03006:  MOVFF  01,6BC
0300A:  MOVFF  00,6BB
0300E:  RCALL  2A4C
03010:  MOVLW  80
03012:  XORWF  01,F
03014:  BRA    3156
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03016:  BRA    3156
03018:  MOVFF  6B2,6DE
0301C:  MOVFF  6B1,6DD
03020:  MOVFF  6B0,6DC
03024:  MOVFF  6AF,6DB
03028:  MOVLB  6
0302A:  CLRF   xE2
0302C:  CLRF   xE1
0302E:  CLRF   xE0
03030:  CLRF   xDF
03032:  MOVLB  0
03034:  CALL   1778
03038:  BNC   309A
0303A:  MOVFF  6B6,6BA
0303E:  MOVFF  6B5,6B9
03042:  MOVFF  6B4,6B8
03046:  MOVFF  6B3,6B7
0304A:  MOVLB  6
0304C:  CLRF   xBE
0304E:  CLRF   xBD
03050:  CLRF   xBC
03052:  MOVLW  7F
03054:  MOVWF  xBB
03056:  MOVLB  0
03058:  CALL   2552
0305C:  MOVFF  03,6BA
03060:  MOVFF  02,6B9
03064:  MOVFF  01,6B8
03068:  MOVFF  00,6B7
0306C:  MOVFF  03,6DE
03070:  MOVFF  02,6DD
03074:  MOVFF  01,6DC
03078:  MOVFF  00,6DB
0307C:  MOVLB  6
0307E:  CLRF   xE2
03080:  CLRF   xE1
03082:  CLRF   xE0
03084:  CLRF   xDF
03086:  MOVLB  0
03088:  CALL   1778
0308C:  BZ    309A
....................       return 0;
0308E:  CLRF   00
03090:  CLRF   01
03092:  CLRF   02
03094:  CLRF   03
03096:  BRA    3156
....................    } else {
03098:  BRA    3156
....................       if(x != 0 || 0 >= y) {
0309A:  MOVFF  6B2,6DE
0309E:  MOVFF  6B1,6DD
030A2:  MOVFF  6B0,6DC
030A6:  MOVFF  6AF,6DB
030AA:  MOVLB  6
030AC:  CLRF   xE2
030AE:  CLRF   xE1
030B0:  CLRF   xE0
030B2:  CLRF   xDF
030B4:  MOVLB  0
030B6:  CALL   1778
030BA:  BNZ   30E0
030BC:  MOVFF  6B6,6DE
030C0:  MOVFF  6B5,6DD
030C4:  MOVFF  6B4,6DC
030C8:  MOVFF  6B3,6DB
030CC:  MOVLB  6
030CE:  CLRF   xE2
030D0:  CLRF   xE1
030D2:  CLRF   xE0
030D4:  CLRF   xDF
030D6:  MOVLB  0
030D8:  CALL   1778
030DC:  BC    30E0
030DE:  BNZ   314E
....................          return (exp(log(x) * y));
030E0:  MOVFF  6B2,6BE
030E4:  MOVFF  6B1,6BD
030E8:  MOVFF  6B0,6BC
030EC:  MOVFF  6AF,6BB
030F0:  CALL   26B8
030F4:  MOVFF  03,6BA
030F8:  MOVFF  02,6B9
030FC:  MOVFF  01,6B8
03100:  MOVFF  00,6B7
03104:  MOVFF  03,6E3
03108:  MOVFF  02,6E2
0310C:  MOVFF  01,6E1
03110:  MOVFF  00,6E0
03114:  MOVFF  6B6,6E7
03118:  MOVFF  6B5,6E6
0311C:  MOVFF  6B4,6E5
03120:  MOVFF  6B3,6E4
03124:  CALL   0E32
03128:  MOVFF  03,6BA
0312C:  MOVFF  02,6B9
03130:  MOVFF  01,6B8
03134:  MOVFF  00,6B7
03138:  MOVFF  03,6BE
0313C:  MOVFF  02,6BD
03140:  MOVFF  01,6BC
03144:  MOVFF  00,6BB
03148:  RCALL  2A4C
0314A:  BRA    3156
....................       } else return 0;
0314C:  BRA    3156
0314E:  CLRF   00
03150:  CLRF   01
03152:  CLRF   02
03154:  CLRF   03
....................    }
03156:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01950:  MOVLB  6
01952:  BCF    xCD.0
....................    flag = 0;
01954:  BCF    xCD.1
....................    y = x;
01956:  MOVFF  6C0,6C4
0195A:  MOVFF  6BF,6C3
0195E:  MOVFF  6BE,6C2
01962:  MOVFF  6BD,6C1
.................... 
....................    if (x < 0)
01966:  MOVFF  6C0,6DE
0196A:  MOVFF  6BF,6DD
0196E:  MOVFF  6BE,6DC
01972:  MOVFF  6BD,6DB
01976:  CLRF   xE2
01978:  CLRF   xE1
0197A:  CLRF   xE0
0197C:  CLRF   xDF
0197E:  MOVLB  0
01980:  RCALL  1778
01982:  BNC   1990
....................    {
....................       s = 1;
01984:  MOVLB  6
01986:  BSF    xCD.0
....................       y = -y;
01988:  MOVF   xC2,W
0198A:  XORLW  80
0198C:  MOVWF  xC2
0198E:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01990:  MOVLB  6
01992:  CLRF   xDE
01994:  CLRF   xDD
01996:  CLRF   xDC
01998:  MOVLW  7F
0199A:  MOVWF  xDB
0199C:  MOVFF  6C4,6E2
019A0:  MOVFF  6C3,6E1
019A4:  MOVFF  6C2,6E0
019A8:  MOVFF  6C1,6DF
019AC:  MOVLB  0
019AE:  RCALL  1778
019B0:  BNC   19E8
....................    {
....................       y = 1.0/y;
019B2:  MOVLB  6
019B4:  CLRF   xD7
019B6:  CLRF   xD6
019B8:  CLRF   xD5
019BA:  MOVLW  7F
019BC:  MOVWF  xD4
019BE:  MOVFF  6C4,6DB
019C2:  MOVFF  6C3,6DA
019C6:  MOVFF  6C2,6D9
019CA:  MOVFF  6C1,6D8
019CE:  MOVLB  0
019D0:  RCALL  17F2
019D2:  MOVFF  03,6C4
019D6:  MOVFF  02,6C3
019DA:  MOVFF  01,6C2
019DE:  MOVFF  00,6C1
....................       flag = 1;
019E2:  MOVLB  6
019E4:  BSF    xCD.1
019E6:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
019E8:  MOVLW  0A
019EA:  MOVLB  6
019EC:  MOVWF  xE3
019EE:  MOVLW  89
019F0:  MOVWF  xE2
019F2:  MOVLW  34
019F4:  MOVWF  xE1
019F6:  MOVLW  7C
019F8:  MOVWF  xE0
019FA:  MOVFF  6C4,6E7
019FE:  MOVFF  6C3,6E6
01A02:  MOVFF  6C2,6E5
01A06:  MOVFF  6C1,6E4
01A0A:  MOVLB  0
01A0C:  CALL   0E32
01A10:  MOVFF  03,6D1
01A14:  MOVFF  02,6D0
01A18:  MOVFF  01,6CF
01A1C:  MOVFF  00,6CE
01A20:  MOVFF  03,6E3
01A24:  MOVFF  02,6E2
01A28:  MOVFF  01,6E1
01A2C:  MOVFF  00,6E0
01A30:  MOVFF  6C4,6E7
01A34:  MOVFF  6C3,6E6
01A38:  MOVFF  6C2,6E5
01A3C:  MOVFF  6C1,6E4
01A40:  CALL   0E32
01A44:  MOVFF  03,6D1
01A48:  MOVFF  02,6D0
01A4C:  MOVFF  01,6CF
01A50:  MOVFF  00,6CE
01A54:  BCF    FD8.1
01A56:  MOVFF  03,6E2
01A5A:  MOVFF  02,6E1
01A5E:  MOVFF  01,6E0
01A62:  MOVFF  00,6DF
01A66:  MOVLW  7C
01A68:  MOVLB  6
01A6A:  MOVWF  xE6
01A6C:  MOVLW  79
01A6E:  MOVWF  xE5
01A70:  MOVLW  35
01A72:  MOVWF  xE4
01A74:  MOVLW  81
01A76:  MOVWF  xE3
01A78:  MOVLB  0
01A7A:  CALL   0F28
01A7E:  MOVFF  03,6C8
01A82:  MOVFF  02,6C7
01A86:  MOVFF  01,6C6
01A8A:  MOVFF  00,6C5
....................    res = res*y*y + pat[2];
01A8E:  MOVFF  6C8,6E3
01A92:  MOVFF  6C7,6E2
01A96:  MOVFF  6C6,6E1
01A9A:  MOVFF  6C5,6E0
01A9E:  MOVFF  6C4,6E7
01AA2:  MOVFF  6C3,6E6
01AA6:  MOVFF  6C2,6E5
01AAA:  MOVFF  6C1,6E4
01AAE:  CALL   0E32
01AB2:  MOVFF  03,6D1
01AB6:  MOVFF  02,6D0
01ABA:  MOVFF  01,6CF
01ABE:  MOVFF  00,6CE
01AC2:  MOVFF  03,6E3
01AC6:  MOVFF  02,6E2
01ACA:  MOVFF  01,6E1
01ACE:  MOVFF  00,6E0
01AD2:  MOVFF  6C4,6E7
01AD6:  MOVFF  6C3,6E6
01ADA:  MOVFF  6C2,6E5
01ADE:  MOVFF  6C1,6E4
01AE2:  CALL   0E32
01AE6:  MOVFF  03,6D1
01AEA:  MOVFF  02,6D0
01AEE:  MOVFF  01,6CF
01AF2:  MOVFF  00,6CE
01AF6:  BCF    FD8.1
01AF8:  MOVFF  03,6E2
01AFC:  MOVFF  02,6E1
01B00:  MOVFF  01,6E0
01B04:  MOVFF  00,6DF
01B08:  MOVLW  3F
01B0A:  MOVLB  6
01B0C:  MOVWF  xE6
01B0E:  MOVLW  02
01B10:  MOVWF  xE5
01B12:  MOVLW  33
01B14:  MOVWF  xE4
01B16:  MOVLW  83
01B18:  MOVWF  xE3
01B1A:  MOVLB  0
01B1C:  CALL   0F28
01B20:  MOVFF  03,6C8
01B24:  MOVFF  02,6C7
01B28:  MOVFF  01,6C6
01B2C:  MOVFF  00,6C5
....................    res = res*y*y + pat[3];
01B30:  MOVFF  6C8,6E3
01B34:  MOVFF  6C7,6E2
01B38:  MOVFF  6C6,6E1
01B3C:  MOVFF  6C5,6E0
01B40:  MOVFF  6C4,6E7
01B44:  MOVFF  6C3,6E6
01B48:  MOVFF  6C2,6E5
01B4C:  MOVFF  6C1,6E4
01B50:  CALL   0E32
01B54:  MOVFF  03,6D1
01B58:  MOVFF  02,6D0
01B5C:  MOVFF  01,6CF
01B60:  MOVFF  00,6CE
01B64:  MOVFF  03,6E3
01B68:  MOVFF  02,6E2
01B6C:  MOVFF  01,6E1
01B70:  MOVFF  00,6E0
01B74:  MOVFF  6C4,6E7
01B78:  MOVFF  6C3,6E6
01B7C:  MOVFF  6C2,6E5
01B80:  MOVFF  6C1,6E4
01B84:  CALL   0E32
01B88:  MOVFF  03,6D1
01B8C:  MOVFF  02,6D0
01B90:  MOVFF  01,6CF
01B94:  MOVFF  00,6CE
01B98:  BCF    FD8.1
01B9A:  MOVFF  03,6E2
01B9E:  MOVFF  02,6E1
01BA2:  MOVFF  01,6E0
01BA6:  MOVFF  00,6DF
01BAA:  MOVLW  33
01BAC:  MOVLB  6
01BAE:  MOVWF  xE6
01BB0:  MOVLW  8C
01BB2:  MOVWF  xE5
01BB4:  MOVLW  1E
01BB6:  MOVWF  xE4
01BB8:  MOVLW  83
01BBA:  MOVWF  xE3
01BBC:  MOVLB  0
01BBE:  CALL   0F28
01BC2:  MOVFF  03,6C8
01BC6:  MOVFF  02,6C7
01BCA:  MOVFF  01,6C6
01BCE:  MOVFF  00,6C5
.................... 
....................    r = qat[0]*y*y + qat[1];
01BD2:  MOVLB  6
01BD4:  CLRF   xE3
01BD6:  CLRF   xE2
01BD8:  CLRF   xE1
01BDA:  MOVLW  7F
01BDC:  MOVWF  xE0
01BDE:  MOVFF  6C4,6E7
01BE2:  MOVFF  6C3,6E6
01BE6:  MOVFF  6C2,6E5
01BEA:  MOVFF  6C1,6E4
01BEE:  MOVLB  0
01BF0:  CALL   0E32
01BF4:  MOVFF  03,6D1
01BF8:  MOVFF  02,6D0
01BFC:  MOVFF  01,6CF
01C00:  MOVFF  00,6CE
01C04:  MOVFF  03,6E3
01C08:  MOVFF  02,6E2
01C0C:  MOVFF  01,6E1
01C10:  MOVFF  00,6E0
01C14:  MOVFF  6C4,6E7
01C18:  MOVFF  6C3,6E6
01C1C:  MOVFF  6C2,6E5
01C20:  MOVFF  6C1,6E4
01C24:  CALL   0E32
01C28:  MOVFF  03,6D1
01C2C:  MOVFF  02,6D0
01C30:  MOVFF  01,6CF
01C34:  MOVFF  00,6CE
01C38:  BCF    FD8.1
01C3A:  MOVFF  03,6E2
01C3E:  MOVFF  02,6E1
01C42:  MOVFF  01,6E0
01C46:  MOVFF  00,6DF
01C4A:  MOVLW  1B
01C4C:  MOVLB  6
01C4E:  MOVWF  xE6
01C50:  MOVLW  E4
01C52:  MOVWF  xE5
01C54:  MOVLW  35
01C56:  MOVWF  xE4
01C58:  MOVLW  82
01C5A:  MOVWF  xE3
01C5C:  MOVLB  0
01C5E:  CALL   0F28
01C62:  MOVFF  03,6CC
01C66:  MOVFF  02,6CB
01C6A:  MOVFF  01,6CA
01C6E:  MOVFF  00,6C9
....................    r = r*y*y + qat[2];
01C72:  MOVFF  6CC,6E3
01C76:  MOVFF  6CB,6E2
01C7A:  MOVFF  6CA,6E1
01C7E:  MOVFF  6C9,6E0
01C82:  MOVFF  6C4,6E7
01C86:  MOVFF  6C3,6E6
01C8A:  MOVFF  6C2,6E5
01C8E:  MOVFF  6C1,6E4
01C92:  CALL   0E32
01C96:  MOVFF  03,6D1
01C9A:  MOVFF  02,6D0
01C9E:  MOVFF  01,6CF
01CA2:  MOVFF  00,6CE
01CA6:  MOVFF  03,6E3
01CAA:  MOVFF  02,6E2
01CAE:  MOVFF  01,6E1
01CB2:  MOVFF  00,6E0
01CB6:  MOVFF  6C4,6E7
01CBA:  MOVFF  6C3,6E6
01CBE:  MOVFF  6C2,6E5
01CC2:  MOVFF  6C1,6E4
01CC6:  CALL   0E32
01CCA:  MOVFF  03,6D1
01CCE:  MOVFF  02,6D0
01CD2:  MOVFF  01,6CF
01CD6:  MOVFF  00,6CE
01CDA:  BCF    FD8.1
01CDC:  MOVFF  03,6E2
01CE0:  MOVFF  02,6E1
01CE4:  MOVFF  01,6E0
01CE8:  MOVFF  00,6DF
01CEC:  MOVLW  A4
01CEE:  MOVLB  6
01CF0:  MOVWF  xE6
01CF2:  MOVLW  DB
01CF4:  MOVWF  xE5
01CF6:  MOVLW  67
01CF8:  MOVWF  xE4
01CFA:  MOVLW  83
01CFC:  MOVWF  xE3
01CFE:  MOVLB  0
01D00:  CALL   0F28
01D04:  MOVFF  03,6CC
01D08:  MOVFF  02,6CB
01D0C:  MOVFF  01,6CA
01D10:  MOVFF  00,6C9
....................    r = r*y*y + qat[3];
01D14:  MOVFF  6CC,6E3
01D18:  MOVFF  6CB,6E2
01D1C:  MOVFF  6CA,6E1
01D20:  MOVFF  6C9,6E0
01D24:  MOVFF  6C4,6E7
01D28:  MOVFF  6C3,6E6
01D2C:  MOVFF  6C2,6E5
01D30:  MOVFF  6C1,6E4
01D34:  CALL   0E32
01D38:  MOVFF  03,6D1
01D3C:  MOVFF  02,6D0
01D40:  MOVFF  01,6CF
01D44:  MOVFF  00,6CE
01D48:  MOVFF  03,6E3
01D4C:  MOVFF  02,6E2
01D50:  MOVFF  01,6E1
01D54:  MOVFF  00,6E0
01D58:  MOVFF  6C4,6E7
01D5C:  MOVFF  6C3,6E6
01D60:  MOVFF  6C2,6E5
01D64:  MOVFF  6C1,6E4
01D68:  CALL   0E32
01D6C:  MOVFF  03,6D1
01D70:  MOVFF  02,6D0
01D74:  MOVFF  01,6CF
01D78:  MOVFF  00,6CE
01D7C:  BCF    FD8.1
01D7E:  MOVFF  03,6E2
01D82:  MOVFF  02,6E1
01D86:  MOVFF  01,6E0
01D8A:  MOVFF  00,6DF
01D8E:  MOVLW  33
01D90:  MOVLB  6
01D92:  MOVWF  xE6
01D94:  MOVLW  8C
01D96:  MOVWF  xE5
01D98:  MOVLW  1E
01D9A:  MOVWF  xE4
01D9C:  MOVLW  83
01D9E:  MOVWF  xE3
01DA0:  MOVLB  0
01DA2:  CALL   0F28
01DA6:  MOVFF  03,6CC
01DAA:  MOVFF  02,6CB
01DAE:  MOVFF  01,6CA
01DB2:  MOVFF  00,6C9
.................... 
....................    res = y*res/r;
01DB6:  MOVFF  6C4,6E3
01DBA:  MOVFF  6C3,6E2
01DBE:  MOVFF  6C2,6E1
01DC2:  MOVFF  6C1,6E0
01DC6:  MOVFF  6C8,6E7
01DCA:  MOVFF  6C7,6E6
01DCE:  MOVFF  6C6,6E5
01DD2:  MOVFF  6C5,6E4
01DD6:  CALL   0E32
01DDA:  MOVFF  03,6D1
01DDE:  MOVFF  02,6D0
01DE2:  MOVFF  01,6CF
01DE6:  MOVFF  00,6CE
01DEA:  MOVFF  03,6D7
01DEE:  MOVFF  02,6D6
01DF2:  MOVFF  01,6D5
01DF6:  MOVFF  00,6D4
01DFA:  MOVFF  6CC,6DB
01DFE:  MOVFF  6CB,6DA
01E02:  MOVFF  6CA,6D9
01E06:  MOVFF  6C9,6D8
01E0A:  RCALL  17F2
01E0C:  MOVFF  03,6C8
01E10:  MOVFF  02,6C7
01E14:  MOVFF  01,6C6
01E18:  MOVFF  00,6C5
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
01E1C:  MOVLB  6
01E1E:  BTFSS  xCD.1
01E20:  BRA    1E5C
....................       res = PI_DIV_BY_TWO - res;
01E22:  BSF    FD8.1
01E24:  MOVLW  DB
01E26:  MOVWF  xE2
01E28:  MOVLW  0F
01E2A:  MOVWF  xE1
01E2C:  MOVLW  49
01E2E:  MOVWF  xE0
01E30:  MOVLW  7F
01E32:  MOVWF  xDF
01E34:  MOVFF  6C8,6E6
01E38:  MOVFF  6C7,6E5
01E3C:  MOVFF  6C6,6E4
01E40:  MOVFF  6C5,6E3
01E44:  MOVLB  0
01E46:  CALL   0F28
01E4A:  MOVFF  03,6C8
01E4E:  MOVFF  02,6C7
01E52:  MOVFF  01,6C6
01E56:  MOVFF  00,6C5
01E5A:  MOVLB  6
....................    if (s)
01E5C:  BTFSS  xCD.0
01E5E:  BRA    1E66
....................       res = -res;
01E60:  MOVF   xC6,W
01E62:  XORLW  80
01E64:  MOVWF  xC6
.................... 
....................    return(res);
01E66:  MOVFF  6C5,00
01E6A:  MOVFF  6C6,01
01E6E:  MOVFF  6C7,02
01E72:  MOVFF  6C8,03
01E76:  MOVLB  0
01E78:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01E7A:  MOVLB  6
01E7C:  BCF    xBB.0
....................    quad=0; //quadrant
01E7E:  CLRF   xBC
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01E80:  MOVFF  6B2,6DE
01E84:  MOVFF  6B1,6DD
01E88:  MOVFF  6B0,6DC
01E8C:  MOVFF  6AF,6DB
01E90:  CLRF   xE2
01E92:  CLRF   xE1
01E94:  CLRF   xE0
01E96:  CLRF   xDF
01E98:  MOVLB  0
01E9A:  RCALL  1778
01E9C:  BC    1EA0
01E9E:  BNZ   1ECA
01EA0:  MOVFF  6B6,6DE
01EA4:  MOVFF  6B5,6DD
01EA8:  MOVFF  6B4,6DC
01EAC:  MOVFF  6B3,6DB
01EB0:  MOVLB  6
01EB2:  CLRF   xE2
01EB4:  CLRF   xE1
01EB6:  CLRF   xE0
01EB8:  CLRF   xDF
01EBA:  MOVLB  0
01EBC:  RCALL  1778
01EBE:  BC    1EC2
01EC0:  BNZ   1EC6
01EC2:  MOVLW  03
01EC4:  BRA    1EC8
01EC6:  MOVLW  04
01EC8:  BRA    1EF0
01ECA:  MOVFF  6B6,6DE
01ECE:  MOVFF  6B5,6DD
01ED2:  MOVFF  6B4,6DC
01ED6:  MOVFF  6B3,6DB
01EDA:  MOVLB  6
01EDC:  CLRF   xE2
01EDE:  CLRF   xE1
01EE0:  CLRF   xE0
01EE2:  CLRF   xDF
01EE4:  MOVLB  0
01EE6:  RCALL  1778
01EE8:  BNC   1EEE
01EEA:  MOVLW  02
01EEC:  BRA    1EF0
01EEE:  MOVLW  01
01EF0:  MOVLB  6
01EF2:  MOVWF  xBC
....................    if(y<0.0)
01EF4:  MOVFF  6B2,6DE
01EF8:  MOVFF  6B1,6DD
01EFC:  MOVFF  6B0,6DC
01F00:  MOVFF  6AF,6DB
01F04:  CLRF   xE2
01F06:  CLRF   xE1
01F08:  CLRF   xE0
01F0A:  CLRF   xDF
01F0C:  MOVLB  0
01F0E:  RCALL  1778
01F10:  BNC   1F1E
....................    {
....................       sign=1;
01F12:  MOVLB  6
01F14:  BSF    xBB.0
....................       y=-y;
01F16:  MOVF   xB0,W
01F18:  XORLW  80
01F1A:  MOVWF  xB0
01F1C:  MOVLB  0
....................    }
....................    if(x<0.0)
01F1E:  MOVFF  6B6,6DE
01F22:  MOVFF  6B5,6DD
01F26:  MOVFF  6B4,6DC
01F2A:  MOVFF  6B3,6DB
01F2E:  MOVLB  6
01F30:  CLRF   xE2
01F32:  CLRF   xE1
01F34:  CLRF   xE0
01F36:  CLRF   xDF
01F38:  MOVLB  0
01F3A:  RCALL  1778
01F3C:  BNC   1F48
....................    {
....................       x=-x;
01F3E:  MOVLB  6
01F40:  MOVF   xB4,W
01F42:  XORLW  80
01F44:  MOVWF  xB4
01F46:  MOVLB  0
....................    }
....................    if (x==0.0)
01F48:  MOVFF  6B6,6DE
01F4C:  MOVFF  6B5,6DD
01F50:  MOVFF  6B4,6DC
01F54:  MOVFF  6B3,6DB
01F58:  MOVLB  6
01F5A:  CLRF   xE2
01F5C:  CLRF   xE1
01F5E:  CLRF   xE0
01F60:  CLRF   xDF
01F62:  MOVLB  0
01F64:  RCALL  1778
01F66:  BNZ   1FBC
....................    {
....................       if(y==0.0)
01F68:  MOVFF  6B2,6DE
01F6C:  MOVFF  6B1,6DD
01F70:  MOVFF  6B0,6DC
01F74:  MOVFF  6AF,6DB
01F78:  MOVLB  6
01F7A:  CLRF   xE2
01F7C:  CLRF   xE1
01F7E:  CLRF   xE0
01F80:  CLRF   xDF
01F82:  MOVLB  0
01F84:  CALL   1778
01F88:  BNZ   1F8C
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01F8A:  BRA    1FBA
....................       else
....................       {
....................          if(sign)
01F8C:  MOVLB  6
01F8E:  BTFSS  xBB.0
01F90:  BRA    1FA6
....................          {
....................          return (-(PI_DIV_BY_TWO));
01F92:  MOVLW  7F
01F94:  MOVWF  00
01F96:  MOVLW  C9
01F98:  MOVWF  01
01F9A:  MOVLW  0F
01F9C:  MOVWF  02
01F9E:  MOVLW  DB
01FA0:  MOVWF  03
01FA2:  BRA    20F4
....................          }
01FA4:  BRA    1FB8
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01FA6:  MOVLW  7F
01FA8:  MOVWF  00
01FAA:  MOVLW  49
01FAC:  MOVWF  01
01FAE:  MOVLW  0F
01FB0:  MOVWF  02
01FB2:  MOVLW  DB
01FB4:  MOVWF  03
01FB6:  BRA    20F4
01FB8:  MOVLB  0
....................          }
....................       }
....................    }
01FBA:  BRA    20F2
....................    else
....................    {
....................       z=y/x;
01FBC:  MOVFF  6B2,6D7
01FC0:  MOVFF  6B1,6D6
01FC4:  MOVFF  6B0,6D5
01FC8:  MOVFF  6AF,6D4
01FCC:  MOVFF  6B6,6DB
01FD0:  MOVFF  6B5,6DA
01FD4:  MOVFF  6B4,6D9
01FD8:  MOVFF  6B3,6D8
01FDC:  RCALL  17F2
01FDE:  MOVFF  03,6BA
01FE2:  MOVFF  02,6B9
01FE6:  MOVFF  01,6B8
01FEA:  MOVFF  00,6B7
....................       switch(quad)
01FEE:  MOVLW  01
01FF0:  MOVLB  6
01FF2:  SUBWF  xBC,W
01FF4:  ADDLW  FC
01FF6:  BTFSC  FD8.0
01FF8:  BRA    20F4
01FFA:  ADDLW  04
01FFC:  MOVLB  0
01FFE:  GOTO   20FA
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02002:  MOVFF  6BA,6C0
02006:  MOVFF  6B9,6BF
0200A:  MOVFF  6B8,6BE
0200E:  MOVFF  6B7,6BD
02012:  RCALL  1950
02014:  MOVLB  6
02016:  BRA    20F4
....................             break;
02018:  BRA    20F4
0201A:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
0201C:  MOVFF  6BA,6C0
02020:  MOVFF  6B9,6BF
02024:  MOVFF  6B8,6BE
02028:  MOVFF  6B7,6BD
0202C:  RCALL  1950
0202E:  MOVFF  FEA,6BE
02032:  MOVFF  FE9,6BD
02036:  BSF    FD8.1
02038:  MOVLW  DB
0203A:  MOVLB  6
0203C:  MOVWF  xE2
0203E:  MOVLW  0F
02040:  MOVWF  xE1
02042:  MOVLW  49
02044:  MOVWF  xE0
02046:  MOVLW  80
02048:  MOVWF  xDF
0204A:  MOVFF  03,6E6
0204E:  MOVFF  02,6E5
02052:  MOVFF  01,6E4
02056:  MOVFF  00,6E3
0205A:  MOVLB  0
0205C:  CALL   0F28
02060:  MOVFF  6BE,FEA
02064:  MOVFF  6BD,FE9
02068:  MOVLB  6
0206A:  BRA    20F4
....................             break;
0206C:  BRA    20F4
0206E:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02070:  MOVFF  6BA,6C0
02074:  MOVFF  6B9,6BF
02078:  MOVFF  6B8,6BE
0207C:  MOVFF  6B7,6BD
02080:  RCALL  1950
02082:  MOVFF  03,6C0
02086:  MOVFF  02,6BF
0208A:  MOVFF  01,6BE
0208E:  MOVFF  00,6BD
02092:  MOVFF  FEA,6C2
02096:  MOVFF  FE9,6C1
0209A:  BSF    FD8.1
0209C:  MOVFF  03,6E2
020A0:  MOVFF  02,6E1
020A4:  MOVFF  01,6E0
020A8:  MOVFF  00,6DF
020AC:  MOVLW  DB
020AE:  MOVLB  6
020B0:  MOVWF  xE6
020B2:  MOVLW  0F
020B4:  MOVWF  xE5
020B6:  MOVLW  49
020B8:  MOVWF  xE4
020BA:  MOVLW  80
020BC:  MOVWF  xE3
020BE:  MOVLB  0
020C0:  CALL   0F28
020C4:  MOVFF  6C2,FEA
020C8:  MOVFF  6C1,FE9
020CC:  MOVLB  6
020CE:  BRA    20F4
....................             break;
020D0:  BRA    20F4
020D2:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
020D4:  MOVFF  6BA,6C0
020D8:  MOVFF  6B9,6BF
020DC:  MOVFF  6B8,6BE
020E0:  MOVFF  6B7,6BD
020E4:  RCALL  1950
020E6:  MOVLW  80
020E8:  XORWF  01,F
020EA:  MOVLB  6
020EC:  BRA    20F4
....................             break;
020EE:  BRA    20F4
020F0:  MOVLB  0
020F2:  MOVLB  6
....................          }
....................       }
....................    }
020F4:  MOVLB  0
020F6:  GOTO   3800 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 8
.................... typedef struct {
....................    signed int8 in;
.................... //!   signed int8 out;
....................    signed int32 buff[BUFFER_SIZE];
.................... } buffer;
.................... 
.................... buffer sinQ_x;
.................... buffer cosQ_x;
.................... buffer sinQ_y;
.................... buffer cosQ_y;
.................... 
.................... //!#define incin(buff) ((buff->in==(BUFFER_SIZE-1))?0:buff->in+1)
.................... //!#define incout(buff) ((buff->out==(BUFFER_SIZE-1))?0:buff->out+1)
.................... //!#define isempty(buff) (buff->in==buff->out)
.................... //!#define hasdata(buff) (buff->in!=buff->out)
.................... //!#define isfull(buff) (incin(buff)==buff->out)
.................... //!
.................... //!#define tobuff(bname,c) { bname->buff[bname->in]=c;\
.................... //!   bname->in=incin(bname);\
.................... //!   if (bname->in==bname->out) bname->out=incout(bname);\
.................... //!   }
.................... //!#define frombuff(bname) (btemp##bname=bname->buff[bname->out],\
.................... //!   bname->out=incout(bname), \
.................... //!   btemp##bname)
.................... //!#define clrbuff(buff) buff->in=buff->out=0
.................... 
.................... //!#define COMPARE(a,b) (((a) > (b)) - ((a) < (b)))
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    buffer* sinQ;
....................    buffer* cosQ;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, &sinQ_x, &cosQ_x, 0, 0},
....................    {false, false, &sinQ_y, &cosQ_y, 0, 0}
.................... };
.................... 
.................... signed int compar(void *a, void *b) {
....................     signed int32 a_t = (signed int32)a;
....................     signed int32 b_t = (signed int32)b;
.................... 
....................     signed int32 a_p = (*(signed int32)a);
....................     signed int32 b_p = (*(signed int32)b);
....................     
....................     if ( a_p < b_p ) return -1;
....................     else if ( a_p == b_p ) return 0;
....................     else return 1;
.................... //!    return COMPARE(a,b);
.................... }
.................... 
.................... void push(buffer* q, signed int32 newData) {
....................    q->buff[q->in]=newData;
*
00902:  MOVLB  6
00904:  MOVFF  69D,FE9
00908:  MOVFF  69E,FEA
0090C:  CLRF   xA4
0090E:  MOVFF  FEF,6A3
00912:  BTFSC  xA3.7
00914:  DECF   xA4,F
00916:  MOVFF  6A4,6F8
0091A:  MOVFF  6A3,6F7
0091E:  CLRF   xFA
00920:  MOVLW  04
00922:  MOVWF  xF9
00924:  MOVLB  0
00926:  RCALL  0860
00928:  MOVFF  02,03
0092C:  MOVF   01,W
0092E:  ADDLW  01
00930:  MOVWF  01
00932:  MOVLW  00
00934:  ADDWFC 03,F
00936:  MOVF   01,W
00938:  MOVLB  6
0093A:  ADDWF  x9D,W
0093C:  MOVWF  FE9
0093E:  MOVF   x9E,W
00940:  ADDWFC 03,W
00942:  MOVWF  FEA
00944:  MOVFF  69F,FEF
00948:  MOVFF  6A0,FEC
0094C:  MOVFF  6A1,FEC
00950:  MOVFF  6A2,FEC
....................    q->in=(q->in+1) % BUFFER_SIZE;
00954:  MOVFF  69D,6A3
00958:  MOVFF  69E,6A4
0095C:  MOVFF  69D,FE9
00960:  MOVFF  69E,FEA
00964:  MOVLW  01
00966:  ADDWF  FEF,W
00968:  MOVWF  xA6
0096A:  MOVWF  xA7
0096C:  MOVLW  08
0096E:  MOVWF  xA8
00970:  MOVLB  0
00972:  BRA    08B4
00974:  MOVLB  6
00976:  MOVFF  6A4,FEA
0097A:  MOVFF  6A3,FE9
0097E:  MOVFF  00,FEF
00982:  MOVLB  0
00984:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
011A0:  MOVLB  F
011A2:  BTFSC  x5B.0
011A4:  BRA    16F0
....................    {
....................       switch (state)
011A6:  MOVLB  2
011A8:  MOVF   x03,W
011AA:  ADDLW  F9
011AC:  BTFSC  FD8.0
011AE:  BRA    16EE
011B0:  ADDLW  07
011B2:  MOVLB  0
011B4:  GOTO   16F6
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
011B8:  MOVLB  F
011BA:  BTFSC  x5B.0
011BC:  BRA    11BA
011BE:  MOVFF  F5F,02
011C2:  MOVFF  F5E,01
011C6:  MOVFF  02,691
011CA:  MOVFF  01,690
011CE:  MOVFF  02,6E0
011D2:  MOVFF  01,6DF
011D6:  MOVLB  0
011D8:  RCALL  0DFC
011DA:  MOVFF  03,6E3
011DE:  MOVFF  02,6E2
011E2:  MOVFF  01,6E1
011E6:  MOVFF  00,6E0
011EA:  MOVFF  B9,6E7
011EE:  MOVFF  B8,6E6
011F2:  MOVFF  B7,6E5
011F6:  MOVFF  B6,6E4
011FA:  RCALL  0E32
011FC:  MOVFF  03,693
01200:  MOVFF  02,692
01204:  MOVFF  01,691
01208:  MOVFF  00,690
0120C:  BCF    FD8.1
0120E:  MOVFF  03,6E2
01212:  MOVFF  02,6E1
01216:  MOVFF  01,6E0
0121A:  MOVFF  00,6DF
0121E:  MOVFF  B5,6E6
01222:  MOVFF  B4,6E5
01226:  MOVFF  B3,6E4
0122A:  MOVFF  B2,6E3
0122E:  RCALL  0F28
01230:  MOVFF  03,F6
01234:  MOVFF  02,F5
01238:  MOVFF  01,F4
0123C:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
01240:  MOVLB  F
01242:  MOVF   x5A,W
01244:  ANDLW  3F
01246:  MOVWF  01
01248:  MOVLW  10
0124A:  MOVWF  x5A
0124C:  BTFSS  x5B.7
0124E:  BRA    125E
01250:  MOVF   01,W
01252:  SUBLW  10
01254:  BZ    125E
01256:  BSF    x5B.0
01258:  NOP   
0125A:  BTFSC  x5B.0
0125C:  BRA    125A
....................             delay_ms(10);
0125E:  MOVLW  0A
01260:  MOVLB  6
01262:  MOVWF  x98
01264:  MOVLB  0
01266:  CALL   0430
....................             read_adc(ADC_START_ONLY);
0126A:  MOVLB  F
0126C:  BSF    x5B.0
0126E:  NOP   
....................             state = 1;
01270:  MOVLW  01
01272:  MOVLB  2
01274:  MOVWF  x03
....................          break;
01276:  BRA    16EE
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01278:  MOVLB  F
0127A:  BTFSC  x5B.0
0127C:  BRA    127A
0127E:  MOVFF  F5F,02
01282:  MOVFF  F5E,01
01286:  MOVFF  02,691
0128A:  MOVFF  01,690
0128E:  MOVFF  02,6E0
01292:  MOVFF  01,6DF
01296:  MOVLB  0
01298:  RCALL  0DFC
0129A:  MOVFF  03,6E3
0129E:  MOVFF  02,6E2
012A2:  MOVFF  01,6E1
012A6:  MOVFF  00,6E0
012AA:  MOVFF  C1,6E7
012AE:  MOVFF  C0,6E6
012B2:  MOVFF  BF,6E5
012B6:  MOVFF  BE,6E4
012BA:  RCALL  0E32
012BC:  MOVFF  03,693
012C0:  MOVFF  02,692
012C4:  MOVFF  01,691
012C8:  MOVFF  00,690
012CC:  BCF    FD8.1
012CE:  MOVFF  03,6E2
012D2:  MOVFF  02,6E1
012D6:  MOVFF  01,6E0
012DA:  MOVFF  00,6DF
012DE:  MOVFF  BD,6E6
012E2:  MOVFF  BC,6E5
012E6:  MOVFF  BB,6E4
012EA:  MOVFF  BA,6E3
012EE:  RCALL  0F28
012F0:  MOVFF  03,FA
012F4:  MOVFF  02,F9
012F8:  MOVFF  01,F8
012FC:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
01300:  MOVLB  F
01302:  MOVF   x5A,W
01304:  ANDLW  3F
01306:  MOVWF  01
01308:  MOVLW  18
0130A:  MOVWF  x5A
0130C:  BTFSS  x5B.7
0130E:  BRA    131E
01310:  MOVF   01,W
01312:  SUBLW  18
01314:  BZ    131E
01316:  BSF    x5B.0
01318:  NOP   
0131A:  BTFSC  x5B.0
0131C:  BRA    131A
....................             delay_ms(10);
0131E:  MOVLW  0A
01320:  MOVLB  6
01322:  MOVWF  x98
01324:  MOVLB  0
01326:  CALL   0430
....................             read_adc(ADC_START_ONLY);
0132A:  MOVLB  F
0132C:  BSF    x5B.0
0132E:  NOP   
....................             state = 2;
01330:  MOVLW  02
01332:  MOVLB  2
01334:  MOVWF  x03
....................          break;
01336:  BRA    16EE
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01338:  MOVLB  F
0133A:  BTFSC  x5B.0
0133C:  BRA    133A
0133E:  MOVFF  F5F,02
01342:  MOVFF  F5E,01
01346:  MOVFF  02,691
0134A:  MOVFF  01,690
0134E:  MOVFF  02,6E0
01352:  MOVFF  01,6DF
01356:  MOVLB  0
01358:  RCALL  0DFC
0135A:  MOVFF  03,6E3
0135E:  MOVFF  02,6E2
01362:  MOVFF  01,6E1
01366:  MOVFF  00,6E0
0136A:  MOVFF  C9,6E7
0136E:  MOVFF  C8,6E6
01372:  MOVFF  C7,6E5
01376:  MOVFF  C6,6E4
0137A:  RCALL  0E32
0137C:  MOVFF  03,693
01380:  MOVFF  02,692
01384:  MOVFF  01,691
01388:  MOVFF  00,690
0138C:  BCF    FD8.1
0138E:  MOVFF  03,6E2
01392:  MOVFF  02,6E1
01396:  MOVFF  01,6E0
0139A:  MOVFF  00,6DF
0139E:  MOVFF  C5,6E6
013A2:  MOVFF  C4,6E5
013A6:  MOVFF  C3,6E4
013AA:  MOVFF  C2,6E3
013AE:  RCALL  0F28
013B0:  MOVFF  03,FE
013B4:  MOVFF  02,FD
013B8:  MOVFF  01,FC
013BC:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
013C0:  MOVLB  F
013C2:  MOVF   x5A,W
013C4:  ANDLW  3F
013C6:  MOVWF  01
013C8:  MOVLW  19
013CA:  MOVWF  x5A
013CC:  BTFSS  x5B.7
013CE:  BRA    13DE
013D0:  MOVF   01,W
013D2:  SUBLW  19
013D4:  BZ    13DE
013D6:  BSF    x5B.0
013D8:  NOP   
013DA:  BTFSC  x5B.0
013DC:  BRA    13DA
....................             delay_ms(10);
013DE:  MOVLW  0A
013E0:  MOVLB  6
013E2:  MOVWF  x98
013E4:  MOVLB  0
013E6:  CALL   0430
....................             read_adc(ADC_START_ONLY);
013EA:  MOVLB  F
013EC:  BSF    x5B.0
013EE:  NOP   
....................             state = 3;
013F0:  MOVLW  03
013F2:  MOVLB  2
013F4:  MOVWF  x03
....................          break;
013F6:  BRA    16EE
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
013F8:  MOVLB  F
013FA:  BTFSC  x5B.0
013FC:  BRA    13FA
013FE:  MOVFF  F5F,02
01402:  MOVFF  F5E,01
01406:  MOVFF  02,691
0140A:  MOVFF  01,690
0140E:  MOVFF  02,6E0
01412:  MOVFF  01,6DF
01416:  MOVLB  0
01418:  RCALL  0DFC
0141A:  MOVFF  03,6E3
0141E:  MOVFF  02,6E2
01422:  MOVFF  01,6E1
01426:  MOVFF  00,6E0
0142A:  MOVFF  D1,6E7
0142E:  MOVFF  D0,6E6
01432:  MOVFF  CF,6E5
01436:  MOVFF  CE,6E4
0143A:  RCALL  0E32
0143C:  MOVFF  03,693
01440:  MOVFF  02,692
01444:  MOVFF  01,691
01448:  MOVFF  00,690
0144C:  BCF    FD8.1
0144E:  MOVFF  03,6E2
01452:  MOVFF  02,6E1
01456:  MOVFF  01,6E0
0145A:  MOVFF  00,6DF
0145E:  MOVFF  CD,6E6
01462:  MOVFF  CC,6E5
01466:  MOVFF  CB,6E4
0146A:  MOVFF  CA,6E3
0146E:  RCALL  0F28
01470:  MOVFF  03,102
01474:  MOVFF  02,101
01478:  MOVFF  01,100
0147C:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01480:  MOVLB  F
01482:  MOVF   x5A,W
01484:  ANDLW  3F
01486:  MOVWF  01
01488:  MOVLW  11
0148A:  MOVWF  x5A
0148C:  BTFSS  x5B.7
0148E:  BRA    149E
01490:  MOVF   01,W
01492:  SUBLW  11
01494:  BZ    149E
01496:  BSF    x5B.0
01498:  NOP   
0149A:  BTFSC  x5B.0
0149C:  BRA    149A
....................             delay_ms(10);
0149E:  MOVLW  0A
014A0:  MOVLB  6
014A2:  MOVWF  x98
014A4:  MOVLB  0
014A6:  CALL   0430
....................             read_adc(ADC_START_ONLY);
014AA:  MOVLB  F
014AC:  BSF    x5B.0
014AE:  NOP   
....................             state = 4;
014B0:  MOVLW  04
014B2:  MOVLB  2
014B4:  MOVWF  x03
....................          break;
014B6:  BRA    16EE
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
014B8:  MOVLB  F
014BA:  BTFSC  x5B.0
014BC:  BRA    14BA
014BE:  MOVFF  F5F,02
014C2:  MOVFF  F5E,01
014C6:  MOVFF  02,691
014CA:  MOVFF  01,690
014CE:  MOVFF  02,6E0
014D2:  MOVFF  01,6DF
014D6:  MOVLB  0
014D8:  RCALL  0DFC
014DA:  MOVFF  03,6E3
014DE:  MOVFF  02,6E2
014E2:  MOVFF  01,6E1
014E6:  MOVFF  00,6E0
014EA:  MOVFF  D9,6E7
014EE:  MOVFF  D8,6E6
014F2:  MOVFF  D7,6E5
014F6:  MOVFF  D6,6E4
014FA:  RCALL  0E32
014FC:  MOVFF  03,693
01500:  MOVFF  02,692
01504:  MOVFF  01,691
01508:  MOVFF  00,690
0150C:  BCF    FD8.1
0150E:  MOVFF  03,6E2
01512:  MOVFF  02,6E1
01516:  MOVFF  01,6E0
0151A:  MOVFF  00,6DF
0151E:  MOVFF  D5,6E6
01522:  MOVFF  D4,6E5
01526:  MOVFF  D3,6E4
0152A:  MOVFF  D2,6E3
0152E:  RCALL  0F28
01530:  MOVFF  03,106
01534:  MOVFF  02,105
01538:  MOVFF  01,104
0153C:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01540:  MOVLB  F
01542:  MOVF   x5A,W
01544:  ANDLW  3F
01546:  MOVWF  01
01548:  MOVLW  1B
0154A:  MOVWF  x5A
0154C:  BTFSS  x5B.7
0154E:  BRA    155E
01550:  MOVF   01,W
01552:  SUBLW  1B
01554:  BZ    155E
01556:  BSF    x5B.0
01558:  NOP   
0155A:  BTFSC  x5B.0
0155C:  BRA    155A
....................             delay_ms(10);
0155E:  MOVLW  0A
01560:  MOVLB  6
01562:  MOVWF  x98
01564:  MOVLB  0
01566:  CALL   0430
....................             read_adc(ADC_START_ONLY);
0156A:  MOVLB  F
0156C:  BSF    x5B.0
0156E:  NOP   
....................             state = 5;
01570:  MOVLW  05
01572:  MOVLB  2
01574:  MOVWF  x03
....................          break;
01576:  BRA    16EE
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01578:  MOVLB  F
0157A:  BTFSC  x5B.0
0157C:  BRA    157A
0157E:  MOVFF  F5F,02
01582:  MOVFF  F5E,01
01586:  MOVFF  02,691
0158A:  MOVFF  01,690
0158E:  MOVFF  02,6E0
01592:  MOVFF  01,6DF
01596:  MOVLB  0
01598:  RCALL  0DFC
0159A:  MOVFF  03,6E3
0159E:  MOVFF  02,6E2
015A2:  MOVFF  01,6E1
015A6:  MOVFF  00,6E0
015AA:  MOVFF  E1,6E7
015AE:  MOVFF  E0,6E6
015B2:  MOVFF  DF,6E5
015B6:  MOVFF  DE,6E4
015BA:  RCALL  0E32
015BC:  MOVFF  03,693
015C0:  MOVFF  02,692
015C4:  MOVFF  01,691
015C8:  MOVFF  00,690
015CC:  BCF    FD8.1
015CE:  MOVFF  03,6E2
015D2:  MOVFF  02,6E1
015D6:  MOVFF  01,6E0
015DA:  MOVFF  00,6DF
015DE:  MOVFF  DD,6E6
015E2:  MOVFF  DC,6E5
015E6:  MOVFF  DB,6E4
015EA:  MOVFF  DA,6E3
015EE:  RCALL  0F28
015F0:  MOVFF  03,10A
015F4:  MOVFF  02,109
015F8:  MOVFF  01,108
015FC:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01600:  MOVLB  F
01602:  MOVF   x5A,W
01604:  ANDLW  3F
01606:  MOVWF  01
01608:  MOVLW  1A
0160A:  MOVWF  x5A
0160C:  BTFSS  x5B.7
0160E:  BRA    161E
01610:  MOVF   01,W
01612:  SUBLW  1A
01614:  BZ    161E
01616:  BSF    x5B.0
01618:  NOP   
0161A:  BTFSC  x5B.0
0161C:  BRA    161A
....................             delay_ms(10);
0161E:  MOVLW  0A
01620:  MOVLB  6
01622:  MOVWF  x98
01624:  MOVLB  0
01626:  CALL   0430
....................             read_adc(ADC_START_ONLY);
0162A:  MOVLB  F
0162C:  BSF    x5B.0
0162E:  NOP   
....................             state = 6;
01630:  MOVLW  06
01632:  MOVLB  2
01634:  MOVWF  x03
....................          break;
01636:  BRA    16EE
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01638:  MOVLB  F
0163A:  BTFSC  x5B.0
0163C:  BRA    163A
0163E:  MOVFF  F5F,02
01642:  MOVFF  F5E,01
01646:  MOVFF  02,691
0164A:  MOVFF  01,690
0164E:  MOVFF  02,6E0
01652:  MOVFF  01,6DF
01656:  MOVLB  0
01658:  CALL   0DFC
0165C:  MOVFF  03,6E3
01660:  MOVFF  02,6E2
01664:  MOVFF  01,6E1
01668:  MOVFF  00,6E0
0166C:  MOVFF  E9,6E7
01670:  MOVFF  E8,6E6
01674:  MOVFF  E7,6E5
01678:  MOVFF  E6,6E4
0167C:  CALL   0E32
01680:  MOVFF  03,693
01684:  MOVFF  02,692
01688:  MOVFF  01,691
0168C:  MOVFF  00,690
01690:  BCF    FD8.1
01692:  MOVFF  03,6E2
01696:  MOVFF  02,6E1
0169A:  MOVFF  01,6E0
0169E:  MOVFF  00,6DF
016A2:  MOVFF  E5,6E6
016A6:  MOVFF  E4,6E5
016AA:  MOVFF  E3,6E4
016AE:  MOVFF  E2,6E3
016B2:  RCALL  0F28
016B4:  MOVFF  03,10E
016B8:  MOVFF  02,10D
016BC:  MOVFF  01,10C
016C0:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
016C4:  MOVLB  F
016C6:  MOVF   x5A,W
016C8:  ANDLW  3F
016CA:  MOVWF  01
016CC:  MOVLW  06
016CE:  MOVWF  x5A
016D0:  BTFSS  x5B.7
016D2:  BRA    16E2
016D4:  MOVF   01,W
016D6:  SUBLW  06
016D8:  BZ    16E2
016DA:  BSF    x5B.0
016DC:  NOP   
016DE:  BTFSC  x5B.0
016E0:  BRA    16DE
....................             read_adc(ADC_START_ONLY);
016E2:  BSF    x5B.0
016E4:  NOP   
....................             state = 0;
016E6:  MOVLB  2
016E8:  CLRF   x03
....................          break;   
016EA:  BRA    16EE
016EC:  MOVLB  2
016EE:  MOVLB  F
....................       }
....................    }
016F0:  MOVLB  0
016F2:  GOTO   A00E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch)//, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03158:  MOVLB  6
0315A:  MOVF   x98,W
0315C:  MULLW  21
0315E:  MOVF   FF3,W
03160:  CLRF   xA2
03162:  MOVWF  xA1
03164:  MOVLW  10
03166:  ADDWF  xA1,W
03168:  MOVWF  01
0316A:  MOVLW  00
0316C:  ADDWFC xA2,W
0316E:  MOVWF  03
03170:  MOVF   01,W
03172:  ADDLW  0F
03174:  MOVWF  01
03176:  MOVLW  01
03178:  ADDWFC 03,F
0317A:  MOVFF  01,6A1
0317E:  MOVFF  03,6A2
03182:  MOVF   x98,W
03184:  MULLW  21
03186:  MOVF   FF3,W
03188:  CLRF   xA4
0318A:  MOVWF  xA3
0318C:  MOVLW  08
0318E:  ADDWF  xA3,W
03190:  MOVWF  01
03192:  MOVLW  00
03194:  ADDWFC xA4,W
03196:  MOVWF  03
03198:  MOVF   01,W
0319A:  ADDLW  0F
0319C:  MOVWF  FE9
0319E:  MOVLW  01
031A0:  ADDWFC 03,W
031A2:  MOVWF  FEA
031A4:  MOVFF  FEF,00
031A8:  MOVFF  FEC,01
031AC:  MOVFF  FEC,02
031B0:  MOVFF  FEC,03
031B4:  MOVFF  6A2,FEA
031B8:  MOVFF  6A1,FE9
031BC:  MOVFF  00,FEF
031C0:  MOVFF  01,FEC
031C4:  MOVFF  02,FEC
031C8:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
031CC:  MOVF   x98,W
031CE:  MULLW  21
031D0:  MOVF   FF3,W
031D2:  CLRF   xA2
031D4:  MOVWF  xA1
031D6:  MOVLW  14
031D8:  ADDWF  xA1,W
031DA:  MOVWF  01
031DC:  MOVLW  00
031DE:  ADDWFC xA2,W
031E0:  MOVWF  03
031E2:  MOVF   01,W
031E4:  ADDLW  0F
031E6:  MOVWF  01
031E8:  MOVLW  01
031EA:  ADDWFC 03,F
031EC:  MOVFF  01,6A1
031F0:  MOVFF  03,6A2
031F4:  MOVF   x98,W
031F6:  MULLW  21
031F8:  MOVF   FF3,W
031FA:  CLRF   xA4
031FC:  MOVWF  xA3
031FE:  MOVLW  0C
03200:  ADDWF  xA3,W
03202:  MOVWF  01
03204:  MOVLW  00
03206:  ADDWFC xA4,W
03208:  MOVWF  03
0320A:  MOVF   01,W
0320C:  ADDLW  0F
0320E:  MOVWF  FE9
03210:  MOVLW  01
03212:  ADDWFC 03,W
03214:  MOVWF  FEA
03216:  MOVFF  FEF,00
0321A:  MOVFF  FEC,01
0321E:  MOVFF  FEC,02
03222:  MOVFF  FEC,03
03226:  MOVFF  6A2,FEA
0322A:  MOVFF  6A1,FE9
0322E:  MOVFF  00,FEF
03232:  MOVFF  01,FEC
03236:  MOVFF  02,FEC
0323A:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
0323E:  MOVF   x98,W
03240:  MULLW  21
03242:  MOVF   FF3,W
03244:  CLRF   xA2
03246:  MOVWF  xA1
03248:  MOVLW  0F
0324A:  ADDWF  xA1,W
0324C:  MOVWF  01
0324E:  MOVLW  01
03250:  ADDWFC xA2,W
03252:  MOVWF  03
03254:  MOVFF  01,6A3
03258:  MOVWF  xA4
0325A:  MOVF   x98,W
0325C:  MULLW  0D
0325E:  MOVF   FF3,W
03260:  CLRF   xA6
03262:  MOVWF  xA5
03264:  MOVLW  05
03266:  ADDWF  xA5,W
03268:  MOVWF  01
0326A:  MOVLW  00
0326C:  ADDWFC xA6,W
0326E:  MOVWF  03
03270:  MOVF   01,W
03272:  ADDLW  E9
03274:  MOVWF  FE9
03276:  MOVLW  01
03278:  ADDWFC 03,W
0327A:  MOVWF  FEA
0327C:  MOVFF  FEF,6A5
03280:  MOVFF  FEC,01
03284:  MOVFF  FEC,02
03288:  MOVFF  FEC,03
0328C:  MOVFF  03,6A8
03290:  MOVFF  02,6A7
03294:  MOVFF  01,6A6
03298:  MOVLB  0
0329A:  CALL   171E
0329E:  MOVFF  6A4,FEA
032A2:  MOVFF  6A3,FE9
032A6:  MOVFF  00,FEF
032AA:  MOVFF  01,FEC
032AE:  MOVFF  02,FEC
032B2:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
032B6:  MOVLB  6
032B8:  MOVF   x98,W
032BA:  MULLW  21
032BC:  MOVF   FF3,W
032BE:  CLRF   xA2
032C0:  MOVWF  xA1
032C2:  MOVLW  04
032C4:  ADDWF  xA1,W
032C6:  MOVWF  01
032C8:  MOVLW  00
032CA:  ADDWFC xA2,W
032CC:  MOVWF  03
032CE:  MOVF   01,W
032D0:  ADDLW  0F
032D2:  MOVWF  01
032D4:  MOVLW  01
032D6:  ADDWFC 03,F
032D8:  MOVFF  01,6A1
032DC:  MOVFF  03,6A2
032E0:  MOVF   x98,W
032E2:  MULLW  0D
032E4:  MOVF   FF3,W
032E6:  CLRF   xA4
032E8:  MOVWF  xA3
032EA:  MOVLW  09
032EC:  ADDWF  xA3,W
032EE:  MOVWF  01
032F0:  MOVLW  00
032F2:  ADDWFC xA4,W
032F4:  MOVWF  03
032F6:  MOVF   01,W
032F8:  ADDLW  E9
032FA:  MOVWF  FE9
032FC:  MOVLW  01
032FE:  ADDWFC 03,W
03300:  MOVWF  FEA
03302:  MOVFF  FEF,6A5
03306:  MOVFF  FEC,01
0330A:  MOVFF  FEC,02
0330E:  MOVFF  FEC,03
03312:  MOVFF  03,6A8
03316:  MOVFF  02,6A7
0331A:  MOVFF  01,6A6
0331E:  MOVLB  0
03320:  CALL   171E
03324:  MOVFF  6A2,FEA
03328:  MOVFF  6A1,FE9
0332C:  MOVFF  00,FEF
03330:  MOVFF  01,FEC
03334:  MOVFF  02,FEC
03338:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
0333C:  MOVLB  6
0333E:  MOVF   x98,W
03340:  MULLW  21
03342:  MOVF   FF3,W
03344:  CLRF   xA2
03346:  MOVWF  xA1
03348:  MOVLW  08
0334A:  ADDWF  xA1,W
0334C:  MOVWF  01
0334E:  MOVLW  00
03350:  ADDWFC xA2,W
03352:  MOVWF  03
03354:  MOVF   01,W
03356:  ADDLW  0F
03358:  MOVWF  01
0335A:  MOVLW  01
0335C:  ADDWFC 03,F
0335E:  MOVFF  01,6A1
03362:  MOVFF  03,6A2
03366:  MOVF   x98,W
03368:  MULLW  21
0336A:  MOVF   FF3,W
0336C:  CLRF   xA4
0336E:  MOVWF  xA3
03370:  MOVLW  0F
03372:  ADDWF  xA3,W
03374:  MOVWF  FE9
03376:  MOVLW  01
03378:  ADDWFC xA4,W
0337A:  MOVWF  FEA
0337C:  MOVFF  FEF,6E0
03380:  MOVFF  FEC,6E1
03384:  MOVFF  FEC,6E2
03388:  MOVFF  FEC,6E3
0338C:  MOVF   x98,W
0338E:  MULLW  10
03390:  MOVF   FF3,W
03392:  CLRF   xAA
03394:  MOVWF  xA9
03396:  MOVLW  08
03398:  ADDWF  xA9,W
0339A:  MOVWF  01
0339C:  MOVLW  00
0339E:  ADDWFC xAA,W
033A0:  MOVWF  03
033A2:  MOVF   01,W
033A4:  ADDLW  62
033A6:  MOVWF  FE9
033A8:  MOVLW  00
033AA:  ADDWFC 03,W
033AC:  MOVWF  FEA
033AE:  MOVFF  FEF,6E4
033B2:  MOVFF  FEC,01
033B6:  MOVFF  FEC,02
033BA:  MOVFF  FEC,03
033BE:  MOVFF  03,6E7
033C2:  MOVFF  02,6E6
033C6:  MOVFF  01,6E5
033CA:  MOVLB  0
033CC:  CALL   0E32
033D0:  MOVFF  03,6E2
033D4:  MOVFF  02,6E1
033D8:  MOVFF  01,6E0
033DC:  MOVFF  00,6DF
033E0:  MOVLB  6
033E2:  MOVF   x98,W
033E4:  MULLW  10
033E6:  MOVF   FF3,W
033E8:  CLRF   xAA
033EA:  MOVWF  xA9
033EC:  MOVLW  62
033EE:  ADDWF  xA9,W
033F0:  MOVWF  FE9
033F2:  MOVLW  00
033F4:  ADDWFC xAA,W
033F6:  MOVWF  FEA
033F8:  MOVFF  FEF,6E3
033FC:  MOVFF  FEC,01
03400:  MOVFF  FEC,02
03404:  MOVFF  FEC,03
03408:  BCF    FD8.1
0340A:  MOVFF  03,6E6
0340E:  MOVFF  02,6E5
03412:  MOVFF  01,6E4
03416:  MOVLB  0
03418:  CALL   0F28
0341C:  MOVFF  6A2,FEA
03420:  MOVFF  6A1,FE9
03424:  MOVFF  00,FEF
03428:  MOVFF  01,FEC
0342C:  MOVFF  02,FEC
03430:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
03434:  MOVLB  6
03436:  MOVF   x98,W
03438:  MULLW  21
0343A:  MOVF   FF3,W
0343C:  CLRF   xA2
0343E:  MOVWF  xA1
03440:  MOVLW  0C
03442:  ADDWF  xA1,W
03444:  MOVWF  01
03446:  MOVLW  00
03448:  ADDWFC xA2,W
0344A:  MOVWF  03
0344C:  MOVF   01,W
0344E:  ADDLW  0F
03450:  MOVWF  01
03452:  MOVLW  01
03454:  ADDWFC 03,F
03456:  MOVFF  01,6A1
0345A:  MOVFF  03,6A2
0345E:  MOVF   x98,W
03460:  MULLW  21
03462:  MOVF   FF3,W
03464:  CLRF   xA4
03466:  MOVWF  xA3
03468:  MOVLW  04
0346A:  ADDWF  xA3,W
0346C:  MOVWF  01
0346E:  MOVLW  00
03470:  ADDWFC xA4,W
03472:  MOVWF  03
03474:  MOVF   01,W
03476:  ADDLW  0F
03478:  MOVWF  FE9
0347A:  MOVLW  01
0347C:  ADDWFC 03,W
0347E:  MOVWF  FEA
03480:  MOVFF  FEF,6E0
03484:  MOVFF  FEC,6E1
03488:  MOVFF  FEC,6E2
0348C:  MOVFF  FEC,6E3
03490:  MOVF   x98,W
03492:  MULLW  10
03494:  MOVF   FF3,W
03496:  CLRF   xA8
03498:  MOVWF  xA7
0349A:  MOVLW  0C
0349C:  ADDWF  xA7,W
0349E:  MOVWF  01
034A0:  MOVLW  00
034A2:  ADDWFC xA8,W
034A4:  MOVWF  03
034A6:  MOVF   01,W
034A8:  ADDLW  62
034AA:  MOVWF  FE9
034AC:  MOVLW  00
034AE:  ADDWFC 03,W
034B0:  MOVWF  FEA
034B2:  MOVFF  FEF,6E4
034B6:  MOVFF  FEC,01
034BA:  MOVFF  FEC,02
034BE:  MOVFF  FEC,03
034C2:  MOVFF  03,6E7
034C6:  MOVFF  02,6E6
034CA:  MOVFF  01,6E5
034CE:  MOVLB  0
034D0:  CALL   0E32
034D4:  MOVFF  03,6E2
034D8:  MOVFF  02,6E1
034DC:  MOVFF  01,6E0
034E0:  MOVFF  00,6DF
034E4:  MOVLB  6
034E6:  MOVF   x98,W
034E8:  MULLW  10
034EA:  MOVF   FF3,W
034EC:  CLRF   xA8
034EE:  MOVWF  xA7
034F0:  MOVLW  04
034F2:  ADDWF  xA7,W
034F4:  MOVWF  01
034F6:  MOVLW  00
034F8:  ADDWFC xA8,W
034FA:  MOVWF  03
034FC:  MOVF   01,W
034FE:  ADDLW  62
03500:  MOVWF  FE9
03502:  MOVLW  00
03504:  ADDWFC 03,W
03506:  MOVWF  FEA
03508:  MOVFF  FEF,6E3
0350C:  MOVFF  FEC,01
03510:  MOVFF  FEC,02
03514:  MOVFF  FEC,03
03518:  BCF    FD8.1
0351A:  MOVFF  03,6E6
0351E:  MOVFF  02,6E5
03522:  MOVFF  01,6E4
03526:  MOVLB  0
03528:  CALL   0F28
0352C:  MOVFF  6A2,FEA
03530:  MOVFF  6A1,FE9
03534:  MOVFF  00,FEF
03538:  MOVFF  01,FEC
0353C:  MOVFF  02,FEC
03540:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03544:  MOVLB  6
03546:  CLRF   x9C
03548:  CLRF   x9B
0354A:  CLRF   x9A
0354C:  CLRF   x99
0354E:  CLRF   xA0
03550:  CLRF   x9F
03552:  CLRF   x9E
03554:  MOVLW  7F
03556:  MOVWF  x9D
....................    
....................    if (adcVals[ch].cosCounts < 0){
03558:  MOVF   x98,W
0355A:  MULLW  21
0355C:  MOVF   FF3,W
0355E:  CLRF   xA2
03560:  MOVWF  xA1
03562:  MOVLW  0C
03564:  ADDWF  xA1,W
03566:  MOVWF  01
03568:  MOVLW  00
0356A:  ADDWFC xA2,W
0356C:  MOVWF  03
0356E:  MOVF   01,W
03570:  ADDLW  0F
03572:  MOVWF  FE9
03574:  MOVLW  01
03576:  ADDWFC 03,W
03578:  MOVWF  FEA
0357A:  MOVFF  FEF,6DB
0357E:  MOVFF  FEC,6DC
03582:  MOVFF  FEC,6DD
03586:  MOVFF  FEC,6DE
0358A:  CLRF   xE2
0358C:  CLRF   xE1
0358E:  CLRF   xE0
03590:  CLRF   xDF
03592:  MOVLB  0
03594:  CALL   1778
03598:  BTFSS  FD8.0
0359A:  BRA    3704
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
0359C:  MOVLB  6
0359E:  MOVF   x98,W
035A0:  MULLW  21
035A2:  MOVF   FF3,W
035A4:  CLRF   xA2
035A6:  MOVWF  xA1
035A8:  MOVLW  08
035AA:  ADDWF  xA1,W
035AC:  MOVWF  01
035AE:  MOVLW  00
035B0:  ADDWFC xA2,W
035B2:  MOVWF  03
035B4:  MOVF   01,W
035B6:  ADDLW  0F
035B8:  MOVWF  FE9
035BA:  MOVLW  01
035BC:  ADDWFC 03,W
035BE:  MOVWF  FEA
035C0:  MOVFF  FEF,6DF
035C4:  MOVFF  FEC,6A2
035C8:  MOVFF  FEC,6E1
035CC:  MOVFF  FEC,6E2
035D0:  CLRF   xDE
035D2:  CLRF   xDD
035D4:  CLRF   xDC
035D6:  CLRF   xDB
035D8:  MOVFF  6A2,6E0
035DC:  MOVLB  0
035DE:  CALL   1778
035E2:  BNC   3650
035E4:  MOVLB  6
035E6:  MOVF   x98,W
035E8:  MULLW  21
035EA:  MOVF   FF3,W
035EC:  CLRF   xA2
035EE:  MOVWF  xA1
035F0:  MOVLW  10
035F2:  ADDWF  xA1,W
035F4:  MOVWF  01
035F6:  MOVLW  00
035F8:  ADDWFC xA2,W
035FA:  MOVWF  03
035FC:  MOVF   01,W
035FE:  ADDLW  0F
03600:  MOVWF  FE9
03602:  MOVLW  01
03604:  ADDWFC 03,W
03606:  MOVWF  FEA
03608:  MOVFF  FEF,6DB
0360C:  MOVFF  FEC,6DC
03610:  MOVFF  FEC,6DD
03614:  MOVFF  FEC,6DE
03618:  CLRF   xE2
0361A:  CLRF   xE1
0361C:  CLRF   xE0
0361E:  CLRF   xDF
03620:  MOVLB  0
03622:  CALL   1778
03626:  BNC   3650
....................          adcVals[ch].npoles--;
03628:  MOVLB  6
0362A:  MOVF   x98,W
0362C:  MULLW  21
0362E:  MOVF   FF3,W
03630:  CLRF   xA2
03632:  MOVWF  xA1
03634:  MOVLW  1C
03636:  ADDWF  xA1,W
03638:  MOVWF  01
0363A:  MOVLW  00
0363C:  ADDWFC xA2,W
0363E:  MOVWF  03
03640:  MOVF   01,W
03642:  ADDLW  0F
03644:  MOVWF  FE9
03646:  MOVLW  01
03648:  ADDWFC 03,W
0364A:  MOVWF  FEA
0364C:  DECF   FEF,F
....................       }
0364E:  BRA    3702
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03650:  MOVLB  6
03652:  MOVF   x98,W
03654:  MULLW  21
03656:  MOVF   FF3,W
03658:  CLRF   xA2
0365A:  MOVWF  xA1
0365C:  MOVLW  08
0365E:  ADDWF  xA1,W
03660:  MOVWF  01
03662:  MOVLW  00
03664:  ADDWFC xA2,W
03666:  MOVWF  03
03668:  MOVF   01,W
0366A:  ADDLW  0F
0366C:  MOVWF  FE9
0366E:  MOVLW  01
03670:  ADDWFC 03,W
03672:  MOVWF  FEA
03674:  MOVFF  FEF,6DB
03678:  MOVFF  FEC,6A2
0367C:  MOVFF  FEC,6DD
03680:  MOVFF  FEC,6DE
03684:  MOVFF  6A2,6DC
03688:  CLRF   xE2
0368A:  CLRF   xE1
0368C:  CLRF   xE0
0368E:  CLRF   xDF
03690:  MOVLB  0
03692:  CALL   1778
03696:  BNC   3704
03698:  MOVLB  6
0369A:  MOVF   x98,W
0369C:  MULLW  21
0369E:  MOVF   FF3,W
036A0:  CLRF   xA2
036A2:  MOVWF  xA1
036A4:  MOVLW  10
036A6:  ADDWF  xA1,W
036A8:  MOVWF  01
036AA:  MOVLW  00
036AC:  ADDWFC xA2,W
036AE:  MOVWF  03
036B0:  MOVF   01,W
036B2:  ADDLW  0F
036B4:  MOVWF  FE9
036B6:  MOVLW  01
036B8:  ADDWFC 03,W
036BA:  MOVWF  FEA
036BC:  MOVFF  FEF,6DF
036C0:  MOVFF  FEC,6E0
036C4:  MOVFF  FEC,6E1
036C8:  MOVFF  FEC,6E2
036CC:  CLRF   xDE
036CE:  CLRF   xDD
036D0:  CLRF   xDC
036D2:  CLRF   xDB
036D4:  MOVLB  0
036D6:  CALL   1778
036DA:  BNC   3704
....................          adcVals[ch].npoles++;
036DC:  MOVLB  6
036DE:  MOVF   x98,W
036E0:  MULLW  21
036E2:  MOVF   FF3,W
036E4:  CLRF   xA2
036E6:  MOVWF  xA1
036E8:  MOVLW  1C
036EA:  ADDWF  xA1,W
036EC:  MOVWF  01
036EE:  MOVLW  00
036F0:  ADDWFC xA2,W
036F2:  MOVWF  03
036F4:  MOVF   01,W
036F6:  ADDLW  0F
036F8:  MOVWF  FE9
036FA:  MOVLW  01
036FC:  ADDWFC 03,W
036FE:  MOVWF  FEA
03700:  INCF   FEF,F
03702:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03704:  MOVLB  6
03706:  MOVF   x98,W
03708:  MULLW  21
0370A:  MOVF   FF3,W
0370C:  CLRF   xA2
0370E:  MOVWF  xA1
03710:  MOVLW  18
03712:  ADDWF  xA1,W
03714:  MOVWF  01
03716:  MOVLW  00
03718:  ADDWFC xA2,W
0371A:  MOVWF  03
0371C:  MOVF   01,W
0371E:  ADDLW  0F
03720:  MOVWF  01
03722:  MOVLW  01
03724:  ADDWFC 03,F
03726:  MOVFF  01,6A1
0372A:  MOVFF  03,6A2
0372E:  MOVFF  6A0,6E3
03732:  MOVFF  69F,6E2
03736:  MOVFF  69E,6E1
0373A:  MOVFF  69D,6E0
0373E:  MOVLW  AA
03740:  MOVWF  xE7
03742:  MOVLW  27
03744:  MOVWF  xE6
03746:  MOVLW  1F
03748:  MOVWF  xE5
0374A:  MOVLW  86
0374C:  MOVWF  xE4
0374E:  MOVLB  0
03750:  CALL   0E32
03754:  MOVFF  03,6A6
03758:  MOVFF  02,6A5
0375C:  MOVFF  01,6A4
03760:  MOVFF  00,6A3
03764:  MOVLB  6
03766:  MOVF   x98,W
03768:  MULLW  21
0376A:  MOVF   FF3,W
0376C:  CLRF   xA8
0376E:  MOVWF  xA7
03770:  MOVLW  08
03772:  ADDWF  xA7,W
03774:  MOVWF  01
03776:  MOVLW  00
03778:  ADDWFC xA8,W
0377A:  MOVWF  03
0377C:  MOVF   01,W
0377E:  ADDLW  0F
03780:  MOVWF  FE9
03782:  MOVLW  01
03784:  ADDWFC 03,W
03786:  MOVWF  FEA
03788:  MOVFF  FEF,6A7
0378C:  MOVFF  FEC,6A8
03790:  MOVFF  FEC,6A9
03794:  MOVFF  FEC,6AA
03798:  MOVF   x98,W
0379A:  MULLW  21
0379C:  MOVF   FF3,W
0379E:  CLRF   xAC
037A0:  MOVWF  xAB
037A2:  MOVLW  0C
037A4:  ADDWF  xAB,W
037A6:  MOVWF  01
037A8:  MOVLW  00
037AA:  ADDWFC xAC,W
037AC:  MOVWF  03
037AE:  MOVF   01,W
037B0:  ADDLW  0F
037B2:  MOVWF  FE9
037B4:  MOVLW  01
037B6:  ADDWFC 03,W
037B8:  MOVWF  FEA
037BA:  MOVFF  FEF,00
037BE:  MOVFF  FEC,01
037C2:  MOVFF  FEC,02
037C6:  MOVFF  FEC,03
037CA:  MOVFF  03,6AE
037CE:  MOVFF  02,6AD
037D2:  MOVFF  01,6AC
037D6:  MOVFF  00,6AB
037DA:  MOVFF  6AA,6B2
037DE:  MOVFF  6A9,6B1
037E2:  MOVFF  6A8,6B0
037E6:  MOVFF  6A7,6AF
037EA:  MOVFF  03,6B6
037EE:  MOVFF  02,6B5
037F2:  MOVFF  01,6B4
037F6:  MOVFF  00,6B3
037FA:  MOVLB  0
037FC:  GOTO   1E7A
03800:  MOVFF  6A6,6E3
03804:  MOVFF  6A5,6E2
03808:  MOVFF  6A4,6E1
0380C:  MOVFF  6A3,6E0
03810:  MOVFF  03,6E7
03814:  MOVFF  02,6E6
03818:  MOVFF  01,6E5
0381C:  MOVFF  00,6E4
03820:  CALL   0E32
03824:  MOVFF  6A2,FEA
03828:  MOVFF  6A1,FE9
0382C:  MOVFF  00,FEF
03830:  MOVFF  01,FEC
03834:  MOVFF  02,FEC
03838:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
0383C:  MOVLB  6
0383E:  MOVF   x98,W
03840:  MULLW  21
03842:  MOVF   FF3,W
03844:  CLRF   xA2
03846:  MOVWF  xA1
03848:  MOVLW  18
0384A:  ADDWF  xA1,W
0384C:  MOVWF  01
0384E:  MOVLW  00
03850:  ADDWFC xA2,W
03852:  MOVWF  03
03854:  MOVF   01,W
03856:  ADDLW  0F
03858:  MOVWF  FE9
0385A:  MOVLW  01
0385C:  ADDWFC 03,W
0385E:  MOVWF  FEA
03860:  MOVFF  FEF,6A1
03864:  MOVFF  FEC,6A2
03868:  MOVFF  FEC,6A3
0386C:  MOVFF  FEC,6A4
03870:  CLRF   xE3
03872:  CLRF   xE2
03874:  MOVLW  7A
03876:  MOVWF  xE1
03878:  MOVLW  88
0387A:  MOVWF  xE0
0387C:  MOVFF  6A0,6E7
03880:  MOVFF  69F,6E6
03884:  MOVFF  69E,6E5
03888:  MOVFF  69D,6E4
0388C:  MOVLB  0
0388E:  CALL   0E32
03892:  MOVFF  03,6A8
03896:  MOVFF  02,6A7
0389A:  MOVFF  01,6A6
0389E:  MOVFF  00,6A5
038A2:  MOVLB  6
038A4:  MOVF   x98,W
038A6:  MULLW  21
038A8:  MOVF   FF3,W
038AA:  CLRF   xAA
038AC:  MOVWF  xA9
038AE:  MOVLW  1C
038B0:  ADDWF  xA9,W
038B2:  MOVWF  01
038B4:  MOVLW  00
038B6:  ADDWFC xAA,W
038B8:  MOVWF  03
038BA:  MOVF   01,W
038BC:  ADDLW  0F
038BE:  MOVWF  FE9
038C0:  MOVLW  01
038C2:  ADDWFC 03,W
038C4:  MOVWF  FEA
038C6:  MOVF   FEF,W
038C8:  CLRF   xD2
038CA:  MOVWF  xD1
038CC:  BTFSC  xD1.7
038CE:  DECF   xD2,F
038D0:  MOVLB  0
038D2:  CALL   211C
038D6:  MOVFF  6A8,6E3
038DA:  MOVFF  6A7,6E2
038DE:  MOVFF  6A6,6E1
038E2:  MOVFF  6A5,6E0
038E6:  MOVFF  03,6E7
038EA:  MOVFF  02,6E6
038EE:  MOVFF  01,6E5
038F2:  MOVFF  00,6E4
038F6:  CALL   0E32
038FA:  MOVFF  FEA,6A6
038FE:  MOVFF  FE9,6A5
03902:  BCF    FD8.1
03904:  MOVFF  6A4,6E2
03908:  MOVFF  6A3,6E1
0390C:  MOVFF  6A2,6E0
03910:  MOVFF  6A1,6DF
03914:  MOVFF  03,6E6
03918:  MOVFF  02,6E5
0391C:  MOVFF  01,6E4
03920:  MOVFF  00,6E3
03924:  CALL   0F28
03928:  MOVFF  6A6,FEA
0392C:  MOVFF  6A5,FE9
03930:  MOVFF  03,69C
03934:  MOVFF  02,69B
03938:  MOVFF  01,69A
0393C:  MOVFF  00,699
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03940:  MOVLB  6
03942:  MOVF   x98,W
03944:  MULLW  21
03946:  MOVF   FF3,W
03948:  CLRF   xA2
0394A:  MOVWF  xA1
0394C:  MOVLW  1D
0394E:  ADDWF  xA1,W
03950:  MOVWF  01
03952:  MOVLW  00
03954:  ADDWFC xA2,W
03956:  MOVWF  03
03958:  MOVF   01,W
0395A:  ADDLW  0F
0395C:  MOVWF  01
0395E:  MOVLW  01
03960:  ADDWFC 03,F
03962:  MOVFF  01,6A1
03966:  MOVFF  03,6A2
0396A:  MOVF   x98,W
0396C:  MULLW  18
0396E:  MOVF   FF3,W
03970:  CLRF   xA4
03972:  MOVWF  xA3
03974:  MOVLW  14
03976:  ADDWF  xA3,W
03978:  MOVWF  01
0397A:  MOVLW  00
0397C:  ADDWFC xA4,W
0397E:  MOVWF  03
03980:  MOVF   01,W
03982:  ADDLW  82
03984:  MOVWF  FE9
03986:  MOVLW  00
03988:  ADDWFC 03,W
0398A:  MOVWF  FEA
0398C:  MOVFF  FEF,6E4
03990:  MOVFF  FEC,01
03994:  MOVFF  FEC,02
03998:  MOVFF  FEC,03
0399C:  MOVFF  69C,6E3
039A0:  MOVFF  69B,6E2
039A4:  MOVFF  69A,6E1
039A8:  MOVFF  699,6E0
039AC:  MOVFF  03,6E7
039B0:  MOVFF  02,6E6
039B4:  MOVFF  01,6E5
039B8:  MOVLB  0
039BA:  CALL   0E32
039BE:  MOVFF  03,6A6
039C2:  MOVFF  02,6A5
039C6:  MOVFF  01,6A4
039CA:  MOVFF  00,6A3
039CE:  MOVFF  03,6B2
039D2:  MOVFF  02,6B1
039D6:  MOVFF  01,6B0
039DA:  MOVFF  00,6AF
039DE:  MOVLB  6
039E0:  CLRF   xB6
039E2:  CLRF   xB5
039E4:  MOVLW  20
039E6:  MOVWF  xB4
039E8:  MOVLW  81
039EA:  MOVWF  xB3
039EC:  MOVLB  0
039EE:  CALL   2E5A
039F2:  MOVFF  03,6A6
039F6:  MOVFF  02,6A5
039FA:  MOVFF  01,6A4
039FE:  MOVFF  00,6A3
03A02:  MOVLB  6
03A04:  MOVF   x98,W
03A06:  MULLW  18
03A08:  MOVF   FF3,W
03A0A:  CLRF   xA8
03A0C:  MOVWF  xA7
03A0E:  MOVLW  10
03A10:  ADDWF  xA7,W
03A12:  MOVWF  01
03A14:  MOVLW  00
03A16:  ADDWFC xA8,W
03A18:  MOVWF  03
03A1A:  MOVF   01,W
03A1C:  ADDLW  82
03A1E:  MOVWF  FE9
03A20:  MOVLW  00
03A22:  ADDWFC 03,W
03A24:  MOVWF  FEA
03A26:  MOVFF  FEF,6E4
03A2A:  MOVFF  FEC,01
03A2E:  MOVFF  FEC,02
03A32:  MOVFF  FEC,03
03A36:  MOVFF  69C,6E3
03A3A:  MOVFF  69B,6E2
03A3E:  MOVFF  69A,6E1
03A42:  MOVFF  699,6E0
03A46:  MOVFF  03,6E7
03A4A:  MOVFF  02,6E6
03A4E:  MOVFF  01,6E5
03A52:  MOVLB  0
03A54:  CALL   0E32
03A58:  MOVFF  03,6AA
03A5C:  MOVFF  02,6A9
03A60:  MOVFF  01,6A8
03A64:  MOVFF  00,6A7
03A68:  MOVFF  03,6B2
03A6C:  MOVFF  02,6B1
03A70:  MOVFF  01,6B0
03A74:  MOVFF  00,6AF
03A78:  MOVLB  6
03A7A:  CLRF   xB6
03A7C:  CLRF   xB5
03A7E:  CLRF   xB4
03A80:  MOVLW  81
03A82:  MOVWF  xB3
03A84:  MOVLB  0
03A86:  CALL   2E5A
03A8A:  MOVFF  FEA,6A8
03A8E:  MOVFF  FE9,6A7
03A92:  BCF    FD8.1
03A94:  MOVFF  6A6,6E2
03A98:  MOVFF  6A5,6E1
03A9C:  MOVFF  6A4,6E0
03AA0:  MOVFF  6A3,6DF
03AA4:  MOVFF  03,6E6
03AA8:  MOVFF  02,6E5
03AAC:  MOVFF  01,6E4
03AB0:  MOVFF  00,6E3
03AB4:  CALL   0F28
03AB8:  MOVFF  6A8,FEA
03ABC:  MOVFF  6A7,FE9
03AC0:  MOVFF  03,6A6
03AC4:  MOVFF  02,6A5
03AC8:  MOVFF  01,6A4
03ACC:  MOVFF  00,6A3
03AD0:  MOVLB  6
03AD2:  MOVF   x98,W
03AD4:  MULLW  18
03AD6:  MOVF   FF3,W
03AD8:  CLRF   xAA
03ADA:  MOVWF  xA9
03ADC:  MOVLW  0C
03ADE:  ADDWF  xA9,W
03AE0:  MOVWF  01
03AE2:  MOVLW  00
03AE4:  ADDWFC xAA,W
03AE6:  MOVWF  03
03AE8:  MOVF   01,W
03AEA:  ADDLW  82
03AEC:  MOVWF  FE9
03AEE:  MOVLW  00
03AF0:  ADDWFC 03,W
03AF2:  MOVWF  FEA
03AF4:  MOVFF  FEF,6E4
03AF8:  MOVFF  FEC,01
03AFC:  MOVFF  FEC,02
03B00:  MOVFF  FEC,03
03B04:  MOVFF  69C,6E3
03B08:  MOVFF  69B,6E2
03B0C:  MOVFF  69A,6E1
03B10:  MOVFF  699,6E0
03B14:  MOVFF  03,6E7
03B18:  MOVFF  02,6E6
03B1C:  MOVFF  01,6E5
03B20:  MOVLB  0
03B22:  CALL   0E32
03B26:  MOVFF  03,6AC
03B2A:  MOVFF  02,6AB
03B2E:  MOVFF  01,6AA
03B32:  MOVFF  00,6A9
03B36:  MOVFF  03,6B2
03B3A:  MOVFF  02,6B1
03B3E:  MOVFF  01,6B0
03B42:  MOVFF  00,6AF
03B46:  MOVLB  6
03B48:  CLRF   xB6
03B4A:  CLRF   xB5
03B4C:  MOVLW  40
03B4E:  MOVWF  xB4
03B50:  MOVLW  80
03B52:  MOVWF  xB3
03B54:  MOVLB  0
03B56:  CALL   2E5A
03B5A:  MOVFF  FEA,6AA
03B5E:  MOVFF  FE9,6A9
03B62:  BCF    FD8.1
03B64:  MOVFF  6A6,6E2
03B68:  MOVFF  6A5,6E1
03B6C:  MOVFF  6A4,6E0
03B70:  MOVFF  6A3,6DF
03B74:  MOVFF  03,6E6
03B78:  MOVFF  02,6E5
03B7C:  MOVFF  01,6E4
03B80:  MOVFF  00,6E3
03B84:  CALL   0F28
03B88:  MOVFF  6AA,FEA
03B8C:  MOVFF  6A9,FE9
03B90:  MOVFF  03,6A6
03B94:  MOVFF  02,6A5
03B98:  MOVFF  01,6A4
03B9C:  MOVFF  00,6A3
03BA0:  MOVLB  6
03BA2:  MOVF   x98,W
03BA4:  MULLW  18
03BA6:  MOVF   FF3,W
03BA8:  CLRF   xAC
03BAA:  MOVWF  xAB
03BAC:  MOVLW  08
03BAE:  ADDWF  xAB,W
03BB0:  MOVWF  01
03BB2:  MOVLW  00
03BB4:  ADDWFC xAC,W
03BB6:  MOVWF  03
03BB8:  MOVF   01,W
03BBA:  ADDLW  82
03BBC:  MOVWF  FE9
03BBE:  MOVLW  00
03BC0:  ADDWFC 03,W
03BC2:  MOVWF  FEA
03BC4:  MOVFF  FEF,6E4
03BC8:  MOVFF  FEC,01
03BCC:  MOVFF  FEC,02
03BD0:  MOVFF  FEC,03
03BD4:  MOVFF  69C,6E3
03BD8:  MOVFF  69B,6E2
03BDC:  MOVFF  69A,6E1
03BE0:  MOVFF  699,6E0
03BE4:  MOVFF  03,6E7
03BE8:  MOVFF  02,6E6
03BEC:  MOVFF  01,6E5
03BF0:  MOVLB  0
03BF2:  CALL   0E32
03BF6:  MOVFF  03,6AE
03BFA:  MOVFF  02,6AD
03BFE:  MOVFF  01,6AC
03C02:  MOVFF  00,6AB
03C06:  MOVFF  03,6B2
03C0A:  MOVFF  02,6B1
03C0E:  MOVFF  01,6B0
03C12:  MOVFF  00,6AF
03C16:  MOVLB  6
03C18:  CLRF   xB6
03C1A:  CLRF   xB5
03C1C:  CLRF   xB4
03C1E:  MOVLW  80
03C20:  MOVWF  xB3
03C22:  MOVLB  0
03C24:  CALL   2E5A
03C28:  MOVFF  FEA,6AC
03C2C:  MOVFF  FE9,6AB
03C30:  BCF    FD8.1
03C32:  MOVFF  6A6,6E2
03C36:  MOVFF  6A5,6E1
03C3A:  MOVFF  6A4,6E0
03C3E:  MOVFF  6A3,6DF
03C42:  MOVFF  03,6E6
03C46:  MOVFF  02,6E5
03C4A:  MOVFF  01,6E4
03C4E:  MOVFF  00,6E3
03C52:  CALL   0F28
03C56:  MOVFF  6AC,FEA
03C5A:  MOVFF  6AB,FE9
03C5E:  MOVFF  03,6A6
03C62:  MOVFF  02,6A5
03C66:  MOVFF  01,6A4
03C6A:  MOVFF  00,6A3
03C6E:  MOVLB  6
03C70:  MOVF   x98,W
03C72:  MULLW  18
03C74:  MOVF   FF3,W
03C76:  CLRF   xAE
03C78:  MOVWF  xAD
03C7A:  MOVLW  04
03C7C:  ADDWF  xAD,W
03C7E:  MOVWF  01
03C80:  MOVLW  00
03C82:  ADDWFC xAE,W
03C84:  MOVWF  03
03C86:  MOVF   01,W
03C88:  ADDLW  82
03C8A:  MOVWF  FE9
03C8C:  MOVLW  00
03C8E:  ADDWFC 03,W
03C90:  MOVWF  FEA
03C92:  MOVFF  FEF,6E4
03C96:  MOVFF  FEC,01
03C9A:  MOVFF  FEC,02
03C9E:  MOVFF  FEC,03
03CA2:  MOVFF  69C,6E3
03CA6:  MOVFF  69B,6E2
03CAA:  MOVFF  69A,6E1
03CAE:  MOVFF  699,6E0
03CB2:  MOVFF  03,6E7
03CB6:  MOVFF  02,6E6
03CBA:  MOVFF  01,6E5
03CBE:  MOVLB  0
03CC0:  CALL   0E32
03CC4:  MOVFF  FEA,6AE
03CC8:  MOVFF  FE9,6AD
03CCC:  BCF    FD8.1
03CCE:  MOVFF  6A6,6E2
03CD2:  MOVFF  6A5,6E1
03CD6:  MOVFF  6A4,6E0
03CDA:  MOVFF  6A3,6DF
03CDE:  MOVFF  03,6E6
03CE2:  MOVFF  02,6E5
03CE6:  MOVFF  01,6E4
03CEA:  MOVFF  00,6E3
03CEE:  CALL   0F28
03CF2:  MOVFF  6AE,FEA
03CF6:  MOVFF  6AD,FE9
03CFA:  MOVFF  03,6E2
03CFE:  MOVFF  02,6E1
03D02:  MOVFF  01,6E0
03D06:  MOVFF  00,6DF
03D0A:  MOVLB  6
03D0C:  MOVF   x98,W
03D0E:  MULLW  18
03D10:  MOVF   FF3,W
03D12:  CLRF   xB0
03D14:  MOVWF  xAF
03D16:  MOVLW  82
03D18:  ADDWF  xAF,W
03D1A:  MOVWF  FE9
03D1C:  MOVLW  00
03D1E:  ADDWFC xB0,W
03D20:  MOVWF  FEA
03D22:  MOVFF  FEF,6E3
03D26:  MOVFF  FEC,01
03D2A:  MOVFF  FEC,02
03D2E:  MOVFF  FEC,03
03D32:  BCF    FD8.1
03D34:  MOVFF  03,6E6
03D38:  MOVFF  02,6E5
03D3C:  MOVFF  01,6E4
03D40:  MOVLB  0
03D42:  CALL   0F28
03D46:  MOVFF  6A2,FEA
03D4A:  MOVFF  6A1,FE9
03D4E:  MOVFF  00,FEF
03D52:  MOVFF  01,FEC
03D56:  MOVFF  02,FEC
03D5A:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
03D5E:  MOVLB  6
03D60:  MOVF   x98,F
03D62:  BNZ   3DC0
03D64:  MOVF   x98,W
03D66:  MULLW  21
03D68:  MOVF   FF3,W
03D6A:  CLRF   xA2
03D6C:  MOVWF  xA1
03D6E:  MOVLW  1D
03D70:  ADDWF  xA1,W
03D72:  MOVWF  01
03D74:  MOVLW  00
03D76:  ADDWFC xA2,W
03D78:  MOVWF  03
03D7A:  MOVF   01,W
03D7C:  ADDLW  0F
03D7E:  MOVWF  FE9
03D80:  MOVLW  01
03D82:  ADDWFC 03,W
03D84:  MOVWF  FEA
03D86:  MOVFF  FEF,6E0
03D8A:  MOVFF  FEC,6E1
03D8E:  MOVFF  FEC,6E2
03D92:  MOVFF  FEC,6E3
03D96:  MOVF   FED,F
03D98:  MOVF   FED,F
03D9A:  MOVF   FED,F
03D9C:  CLRF   xE7
03D9E:  CLRF   xE6
03DA0:  MOVLW  80
03DA2:  MOVWF  xE5
03DA4:  MOVLW  7F
03DA6:  MOVWF  xE4
03DA8:  MOVLB  0
03DAA:  CALL   0E32
03DAE:  MOVFF  00,FEF
03DB2:  MOVFF  01,FEC
03DB6:  MOVFF  02,FEC
03DBA:  MOVFF  03,FEC
03DBE:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
03DC0:  MOVF   x98,W
03DC2:  MULLW  20
03DC4:  MOVF   FF3,W
03DC6:  CLRF   xA2
03DC8:  MOVWF  xA1
03DCA:  MOVLW  14
03DCC:  ADDWF  xA1,W
03DCE:  MOVWF  01
03DD0:  MOVLW  00
03DD2:  ADDWFC xA2,W
03DD4:  MOVWF  03
03DD6:  MOVF   01,W
03DD8:  ADDLW  20
03DDA:  MOVWF  01
03DDC:  MOVLW  00
03DDE:  ADDWFC 03,F
03DE0:  MOVFF  01,6A1
03DE4:  MOVFF  03,6A2
03DE8:  MOVF   x98,W
03DEA:  MULLW  20
03DEC:  MOVF   FF3,W
03DEE:  CLRF   xA4
03DF0:  MOVWF  xA3
03DF2:  MOVLW  10
03DF4:  ADDWF  xA3,W
03DF6:  MOVWF  01
03DF8:  MOVLW  00
03DFA:  ADDWFC xA4,W
03DFC:  MOVWF  03
03DFE:  MOVF   01,W
03E00:  ADDLW  20
03E02:  MOVWF  FE9
03E04:  MOVLW  00
03E06:  ADDWFC 03,W
03E08:  MOVWF  FEA
03E0A:  MOVFF  FEF,00
03E0E:  MOVFF  FEC,01
03E12:  MOVFF  FEC,02
03E16:  MOVFF  FEC,03
03E1A:  MOVFF  6A2,FEA
03E1E:  MOVFF  6A1,FE9
03E22:  MOVFF  00,FEF
03E26:  MOVFF  01,FEC
03E2A:  MOVFF  02,FEC
03E2E:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03E32:  MOVF   x98,W
03E34:  MULLW  20
03E36:  MOVF   FF3,W
03E38:  CLRF   xA2
03E3A:  MOVWF  xA1
03E3C:  MOVLW  10
03E3E:  ADDWF  xA1,W
03E40:  MOVWF  01
03E42:  MOVLW  00
03E44:  ADDWFC xA2,W
03E46:  MOVWF  03
03E48:  MOVF   01,W
03E4A:  ADDLW  20
03E4C:  MOVWF  01
03E4E:  MOVLW  00
03E50:  ADDWFC 03,F
03E52:  MOVFF  01,6A1
03E56:  MOVFF  03,6A2
03E5A:  MOVF   x98,W
03E5C:  MULLW  21
03E5E:  MOVF   FF3,W
03E60:  CLRF   xA4
03E62:  MOVWF  xA3
03E64:  MOVLW  1D
03E66:  ADDWF  xA3,W
03E68:  MOVWF  01
03E6A:  MOVLW  00
03E6C:  ADDWFC xA4,W
03E6E:  MOVWF  03
03E70:  MOVF   01,W
03E72:  ADDLW  0F
03E74:  MOVWF  FE9
03E76:  MOVLW  01
03E78:  ADDWFC 03,W
03E7A:  MOVWF  FEA
03E7C:  MOVFF  FEF,00
03E80:  MOVFF  FEC,01
03E84:  MOVFF  FEC,02
03E88:  MOVFF  FEC,03
03E8C:  MOVFF  6A2,FEA
03E90:  MOVFF  6A1,FE9
03E94:  MOVFF  00,FEF
03E98:  MOVFF  01,FEC
03E9C:  MOVFF  02,FEC
03EA0:  MOVFF  03,FEC
03EA4:  MOVLB  0
03EA6:  GOTO   3FD0 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001B8:  MOVLB  2
001BA:  MOVF   x04,W
001BC:  MULLW  0D
001BE:  MOVF   FF3,W
001C0:  MOVLB  7
001C2:  CLRF   x01
001C4:  MOVWF  x00
001C6:  MOVLW  E9
001C8:  ADDWF  x00,W
001CA:  MOVWF  FE9
001CC:  MOVLW  01
001CE:  ADDWFC x01,W
001D0:  MOVWF  FEA
001D2:  BTFSC  FEF.1
001D4:  BRA    024E
....................    {
....................       smData[ch].adcBusy = true;
001D6:  MOVLB  2
001D8:  MOVF   x04,W
001DA:  MULLW  0D
001DC:  MOVF   FF3,W
001DE:  MOVLB  7
001E0:  CLRF   x01
001E2:  MOVWF  x00
001E4:  MOVLW  E9
001E6:  ADDWF  x00,W
001E8:  MOVWF  FE9
001EA:  MOVLW  01
001EC:  ADDWFC x01,W
001EE:  MOVWF  FEA
001F0:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001F2:  MOVFF  204,6FF
001F6:  MOVLB  0
001F8:  RCALL  019E
....................       ch = !ch;
001FA:  MOVLB  2
001FC:  MOVF   x04,F
001FE:  BZ    0204
00200:  MOVLW  00
00202:  BRA    0206
00204:  MOVLW  01
00206:  MOVWF  x04
....................       
....................       smData[!ch].dataReady = true;
00208:  MOVF   x04,F
0020A:  BZ    0210
0020C:  MOVLW  00
0020E:  BRA    0212
00210:  MOVLW  01
00212:  MULLW  0D
00214:  MOVF   FF3,W
00216:  MOVLB  7
00218:  CLRF   x01
0021A:  MOVWF  x00
0021C:  MOVLW  E9
0021E:  ADDWF  x00,W
00220:  MOVWF  FE9
00222:  MOVLW  01
00224:  ADDWFC x01,W
00226:  MOVWF  FEA
00228:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
0022A:  MOVLB  2
0022C:  MOVF   x04,F
0022E:  BZ    0234
00230:  MOVLW  00
00232:  BRA    0236
00234:  MOVLW  01
00236:  MULLW  0D
00238:  MOVF   FF3,W
0023A:  MOVLB  7
0023C:  CLRF   x01
0023E:  MOVWF  x00
00240:  MOVLW  E9
00242:  ADDWF  x00,W
00244:  MOVWF  FE9
00246:  MOVLW  01
00248:  ADDWFC x01,W
0024A:  MOVWF  FEA
0024C:  BCF    FEF.1
....................    }
0024E:  MOVLB  0
00250:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts)
.................... {
....................    signed int32 iqmBufSin[BUFFER_SIZE];
....................    signed int32 iqmBufCos[BUFFER_SIZE];
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
.................... //!   tobuff(smData[ch].sinQ, sinCnts); // push new data into queues
.................... //!   tobuff(smData[ch].cosQ, cosCnts);
....................    
....................    push(smData[ch].sinQ, sinCnts); // push new data into queues
....................    push(smData[ch].cosQ, cosCnts);
....................    
....................    // copy queue contents out to buffer for qsorting
....................    for (int j=0; j<BUFFER_SIZE; j++){
....................       iqmBufSin[j] = smData[ch].sinQ->buff[j];
....................       iqmBufCos[j] = smData[ch].cosQ->buff[j];
....................    }
....................    
....................    qsort(iqmBufSin, BUFFER_SIZE, sizeof(*iqmBufSin), compar);
....................    qsort(iqmBufCos, BUFFER_SIZE, sizeof(*iqmBufCos), compar);
....................    
....................    for (int k=1; k<(BUFFER_SIZE-1); k++){
....................       sumSin+=iqmBufSin[k];
....................       sumCos+=iqmBufCos[k];
....................    }
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
03EAA:  MOVLB  6
03EAC:  CLRF   x93
03EAE:  CLRF   x92
03EB0:  CLRF   x91
03EB2:  CLRF   x90
03EB4:  CLRF   x97
03EB6:  CLRF   x96
03EB8:  CLRF   x95
03EBA:  CLRF   x94
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
03EBC:  MOVLB  2
03EBE:  MOVF   x05,W
03EC0:  MULLW  0D
03EC2:  MOVF   FF3,W
03EC4:  MOVLB  6
03EC6:  CLRF   x99
03EC8:  MOVWF  x98
03ECA:  MOVLW  E9
03ECC:  ADDWF  x98,W
03ECE:  MOVWF  FE9
03ED0:  MOVLW  01
03ED2:  ADDWFC x99,W
03ED4:  MOVWF  FEA
03ED6:  BTFSC  FEF.1
03ED8:  BRA    4024
03EDA:  MOVLB  2
03EDC:  MOVF   x05,W
03EDE:  MULLW  0D
03EE0:  MOVF   FF3,W
03EE2:  MOVLB  6
03EE4:  CLRF   x9B
03EE6:  MOVWF  x9A
03EE8:  MOVLW  E9
03EEA:  ADDWF  x9A,W
03EEC:  MOVWF  FE9
03EEE:  MOVLW  01
03EF0:  ADDWFC x9B,W
03EF2:  MOVWF  FEA
03EF4:  BTFSS  FEF.0
03EF6:  BRA    4024
....................       smData[ch].adcBusy = true;
03EF8:  MOVLB  2
03EFA:  MOVF   x05,W
03EFC:  MULLW  0D
03EFE:  MOVF   FF3,W
03F00:  MOVLB  6
03F02:  CLRF   x99
03F04:  MOVWF  x98
03F06:  MOVLW  E9
03F08:  ADDWF  x98,W
03F0A:  MOVWF  FE9
03F0C:  MOVLW  01
03F0E:  ADDWFC x99,W
03F10:  MOVWF  FEA
03F12:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
03F14:  BCF    FD8.0
03F16:  MOVLB  2
03F18:  RLCF   x05,W
03F1A:  MOVLB  6
03F1C:  MOVWF  x98
03F1E:  MOVWF  x9A
03F20:  MOVLB  0
03F22:  CALL   0812
03F26:  MOVFF  03,693
03F2A:  MOVFF  02,692
03F2E:  MOVFF  01,691
03F32:  MOVFF  00,690
....................       cosNew = ads_read_data(ch*2+1);      
03F36:  BCF    FD8.0
03F38:  MOVLB  2
03F3A:  RLCF   x05,W
03F3C:  ADDLW  01
03F3E:  MOVLB  6
03F40:  MOVWF  x98
03F42:  MOVWF  x9A
03F44:  MOVLB  0
03F46:  CALL   0812
03F4A:  MOVFF  03,697
03F4E:  MOVFF  02,696
03F52:  MOVFF  01,695
03F56:  MOVFF  00,694
....................       
.................... //!      iqm_ring_buffer(ch, sinNew, cosNew);
....................       smData[ch].avgSin = sinNew;
03F5A:  MOVLB  2
03F5C:  MOVF   x05,W
03F5E:  MULLW  0D
03F60:  MOVF   FF3,W
03F62:  MOVLB  6
03F64:  CLRF   x99
03F66:  MOVWF  x98
03F68:  MOVLW  05
03F6A:  ADDWF  x98,W
03F6C:  MOVWF  01
03F6E:  MOVLW  00
03F70:  ADDWFC x99,W
03F72:  MOVWF  03
03F74:  MOVF   01,W
03F76:  ADDLW  E9
03F78:  MOVWF  FE9
03F7A:  MOVLW  01
03F7C:  ADDWFC 03,W
03F7E:  MOVWF  FEA
03F80:  MOVFF  690,FEF
03F84:  MOVFF  691,FEC
03F88:  MOVFF  692,FEC
03F8C:  MOVFF  693,FEC
....................       smData[ch].avgCos = cosNew;
03F90:  MOVLB  2
03F92:  MOVF   x05,W
03F94:  MULLW  0D
03F96:  MOVF   FF3,W
03F98:  MOVLB  6
03F9A:  CLRF   x99
03F9C:  MOVWF  x98
03F9E:  MOVLW  09
03FA0:  ADDWF  x98,W
03FA2:  MOVWF  01
03FA4:  MOVLW  00
03FA6:  ADDWFC x99,W
03FA8:  MOVWF  03
03FAA:  MOVF   01,W
03FAC:  ADDLW  E9
03FAE:  MOVWF  FE9
03FB0:  MOVLW  01
03FB2:  ADDWFC 03,W
03FB4:  MOVWF  FEA
03FB6:  MOVFF  694,FEF
03FBA:  MOVFF  695,FEC
03FBE:  MOVFF  696,FEC
03FC2:  MOVFF  697,FEC
....................       
....................       sensor_process_data(ch);
03FC6:  MOVFF  205,698
03FCA:  MOVLB  0
03FCC:  GOTO   3158
....................       ch = !ch;
03FD0:  MOVLB  2
03FD2:  MOVF   x05,F
03FD4:  BZ    3FDA
03FD6:  MOVLW  00
03FD8:  BRA    3FDC
03FDA:  MOVLW  01
03FDC:  MOVWF  x05
....................       
....................       smData[!ch].dataReady = false;
03FDE:  MOVF   x05,F
03FE0:  BZ    3FE6
03FE2:  MOVLW  00
03FE4:  BRA    3FE8
03FE6:  MOVLW  01
03FE8:  MULLW  0D
03FEA:  MOVF   FF3,W
03FEC:  MOVLB  6
03FEE:  CLRF   x99
03FF0:  MOVWF  x98
03FF2:  MOVLW  E9
03FF4:  ADDWF  x98,W
03FF6:  MOVWF  FE9
03FF8:  MOVLW  01
03FFA:  ADDWFC x99,W
03FFC:  MOVWF  FEA
03FFE:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04000:  MOVLB  2
04002:  MOVF   x05,F
04004:  BZ    400A
04006:  MOVLW  00
04008:  BRA    400C
0400A:  MOVLW  01
0400C:  MULLW  0D
0400E:  MOVF   FF3,W
04010:  MOVLB  6
04012:  CLRF   x99
04014:  MOVWF  x98
04016:  MOVLW  E9
04018:  ADDWF  x98,W
0401A:  MOVWF  FE9
0401C:  MOVLW  01
0401E:  ADDWFC x99,W
04020:  MOVWF  FEA
04022:  BCF    FEF.1
....................    }
04024:  MOVLB  0
04026:  GOTO   A012 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
00986:  MOVLB  6
00988:  CLRF   x90
0098A:  CLRF   x91
0098C:  CLRF   x92
0098E:  CLRF   x93
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00990:  CLRF   x94
00992:  MOVF   x94,W
00994:  SUBLW  03
00996:  BNC   09CC
....................       rc0=reg0config;
00998:  MOVLW  30
0099A:  MOVWF  x90
....................       rc1=reg1config;
0099C:  MOVLW  10
0099E:  MOVWF  x91
....................       rc2=reg2config;
009A0:  CLRF   x92
....................       rc3=reg3config;
009A2:  CLRF   x93
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
009A4:  MOVFF  694,697
009A8:  MOVFF  690,698
009AC:  MOVFF  691,699
009B0:  MOVFF  692,69A
009B4:  MOVFF  693,69B
009B8:  MOVLB  0
009BA:  BRA    0744
....................       delay_ms(100);
009BC:  MOVLW  64
009BE:  MOVLB  6
009C0:  MOVWF  x98
009C2:  MOVLB  0
009C4:  RCALL  0430
009C6:  MOVLB  6
009C8:  INCF   x94,F
009CA:  BRA    0992
....................    }
....................    
....................    for (int i = 0; i < BUFFER_SIZE; i++){
009CC:  CLRF   x95
009CE:  MOVF   x95,W
009D0:  SUBLW  07
009D2:  BTFSS  FD8.0
009D4:  BRA    0B42
....................       ads_start_conv_all();
009D6:  MOVLB  0
009D8:  BRA    07E2
....................       delay_ms(600);
009DA:  MOVLW  03
009DC:  MOVLB  6
009DE:  MOVWF  x97
009E0:  MOVLW  C8
009E2:  MOVWF  x98
009E4:  MOVLB  0
009E6:  RCALL  0430
009E8:  MOVLB  6
009EA:  DECFSZ x97,F
009EC:  BRA    09E0
....................       for (int b = 0; b < 2; b++){
009EE:  CLRF   x96
009F0:  MOVF   x96,W
009F2:  SUBLW  01
009F4:  BTFSS  FD8.0
009F6:  BRA    0B3E
....................          smData[b].sinQ->in = 0;
009F8:  MOVF   x96,W
009FA:  MULLW  0D
009FC:  MOVF   FF3,W
009FE:  CLRF   x98
00A00:  MOVWF  x97
00A02:  MOVLW  01
00A04:  ADDWF  x97,W
00A06:  MOVWF  01
00A08:  MOVLW  00
00A0A:  ADDWFC x98,W
00A0C:  MOVWF  03
00A0E:  MOVF   01,W
00A10:  ADDLW  E9
00A12:  MOVWF  01
00A14:  MOVLW  01
00A16:  ADDWFC 03,F
00A18:  MOVFF  03,FEA
00A1C:  MOVFF  01,FE9
00A20:  MOVFF  FEC,69A
00A24:  MOVF   FED,F
00A26:  MOVFF  FEF,699
00A2A:  MOVFF  699,FE9
00A2E:  MOVFF  69A,FEA
00A32:  CLRF   FEF
....................          smData[b].cosQ->in = 0;
00A34:  MOVF   x96,W
00A36:  MULLW  0D
00A38:  MOVF   FF3,W
00A3A:  CLRF   x98
00A3C:  MOVWF  x97
00A3E:  MOVLW  03
00A40:  ADDWF  x97,W
00A42:  MOVWF  01
00A44:  MOVLW  00
00A46:  ADDWFC x98,W
00A48:  MOVWF  03
00A4A:  MOVF   01,W
00A4C:  ADDLW  E9
00A4E:  MOVWF  01
00A50:  MOVLW  01
00A52:  ADDWFC 03,F
00A54:  MOVFF  03,FEA
00A58:  MOVFF  01,FE9
00A5C:  MOVFF  FEC,69A
00A60:  MOVF   FED,F
00A62:  MOVFF  FEF,699
00A66:  MOVFF  699,FE9
00A6A:  MOVFF  69A,FEA
00A6E:  CLRF   FEF
....................      
....................          push(smData[b].sinQ, ads_read_data(b*2));
00A70:  MOVF   x96,W
00A72:  MULLW  0D
00A74:  MOVF   FF3,W
00A76:  CLRF   x98
00A78:  MOVWF  x97
00A7A:  MOVLW  01
00A7C:  ADDWF  x97,W
00A7E:  MOVWF  01
00A80:  MOVLW  00
00A82:  ADDWFC x98,W
00A84:  MOVWF  03
00A86:  MOVF   01,W
00A88:  ADDLW  E9
00A8A:  MOVWF  FE9
00A8C:  MOVLW  01
00A8E:  ADDWFC 03,W
00A90:  MOVWF  FEA
00A92:  MOVFF  FEC,698
00A96:  MOVF   FED,F
00A98:  MOVFF  FEF,697
00A9C:  BCF    FD8.0
00A9E:  RLCF   x96,W
00AA0:  MOVWF  x99
00AA2:  MOVWF  x9A
00AA4:  MOVLB  0
00AA6:  RCALL  0812
00AA8:  MOVFF  03,69C
00AAC:  MOVFF  02,69B
00AB0:  MOVFF  01,69A
00AB4:  MOVFF  00,699
00AB8:  MOVFF  698,69E
00ABC:  MOVFF  697,69D
00AC0:  MOVFF  03,6A2
00AC4:  MOVFF  02,6A1
00AC8:  MOVFF  01,6A0
00ACC:  MOVFF  00,69F
00AD0:  RCALL  0902
....................          push(smData[b].cosQ, ads_read_data(b*2+1));      
00AD2:  MOVLB  6
00AD4:  MOVF   x96,W
00AD6:  MULLW  0D
00AD8:  MOVF   FF3,W
00ADA:  CLRF   x98
00ADC:  MOVWF  x97
00ADE:  MOVLW  03
00AE0:  ADDWF  x97,W
00AE2:  MOVWF  01
00AE4:  MOVLW  00
00AE6:  ADDWFC x98,W
00AE8:  MOVWF  03
00AEA:  MOVF   01,W
00AEC:  ADDLW  E9
00AEE:  MOVWF  FE9
00AF0:  MOVLW  01
00AF2:  ADDWFC 03,W
00AF4:  MOVWF  FEA
00AF6:  MOVFF  FEC,698
00AFA:  MOVF   FED,F
00AFC:  MOVFF  FEF,697
00B00:  BCF    FD8.0
00B02:  RLCF   x96,W
00B04:  ADDLW  01
00B06:  MOVWF  x99
00B08:  MOVWF  x9A
00B0A:  MOVLB  0
00B0C:  RCALL  0812
00B0E:  MOVFF  03,69C
00B12:  MOVFF  02,69B
00B16:  MOVFF  01,69A
00B1A:  MOVFF  00,699
00B1E:  MOVFF  698,69E
00B22:  MOVFF  697,69D
00B26:  MOVFF  03,6A2
00B2A:  MOVFF  02,6A1
00B2E:  MOVFF  01,6A0
00B32:  MOVFF  00,69F
00B36:  RCALL  0902
00B38:  MOVLB  6
00B3A:  INCF   x96,F
00B3C:  BRA    09F0
....................       }
00B3E:  INCF   x95,F
00B40:  BRA    09CE
....................    }
00B42:  MOVLB  0
00B44:  GOTO   0BA8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00B48:  MOVLW  00
00B4A:  MOVLB  F
00B4C:  MOVWF  x53
00B4E:  MOVLW  40
00B50:  MOVWF  x0C
00B52:  MOVLW  00
00B54:  MOVWF  x14
00B56:  MOVLW  03
00B58:  MOVWF  x1C
00B5A:  MOVLW  0F
00B5C:  MOVWF  x21
00B5E:  MOVLW  00
00B60:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00B62:  MOVLW  08
00B64:  MOVWF  x55
00B66:  CLRF   x56
00B68:  CLRF   x52
00B6A:  SETF   x57
00B6C:  CLRF   F61
00B6E:  MOVLW  94
00B70:  MOVWF  x5B
....................    output_high(EN_EXC);
00B72:  MOVLW  E8
00B74:  MOVWF  F8B
00B76:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B78:  MOVF   x5A,W
00B7A:  ANDLW  3F
00B7C:  MOVWF  01
00B7E:  MOVLW  06
00B80:  MOVWF  x5A
00B82:  BTFSS  x5B.7
00B84:  BRA    0B94
00B86:  MOVF   01,W
00B88:  SUBLW  06
00B8A:  BZ    0B94
00B8C:  BSF    x5B.0
00B8E:  NOP   
00B90:  BTFSC  x5B.0
00B92:  BRA    0B90
....................    delay_ms(10);
00B94:  MOVLW  0A
00B96:  MOVLB  6
00B98:  MOVWF  x98
00B9A:  MOVLB  0
00B9C:  RCALL  0430
....................    read_adc(ADC_START_ONLY);
00B9E:  MOVLB  F
00BA0:  BSF    x5B.0
00BA2:  NOP   
....................    setup_external_ADCs();
00BA4:  MOVLB  0
00BA6:  BRA    0986
....................    intTimeoutReg = sensorSampleRate;
00BA8:  MOVLB  1
00BAA:  CLRF   x64
00BAC:  MOVLW  32
00BAE:  MOVWF  x63
00BB0:  MOVLB  0
00BB2:  GOTO   9FFE (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
04104:  MOVLB  6
04106:  MOVF   x94,W
04108:  MULLW  20
0410A:  MOVF   FF3,W
0410C:  CLRF   xA2
0410E:  MOVWF  xA1
04110:  MOVLW  0C
04112:  ADDWF  xA1,W
04114:  MOVWF  01
04116:  MOVLW  00
04118:  ADDWFC xA2,W
0411A:  MOVWF  03
0411C:  MOVF   01,W
0411E:  ADDLW  20
04120:  MOVWF  FE9
04122:  MOVLW  00
04124:  ADDWFC 03,W
04126:  MOVWF  FEA
04128:  MOVFF  FEF,6DF
0412C:  MOVFF  FEC,6E0
04130:  MOVFF  FEC,6E1
04134:  MOVFF  FEC,6E2
04138:  MOVF   x94,W
0413A:  MULLW  20
0413C:  MOVF   FF3,W
0413E:  CLRF   xA6
04140:  MOVWF  xA5
04142:  MOVLW  10
04144:  ADDWF  xA5,W
04146:  MOVWF  01
04148:  MOVLW  00
0414A:  ADDWFC xA6,W
0414C:  MOVWF  03
0414E:  MOVF   01,W
04150:  ADDLW  20
04152:  MOVWF  FE9
04154:  MOVLW  00
04156:  ADDWFC 03,W
04158:  MOVWF  FEA
0415A:  MOVFF  FEF,6E3
0415E:  MOVFF  FEC,01
04162:  MOVFF  FEC,02
04166:  MOVFF  FEC,03
0416A:  MOVFF  FEA,6A6
0416E:  MOVFF  FE9,6A5
04172:  BSF    FD8.1
04174:  MOVFF  03,6E6
04178:  MOVFF  02,6E5
0417C:  MOVFF  01,6E4
04180:  MOVLB  0
04182:  CALL   0F28
04186:  MOVFF  6A6,FEA
0418A:  MOVFF  6A5,FE9
0418E:  MOVFF  03,698
04192:  MOVFF  02,697
04196:  MOVFF  01,696
0419A:  MOVFF  00,695
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
0419E:  MOVLB  6
041A0:  MOVF   x94,W
041A2:  MULLW  20
041A4:  MOVF   FF3,W
041A6:  CLRF   xA2
041A8:  MOVWF  xA1
041AA:  MOVLW  1C
041AC:  ADDWF  xA1,W
041AE:  MOVWF  01
041B0:  MOVLW  00
041B2:  ADDWFC xA2,W
041B4:  MOVWF  03
041B6:  MOVF   01,W
041B8:  ADDLW  20
041BA:  MOVWF  01
041BC:  MOVLW  00
041BE:  ADDWFC 03,F
041C0:  MOVFF  01,6A1
041C4:  MOVFF  03,6A2
041C8:  MOVFF  03,FEA
041CC:  MOVFF  01,FE9
041D0:  MOVFF  FEF,6A3
041D4:  MOVFF  FEC,6A4
041D8:  MOVFF  FEC,6A5
041DC:  MOVFF  FEC,6A6
041E0:  MOVF   x94,W
041E2:  MULLW  20
041E4:  MOVF   FF3,W
041E6:  CLRF   xA8
041E8:  MOVWF  xA7
041EA:  MOVLW  04
041EC:  ADDWF  xA7,W
041EE:  MOVWF  01
041F0:  MOVLW  00
041F2:  ADDWFC xA8,W
041F4:  MOVWF  03
041F6:  MOVF   01,W
041F8:  ADDLW  20
041FA:  MOVWF  FE9
041FC:  MOVLW  00
041FE:  ADDWFC 03,W
04200:  MOVWF  FEA
04202:  MOVFF  FEF,6E4
04206:  MOVFF  FEC,01
0420A:  MOVFF  FEC,02
0420E:  MOVFF  FEC,03
04212:  MOVFF  698,6E3
04216:  MOVFF  697,6E2
0421A:  MOVFF  696,6E1
0421E:  MOVFF  695,6E0
04222:  MOVFF  03,6E7
04226:  MOVFF  02,6E6
0422A:  MOVFF  01,6E5
0422E:  MOVLB  0
04230:  CALL   0E32
04234:  BCF    FD8.1
04236:  MOVFF  6A6,6E2
0423A:  MOVFF  6A5,6E1
0423E:  MOVFF  6A4,6E0
04242:  MOVFF  6A3,6DF
04246:  MOVFF  03,6E6
0424A:  MOVFF  02,6E5
0424E:  MOVFF  01,6E4
04252:  MOVFF  00,6E3
04256:  CALL   0F28
0425A:  MOVFF  6A2,FEA
0425E:  MOVFF  6A1,FE9
04262:  MOVFF  00,FEF
04266:  MOVFF  01,FEC
0426A:  MOVFF  02,FEC
0426E:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
04272:  MOVLB  6
04274:  MOVF   x94,W
04276:  MULLW  20
04278:  MOVF   FF3,W
0427A:  CLRF   xA2
0427C:  MOVWF  xA1
0427E:  MOVLW  1C
04280:  ADDWF  xA1,W
04282:  MOVWF  01
04284:  MOVLW  00
04286:  ADDWFC xA2,W
04288:  MOVWF  03
0428A:  MOVF   01,W
0428C:  ADDLW  20
0428E:  MOVWF  FE9
04290:  MOVLW  00
04292:  ADDWFC 03,W
04294:  MOVWF  FEA
04296:  MOVFF  FEF,6DF
0429A:  MOVFF  FEC,6A2
0429E:  MOVFF  FEC,6E1
042A2:  MOVFF  FEC,6E2
042A6:  CLRF   xDE
042A8:  CLRF   xDD
042AA:  MOVLW  7C
042AC:  MOVWF  xDC
042AE:  MOVLW  84
042B0:  MOVWF  xDB
042B2:  MOVFF  6A2,6E0
042B6:  MOVLB  0
042B8:  CALL   1778
042BC:  BNC   42F0
042BE:  MOVLB  6
042C0:  MOVF   x94,W
042C2:  MULLW  20
042C4:  MOVF   FF3,W
042C6:  CLRF   xA2
042C8:  MOVWF  xA1
042CA:  MOVLW  1C
042CC:  ADDWF  xA1,W
042CE:  MOVWF  01
042D0:  MOVLW  00
042D2:  ADDWFC xA2,W
042D4:  MOVWF  03
042D6:  MOVF   01,W
042D8:  ADDLW  20
042DA:  MOVWF  FE9
042DC:  MOVLW  00
042DE:  ADDWFC 03,W
042E0:  MOVWF  FEA
042E2:  MOVLW  84
042E4:  MOVWF  FEF
042E6:  MOVLW  7C
042E8:  MOVWF  FEC
042EA:  CLRF   FEC
042EC:  CLRF   FEC
042EE:  BRA    436C
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
042F0:  MOVLB  6
042F2:  MOVF   x94,W
042F4:  MULLW  20
042F6:  MOVF   FF3,W
042F8:  CLRF   xA2
042FA:  MOVWF  xA1
042FC:  MOVLW  1C
042FE:  ADDWF  xA1,W
04300:  MOVWF  01
04302:  MOVLW  00
04304:  ADDWFC xA2,W
04306:  MOVWF  03
04308:  MOVF   01,W
0430A:  ADDLW  20
0430C:  MOVWF  FE9
0430E:  MOVLW  00
04310:  ADDWFC 03,W
04312:  MOVWF  FEA
04314:  MOVFF  FEF,6DB
04318:  MOVFF  FEC,6A2
0431C:  MOVFF  FEC,6DD
04320:  MOVFF  FEC,6DE
04324:  MOVFF  6A2,6DC
04328:  CLRF   xE2
0432A:  CLRF   xE1
0432C:  MOVLW  FC
0432E:  MOVWF  xE0
04330:  MOVLW  84
04332:  MOVWF  xDF
04334:  MOVLB  0
04336:  CALL   1778
0433A:  BNC   436E
0433C:  MOVLB  6
0433E:  MOVF   x94,W
04340:  MULLW  20
04342:  MOVF   FF3,W
04344:  CLRF   xA2
04346:  MOVWF  xA1
04348:  MOVLW  1C
0434A:  ADDWF  xA1,W
0434C:  MOVWF  01
0434E:  MOVLW  00
04350:  ADDWFC xA2,W
04352:  MOVWF  03
04354:  MOVF   01,W
04356:  ADDLW  20
04358:  MOVWF  FE9
0435A:  MOVLW  00
0435C:  ADDWFC 03,W
0435E:  MOVWF  FEA
04360:  MOVLW  84
04362:  MOVWF  FEF
04364:  MOVLW  FC
04366:  MOVWF  FEC
04368:  CLRF   FEC
0436A:  CLRF   FEC
0436C:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
0436E:  MOVLB  6
04370:  MOVF   x94,W
04372:  MULLW  20
04374:  MOVF   FF3,W
04376:  CLRF   xA2
04378:  MOVWF  xA1
0437A:  MOVLW  20
0437C:  ADDWF  xA1,W
0437E:  MOVWF  FE9
04380:  MOVLW  00
04382:  ADDWFC xA2,W
04384:  MOVWF  FEA
04386:  MOVFF  FEF,6E4
0438A:  MOVFF  FEC,01
0438E:  MOVFF  FEC,02
04392:  MOVFF  FEC,03
04396:  MOVFF  698,6E3
0439A:  MOVFF  697,6E2
0439E:  MOVFF  696,6E1
043A2:  MOVFF  695,6E0
043A6:  MOVFF  03,6E7
043AA:  MOVFF  02,6E6
043AE:  MOVFF  01,6E5
043B2:  MOVLB  0
043B4:  CALL   0E32
043B8:  MOVFF  03,69C
043BC:  MOVFF  02,69B
043C0:  MOVFF  01,69A
043C4:  MOVFF  00,699
043C8:  MOVLB  6
043CA:  MOVF   x94,W
043CC:  MULLW  20
043CE:  MOVF   FF3,W
043D0:  CLRF   xA4
043D2:  MOVWF  xA3
043D4:  MOVLW  08
043D6:  ADDWF  xA3,W
043D8:  MOVWF  01
043DA:  MOVLW  00
043DC:  ADDWFC xA4,W
043DE:  MOVWF  03
043E0:  MOVF   01,W
043E2:  ADDLW  20
043E4:  MOVWF  FE9
043E6:  MOVLW  00
043E8:  ADDWFC 03,W
043EA:  MOVWF  FEA
043EC:  MOVFF  FEF,6A3
043F0:  MOVFF  FEC,6A4
043F4:  MOVFF  FEC,6A5
043F8:  MOVFF  FEC,6A6
043FC:  MOVF   x94,W
043FE:  MULLW  20
04400:  MOVF   FF3,W
04402:  CLRF   xA8
04404:  MOVWF  xA7
04406:  MOVLW  10
04408:  ADDWF  xA7,W
0440A:  MOVWF  01
0440C:  MOVLW  00
0440E:  ADDWFC xA8,W
04410:  MOVWF  03
04412:  MOVF   01,W
04414:  ADDLW  20
04416:  MOVWF  FE9
04418:  MOVLW  00
0441A:  ADDWFC 03,W
0441C:  MOVWF  FEA
0441E:  MOVFF  FEF,6DF
04422:  MOVFF  FEC,6E0
04426:  MOVFF  FEC,6E1
0442A:  MOVFF  FEC,6E2
0442E:  MOVF   x94,W
04430:  MULLW  20
04432:  MOVF   FF3,W
04434:  CLRF   xAC
04436:  MOVWF  xAB
04438:  MOVLW  14
0443A:  ADDWF  xAB,W
0443C:  MOVWF  01
0443E:  MOVLW  00
04440:  ADDWFC xAC,W
04442:  MOVWF  03
04444:  MOVF   01,W
04446:  ADDLW  20
04448:  MOVWF  FE9
0444A:  MOVLW  00
0444C:  ADDWFC 03,W
0444E:  MOVWF  FEA
04450:  MOVFF  FEF,6E3
04454:  MOVFF  FEC,01
04458:  MOVFF  FEC,02
0445C:  MOVFF  FEC,03
04460:  MOVFF  FEA,6AC
04464:  MOVFF  FE9,6AB
04468:  BSF    FD8.1
0446A:  MOVFF  03,6E6
0446E:  MOVFF  02,6E5
04472:  MOVFF  01,6E4
04476:  MOVLB  0
04478:  CALL   0F28
0447C:  MOVFF  6AC,FEA
04480:  MOVFF  6AB,FE9
04484:  MOVFF  6A6,6E3
04488:  MOVFF  6A5,6E2
0448C:  MOVFF  6A4,6E1
04490:  MOVFF  6A3,6E0
04494:  MOVFF  03,6E7
04498:  MOVFF  02,6E6
0449C:  MOVFF  01,6E5
044A0:  MOVFF  00,6E4
044A4:  CALL   0E32
044A8:  MOVFF  03,6A0
044AC:  MOVFF  02,69F
044B0:  MOVFF  01,69E
044B4:  MOVFF  00,69D
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
044B8:  MOVLB  6
044BA:  MOVF   x94,W
044BC:  MULLW  20
044BE:  MOVF   FF3,W
044C0:  CLRF   xA2
044C2:  MOVWF  xA1
044C4:  MOVLW  18
044C6:  ADDWF  xA1,W
044C8:  MOVWF  01
044CA:  MOVLW  00
044CC:  ADDWFC xA2,W
044CE:  MOVWF  03
044D0:  MOVF   01,W
044D2:  ADDLW  20
044D4:  MOVWF  01
044D6:  MOVLW  00
044D8:  ADDWFC 03,F
044DA:  MOVFF  01,6A1
044DE:  MOVFF  03,6A2
044E2:  MOVF   x94,W
044E4:  MULLW  20
044E6:  MOVF   FF3,W
044E8:  CLRF   xA4
044EA:  MOVWF  xA3
044EC:  MOVLW  1C
044EE:  ADDWF  xA3,W
044F0:  MOVWF  01
044F2:  MOVLW  00
044F4:  ADDWFC xA4,W
044F6:  MOVWF  03
044F8:  MOVF   01,W
044FA:  ADDLW  20
044FC:  MOVWF  FE9
044FE:  MOVLW  00
04500:  ADDWFC 03,W
04502:  MOVWF  FEA
04504:  MOVFF  FEF,6E3
04508:  MOVFF  FEC,01
0450C:  MOVFF  FEC,02
04510:  MOVFF  FEC,03
04514:  MOVFF  FEA,6A4
04518:  MOVFF  FE9,6A3
0451C:  BCF    FD8.1
0451E:  MOVFF  69C,6E2
04522:  MOVFF  69B,6E1
04526:  MOVFF  69A,6E0
0452A:  MOVFF  699,6DF
0452E:  MOVFF  03,6E6
04532:  MOVFF  02,6E5
04536:  MOVFF  01,6E4
0453A:  MOVLB  0
0453C:  CALL   0F28
04540:  MOVFF  6A4,FEA
04544:  MOVFF  6A3,FE9
04548:  MOVFF  03,6A8
0454C:  MOVFF  02,6A7
04550:  MOVFF  01,6A6
04554:  MOVFF  00,6A5
04558:  BCF    FD8.1
0455A:  MOVFF  03,6E2
0455E:  MOVFF  02,6E1
04562:  MOVFF  01,6E0
04566:  MOVFF  00,6DF
0456A:  MOVFF  6A0,6E6
0456E:  MOVFF  69F,6E5
04572:  MOVFF  69E,6E4
04576:  MOVFF  69D,6E3
0457A:  CALL   0F28
0457E:  MOVFF  6A2,FEA
04582:  MOVFF  6A1,FE9
04586:  MOVFF  00,FEF
0458A:  MOVFF  01,FEC
0458E:  MOVFF  02,FEC
04592:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04596:  MOVLB  6
04598:  MOVF   x94,W
0459A:  MULLW  20
0459C:  MOVF   FF3,W
0459E:  CLRF   xA2
045A0:  MOVWF  xA1
045A2:  MOVLW  18
045A4:  ADDWF  xA1,W
045A6:  MOVWF  01
045A8:  MOVLW  00
045AA:  ADDWFC xA2,W
045AC:  MOVWF  03
045AE:  MOVF   01,W
045B0:  ADDLW  20
045B2:  MOVWF  FE9
045B4:  MOVLW  00
045B6:  ADDWFC 03,W
045B8:  MOVWF  FEA
045BA:  MOVFF  FEF,6DF
045BE:  MOVFF  FEC,6A2
045C2:  MOVFF  FEC,6E1
045C6:  MOVFF  FEC,6E2
045CA:  CLRF   xDE
045CC:  CLRF   xDD
045CE:  MOVLW  7C
045D0:  MOVWF  xDC
045D2:  MOVLW  84
045D4:  MOVWF  xDB
045D6:  MOVFF  6A2,6E0
045DA:  MOVLB  0
045DC:  CALL   1778
045E0:  BNC   4614
045E2:  MOVLB  6
045E4:  MOVF   x94,W
045E6:  MULLW  20
045E8:  MOVF   FF3,W
045EA:  CLRF   xA2
045EC:  MOVWF  xA1
045EE:  MOVLW  18
045F0:  ADDWF  xA1,W
045F2:  MOVWF  01
045F4:  MOVLW  00
045F6:  ADDWFC xA2,W
045F8:  MOVWF  03
045FA:  MOVF   01,W
045FC:  ADDLW  20
045FE:  MOVWF  FE9
04600:  MOVLW  00
04602:  ADDWFC 03,W
04604:  MOVWF  FEA
04606:  MOVLW  84
04608:  MOVWF  FEF
0460A:  MOVLW  7C
0460C:  MOVWF  FEC
0460E:  CLRF   FEC
04610:  CLRF   FEC
04612:  BRA    4690
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04614:  MOVLB  6
04616:  MOVF   x94,W
04618:  MULLW  20
0461A:  MOVF   FF3,W
0461C:  CLRF   xA2
0461E:  MOVWF  xA1
04620:  MOVLW  18
04622:  ADDWF  xA1,W
04624:  MOVWF  01
04626:  MOVLW  00
04628:  ADDWFC xA2,W
0462A:  MOVWF  03
0462C:  MOVF   01,W
0462E:  ADDLW  20
04630:  MOVWF  FE9
04632:  MOVLW  00
04634:  ADDWFC 03,W
04636:  MOVWF  FEA
04638:  MOVFF  FEF,6DB
0463C:  MOVFF  FEC,6A2
04640:  MOVFF  FEC,6DD
04644:  MOVFF  FEC,6DE
04648:  MOVFF  6A2,6DC
0464C:  CLRF   xE2
0464E:  CLRF   xE1
04650:  MOVLW  FC
04652:  MOVWF  xE0
04654:  MOVLW  84
04656:  MOVWF  xDF
04658:  MOVLB  0
0465A:  CALL   1778
0465E:  BNC   4690
04660:  MOVLB  6
04662:  MOVF   x94,W
04664:  MULLW  20
04666:  MOVF   FF3,W
04668:  CLRF   xA2
0466A:  MOVWF  xA1
0466C:  MOVLW  18
0466E:  ADDWF  xA1,W
04670:  MOVWF  01
04672:  MOVLW  00
04674:  ADDWFC xA2,W
04676:  MOVWF  03
04678:  MOVF   01,W
0467A:  ADDLW  20
0467C:  MOVWF  FE9
0467E:  MOVLW  00
04680:  ADDWFC 03,W
04682:  MOVWF  FEA
04684:  MOVLW  84
04686:  MOVWF  FEF
04688:  MOVLW  FC
0468A:  MOVWF  FEC
0468C:  CLRF   FEC
0468E:  CLRF   FEC
04690:  MOVLB  0
04692:  GOTO   470A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04696:  MOVLB  6
04698:  MOVF   x93,W
0469A:  MULLW  20
0469C:  MOVF   FF3,W
0469E:  CLRF   x95
046A0:  MOVWF  x94
046A2:  MOVLW  0C
046A4:  ADDWF  x94,W
046A6:  MOVWF  01
046A8:  MOVLW  00
046AA:  ADDWFC x95,W
046AC:  MOVWF  03
046AE:  MOVF   01,W
046B0:  ADDLW  20
046B2:  MOVWF  FE9
046B4:  MOVLW  00
046B6:  ADDWFC 03,W
046B8:  MOVWF  FEA
046BA:  MOVFF  FEF,6DB
046BE:  MOVFF  FEC,6DC
046C2:  MOVFF  FEC,6DD
046C6:  MOVFF  FEC,6DE
046CA:  MOVF   x93,W
046CC:  MULLW  20
046CE:  MOVF   FF3,W
046D0:  CLRF   x99
046D2:  MOVWF  x98
046D4:  MOVLW  10
046D6:  ADDWF  x98,W
046D8:  MOVWF  01
046DA:  MOVLW  00
046DC:  ADDWFC x99,W
046DE:  MOVWF  03
046E0:  MOVF   01,W
046E2:  ADDLW  20
046E4:  MOVWF  FE9
046E6:  MOVLW  00
046E8:  ADDWFC 03,W
046EA:  MOVWF  FEA
046EC:  MOVFF  FEF,6DF
046F0:  MOVFF  FEC,6E0
046F4:  MOVFF  FEC,6E1
046F8:  MOVFF  FEC,6E2
046FC:  MOVLB  0
046FE:  CALL   1778
04702:  BZ    470A
04704:  MOVFF  693,694
04708:  BRA    4104
....................    if ((index++) >= numChannels) index = 0;
0470A:  MOVLB  2
0470C:  MOVF   x06,W
0470E:  INCF   x06,F
04710:  SUBLW  01
04712:  BC    4716
04714:  CLRF   x06
04716:  MOVLB  0
04718:  GOTO   4804 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00BB6:  CLRF   03
00BB8:  MOVF   F91,W
00BBA:  MOVFF  695,F91
00BBE:  RRCF   F94,W
00BC0:  BNC   0BBE
00BC2:  MOVF   F91,W
00BC4:  MOVWF  02
00BC6:  MOVFF  694,F91
00BCA:  RRCF   F94,W
00BCC:  BNC   0BCA
00BCE:  MOVF   F91,W
00BD0:  MOVWF  01
00BD2:  MOVFF  693,F91
00BD6:  RRCF   F94,W
00BD8:  BNC   0BD6
00BDA:  MOVFF  F91,00
00BDE:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04060:  MOVLB  6
04062:  MOVF   x94,F
04064:  BZ    40B4
....................       if (chMap[0] == ch) output_low(INV_HVX);
04066:  MOVLW  00
04068:  MOVLB  0
0406A:  BTFSC  x60.0
0406C:  MOVLW  01
0406E:  MOVLB  6
04070:  SUBWF  x93,W
04072:  BNZ   407A
04074:  MOVLW  C4
04076:  MOVWF  F88
04078:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0407A:  MOVLW  00
0407C:  MOVLB  0
0407E:  BTFSC  x60.1
04080:  MOVLW  01
04082:  MOVLB  6
04084:  SUBWF  x93,W
04086:  BNZ   408E
04088:  MOVLW  C4
0408A:  MOVWF  F88
0408C:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
0408E:  MOVF   x93,W
04090:  MULLW  03
04092:  MOVF   FF3,W
04094:  CLRF   x96
04096:  MOVWF  x95
04098:  MOVLW  02
0409A:  ADDWF  x95,W
0409C:  MOVWF  01
0409E:  MOVLW  00
040A0:  ADDWFC x96,W
040A2:  MOVWF  03
040A4:  MOVF   01,W
040A6:  ADDLW  51
040A8:  MOVWF  FE9
040AA:  MOVLW  01
040AC:  ADDWFC 03,W
040AE:  MOVWF  FEA
040B0:  BSF    FEF.0
....................    }
040B2:  BRA    4100
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
040B4:  MOVLW  00
040B6:  MOVLB  0
040B8:  BTFSC  x60.0
040BA:  MOVLW  01
040BC:  MOVLB  6
040BE:  SUBWF  x93,W
040C0:  BNZ   40C8
040C2:  MOVLW  C4
040C4:  MOVWF  F88
040C6:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
040C8:  MOVLW  00
040CA:  MOVLB  0
040CC:  BTFSC  x60.1
040CE:  MOVLW  01
040D0:  MOVLB  6
040D2:  SUBWF  x93,W
040D4:  BNZ   40DC
040D6:  MOVLW  C4
040D8:  MOVWF  F88
040DA:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
040DC:  MOVF   x93,W
040DE:  MULLW  03
040E0:  MOVF   FF3,W
040E2:  CLRF   x96
040E4:  MOVWF  x95
040E6:  MOVLW  02
040E8:  ADDWF  x95,W
040EA:  MOVWF  01
040EC:  MOVLW  00
040EE:  ADDWFC x96,W
040F0:  MOVWF  03
040F2:  MOVF   01,W
040F4:  ADDLW  51
040F6:  MOVWF  FE9
040F8:  MOVLW  01
040FA:  ADDWFC 03,W
040FC:  MOVWF  FEA
040FE:  BCF    FEF.0
....................    }
04100:  MOVLB  0
04102:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
0471C:  MOVLB  6
0471E:  CLRF   x92
04720:  CLRF   x91
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04722:  MOVFF  690,69D
04726:  CLRF   x9F
04728:  MOVLW  61
0472A:  MOVWF  x9E
0472C:  MOVLB  0
0472E:  RCALL  402A
04730:  MOVF   01,F
04732:  BNZ   47FE
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04734:  MOVLB  6
04736:  MOVF   x90,W
04738:  MULLW  04
0473A:  MOVF   FF3,W
0473C:  CLRF   03
0473E:  ADDLW  EA
04740:  MOVWF  FE9
04742:  MOVLW  00
04744:  ADDWFC 03,W
04746:  MOVWF  FEA
04748:  MOVFF  FEF,6DB
0474C:  MOVFF  FEC,6DC
04750:  MOVFF  FEC,6DD
04754:  MOVFF  FEC,6DE
04758:  CLRF   xE2
0475A:  CLRF   xE1
0475C:  CLRF   xE0
0475E:  CLRF   xDF
04760:  MOVLB  0
04762:  CALL   1778
04766:  BNC   4778
04768:  MOVFF  690,693
0476C:  MOVLW  01
0476E:  MOVLB  6
04770:  MOVWF  x94
04772:  MOVLB  0
04774:  RCALL  4060
04776:  BRA    4784
....................       else                             invert_voltage(ch, FALSE);
04778:  MOVFF  690,693
0477C:  MOVLB  6
0477E:  CLRF   x94
04780:  MOVLB  0
04782:  RCALL  4060
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04784:  MOVLB  6
04786:  MOVF   x90,W
04788:  MULLW  04
0478A:  MOVF   FF3,W
0478C:  CLRF   03
0478E:  ADDLW  EA
04790:  MOVWF  FE9
04792:  MOVLW  00
04794:  ADDWFC 03,W
04796:  MOVWF  FEA
04798:  MOVFF  FEF,00
0479C:  MOVFF  FEC,01
047A0:  MOVFF  FEC,02
047A4:  MOVFF  FEC,03
047A8:  BCF    01.7
047AA:  MOVFF  03,696
047AE:  MOVFF  02,695
047B2:  MOVFF  01,694
047B6:  MOVFF  00,693
047BA:  MOVFF  03,6E3
047BE:  MOVFF  02,6E2
047C2:  MOVFF  01,6E1
047C6:  MOVFF  00,6E0
047CA:  MOVLW  66
047CC:  MOVWF  xE7
047CE:  MOVLW  D6
047D0:  MOVWF  xE6
047D2:  MOVLW  23
047D4:  MOVWF  xE5
047D6:  MOVLW  88
047D8:  MOVWF  xE4
047DA:  MOVLB  0
047DC:  CALL   0E32
047E0:  MOVFF  03,6DE
047E4:  MOVFF  02,6DD
047E8:  MOVFF  01,6DC
047EC:  MOVFF  00,6DB
047F0:  CALL   216C
047F4:  MOVFF  02,692
047F8:  MOVFF  01,691
....................    }
047FC:  BRA    48EE
....................    else {
....................       pid_task(ch);
047FE:  MOVFF  690,693
04802:  BRA    4696
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04804:  MOVLB  6
04806:  MOVF   x90,W
04808:  MULLW  20
0480A:  MOVF   FF3,W
0480C:  CLRF   x94
0480E:  MOVWF  x93
04810:  MOVLW  18
04812:  ADDWF  x93,W
04814:  MOVWF  01
04816:  MOVLW  00
04818:  ADDWFC x94,W
0481A:  MOVWF  03
0481C:  MOVF   01,W
0481E:  ADDLW  20
04820:  MOVWF  FE9
04822:  MOVLW  00
04824:  ADDWFC 03,W
04826:  MOVWF  FEA
04828:  MOVFF  FEF,6DB
0482C:  MOVFF  FEC,6DC
04830:  MOVFF  FEC,6DD
04834:  MOVFF  FEC,6DE
04838:  CLRF   xE2
0483A:  CLRF   xE1
0483C:  CLRF   xE0
0483E:  CLRF   xDF
04840:  MOVLB  0
04842:  CALL   1778
04846:  BNC   4858
04848:  MOVFF  690,693
0484C:  MOVLW  01
0484E:  MOVLB  6
04850:  MOVWF  x94
04852:  MOVLB  0
04854:  RCALL  4060
04856:  BRA    4866
....................       else                       invert_voltage(ch, FALSE);
04858:  MOVFF  690,693
0485C:  MOVLB  6
0485E:  CLRF   x94
04860:  MOVLB  0
04862:  CALL   4060
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04866:  MOVLB  6
04868:  MOVF   x90,W
0486A:  MULLW  20
0486C:  MOVF   FF3,W
0486E:  CLRF   x94
04870:  MOVWF  x93
04872:  MOVLW  18
04874:  ADDWF  x93,W
04876:  MOVWF  01
04878:  MOVLW  00
0487A:  ADDWFC x94,W
0487C:  MOVWF  03
0487E:  MOVF   01,W
04880:  ADDLW  20
04882:  MOVWF  FE9
04884:  MOVLW  00
04886:  ADDWFC 03,W
04888:  MOVWF  FEA
0488A:  MOVFF  FEF,00
0488E:  MOVFF  FEC,01
04892:  MOVFF  FEC,02
04896:  MOVFF  FEC,03
0489A:  BCF    01.7
0489C:  MOVFF  03,696
048A0:  MOVFF  02,695
048A4:  MOVFF  01,694
048A8:  MOVFF  00,693
048AC:  MOVFF  03,6E3
048B0:  MOVFF  02,6E2
048B4:  MOVFF  01,6E1
048B8:  MOVFF  00,6E0
048BC:  MOVLW  66
048BE:  MOVWF  xE7
048C0:  MOVLW  D6
048C2:  MOVWF  xE6
048C4:  MOVLW  23
048C6:  MOVWF  xE5
048C8:  MOVLW  88
048CA:  MOVWF  xE4
048CC:  MOVLB  0
048CE:  CALL   0E32
048D2:  MOVFF  03,6DE
048D6:  MOVFF  02,6DD
048DA:  MOVFF  01,6DC
048DE:  MOVFF  00,6DB
048E2:  CALL   216C
048E6:  MOVFF  02,692
048EA:  MOVFF  01,691
....................    }
....................    
....................    dacVals[ch].val = txData;
048EE:  MOVLB  6
048F0:  MOVF   x90,W
048F2:  MULLW  03
048F4:  MOVF   FF3,W
048F6:  CLRF   x94
048F8:  MOVWF  x93
048FA:  MOVLW  51
048FC:  ADDWF  x93,W
048FE:  MOVWF  FE9
04900:  MOVLW  01
04902:  ADDWFC x94,W
04904:  MOVWF  FEA
04906:  MOVFF  692,FEC
0490A:  MOVF   FED,F
0490C:  MOVFF  691,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04910:  MOVLW  00
04912:  MOVLB  0
04914:  BTFSC  x60.0
04916:  MOVLW  01
04918:  MOVLB  6
0491A:  SUBWF  x90,W
0491C:  BNZ   4924
0491E:  MOVLW  E8
04920:  MOVWF  F8B
04922:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04924:  MOVLW  00
04926:  MOVLB  0
04928:  BTFSC  x60.1
0492A:  MOVLW  01
0492C:  MOVLB  6
0492E:  SUBWF  x90,W
04930:  BNZ   4938
04932:  MOVLW  E8
04934:  MOVWF  F8B
04936:  BSF    F86.1
....................    
....................    delay_ms(1);
04938:  MOVLW  01
0493A:  MOVWF  x98
0493C:  MOVLB  0
0493E:  CALL   0430
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04942:  MOVLW  00
04944:  BTFSC  x60.0
04946:  MOVLW  01
04948:  MOVLB  6
0494A:  SUBWF  x90,W
0494C:  BNZ   4954
0494E:  MOVLW  E8
04950:  MOVWF  F8B
04952:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04954:  MOVLW  00
04956:  MOVLB  0
04958:  BTFSC  x60.1
0495A:  MOVLW  01
0495C:  MOVLB  6
0495E:  SUBWF  x90,W
04960:  BNZ   4968
04962:  MOVLW  E8
04964:  MOVWF  F8B
04966:  BCF    F86.1
....................    delay_ms(1);
04968:  MOVLW  01
0496A:  MOVWF  x98
0496C:  MOVLB  0
0496E:  CALL   0430
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04972:  MOVLB  6
04974:  CLRF   x96
04976:  CLRF   x95
04978:  MOVFF  692,694
0497C:  MOVFF  691,693
04980:  MOVLB  0
04982:  CALL   0BB6
....................    delay_ms(1);
04986:  MOVLW  01
04988:  MOVLB  6
0498A:  MOVWF  x98
0498C:  MOVLB  0
0498E:  CALL   0430
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04992:  MOVLW  00
04994:  BTFSC  x60.0
04996:  MOVLW  01
04998:  MOVLB  6
0499A:  SUBWF  x90,W
0499C:  BNZ   49A4
0499E:  MOVLW  E8
049A0:  MOVWF  F8B
049A2:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
049A4:  MOVLW  00
049A6:  MOVLB  0
049A8:  BTFSC  x60.1
049AA:  MOVLW  01
049AC:  MOVLB  6
049AE:  SUBWF  x90,W
049B0:  BNZ   49B8
049B2:  MOVLW  E8
049B4:  MOVWF  F8B
049B6:  BSF    F86.1
049B8:  MOVLB  0
049BA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
049BC:  MOVLB  2
049BE:  MOVF   x07,W
049C0:  XORLW  00
049C2:  MOVLB  0
049C4:  BZ    49CC
049C6:  XORLW  01
049C8:  BZ    49DE
049CA:  BRA    49EE
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
049CC:  MOVLB  6
049CE:  CLRF   x90
049D0:  MOVLB  0
049D2:  RCALL  471C
....................          state = 1;
049D4:  MOVLW  01
049D6:  MOVLB  2
049D8:  MOVWF  x07
....................       break;
049DA:  MOVLB  0
049DC:  BRA    49EE
....................       case 1:
....................          set_nanoDAC_outputs(chY);
049DE:  MOVLW  01
049E0:  MOVLB  6
049E2:  MOVWF  x90
049E4:  MOVLB  0
049E6:  RCALL  471C
....................          state = 0;
049E8:  MOVLB  2
049EA:  CLRF   x07
....................       break;
049EC:  MOVLB  0
....................    }
049EE:  GOTO   A016 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00BE0:  MOVLB  6
00BE2:  CLRF   x96
00BE4:  CLRF   x95
00BE6:  CLRF   x94
00BE8:  CLRF   x93
00BEA:  MOVLB  0
00BEC:  RCALL  0BB6
....................    output_low(_SYNC_X);
00BEE:  MOVLW  E8
00BF0:  MOVWF  F8B
00BF2:  BCF    F86.2
....................    output_low(_SYNC_Y);
00BF4:  MOVWF  F8B
00BF6:  BCF    F86.1
....................    output_high(_SYNC_X);
00BF8:  MOVWF  F8B
00BFA:  BSF    F86.2
....................    output_high(_SYNC_Y);
00BFC:  MOVWF  F8B
00BFE:  BSF    F86.1
00C00:  GOTO   A002 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
00C26:  MOVLB  6
00C28:  MOVF   x91,W
00C2A:  SUBLW  03
00C2C:  BTFSS  FD8.0
00C2E:  BRA    0D9C
....................    {
....................       for (int i = 0; i <numParam; i ++)
00C30:  CLRF   x92
00C32:  MOVF   x92,W
00C34:  SUBLW  06
00C36:  BNC   0C86
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00C38:  CLRF   xD2
00C3A:  MOVFF  691,6D1
00C3E:  CLRF   xD4
00C40:  MOVLW  B5
00C42:  MOVWF  xD3
00C44:  MOVLB  0
00C46:  RCALL  0C04
00C48:  MOVFF  02,694
00C4C:  MOVFF  01,693
00C50:  MOVLW  06
00C52:  MOVLB  6
00C54:  ADDWF  x93,F
00C56:  MOVLW  00
00C58:  ADDWFC x94,F
00C5A:  CLRF   xD2
00C5C:  MOVFF  692,6D1
00C60:  CLRF   xD4
00C62:  MOVLW  19
00C64:  MOVWF  xD3
00C66:  MOVLB  0
00C68:  RCALL  0C04
00C6A:  MOVF   01,W
00C6C:  MOVLB  6
00C6E:  ADDWF  x93,F
00C70:  MOVF   02,W
00C72:  ADDWFC x94,F
00C74:  MOVLW  08
00C76:  ADDWF  x93,W
00C78:  MOVWF  FE9
00C7A:  MOVLW  02
00C7C:  ADDWFC x94,W
00C7E:  MOVWF  FEA
00C80:  CLRF   FEF
00C82:  INCF   x92,F
00C84:  BRA    0C32
....................       }
....................       SERcmd[recNum].t = 0;
00C86:  CLRF   xD2
00C88:  MOVFF  691,6D1
00C8C:  CLRF   xD4
00C8E:  MOVLW  B5
00C90:  MOVWF  xD3
00C92:  MOVLB  0
00C94:  RCALL  0C04
00C96:  MOVFF  01,693
00C9A:  MOVLW  05
00C9C:  MOVLB  6
00C9E:  ADDWF  01,W
00CA0:  MOVWF  01
00CA2:  MOVLW  00
00CA4:  ADDWFC 02,W
00CA6:  MOVWF  03
00CA8:  MOVF   01,W
00CAA:  ADDLW  08
00CAC:  MOVWF  FE9
00CAE:  MOVLW  02
00CB0:  ADDWFC 03,W
00CB2:  MOVWF  FEA
00CB4:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00CB6:  CLRF   xD2
00CB8:  MOVFF  691,6D1
00CBC:  CLRF   xD4
00CBE:  MOVLW  B5
00CC0:  MOVWF  xD3
00CC2:  MOVLB  0
00CC4:  RCALL  0C04
00CC6:  MOVFF  01,693
00CCA:  MOVLW  01
00CCC:  MOVLB  6
00CCE:  ADDWF  01,W
00CD0:  MOVWF  01
00CD2:  MOVLW  00
00CD4:  ADDWFC 02,W
00CD6:  MOVWF  03
00CD8:  MOVF   01,W
00CDA:  ADDLW  08
00CDC:  MOVWF  FE9
00CDE:  MOVLW  02
00CE0:  ADDWFC 03,W
00CE2:  MOVWF  FEA
00CE4:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00CE6:  CLRF   xD2
00CE8:  MOVFF  691,6D1
00CEC:  CLRF   xD4
00CEE:  MOVLW  B5
00CF0:  MOVWF  xD3
00CF2:  MOVLB  0
00CF4:  RCALL  0C04
00CF6:  MOVFF  01,693
00CFA:  MOVLW  02
00CFC:  MOVLB  6
00CFE:  ADDWF  01,W
00D00:  MOVWF  01
00D02:  MOVLW  00
00D04:  ADDWFC 02,W
00D06:  MOVWF  03
00D08:  MOVF   01,W
00D0A:  ADDLW  08
00D0C:  MOVWF  FE9
00D0E:  MOVLW  02
00D10:  ADDWFC 03,W
00D12:  MOVWF  FEA
00D14:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00D16:  CLRF   xD2
00D18:  MOVFF  691,6D1
00D1C:  CLRF   xD4
00D1E:  MOVLW  B5
00D20:  MOVWF  xD3
00D22:  MOVLB  0
00D24:  RCALL  0C04
00D26:  MOVFF  01,693
00D2A:  MOVLW  03
00D2C:  MOVLB  6
00D2E:  ADDWF  01,W
00D30:  MOVWF  01
00D32:  MOVLW  00
00D34:  ADDWFC 02,W
00D36:  MOVWF  03
00D38:  MOVF   01,W
00D3A:  ADDLW  08
00D3C:  MOVWF  FE9
00D3E:  MOVLW  02
00D40:  ADDWFC 03,W
00D42:  MOVWF  FEA
00D44:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00D46:  CLRF   xD2
00D48:  MOVFF  691,6D1
00D4C:  CLRF   xD4
00D4E:  MOVLW  B5
00D50:  MOVWF  xD3
00D52:  MOVLB  0
00D54:  RCALL  0C04
00D56:  MOVFF  01,693
00D5A:  MOVLW  04
00D5C:  MOVLB  6
00D5E:  ADDWF  01,W
00D60:  MOVWF  01
00D62:  MOVLW  00
00D64:  ADDWFC 02,W
00D66:  MOVWF  03
00D68:  MOVF   01,W
00D6A:  ADDLW  08
00D6C:  MOVWF  FE9
00D6E:  MOVLW  02
00D70:  ADDWFC 03,W
00D72:  MOVWF  FEA
00D74:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00D76:  CLRF   xD2
00D78:  MOVFF  691,6D1
00D7C:  CLRF   xD4
00D7E:  MOVLW  B5
00D80:  MOVWF  xD3
00D82:  MOVLB  0
00D84:  RCALL  0C04
00D86:  MOVLW  08
00D88:  MOVLB  6
00D8A:  ADDWF  01,W
00D8C:  MOVWF  FE9
00D8E:  MOVLW  02
00D90:  ADDWFC 02,W
00D92:  MOVWF  FEA
00D94:  BCF    FEF.0
....................       retData[0] = '\0';
00D96:  MOVLB  4
00D98:  CLRF   xDE
00D9A:  MOVLB  6
....................    }
00D9C:  MOVLB  0
00D9E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
0539A:  MOVLB  6
0539C:  CLRF   xD2
0539E:  MOVFF  4DC,6D1
053A2:  CLRF   xD4
053A4:  MOVLW  B5
053A6:  MOVWF  xD3
053A8:  MOVLB  0
053AA:  CALL   0C04
053AE:  MOVFF  02,692
053B2:  MOVFF  01,691
053B6:  MOVLW  08
053B8:  MOVLB  6
053BA:  ADDWF  01,W
053BC:  MOVWF  FE9
053BE:  MOVLW  02
053C0:  ADDWFC 02,W
053C2:  MOVWF  FEA
053C4:  BTFSC  FEF.0
053C6:  BRA    53E8
....................    {
....................       if (SRI == SWI) return FALSE;
053C8:  MOVLB  4
053CA:  MOVF   xDD,W
053CC:  SUBWF  xDC,W
053CE:  BNZ   53D6
053D0:  MOVLW  00
053D2:  MOVWF  01
053D4:  BRA    53EE
....................       SRI +=1;
053D6:  MOVLW  01
053D8:  ADDWF  xDC,F
....................       if (SRI >= numRecords) SRI=0;
053DA:  MOVF   xDC,W
053DC:  SUBLW  03
053DE:  BC    53E2
053E0:  CLRF   xDC
053E2:  MOVLB  0
053E4:  BRA    539A
053E6:  MOVLB  6
....................    }
....................    return TRUE;
053E8:  MOVLW  01
053EA:  MOVWF  01
053EC:  MOVLB  4
053EE:  MOVLB  0
053F0:  GOTO   9B5C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
04A26:  MOVLW  01
04A28:  MOVLB  4
04A2A:  ADDWF  xDD,F
....................    if (SWI >= numRecords) SWI=0;
04A2C:  MOVF   xDD,W
04A2E:  SUBLW  03
04A30:  BC    4A34
04A32:  CLRF   xDD
04A34:  MOVLB  0
04A36:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,581
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x81.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
04A38:  MOVLW  93
04A3A:  MOVWF  F89
04A3C:  BSF    F84.5
04A3E:  MOVLB  E
04A40:  BTFSS  xC8.4
04A42:  BRA    4A40
04A44:  MOVLW  93
04A46:  MOVWF  F89
04A48:  BSF    F84.5
04A4A:  MOVLB  6
04A4C:  MOVFF  6A6,F99
04A50:  NOP   
04A52:  BTFSS  F9D.1
04A54:  BRA    4A52
04A56:  MOVLW  93
04A58:  MOVWF  F89
04A5A:  BCF    F84.5
04A5C:  MOVLB  0
04A5E:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x7E,W
000F6:  ADDLW  42
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,703
00104:  MOVFF  FE9,702
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  703,FEA
00110:  MOVFF  702,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x7E,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x7E,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x7E
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    x80.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
049F2:  CLRF   03
049F4:  MOVLB  5
049F6:  MOVF   x7F,W
049F8:  ADDLW  42
049FA:  MOVWF  FE9
049FC:  MOVLW  05
049FE:  ADDWFC 03,W
04A00:  MOVWF  FEA
04A02:  MOVFF  FEF,691
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
04A06:  MOVLW  01
04A08:  ADDWF  x7F,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
04A0A:  MOVF   x7F,W
04A0C:  SUBLW  3B
04A0E:  BC    4A12
04A10:  CLRF   x7F
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
04A12:  MOVF   x7E,W
04A14:  SUBWF  x7F,W
04A16:  BNZ   4A1A
04A18:  BCF    x80.0
....................    return data;
04A1A:  MOVLB  6
04A1C:  MOVFF  691,01
04A20:  MOVLB  0
04A22:  GOTO   4AC6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
04A84:  MOVLB  5
04A86:  BTFSS  x80.0
04A88:  BRA    4F76
04A8A:  MOVLB  6
04A8C:  CLRF   xD2
04A8E:  MOVFF  4DD,6D1
04A92:  CLRF   xD4
04A94:  MOVLW  B5
04A96:  MOVWF  xD3
04A98:  MOVLB  0
04A9A:  CALL   0C04
04A9E:  MOVFF  02,692
04AA2:  MOVFF  01,691
04AA6:  MOVLW  08
04AA8:  MOVLB  6
04AAA:  ADDWF  01,W
04AAC:  MOVWF  01
04AAE:  MOVLW  02
04AB0:  ADDWFC 02,W
04AB2:  MOVWF  03
04AB4:  MOVFF  01,FE9
04AB8:  MOVWF  FEA
04ABA:  BTFSS  FEF.0
04ABC:  BRA    4AC2
04ABE:  MOVLB  5
04AC0:  BRA    4F76
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
04AC2:  MOVLB  0
04AC4:  BRA    49F2
04AC6:  MOVFF  01,690
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
04ACA:  MOVLB  6
04ACC:  MOVF   x90,W
04ACE:  SUBLW  0D
04AD0:  BZ    4AD8
04AD2:  MOVF   x90,W
04AD4:  SUBLW  20
04AD6:  BNZ   4ADA
....................       {
....................       }
04AD8:  BRA    4F70
....................       else if (rxChar == UART_SOT_CHAR)
04ADA:  MOVF   x90,W
04ADC:  SUBLW  7E
04ADE:  BNZ   4B22
....................       {
....................          resetSERcmd(SWI);
04AE0:  MOVFF  4DD,691
04AE4:  MOVLB  0
04AE6:  CALL   0C26
....................          SERcmd[SWI].t = rxChar;
04AEA:  MOVLB  6
04AEC:  CLRF   xD2
04AEE:  MOVFF  4DD,6D1
04AF2:  CLRF   xD4
04AF4:  MOVLW  B5
04AF6:  MOVWF  xD3
04AF8:  MOVLB  0
04AFA:  CALL   0C04
04AFE:  MOVFF  01,691
04B02:  MOVLW  05
04B04:  MOVLB  6
04B06:  ADDWF  01,W
04B08:  MOVWF  01
04B0A:  MOVLW  00
04B0C:  ADDWFC 02,W
04B0E:  MOVWF  03
04B10:  MOVF   01,W
04B12:  ADDLW  08
04B14:  MOVWF  FE9
04B16:  MOVLW  02
04B18:  ADDWFC 03,W
04B1A:  MOVWF  FEA
04B1C:  MOVFF  690,FEF
....................       }
04B20:  BRA    4F70
....................       else if (rxChar >= oneByteCmdTestValue)
04B22:  MOVF   x90,W
04B24:  SUBLW  7F
04B26:  BC    4B92
....................       {
....................          resetSERcmd(SWI);
04B28:  MOVFF  4DD,691
04B2C:  MOVLB  0
04B2E:  CALL   0C26
....................          SERcmd[SWI].t = rxChar;
04B32:  MOVLB  6
04B34:  CLRF   xD2
04B36:  MOVFF  4DD,6D1
04B3A:  CLRF   xD4
04B3C:  MOVLW  B5
04B3E:  MOVWF  xD3
04B40:  MOVLB  0
04B42:  CALL   0C04
04B46:  MOVFF  01,691
04B4A:  MOVLW  05
04B4C:  MOVLB  6
04B4E:  ADDWF  01,W
04B50:  MOVWF  01
04B52:  MOVLW  00
04B54:  ADDWFC 02,W
04B56:  MOVWF  03
04B58:  MOVF   01,W
04B5A:  ADDLW  08
04B5C:  MOVWF  FE9
04B5E:  MOVLW  02
04B60:  ADDWFC 03,W
04B62:  MOVWF  FEA
04B64:  MOVFF  690,FEF
....................          SERcmd[SWI].full = TRUE;
04B68:  CLRF   xD2
04B6A:  MOVFF  4DD,6D1
04B6E:  CLRF   xD4
04B70:  MOVLW  B5
04B72:  MOVWF  xD3
04B74:  MOVLB  0
04B76:  CALL   0C04
04B7A:  MOVLW  08
04B7C:  MOVLB  6
04B7E:  ADDWF  01,W
04B80:  MOVWF  FE9
04B82:  MOVLW  02
04B84:  ADDWFC 02,W
04B86:  MOVWF  FEA
04B88:  BSF    FEF.0
....................          setNextSERWriteIndex();
04B8A:  MOVLB  0
04B8C:  RCALL  4A26
....................       }
04B8E:  BRA    4F6E
04B90:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
04B92:  MOVF   x90,W
04B94:  SUBLW  0A
04B96:  BTFSS  FD8.2
04B98:  BRA    4C9E
....................       {
....................          SERcmd[SWI].full = TRUE;
04B9A:  CLRF   xD2
04B9C:  MOVFF  4DD,6D1
04BA0:  CLRF   xD4
04BA2:  MOVLW  B5
04BA4:  MOVWF  xD3
04BA6:  MOVLB  0
04BA8:  CALL   0C04
04BAC:  MOVLW  08
04BAE:  MOVLB  6
04BB0:  ADDWF  01,W
04BB2:  MOVWF  FE9
04BB4:  MOVLW  02
04BB6:  ADDWFC 02,W
04BB8:  MOVWF  FEA
04BBA:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
04BBC:  CLRF   xD2
04BBE:  MOVFF  4DD,6D1
04BC2:  CLRF   xD4
04BC4:  MOVLW  B5
04BC6:  MOVWF  xD3
04BC8:  MOVLB  0
04BCA:  CALL   0C04
04BCE:  MOVFF  01,691
04BD2:  MOVLW  04
04BD4:  MOVLB  6
04BD6:  ADDWF  01,W
04BD8:  MOVWF  01
04BDA:  MOVLW  00
04BDC:  ADDWFC 02,W
04BDE:  MOVWF  03
04BE0:  MOVF   01,W
04BE2:  ADDLW  08
04BE4:  MOVWF  01
04BE6:  MOVLW  02
04BE8:  ADDWFC 03,F
04BEA:  MOVFF  01,691
04BEE:  MOVFF  03,692
04BF2:  CLRF   xD2
04BF4:  MOVFF  4DD,6D1
04BF8:  CLRF   xD4
04BFA:  MOVLW  B5
04BFC:  MOVWF  xD3
04BFE:  MOVLB  0
04C00:  CALL   0C04
04C04:  MOVFF  01,693
04C08:  MOVLW  02
04C0A:  MOVLB  6
04C0C:  ADDWF  01,W
04C0E:  MOVWF  01
04C10:  MOVLW  00
04C12:  ADDWFC 02,W
04C14:  MOVWF  03
04C16:  MOVF   01,W
04C18:  ADDLW  08
04C1A:  MOVWF  FE9
04C1C:  MOVLW  02
04C1E:  ADDWFC 03,W
04C20:  MOVWF  FEA
04C22:  MOVFF  FEF,693
04C26:  MOVFF  692,FEA
04C2A:  MOVFF  691,FE9
04C2E:  MOVFF  693,FEF
....................          SERcmd[SWI].chrIndex = 0;
04C32:  CLRF   xD2
04C34:  MOVFF  4DD,6D1
04C38:  CLRF   xD4
04C3A:  MOVLW  B5
04C3C:  MOVWF  xD3
04C3E:  MOVLB  0
04C40:  CALL   0C04
04C44:  MOVFF  01,691
04C48:  MOVLW  01
04C4A:  MOVLB  6
04C4C:  ADDWF  01,W
04C4E:  MOVWF  01
04C50:  MOVLW  00
04C52:  ADDWFC 02,W
04C54:  MOVWF  03
04C56:  MOVF   01,W
04C58:  ADDLW  08
04C5A:  MOVWF  FE9
04C5C:  MOVLW  02
04C5E:  ADDWFC 03,W
04C60:  MOVWF  FEA
04C62:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
04C64:  CLRF   xD2
04C66:  MOVFF  4DD,6D1
04C6A:  CLRF   xD4
04C6C:  MOVLW  B5
04C6E:  MOVWF  xD3
04C70:  MOVLB  0
04C72:  CALL   0C04
04C76:  MOVFF  01,691
04C7A:  MOVLW  02
04C7C:  MOVLB  6
04C7E:  ADDWF  01,W
04C80:  MOVWF  01
04C82:  MOVLW  00
04C84:  ADDWFC 02,W
04C86:  MOVWF  03
04C88:  MOVF   01,W
04C8A:  ADDLW  08
04C8C:  MOVWF  FE9
04C8E:  MOVLW  02
04C90:  ADDWFC 03,W
04C92:  MOVWF  FEA
04C94:  CLRF   FEF
....................          setNextSERWriteIndex();
04C96:  MOVLB  0
04C98:  RCALL  4A26
....................       }
04C9A:  BRA    4F6E
04C9C:  MOVLB  6
....................       else if (rxChar == delimiter)
04C9E:  MOVF   x90,W
04CA0:  SUBLW  2C
04CA2:  BNZ   4D60
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
04CA4:  CLRF   xD2
04CA6:  MOVFF  4DD,6D1
04CAA:  CLRF   xD4
04CAC:  MOVLW  B5
04CAE:  MOVWF  xD3
04CB0:  MOVLB  0
04CB2:  CALL   0C04
04CB6:  MOVFF  02,692
04CBA:  MOVFF  01,691
04CBE:  MOVLW  02
04CC0:  MOVLB  6
04CC2:  ADDWF  01,W
04CC4:  MOVWF  01
04CC6:  MOVLW  00
04CC8:  ADDWFC 02,W
04CCA:  MOVWF  03
04CCC:  MOVF   01,W
04CCE:  ADDLW  08
04CD0:  MOVWF  FE9
04CD2:  MOVLW  02
04CD4:  ADDWFC 03,W
04CD6:  MOVWF  FEA
04CD8:  MOVF   FEF,W
04CDA:  SUBLW  05
04CDC:  BNC   4D48
....................          {
....................             SERcmd[SWI].paramIndex +=1;
04CDE:  CLRF   xD2
04CE0:  MOVFF  4DD,6D1
04CE4:  CLRF   xD4
04CE6:  MOVLW  B5
04CE8:  MOVWF  xD3
04CEA:  MOVLB  0
04CEC:  CALL   0C04
04CF0:  MOVFF  01,691
04CF4:  MOVLW  02
04CF6:  MOVLB  6
04CF8:  ADDWF  01,W
04CFA:  MOVWF  01
04CFC:  MOVLW  00
04CFE:  ADDWFC 02,W
04D00:  MOVWF  03
04D02:  MOVF   01,W
04D04:  ADDLW  08
04D06:  MOVWF  FE9
04D08:  MOVLW  02
04D0A:  ADDWFC 03,W
04D0C:  MOVWF  FEA
04D0E:  MOVLW  01
04D10:  ADDWF  FEF,W
04D12:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
04D14:  CLRF   xD2
04D16:  MOVFF  4DD,6D1
04D1A:  CLRF   xD4
04D1C:  MOVLW  B5
04D1E:  MOVWF  xD3
04D20:  MOVLB  0
04D22:  CALL   0C04
04D26:  MOVFF  01,691
04D2A:  MOVLW  01
04D2C:  MOVLB  6
04D2E:  ADDWF  01,W
04D30:  MOVWF  01
04D32:  MOVLW  00
04D34:  ADDWFC 02,W
04D36:  MOVWF  03
04D38:  MOVF   01,W
04D3A:  ADDLW  08
04D3C:  MOVWF  FE9
04D3E:  MOVLW  02
04D40:  ADDWFC 03,W
04D42:  MOVWF  FEA
04D44:  CLRF   FEF
....................          }
04D46:  BRA    4D5E
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
04D48:  MOVFF  4DD,691
04D4C:  MOVLB  0
04D4E:  CALL   0C26
....................             fprintf(SERIAL, retData);
04D52:  MOVLW  04
04D54:  MOVWF  FEA
04D56:  MOVLW  DE
04D58:  MOVWF  FE9
04D5A:  RCALL  4A60
04D5C:  MOVLB  6
....................          }
....................       }
04D5E:  BRA    4F70
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
04D60:  CLRF   xD2
04D62:  MOVFF  4DD,6D1
04D66:  CLRF   xD4
04D68:  MOVLW  B5
04D6A:  MOVWF  xD3
04D6C:  MOVLB  0
04D6E:  CALL   0C04
04D72:  MOVFF  02,692
04D76:  MOVFF  01,691
04D7A:  MOVLW  01
04D7C:  MOVLB  6
04D7E:  ADDWF  01,W
04D80:  MOVWF  01
04D82:  MOVLW  00
04D84:  ADDWFC 02,W
04D86:  MOVWF  03
04D88:  MOVF   01,W
04D8A:  ADDLW  08
04D8C:  MOVWF  FE9
04D8E:  MOVLW  02
04D90:  ADDWFC 03,W
04D92:  MOVWF  FEA
04D94:  MOVF   FEF,W
04D96:  SUBLW  18
04D98:  BTFSS  FD8.0
04D9A:  BRA    4F5A
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
04D9C:  CLRF   xD2
04D9E:  MOVFF  4DD,6D1
04DA2:  CLRF   xD4
04DA4:  MOVLW  B5
04DA6:  MOVWF  xD3
04DA8:  MOVLB  0
04DAA:  CALL   0C04
04DAE:  MOVFF  02,692
04DB2:  MOVFF  01,691
04DB6:  MOVLW  06
04DB8:  MOVLB  6
04DBA:  ADDWF  x91,F
04DBC:  MOVLW  00
04DBE:  ADDWFC x92,F
04DC0:  CLRF   xD2
04DC2:  MOVFF  4DD,6D1
04DC6:  CLRF   xD4
04DC8:  MOVLW  B5
04DCA:  MOVWF  xD3
04DCC:  MOVLB  0
04DCE:  CALL   0C04
04DD2:  MOVFF  02,694
04DD6:  MOVFF  01,693
04DDA:  MOVLW  02
04DDC:  MOVLB  6
04DDE:  ADDWF  01,W
04DE0:  MOVWF  01
04DE2:  MOVLW  00
04DE4:  ADDWFC 02,W
04DE6:  MOVWF  03
04DE8:  MOVF   01,W
04DEA:  ADDLW  08
04DEC:  MOVWF  FE9
04DEE:  MOVLW  02
04DF0:  ADDWFC 03,W
04DF2:  MOVWF  FEA
04DF4:  CLRF   xD2
04DF6:  MOVFF  FEF,6D1
04DFA:  CLRF   xD4
04DFC:  MOVLW  19
04DFE:  MOVWF  xD3
04E00:  MOVLB  0
04E02:  CALL   0C04
04E06:  MOVFF  02,03
04E0A:  MOVF   01,W
04E0C:  MOVLB  6
04E0E:  ADDWF  x91,F
04E10:  MOVF   02,W
04E12:  ADDWFC x92,F
04E14:  CLRF   xD2
04E16:  MOVFF  4DD,6D1
04E1A:  CLRF   xD4
04E1C:  MOVLW  B5
04E1E:  MOVWF  xD3
04E20:  MOVLB  0
04E22:  CALL   0C04
04E26:  MOVFF  01,693
04E2A:  MOVLW  01
04E2C:  MOVLB  6
04E2E:  ADDWF  01,W
04E30:  MOVWF  01
04E32:  MOVLW  00
04E34:  ADDWFC 02,W
04E36:  MOVWF  03
04E38:  MOVF   01,W
04E3A:  ADDLW  08
04E3C:  MOVWF  FE9
04E3E:  MOVLW  02
04E40:  ADDWFC 03,W
04E42:  MOVWF  FEA
04E44:  MOVF   FEF,W
04E46:  ADDWF  x91,W
04E48:  MOVWF  01
04E4A:  MOVLW  00
04E4C:  ADDWFC x92,W
04E4E:  MOVWF  03
04E50:  MOVF   01,W
04E52:  ADDLW  08
04E54:  MOVWF  FE9
04E56:  MOVLW  02
04E58:  ADDWFC 03,W
04E5A:  MOVWF  FEA
04E5C:  MOVFF  690,FEF
....................             SERcmd[SWI].chrIndex += 1;
04E60:  CLRF   xD2
04E62:  MOVFF  4DD,6D1
04E66:  CLRF   xD4
04E68:  MOVLW  B5
04E6A:  MOVWF  xD3
04E6C:  MOVLB  0
04E6E:  CALL   0C04
04E72:  MOVFF  01,691
04E76:  MOVLW  01
04E78:  MOVLB  6
04E7A:  ADDWF  01,W
04E7C:  MOVWF  01
04E7E:  MOVLW  00
04E80:  ADDWFC 02,W
04E82:  MOVWF  03
04E84:  MOVF   01,W
04E86:  ADDLW  08
04E88:  MOVWF  FE9
04E8A:  MOVLW  02
04E8C:  ADDWFC 03,W
04E8E:  MOVWF  FEA
04E90:  MOVLW  01
04E92:  ADDWF  FEF,W
04E94:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
04E96:  CLRF   xD2
04E98:  MOVFF  4DD,6D1
04E9C:  CLRF   xD4
04E9E:  MOVLW  B5
04EA0:  MOVWF  xD3
04EA2:  MOVLB  0
04EA4:  CALL   0C04
04EA8:  MOVFF  02,692
04EAC:  MOVFF  01,691
04EB0:  MOVLW  06
04EB2:  MOVLB  6
04EB4:  ADDWF  x91,F
04EB6:  MOVLW  00
04EB8:  ADDWFC x92,F
04EBA:  CLRF   xD2
04EBC:  MOVFF  4DD,6D1
04EC0:  CLRF   xD4
04EC2:  MOVLW  B5
04EC4:  MOVWF  xD3
04EC6:  MOVLB  0
04EC8:  CALL   0C04
04ECC:  MOVFF  02,694
04ED0:  MOVFF  01,693
04ED4:  MOVLW  02
04ED6:  MOVLB  6
04ED8:  ADDWF  01,W
04EDA:  MOVWF  01
04EDC:  MOVLW  00
04EDE:  ADDWFC 02,W
04EE0:  MOVWF  03
04EE2:  MOVF   01,W
04EE4:  ADDLW  08
04EE6:  MOVWF  FE9
04EE8:  MOVLW  02
04EEA:  ADDWFC 03,W
04EEC:  MOVWF  FEA
04EEE:  CLRF   xD2
04EF0:  MOVFF  FEF,6D1
04EF4:  CLRF   xD4
04EF6:  MOVLW  19
04EF8:  MOVWF  xD3
04EFA:  MOVLB  0
04EFC:  CALL   0C04
04F00:  MOVFF  02,03
04F04:  MOVF   01,W
04F06:  MOVLB  6
04F08:  ADDWF  x91,F
04F0A:  MOVF   02,W
04F0C:  ADDWFC x92,F
04F0E:  CLRF   xD2
04F10:  MOVFF  4DD,6D1
04F14:  CLRF   xD4
04F16:  MOVLW  B5
04F18:  MOVWF  xD3
04F1A:  MOVLB  0
04F1C:  CALL   0C04
04F20:  MOVFF  01,693
04F24:  MOVLW  01
04F26:  MOVLB  6
04F28:  ADDWF  01,W
04F2A:  MOVWF  01
04F2C:  MOVLW  00
04F2E:  ADDWFC 02,W
04F30:  MOVWF  03
04F32:  MOVF   01,W
04F34:  ADDLW  08
04F36:  MOVWF  FE9
04F38:  MOVLW  02
04F3A:  ADDWFC 03,W
04F3C:  MOVWF  FEA
04F3E:  MOVF   FEF,W
04F40:  ADDWF  x91,W
04F42:  MOVWF  01
04F44:  MOVLW  00
04F46:  ADDWFC x92,W
04F48:  MOVWF  03
04F4A:  MOVF   01,W
04F4C:  ADDLW  08
04F4E:  MOVWF  FE9
04F50:  MOVLW  02
04F52:  ADDWFC 03,W
04F54:  MOVWF  FEA
04F56:  CLRF   FEF
....................          }
04F58:  BRA    4F70
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
04F5A:  MOVFF  4DD,691
04F5E:  MOVLB  0
04F60:  CALL   0C26
....................             fprintf(SERIAL, retData);
04F64:  MOVLW  04
04F66:  MOVWF  FEA
04F68:  MOVLW  DE
04F6A:  MOVWF  FE9
04F6C:  RCALL  4A60
04F6E:  MOVLB  6
....................          }
....................       }
04F70:  MOVLB  0
04F72:  BRA    4A84
04F74:  MOVLB  5
....................    }          
04F76:  MOVLB  0
04F78:  GOTO   A01A (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00DA0:  MOVLB  6
00DA2:  CLRF   x90
00DA4:  MOVF   x90,W
00DA6:  SUBLW  03
00DA8:  BNC   0DB8
....................    {
....................       resetSERcmd(i);
00DAA:  MOVFF  690,691
00DAE:  MOVLB  0
00DB0:  RCALL  0C26
00DB2:  MOVLB  6
00DB4:  INCF   x90,F
00DB6:  BRA    0DA4
....................    }
....................    enable_interrupts(INT_RDA);
00DB8:  MOVLB  E
00DBA:  BSF    xC0.5
00DBC:  MOVLB  0
00DBE:  GOTO   A006 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00DC2:  MOVLB  E
00DC4:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00DC6:  MOVLW  01
00DC8:  MOVWF  FD1
00DCA:  MOVLW  07
00DCC:  MOVWF  FCE
00DCE:  CLRF   FCF
00DD0:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00DD2:  MOVLB  1
00DD4:  CLRF   x5A
00DD6:  CLRF   x59
00DD8:  CLRF   x58
00DDA:  CLRF   x57
....................    timeoutReg1 = 0;
00DDC:  CLRF   x5E
00DDE:  CLRF   x5D
00DE0:  CLRF   x5C
00DE2:  CLRF   x5B
....................    timeoutReg2 = 0;
00DE4:  CLRF   x62
00DE6:  CLRF   x61
00DE8:  CLRF   x60
00DEA:  CLRF   x5F
....................    intTimeoutReg = 50;
00DEC:  CLRF   x64
00DEE:  MOVLW  32
00DF0:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
00DF2:  MOVLB  E
00DF4:  BSF    xC1.0
00DF6:  MOVLB  0
00DF8:  GOTO   A00A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00252:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00254:  MOVLW  0B
00256:  MOVWF  FCD
00258:  MOVLW  DB
0025A:  MOVWF  FCC
0025C:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0025E:  MOVLB  1
00260:  MOVF   x5A,F
00262:  BNZ   0272
00264:  MOVF   x59,F
00266:  BNZ   0272
00268:  MOVF   x58,F
0026A:  BNZ   0272
0026C:  MOVF   x57,W
0026E:  SUBLW  0A
00270:  BC    0280
00272:  MOVLW  0A
00274:  SUBWF  x57,F
00276:  MOVLW  00
00278:  SUBWFB x58,F
0027A:  SUBWFB x59,F
0027C:  SUBWFB x5A,F
0027E:  BRA    0288
00280:  CLRF   x5A
00282:  CLRF   x59
00284:  CLRF   x58
00286:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00288:  MOVF   x5E,F
0028A:  BNZ   029A
0028C:  MOVF   x5D,F
0028E:  BNZ   029A
00290:  MOVF   x5C,F
00292:  BNZ   029A
00294:  MOVF   x5B,W
00296:  SUBLW  0A
00298:  BC    02A8
0029A:  MOVLW  0A
0029C:  SUBWF  x5B,F
0029E:  MOVLW  00
002A0:  SUBWFB x5C,F
002A2:  SUBWFB x5D,F
002A4:  SUBWFB x5E,F
002A6:  BRA    02B0
002A8:  CLRF   x5E
002AA:  CLRF   x5D
002AC:  CLRF   x5C
002AE:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002B0:  MOVF   x62,F
002B2:  BNZ   02C2
002B4:  MOVF   x61,F
002B6:  BNZ   02C2
002B8:  MOVF   x60,F
002BA:  BNZ   02C2
002BC:  MOVF   x5F,W
002BE:  SUBLW  0A
002C0:  BC    02D0
002C2:  MOVLW  0A
002C4:  SUBWF  x5F,F
002C6:  MOVLW  00
002C8:  SUBWFB x60,F
002CA:  SUBWFB x61,F
002CC:  SUBWFB x62,F
002CE:  BRA    02D8
002D0:  CLRF   x62
002D2:  CLRF   x61
002D4:  CLRF   x60
002D6:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002D8:  MOVF   x63,F
002DA:  BNZ   02E0
002DC:  MOVF   x64,F
002DE:  BZ    031C
....................    {
....................       timeCounter+=10;
002E0:  MOVLW  0A
002E2:  MOVLB  5
002E4:  ADDWF  x84,F
002E6:  MOVLW  00
002E8:  ADDWFC x85,F
002EA:  ADDWFC x86,F
002EC:  ADDWFC x87,F
....................       if (timeCounter >= intTimeoutReg)
002EE:  MOVF   x87,F
002F0:  BNZ   030C
002F2:  MOVF   x86,F
002F4:  BNZ   030C
002F6:  MOVLB  1
002F8:  MOVF   x64,W
002FA:  MOVLB  5
002FC:  SUBWF  x85,W
002FE:  BNC   031A
00300:  BNZ   030C
00302:  MOVLB  1
00304:  MOVF   x63,W
00306:  MOVLB  5
00308:  SUBWF  x84,W
0030A:  BNC   031A
....................       {
....................          sensor_monitor_interrupt_task();
0030C:  MOVLB  0
0030E:  RCALL  01B8
....................          timeCounter = 0;
00310:  MOVLB  5
00312:  CLRF   x87
00314:  CLRF   x86
00316:  CLRF   x85
00318:  CLRF   x84
0031A:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
0031C:  MOVLB  E
0031E:  BCF    xC9.0
00320:  MOVLB  0
00322:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
0551E:  MOVLW  04
05520:  MOVLB  6
05522:  MOVWF  xD2
05524:  MOVLW  DE
05526:  MOVWF  xD1
05528:  MOVLB  0
0552A:  RCALL  542E
0552C:  MOVFF  02,03
05530:  MOVF   01,W
05532:  ADDLW  DE
05534:  MOVLB  6
05536:  MOVWF  x9B
05538:  MOVLW  04
0553A:  ADDWFC 02,W
0553C:  MOVWF  x9C
0553E:  MOVFF  FE8,583
05542:  MOVFF  69B,582
05546:  MOVLW  26
05548:  MOVWF  FF6
0554A:  MOVLW  03
0554C:  MOVWF  FF7
0554E:  MOVLB  0
05550:  RCALL  54FE
05552:  MOVLW  2C
05554:  MOVLB  6
05556:  MOVWF  xE0
05558:  MOVLB  0
0555A:  RCALL  54DE
....................    return SUCCESS;
0555C:  MOVLW  00
0555E:  MOVWF  01
05560:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05562:  MOVLW  04
05564:  MOVLB  6
05566:  MOVWF  xD2
05568:  MOVLW  DE
0556A:  MOVWF  xD1
0556C:  MOVLB  0
0556E:  RCALL  542E
05570:  MOVFF  02,03
05574:  MOVF   01,W
05576:  ADDLW  DE
05578:  MOVLB  6
0557A:  MOVWF  x9B
0557C:  MOVLW  04
0557E:  ADDWFC 02,W
05580:  MOVWF  x9C
05582:  MOVFF  FE8,583
05586:  MOVFF  69B,582
0558A:  MOVLW  30
0558C:  MOVWF  FF6
0558E:  MOVLW  03
05590:  MOVWF  FF7
05592:  MOVLB  0
05594:  RCALL  54FE
05596:  MOVLW  2C
05598:  MOVLB  6
0559A:  MOVWF  xE0
0559C:  MOVLB  0
0559E:  RCALL  54DE
....................    return SUCCESS;
055A0:  MOVLW  00
055A2:  MOVWF  01
055A4:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05A56:  MOVLB  6
05A58:  CLRF   xD2
05A5A:  MOVFF  68F,6D1
05A5E:  CLRF   xD4
05A60:  MOVLW  B5
05A62:  MOVWF  xD3
05A64:  MOVLB  0
05A66:  CALL   0C04
05A6A:  MOVFF  02,69D
05A6E:  MOVFF  01,69C
05A72:  MOVLW  06
05A74:  MOVLB  6
05A76:  ADDWF  x9C,F
05A78:  MOVLW  00
05A7A:  ADDWFC x9D,F
05A7C:  MOVLW  32
05A7E:  ADDWF  x9C,W
05A80:  MOVWF  01
05A82:  MOVLW  00
05A84:  ADDWFC x9D,W
05A86:  MOVWF  03
05A88:  MOVF   01,W
05A8A:  ADDLW  08
05A8C:  MOVWF  01
05A8E:  MOVLW  02
05A90:  ADDWFC 03,F
05A92:  MOVFF  01,69C
05A96:  MOVFF  03,69D
05A9A:  MOVFF  03,6C4
05A9E:  MOVFF  01,6C3
05AA2:  MOVLB  0
05AA4:  RCALL  55A6
05AA6:  MOVF   01,F
05AA8:  BNZ   5AB2
05AAA:  MOVLW  02
05AAC:  MOVWF  01
05AAE:  BRA    5BF0
05AB0:  BRA    5B0E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05AB2:  MOVLB  6
05AB4:  CLRF   xD2
05AB6:  MOVFF  68F,6D1
05ABA:  CLRF   xD4
05ABC:  MOVLW  B5
05ABE:  MOVWF  xD3
05AC0:  MOVLB  0
05AC2:  CALL   0C04
05AC6:  MOVFF  02,69D
05ACA:  MOVFF  01,69C
05ACE:  MOVLW  06
05AD0:  MOVLB  6
05AD2:  ADDWF  x9C,F
05AD4:  MOVLW  00
05AD6:  ADDWFC x9D,F
05AD8:  MOVLW  32
05ADA:  ADDWF  x9C,W
05ADC:  MOVWF  01
05ADE:  MOVLW  00
05AE0:  ADDWFC x9D,W
05AE2:  MOVWF  03
05AE4:  MOVF   01,W
05AE6:  ADDLW  08
05AE8:  MOVWF  01
05AEA:  MOVLW  02
05AEC:  ADDWFC 03,F
05AEE:  MOVFF  01,69C
05AF2:  MOVFF  03,69D
05AF6:  MOVFF  03,6C4
05AFA:  MOVFF  01,6C3
05AFE:  CLRF   xC6
05B00:  CLRF   xC5
05B02:  MOVLW  0A
05B04:  MOVWF  xC7
05B06:  MOVLB  0
05B08:  RCALL  5640
05B0A:  MOVFF  01,69B
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05B0E:  MOVLW  01
05B10:  MOVLB  6
05B12:  SUBWF  x9B,W
05B14:  MOVWF  x9D
05B16:  CLRF   x9F
05B18:  MOVLW  60
05B1A:  MOVWF  x9E
05B1C:  MOVLB  0
05B1E:  CALL   402A
05B22:  BTFSC  01.0
05B24:  BRA    5B7A
05B26:  MOVLW  04
05B28:  MOVLB  6
05B2A:  MOVWF  xD2
05B2C:  MOVLW  DE
05B2E:  MOVWF  xD1
05B30:  MOVLB  0
05B32:  RCALL  542E
05B34:  MOVFF  02,03
05B38:  MOVF   01,W
05B3A:  ADDLW  DE
05B3C:  MOVLB  6
05B3E:  MOVWF  x9C
05B40:  MOVLW  04
05B42:  ADDWFC 02,W
05B44:  MOVWF  x9D
05B46:  MOVFF  FE8,583
05B4A:  MOVFF  69C,582
05B4E:  MOVFF  69B,6C4
05B52:  MOVLW  18
05B54:  MOVWF  xC5
05B56:  MOVLB  0
05B58:  RCALL  5996
05B5A:  MOVLW  2C
05B5C:  MOVLB  6
05B5E:  MOVWF  xE0
05B60:  MOVLB  0
05B62:  RCALL  54DE
05B64:  MOVLW  58
05B66:  MOVLB  6
05B68:  MOVWF  xE0
05B6A:  MOVLB  0
05B6C:  RCALL  54DE
05B6E:  MOVLW  2C
05B70:  MOVLB  6
05B72:  MOVWF  xE0
05B74:  MOVLB  0
05B76:  RCALL  54DE
05B78:  BRA    5BEC
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05B7A:  MOVLW  01
05B7C:  MOVLB  6
05B7E:  SUBWF  x9B,W
05B80:  MOVWF  x9D
05B82:  CLRF   x9F
05B84:  MOVLW  60
05B86:  MOVWF  x9E
05B88:  MOVLB  0
05B8A:  CALL   402A
05B8E:  BTFSS  01.0
05B90:  BRA    5BE6
05B92:  MOVLW  04
05B94:  MOVLB  6
05B96:  MOVWF  xD2
05B98:  MOVLW  DE
05B9A:  MOVWF  xD1
05B9C:  MOVLB  0
05B9E:  RCALL  542E
05BA0:  MOVFF  02,03
05BA4:  MOVF   01,W
05BA6:  ADDLW  DE
05BA8:  MOVLB  6
05BAA:  MOVWF  x9C
05BAC:  MOVLW  04
05BAE:  ADDWFC 02,W
05BB0:  MOVWF  x9D
05BB2:  MOVFF  FE8,583
05BB6:  MOVFF  69C,582
05BBA:  MOVFF  69B,6C4
05BBE:  MOVLW  18
05BC0:  MOVWF  xC5
05BC2:  MOVLB  0
05BC4:  RCALL  5996
05BC6:  MOVLW  2C
05BC8:  MOVLB  6
05BCA:  MOVWF  xE0
05BCC:  MOVLB  0
05BCE:  RCALL  54DE
05BD0:  MOVLW  59
05BD2:  MOVLB  6
05BD4:  MOVWF  xE0
05BD6:  MOVLB  0
05BD8:  RCALL  54DE
05BDA:  MOVLW  2C
05BDC:  MOVLB  6
05BDE:  MOVWF  xE0
05BE0:  MOVLB  0
05BE2:  RCALL  54DE
05BE4:  BRA    5BEC
....................    else return INV_PARAM;
05BE6:  MOVLW  02
05BE8:  MOVWF  01
05BEA:  BRA    5BF0
....................    
....................    return SUCCESS;
05BEC:  MOVLW  00
05BEE:  MOVWF  01
05BF0:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05C34:  MOVLB  6
05C36:  CLRF   xD2
05C38:  MOVFF  68F,6D1
05C3C:  CLRF   xD4
05C3E:  MOVLW  B5
05C40:  MOVWF  xD3
05C42:  MOVLB  0
05C44:  CALL   0C04
05C48:  MOVFF  02,69E
05C4C:  MOVFF  01,69D
05C50:  MOVLW  06
05C52:  MOVLB  6
05C54:  ADDWF  x9D,F
05C56:  MOVLW  00
05C58:  ADDWFC x9E,F
05C5A:  MOVLW  32
05C5C:  ADDWF  x9D,W
05C5E:  MOVWF  01
05C60:  MOVLW  00
05C62:  ADDWFC x9E,W
05C64:  MOVWF  03
05C66:  MOVF   01,W
05C68:  ADDLW  08
05C6A:  MOVWF  01
05C6C:  MOVLW  02
05C6E:  ADDWFC 03,F
05C70:  MOVFF  01,69D
05C74:  MOVFF  03,69E
05C78:  MOVFF  03,6C4
05C7C:  MOVFF  01,6C3
05C80:  MOVLB  0
05C82:  RCALL  55A6
05C84:  MOVF   01,F
05C86:  BNZ   5C90
05C88:  MOVLW  02
05C8A:  MOVWF  01
05C8C:  BRA    5DE0
05C8E:  BRA    5CEC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05C90:  MOVLB  6
05C92:  CLRF   xD2
05C94:  MOVFF  68F,6D1
05C98:  CLRF   xD4
05C9A:  MOVLW  B5
05C9C:  MOVWF  xD3
05C9E:  MOVLB  0
05CA0:  CALL   0C04
05CA4:  MOVFF  02,69E
05CA8:  MOVFF  01,69D
05CAC:  MOVLW  06
05CAE:  MOVLB  6
05CB0:  ADDWF  x9D,F
05CB2:  MOVLW  00
05CB4:  ADDWFC x9E,F
05CB6:  MOVLW  32
05CB8:  ADDWF  x9D,W
05CBA:  MOVWF  01
05CBC:  MOVLW  00
05CBE:  ADDWFC x9E,W
05CC0:  MOVWF  03
05CC2:  MOVF   01,W
05CC4:  ADDLW  08
05CC6:  MOVWF  01
05CC8:  MOVLW  02
05CCA:  ADDWFC 03,F
05CCC:  MOVFF  01,69D
05CD0:  MOVFF  03,69E
05CD4:  MOVFF  03,6C4
05CD8:  MOVFF  01,6C3
05CDC:  CLRF   xC6
05CDE:  CLRF   xC5
05CE0:  MOVLW  0A
05CE2:  MOVWF  xC7
05CE4:  MOVLB  0
05CE6:  RCALL  5640
05CE8:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05CEC:  MOVLB  6
05CEE:  CLRF   xD2
05CF0:  MOVFF  68F,6D1
05CF4:  CLRF   xD4
05CF6:  MOVLW  B5
05CF8:  MOVWF  xD3
05CFA:  MOVLB  0
05CFC:  CALL   0C04
05D00:  MOVFF  02,69E
05D04:  MOVFF  01,69D
05D08:  MOVLW  06
05D0A:  MOVLB  6
05D0C:  ADDWF  x9D,F
05D0E:  MOVLW  00
05D10:  ADDWFC x9E,F
05D12:  MOVLW  4B
05D14:  ADDWF  x9D,W
05D16:  MOVWF  01
05D18:  MOVLW  00
05D1A:  ADDWFC x9E,W
05D1C:  MOVWF  03
05D1E:  MOVF   01,W
05D20:  ADDLW  08
05D22:  MOVWF  01
05D24:  MOVLW  02
05D26:  ADDWFC 03,F
05D28:  MOVFF  01,69D
05D2C:  MOVFF  03,69E
05D30:  MOVFF  03,6D2
05D34:  MOVFF  01,6D1
05D38:  MOVLB  0
05D3A:  CALL   542E
05D3E:  MOVFF  02,03
05D42:  MOVF   01,W
05D44:  SUBLW  01
05D46:  BNZ   5D4C
05D48:  MOVF   03,F
05D4A:  BZ    5D54
05D4C:  MOVLW  02
05D4E:  MOVWF  01
05D50:  BRA    5DE0
05D52:  BRA    5D94
....................    else arg2 = SERcmd[rec].p[3][0];
05D54:  MOVLB  6
05D56:  CLRF   xD2
05D58:  MOVFF  68F,6D1
05D5C:  CLRF   xD4
05D5E:  MOVLW  B5
05D60:  MOVWF  xD3
05D62:  MOVLB  0
05D64:  CALL   0C04
05D68:  MOVFF  02,69E
05D6C:  MOVFF  01,69D
05D70:  MOVLW  06
05D72:  MOVLB  6
05D74:  ADDWF  x9D,F
05D76:  MOVLW  00
05D78:  ADDWFC x9E,F
05D7A:  MOVLW  4B
05D7C:  ADDWF  x9D,F
05D7E:  MOVLW  00
05D80:  ADDWFC x9E,F
05D82:  MOVLW  08
05D84:  ADDWF  x9D,W
05D86:  MOVWF  FE9
05D88:  MOVLW  02
05D8A:  ADDWFC x9E,W
05D8C:  MOVWF  FEA
05D8E:  MOVFF  FEF,69C
05D92:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
05D94:  MOVLB  6
05D96:  MOVF   x9C,W
05D98:  SUBLW  58
05D9A:  BNZ   5DB4
05D9C:  MOVLW  01
05D9E:  SUBWF  x9B,W
05DA0:  MOVWF  x9D
05DA2:  MOVWF  xB2
05DA4:  CLRF   xB3
05DA6:  CLRF   xB5
05DA8:  MOVLW  60
05DAA:  MOVWF  xB4
05DAC:  MOVLB  0
05DAE:  RCALL  5BF2
05DB0:  BRA    5DDC
05DB2:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
05DB4:  MOVF   x9C,W
05DB6:  SUBLW  59
05DB8:  BNZ   5DD4
05DBA:  MOVLW  01
05DBC:  SUBWF  x9B,W
05DBE:  MOVWF  x9D
05DC0:  MOVWF  xB2
05DC2:  MOVLW  01
05DC4:  MOVWF  xB3
05DC6:  CLRF   xB5
05DC8:  MOVLW  60
05DCA:  MOVWF  xB4
05DCC:  MOVLB  0
05DCE:  RCALL  5BF2
05DD0:  BRA    5DDC
05DD2:  MOVLB  6
....................    else return INV_PARAM;
05DD4:  MOVLW  02
05DD6:  MOVWF  01
05DD8:  MOVLB  0
05DDA:  BRA    5DE0
....................    
....................    return SUCCESS;
05DDC:  MOVLW  00
05DDE:  MOVWF  01
05DE0:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05E0C:  MOVLB  6
05E0E:  CLRF   xD2
05E10:  MOVFF  68F,6D1
05E14:  CLRF   xD4
05E16:  MOVLW  B5
05E18:  MOVWF  xD3
05E1A:  MOVLB  0
05E1C:  CALL   0C04
05E20:  MOVFF  02,69D
05E24:  MOVFF  01,69C
05E28:  MOVLW  06
05E2A:  MOVLB  6
05E2C:  ADDWF  x9C,F
05E2E:  MOVLW  00
05E30:  ADDWFC x9D,F
05E32:  MOVLW  32
05E34:  ADDWF  x9C,W
05E36:  MOVWF  01
05E38:  MOVLW  00
05E3A:  ADDWFC x9D,W
05E3C:  MOVWF  03
05E3E:  MOVF   01,W
05E40:  ADDLW  08
05E42:  MOVWF  01
05E44:  MOVLW  02
05E46:  ADDWFC 03,F
05E48:  MOVFF  01,69C
05E4C:  MOVFF  03,69D
05E50:  MOVFF  03,6C4
05E54:  MOVFF  01,6C3
05E58:  MOVLB  0
05E5A:  CALL   55A6
05E5E:  MOVF   01,F
05E60:  BNZ   5E6A
05E62:  MOVLW  02
05E64:  MOVWF  01
05E66:  BRA    5F96
05E68:  BRA    5EC8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05E6A:  MOVLB  6
05E6C:  CLRF   xD2
05E6E:  MOVFF  68F,6D1
05E72:  CLRF   xD4
05E74:  MOVLW  B5
05E76:  MOVWF  xD3
05E78:  MOVLB  0
05E7A:  CALL   0C04
05E7E:  MOVFF  02,69D
05E82:  MOVFF  01,69C
05E86:  MOVLW  06
05E88:  MOVLB  6
05E8A:  ADDWF  x9C,F
05E8C:  MOVLW  00
05E8E:  ADDWFC x9D,F
05E90:  MOVLW  32
05E92:  ADDWF  x9C,W
05E94:  MOVWF  01
05E96:  MOVLW  00
05E98:  ADDWFC x9D,W
05E9A:  MOVWF  03
05E9C:  MOVF   01,W
05E9E:  ADDLW  08
05EA0:  MOVWF  01
05EA2:  MOVLW  02
05EA4:  ADDWFC 03,F
05EA6:  MOVFF  01,69C
05EAA:  MOVFF  03,69D
05EAE:  MOVFF  03,6C4
05EB2:  MOVFF  01,6C3
05EB6:  CLRF   xC6
05EB8:  CLRF   xC5
05EBA:  MOVLW  0A
05EBC:  MOVWF  xC7
05EBE:  MOVLB  0
05EC0:  CALL   5640
05EC4:  MOVFF  01,69B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
05EC8:  MOVLW  01
05ECA:  MOVLB  6
05ECC:  SUBWF  x9B,W
05ECE:  MOVWF  x9D
05ED0:  CLRF   x9F
05ED2:  MOVLW  61
05ED4:  MOVWF  x9E
05ED6:  MOVLB  0
05ED8:  CALL   402A
05EDC:  BTFSC  01.0
05EDE:  BRA    5F2A
05EE0:  MOVLW  04
05EE2:  MOVLB  6
05EE4:  MOVWF  xD2
05EE6:  MOVLW  DE
05EE8:  MOVWF  xD1
05EEA:  MOVLB  0
05EEC:  CALL   542E
05EF0:  MOVFF  02,03
05EF4:  MOVF   01,W
05EF6:  ADDLW  DE
05EF8:  MOVLB  6
05EFA:  MOVWF  x9C
05EFC:  MOVLW  04
05EFE:  ADDWFC 02,W
05F00:  MOVWF  x9D
05F02:  MOVFF  FE8,583
05F06:  MOVFF  69C,582
05F0A:  MOVFF  69B,6C4
05F0E:  MOVLW  18
05F10:  MOVWF  xC5
05F12:  MOVLB  0
05F14:  RCALL  5996
05F16:  MOVLW  38
05F18:  MOVWF  FF6
05F1A:  MOVLW  03
05F1C:  MOVWF  FF7
05F1E:  MOVLW  08
05F20:  MOVLB  6
05F22:  MOVWF  x9F
05F24:  MOVLB  0
05F26:  RCALL  5DE2
05F28:  BRA    5F92
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
05F2A:  MOVLW  01
05F2C:  MOVLB  6
05F2E:  SUBWF  x9B,W
05F30:  MOVWF  x9D
05F32:  CLRF   x9F
05F34:  MOVLW  61
05F36:  MOVWF  x9E
05F38:  MOVLB  0
05F3A:  CALL   402A
05F3E:  BTFSS  01.0
05F40:  BRA    5F8C
05F42:  MOVLW  04
05F44:  MOVLB  6
05F46:  MOVWF  xD2
05F48:  MOVLW  DE
05F4A:  MOVWF  xD1
05F4C:  MOVLB  0
05F4E:  CALL   542E
05F52:  MOVFF  02,03
05F56:  MOVF   01,W
05F58:  ADDLW  DE
05F5A:  MOVLB  6
05F5C:  MOVWF  x9C
05F5E:  MOVLW  04
05F60:  ADDWFC 02,W
05F62:  MOVWF  x9D
05F64:  MOVFF  FE8,583
05F68:  MOVFF  69C,582
05F6C:  MOVFF  69B,6C4
05F70:  MOVLW  18
05F72:  MOVWF  xC5
05F74:  MOVLB  0
05F76:  RCALL  5996
05F78:  MOVLW  44
05F7A:  MOVWF  FF6
05F7C:  MOVLW  03
05F7E:  MOVWF  FF7
05F80:  MOVLW  08
05F82:  MOVLB  6
05F84:  MOVWF  x9F
05F86:  MOVLB  0
05F88:  RCALL  5DE2
05F8A:  BRA    5F92
....................    else return INV_PARAM;
05F8C:  MOVLW  02
05F8E:  MOVWF  01
05F90:  BRA    5F96
....................    
....................    return SUCCESS;
05F92:  MOVLW  00
05F94:  MOVWF  01
05F96:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
05F98:  MOVLW  4D
05F9A:  MOVLB  6
05F9C:  MOVWF  xA0
05F9E:  MOVLW  41
05FA0:  MOVWF  xA1
05FA2:  MOVLW  4E
05FA4:  MOVWF  xA2
05FA6:  MOVLW  55
05FA8:  MOVWF  xA3
05FAA:  MOVLW  41
05FAC:  MOVWF  xA4
05FAE:  MOVLW  4C
05FB0:  MOVWF  xA5
05FB2:  CLRF   xA6
05FB4:  MOVLW  06
05FB6:  MOVWF  x9F
05FB8:  MOVLW  A0
05FBA:  MOVWF  x9E
....................    char *s_magsns = "MAGSNS";
05FBC:  MOVLW  4D
05FBE:  MOVWF  xA9
05FC0:  MOVLW  41
05FC2:  MOVWF  xAA
05FC4:  MOVLW  47
05FC6:  MOVWF  xAB
05FC8:  MOVLW  53
05FCA:  MOVWF  xAC
05FCC:  MOVLW  4E
05FCE:  MOVWF  xAD
05FD0:  MOVLW  53
05FD2:  MOVWF  xAE
05FD4:  CLRF   xAF
05FD6:  MOVLW  06
05FD8:  MOVWF  xA8
05FDA:  MOVLW  A9
05FDC:  MOVWF  xA7
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05FDE:  CLRF   xD2
05FE0:  MOVFF  68F,6D1
05FE4:  CLRF   xD4
05FE6:  MOVLW  B5
05FE8:  MOVWF  xD3
05FEA:  MOVLB  0
05FEC:  CALL   0C04
05FF0:  MOVFF  02,6B1
05FF4:  MOVFF  01,6B0
05FF8:  MOVLW  06
05FFA:  MOVLB  6
05FFC:  ADDWF  xB0,F
05FFE:  MOVLW  00
06000:  ADDWFC xB1,F
06002:  MOVLW  32
06004:  ADDWF  xB0,W
06006:  MOVWF  01
06008:  MOVLW  00
0600A:  ADDWFC xB1,W
0600C:  MOVWF  03
0600E:  MOVF   01,W
06010:  ADDLW  08
06012:  MOVWF  01
06014:  MOVLW  02
06016:  ADDWFC 03,F
06018:  MOVFF  01,6B0
0601C:  MOVFF  03,6B1
06020:  MOVFF  03,6C4
06024:  MOVFF  01,6C3
06028:  MOVLB  0
0602A:  CALL   55A6
0602E:  MOVF   01,F
06030:  BNZ   603A
06032:  MOVLW  02
06034:  MOVWF  01
06036:  BRA    61B0
06038:  BRA    6098
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0603A:  MOVLB  6
0603C:  CLRF   xD2
0603E:  MOVFF  68F,6D1
06042:  CLRF   xD4
06044:  MOVLW  B5
06046:  MOVWF  xD3
06048:  MOVLB  0
0604A:  CALL   0C04
0604E:  MOVFF  02,6B1
06052:  MOVFF  01,6B0
06056:  MOVLW  06
06058:  MOVLB  6
0605A:  ADDWF  xB0,F
0605C:  MOVLW  00
0605E:  ADDWFC xB1,F
06060:  MOVLW  32
06062:  ADDWF  xB0,W
06064:  MOVWF  01
06066:  MOVLW  00
06068:  ADDWFC xB1,W
0606A:  MOVWF  03
0606C:  MOVF   01,W
0606E:  ADDLW  08
06070:  MOVWF  01
06072:  MOVLW  02
06074:  ADDWFC 03,F
06076:  MOVFF  01,6B0
0607A:  MOVFF  03,6B1
0607E:  MOVFF  03,6C4
06082:  MOVFF  01,6C3
06086:  CLRF   xC6
06088:  CLRF   xC5
0608A:  MOVLW  0A
0608C:  MOVWF  xC7
0608E:  MOVLB  0
06090:  CALL   5640
06094:  MOVFF  01,69B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06098:  MOVLB  6
0609A:  CLRF   xD2
0609C:  MOVFF  68F,6D1
060A0:  CLRF   xD4
060A2:  MOVLW  B5
060A4:  MOVWF  xD3
060A6:  MOVLB  0
060A8:  CALL   0C04
060AC:  MOVFF  02,6B1
060B0:  MOVFF  01,6B0
060B4:  MOVLW  06
060B6:  MOVLB  6
060B8:  ADDWF  xB0,F
060BA:  MOVLW  00
060BC:  ADDWFC xB1,F
060BE:  MOVLW  4B
060C0:  ADDWF  xB0,W
060C2:  MOVWF  01
060C4:  MOVLW  00
060C6:  ADDWFC xB1,W
060C8:  MOVWF  03
060CA:  MOVF   01,W
060CC:  ADDLW  08
060CE:  MOVWF  01
060D0:  MOVLW  02
060D2:  ADDWFC 03,F
060D4:  MOVFF  01,6B0
060D8:  MOVFF  03,6B1
060DC:  MOVFF  03,6D2
060E0:  MOVFF  01,6D1
060E4:  MOVLB  0
060E6:  CALL   542E
060EA:  MOVFF  02,03
060EE:  MOVF   01,W
060F0:  BNZ   60FE
060F2:  MOVF   03,F
060F4:  BNZ   60FE
060F6:  MOVLW  02
060F8:  MOVWF  01
060FA:  BRA    61B0
060FC:  BRA    6144
....................    else arg2 = SERcmd[rec].p[3];
060FE:  MOVLB  6
06100:  CLRF   xD2
06102:  MOVFF  68F,6D1
06106:  CLRF   xD4
06108:  MOVLW  B5
0610A:  MOVWF  xD3
0610C:  MOVLB  0
0610E:  CALL   0C04
06112:  MOVFF  02,6B1
06116:  MOVFF  01,6B0
0611A:  MOVLW  06
0611C:  MOVLB  6
0611E:  ADDWF  xB0,F
06120:  MOVLW  00
06122:  ADDWFC xB1,F
06124:  MOVLW  4B
06126:  ADDWF  xB0,W
06128:  MOVWF  01
0612A:  MOVLW  00
0612C:  ADDWFC xB1,W
0612E:  MOVWF  03
06130:  MOVF   01,W
06132:  ADDLW  08
06134:  MOVWF  01
06136:  MOVLW  02
06138:  ADDWFC 03,F
0613A:  MOVFF  01,69C
0613E:  MOVFF  03,69D
06142:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06144:  MOVFF  69F,6D2
06148:  MOVFF  69E,6D1
0614C:  MOVFF  69D,6D4
06150:  MOVFF  69C,6D3
06154:  CALL   5466
06158:  MOVF   01,F
0615A:  BNZ   6174
0615C:  MOVLW  01
0615E:  MOVLB  6
06160:  SUBWF  x9B,W
06162:  MOVWF  xB0
06164:  MOVWF  xB2
06166:  CLRF   xB3
06168:  CLRF   xB5
0616A:  MOVLW  61
0616C:  MOVWF  xB4
0616E:  MOVLB  0
06170:  RCALL  5BF2
06172:  BRA    61AC
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06174:  MOVFF  6A8,6D2
06178:  MOVFF  6A7,6D1
0617C:  MOVFF  69D,6D4
06180:  MOVFF  69C,6D3
06184:  CALL   5466
06188:  MOVF   01,F
0618A:  BNZ   61A6
0618C:  MOVLW  01
0618E:  MOVLB  6
06190:  SUBWF  x9B,W
06192:  MOVWF  xB0
06194:  MOVWF  xB2
06196:  MOVLW  01
06198:  MOVWF  xB3
0619A:  CLRF   xB5
0619C:  MOVLW  61
0619E:  MOVWF  xB4
061A0:  MOVLB  0
061A2:  RCALL  5BF2
061A4:  BRA    61AC
....................    else return INV_PARAM;
061A6:  MOVLW  02
061A8:  MOVWF  01
061AA:  BRA    61B0
....................    
....................    return SUCCESS;
061AC:  MOVLW  00
061AE:  MOVWF  01
061B0:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06368:  MOVLB  6
0636A:  CLRF   xD2
0636C:  MOVFF  68F,6D1
06370:  CLRF   xD4
06372:  MOVLW  B5
06374:  MOVWF  xD3
06376:  MOVLB  0
06378:  CALL   0C04
0637C:  MOVFF  02,69E
06380:  MOVFF  01,69D
06384:  MOVLW  06
06386:  MOVLB  6
06388:  ADDWF  x9D,F
0638A:  MOVLW  00
0638C:  ADDWFC x9E,F
0638E:  MOVLW  32
06390:  ADDWF  x9D,W
06392:  MOVWF  01
06394:  MOVLW  00
06396:  ADDWFC x9E,W
06398:  MOVWF  03
0639A:  MOVF   01,W
0639C:  ADDLW  08
0639E:  MOVWF  01
063A0:  MOVLW  02
063A2:  ADDWFC 03,F
063A4:  MOVFF  01,69D
063A8:  MOVFF  03,69E
063AC:  MOVFF  03,6C4
063B0:  MOVFF  01,6C3
063B4:  MOVLB  0
063B6:  CALL   55A6
063BA:  MOVF   01,F
063BC:  BNZ   63C6
063BE:  MOVLW  02
063C0:  MOVWF  01
063C2:  BRA    681C
063C4:  BRA    6424
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
063C6:  MOVLB  6
063C8:  CLRF   xD2
063CA:  MOVFF  68F,6D1
063CE:  CLRF   xD4
063D0:  MOVLW  B5
063D2:  MOVWF  xD3
063D4:  MOVLB  0
063D6:  CALL   0C04
063DA:  MOVFF  02,69E
063DE:  MOVFF  01,69D
063E2:  MOVLW  06
063E4:  MOVLB  6
063E6:  ADDWF  x9D,F
063E8:  MOVLW  00
063EA:  ADDWFC x9E,F
063EC:  MOVLW  32
063EE:  ADDWF  x9D,W
063F0:  MOVWF  01
063F2:  MOVLW  00
063F4:  ADDWFC x9E,W
063F6:  MOVWF  03
063F8:  MOVF   01,W
063FA:  ADDLW  08
063FC:  MOVWF  01
063FE:  MOVLW  02
06400:  ADDWFC 03,F
06402:  MOVFF  01,69D
06406:  MOVFF  03,69E
0640A:  MOVFF  03,6C4
0640E:  MOVFF  01,6C3
06412:  CLRF   xC6
06414:  CLRF   xC5
06416:  MOVLW  0A
06418:  MOVWF  xC7
0641A:  MOVLB  0
0641C:  CALL   5640
06420:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06424:  MOVLB  6
06426:  CLRF   xD2
06428:  MOVFF  68F,6D1
0642C:  CLRF   xD4
0642E:  MOVLW  B5
06430:  MOVWF  xD3
06432:  MOVLB  0
06434:  CALL   0C04
06438:  MOVFF  02,69E
0643C:  MOVFF  01,69D
06440:  MOVLW  06
06442:  MOVLB  6
06444:  ADDWF  x9D,F
06446:  MOVLW  00
06448:  ADDWFC x9E,F
0644A:  MOVLW  4B
0644C:  ADDWF  x9D,W
0644E:  MOVWF  01
06450:  MOVLW  00
06452:  ADDWFC x9E,W
06454:  MOVWF  03
06456:  MOVF   01,W
06458:  ADDLW  08
0645A:  MOVWF  01
0645C:  MOVLW  02
0645E:  ADDWFC 03,F
06460:  MOVFF  01,69D
06464:  MOVFF  03,69E
06468:  MOVFF  03,6D2
0646C:  MOVFF  01,6D1
06470:  MOVLB  0
06472:  CALL   542E
06476:  MOVFF  02,03
0647A:  MOVF   01,W
0647C:  SUBLW  01
0647E:  BNZ   6484
06480:  MOVF   03,F
06482:  BZ    648C
06484:  MOVLW  02
06486:  MOVWF  01
06488:  BRA    681C
0648A:  BRA    64CC
....................    else arg2 = SERcmd[rec].p[3][0];
0648C:  MOVLB  6
0648E:  CLRF   xD2
06490:  MOVFF  68F,6D1
06494:  CLRF   xD4
06496:  MOVLW  B5
06498:  MOVWF  xD3
0649A:  MOVLB  0
0649C:  CALL   0C04
064A0:  MOVFF  02,69E
064A4:  MOVFF  01,69D
064A8:  MOVLW  06
064AA:  MOVLB  6
064AC:  ADDWF  x9D,F
064AE:  MOVLW  00
064B0:  ADDWFC x9E,F
064B2:  MOVLW  4B
064B4:  ADDWF  x9D,F
064B6:  MOVLW  00
064B8:  ADDWFC x9E,F
064BA:  MOVLW  08
064BC:  ADDWF  x9D,W
064BE:  MOVWF  FE9
064C0:  MOVLW  02
064C2:  ADDWFC x9E,W
064C4:  MOVWF  FEA
064C6:  MOVFF  FEF,69C
064CA:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
064CC:  MOVLB  6
064CE:  MOVF   x9C,W
064D0:  SUBLW  50
064D2:  BNZ   656C
064D4:  MOVLW  04
064D6:  MOVWF  xD2
064D8:  MOVLW  DE
064DA:  MOVWF  xD1
064DC:  MOVLB  0
064DE:  CALL   542E
064E2:  MOVFF  02,03
064E6:  MOVF   01,W
064E8:  ADDLW  DE
064EA:  MOVLB  6
064EC:  MOVWF  x9D
064EE:  MOVLW  04
064F0:  ADDWFC 02,W
064F2:  MOVWF  x9E
064F4:  MOVLW  01
064F6:  SUBWF  x9B,W
064F8:  MULLW  20
064FA:  MOVF   FF3,W
064FC:  CLRF   xA0
064FE:  MOVWF  x9F
06500:  MOVLW  20
06502:  ADDWF  x9F,W
06504:  MOVWF  FE9
06506:  MOVLW  00
06508:  ADDWFC xA0,W
0650A:  MOVWF  FEA
0650C:  MOVFF  FEF,6A1
06510:  MOVFF  FEC,6A2
06514:  MOVFF  FEC,6A3
06518:  MOVFF  FEC,6A4
0651C:  MOVFF  69E,583
06520:  MOVFF  69D,582
06524:  MOVFF  69B,6C4
06528:  MOVLW  18
0652A:  MOVWF  xC5
0652C:  MOVLB  0
0652E:  CALL   5996
06532:  MOVLW  2C
06534:  MOVLB  6
06536:  MOVWF  xE0
06538:  MOVLB  0
0653A:  CALL   54DE
0653E:  MOVLW  89
06540:  MOVWF  FE9
06542:  MOVFF  6A4,6D6
06546:  MOVFF  6A3,6D5
0654A:  MOVFF  6A2,6D4
0654E:  MOVFF  6A1,6D3
06552:  MOVLW  02
06554:  MOVLB  6
06556:  MOVWF  xD7
06558:  MOVLB  0
0655A:  RCALL  61B2
0655C:  MOVLW  2C
0655E:  MOVLB  6
06560:  MOVWF  xE0
06562:  MOVLB  0
06564:  CALL   54DE
06568:  BRA    6818
0656A:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
0656C:  MOVF   x9C,W
0656E:  SUBLW  49
06570:  BNZ   6612
06572:  MOVLW  04
06574:  MOVWF  xD2
06576:  MOVLW  DE
06578:  MOVWF  xD1
0657A:  MOVLB  0
0657C:  CALL   542E
06580:  MOVF   01,W
06582:  ADDLW  DE
06584:  MOVLB  6
06586:  MOVWF  x9D
06588:  MOVLW  04
0658A:  ADDWFC 02,W
0658C:  MOVWF  x9E
0658E:  MOVLW  01
06590:  SUBWF  x9B,W
06592:  MULLW  20
06594:  MOVF   FF3,W
06596:  CLRF   xA0
06598:  MOVWF  x9F
0659A:  MOVLW  04
0659C:  ADDWF  x9F,W
0659E:  MOVWF  01
065A0:  MOVLW  00
065A2:  ADDWFC xA0,W
065A4:  MOVWF  03
065A6:  MOVF   01,W
065A8:  ADDLW  20
065AA:  MOVWF  FE9
065AC:  MOVLW  00
065AE:  ADDWFC 03,W
065B0:  MOVWF  FEA
065B2:  MOVFF  FEF,69F
065B6:  MOVFF  FEC,6A0
065BA:  MOVFF  FEC,6A1
065BE:  MOVFF  FEC,6A2
065C2:  MOVFF  69E,583
065C6:  MOVFF  69D,582
065CA:  MOVFF  69B,6C4
065CE:  MOVLW  18
065D0:  MOVWF  xC5
065D2:  MOVLB  0
065D4:  CALL   5996
065D8:  MOVLW  2C
065DA:  MOVLB  6
065DC:  MOVWF  xE0
065DE:  MOVLB  0
065E0:  CALL   54DE
065E4:  MOVLW  89
065E6:  MOVWF  FE9
065E8:  MOVFF  6A2,6D6
065EC:  MOVFF  6A1,6D5
065F0:  MOVFF  6A0,6D4
065F4:  MOVFF  69F,6D3
065F8:  MOVLW  02
065FA:  MOVLB  6
065FC:  MOVWF  xD7
065FE:  MOVLB  0
06600:  RCALL  61B2
06602:  MOVLW  2C
06604:  MOVLB  6
06606:  MOVWF  xE0
06608:  MOVLB  0
0660A:  CALL   54DE
0660E:  BRA    6818
06610:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06612:  MOVF   x9C,W
06614:  SUBLW  44
06616:  BNZ   66B8
06618:  MOVLW  04
0661A:  MOVWF  xD2
0661C:  MOVLW  DE
0661E:  MOVWF  xD1
06620:  MOVLB  0
06622:  CALL   542E
06626:  MOVF   01,W
06628:  ADDLW  DE
0662A:  MOVLB  6
0662C:  MOVWF  x9D
0662E:  MOVLW  04
06630:  ADDWFC 02,W
06632:  MOVWF  x9E
06634:  MOVLW  01
06636:  SUBWF  x9B,W
06638:  MULLW  20
0663A:  MOVF   FF3,W
0663C:  CLRF   xA0
0663E:  MOVWF  x9F
06640:  MOVLW  08
06642:  ADDWF  x9F,W
06644:  MOVWF  01
06646:  MOVLW  00
06648:  ADDWFC xA0,W
0664A:  MOVWF  03
0664C:  MOVF   01,W
0664E:  ADDLW  20
06650:  MOVWF  FE9
06652:  MOVLW  00
06654:  ADDWFC 03,W
06656:  MOVWF  FEA
06658:  MOVFF  FEF,69F
0665C:  MOVFF  FEC,6A0
06660:  MOVFF  FEC,6A1
06664:  MOVFF  FEC,6A2
06668:  MOVFF  69E,583
0666C:  MOVFF  69D,582
06670:  MOVFF  69B,6C4
06674:  MOVLW  18
06676:  MOVWF  xC5
06678:  MOVLB  0
0667A:  CALL   5996
0667E:  MOVLW  2C
06680:  MOVLB  6
06682:  MOVWF  xE0
06684:  MOVLB  0
06686:  CALL   54DE
0668A:  MOVLW  89
0668C:  MOVWF  FE9
0668E:  MOVFF  6A2,6D6
06692:  MOVFF  6A1,6D5
06696:  MOVFF  6A0,6D4
0669A:  MOVFF  69F,6D3
0669E:  MOVLW  02
066A0:  MOVLB  6
066A2:  MOVWF  xD7
066A4:  MOVLB  0
066A6:  RCALL  61B2
066A8:  MOVLW  2C
066AA:  MOVLB  6
066AC:  MOVWF  xE0
066AE:  MOVLB  0
066B0:  CALL   54DE
066B4:  BRA    6818
066B6:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
066B8:  MOVF   x9C,W
066BA:  SUBLW  41
066BC:  BTFSS  FD8.2
066BE:  BRA    6810
066C0:  MOVLW  04
066C2:  MOVWF  xD2
066C4:  MOVLW  DE
066C6:  MOVWF  xD1
066C8:  MOVLB  0
066CA:  CALL   542E
066CE:  MOVF   01,W
066D0:  ADDLW  DE
066D2:  MOVLB  6
066D4:  MOVWF  x9D
066D6:  MOVLW  04
066D8:  ADDWFC 02,W
066DA:  MOVWF  x9E
066DC:  MOVLW  01
066DE:  SUBWF  x9B,W
066E0:  MULLW  20
066E2:  MOVF   FF3,W
066E4:  CLRF   xA0
066E6:  MOVWF  x9F
066E8:  MOVLW  20
066EA:  ADDWF  x9F,W
066EC:  MOVWF  FE9
066EE:  MOVLW  00
066F0:  ADDWFC xA0,W
066F2:  MOVWF  FEA
066F4:  MOVFF  FEF,6A1
066F8:  MOVFF  FEC,6A2
066FC:  MOVFF  FEC,6A3
06700:  MOVFF  FEC,6A4
06704:  MOVLW  01
06706:  SUBWF  x9B,W
06708:  MULLW  20
0670A:  MOVF   FF3,W
0670C:  CLRF   xA6
0670E:  MOVWF  xA5
06710:  MOVLW  04
06712:  ADDWF  xA5,W
06714:  MOVWF  01
06716:  MOVLW  00
06718:  ADDWFC xA6,W
0671A:  MOVWF  03
0671C:  MOVF   01,W
0671E:  ADDLW  20
06720:  MOVWF  FE9
06722:  MOVLW  00
06724:  ADDWFC 03,W
06726:  MOVWF  FEA
06728:  MOVFF  FEF,6A5
0672C:  MOVFF  FEC,6A6
06730:  MOVFF  FEC,6A7
06734:  MOVFF  FEC,6A8
06738:  MOVLW  01
0673A:  SUBWF  x9B,W
0673C:  MULLW  20
0673E:  MOVF   FF3,W
06740:  CLRF   xAA
06742:  MOVWF  xA9
06744:  MOVLW  08
06746:  ADDWF  xA9,W
06748:  MOVWF  01
0674A:  MOVLW  00
0674C:  ADDWFC xAA,W
0674E:  MOVWF  03
06750:  MOVF   01,W
06752:  ADDLW  20
06754:  MOVWF  FE9
06756:  MOVLW  00
06758:  ADDWFC 03,W
0675A:  MOVWF  FEA
0675C:  MOVFF  FEF,6A9
06760:  MOVFF  FEC,6AA
06764:  MOVFF  FEC,6AB
06768:  MOVFF  FEC,6AC
0676C:  MOVFF  69E,583
06770:  MOVFF  69D,582
06774:  MOVFF  69B,6C4
06778:  MOVLW  18
0677A:  MOVWF  xC5
0677C:  MOVLB  0
0677E:  CALL   5996
06782:  MOVLW  2C
06784:  MOVLB  6
06786:  MOVWF  xE0
06788:  MOVLB  0
0678A:  CALL   54DE
0678E:  MOVLW  89
06790:  MOVWF  FE9
06792:  MOVFF  6A4,6D6
06796:  MOVFF  6A3,6D5
0679A:  MOVFF  6A2,6D4
0679E:  MOVFF  6A1,6D3
067A2:  MOVLW  02
067A4:  MOVLB  6
067A6:  MOVWF  xD7
067A8:  MOVLB  0
067AA:  RCALL  61B2
067AC:  MOVLW  2C
067AE:  MOVLB  6
067B0:  MOVWF  xE0
067B2:  MOVLB  0
067B4:  CALL   54DE
067B8:  MOVLW  89
067BA:  MOVWF  FE9
067BC:  MOVFF  6A8,6D6
067C0:  MOVFF  6A7,6D5
067C4:  MOVFF  6A6,6D4
067C8:  MOVFF  6A5,6D3
067CC:  MOVLW  02
067CE:  MOVLB  6
067D0:  MOVWF  xD7
067D2:  MOVLB  0
067D4:  RCALL  61B2
067D6:  MOVLW  2C
067D8:  MOVLB  6
067DA:  MOVWF  xE0
067DC:  MOVLB  0
067DE:  CALL   54DE
067E2:  MOVLW  89
067E4:  MOVWF  FE9
067E6:  MOVFF  6AC,6D6
067EA:  MOVFF  6AB,6D5
067EE:  MOVFF  6AA,6D4
067F2:  MOVFF  6A9,6D3
067F6:  MOVLW  02
067F8:  MOVLB  6
067FA:  MOVWF  xD7
067FC:  MOVLB  0
067FE:  RCALL  61B2
06800:  MOVLW  2C
06802:  MOVLB  6
06804:  MOVWF  xE0
06806:  MOVLB  0
06808:  CALL   54DE
0680C:  BRA    6818
0680E:  MOVLB  6
....................    else return INV_PARAM;
06810:  MOVLW  02
06812:  MOVWF  01
06814:  MOVLB  0
06816:  BRA    681C
....................    
....................    return SUCCESS;
06818:  MOVLW  00
0681A:  MOVWF  01
0681C:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06B3A:  MOVLB  6
06B3C:  CLRF   xD2
06B3E:  MOVFF  68F,6D1
06B42:  CLRF   xD4
06B44:  MOVLW  B5
06B46:  MOVWF  xD3
06B48:  MOVLB  0
06B4A:  CALL   0C04
06B4E:  MOVFF  02,6A2
06B52:  MOVFF  01,6A1
06B56:  MOVLW  06
06B58:  MOVLB  6
06B5A:  ADDWF  xA1,F
06B5C:  MOVLW  00
06B5E:  ADDWFC xA2,F
06B60:  MOVLW  32
06B62:  ADDWF  xA1,W
06B64:  MOVWF  01
06B66:  MOVLW  00
06B68:  ADDWFC xA2,W
06B6A:  MOVWF  03
06B6C:  MOVF   01,W
06B6E:  ADDLW  08
06B70:  MOVWF  01
06B72:  MOVLW  02
06B74:  ADDWFC 03,F
06B76:  MOVFF  01,6A1
06B7A:  MOVFF  03,6A2
06B7E:  MOVFF  03,6C4
06B82:  MOVFF  01,6C3
06B86:  MOVLB  0
06B88:  CALL   55A6
06B8C:  MOVF   01,F
06B8E:  BNZ   6B98
06B90:  MOVLW  02
06B92:  MOVWF  01
06B94:  BRA    6E18
06B96:  BRA    6BF6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06B98:  MOVLB  6
06B9A:  CLRF   xD2
06B9C:  MOVFF  68F,6D1
06BA0:  CLRF   xD4
06BA2:  MOVLW  B5
06BA4:  MOVWF  xD3
06BA6:  MOVLB  0
06BA8:  CALL   0C04
06BAC:  MOVFF  02,6A2
06BB0:  MOVFF  01,6A1
06BB4:  MOVLW  06
06BB6:  MOVLB  6
06BB8:  ADDWF  xA1,F
06BBA:  MOVLW  00
06BBC:  ADDWFC xA2,F
06BBE:  MOVLW  32
06BC0:  ADDWF  xA1,W
06BC2:  MOVWF  01
06BC4:  MOVLW  00
06BC6:  ADDWFC xA2,W
06BC8:  MOVWF  03
06BCA:  MOVF   01,W
06BCC:  ADDLW  08
06BCE:  MOVWF  01
06BD0:  MOVLW  02
06BD2:  ADDWFC 03,F
06BD4:  MOVFF  01,6A1
06BD8:  MOVFF  03,6A2
06BDC:  MOVFF  03,6C4
06BE0:  MOVFF  01,6C3
06BE4:  CLRF   xC6
06BE6:  CLRF   xC5
06BE8:  MOVLW  0A
06BEA:  MOVWF  xC7
06BEC:  MOVLB  0
06BEE:  CALL   5640
06BF2:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06BF6:  MOVLB  6
06BF8:  CLRF   xD2
06BFA:  MOVFF  68F,6D1
06BFE:  CLRF   xD4
06C00:  MOVLW  B5
06C02:  MOVWF  xD3
06C04:  MOVLB  0
06C06:  CALL   0C04
06C0A:  MOVFF  02,6A2
06C0E:  MOVFF  01,6A1
06C12:  MOVLW  06
06C14:  MOVLB  6
06C16:  ADDWF  xA1,F
06C18:  MOVLW  00
06C1A:  ADDWFC xA2,F
06C1C:  MOVLW  4B
06C1E:  ADDWF  xA1,W
06C20:  MOVWF  01
06C22:  MOVLW  00
06C24:  ADDWFC xA2,W
06C26:  MOVWF  03
06C28:  MOVF   01,W
06C2A:  ADDLW  08
06C2C:  MOVWF  01
06C2E:  MOVLW  02
06C30:  ADDWFC 03,F
06C32:  MOVFF  01,6A1
06C36:  MOVFF  03,6A2
06C3A:  MOVFF  03,6D2
06C3E:  MOVFF  01,6D1
06C42:  MOVLB  0
06C44:  CALL   542E
06C48:  MOVFF  02,03
06C4C:  MOVF   01,W
06C4E:  SUBLW  01
06C50:  BNZ   6C56
06C52:  MOVF   03,F
06C54:  BZ    6C5E
06C56:  MOVLW  02
06C58:  MOVWF  01
06C5A:  BRA    6E18
06C5C:  BRA    6C9E
....................    else arg2 = SERcmd[rec].p[3][0];
06C5E:  MOVLB  6
06C60:  CLRF   xD2
06C62:  MOVFF  68F,6D1
06C66:  CLRF   xD4
06C68:  MOVLW  B5
06C6A:  MOVWF  xD3
06C6C:  MOVLB  0
06C6E:  CALL   0C04
06C72:  MOVFF  02,6A2
06C76:  MOVFF  01,6A1
06C7A:  MOVLW  06
06C7C:  MOVLB  6
06C7E:  ADDWF  xA1,F
06C80:  MOVLW  00
06C82:  ADDWFC xA2,F
06C84:  MOVLW  4B
06C86:  ADDWF  xA1,F
06C88:  MOVLW  00
06C8A:  ADDWFC xA2,F
06C8C:  MOVLW  08
06C8E:  ADDWF  xA1,W
06C90:  MOVWF  FE9
06C92:  MOVLW  02
06C94:  ADDWFC xA2,W
06C96:  MOVWF  FEA
06C98:  MOVFF  FEF,69C
06C9C:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
06C9E:  MOVLB  6
06CA0:  CLRF   xD2
06CA2:  MOVFF  68F,6D1
06CA6:  CLRF   xD4
06CA8:  MOVLW  B5
06CAA:  MOVWF  xD3
06CAC:  MOVLB  0
06CAE:  CALL   0C04
06CB2:  MOVFF  02,6A2
06CB6:  MOVFF  01,6A1
06CBA:  MOVLW  06
06CBC:  MOVLB  6
06CBE:  ADDWF  xA1,F
06CC0:  MOVLW  00
06CC2:  ADDWFC xA2,F
06CC4:  MOVLW  64
06CC6:  ADDWF  xA1,W
06CC8:  MOVWF  01
06CCA:  MOVLW  00
06CCC:  ADDWFC xA2,W
06CCE:  MOVWF  03
06CD0:  MOVF   01,W
06CD2:  ADDLW  08
06CD4:  MOVWF  01
06CD6:  MOVLW  02
06CD8:  ADDWFC 03,F
06CDA:  MOVFF  01,6A1
06CDE:  MOVFF  03,6A2
06CE2:  MOVFF  03,6A5
06CE6:  MOVFF  01,6A4
06CEA:  MOVLB  0
06CEC:  RCALL  681E
06CEE:  MOVF   01,F
06CF0:  BNZ   6CFA
06CF2:  MOVLW  02
06CF4:  MOVWF  01
06CF6:  BRA    6E18
06CF8:  BRA    6D5E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06CFA:  MOVLB  6
06CFC:  CLRF   xD2
06CFE:  MOVFF  68F,6D1
06D02:  CLRF   xD4
06D04:  MOVLW  B5
06D06:  MOVWF  xD3
06D08:  MOVLB  0
06D0A:  CALL   0C04
06D0E:  MOVFF  02,6A2
06D12:  MOVFF  01,6A1
06D16:  MOVLW  06
06D18:  MOVLB  6
06D1A:  ADDWF  xA1,F
06D1C:  MOVLW  00
06D1E:  ADDWFC xA2,F
06D20:  MOVLW  64
06D22:  ADDWF  xA1,W
06D24:  MOVWF  01
06D26:  MOVLW  00
06D28:  ADDWFC xA2,W
06D2A:  MOVWF  03
06D2C:  MOVF   01,W
06D2E:  ADDLW  08
06D30:  MOVWF  01
06D32:  MOVLW  02
06D34:  ADDWFC 03,F
06D36:  MOVFF  01,6A1
06D3A:  MOVFF  03,6A2
06D3E:  MOVFF  03,6A5
06D42:  MOVFF  01,6A4
06D46:  CLRF   xA7
06D48:  CLRF   xA6
06D4A:  MOVLB  0
06D4C:  RCALL  68E0
06D4E:  MOVFF  03,6A0
06D52:  MOVFF  02,69F
06D56:  MOVFF  01,69E
06D5A:  MOVFF  00,69D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
06D5E:  MOVLB  6
06D60:  MOVF   x9C,W
06D62:  SUBLW  50
06D64:  BNZ   6D90
06D66:  MOVLW  01
06D68:  SUBWF  x9B,W
06D6A:  MULLW  20
06D6C:  MOVF   FF3,W
06D6E:  CLRF   xA2
06D70:  MOVWF  xA1
06D72:  MOVLW  20
06D74:  ADDWF  xA1,W
06D76:  MOVWF  FE9
06D78:  MOVLW  00
06D7A:  ADDWFC xA2,W
06D7C:  MOVWF  FEA
06D7E:  MOVFF  69D,FEF
06D82:  MOVFF  69E,FEC
06D86:  MOVFF  69F,FEC
06D8A:  MOVFF  6A0,FEC
06D8E:  BRA    6E12
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
06D90:  MOVF   x9C,W
06D92:  SUBLW  49
06D94:  BNZ   6DCC
06D96:  MOVLW  01
06D98:  SUBWF  x9B,W
06D9A:  MULLW  20
06D9C:  MOVF   FF3,W
06D9E:  CLRF   xA2
06DA0:  MOVWF  xA1
06DA2:  MOVLW  04
06DA4:  ADDWF  xA1,W
06DA6:  MOVWF  01
06DA8:  MOVLW  00
06DAA:  ADDWFC xA2,W
06DAC:  MOVWF  03
06DAE:  MOVF   01,W
06DB0:  ADDLW  20
06DB2:  MOVWF  FE9
06DB4:  MOVLW  00
06DB6:  ADDWFC 03,W
06DB8:  MOVWF  FEA
06DBA:  MOVFF  69D,FEF
06DBE:  MOVFF  69E,FEC
06DC2:  MOVFF  69F,FEC
06DC6:  MOVFF  6A0,FEC
06DCA:  BRA    6E12
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
06DCC:  MOVF   x9C,W
06DCE:  SUBLW  44
06DD0:  BNZ   6E08
06DD2:  MOVLW  01
06DD4:  SUBWF  x9B,W
06DD6:  MULLW  20
06DD8:  MOVF   FF3,W
06DDA:  CLRF   xA2
06DDC:  MOVWF  xA1
06DDE:  MOVLW  08
06DE0:  ADDWF  xA1,W
06DE2:  MOVWF  01
06DE4:  MOVLW  00
06DE6:  ADDWFC xA2,W
06DE8:  MOVWF  03
06DEA:  MOVF   01,W
06DEC:  ADDLW  20
06DEE:  MOVWF  FE9
06DF0:  MOVLW  00
06DF2:  ADDWFC 03,W
06DF4:  MOVWF  FEA
06DF6:  MOVFF  69D,FEF
06DFA:  MOVFF  69E,FEC
06DFE:  MOVFF  69F,FEC
06E02:  MOVFF  6A0,FEC
06E06:  BRA    6E12
....................    else return INV_PARAM;
06E08:  MOVLW  02
06E0A:  MOVWF  01
06E0C:  MOVLB  0
06E0E:  BRA    6E18
06E10:  MOVLB  6
....................    
....................    return SUCCESS;
06E12:  MOVLW  00
06E14:  MOVWF  01
06E16:  MOVLB  0
06E18:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06E1A:  MOVLB  6
06E1C:  CLRF   xD2
06E1E:  MOVFF  68F,6D1
06E22:  CLRF   xD4
06E24:  MOVLW  B5
06E26:  MOVWF  xD3
06E28:  MOVLB  0
06E2A:  CALL   0C04
06E2E:  MOVFF  02,69D
06E32:  MOVFF  01,69C
06E36:  MOVLW  06
06E38:  MOVLB  6
06E3A:  ADDWF  x9C,F
06E3C:  MOVLW  00
06E3E:  ADDWFC x9D,F
06E40:  MOVLW  32
06E42:  ADDWF  x9C,W
06E44:  MOVWF  01
06E46:  MOVLW  00
06E48:  ADDWFC x9D,W
06E4A:  MOVWF  03
06E4C:  MOVF   01,W
06E4E:  ADDLW  08
06E50:  MOVWF  01
06E52:  MOVLW  02
06E54:  ADDWFC 03,F
06E56:  MOVFF  01,69C
06E5A:  MOVFF  03,69D
06E5E:  MOVFF  03,6C4
06E62:  MOVFF  01,6C3
06E66:  MOVLB  0
06E68:  CALL   55A6
06E6C:  MOVF   01,F
06E6E:  BNZ   6E78
06E70:  MOVLW  02
06E72:  MOVWF  01
06E74:  BRA    6F7A
06E76:  BRA    6ED6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06E78:  MOVLB  6
06E7A:  CLRF   xD2
06E7C:  MOVFF  68F,6D1
06E80:  CLRF   xD4
06E82:  MOVLW  B5
06E84:  MOVWF  xD3
06E86:  MOVLB  0
06E88:  CALL   0C04
06E8C:  MOVFF  02,69D
06E90:  MOVFF  01,69C
06E94:  MOVLW  06
06E96:  MOVLB  6
06E98:  ADDWF  x9C,F
06E9A:  MOVLW  00
06E9C:  ADDWFC x9D,F
06E9E:  MOVLW  32
06EA0:  ADDWF  x9C,W
06EA2:  MOVWF  01
06EA4:  MOVLW  00
06EA6:  ADDWFC x9D,W
06EA8:  MOVWF  03
06EAA:  MOVF   01,W
06EAC:  ADDLW  08
06EAE:  MOVWF  01
06EB0:  MOVLW  02
06EB2:  ADDWFC 03,F
06EB4:  MOVFF  01,69C
06EB8:  MOVFF  03,69D
06EBC:  MOVFF  03,6C4
06EC0:  MOVFF  01,6C3
06EC4:  CLRF   xC6
06EC6:  CLRF   xC5
06EC8:  MOVLW  0A
06ECA:  MOVWF  xC7
06ECC:  MOVLB  0
06ECE:  CALL   5640
06ED2:  MOVFF  01,69B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
06ED6:  MOVLW  04
06ED8:  MOVLB  6
06EDA:  MOVWF  xD2
06EDC:  MOVLW  DE
06EDE:  MOVWF  xD1
06EE0:  MOVLB  0
06EE2:  CALL   542E
06EE6:  MOVF   01,W
06EE8:  ADDLW  DE
06EEA:  MOVLB  6
06EEC:  MOVWF  x9C
06EEE:  MOVLW  04
06EF0:  ADDWFC 02,W
06EF2:  MOVWF  x9D
06EF4:  MOVLW  01
06EF6:  SUBWF  x9B,W
06EF8:  MULLW  20
06EFA:  MOVF   FF3,W
06EFC:  CLRF   x9F
06EFE:  MOVWF  x9E
06F00:  MOVLW  0C
06F02:  ADDWF  x9E,W
06F04:  MOVWF  01
06F06:  MOVLW  00
06F08:  ADDWFC x9F,W
06F0A:  MOVWF  03
06F0C:  MOVF   01,W
06F0E:  ADDLW  20
06F10:  MOVWF  FE9
06F12:  MOVLW  00
06F14:  ADDWFC 03,W
06F16:  MOVWF  FEA
06F18:  MOVFF  FEF,69E
06F1C:  MOVFF  FEC,69F
06F20:  MOVFF  FEC,6A0
06F24:  MOVFF  FEC,6A1
06F28:  MOVFF  69D,583
06F2C:  MOVFF  69C,582
06F30:  MOVFF  69B,6C4
06F34:  MOVLW  18
06F36:  MOVWF  xC5
06F38:  MOVLB  0
06F3A:  CALL   5996
06F3E:  MOVLW  2C
06F40:  MOVLB  6
06F42:  MOVWF  xE0
06F44:  MOVLB  0
06F46:  CALL   54DE
06F4A:  MOVLW  89
06F4C:  MOVWF  FE9
06F4E:  MOVFF  6A1,6D6
06F52:  MOVFF  6A0,6D5
06F56:  MOVFF  69F,6D4
06F5A:  MOVFF  69E,6D3
06F5E:  MOVLW  02
06F60:  MOVLB  6
06F62:  MOVWF  xD7
06F64:  MOVLB  0
06F66:  CALL   61B2
06F6A:  MOVLW  2C
06F6C:  MOVLB  6
06F6E:  MOVWF  xE0
06F70:  MOVLB  0
06F72:  CALL   54DE
....................    return SUCCESS;
06F76:  MOVLW  00
06F78:  MOVWF  01
06F7A:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06F7C:  MOVLB  6
06F7E:  CLRF   xD2
06F80:  MOVFF  68F,6D1
06F84:  CLRF   xD4
06F86:  MOVLW  B5
06F88:  MOVWF  xD3
06F8A:  MOVLB  0
06F8C:  CALL   0C04
06F90:  MOVFF  02,6A1
06F94:  MOVFF  01,6A0
06F98:  MOVLW  06
06F9A:  MOVLB  6
06F9C:  ADDWF  xA0,F
06F9E:  MOVLW  00
06FA0:  ADDWFC xA1,F
06FA2:  MOVLW  32
06FA4:  ADDWF  xA0,W
06FA6:  MOVWF  01
06FA8:  MOVLW  00
06FAA:  ADDWFC xA1,W
06FAC:  MOVWF  03
06FAE:  MOVF   01,W
06FB0:  ADDLW  08
06FB2:  MOVWF  01
06FB4:  MOVLW  02
06FB6:  ADDWFC 03,F
06FB8:  MOVFF  01,6A0
06FBC:  MOVFF  03,6A1
06FC0:  MOVFF  03,6C4
06FC4:  MOVFF  01,6C3
06FC8:  MOVLB  0
06FCA:  CALL   55A6
06FCE:  MOVF   01,F
06FD0:  BNZ   6FDA
06FD2:  MOVLW  02
06FD4:  MOVWF  01
06FD6:  BRA    7138
06FD8:  BRA    7038
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06FDA:  MOVLB  6
06FDC:  CLRF   xD2
06FDE:  MOVFF  68F,6D1
06FE2:  CLRF   xD4
06FE4:  MOVLW  B5
06FE6:  MOVWF  xD3
06FE8:  MOVLB  0
06FEA:  CALL   0C04
06FEE:  MOVFF  02,6A1
06FF2:  MOVFF  01,6A0
06FF6:  MOVLW  06
06FF8:  MOVLB  6
06FFA:  ADDWF  xA0,F
06FFC:  MOVLW  00
06FFE:  ADDWFC xA1,F
07000:  MOVLW  32
07002:  ADDWF  xA0,W
07004:  MOVWF  01
07006:  MOVLW  00
07008:  ADDWFC xA1,W
0700A:  MOVWF  03
0700C:  MOVF   01,W
0700E:  ADDLW  08
07010:  MOVWF  01
07012:  MOVLW  02
07014:  ADDWFC 03,F
07016:  MOVFF  01,6A0
0701A:  MOVFF  03,6A1
0701E:  MOVFF  03,6C4
07022:  MOVFF  01,6C3
07026:  CLRF   xC6
07028:  CLRF   xC5
0702A:  MOVLW  0A
0702C:  MOVWF  xC7
0702E:  MOVLB  0
07030:  CALL   5640
07034:  MOVFF  01,69B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07038:  MOVLB  6
0703A:  CLRF   xD2
0703C:  MOVFF  68F,6D1
07040:  CLRF   xD4
07042:  MOVLW  B5
07044:  MOVWF  xD3
07046:  MOVLB  0
07048:  CALL   0C04
0704C:  MOVFF  02,6A1
07050:  MOVFF  01,6A0
07054:  MOVLW  06
07056:  MOVLB  6
07058:  ADDWF  xA0,F
0705A:  MOVLW  00
0705C:  ADDWFC xA1,F
0705E:  MOVLW  4B
07060:  ADDWF  xA0,W
07062:  MOVWF  01
07064:  MOVLW  00
07066:  ADDWFC xA1,W
07068:  MOVWF  03
0706A:  MOVF   01,W
0706C:  ADDLW  08
0706E:  MOVWF  01
07070:  MOVLW  02
07072:  ADDWFC 03,F
07074:  MOVFF  01,6A0
07078:  MOVFF  03,6A1
0707C:  MOVFF  03,6A5
07080:  MOVFF  01,6A4
07084:  MOVLB  0
07086:  CALL   681E
0708A:  MOVF   01,F
0708C:  BNZ   7096
0708E:  MOVLW  02
07090:  MOVWF  01
07092:  BRA    7138
07094:  BRA    70FC
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
07096:  MOVLB  6
07098:  CLRF   xD2
0709A:  MOVFF  68F,6D1
0709E:  CLRF   xD4
070A0:  MOVLW  B5
070A2:  MOVWF  xD3
070A4:  MOVLB  0
070A6:  CALL   0C04
070AA:  MOVFF  02,6A1
070AE:  MOVFF  01,6A0
070B2:  MOVLW  06
070B4:  MOVLB  6
070B6:  ADDWF  xA0,F
070B8:  MOVLW  00
070BA:  ADDWFC xA1,F
070BC:  MOVLW  4B
070BE:  ADDWF  xA0,W
070C0:  MOVWF  01
070C2:  MOVLW  00
070C4:  ADDWFC xA1,W
070C6:  MOVWF  03
070C8:  MOVF   01,W
070CA:  ADDLW  08
070CC:  MOVWF  01
070CE:  MOVLW  02
070D0:  ADDWFC 03,F
070D2:  MOVFF  01,6A0
070D6:  MOVFF  03,6A1
070DA:  MOVFF  03,6A5
070DE:  MOVFF  01,6A4
070E2:  CLRF   xA7
070E4:  CLRF   xA6
070E6:  MOVLB  0
070E8:  CALL   68E0
070EC:  MOVFF  03,69F
070F0:  MOVFF  02,69E
070F4:  MOVFF  01,69D
070F8:  MOVFF  00,69C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
070FC:  MOVLW  01
070FE:  MOVLB  6
07100:  SUBWF  x9B,W
07102:  MULLW  20
07104:  MOVF   FF3,W
07106:  CLRF   xA1
07108:  MOVWF  xA0
0710A:  MOVLW  0C
0710C:  ADDWF  xA0,W
0710E:  MOVWF  01
07110:  MOVLW  00
07112:  ADDWFC xA1,W
07114:  MOVWF  03
07116:  MOVF   01,W
07118:  ADDLW  20
0711A:  MOVWF  FE9
0711C:  MOVLW  00
0711E:  ADDWFC 03,W
07120:  MOVWF  FEA
07122:  MOVFF  69C,FEF
07126:  MOVFF  69D,FEC
0712A:  MOVFF  69E,FEC
0712E:  MOVFF  69F,FEC
....................    
....................    return SUCCESS;
07132:  MOVLW  00
07134:  MOVWF  01
07136:  MOVLB  0
07138:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0713A:  MOVLB  6
0713C:  CLRF   xD2
0713E:  MOVFF  68F,6D1
07142:  CLRF   xD4
07144:  MOVLW  B5
07146:  MOVWF  xD3
07148:  MOVLB  0
0714A:  CALL   0C04
0714E:  MOVFF  02,69D
07152:  MOVFF  01,69C
07156:  MOVLW  06
07158:  MOVLB  6
0715A:  ADDWF  x9C,F
0715C:  MOVLW  00
0715E:  ADDWFC x9D,F
07160:  MOVLW  32
07162:  ADDWF  x9C,W
07164:  MOVWF  01
07166:  MOVLW  00
07168:  ADDWFC x9D,W
0716A:  MOVWF  03
0716C:  MOVF   01,W
0716E:  ADDLW  08
07170:  MOVWF  01
07172:  MOVLW  02
07174:  ADDWFC 03,F
07176:  MOVFF  01,69C
0717A:  MOVFF  03,69D
0717E:  MOVFF  03,6C4
07182:  MOVFF  01,6C3
07186:  MOVLB  0
07188:  CALL   55A6
0718C:  MOVF   01,F
0718E:  BNZ   7198
07190:  MOVLW  02
07192:  MOVWF  01
07194:  BRA    74EE
07196:  BRA    71F6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07198:  MOVLB  6
0719A:  CLRF   xD2
0719C:  MOVFF  68F,6D1
071A0:  CLRF   xD4
071A2:  MOVLW  B5
071A4:  MOVWF  xD3
071A6:  MOVLB  0
071A8:  CALL   0C04
071AC:  MOVFF  02,69D
071B0:  MOVFF  01,69C
071B4:  MOVLW  06
071B6:  MOVLB  6
071B8:  ADDWF  x9C,F
071BA:  MOVLW  00
071BC:  ADDWFC x9D,F
071BE:  MOVLW  32
071C0:  ADDWF  x9C,W
071C2:  MOVWF  01
071C4:  MOVLW  00
071C6:  ADDWFC x9D,W
071C8:  MOVWF  03
071CA:  MOVF   01,W
071CC:  ADDLW  08
071CE:  MOVWF  01
071D0:  MOVLW  02
071D2:  ADDWFC 03,F
071D4:  MOVFF  01,69C
071D8:  MOVFF  03,69D
071DC:  MOVFF  03,6C4
071E0:  MOVFF  01,6C3
071E4:  CLRF   xC6
071E6:  CLRF   xC5
071E8:  MOVLW  0A
071EA:  MOVWF  xC7
071EC:  MOVLB  0
071EE:  CALL   5640
071F2:  MOVFF  01,69B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
071F6:  MOVLW  04
071F8:  MOVLB  6
071FA:  MOVWF  xD2
071FC:  MOVLW  DE
071FE:  MOVWF  xD1
07200:  MOVLB  0
07202:  CALL   542E
07206:  MOVFF  02,03
0720A:  MOVF   01,W
0720C:  ADDLW  DE
0720E:  MOVLB  6
07210:  MOVWF  x9C
07212:  MOVLW  04
07214:  ADDWFC 02,W
07216:  MOVWF  x9D
07218:  MOVFF  FE8,583
0721C:  MOVFF  69C,582
07220:  MOVFF  69B,6C4
07224:  MOVLW  18
07226:  MOVWF  xC5
07228:  MOVLB  0
0722A:  CALL   5996
0722E:  MOVLW  2C
07230:  MOVLB  6
07232:  MOVWF  xE0
07234:  MOVLB  0
07236:  CALL   54DE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0723A:  MOVLW  04
0723C:  MOVLB  6
0723E:  MOVWF  xD2
07240:  MOVLW  DE
07242:  MOVWF  xD1
07244:  MOVLB  0
07246:  CALL   542E
0724A:  MOVFF  02,03
0724E:  MOVF   01,W
07250:  ADDLW  DE
07252:  MOVLB  6
07254:  MOVWF  x9C
07256:  MOVLW  04
07258:  ADDWFC 02,W
0725A:  MOVWF  x9D
0725C:  MOVLW  01
0725E:  SUBWF  x9B,W
07260:  MULLW  18
07262:  MOVF   FF3,W
07264:  CLRF   x9F
07266:  MOVWF  x9E
07268:  MOVLW  82
0726A:  ADDWF  x9E,W
0726C:  MOVWF  FE9
0726E:  MOVLW  00
07270:  ADDWFC x9F,W
07272:  MOVWF  FEA
07274:  MOVFF  FEF,6D3
07278:  MOVFF  FEC,6D4
0727C:  MOVFF  FEC,6D5
07280:  MOVFF  FEC,6D6
07284:  MOVFF  69D,583
07288:  MOVFF  69C,582
0728C:  MOVLW  89
0728E:  MOVWF  FE9
07290:  MOVLW  02
07292:  MOVWF  xD7
07294:  MOVLB  0
07296:  CALL   61B2
0729A:  MOVLW  2C
0729C:  MOVLB  6
0729E:  MOVWF  xE0
072A0:  MOVLB  0
072A2:  CALL   54DE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
072A6:  MOVLW  04
072A8:  MOVLB  6
072AA:  MOVWF  xD2
072AC:  MOVLW  DE
072AE:  MOVWF  xD1
072B0:  MOVLB  0
072B2:  CALL   542E
072B6:  MOVF   01,W
072B8:  ADDLW  DE
072BA:  MOVLB  6
072BC:  MOVWF  x9C
072BE:  MOVLW  04
072C0:  ADDWFC 02,W
072C2:  MOVWF  x9D
072C4:  MOVLW  01
072C6:  SUBWF  x9B,W
072C8:  MULLW  18
072CA:  MOVF   FF3,W
072CC:  CLRF   x9F
072CE:  MOVWF  x9E
072D0:  MOVLW  04
072D2:  ADDWF  x9E,W
072D4:  MOVWF  01
072D6:  MOVLW  00
072D8:  ADDWFC x9F,W
072DA:  MOVWF  03
072DC:  MOVF   01,W
072DE:  ADDLW  82
072E0:  MOVWF  FE9
072E2:  MOVLW  00
072E4:  ADDWFC 03,W
072E6:  MOVWF  FEA
072E8:  MOVFF  FEF,6D3
072EC:  MOVFF  FEC,6D4
072F0:  MOVFF  FEC,6D5
072F4:  MOVFF  FEC,6D6
072F8:  MOVFF  69D,583
072FC:  MOVFF  69C,582
07300:  MOVLW  89
07302:  MOVWF  FE9
07304:  MOVLW  02
07306:  MOVWF  xD7
07308:  MOVLB  0
0730A:  CALL   61B2
0730E:  MOVLW  2C
07310:  MOVLB  6
07312:  MOVWF  xE0
07314:  MOVLB  0
07316:  CALL   54DE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
0731A:  MOVLW  04
0731C:  MOVLB  6
0731E:  MOVWF  xD2
07320:  MOVLW  DE
07322:  MOVWF  xD1
07324:  MOVLB  0
07326:  CALL   542E
0732A:  MOVF   01,W
0732C:  ADDLW  DE
0732E:  MOVLB  6
07330:  MOVWF  x9C
07332:  MOVLW  04
07334:  ADDWFC 02,W
07336:  MOVWF  x9D
07338:  MOVLW  01
0733A:  SUBWF  x9B,W
0733C:  MULLW  18
0733E:  MOVF   FF3,W
07340:  CLRF   x9F
07342:  MOVWF  x9E
07344:  MOVLW  08
07346:  ADDWF  x9E,W
07348:  MOVWF  01
0734A:  MOVLW  00
0734C:  ADDWFC x9F,W
0734E:  MOVWF  03
07350:  MOVF   01,W
07352:  ADDLW  82
07354:  MOVWF  FE9
07356:  MOVLW  00
07358:  ADDWFC 03,W
0735A:  MOVWF  FEA
0735C:  MOVFF  FEF,6D3
07360:  MOVFF  FEC,6D4
07364:  MOVFF  FEC,6D5
07368:  MOVFF  FEC,6D6
0736C:  MOVFF  69D,583
07370:  MOVFF  69C,582
07374:  MOVLW  89
07376:  MOVWF  FE9
07378:  MOVLW  02
0737A:  MOVWF  xD7
0737C:  MOVLB  0
0737E:  CALL   61B2
07382:  MOVLW  2C
07384:  MOVLB  6
07386:  MOVWF  xE0
07388:  MOVLB  0
0738A:  CALL   54DE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
0738E:  MOVLW  04
07390:  MOVLB  6
07392:  MOVWF  xD2
07394:  MOVLW  DE
07396:  MOVWF  xD1
07398:  MOVLB  0
0739A:  CALL   542E
0739E:  MOVF   01,W
073A0:  ADDLW  DE
073A2:  MOVLB  6
073A4:  MOVWF  x9C
073A6:  MOVLW  04
073A8:  ADDWFC 02,W
073AA:  MOVWF  x9D
073AC:  MOVLW  01
073AE:  SUBWF  x9B,W
073B0:  MULLW  18
073B2:  MOVF   FF3,W
073B4:  CLRF   x9F
073B6:  MOVWF  x9E
073B8:  MOVLW  0C
073BA:  ADDWF  x9E,W
073BC:  MOVWF  01
073BE:  MOVLW  00
073C0:  ADDWFC x9F,W
073C2:  MOVWF  03
073C4:  MOVF   01,W
073C6:  ADDLW  82
073C8:  MOVWF  FE9
073CA:  MOVLW  00
073CC:  ADDWFC 03,W
073CE:  MOVWF  FEA
073D0:  MOVFF  FEF,6D3
073D4:  MOVFF  FEC,6D4
073D8:  MOVFF  FEC,6D5
073DC:  MOVFF  FEC,6D6
073E0:  MOVFF  69D,583
073E4:  MOVFF  69C,582
073E8:  MOVLW  89
073EA:  MOVWF  FE9
073EC:  MOVLW  02
073EE:  MOVWF  xD7
073F0:  MOVLB  0
073F2:  CALL   61B2
073F6:  MOVLW  2C
073F8:  MOVLB  6
073FA:  MOVWF  xE0
073FC:  MOVLB  0
073FE:  CALL   54DE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07402:  MOVLW  04
07404:  MOVLB  6
07406:  MOVWF  xD2
07408:  MOVLW  DE
0740A:  MOVWF  xD1
0740C:  MOVLB  0
0740E:  CALL   542E
07412:  MOVF   01,W
07414:  ADDLW  DE
07416:  MOVLB  6
07418:  MOVWF  x9C
0741A:  MOVLW  04
0741C:  ADDWFC 02,W
0741E:  MOVWF  x9D
07420:  MOVLW  01
07422:  SUBWF  x9B,W
07424:  MULLW  18
07426:  MOVF   FF3,W
07428:  CLRF   x9F
0742A:  MOVWF  x9E
0742C:  MOVLW  10
0742E:  ADDWF  x9E,W
07430:  MOVWF  01
07432:  MOVLW  00
07434:  ADDWFC x9F,W
07436:  MOVWF  03
07438:  MOVF   01,W
0743A:  ADDLW  82
0743C:  MOVWF  FE9
0743E:  MOVLW  00
07440:  ADDWFC 03,W
07442:  MOVWF  FEA
07444:  MOVFF  FEF,6D3
07448:  MOVFF  FEC,6D4
0744C:  MOVFF  FEC,6D5
07450:  MOVFF  FEC,6D6
07454:  MOVFF  69D,583
07458:  MOVFF  69C,582
0745C:  MOVLW  89
0745E:  MOVWF  FE9
07460:  MOVLW  02
07462:  MOVWF  xD7
07464:  MOVLB  0
07466:  CALL   61B2
0746A:  MOVLW  2C
0746C:  MOVLB  6
0746E:  MOVWF  xE0
07470:  MOVLB  0
07472:  CALL   54DE
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07476:  MOVLW  04
07478:  MOVLB  6
0747A:  MOVWF  xD2
0747C:  MOVLW  DE
0747E:  MOVWF  xD1
07480:  MOVLB  0
07482:  CALL   542E
07486:  MOVF   01,W
07488:  ADDLW  DE
0748A:  MOVLB  6
0748C:  MOVWF  x9C
0748E:  MOVLW  04
07490:  ADDWFC 02,W
07492:  MOVWF  x9D
07494:  MOVLW  01
07496:  SUBWF  x9B,W
07498:  MULLW  18
0749A:  MOVF   FF3,W
0749C:  CLRF   x9F
0749E:  MOVWF  x9E
074A0:  MOVLW  14
074A2:  ADDWF  x9E,W
074A4:  MOVWF  01
074A6:  MOVLW  00
074A8:  ADDWFC x9F,W
074AA:  MOVWF  03
074AC:  MOVF   01,W
074AE:  ADDLW  82
074B0:  MOVWF  FE9
074B2:  MOVLW  00
074B4:  ADDWFC 03,W
074B6:  MOVWF  FEA
074B8:  MOVFF  FEF,6D3
074BC:  MOVFF  FEC,6D4
074C0:  MOVFF  FEC,6D5
074C4:  MOVFF  FEC,6D6
074C8:  MOVFF  69D,583
074CC:  MOVFF  69C,582
074D0:  MOVLW  89
074D2:  MOVWF  FE9
074D4:  MOVLW  02
074D6:  MOVWF  xD7
074D8:  MOVLB  0
074DA:  CALL   61B2
074DE:  MOVLW  2C
074E0:  MOVLB  6
074E2:  MOVWF  xE0
074E4:  MOVLB  0
074E6:  CALL   54DE
....................    
....................    return SUCCESS;
074EA:  MOVLW  00
074EC:  MOVWF  01
074EE:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
074F0:  MOVLB  6
074F2:  CLRF   xD2
074F4:  MOVFF  68F,6D1
074F8:  CLRF   xD4
074FA:  MOVLW  B5
074FC:  MOVWF  xD3
074FE:  MOVLB  0
07500:  CALL   0C04
07504:  MOVFF  02,69E
07508:  MOVFF  01,69D
0750C:  MOVLW  06
0750E:  MOVLB  6
07510:  ADDWF  x9D,F
07512:  MOVLW  00
07514:  ADDWFC x9E,F
07516:  MOVLW  32
07518:  ADDWF  x9D,W
0751A:  MOVWF  01
0751C:  MOVLW  00
0751E:  ADDWFC x9E,W
07520:  MOVWF  03
07522:  MOVF   01,W
07524:  ADDLW  08
07526:  MOVWF  01
07528:  MOVLW  02
0752A:  ADDWFC 03,F
0752C:  MOVFF  01,69D
07530:  MOVFF  03,69E
07534:  MOVFF  03,6C4
07538:  MOVFF  01,6C3
0753C:  MOVLB  0
0753E:  CALL   55A6
07542:  MOVF   01,F
07544:  BNZ   754E
07546:  MOVLW  02
07548:  MOVWF  01
0754A:  BRA    7A4A
0754C:  BRA    75AC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0754E:  MOVLB  6
07550:  CLRF   xD2
07552:  MOVFF  68F,6D1
07556:  CLRF   xD4
07558:  MOVLW  B5
0755A:  MOVWF  xD3
0755C:  MOVLB  0
0755E:  CALL   0C04
07562:  MOVFF  02,69E
07566:  MOVFF  01,69D
0756A:  MOVLW  06
0756C:  MOVLB  6
0756E:  ADDWF  x9D,F
07570:  MOVLW  00
07572:  ADDWFC x9E,F
07574:  MOVLW  32
07576:  ADDWF  x9D,W
07578:  MOVWF  01
0757A:  MOVLW  00
0757C:  ADDWFC x9E,W
0757E:  MOVWF  03
07580:  MOVF   01,W
07582:  ADDLW  08
07584:  MOVWF  01
07586:  MOVLW  02
07588:  ADDWFC 03,F
0758A:  MOVFF  01,69D
0758E:  MOVFF  03,69E
07592:  MOVFF  03,6C4
07596:  MOVFF  01,6C3
0759A:  CLRF   xC6
0759C:  CLRF   xC5
0759E:  MOVLW  0A
075A0:  MOVWF  xC7
075A2:  MOVLB  0
075A4:  CALL   5640
075A8:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
075AC:  MOVLB  6
075AE:  CLRF   xD2
075B0:  MOVFF  68F,6D1
075B4:  CLRF   xD4
075B6:  MOVLW  B5
075B8:  MOVWF  xD3
075BA:  MOVLB  0
075BC:  CALL   0C04
075C0:  MOVFF  02,69E
075C4:  MOVFF  01,69D
075C8:  MOVLW  06
075CA:  MOVLB  6
075CC:  ADDWF  x9D,F
075CE:  MOVLW  00
075D0:  ADDWFC x9E,F
075D2:  MOVLW  4B
075D4:  ADDWF  x9D,W
075D6:  MOVWF  01
075D8:  MOVLW  00
075DA:  ADDWFC x9E,W
075DC:  MOVWF  03
075DE:  MOVF   01,W
075E0:  ADDLW  08
075E2:  MOVWF  01
075E4:  MOVLW  02
075E6:  ADDWFC 03,F
075E8:  MOVFF  01,69D
075EC:  MOVFF  03,69E
075F0:  MOVFF  03,6D2
075F4:  MOVFF  01,6D1
075F8:  MOVLB  0
075FA:  CALL   542E
075FE:  MOVFF  02,03
07602:  MOVF   01,W
07604:  SUBLW  01
07606:  BNZ   760C
07608:  MOVF   03,F
0760A:  BZ    7614
0760C:  MOVLW  02
0760E:  MOVWF  01
07610:  BRA    7A4A
07612:  BRA    7654
....................    else arg2 = SERcmd[rec].p[3][0];
07614:  MOVLB  6
07616:  CLRF   xD2
07618:  MOVFF  68F,6D1
0761C:  CLRF   xD4
0761E:  MOVLW  B5
07620:  MOVWF  xD3
07622:  MOVLB  0
07624:  CALL   0C04
07628:  MOVFF  02,69E
0762C:  MOVFF  01,69D
07630:  MOVLW  06
07632:  MOVLB  6
07634:  ADDWF  x9D,F
07636:  MOVLW  00
07638:  ADDWFC x9E,F
0763A:  MOVLW  4B
0763C:  ADDWF  x9D,F
0763E:  MOVLW  00
07640:  ADDWFC x9E,F
07642:  MOVLW  08
07644:  ADDWF  x9D,W
07646:  MOVWF  FE9
07648:  MOVLW  02
0764A:  ADDWFC x9E,W
0764C:  MOVWF  FEA
0764E:  MOVFF  FEF,69C
07652:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07654:  MOVLB  6
07656:  MOVF   x9C,W
07658:  SUBLW  30
0765A:  BNZ   76F6
0765C:  MOVLW  04
0765E:  MOVWF  xD2
07660:  MOVLW  DE
07662:  MOVWF  xD1
07664:  MOVLB  0
07666:  CALL   542E
0766A:  MOVFF  02,03
0766E:  MOVF   01,W
07670:  ADDLW  DE
07672:  MOVLB  6
07674:  MOVWF  x9D
07676:  MOVLW  04
07678:  ADDWFC 02,W
0767A:  MOVWF  x9E
0767C:  MOVLW  01
0767E:  SUBWF  x9B,W
07680:  MULLW  18
07682:  MOVF   FF3,W
07684:  CLRF   xA0
07686:  MOVWF  x9F
07688:  MOVLW  82
0768A:  ADDWF  x9F,W
0768C:  MOVWF  FE9
0768E:  MOVLW  00
07690:  ADDWFC xA0,W
07692:  MOVWF  FEA
07694:  MOVFF  FEF,6A1
07698:  MOVFF  FEC,6A2
0769C:  MOVFF  FEC,6A3
076A0:  MOVFF  FEC,6A4
076A4:  MOVFF  69E,583
076A8:  MOVFF  69D,582
076AC:  MOVFF  69B,6C4
076B0:  MOVLW  18
076B2:  MOVWF  xC5
076B4:  MOVLB  0
076B6:  CALL   5996
076BA:  MOVLW  2C
076BC:  MOVLB  6
076BE:  MOVWF  xE0
076C0:  MOVLB  0
076C2:  CALL   54DE
076C6:  MOVLW  89
076C8:  MOVWF  FE9
076CA:  MOVFF  6A4,6D6
076CE:  MOVFF  6A3,6D5
076D2:  MOVFF  6A2,6D4
076D6:  MOVFF  6A1,6D3
076DA:  MOVLW  02
076DC:  MOVLB  6
076DE:  MOVWF  xD7
076E0:  MOVLB  0
076E2:  CALL   61B2
076E6:  MOVLW  2C
076E8:  MOVLB  6
076EA:  MOVWF  xE0
076EC:  MOVLB  0
076EE:  CALL   54DE
076F2:  BRA    7A46
076F4:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
076F6:  MOVF   x9C,W
076F8:  SUBLW  31
076FA:  BNZ   779E
076FC:  MOVLW  04
076FE:  MOVWF  xD2
07700:  MOVLW  DE
07702:  MOVWF  xD1
07704:  MOVLB  0
07706:  CALL   542E
0770A:  MOVF   01,W
0770C:  ADDLW  DE
0770E:  MOVLB  6
07710:  MOVWF  x9D
07712:  MOVLW  04
07714:  ADDWFC 02,W
07716:  MOVWF  x9E
07718:  MOVLW  01
0771A:  SUBWF  x9B,W
0771C:  MULLW  18
0771E:  MOVF   FF3,W
07720:  CLRF   xA0
07722:  MOVWF  x9F
07724:  MOVLW  04
07726:  ADDWF  x9F,W
07728:  MOVWF  01
0772A:  MOVLW  00
0772C:  ADDWFC xA0,W
0772E:  MOVWF  03
07730:  MOVF   01,W
07732:  ADDLW  82
07734:  MOVWF  FE9
07736:  MOVLW  00
07738:  ADDWFC 03,W
0773A:  MOVWF  FEA
0773C:  MOVFF  FEF,69F
07740:  MOVFF  FEC,6A0
07744:  MOVFF  FEC,6A1
07748:  MOVFF  FEC,6A2
0774C:  MOVFF  69E,583
07750:  MOVFF  69D,582
07754:  MOVFF  69B,6C4
07758:  MOVLW  18
0775A:  MOVWF  xC5
0775C:  MOVLB  0
0775E:  CALL   5996
07762:  MOVLW  2C
07764:  MOVLB  6
07766:  MOVWF  xE0
07768:  MOVLB  0
0776A:  CALL   54DE
0776E:  MOVLW  89
07770:  MOVWF  FE9
07772:  MOVFF  6A2,6D6
07776:  MOVFF  6A1,6D5
0777A:  MOVFF  6A0,6D4
0777E:  MOVFF  69F,6D3
07782:  MOVLW  02
07784:  MOVLB  6
07786:  MOVWF  xD7
07788:  MOVLB  0
0778A:  CALL   61B2
0778E:  MOVLW  2C
07790:  MOVLB  6
07792:  MOVWF  xE0
07794:  MOVLB  0
07796:  CALL   54DE
0779A:  BRA    7A46
0779C:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
0779E:  MOVF   x9C,W
077A0:  SUBLW  32
077A2:  BNZ   7846
077A4:  MOVLW  04
077A6:  MOVWF  xD2
077A8:  MOVLW  DE
077AA:  MOVWF  xD1
077AC:  MOVLB  0
077AE:  CALL   542E
077B2:  MOVF   01,W
077B4:  ADDLW  DE
077B6:  MOVLB  6
077B8:  MOVWF  x9D
077BA:  MOVLW  04
077BC:  ADDWFC 02,W
077BE:  MOVWF  x9E
077C0:  MOVLW  01
077C2:  SUBWF  x9B,W
077C4:  MULLW  18
077C6:  MOVF   FF3,W
077C8:  CLRF   xA0
077CA:  MOVWF  x9F
077CC:  MOVLW  08
077CE:  ADDWF  x9F,W
077D0:  MOVWF  01
077D2:  MOVLW  00
077D4:  ADDWFC xA0,W
077D6:  MOVWF  03
077D8:  MOVF   01,W
077DA:  ADDLW  82
077DC:  MOVWF  FE9
077DE:  MOVLW  00
077E0:  ADDWFC 03,W
077E2:  MOVWF  FEA
077E4:  MOVFF  FEF,69F
077E8:  MOVFF  FEC,6A0
077EC:  MOVFF  FEC,6A1
077F0:  MOVFF  FEC,6A2
077F4:  MOVFF  69E,583
077F8:  MOVFF  69D,582
077FC:  MOVFF  69B,6C4
07800:  MOVLW  18
07802:  MOVWF  xC5
07804:  MOVLB  0
07806:  CALL   5996
0780A:  MOVLW  2C
0780C:  MOVLB  6
0780E:  MOVWF  xE0
07810:  MOVLB  0
07812:  CALL   54DE
07816:  MOVLW  89
07818:  MOVWF  FE9
0781A:  MOVFF  6A2,6D6
0781E:  MOVFF  6A1,6D5
07822:  MOVFF  6A0,6D4
07826:  MOVFF  69F,6D3
0782A:  MOVLW  02
0782C:  MOVLB  6
0782E:  MOVWF  xD7
07830:  MOVLB  0
07832:  CALL   61B2
07836:  MOVLW  2C
07838:  MOVLB  6
0783A:  MOVWF  xE0
0783C:  MOVLB  0
0783E:  CALL   54DE
07842:  BRA    7A46
07844:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07846:  MOVF   x9C,W
07848:  SUBLW  33
0784A:  BNZ   78EE
0784C:  MOVLW  04
0784E:  MOVWF  xD2
07850:  MOVLW  DE
07852:  MOVWF  xD1
07854:  MOVLB  0
07856:  CALL   542E
0785A:  MOVF   01,W
0785C:  ADDLW  DE
0785E:  MOVLB  6
07860:  MOVWF  x9D
07862:  MOVLW  04
07864:  ADDWFC 02,W
07866:  MOVWF  x9E
07868:  MOVLW  01
0786A:  SUBWF  x9B,W
0786C:  MULLW  18
0786E:  MOVF   FF3,W
07870:  CLRF   xA0
07872:  MOVWF  x9F
07874:  MOVLW  0C
07876:  ADDWF  x9F,W
07878:  MOVWF  01
0787A:  MOVLW  00
0787C:  ADDWFC xA0,W
0787E:  MOVWF  03
07880:  MOVF   01,W
07882:  ADDLW  82
07884:  MOVWF  FE9
07886:  MOVLW  00
07888:  ADDWFC 03,W
0788A:  MOVWF  FEA
0788C:  MOVFF  FEF,69F
07890:  MOVFF  FEC,6A0
07894:  MOVFF  FEC,6A1
07898:  MOVFF  FEC,6A2
0789C:  MOVFF  69E,583
078A0:  MOVFF  69D,582
078A4:  MOVFF  69B,6C4
078A8:  MOVLW  18
078AA:  MOVWF  xC5
078AC:  MOVLB  0
078AE:  CALL   5996
078B2:  MOVLW  2C
078B4:  MOVLB  6
078B6:  MOVWF  xE0
078B8:  MOVLB  0
078BA:  CALL   54DE
078BE:  MOVLW  89
078C0:  MOVWF  FE9
078C2:  MOVFF  6A2,6D6
078C6:  MOVFF  6A1,6D5
078CA:  MOVFF  6A0,6D4
078CE:  MOVFF  69F,6D3
078D2:  MOVLW  02
078D4:  MOVLB  6
078D6:  MOVWF  xD7
078D8:  MOVLB  0
078DA:  CALL   61B2
078DE:  MOVLW  2C
078E0:  MOVLB  6
078E2:  MOVWF  xE0
078E4:  MOVLB  0
078E6:  CALL   54DE
078EA:  BRA    7A46
078EC:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
078EE:  MOVF   x9C,W
078F0:  SUBLW  34
078F2:  BNZ   7996
078F4:  MOVLW  04
078F6:  MOVWF  xD2
078F8:  MOVLW  DE
078FA:  MOVWF  xD1
078FC:  MOVLB  0
078FE:  CALL   542E
07902:  MOVF   01,W
07904:  ADDLW  DE
07906:  MOVLB  6
07908:  MOVWF  x9D
0790A:  MOVLW  04
0790C:  ADDWFC 02,W
0790E:  MOVWF  x9E
07910:  MOVLW  01
07912:  SUBWF  x9B,W
07914:  MULLW  18
07916:  MOVF   FF3,W
07918:  CLRF   xA0
0791A:  MOVWF  x9F
0791C:  MOVLW  10
0791E:  ADDWF  x9F,W
07920:  MOVWF  01
07922:  MOVLW  00
07924:  ADDWFC xA0,W
07926:  MOVWF  03
07928:  MOVF   01,W
0792A:  ADDLW  82
0792C:  MOVWF  FE9
0792E:  MOVLW  00
07930:  ADDWFC 03,W
07932:  MOVWF  FEA
07934:  MOVFF  FEF,69F
07938:  MOVFF  FEC,6A0
0793C:  MOVFF  FEC,6A1
07940:  MOVFF  FEC,6A2
07944:  MOVFF  69E,583
07948:  MOVFF  69D,582
0794C:  MOVFF  69B,6C4
07950:  MOVLW  18
07952:  MOVWF  xC5
07954:  MOVLB  0
07956:  CALL   5996
0795A:  MOVLW  2C
0795C:  MOVLB  6
0795E:  MOVWF  xE0
07960:  MOVLB  0
07962:  CALL   54DE
07966:  MOVLW  89
07968:  MOVWF  FE9
0796A:  MOVFF  6A2,6D6
0796E:  MOVFF  6A1,6D5
07972:  MOVFF  6A0,6D4
07976:  MOVFF  69F,6D3
0797A:  MOVLW  02
0797C:  MOVLB  6
0797E:  MOVWF  xD7
07980:  MOVLB  0
07982:  CALL   61B2
07986:  MOVLW  2C
07988:  MOVLB  6
0798A:  MOVWF  xE0
0798C:  MOVLB  0
0798E:  CALL   54DE
07992:  BRA    7A46
07994:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07996:  MOVF   x9C,W
07998:  SUBLW  35
0799A:  BNZ   7A3E
0799C:  MOVLW  04
0799E:  MOVWF  xD2
079A0:  MOVLW  DE
079A2:  MOVWF  xD1
079A4:  MOVLB  0
079A6:  CALL   542E
079AA:  MOVF   01,W
079AC:  ADDLW  DE
079AE:  MOVLB  6
079B0:  MOVWF  x9D
079B2:  MOVLW  04
079B4:  ADDWFC 02,W
079B6:  MOVWF  x9E
079B8:  MOVLW  01
079BA:  SUBWF  x9B,W
079BC:  MULLW  18
079BE:  MOVF   FF3,W
079C0:  CLRF   xA0
079C2:  MOVWF  x9F
079C4:  MOVLW  14
079C6:  ADDWF  x9F,W
079C8:  MOVWF  01
079CA:  MOVLW  00
079CC:  ADDWFC xA0,W
079CE:  MOVWF  03
079D0:  MOVF   01,W
079D2:  ADDLW  82
079D4:  MOVWF  FE9
079D6:  MOVLW  00
079D8:  ADDWFC 03,W
079DA:  MOVWF  FEA
079DC:  MOVFF  FEF,69F
079E0:  MOVFF  FEC,6A0
079E4:  MOVFF  FEC,6A1
079E8:  MOVFF  FEC,6A2
079EC:  MOVFF  69E,583
079F0:  MOVFF  69D,582
079F4:  MOVFF  69B,6C4
079F8:  MOVLW  18
079FA:  MOVWF  xC5
079FC:  MOVLB  0
079FE:  CALL   5996
07A02:  MOVLW  2C
07A04:  MOVLB  6
07A06:  MOVWF  xE0
07A08:  MOVLB  0
07A0A:  CALL   54DE
07A0E:  MOVLW  89
07A10:  MOVWF  FE9
07A12:  MOVFF  6A2,6D6
07A16:  MOVFF  6A1,6D5
07A1A:  MOVFF  6A0,6D4
07A1E:  MOVFF  69F,6D3
07A22:  MOVLW  02
07A24:  MOVLB  6
07A26:  MOVWF  xD7
07A28:  MOVLB  0
07A2A:  CALL   61B2
07A2E:  MOVLW  2C
07A30:  MOVLB  6
07A32:  MOVWF  xE0
07A34:  MOVLB  0
07A36:  CALL   54DE
07A3A:  BRA    7A46
07A3C:  MOVLB  6
....................    else return INV_PARAM;
07A3E:  MOVLW  02
07A40:  MOVWF  01
07A42:  MOVLB  0
07A44:  BRA    7A4A
....................    
....................    return SUCCESS;
07A46:  MOVLW  00
07A48:  MOVWF  01
07A4A:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07A4C:  MOVLB  6
07A4E:  CLRF   xD2
07A50:  MOVFF  68F,6D1
07A54:  CLRF   xD4
07A56:  MOVLW  B5
07A58:  MOVWF  xD3
07A5A:  MOVLB  0
07A5C:  CALL   0C04
07A60:  MOVFF  02,6A2
07A64:  MOVFF  01,6A1
07A68:  MOVLW  06
07A6A:  MOVLB  6
07A6C:  ADDWF  xA1,F
07A6E:  MOVLW  00
07A70:  ADDWFC xA2,F
07A72:  MOVLW  32
07A74:  ADDWF  xA1,W
07A76:  MOVWF  01
07A78:  MOVLW  00
07A7A:  ADDWFC xA2,W
07A7C:  MOVWF  03
07A7E:  MOVF   01,W
07A80:  ADDLW  08
07A82:  MOVWF  01
07A84:  MOVLW  02
07A86:  ADDWFC 03,F
07A88:  MOVFF  01,6A1
07A8C:  MOVFF  03,6A2
07A90:  MOVFF  03,6C4
07A94:  MOVFF  01,6C3
07A98:  MOVLB  0
07A9A:  CALL   55A6
07A9E:  MOVF   01,F
07AA0:  BNZ   7AAA
07AA2:  MOVLW  02
07AA4:  MOVWF  01
07AA6:  BRA    7DE2
07AA8:  BRA    7B08
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07AAA:  MOVLB  6
07AAC:  CLRF   xD2
07AAE:  MOVFF  68F,6D1
07AB2:  CLRF   xD4
07AB4:  MOVLW  B5
07AB6:  MOVWF  xD3
07AB8:  MOVLB  0
07ABA:  CALL   0C04
07ABE:  MOVFF  02,6A2
07AC2:  MOVFF  01,6A1
07AC6:  MOVLW  06
07AC8:  MOVLB  6
07ACA:  ADDWF  xA1,F
07ACC:  MOVLW  00
07ACE:  ADDWFC xA2,F
07AD0:  MOVLW  32
07AD2:  ADDWF  xA1,W
07AD4:  MOVWF  01
07AD6:  MOVLW  00
07AD8:  ADDWFC xA2,W
07ADA:  MOVWF  03
07ADC:  MOVF   01,W
07ADE:  ADDLW  08
07AE0:  MOVWF  01
07AE2:  MOVLW  02
07AE4:  ADDWFC 03,F
07AE6:  MOVFF  01,6A1
07AEA:  MOVFF  03,6A2
07AEE:  MOVFF  03,6C4
07AF2:  MOVFF  01,6C3
07AF6:  CLRF   xC6
07AF8:  CLRF   xC5
07AFA:  MOVLW  0A
07AFC:  MOVWF  xC7
07AFE:  MOVLB  0
07B00:  CALL   5640
07B04:  MOVFF  01,69B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07B08:  MOVLB  6
07B0A:  CLRF   xD2
07B0C:  MOVFF  68F,6D1
07B10:  CLRF   xD4
07B12:  MOVLW  B5
07B14:  MOVWF  xD3
07B16:  MOVLB  0
07B18:  CALL   0C04
07B1C:  MOVFF  02,6A2
07B20:  MOVFF  01,6A1
07B24:  MOVLW  06
07B26:  MOVLB  6
07B28:  ADDWF  xA1,F
07B2A:  MOVLW  00
07B2C:  ADDWFC xA2,F
07B2E:  MOVLW  4B
07B30:  ADDWF  xA1,W
07B32:  MOVWF  01
07B34:  MOVLW  00
07B36:  ADDWFC xA2,W
07B38:  MOVWF  03
07B3A:  MOVF   01,W
07B3C:  ADDLW  08
07B3E:  MOVWF  01
07B40:  MOVLW  02
07B42:  ADDWFC 03,F
07B44:  MOVFF  01,6A1
07B48:  MOVFF  03,6A2
07B4C:  MOVFF  03,6D2
07B50:  MOVFF  01,6D1
07B54:  MOVLB  0
07B56:  CALL   542E
07B5A:  MOVFF  02,03
07B5E:  MOVF   01,W
07B60:  SUBLW  01
07B62:  BNZ   7B68
07B64:  MOVF   03,F
07B66:  BZ    7B70
07B68:  MOVLW  02
07B6A:  MOVWF  01
07B6C:  BRA    7DE2
07B6E:  BRA    7BB0
....................    else arg2 = SERcmd[rec].p[3][0];
07B70:  MOVLB  6
07B72:  CLRF   xD2
07B74:  MOVFF  68F,6D1
07B78:  CLRF   xD4
07B7A:  MOVLW  B5
07B7C:  MOVWF  xD3
07B7E:  MOVLB  0
07B80:  CALL   0C04
07B84:  MOVFF  02,6A2
07B88:  MOVFF  01,6A1
07B8C:  MOVLW  06
07B8E:  MOVLB  6
07B90:  ADDWF  xA1,F
07B92:  MOVLW  00
07B94:  ADDWFC xA2,F
07B96:  MOVLW  4B
07B98:  ADDWF  xA1,F
07B9A:  MOVLW  00
07B9C:  ADDWFC xA2,F
07B9E:  MOVLW  08
07BA0:  ADDWF  xA1,W
07BA2:  MOVWF  FE9
07BA4:  MOVLW  02
07BA6:  ADDWFC xA2,W
07BA8:  MOVWF  FEA
07BAA:  MOVFF  FEF,69C
07BAE:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07BB0:  MOVLB  6
07BB2:  CLRF   xD2
07BB4:  MOVFF  68F,6D1
07BB8:  CLRF   xD4
07BBA:  MOVLW  B5
07BBC:  MOVWF  xD3
07BBE:  MOVLB  0
07BC0:  CALL   0C04
07BC4:  MOVFF  02,6A2
07BC8:  MOVFF  01,6A1
07BCC:  MOVLW  06
07BCE:  MOVLB  6
07BD0:  ADDWF  xA1,F
07BD2:  MOVLW  00
07BD4:  ADDWFC xA2,F
07BD6:  MOVLW  64
07BD8:  ADDWF  xA1,W
07BDA:  MOVWF  01
07BDC:  MOVLW  00
07BDE:  ADDWFC xA2,W
07BE0:  MOVWF  03
07BE2:  MOVF   01,W
07BE4:  ADDLW  08
07BE6:  MOVWF  01
07BE8:  MOVLW  02
07BEA:  ADDWFC 03,F
07BEC:  MOVFF  01,6A1
07BF0:  MOVFF  03,6A2
07BF4:  MOVFF  03,6A5
07BF8:  MOVFF  01,6A4
07BFC:  MOVLB  0
07BFE:  CALL   681E
07C02:  MOVF   01,F
07C04:  BNZ   7C0E
07C06:  MOVLW  02
07C08:  MOVWF  01
07C0A:  BRA    7DE2
07C0C:  BRA    7C74
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07C0E:  MOVLB  6
07C10:  CLRF   xD2
07C12:  MOVFF  68F,6D1
07C16:  CLRF   xD4
07C18:  MOVLW  B5
07C1A:  MOVWF  xD3
07C1C:  MOVLB  0
07C1E:  CALL   0C04
07C22:  MOVFF  02,6A2
07C26:  MOVFF  01,6A1
07C2A:  MOVLW  06
07C2C:  MOVLB  6
07C2E:  ADDWF  xA1,F
07C30:  MOVLW  00
07C32:  ADDWFC xA2,F
07C34:  MOVLW  64
07C36:  ADDWF  xA1,W
07C38:  MOVWF  01
07C3A:  MOVLW  00
07C3C:  ADDWFC xA2,W
07C3E:  MOVWF  03
07C40:  MOVF   01,W
07C42:  ADDLW  08
07C44:  MOVWF  01
07C46:  MOVLW  02
07C48:  ADDWFC 03,F
07C4A:  MOVFF  01,6A1
07C4E:  MOVFF  03,6A2
07C52:  MOVFF  03,6A5
07C56:  MOVFF  01,6A4
07C5A:  CLRF   xA7
07C5C:  CLRF   xA6
07C5E:  MOVLB  0
07C60:  CALL   68E0
07C64:  MOVFF  03,6A0
07C68:  MOVFF  02,69F
07C6C:  MOVFF  01,69E
07C70:  MOVFF  00,69D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
07C74:  MOVLB  6
07C76:  MOVF   x9C,W
07C78:  SUBLW  30
07C7A:  BNZ   7CA6
07C7C:  MOVLW  01
07C7E:  SUBWF  x9B,W
07C80:  MULLW  18
07C82:  MOVF   FF3,W
07C84:  CLRF   xA2
07C86:  MOVWF  xA1
07C88:  MOVLW  82
07C8A:  ADDWF  xA1,W
07C8C:  MOVWF  FE9
07C8E:  MOVLW  00
07C90:  ADDWFC xA2,W
07C92:  MOVWF  FEA
07C94:  MOVFF  69D,FEF
07C98:  MOVFF  69E,FEC
07C9C:  MOVFF  69F,FEC
07CA0:  MOVFF  6A0,FEC
07CA4:  BRA    7DDC
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
07CA6:  MOVF   x9C,W
07CA8:  SUBLW  31
07CAA:  BNZ   7CE2
07CAC:  MOVLW  01
07CAE:  SUBWF  x9B,W
07CB0:  MULLW  18
07CB2:  MOVF   FF3,W
07CB4:  CLRF   xA2
07CB6:  MOVWF  xA1
07CB8:  MOVLW  04
07CBA:  ADDWF  xA1,W
07CBC:  MOVWF  01
07CBE:  MOVLW  00
07CC0:  ADDWFC xA2,W
07CC2:  MOVWF  03
07CC4:  MOVF   01,W
07CC6:  ADDLW  82
07CC8:  MOVWF  FE9
07CCA:  MOVLW  00
07CCC:  ADDWFC 03,W
07CCE:  MOVWF  FEA
07CD0:  MOVFF  69D,FEF
07CD4:  MOVFF  69E,FEC
07CD8:  MOVFF  69F,FEC
07CDC:  MOVFF  6A0,FEC
07CE0:  BRA    7DDC
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
07CE2:  MOVF   x9C,W
07CE4:  SUBLW  32
07CE6:  BNZ   7D1E
07CE8:  MOVLW  01
07CEA:  SUBWF  x9B,W
07CEC:  MULLW  18
07CEE:  MOVF   FF3,W
07CF0:  CLRF   xA2
07CF2:  MOVWF  xA1
07CF4:  MOVLW  08
07CF6:  ADDWF  xA1,W
07CF8:  MOVWF  01
07CFA:  MOVLW  00
07CFC:  ADDWFC xA2,W
07CFE:  MOVWF  03
07D00:  MOVF   01,W
07D02:  ADDLW  82
07D04:  MOVWF  FE9
07D06:  MOVLW  00
07D08:  ADDWFC 03,W
07D0A:  MOVWF  FEA
07D0C:  MOVFF  69D,FEF
07D10:  MOVFF  69E,FEC
07D14:  MOVFF  69F,FEC
07D18:  MOVFF  6A0,FEC
07D1C:  BRA    7DDC
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
07D1E:  MOVF   x9C,W
07D20:  SUBLW  33
07D22:  BNZ   7D5A
07D24:  MOVLW  01
07D26:  SUBWF  x9B,W
07D28:  MULLW  18
07D2A:  MOVF   FF3,W
07D2C:  CLRF   xA2
07D2E:  MOVWF  xA1
07D30:  MOVLW  0C
07D32:  ADDWF  xA1,W
07D34:  MOVWF  01
07D36:  MOVLW  00
07D38:  ADDWFC xA2,W
07D3A:  MOVWF  03
07D3C:  MOVF   01,W
07D3E:  ADDLW  82
07D40:  MOVWF  FE9
07D42:  MOVLW  00
07D44:  ADDWFC 03,W
07D46:  MOVWF  FEA
07D48:  MOVFF  69D,FEF
07D4C:  MOVFF  69E,FEC
07D50:  MOVFF  69F,FEC
07D54:  MOVFF  6A0,FEC
07D58:  BRA    7DDC
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
07D5A:  MOVF   x9C,W
07D5C:  SUBLW  34
07D5E:  BNZ   7D96
07D60:  MOVLW  01
07D62:  SUBWF  x9B,W
07D64:  MULLW  18
07D66:  MOVF   FF3,W
07D68:  CLRF   xA2
07D6A:  MOVWF  xA1
07D6C:  MOVLW  10
07D6E:  ADDWF  xA1,W
07D70:  MOVWF  01
07D72:  MOVLW  00
07D74:  ADDWFC xA2,W
07D76:  MOVWF  03
07D78:  MOVF   01,W
07D7A:  ADDLW  82
07D7C:  MOVWF  FE9
07D7E:  MOVLW  00
07D80:  ADDWFC 03,W
07D82:  MOVWF  FEA
07D84:  MOVFF  69D,FEF
07D88:  MOVFF  69E,FEC
07D8C:  MOVFF  69F,FEC
07D90:  MOVFF  6A0,FEC
07D94:  BRA    7DDC
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
07D96:  MOVF   x9C,W
07D98:  SUBLW  35
07D9A:  BNZ   7DD2
07D9C:  MOVLW  01
07D9E:  SUBWF  x9B,W
07DA0:  MULLW  18
07DA2:  MOVF   FF3,W
07DA4:  CLRF   xA2
07DA6:  MOVWF  xA1
07DA8:  MOVLW  14
07DAA:  ADDWF  xA1,W
07DAC:  MOVWF  01
07DAE:  MOVLW  00
07DB0:  ADDWFC xA2,W
07DB2:  MOVWF  03
07DB4:  MOVF   01,W
07DB6:  ADDLW  82
07DB8:  MOVWF  FE9
07DBA:  MOVLW  00
07DBC:  ADDWFC 03,W
07DBE:  MOVWF  FEA
07DC0:  MOVFF  69D,FEF
07DC4:  MOVFF  69E,FEC
07DC8:  MOVFF  69F,FEC
07DCC:  MOVFF  6A0,FEC
07DD0:  BRA    7DDC
....................    else return INV_PARAM;
07DD2:  MOVLW  02
07DD4:  MOVWF  01
07DD6:  MOVLB  0
07DD8:  BRA    7DE2
07DDA:  MOVLB  6
....................    
....................    return SUCCESS;
07DDC:  MOVLW  00
07DDE:  MOVWF  01
07DE0:  MOVLB  0
07DE2:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
07DE4:  MOVLW  4E
07DE6:  MOVLB  6
07DE8:  MOVWF  x9F
07DEA:  MOVLW  31
07DEC:  MOVWF  xA0
07DEE:  MOVLW  35
07DF0:  MOVWF  xA1
07DF2:  CLRF   xA2
07DF4:  MOVLW  06
07DF6:  MOVWF  x9E
07DF8:  MOVLW  9F
07DFA:  MOVWF  x9D
....................    char *s_200 = "200";
07DFC:  MOVLW  32
07DFE:  MOVWF  xA5
07E00:  MOVLW  30
07E02:  MOVWF  xA6
07E04:  MOVWF  xA7
07E06:  CLRF   xA8
07E08:  MOVLW  06
07E0A:  MOVWF  xA4
07E0C:  MOVLW  A5
07E0E:  MOVWF  xA3
....................    char *s_5V6 = "5V6";
07E10:  MOVLW  35
07E12:  MOVWF  xAB
07E14:  MOVLW  56
07E16:  MOVWF  xAC
07E18:  MOVLW  36
07E1A:  MOVWF  xAD
07E1C:  CLRF   xAE
07E1E:  MOVLW  06
07E20:  MOVWF  xAA
07E22:  MOVLW  AB
07E24:  MOVWF  xA9
....................    char *s_5VA = "5VA";
07E26:  MOVLW  35
07E28:  MOVWF  xB1
07E2A:  MOVLW  56
07E2C:  MOVWF  xB2
07E2E:  MOVLW  41
07E30:  MOVWF  xB3
07E32:  CLRF   xB4
07E34:  MOVLW  06
07E36:  MOVWF  xB0
07E38:  MOVLW  B1
07E3A:  MOVWF  xAF
....................    char *s_3V6X = "3V6X";
07E3C:  MOVLW  33
07E3E:  MOVWF  xB7
07E40:  MOVLW  56
07E42:  MOVWF  xB8
07E44:  MOVLW  36
07E46:  MOVWF  xB9
07E48:  MOVLW  58
07E4A:  MOVWF  xBA
07E4C:  CLRF   xBB
07E4E:  MOVLW  06
07E50:  MOVWF  xB6
07E52:  MOVLW  B7
07E54:  MOVWF  xB5
....................    char *s_3V3A = "3V3A";
07E56:  MOVLW  33
07E58:  MOVWF  xBE
07E5A:  MOVLW  56
07E5C:  MOVWF  xBF
07E5E:  MOVLW  33
07E60:  MOVWF  xC0
07E62:  MOVLW  41
07E64:  MOVWF  xC1
07E66:  CLRF   xC2
07E68:  MOVLW  06
07E6A:  MOVWF  xBD
07E6C:  MOVLW  BE
07E6E:  MOVWF  xBC
....................    char *s_3V3D = "3V3D";
07E70:  MOVLW  33
07E72:  MOVWF  xC5
07E74:  MOVLW  56
07E76:  MOVWF  xC6
07E78:  MOVLW  33
07E7A:  MOVWF  xC7
07E7C:  MOVLW  44
07E7E:  MOVWF  xC8
07E80:  CLRF   xC9
07E82:  MOVLW  06
07E84:  MOVWF  xC4
07E86:  MOVLW  C5
07E88:  MOVWF  xC3
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
07E8A:  CLRF   xD2
07E8C:  MOVFF  68F,6D1
07E90:  CLRF   xD4
07E92:  MOVLW  B5
07E94:  MOVWF  xD3
07E96:  MOVLB  0
07E98:  CALL   0C04
07E9C:  MOVFF  02,6CB
07EA0:  MOVFF  01,6CA
07EA4:  MOVLW  06
07EA6:  MOVLB  6
07EA8:  ADDWF  xCA,F
07EAA:  MOVLW  00
07EAC:  ADDWFC xCB,F
07EAE:  MOVLW  32
07EB0:  ADDWF  xCA,W
07EB2:  MOVWF  01
07EB4:  MOVLW  00
07EB6:  ADDWFC xCB,W
07EB8:  MOVWF  03
07EBA:  MOVF   01,W
07EBC:  ADDLW  08
07EBE:  MOVWF  01
07EC0:  MOVLW  02
07EC2:  ADDWFC 03,F
07EC4:  MOVFF  01,69B
07EC8:  MOVFF  03,69C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
07ECC:  MOVFF  69E,6D2
07ED0:  MOVFF  69D,6D1
07ED4:  MOVFF  69C,6D4
07ED8:  MOVFF  69B,6D3
07EDC:  MOVLB  0
07EDE:  CALL   5466
07EE2:  MOVF   01,F
07EE4:  BNZ   7F68
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
07EE6:  MOVLW  04
07EE8:  MOVLB  6
07EEA:  MOVWF  xD2
07EEC:  MOVLW  DE
07EEE:  MOVWF  xD1
07EF0:  MOVLB  0
07EF2:  CALL   542E
07EF6:  MOVFF  02,03
07EFA:  MOVF   01,W
07EFC:  ADDLW  DE
07EFE:  MOVLB  6
07F00:  MOVWF  xCA
07F02:  MOVLW  04
07F04:  ADDWFC 02,W
07F06:  MOVWF  xCB
07F08:  MOVFF  FE8,583
07F0C:  MOVFF  6CA,582
07F10:  MOVLW  89
07F12:  MOVWF  FE9
07F14:  MOVFF  B5,6D6
07F18:  MOVFF  B4,6D5
07F1C:  MOVFF  B3,6D4
07F20:  MOVFF  B2,6D3
07F24:  MOVLW  02
07F26:  MOVWF  xD7
07F28:  MOVLB  0
07F2A:  CALL   61B2
07F2E:  MOVLW  2C
07F30:  MOVLB  6
07F32:  MOVWF  xE0
07F34:  MOVLB  0
07F36:  CALL   54DE
07F3A:  MOVLW  89
07F3C:  MOVWF  FE9
07F3E:  MOVFF  B9,6D6
07F42:  MOVFF  B8,6D5
07F46:  MOVFF  B7,6D4
07F4A:  MOVFF  B6,6D3
07F4E:  MOVLW  02
07F50:  MOVLB  6
07F52:  MOVWF  xD7
07F54:  MOVLB  0
07F56:  CALL   61B2
07F5A:  MOVLW  2C
07F5C:  MOVLB  6
07F5E:  MOVWF  xE0
07F60:  MOVLB  0
07F62:  CALL   54DE
....................    }
07F66:  BRA    830A
....................    else if (0 == strcmp(s_200, arg1)) {
07F68:  MOVFF  6A4,6D2
07F6C:  MOVFF  6A3,6D1
07F70:  MOVFF  69C,6D4
07F74:  MOVFF  69B,6D3
07F78:  CALL   5466
07F7C:  MOVF   01,F
07F7E:  BNZ   8002
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
07F80:  MOVLW  04
07F82:  MOVLB  6
07F84:  MOVWF  xD2
07F86:  MOVLW  DE
07F88:  MOVWF  xD1
07F8A:  MOVLB  0
07F8C:  CALL   542E
07F90:  MOVFF  02,03
07F94:  MOVF   01,W
07F96:  ADDLW  DE
07F98:  MOVLB  6
07F9A:  MOVWF  xCA
07F9C:  MOVLW  04
07F9E:  ADDWFC 02,W
07FA0:  MOVWF  xCB
07FA2:  MOVFF  FE8,583
07FA6:  MOVFF  6CA,582
07FAA:  MOVLW  89
07FAC:  MOVWF  FE9
07FAE:  MOVFF  BD,6D6
07FB2:  MOVFF  BC,6D5
07FB6:  MOVFF  BB,6D4
07FBA:  MOVFF  BA,6D3
07FBE:  MOVLW  02
07FC0:  MOVWF  xD7
07FC2:  MOVLB  0
07FC4:  CALL   61B2
07FC8:  MOVLW  2C
07FCA:  MOVLB  6
07FCC:  MOVWF  xE0
07FCE:  MOVLB  0
07FD0:  CALL   54DE
07FD4:  MOVLW  89
07FD6:  MOVWF  FE9
07FD8:  MOVFF  C1,6D6
07FDC:  MOVFF  C0,6D5
07FE0:  MOVFF  BF,6D4
07FE4:  MOVFF  BE,6D3
07FE8:  MOVLW  02
07FEA:  MOVLB  6
07FEC:  MOVWF  xD7
07FEE:  MOVLB  0
07FF0:  CALL   61B2
07FF4:  MOVLW  2C
07FF6:  MOVLB  6
07FF8:  MOVWF  xE0
07FFA:  MOVLB  0
07FFC:  CALL   54DE
....................    }
08000:  BRA    830A
....................    else if (0 == strcmp(s_5V6, arg1)) {
08002:  MOVFF  6AA,6D2
08006:  MOVFF  6A9,6D1
0800A:  MOVFF  69C,6D4
0800E:  MOVFF  69B,6D3
08012:  CALL   5466
08016:  MOVF   01,F
08018:  BNZ   809C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
0801A:  MOVLW  04
0801C:  MOVLB  6
0801E:  MOVWF  xD2
08020:  MOVLW  DE
08022:  MOVWF  xD1
08024:  MOVLB  0
08026:  CALL   542E
0802A:  MOVFF  02,03
0802E:  MOVF   01,W
08030:  ADDLW  DE
08032:  MOVLB  6
08034:  MOVWF  xCA
08036:  MOVLW  04
08038:  ADDWFC 02,W
0803A:  MOVWF  xCB
0803C:  MOVFF  FE8,583
08040:  MOVFF  6CA,582
08044:  MOVLW  89
08046:  MOVWF  FE9
08048:  MOVFF  C5,6D6
0804C:  MOVFF  C4,6D5
08050:  MOVFF  C3,6D4
08054:  MOVFF  C2,6D3
08058:  MOVLW  02
0805A:  MOVWF  xD7
0805C:  MOVLB  0
0805E:  CALL   61B2
08062:  MOVLW  2C
08064:  MOVLB  6
08066:  MOVWF  xE0
08068:  MOVLB  0
0806A:  CALL   54DE
0806E:  MOVLW  89
08070:  MOVWF  FE9
08072:  MOVFF  C9,6D6
08076:  MOVFF  C8,6D5
0807A:  MOVFF  C7,6D4
0807E:  MOVFF  C6,6D3
08082:  MOVLW  02
08084:  MOVLB  6
08086:  MOVWF  xD7
08088:  MOVLB  0
0808A:  CALL   61B2
0808E:  MOVLW  2C
08090:  MOVLB  6
08092:  MOVWF  xE0
08094:  MOVLB  0
08096:  CALL   54DE
....................    }
0809A:  BRA    830A
....................    else if (0 == strcmp(s_5VA, arg1)) {
0809C:  MOVFF  6B0,6D2
080A0:  MOVFF  6AF,6D1
080A4:  MOVFF  69C,6D4
080A8:  MOVFF  69B,6D3
080AC:  CALL   5466
080B0:  MOVF   01,F
080B2:  BNZ   8136
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
080B4:  MOVLW  04
080B6:  MOVLB  6
080B8:  MOVWF  xD2
080BA:  MOVLW  DE
080BC:  MOVWF  xD1
080BE:  MOVLB  0
080C0:  CALL   542E
080C4:  MOVFF  02,03
080C8:  MOVF   01,W
080CA:  ADDLW  DE
080CC:  MOVLB  6
080CE:  MOVWF  xCA
080D0:  MOVLW  04
080D2:  ADDWFC 02,W
080D4:  MOVWF  xCB
080D6:  MOVFF  FE8,583
080DA:  MOVFF  6CA,582
080DE:  MOVLW  89
080E0:  MOVWF  FE9
080E2:  MOVFF  CD,6D6
080E6:  MOVFF  CC,6D5
080EA:  MOVFF  CB,6D4
080EE:  MOVFF  CA,6D3
080F2:  MOVLW  02
080F4:  MOVWF  xD7
080F6:  MOVLB  0
080F8:  CALL   61B2
080FC:  MOVLW  2C
080FE:  MOVLB  6
08100:  MOVWF  xE0
08102:  MOVLB  0
08104:  CALL   54DE
08108:  MOVLW  89
0810A:  MOVWF  FE9
0810C:  MOVFF  D1,6D6
08110:  MOVFF  D0,6D5
08114:  MOVFF  CF,6D4
08118:  MOVFF  CE,6D3
0811C:  MOVLW  02
0811E:  MOVLB  6
08120:  MOVWF  xD7
08122:  MOVLB  0
08124:  CALL   61B2
08128:  MOVLW  2C
0812A:  MOVLB  6
0812C:  MOVWF  xE0
0812E:  MOVLB  0
08130:  CALL   54DE
....................    }
08134:  BRA    830A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08136:  MOVFF  6B6,6D2
0813A:  MOVFF  6B5,6D1
0813E:  MOVFF  69C,6D4
08142:  MOVFF  69B,6D3
08146:  CALL   5466
0814A:  MOVF   01,F
0814C:  BNZ   81D0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
0814E:  MOVLW  04
08150:  MOVLB  6
08152:  MOVWF  xD2
08154:  MOVLW  DE
08156:  MOVWF  xD1
08158:  MOVLB  0
0815A:  CALL   542E
0815E:  MOVFF  02,03
08162:  MOVF   01,W
08164:  ADDLW  DE
08166:  MOVLB  6
08168:  MOVWF  xCA
0816A:  MOVLW  04
0816C:  ADDWFC 02,W
0816E:  MOVWF  xCB
08170:  MOVFF  FE8,583
08174:  MOVFF  6CA,582
08178:  MOVLW  89
0817A:  MOVWF  FE9
0817C:  MOVFF  D5,6D6
08180:  MOVFF  D4,6D5
08184:  MOVFF  D3,6D4
08188:  MOVFF  D2,6D3
0818C:  MOVLW  02
0818E:  MOVWF  xD7
08190:  MOVLB  0
08192:  CALL   61B2
08196:  MOVLW  2C
08198:  MOVLB  6
0819A:  MOVWF  xE0
0819C:  MOVLB  0
0819E:  CALL   54DE
081A2:  MOVLW  89
081A4:  MOVWF  FE9
081A6:  MOVFF  D9,6D6
081AA:  MOVFF  D8,6D5
081AE:  MOVFF  D7,6D4
081B2:  MOVFF  D6,6D3
081B6:  MOVLW  02
081B8:  MOVLB  6
081BA:  MOVWF  xD7
081BC:  MOVLB  0
081BE:  CALL   61B2
081C2:  MOVLW  2C
081C4:  MOVLB  6
081C6:  MOVWF  xE0
081C8:  MOVLB  0
081CA:  CALL   54DE
....................    }
081CE:  BRA    830A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
081D0:  MOVFF  6BD,6D2
081D4:  MOVFF  6BC,6D1
081D8:  MOVFF  69C,6D4
081DC:  MOVFF  69B,6D3
081E0:  CALL   5466
081E4:  MOVF   01,F
081E6:  BNZ   826A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
081E8:  MOVLW  04
081EA:  MOVLB  6
081EC:  MOVWF  xD2
081EE:  MOVLW  DE
081F0:  MOVWF  xD1
081F2:  MOVLB  0
081F4:  CALL   542E
081F8:  MOVFF  02,03
081FC:  MOVF   01,W
081FE:  ADDLW  DE
08200:  MOVLB  6
08202:  MOVWF  xCA
08204:  MOVLW  04
08206:  ADDWFC 02,W
08208:  MOVWF  xCB
0820A:  MOVFF  FE8,583
0820E:  MOVFF  6CA,582
08212:  MOVLW  89
08214:  MOVWF  FE9
08216:  MOVFF  DD,6D6
0821A:  MOVFF  DC,6D5
0821E:  MOVFF  DB,6D4
08222:  MOVFF  DA,6D3
08226:  MOVLW  02
08228:  MOVWF  xD7
0822A:  MOVLB  0
0822C:  CALL   61B2
08230:  MOVLW  2C
08232:  MOVLB  6
08234:  MOVWF  xE0
08236:  MOVLB  0
08238:  CALL   54DE
0823C:  MOVLW  89
0823E:  MOVWF  FE9
08240:  MOVFF  E1,6D6
08244:  MOVFF  E0,6D5
08248:  MOVFF  DF,6D4
0824C:  MOVFF  DE,6D3
08250:  MOVLW  02
08252:  MOVLB  6
08254:  MOVWF  xD7
08256:  MOVLB  0
08258:  CALL   61B2
0825C:  MOVLW  2C
0825E:  MOVLB  6
08260:  MOVWF  xE0
08262:  MOVLB  0
08264:  CALL   54DE
....................    }
08268:  BRA    830A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0826A:  MOVFF  6C4,6D2
0826E:  MOVFF  6C3,6D1
08272:  MOVFF  69C,6D4
08276:  MOVFF  69B,6D3
0827A:  CALL   5466
0827E:  MOVF   01,F
08280:  BNZ   8304
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08282:  MOVLW  04
08284:  MOVLB  6
08286:  MOVWF  xD2
08288:  MOVLW  DE
0828A:  MOVWF  xD1
0828C:  MOVLB  0
0828E:  CALL   542E
08292:  MOVFF  02,03
08296:  MOVF   01,W
08298:  ADDLW  DE
0829A:  MOVLB  6
0829C:  MOVWF  xCA
0829E:  MOVLW  04
082A0:  ADDWFC 02,W
082A2:  MOVWF  xCB
082A4:  MOVFF  FE8,583
082A8:  MOVFF  6CA,582
082AC:  MOVLW  89
082AE:  MOVWF  FE9
082B0:  MOVFF  E5,6D6
082B4:  MOVFF  E4,6D5
082B8:  MOVFF  E3,6D4
082BC:  MOVFF  E2,6D3
082C0:  MOVLW  02
082C2:  MOVWF  xD7
082C4:  MOVLB  0
082C6:  CALL   61B2
082CA:  MOVLW  2C
082CC:  MOVLB  6
082CE:  MOVWF  xE0
082D0:  MOVLB  0
082D2:  CALL   54DE
082D6:  MOVLW  89
082D8:  MOVWF  FE9
082DA:  MOVFF  E9,6D6
082DE:  MOVFF  E8,6D5
082E2:  MOVFF  E7,6D4
082E6:  MOVFF  E6,6D3
082EA:  MOVLW  02
082EC:  MOVLB  6
082EE:  MOVWF  xD7
082F0:  MOVLB  0
082F2:  CALL   61B2
082F6:  MOVLW  2C
082F8:  MOVLB  6
082FA:  MOVWF  xE0
082FC:  MOVLB  0
082FE:  CALL   54DE
....................    }
08302:  BRA    830A
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
08304:  MOVLW  02
08306:  MOVWF  01
08308:  BRA    830E
....................    
....................    return SUCCESS;
0830A:  MOVLW  00
0830C:  MOVWF  01
0830E:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
08310:  MOVLW  00
08312:  MOVWF  01
08314:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08316:  MOVLW  4E
08318:  MOVLB  6
0831A:  MOVWF  x9F
0831C:  MOVLW  31
0831E:  MOVWF  xA0
08320:  MOVLW  35
08322:  MOVWF  xA1
08324:  CLRF   xA2
08326:  MOVLW  06
08328:  MOVWF  x9E
0832A:  MOVLW  9F
0832C:  MOVWF  x9D
....................    char *s_200 = "200";
0832E:  MOVLW  32
08330:  MOVWF  xA5
08332:  MOVLW  30
08334:  MOVWF  xA6
08336:  MOVWF  xA7
08338:  CLRF   xA8
0833A:  MOVLW  06
0833C:  MOVWF  xA4
0833E:  MOVLW  A5
08340:  MOVWF  xA3
....................    char *s_5V6 = "5V6";
08342:  MOVLW  35
08344:  MOVWF  xAB
08346:  MOVLW  56
08348:  MOVWF  xAC
0834A:  MOVLW  36
0834C:  MOVWF  xAD
0834E:  CLRF   xAE
08350:  MOVLW  06
08352:  MOVWF  xAA
08354:  MOVLW  AB
08356:  MOVWF  xA9
....................    char *s_5VA = "5VA";
08358:  MOVLW  35
0835A:  MOVWF  xB1
0835C:  MOVLW  56
0835E:  MOVWF  xB2
08360:  MOVLW  41
08362:  MOVWF  xB3
08364:  CLRF   xB4
08366:  MOVLW  06
08368:  MOVWF  xB0
0836A:  MOVLW  B1
0836C:  MOVWF  xAF
....................    char *s_3V6X = "3V6X";
0836E:  MOVLW  33
08370:  MOVWF  xB7
08372:  MOVLW  56
08374:  MOVWF  xB8
08376:  MOVLW  36
08378:  MOVWF  xB9
0837A:  MOVLW  58
0837C:  MOVWF  xBA
0837E:  CLRF   xBB
08380:  MOVLW  06
08382:  MOVWF  xB6
08384:  MOVLW  B7
08386:  MOVWF  xB5
....................    char *s_3V3A = "3V3A";
08388:  MOVLW  33
0838A:  MOVWF  xBE
0838C:  MOVLW  56
0838E:  MOVWF  xBF
08390:  MOVLW  33
08392:  MOVWF  xC0
08394:  MOVLW  41
08396:  MOVWF  xC1
08398:  CLRF   xC2
0839A:  MOVLW  06
0839C:  MOVWF  xBD
0839E:  MOVLW  BE
083A0:  MOVWF  xBC
....................    char *s_3V3D = "3V3D";
083A2:  MOVLW  33
083A4:  MOVWF  xC5
083A6:  MOVLW  56
083A8:  MOVWF  xC6
083AA:  MOVLW  33
083AC:  MOVWF  xC7
083AE:  MOVLW  44
083B0:  MOVWF  xC8
083B2:  CLRF   xC9
083B4:  MOVLW  06
083B6:  MOVWF  xC4
083B8:  MOVLW  C5
083BA:  MOVWF  xC3
....................    char *s_all = "all";
083BC:  MOVLW  61
083BE:  MOVWF  xCC
083C0:  MOVLW  6C
083C2:  MOVWF  xCD
083C4:  MOVWF  xCE
083C6:  CLRF   xCF
083C8:  MOVLW  06
083CA:  MOVWF  xCB
083CC:  MOVLW  CC
083CE:  MOVWF  xCA
....................    
....................    arg1 = SERcmd[rec].p[2];
083D0:  CLRF   xD2
083D2:  MOVFF  68F,6D1
083D6:  CLRF   xD4
083D8:  MOVLW  B5
083DA:  MOVWF  xD3
083DC:  MOVLB  0
083DE:  CALL   0C04
083E2:  MOVFF  02,6D1
083E6:  MOVFF  01,6D0
083EA:  MOVLW  06
083EC:  MOVLB  6
083EE:  ADDWF  xD0,F
083F0:  MOVLW  00
083F2:  ADDWFC xD1,F
083F4:  MOVLW  32
083F6:  ADDWF  xD0,W
083F8:  MOVWF  01
083FA:  MOVLW  00
083FC:  ADDWFC xD1,W
083FE:  MOVWF  03
08400:  MOVF   01,W
08402:  ADDLW  08
08404:  MOVWF  01
08406:  MOVLW  02
08408:  ADDWFC 03,F
0840A:  MOVFF  01,69B
0840E:  MOVFF  03,69C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08412:  MOVFF  69E,6D2
08416:  MOVFF  69D,6D1
0841A:  MOVFF  69C,6D4
0841E:  MOVFF  69B,6D3
08422:  MOVLB  0
08424:  CALL   5466
08428:  MOVF   01,F
0842A:  BNZ   8482
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0842C:  MOVLW  04
0842E:  MOVLB  6
08430:  MOVWF  xD2
08432:  MOVLW  DE
08434:  MOVWF  xD1
08436:  MOVLB  0
08438:  CALL   542E
0843C:  MOVFF  02,03
08440:  MOVF   01,W
08442:  ADDLW  DE
08444:  MOVLB  6
08446:  MOVWF  xD0
08448:  MOVLW  04
0844A:  ADDWFC 02,W
0844C:  MOVWF  xD1
0844E:  MOVFF  FE8,583
08452:  MOVFF  6D0,582
08456:  MOVLW  89
08458:  MOVWF  FE9
0845A:  MOVFF  F6,6D6
0845E:  MOVFF  F5,6D5
08462:  MOVFF  F4,6D4
08466:  MOVFF  F3,6D3
0846A:  MOVLW  02
0846C:  MOVWF  xD7
0846E:  MOVLB  0
08470:  CALL   61B2
08474:  MOVLW  2C
08476:  MOVLB  6
08478:  MOVWF  xE0
0847A:  MOVLB  0
0847C:  CALL   54DE
....................    }
08480:  BRA    8984
....................    else if (0 == strcmp(s_200, arg1)) {
08482:  MOVFF  6A4,6D2
08486:  MOVFF  6A3,6D1
0848A:  MOVFF  69C,6D4
0848E:  MOVFF  69B,6D3
08492:  CALL   5466
08496:  MOVF   01,F
08498:  BNZ   84F0
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
0849A:  MOVLW  04
0849C:  MOVLB  6
0849E:  MOVWF  xD2
084A0:  MOVLW  DE
084A2:  MOVWF  xD1
084A4:  MOVLB  0
084A6:  CALL   542E
084AA:  MOVFF  02,03
084AE:  MOVF   01,W
084B0:  ADDLW  DE
084B2:  MOVLB  6
084B4:  MOVWF  xD0
084B6:  MOVLW  04
084B8:  ADDWFC 02,W
084BA:  MOVWF  xD1
084BC:  MOVFF  FE8,583
084C0:  MOVFF  6D0,582
084C4:  MOVLW  89
084C6:  MOVWF  FE9
084C8:  MOVFF  FA,6D6
084CC:  MOVFF  F9,6D5
084D0:  MOVFF  F8,6D4
084D4:  MOVFF  F7,6D3
084D8:  MOVLW  01
084DA:  MOVWF  xD7
084DC:  MOVLB  0
084DE:  CALL   61B2
084E2:  MOVLW  2C
084E4:  MOVLB  6
084E6:  MOVWF  xE0
084E8:  MOVLB  0
084EA:  CALL   54DE
....................    }
084EE:  BRA    8984
....................    else if (0 == strcmp(s_5V6, arg1)) {
084F0:  MOVFF  6AA,6D2
084F4:  MOVFF  6A9,6D1
084F8:  MOVFF  69C,6D4
084FC:  MOVFF  69B,6D3
08500:  CALL   5466
08504:  MOVF   01,F
08506:  BNZ   855E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08508:  MOVLW  04
0850A:  MOVLB  6
0850C:  MOVWF  xD2
0850E:  MOVLW  DE
08510:  MOVWF  xD1
08512:  MOVLB  0
08514:  CALL   542E
08518:  MOVFF  02,03
0851C:  MOVF   01,W
0851E:  ADDLW  DE
08520:  MOVLB  6
08522:  MOVWF  xD0
08524:  MOVLW  04
08526:  ADDWFC 02,W
08528:  MOVWF  xD1
0852A:  MOVFF  FE8,583
0852E:  MOVFF  6D0,582
08532:  MOVLW  89
08534:  MOVWF  FE9
08536:  MOVFF  FE,6D6
0853A:  MOVFF  FD,6D5
0853E:  MOVFF  FC,6D4
08542:  MOVFF  FB,6D3
08546:  MOVLW  03
08548:  MOVWF  xD7
0854A:  MOVLB  0
0854C:  CALL   61B2
08550:  MOVLW  2C
08552:  MOVLB  6
08554:  MOVWF  xE0
08556:  MOVLB  0
08558:  CALL   54DE
....................    }
0855C:  BRA    8984
....................    else if (0 == strcmp(s_5VA, arg1)) {
0855E:  MOVFF  6B0,6D2
08562:  MOVFF  6AF,6D1
08566:  MOVFF  69C,6D4
0856A:  MOVFF  69B,6D3
0856E:  CALL   5466
08572:  MOVF   01,F
08574:  BNZ   85CC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08576:  MOVLW  04
08578:  MOVLB  6
0857A:  MOVWF  xD2
0857C:  MOVLW  DE
0857E:  MOVWF  xD1
08580:  MOVLB  0
08582:  CALL   542E
08586:  MOVFF  02,03
0858A:  MOVF   01,W
0858C:  ADDLW  DE
0858E:  MOVLB  6
08590:  MOVWF  xD0
08592:  MOVLW  04
08594:  ADDWFC 02,W
08596:  MOVWF  xD1
08598:  MOVFF  FE8,583
0859C:  MOVFF  6D0,582
085A0:  MOVLW  89
085A2:  MOVWF  FE9
085A4:  MOVFF  102,6D6
085A8:  MOVFF  101,6D5
085AC:  MOVFF  100,6D4
085B0:  MOVFF  FF,6D3
085B4:  MOVLW  03
085B6:  MOVWF  xD7
085B8:  MOVLB  0
085BA:  CALL   61B2
085BE:  MOVLW  2C
085C0:  MOVLB  6
085C2:  MOVWF  xE0
085C4:  MOVLB  0
085C6:  CALL   54DE
....................    }
085CA:  BRA    8984
....................    else if (0 == strcmp(s_3V6X, arg1)) {
085CC:  MOVFF  6B6,6D2
085D0:  MOVFF  6B5,6D1
085D4:  MOVFF  69C,6D4
085D8:  MOVFF  69B,6D3
085DC:  CALL   5466
085E0:  MOVF   01,F
085E2:  BNZ   863A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
085E4:  MOVLW  04
085E6:  MOVLB  6
085E8:  MOVWF  xD2
085EA:  MOVLW  DE
085EC:  MOVWF  xD1
085EE:  MOVLB  0
085F0:  CALL   542E
085F4:  MOVFF  02,03
085F8:  MOVF   01,W
085FA:  ADDLW  DE
085FC:  MOVLB  6
085FE:  MOVWF  xD0
08600:  MOVLW  04
08602:  ADDWFC 02,W
08604:  MOVWF  xD1
08606:  MOVFF  FE8,583
0860A:  MOVFF  6D0,582
0860E:  MOVLW  89
08610:  MOVWF  FE9
08612:  MOVFF  106,6D6
08616:  MOVFF  105,6D5
0861A:  MOVFF  104,6D4
0861E:  MOVFF  103,6D3
08622:  MOVLW  03
08624:  MOVWF  xD7
08626:  MOVLB  0
08628:  CALL   61B2
0862C:  MOVLW  2C
0862E:  MOVLB  6
08630:  MOVWF  xE0
08632:  MOVLB  0
08634:  CALL   54DE
....................    }
08638:  BRA    8984
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0863A:  MOVFF  6BD,6D2
0863E:  MOVFF  6BC,6D1
08642:  MOVFF  69C,6D4
08646:  MOVFF  69B,6D3
0864A:  CALL   5466
0864E:  MOVF   01,F
08650:  BNZ   86A8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08652:  MOVLW  04
08654:  MOVLB  6
08656:  MOVWF  xD2
08658:  MOVLW  DE
0865A:  MOVWF  xD1
0865C:  MOVLB  0
0865E:  CALL   542E
08662:  MOVFF  02,03
08666:  MOVF   01,W
08668:  ADDLW  DE
0866A:  MOVLB  6
0866C:  MOVWF  xD0
0866E:  MOVLW  04
08670:  ADDWFC 02,W
08672:  MOVWF  xD1
08674:  MOVFF  FE8,583
08678:  MOVFF  6D0,582
0867C:  MOVLW  89
0867E:  MOVWF  FE9
08680:  MOVFF  10A,6D6
08684:  MOVFF  109,6D5
08688:  MOVFF  108,6D4
0868C:  MOVFF  107,6D3
08690:  MOVLW  03
08692:  MOVWF  xD7
08694:  MOVLB  0
08696:  CALL   61B2
0869A:  MOVLW  2C
0869C:  MOVLB  6
0869E:  MOVWF  xE0
086A0:  MOVLB  0
086A2:  CALL   54DE
....................    }
086A6:  BRA    8984
....................    else if (0 == strcmp(s_3V3D, arg1)) {
086A8:  MOVFF  6C4,6D2
086AC:  MOVFF  6C3,6D1
086B0:  MOVFF  69C,6D4
086B4:  MOVFF  69B,6D3
086B8:  CALL   5466
086BC:  MOVF   01,F
086BE:  BNZ   8716
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
086C0:  MOVLW  04
086C2:  MOVLB  6
086C4:  MOVWF  xD2
086C6:  MOVLW  DE
086C8:  MOVWF  xD1
086CA:  MOVLB  0
086CC:  CALL   542E
086D0:  MOVFF  02,03
086D4:  MOVF   01,W
086D6:  ADDLW  DE
086D8:  MOVLB  6
086DA:  MOVWF  xD0
086DC:  MOVLW  04
086DE:  ADDWFC 02,W
086E0:  MOVWF  xD1
086E2:  MOVFF  FE8,583
086E6:  MOVFF  6D0,582
086EA:  MOVLW  89
086EC:  MOVWF  FE9
086EE:  MOVFF  10E,6D6
086F2:  MOVFF  10D,6D5
086F6:  MOVFF  10C,6D4
086FA:  MOVFF  10B,6D3
086FE:  MOVLW  03
08700:  MOVWF  xD7
08702:  MOVLB  0
08704:  CALL   61B2
08708:  MOVLW  2C
0870A:  MOVLB  6
0870C:  MOVWF  xE0
0870E:  MOVLB  0
08710:  CALL   54DE
....................    }
08714:  BRA    8984
....................    else if (0 == strcmp(s_all, arg1)) {
08716:  MOVFF  6CB,6D2
0871A:  MOVFF  6CA,6D1
0871E:  MOVFF  69C,6D4
08722:  MOVFF  69B,6D3
08726:  CALL   5466
0872A:  MOVF   01,F
0872C:  BTFSS  FD8.2
0872E:  BRA    897E
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08730:  MOVLW  04
08732:  MOVLB  6
08734:  MOVWF  xD2
08736:  MOVLW  DE
08738:  MOVWF  xD1
0873A:  MOVLB  0
0873C:  CALL   542E
08740:  MOVFF  02,03
08744:  MOVF   01,W
08746:  ADDLW  DE
08748:  MOVLB  6
0874A:  MOVWF  xD0
0874C:  MOVLW  04
0874E:  ADDWFC 02,W
08750:  MOVWF  xD1
08752:  MOVFF  FE8,583
08756:  MOVFF  6D0,582
0875A:  MOVLW  89
0875C:  MOVWF  FE9
0875E:  MOVFF  F6,6D6
08762:  MOVFF  F5,6D5
08766:  MOVFF  F4,6D4
0876A:  MOVFF  F3,6D3
0876E:  MOVLW  02
08770:  MOVWF  xD7
08772:  MOVLB  0
08774:  CALL   61B2
08778:  MOVLW  2C
0877A:  MOVLB  6
0877C:  MOVWF  xE0
0877E:  MOVLB  0
08780:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08784:  MOVLW  04
08786:  MOVLB  6
08788:  MOVWF  xD2
0878A:  MOVLW  DE
0878C:  MOVWF  xD1
0878E:  MOVLB  0
08790:  CALL   542E
08794:  MOVFF  02,03
08798:  MOVF   01,W
0879A:  ADDLW  DE
0879C:  MOVLB  6
0879E:  MOVWF  xD0
087A0:  MOVLW  04
087A2:  ADDWFC 02,W
087A4:  MOVWF  xD1
087A6:  MOVFF  FE8,583
087AA:  MOVFF  6D0,582
087AE:  MOVLW  89
087B0:  MOVWF  FE9
087B2:  MOVFF  FA,6D6
087B6:  MOVFF  F9,6D5
087BA:  MOVFF  F8,6D4
087BE:  MOVFF  F7,6D3
087C2:  MOVLW  01
087C4:  MOVWF  xD7
087C6:  MOVLB  0
087C8:  CALL   61B2
087CC:  MOVLW  2C
087CE:  MOVLB  6
087D0:  MOVWF  xE0
087D2:  MOVLB  0
087D4:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
087D8:  MOVLW  04
087DA:  MOVLB  6
087DC:  MOVWF  xD2
087DE:  MOVLW  DE
087E0:  MOVWF  xD1
087E2:  MOVLB  0
087E4:  CALL   542E
087E8:  MOVFF  02,03
087EC:  MOVF   01,W
087EE:  ADDLW  DE
087F0:  MOVLB  6
087F2:  MOVWF  xD0
087F4:  MOVLW  04
087F6:  ADDWFC 02,W
087F8:  MOVWF  xD1
087FA:  MOVFF  FE8,583
087FE:  MOVFF  6D0,582
08802:  MOVLW  89
08804:  MOVWF  FE9
08806:  MOVFF  FE,6D6
0880A:  MOVFF  FD,6D5
0880E:  MOVFF  FC,6D4
08812:  MOVFF  FB,6D3
08816:  MOVLW  03
08818:  MOVWF  xD7
0881A:  MOVLB  0
0881C:  CALL   61B2
08820:  MOVLW  2C
08822:  MOVLB  6
08824:  MOVWF  xE0
08826:  MOVLB  0
08828:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
0882C:  MOVLW  04
0882E:  MOVLB  6
08830:  MOVWF  xD2
08832:  MOVLW  DE
08834:  MOVWF  xD1
08836:  MOVLB  0
08838:  CALL   542E
0883C:  MOVFF  02,03
08840:  MOVF   01,W
08842:  ADDLW  DE
08844:  MOVLB  6
08846:  MOVWF  xD0
08848:  MOVLW  04
0884A:  ADDWFC 02,W
0884C:  MOVWF  xD1
0884E:  MOVFF  FE8,583
08852:  MOVFF  6D0,582
08856:  MOVLW  89
08858:  MOVWF  FE9
0885A:  MOVFF  102,6D6
0885E:  MOVFF  101,6D5
08862:  MOVFF  100,6D4
08866:  MOVFF  FF,6D3
0886A:  MOVLW  03
0886C:  MOVWF  xD7
0886E:  MOVLB  0
08870:  CALL   61B2
08874:  MOVLW  2C
08876:  MOVLB  6
08878:  MOVWF  xE0
0887A:  MOVLB  0
0887C:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08880:  MOVLW  04
08882:  MOVLB  6
08884:  MOVWF  xD2
08886:  MOVLW  DE
08888:  MOVWF  xD1
0888A:  MOVLB  0
0888C:  CALL   542E
08890:  MOVFF  02,03
08894:  MOVF   01,W
08896:  ADDLW  DE
08898:  MOVLB  6
0889A:  MOVWF  xD0
0889C:  MOVLW  04
0889E:  ADDWFC 02,W
088A0:  MOVWF  xD1
088A2:  MOVFF  FE8,583
088A6:  MOVFF  6D0,582
088AA:  MOVLW  89
088AC:  MOVWF  FE9
088AE:  MOVFF  106,6D6
088B2:  MOVFF  105,6D5
088B6:  MOVFF  104,6D4
088BA:  MOVFF  103,6D3
088BE:  MOVLW  03
088C0:  MOVWF  xD7
088C2:  MOVLB  0
088C4:  CALL   61B2
088C8:  MOVLW  2C
088CA:  MOVLB  6
088CC:  MOVWF  xE0
088CE:  MOVLB  0
088D0:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
088D4:  MOVLW  04
088D6:  MOVLB  6
088D8:  MOVWF  xD2
088DA:  MOVLW  DE
088DC:  MOVWF  xD1
088DE:  MOVLB  0
088E0:  CALL   542E
088E4:  MOVFF  02,03
088E8:  MOVF   01,W
088EA:  ADDLW  DE
088EC:  MOVLB  6
088EE:  MOVWF  xD0
088F0:  MOVLW  04
088F2:  ADDWFC 02,W
088F4:  MOVWF  xD1
088F6:  MOVFF  FE8,583
088FA:  MOVFF  6D0,582
088FE:  MOVLW  89
08900:  MOVWF  FE9
08902:  MOVFF  10A,6D6
08906:  MOVFF  109,6D5
0890A:  MOVFF  108,6D4
0890E:  MOVFF  107,6D3
08912:  MOVLW  03
08914:  MOVWF  xD7
08916:  MOVLB  0
08918:  CALL   61B2
0891C:  MOVLW  2C
0891E:  MOVLB  6
08920:  MOVWF  xE0
08922:  MOVLB  0
08924:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08928:  MOVLW  04
0892A:  MOVLB  6
0892C:  MOVWF  xD2
0892E:  MOVLW  DE
08930:  MOVWF  xD1
08932:  MOVLB  0
08934:  CALL   542E
08938:  MOVFF  02,03
0893C:  MOVF   01,W
0893E:  ADDLW  DE
08940:  MOVLB  6
08942:  MOVWF  xD0
08944:  MOVLW  04
08946:  ADDWFC 02,W
08948:  MOVWF  xD1
0894A:  MOVFF  FE8,583
0894E:  MOVFF  6D0,582
08952:  MOVLW  89
08954:  MOVWF  FE9
08956:  MOVFF  10E,6D6
0895A:  MOVFF  10D,6D5
0895E:  MOVFF  10C,6D4
08962:  MOVFF  10B,6D3
08966:  MOVLW  03
08968:  MOVWF  xD7
0896A:  MOVLB  0
0896C:  CALL   61B2
08970:  MOVLW  2C
08972:  MOVLB  6
08974:  MOVWF  xE0
08976:  MOVLB  0
08978:  CALL   54DE
....................    }
0897C:  BRA    8984
....................    else return INV_PARAM;
0897E:  MOVLW  02
08980:  MOVWF  01
08982:  BRA    8988
....................    
....................    return SUCCESS;
08984:  MOVLW  00
08986:  MOVWF  01
08988:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
0898A:  MOVLW  50
0898C:  MOVLB  6
0898E:  MOVWF  xA0
08990:  MOVLW  56
08992:  MOVWF  xA1
08994:  CLRF   xA2
08996:  MOVLW  06
08998:  MOVWF  x9F
0899A:  MOVLW  A0
0899C:  MOVWF  x9E
....................    char *s_CV = "CV";
0899E:  MOVLW  43
089A0:  MOVWF  xA5
089A2:  MOVLW  56
089A4:  MOVWF  xA6
089A6:  CLRF   xA7
089A8:  MOVLW  06
089AA:  MOVWF  xA4
089AC:  MOVLW  A5
089AE:  MOVWF  xA3
....................    char *s_PVold = "PVold";
089B0:  MOVLW  50
089B2:  MOVWF  xAA
089B4:  MOVLW  56
089B6:  MOVWF  xAB
089B8:  MOVLW  6F
089BA:  MOVWF  xAC
089BC:  MOVLW  6C
089BE:  MOVWF  xAD
089C0:  MOVLW  64
089C2:  MOVWF  xAE
089C4:  CLRF   xAF
089C6:  MOVLW  06
089C8:  MOVWF  xA9
089CA:  MOVLW  AA
089CC:  MOVWF  xA8
....................    char *s_I = "I";
089CE:  MOVLW  49
089D0:  MOVWF  xB2
089D2:  CLRF   xB3
089D4:  MOVLW  06
089D6:  MOVWF  xB1
089D8:  MOVLW  B2
089DA:  MOVWF  xB0
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
089DC:  CLRF   xD2
089DE:  MOVFF  68F,6D1
089E2:  CLRF   xD4
089E4:  MOVLW  B5
089E6:  MOVWF  xD3
089E8:  MOVLB  0
089EA:  CALL   0C04
089EE:  MOVFF  02,6B5
089F2:  MOVFF  01,6B4
089F6:  MOVLW  06
089F8:  MOVLB  6
089FA:  ADDWF  xB4,F
089FC:  MOVLW  00
089FE:  ADDWFC xB5,F
08A00:  MOVLW  32
08A02:  ADDWF  xB4,W
08A04:  MOVWF  01
08A06:  MOVLW  00
08A08:  ADDWFC xB5,W
08A0A:  MOVWF  03
08A0C:  MOVF   01,W
08A0E:  ADDLW  08
08A10:  MOVWF  01
08A12:  MOVLW  02
08A14:  ADDWFC 03,F
08A16:  MOVFF  01,6B4
08A1A:  MOVFF  03,6B5
08A1E:  MOVFF  03,6C4
08A22:  MOVFF  01,6C3
08A26:  MOVLB  0
08A28:  CALL   55A6
08A2C:  MOVF   01,F
08A2E:  BNZ   8A38
08A30:  MOVLW  02
08A32:  MOVWF  01
08A34:  BRA    8DCE
08A36:  BRA    8A96
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08A38:  MOVLB  6
08A3A:  CLRF   xD2
08A3C:  MOVFF  68F,6D1
08A40:  CLRF   xD4
08A42:  MOVLW  B5
08A44:  MOVWF  xD3
08A46:  MOVLB  0
08A48:  CALL   0C04
08A4C:  MOVFF  02,6B5
08A50:  MOVFF  01,6B4
08A54:  MOVLW  06
08A56:  MOVLB  6
08A58:  ADDWF  xB4,F
08A5A:  MOVLW  00
08A5C:  ADDWFC xB5,F
08A5E:  MOVLW  32
08A60:  ADDWF  xB4,W
08A62:  MOVWF  01
08A64:  MOVLW  00
08A66:  ADDWFC xB5,W
08A68:  MOVWF  03
08A6A:  MOVF   01,W
08A6C:  ADDLW  08
08A6E:  MOVWF  01
08A70:  MOVLW  02
08A72:  ADDWFC 03,F
08A74:  MOVFF  01,6B4
08A78:  MOVFF  03,6B5
08A7C:  MOVFF  03,6C4
08A80:  MOVFF  01,6C3
08A84:  CLRF   xC6
08A86:  CLRF   xC5
08A88:  MOVLW  0A
08A8A:  MOVWF  xC7
08A8C:  MOVLB  0
08A8E:  CALL   5640
08A92:  MOVFF  01,69B
....................    
....................    arg2 = SERcmd[rec].p[3];
08A96:  MOVLB  6
08A98:  CLRF   xD2
08A9A:  MOVFF  68F,6D1
08A9E:  CLRF   xD4
08AA0:  MOVLW  B5
08AA2:  MOVWF  xD3
08AA4:  MOVLB  0
08AA6:  CALL   0C04
08AAA:  MOVFF  02,6B5
08AAE:  MOVFF  01,6B4
08AB2:  MOVLW  06
08AB4:  MOVLB  6
08AB6:  ADDWF  xB4,F
08AB8:  MOVLW  00
08ABA:  ADDWFC xB5,F
08ABC:  MOVLW  4B
08ABE:  ADDWF  xB4,W
08AC0:  MOVWF  01
08AC2:  MOVLW  00
08AC4:  ADDWFC xB5,W
08AC6:  MOVWF  03
08AC8:  MOVF   01,W
08ACA:  ADDLW  08
08ACC:  MOVWF  01
08ACE:  MOVLW  02
08AD0:  ADDWFC 03,F
08AD2:  MOVFF  01,69C
08AD6:  MOVFF  03,69D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08ADA:  MOVFF  69F,6D2
08ADE:  MOVFF  69E,6D1
08AE2:  MOVFF  69D,6D4
08AE6:  MOVFF  69C,6D3
08AEA:  MOVLB  0
08AEC:  CALL   5466
08AF0:  MOVF   01,F
08AF2:  BNZ   8B96
08AF4:  MOVLW  04
08AF6:  MOVLB  6
08AF8:  MOVWF  xD2
08AFA:  MOVLW  DE
08AFC:  MOVWF  xD1
08AFE:  MOVLB  0
08B00:  CALL   542E
08B04:  MOVF   01,W
08B06:  ADDLW  DE
08B08:  MOVLB  6
08B0A:  MOVWF  xB4
08B0C:  MOVLW  04
08B0E:  ADDWFC 02,W
08B10:  MOVWF  xB5
08B12:  MOVLW  01
08B14:  SUBWF  x9B,W
08B16:  MULLW  20
08B18:  MOVF   FF3,W
08B1A:  CLRF   xB7
08B1C:  MOVWF  xB6
08B1E:  MOVLW  10
08B20:  ADDWF  xB6,W
08B22:  MOVWF  01
08B24:  MOVLW  00
08B26:  ADDWFC xB7,W
08B28:  MOVWF  03
08B2A:  MOVF   01,W
08B2C:  ADDLW  20
08B2E:  MOVWF  FE9
08B30:  MOVLW  00
08B32:  ADDWFC 03,W
08B34:  MOVWF  FEA
08B36:  MOVFF  FEF,6B6
08B3A:  MOVFF  FEC,6B7
08B3E:  MOVFF  FEC,6B8
08B42:  MOVFF  FEC,6B9
08B46:  MOVFF  6B5,583
08B4A:  MOVFF  6B4,582
08B4E:  MOVFF  69B,6C4
08B52:  MOVLW  18
08B54:  MOVWF  xC5
08B56:  MOVLB  0
08B58:  CALL   5996
08B5C:  MOVLW  2C
08B5E:  MOVLB  6
08B60:  MOVWF  xE0
08B62:  MOVLB  0
08B64:  CALL   54DE
08B68:  MOVLW  89
08B6A:  MOVWF  FE9
08B6C:  MOVFF  6B9,6D6
08B70:  MOVFF  6B8,6D5
08B74:  MOVFF  6B7,6D4
08B78:  MOVFF  6B6,6D3
08B7C:  MOVLW  02
08B7E:  MOVLB  6
08B80:  MOVWF  xD7
08B82:  MOVLB  0
08B84:  CALL   61B2
08B88:  MOVLW  2C
08B8A:  MOVLB  6
08B8C:  MOVWF  xE0
08B8E:  MOVLB  0
08B90:  CALL   54DE
08B94:  BRA    8DCA
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
08B96:  MOVFF  6A4,6D2
08B9A:  MOVFF  6A3,6D1
08B9E:  MOVFF  69D,6D4
08BA2:  MOVFF  69C,6D3
08BA6:  CALL   5466
08BAA:  MOVF   01,F
08BAC:  BNZ   8C50
08BAE:  MOVLW  04
08BB0:  MOVLB  6
08BB2:  MOVWF  xD2
08BB4:  MOVLW  DE
08BB6:  MOVWF  xD1
08BB8:  MOVLB  0
08BBA:  CALL   542E
08BBE:  MOVF   01,W
08BC0:  ADDLW  DE
08BC2:  MOVLB  6
08BC4:  MOVWF  xB4
08BC6:  MOVLW  04
08BC8:  ADDWFC 02,W
08BCA:  MOVWF  xB5
08BCC:  MOVLW  01
08BCE:  SUBWF  x9B,W
08BD0:  MULLW  20
08BD2:  MOVF   FF3,W
08BD4:  CLRF   xB7
08BD6:  MOVWF  xB6
08BD8:  MOVLW  18
08BDA:  ADDWF  xB6,W
08BDC:  MOVWF  01
08BDE:  MOVLW  00
08BE0:  ADDWFC xB7,W
08BE2:  MOVWF  03
08BE4:  MOVF   01,W
08BE6:  ADDLW  20
08BE8:  MOVWF  FE9
08BEA:  MOVLW  00
08BEC:  ADDWFC 03,W
08BEE:  MOVWF  FEA
08BF0:  MOVFF  FEF,6B6
08BF4:  MOVFF  FEC,6B7
08BF8:  MOVFF  FEC,6B8
08BFC:  MOVFF  FEC,6B9
08C00:  MOVFF  6B5,583
08C04:  MOVFF  6B4,582
08C08:  MOVFF  69B,6C4
08C0C:  MOVLW  18
08C0E:  MOVWF  xC5
08C10:  MOVLB  0
08C12:  CALL   5996
08C16:  MOVLW  2C
08C18:  MOVLB  6
08C1A:  MOVWF  xE0
08C1C:  MOVLB  0
08C1E:  CALL   54DE
08C22:  MOVLW  89
08C24:  MOVWF  FE9
08C26:  MOVFF  6B9,6D6
08C2A:  MOVFF  6B8,6D5
08C2E:  MOVFF  6B7,6D4
08C32:  MOVFF  6B6,6D3
08C36:  MOVLW  02
08C38:  MOVLB  6
08C3A:  MOVWF  xD7
08C3C:  MOVLB  0
08C3E:  CALL   61B2
08C42:  MOVLW  2C
08C44:  MOVLB  6
08C46:  MOVWF  xE0
08C48:  MOVLB  0
08C4A:  CALL   54DE
08C4E:  BRA    8DCA
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
08C50:  MOVFF  6A9,6D2
08C54:  MOVFF  6A8,6D1
08C58:  MOVFF  69D,6D4
08C5C:  MOVFF  69C,6D3
08C60:  CALL   5466
08C64:  MOVF   01,F
08C66:  BNZ   8D0A
08C68:  MOVLW  04
08C6A:  MOVLB  6
08C6C:  MOVWF  xD2
08C6E:  MOVLW  DE
08C70:  MOVWF  xD1
08C72:  MOVLB  0
08C74:  CALL   542E
08C78:  MOVF   01,W
08C7A:  ADDLW  DE
08C7C:  MOVLB  6
08C7E:  MOVWF  xB4
08C80:  MOVLW  04
08C82:  ADDWFC 02,W
08C84:  MOVWF  xB5
08C86:  MOVLW  01
08C88:  SUBWF  x9B,W
08C8A:  MULLW  20
08C8C:  MOVF   FF3,W
08C8E:  CLRF   xB7
08C90:  MOVWF  xB6
08C92:  MOVLW  14
08C94:  ADDWF  xB6,W
08C96:  MOVWF  01
08C98:  MOVLW  00
08C9A:  ADDWFC xB7,W
08C9C:  MOVWF  03
08C9E:  MOVF   01,W
08CA0:  ADDLW  20
08CA2:  MOVWF  FE9
08CA4:  MOVLW  00
08CA6:  ADDWFC 03,W
08CA8:  MOVWF  FEA
08CAA:  MOVFF  FEF,6B6
08CAE:  MOVFF  FEC,6B7
08CB2:  MOVFF  FEC,6B8
08CB6:  MOVFF  FEC,6B9
08CBA:  MOVFF  6B5,583
08CBE:  MOVFF  6B4,582
08CC2:  MOVFF  69B,6C4
08CC6:  MOVLW  18
08CC8:  MOVWF  xC5
08CCA:  MOVLB  0
08CCC:  CALL   5996
08CD0:  MOVLW  2C
08CD2:  MOVLB  6
08CD4:  MOVWF  xE0
08CD6:  MOVLB  0
08CD8:  CALL   54DE
08CDC:  MOVLW  89
08CDE:  MOVWF  FE9
08CE0:  MOVFF  6B9,6D6
08CE4:  MOVFF  6B8,6D5
08CE8:  MOVFF  6B7,6D4
08CEC:  MOVFF  6B6,6D3
08CF0:  MOVLW  02
08CF2:  MOVLB  6
08CF4:  MOVWF  xD7
08CF6:  MOVLB  0
08CF8:  CALL   61B2
08CFC:  MOVLW  2C
08CFE:  MOVLB  6
08D00:  MOVWF  xE0
08D02:  MOVLB  0
08D04:  CALL   54DE
08D08:  BRA    8DCA
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
08D0A:  MOVFF  6B1,6D2
08D0E:  MOVFF  6B0,6D1
08D12:  MOVFF  69D,6D4
08D16:  MOVFF  69C,6D3
08D1A:  CALL   5466
08D1E:  MOVF   01,F
08D20:  BNZ   8DC4
08D22:  MOVLW  04
08D24:  MOVLB  6
08D26:  MOVWF  xD2
08D28:  MOVLW  DE
08D2A:  MOVWF  xD1
08D2C:  MOVLB  0
08D2E:  CALL   542E
08D32:  MOVF   01,W
08D34:  ADDLW  DE
08D36:  MOVLB  6
08D38:  MOVWF  xB4
08D3A:  MOVLW  04
08D3C:  ADDWFC 02,W
08D3E:  MOVWF  xB5
08D40:  MOVLW  01
08D42:  SUBWF  x9B,W
08D44:  MULLW  20
08D46:  MOVF   FF3,W
08D48:  CLRF   xB7
08D4A:  MOVWF  xB6
08D4C:  MOVLW  1C
08D4E:  ADDWF  xB6,W
08D50:  MOVWF  01
08D52:  MOVLW  00
08D54:  ADDWFC xB7,W
08D56:  MOVWF  03
08D58:  MOVF   01,W
08D5A:  ADDLW  20
08D5C:  MOVWF  FE9
08D5E:  MOVLW  00
08D60:  ADDWFC 03,W
08D62:  MOVWF  FEA
08D64:  MOVFF  FEF,6B6
08D68:  MOVFF  FEC,6B7
08D6C:  MOVFF  FEC,6B8
08D70:  MOVFF  FEC,6B9
08D74:  MOVFF  6B5,583
08D78:  MOVFF  6B4,582
08D7C:  MOVFF  69B,6C4
08D80:  MOVLW  18
08D82:  MOVWF  xC5
08D84:  MOVLB  0
08D86:  CALL   5996
08D8A:  MOVLW  2C
08D8C:  MOVLB  6
08D8E:  MOVWF  xE0
08D90:  MOVLB  0
08D92:  CALL   54DE
08D96:  MOVLW  89
08D98:  MOVWF  FE9
08D9A:  MOVFF  6B9,6D6
08D9E:  MOVFF  6B8,6D5
08DA2:  MOVFF  6B7,6D4
08DA6:  MOVFF  6B6,6D3
08DAA:  MOVLW  02
08DAC:  MOVLB  6
08DAE:  MOVWF  xD7
08DB0:  MOVLB  0
08DB2:  CALL   61B2
08DB6:  MOVLW  2C
08DB8:  MOVLB  6
08DBA:  MOVWF  xE0
08DBC:  MOVLB  0
08DBE:  CALL   54DE
08DC2:  BRA    8DCA
....................    else return INV_PARAM;
08DC4:  MOVLW  02
08DC6:  MOVWF  01
08DC8:  BRA    8DCE
....................    
....................    return SUCCESS;
08DCA:  MOVLW  00
08DCC:  MOVWF  01
08DCE:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
08EEE:  MOVLW  72
08EF0:  MOVLB  6
08EF2:  MOVWF  xA0
08EF4:  MOVLW  61
08EF6:  MOVWF  xA1
08EF8:  MOVLW  77
08EFA:  MOVWF  xA2
08EFC:  CLRF   xA3
08EFE:  MOVLW  06
08F00:  MOVWF  x9F
08F02:  MOVLW  A0
08F04:  MOVWF  x9E
....................    char *s_calibrated = "calib";
08F06:  MOVLW  63
08F08:  MOVWF  xA6
08F0A:  MOVLW  61
08F0C:  MOVWF  xA7
08F0E:  MOVLW  6C
08F10:  MOVWF  xA8
08F12:  MOVLW  69
08F14:  MOVWF  xA9
08F16:  MOVLW  62
08F18:  MOVWF  xAA
08F1A:  CLRF   xAB
08F1C:  MOVLW  06
08F1E:  MOVWF  xA5
08F20:  MOVLW  A6
08F22:  MOVWF  xA4
....................    char *s_p0 = "p0";
08F24:  MOVLW  70
08F26:  MOVWF  xAE
08F28:  MOVLW  30
08F2A:  MOVWF  xAF
08F2C:  CLRF   xB0
08F2E:  MOVLW  06
08F30:  MOVWF  xAD
08F32:  MOVLW  AE
08F34:  MOVWF  xAC
....................    char *s_poles = "poles";
08F36:  MOVLW  70
08F38:  MOVWF  xB3
08F3A:  MOVLW  6F
08F3C:  MOVWF  xB4
08F3E:  MOVLW  6C
08F40:  MOVWF  xB5
08F42:  MOVLW  65
08F44:  MOVWF  xB6
08F46:  MOVLW  73
08F48:  MOVWF  xB7
08F4A:  CLRF   xB8
08F4C:  MOVLW  06
08F4E:  MOVWF  xB2
08F50:  MOVLW  B3
08F52:  MOVWF  xB1
....................    char *s_real = "real";
08F54:  MOVLW  72
08F56:  MOVWF  xBB
08F58:  MOVLW  65
08F5A:  MOVWF  xBC
08F5C:  MOVLW  61
08F5E:  MOVWF  xBD
08F60:  MOVLW  6C
08F62:  MOVWF  xBE
08F64:  CLRF   xBF
08F66:  MOVLW  06
08F68:  MOVWF  xBA
08F6A:  MOVLW  BB
08F6C:  MOVWF  xB9
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08F6E:  CLRF   xD2
08F70:  MOVFF  68F,6D1
08F74:  CLRF   xD4
08F76:  MOVLW  B5
08F78:  MOVWF  xD3
08F7A:  MOVLB  0
08F7C:  CALL   0C04
08F80:  MOVFF  02,6C1
08F84:  MOVFF  01,6C0
08F88:  MOVLW  06
08F8A:  MOVLB  6
08F8C:  ADDWF  xC0,F
08F8E:  MOVLW  00
08F90:  ADDWFC xC1,F
08F92:  MOVLW  32
08F94:  ADDWF  xC0,W
08F96:  MOVWF  01
08F98:  MOVLW  00
08F9A:  ADDWFC xC1,W
08F9C:  MOVWF  03
08F9E:  MOVF   01,W
08FA0:  ADDLW  08
08FA2:  MOVWF  01
08FA4:  MOVLW  02
08FA6:  ADDWFC 03,F
08FA8:  MOVFF  01,6C0
08FAC:  MOVFF  03,6C1
08FB0:  MOVFF  03,6C4
08FB4:  MOVFF  01,6C3
08FB8:  MOVLB  0
08FBA:  CALL   55A6
08FBE:  MOVF   01,F
08FC0:  BNZ   8FCA
08FC2:  MOVLW  02
08FC4:  MOVWF  01
08FC6:  BRA    960E
08FC8:  BRA    9028
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08FCA:  MOVLB  6
08FCC:  CLRF   xD2
08FCE:  MOVFF  68F,6D1
08FD2:  CLRF   xD4
08FD4:  MOVLW  B5
08FD6:  MOVWF  xD3
08FD8:  MOVLB  0
08FDA:  CALL   0C04
08FDE:  MOVFF  02,6C1
08FE2:  MOVFF  01,6C0
08FE6:  MOVLW  06
08FE8:  MOVLB  6
08FEA:  ADDWF  xC0,F
08FEC:  MOVLW  00
08FEE:  ADDWFC xC1,F
08FF0:  MOVLW  32
08FF2:  ADDWF  xC0,W
08FF4:  MOVWF  01
08FF6:  MOVLW  00
08FF8:  ADDWFC xC1,W
08FFA:  MOVWF  03
08FFC:  MOVF   01,W
08FFE:  ADDLW  08
09000:  MOVWF  01
09002:  MOVLW  02
09004:  ADDWFC 03,F
09006:  MOVFF  01,6C0
0900A:  MOVFF  03,6C1
0900E:  MOVFF  03,6C4
09012:  MOVFF  01,6C3
09016:  CLRF   xC6
09018:  CLRF   xC5
0901A:  MOVLW  0A
0901C:  MOVWF  xC7
0901E:  MOVLB  0
09020:  CALL   5640
09024:  MOVFF  01,69B
....................    
....................    arg2 = SERcmd[rec].p[3];
09028:  MOVLB  6
0902A:  CLRF   xD2
0902C:  MOVFF  68F,6D1
09030:  CLRF   xD4
09032:  MOVLW  B5
09034:  MOVWF  xD3
09036:  MOVLB  0
09038:  CALL   0C04
0903C:  MOVFF  02,6C1
09040:  MOVFF  01,6C0
09044:  MOVLW  06
09046:  MOVLB  6
09048:  ADDWF  xC0,F
0904A:  MOVLW  00
0904C:  ADDWFC xC1,F
0904E:  MOVLW  4B
09050:  ADDWF  xC0,W
09052:  MOVWF  01
09054:  MOVLW  00
09056:  ADDWFC xC1,W
09058:  MOVWF  03
0905A:  MOVF   01,W
0905C:  ADDLW  08
0905E:  MOVWF  01
09060:  MOVLW  02
09062:  ADDWFC 03,F
09064:  MOVFF  01,69C
09068:  MOVFF  03,69D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0906C:  MOVFF  69F,6D2
09070:  MOVFF  69E,6D1
09074:  MOVFF  69D,6D4
09078:  MOVFF  69C,6D3
0907C:  MOVLB  0
0907E:  CALL   5466
09082:  MOVF   01,F
09084:  BTFSS  FD8.2
09086:  BRA    9202
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09088:  MOVLW  04
0908A:  MOVLB  6
0908C:  MOVWF  xD2
0908E:  MOVLW  DE
09090:  MOVWF  xD1
09092:  MOVLB  0
09094:  CALL   542E
09098:  MOVFF  02,03
0909C:  MOVF   01,W
0909E:  ADDLW  DE
090A0:  MOVLB  6
090A2:  MOVWF  xC0
090A4:  MOVLW  04
090A6:  ADDWFC 02,W
090A8:  MOVWF  xC1
090AA:  MOVFF  FE8,583
090AE:  MOVFF  6C0,582
090B2:  MOVFF  69B,6C4
090B6:  MOVLW  18
090B8:  MOVWF  xC5
090BA:  MOVLB  0
090BC:  CALL   5996
090C0:  MOVLW  2C
090C2:  MOVLB  6
090C4:  MOVWF  xE0
090C6:  MOVLB  0
090C8:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
090CC:  MOVLW  04
090CE:  MOVLB  6
090D0:  MOVWF  xD2
090D2:  MOVLW  DE
090D4:  MOVWF  xD1
090D6:  MOVLB  0
090D8:  CALL   542E
090DC:  MOVFF  02,03
090E0:  MOVF   01,W
090E2:  ADDLW  DE
090E4:  MOVLB  6
090E6:  MOVWF  xC0
090E8:  MOVLW  04
090EA:  ADDWFC 02,W
090EC:  MOVWF  xC1
090EE:  MOVLW  01
090F0:  SUBWF  x9B,W
090F2:  MULLW  21
090F4:  MOVF   FF3,W
090F6:  CLRF   xC3
090F8:  MOVWF  xC2
090FA:  MOVLW  0F
090FC:  ADDWF  xC2,W
090FE:  MOVWF  FE9
09100:  MOVLW  01
09102:  ADDWFC xC3,W
09104:  MOVWF  FEA
09106:  MOVFF  FEF,6E0
0910A:  MOVFF  FEC,01
0910E:  MOVFF  FEC,02
09112:  MOVFF  FEC,03
09116:  MOVFF  03,6E3
0911A:  MOVFF  02,6E2
0911E:  MOVFF  01,6E1
09122:  MOVLB  0
09124:  CALL   504C
09128:  MOVFF  03,6C7
0912C:  MOVFF  02,6C6
09130:  MOVFF  01,6C5
09134:  MOVFF  00,6C4
09138:  MOVFF  6C1,583
0913C:  MOVFF  6C0,582
09140:  MOVLW  41
09142:  MOVWF  FE9
09144:  MOVFF  03,6CC
09148:  MOVFF  02,6CB
0914C:  MOVFF  01,6CA
09150:  MOVFF  00,6C9
09154:  RCALL  8DD0
09156:  MOVLW  2C
09158:  MOVLB  6
0915A:  MOVWF  xE0
0915C:  MOVLB  0
0915E:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09162:  MOVLW  04
09164:  MOVLB  6
09166:  MOVWF  xD2
09168:  MOVLW  DE
0916A:  MOVWF  xD1
0916C:  MOVLB  0
0916E:  CALL   542E
09172:  MOVF   01,W
09174:  ADDLW  DE
09176:  MOVLB  6
09178:  MOVWF  xC0
0917A:  MOVLW  04
0917C:  ADDWFC 02,W
0917E:  MOVWF  xC1
09180:  MOVLW  01
09182:  SUBWF  x9B,W
09184:  MULLW  21
09186:  MOVF   FF3,W
09188:  CLRF   xC3
0918A:  MOVWF  xC2
0918C:  MOVLW  04
0918E:  ADDWF  xC2,W
09190:  MOVWF  01
09192:  MOVLW  00
09194:  ADDWFC xC3,W
09196:  MOVWF  03
09198:  MOVF   01,W
0919A:  ADDLW  0F
0919C:  MOVWF  FE9
0919E:  MOVLW  01
091A0:  ADDWFC 03,W
091A2:  MOVWF  FEA
091A4:  MOVFF  FEF,6E0
091A8:  MOVFF  FEC,01
091AC:  MOVFF  FEC,02
091B0:  MOVFF  FEC,03
091B4:  MOVFF  03,6E3
091B8:  MOVFF  02,6E2
091BC:  MOVFF  01,6E1
091C0:  MOVLB  0
091C2:  CALL   504C
091C6:  MOVFF  03,6C5
091CA:  MOVFF  02,6C4
091CE:  MOVFF  01,6C3
091D2:  MOVFF  00,6C2
091D6:  MOVFF  6C1,583
091DA:  MOVFF  6C0,582
091DE:  MOVLW  41
091E0:  MOVWF  FE9
091E2:  MOVFF  03,6CC
091E6:  MOVFF  02,6CB
091EA:  MOVFF  01,6CA
091EE:  MOVFF  00,6C9
091F2:  RCALL  8DD0
091F4:  MOVLW  2C
091F6:  MOVLB  6
091F8:  MOVWF  xE0
091FA:  MOVLB  0
091FC:  CALL   54DE
....................    }
09200:  BRA    960A
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09202:  MOVFF  6A5,6D2
09206:  MOVFF  6A4,6D1
0920A:  MOVFF  69D,6D4
0920E:  MOVFF  69C,6D3
09212:  CALL   5466
09216:  MOVF   01,F
09218:  BTFSS  FD8.2
0921A:  BRA    939E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0921C:  MOVLW  04
0921E:  MOVLB  6
09220:  MOVWF  xD2
09222:  MOVLW  DE
09224:  MOVWF  xD1
09226:  MOVLB  0
09228:  CALL   542E
0922C:  MOVFF  02,03
09230:  MOVF   01,W
09232:  ADDLW  DE
09234:  MOVLB  6
09236:  MOVWF  xC0
09238:  MOVLW  04
0923A:  ADDWFC 02,W
0923C:  MOVWF  xC1
0923E:  MOVFF  FE8,583
09242:  MOVFF  6C0,582
09246:  MOVFF  69B,6C4
0924A:  MOVLW  18
0924C:  MOVWF  xC5
0924E:  MOVLB  0
09250:  CALL   5996
09254:  MOVLW  2C
09256:  MOVLB  6
09258:  MOVWF  xE0
0925A:  MOVLB  0
0925C:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09260:  MOVLW  04
09262:  MOVLB  6
09264:  MOVWF  xD2
09266:  MOVLW  DE
09268:  MOVWF  xD1
0926A:  MOVLB  0
0926C:  CALL   542E
09270:  MOVF   01,W
09272:  ADDLW  DE
09274:  MOVLB  6
09276:  MOVWF  xC0
09278:  MOVLW  04
0927A:  ADDWFC 02,W
0927C:  MOVWF  xC1
0927E:  MOVLW  01
09280:  SUBWF  x9B,W
09282:  MULLW  21
09284:  MOVF   FF3,W
09286:  CLRF   xC3
09288:  MOVWF  xC2
0928A:  MOVLW  08
0928C:  ADDWF  xC2,W
0928E:  MOVWF  01
09290:  MOVLW  00
09292:  ADDWFC xC3,W
09294:  MOVWF  03
09296:  MOVF   01,W
09298:  ADDLW  0F
0929A:  MOVWF  FE9
0929C:  MOVLW  01
0929E:  ADDWFC 03,W
092A0:  MOVWF  FEA
092A2:  MOVFF  FEF,6E0
092A6:  MOVFF  FEC,01
092AA:  MOVFF  FEC,02
092AE:  MOVFF  FEC,03
092B2:  MOVFF  03,6E3
092B6:  MOVFF  02,6E2
092BA:  MOVFF  01,6E1
092BE:  MOVLB  0
092C0:  CALL   504C
092C4:  MOVFF  03,6C5
092C8:  MOVFF  02,6C4
092CC:  MOVFF  01,6C3
092D0:  MOVFF  00,6C2
092D4:  MOVFF  6C1,583
092D8:  MOVFF  6C0,582
092DC:  MOVLW  41
092DE:  MOVWF  FE9
092E0:  MOVFF  03,6CC
092E4:  MOVFF  02,6CB
092E8:  MOVFF  01,6CA
092EC:  MOVFF  00,6C9
092F0:  RCALL  8DD0
092F2:  MOVLW  2C
092F4:  MOVLB  6
092F6:  MOVWF  xE0
092F8:  MOVLB  0
092FA:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
092FE:  MOVLW  04
09300:  MOVLB  6
09302:  MOVWF  xD2
09304:  MOVLW  DE
09306:  MOVWF  xD1
09308:  MOVLB  0
0930A:  CALL   542E
0930E:  MOVF   01,W
09310:  ADDLW  DE
09312:  MOVLB  6
09314:  MOVWF  xC0
09316:  MOVLW  04
09318:  ADDWFC 02,W
0931A:  MOVWF  xC1
0931C:  MOVLW  01
0931E:  SUBWF  x9B,W
09320:  MULLW  21
09322:  MOVF   FF3,W
09324:  CLRF   xC3
09326:  MOVWF  xC2
09328:  MOVLW  0C
0932A:  ADDWF  xC2,W
0932C:  MOVWF  01
0932E:  MOVLW  00
09330:  ADDWFC xC3,W
09332:  MOVWF  03
09334:  MOVF   01,W
09336:  ADDLW  0F
09338:  MOVWF  FE9
0933A:  MOVLW  01
0933C:  ADDWFC 03,W
0933E:  MOVWF  FEA
09340:  MOVFF  FEF,6E0
09344:  MOVFF  FEC,01
09348:  MOVFF  FEC,02
0934C:  MOVFF  FEC,03
09350:  MOVFF  03,6E3
09354:  MOVFF  02,6E2
09358:  MOVFF  01,6E1
0935C:  MOVLB  0
0935E:  CALL   504C
09362:  MOVFF  03,6C5
09366:  MOVFF  02,6C4
0936A:  MOVFF  01,6C3
0936E:  MOVFF  00,6C2
09372:  MOVFF  6C1,583
09376:  MOVFF  6C0,582
0937A:  MOVLW  41
0937C:  MOVWF  FE9
0937E:  MOVFF  03,6CC
09382:  MOVFF  02,6CB
09386:  MOVFF  01,6CA
0938A:  MOVFF  00,6C9
0938E:  RCALL  8DD0
09390:  MOVLW  2C
09392:  MOVLB  6
09394:  MOVWF  xE0
09396:  MOVLB  0
09398:  CALL   54DE
....................    }
0939C:  BRA    960A
....................    else if (0 == strcmp(s_p0, arg2)) {
0939E:  MOVFF  6AD,6D2
093A2:  MOVFF  6AC,6D1
093A6:  MOVFF  69D,6D4
093AA:  MOVFF  69C,6D3
093AE:  CALL   5466
093B2:  MOVF   01,F
093B4:  BNZ   9470
....................       sprintf(retData+strlen(retData), "%d,", arg1);
093B6:  MOVLW  04
093B8:  MOVLB  6
093BA:  MOVWF  xD2
093BC:  MOVLW  DE
093BE:  MOVWF  xD1
093C0:  MOVLB  0
093C2:  CALL   542E
093C6:  MOVFF  02,03
093CA:  MOVF   01,W
093CC:  ADDLW  DE
093CE:  MOVLB  6
093D0:  MOVWF  xC0
093D2:  MOVLW  04
093D4:  ADDWFC 02,W
093D6:  MOVWF  xC1
093D8:  MOVFF  FE8,583
093DC:  MOVFF  6C0,582
093E0:  MOVFF  69B,6C4
093E4:  MOVLW  18
093E6:  MOVWF  xC5
093E8:  MOVLB  0
093EA:  CALL   5996
093EE:  MOVLW  2C
093F0:  MOVLB  6
093F2:  MOVWF  xE0
093F4:  MOVLB  0
093F6:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
093FA:  MOVLW  04
093FC:  MOVLB  6
093FE:  MOVWF  xD2
09400:  MOVLW  DE
09402:  MOVWF  xD1
09404:  MOVLB  0
09406:  CALL   542E
0940A:  MOVF   01,W
0940C:  ADDLW  DE
0940E:  MOVLB  6
09410:  MOVWF  xC0
09412:  MOVLW  04
09414:  ADDWFC 02,W
09416:  MOVWF  xC1
09418:  MOVLW  01
0941A:  SUBWF  x9B,W
0941C:  MULLW  21
0941E:  MOVF   FF3,W
09420:  CLRF   xC3
09422:  MOVWF  xC2
09424:  MOVLW  18
09426:  ADDWF  xC2,W
09428:  MOVWF  01
0942A:  MOVLW  00
0942C:  ADDWFC xC3,W
0942E:  MOVWF  03
09430:  MOVF   01,W
09432:  ADDLW  0F
09434:  MOVWF  FE9
09436:  MOVLW  01
09438:  ADDWFC 03,W
0943A:  MOVWF  FEA
0943C:  MOVFF  FEF,6D3
09440:  MOVFF  FEC,6D4
09444:  MOVFF  FEC,6D5
09448:  MOVFF  FEC,6D6
0944C:  MOVFF  6C1,583
09450:  MOVFF  6C0,582
09454:  MOVLW  89
09456:  MOVWF  FE9
09458:  MOVLW  02
0945A:  MOVWF  xD7
0945C:  MOVLB  0
0945E:  CALL   61B2
09462:  MOVLW  2C
09464:  MOVLB  6
09466:  MOVWF  xE0
09468:  MOVLB  0
0946A:  CALL   54DE
....................    }
0946E:  BRA    960A
....................    else if (0 == strcmp(s_poles, arg2)) {
09470:  MOVFF  6B2,6D2
09474:  MOVFF  6B1,6D1
09478:  MOVFF  69D,6D4
0947C:  MOVFF  69C,6D3
09480:  CALL   5466
09484:  MOVF   01,F
09486:  BNZ   9532
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09488:  MOVLW  04
0948A:  MOVLB  6
0948C:  MOVWF  xD2
0948E:  MOVLW  DE
09490:  MOVWF  xD1
09492:  MOVLB  0
09494:  CALL   542E
09498:  MOVFF  02,03
0949C:  MOVF   01,W
0949E:  ADDLW  DE
094A0:  MOVLB  6
094A2:  MOVWF  xC0
094A4:  MOVLW  04
094A6:  ADDWFC 02,W
094A8:  MOVWF  xC1
094AA:  MOVFF  FE8,583
094AE:  MOVFF  6C0,582
094B2:  MOVFF  69B,6C4
094B6:  MOVLW  18
094B8:  MOVWF  xC5
094BA:  MOVLB  0
094BC:  CALL   5996
094C0:  MOVLW  2C
094C2:  MOVLB  6
094C4:  MOVWF  xE0
094C6:  MOVLB  0
094C8:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
094CC:  MOVLW  04
094CE:  MOVLB  6
094D0:  MOVWF  xD2
094D2:  MOVLW  DE
094D4:  MOVWF  xD1
094D6:  MOVLB  0
094D8:  CALL   542E
094DC:  MOVF   01,W
094DE:  ADDLW  DE
094E0:  MOVLB  6
094E2:  MOVWF  xC0
094E4:  MOVLW  04
094E6:  ADDWFC 02,W
094E8:  MOVWF  xC1
094EA:  MOVLW  01
094EC:  SUBWF  x9B,W
094EE:  MULLW  21
094F0:  MOVF   FF3,W
094F2:  CLRF   xC3
094F4:  MOVWF  xC2
094F6:  MOVLW  1C
094F8:  ADDWF  xC2,W
094FA:  MOVWF  01
094FC:  MOVLW  00
094FE:  ADDWFC xC3,W
09500:  MOVWF  03
09502:  MOVF   01,W
09504:  ADDLW  0F
09506:  MOVWF  FE9
09508:  MOVLW  01
0950A:  ADDWFC 03,W
0950C:  MOVWF  FEA
0950E:  MOVFF  FEF,6C4
09512:  MOVFF  6C1,583
09516:  MOVFF  6C0,582
0951A:  MOVLW  18
0951C:  MOVWF  xC5
0951E:  MOVLB  0
09520:  CALL   5996
09524:  MOVLW  2C
09526:  MOVLB  6
09528:  MOVWF  xE0
0952A:  MOVLB  0
0952C:  CALL   54DE
....................    }
09530:  BRA    960A
....................    else if (0 == strcmp(s_real, arg2)) {
09532:  MOVFF  6BA,6D2
09536:  MOVFF  6B9,6D1
0953A:  MOVFF  69D,6D4
0953E:  MOVFF  69C,6D3
09542:  CALL   5466
09546:  MOVF   01,F
09548:  BNZ   9604
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0954A:  MOVLW  04
0954C:  MOVLB  6
0954E:  MOVWF  xD2
09550:  MOVLW  DE
09552:  MOVWF  xD1
09554:  MOVLB  0
09556:  CALL   542E
0955A:  MOVFF  02,03
0955E:  MOVF   01,W
09560:  ADDLW  DE
09562:  MOVLB  6
09564:  MOVWF  xC0
09566:  MOVLW  04
09568:  ADDWFC 02,W
0956A:  MOVWF  xC1
0956C:  MOVFF  FE8,583
09570:  MOVFF  6C0,582
09574:  MOVFF  69B,6C4
09578:  MOVLW  18
0957A:  MOVWF  xC5
0957C:  MOVLB  0
0957E:  CALL   5996
09582:  MOVLW  2C
09584:  MOVLB  6
09586:  MOVWF  xE0
09588:  MOVLB  0
0958A:  CALL   54DE
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
0958E:  MOVLW  04
09590:  MOVLB  6
09592:  MOVWF  xD2
09594:  MOVLW  DE
09596:  MOVWF  xD1
09598:  MOVLB  0
0959A:  CALL   542E
0959E:  MOVF   01,W
095A0:  ADDLW  DE
095A2:  MOVLB  6
095A4:  MOVWF  xC0
095A6:  MOVLW  04
095A8:  ADDWFC 02,W
095AA:  MOVWF  xC1
095AC:  MOVLW  01
095AE:  SUBWF  x9B,W
095B0:  MULLW  21
095B2:  MOVF   FF3,W
095B4:  CLRF   xC3
095B6:  MOVWF  xC2
095B8:  MOVLW  1D
095BA:  ADDWF  xC2,W
095BC:  MOVWF  01
095BE:  MOVLW  00
095C0:  ADDWFC xC3,W
095C2:  MOVWF  03
095C4:  MOVF   01,W
095C6:  ADDLW  0F
095C8:  MOVWF  FE9
095CA:  MOVLW  01
095CC:  ADDWFC 03,W
095CE:  MOVWF  FEA
095D0:  MOVFF  FEF,6D3
095D4:  MOVFF  FEC,6D4
095D8:  MOVFF  FEC,6D5
095DC:  MOVFF  FEC,6D6
095E0:  MOVFF  6C1,583
095E4:  MOVFF  6C0,582
095E8:  MOVLW  89
095EA:  MOVWF  FE9
095EC:  MOVLW  02
095EE:  MOVWF  xD7
095F0:  MOVLB  0
095F2:  CALL   61B2
095F6:  MOVLW  2C
095F8:  MOVLB  6
095FA:  MOVWF  xE0
095FC:  MOVLB  0
095FE:  CALL   54DE
....................    }
09602:  BRA    960A
....................    else return INV_PARAM;
09604:  MOVLW  02
09606:  MOVWF  01
09608:  BRA    960E
....................    
....................    return SUCCESS;
0960A:  MOVLW  00
0960C:  MOVWF  01
0960E:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09610:  MOVLB  6
09612:  CLRF   xD2
09614:  MOVFF  68F,6D1
09618:  CLRF   xD4
0961A:  MOVLW  B5
0961C:  MOVWF  xD3
0961E:  MOVLB  0
09620:  CALL   0C04
09624:  MOVFF  02,69D
09628:  MOVFF  01,69C
0962C:  MOVLW  06
0962E:  MOVLB  6
09630:  ADDWF  x9C,F
09632:  MOVLW  00
09634:  ADDWFC x9D,F
09636:  MOVLW  32
09638:  ADDWF  x9C,W
0963A:  MOVWF  01
0963C:  MOVLW  00
0963E:  ADDWFC x9D,W
09640:  MOVWF  03
09642:  MOVF   01,W
09644:  ADDLW  08
09646:  MOVWF  01
09648:  MOVLW  02
0964A:  ADDWFC 03,F
0964C:  MOVFF  01,69C
09650:  MOVFF  03,69D
09654:  MOVFF  03,6C4
09658:  MOVFF  01,6C3
0965C:  MOVLB  0
0965E:  CALL   55A6
09662:  MOVF   01,F
09664:  BNZ   966E
09666:  MOVLW  02
09668:  MOVWF  01
0966A:  BRA    9760
0966C:  BRA    96CC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0966E:  MOVLB  6
09670:  CLRF   xD2
09672:  MOVFF  68F,6D1
09676:  CLRF   xD4
09678:  MOVLW  B5
0967A:  MOVWF  xD3
0967C:  MOVLB  0
0967E:  CALL   0C04
09682:  MOVFF  02,69D
09686:  MOVFF  01,69C
0968A:  MOVLW  06
0968C:  MOVLB  6
0968E:  ADDWF  x9C,F
09690:  MOVLW  00
09692:  ADDWFC x9D,F
09694:  MOVLW  32
09696:  ADDWF  x9C,W
09698:  MOVWF  01
0969A:  MOVLW  00
0969C:  ADDWFC x9D,W
0969E:  MOVWF  03
096A0:  MOVF   01,W
096A2:  ADDLW  08
096A4:  MOVWF  01
096A6:  MOVLW  02
096A8:  ADDWFC 03,F
096AA:  MOVFF  01,69C
096AE:  MOVFF  03,69D
096B2:  MOVFF  03,6C4
096B6:  MOVFF  01,6C3
096BA:  CLRF   xC6
096BC:  CLRF   xC5
096BE:  MOVLW  0A
096C0:  MOVWF  xC7
096C2:  MOVLB  0
096C4:  CALL   5640
096C8:  MOVFF  01,69B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
096CC:  MOVLW  04
096CE:  MOVLB  6
096D0:  MOVWF  xD2
096D2:  MOVLW  DE
096D4:  MOVWF  xD1
096D6:  MOVLB  0
096D8:  CALL   542E
096DC:  MOVF   01,W
096DE:  ADDLW  DE
096E0:  MOVLB  6
096E2:  MOVWF  x9C
096E4:  MOVLW  04
096E6:  ADDWFC 02,W
096E8:  MOVWF  x9D
096EA:  MOVLW  01
096EC:  SUBWF  x9B,W
096EE:  MULLW  04
096F0:  MOVF   FF3,W
096F2:  CLRF   03
096F4:  ADDLW  EA
096F6:  MOVWF  FE9
096F8:  MOVLW  00
096FA:  ADDWFC 03,W
096FC:  MOVWF  FEA
096FE:  MOVFF  FEF,69E
09702:  MOVFF  FEC,69F
09706:  MOVFF  FEC,6A0
0970A:  MOVFF  FEC,6A1
0970E:  MOVFF  69D,583
09712:  MOVFF  69C,582
09716:  MOVFF  69B,6C4
0971A:  MOVLW  18
0971C:  MOVWF  xC5
0971E:  MOVLB  0
09720:  CALL   5996
09724:  MOVLW  2C
09726:  MOVLB  6
09728:  MOVWF  xE0
0972A:  MOVLB  0
0972C:  CALL   54DE
09730:  MOVLW  89
09732:  MOVWF  FE9
09734:  MOVFF  6A1,6D6
09738:  MOVFF  6A0,6D5
0973C:  MOVFF  69F,6D4
09740:  MOVFF  69E,6D3
09744:  MOVLW  02
09746:  MOVLB  6
09748:  MOVWF  xD7
0974A:  MOVLB  0
0974C:  CALL   61B2
09750:  MOVLW  2C
09752:  MOVLB  6
09754:  MOVWF  xE0
09756:  MOVLB  0
09758:  CALL   54DE
....................    
....................    return SUCCESS;
0975C:  MOVLW  00
0975E:  MOVWF  01
09760:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09762:  MOVLB  6
09764:  CLRF   xD2
09766:  MOVFF  68F,6D1
0976A:  CLRF   xD4
0976C:  MOVLW  B5
0976E:  MOVWF  xD3
09770:  MOVLB  0
09772:  CALL   0C04
09776:  MOVFF  02,6A1
0977A:  MOVFF  01,6A0
0977E:  MOVLW  06
09780:  MOVLB  6
09782:  ADDWF  xA0,F
09784:  MOVLW  00
09786:  ADDWFC xA1,F
09788:  MOVLW  32
0978A:  ADDWF  xA0,W
0978C:  MOVWF  01
0978E:  MOVLW  00
09790:  ADDWFC xA1,W
09792:  MOVWF  03
09794:  MOVF   01,W
09796:  ADDLW  08
09798:  MOVWF  01
0979A:  MOVLW  02
0979C:  ADDWFC 03,F
0979E:  MOVFF  01,6A0
097A2:  MOVFF  03,6A1
097A6:  MOVFF  03,6C4
097AA:  MOVFF  01,6C3
097AE:  MOVLB  0
097B0:  CALL   55A6
097B4:  MOVF   01,F
097B6:  BNZ   97C0
097B8:  MOVLW  02
097BA:  MOVWF  01
097BC:  BRA    99A2
097BE:  BRA    981E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
097C0:  MOVLB  6
097C2:  CLRF   xD2
097C4:  MOVFF  68F,6D1
097C8:  CLRF   xD4
097CA:  MOVLW  B5
097CC:  MOVWF  xD3
097CE:  MOVLB  0
097D0:  CALL   0C04
097D4:  MOVFF  02,6A1
097D8:  MOVFF  01,6A0
097DC:  MOVLW  06
097DE:  MOVLB  6
097E0:  ADDWF  xA0,F
097E2:  MOVLW  00
097E4:  ADDWFC xA1,F
097E6:  MOVLW  32
097E8:  ADDWF  xA0,W
097EA:  MOVWF  01
097EC:  MOVLW  00
097EE:  ADDWFC xA1,W
097F0:  MOVWF  03
097F2:  MOVF   01,W
097F4:  ADDLW  08
097F6:  MOVWF  01
097F8:  MOVLW  02
097FA:  ADDWFC 03,F
097FC:  MOVFF  01,6A0
09800:  MOVFF  03,6A1
09804:  MOVFF  03,6C4
09808:  MOVFF  01,6C3
0980C:  CLRF   xC6
0980E:  CLRF   xC5
09810:  MOVLW  0A
09812:  MOVWF  xC7
09814:  MOVLB  0
09816:  CALL   5640
0981A:  MOVFF  01,69B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0981E:  MOVLB  6
09820:  CLRF   xD2
09822:  MOVFF  68F,6D1
09826:  CLRF   xD4
09828:  MOVLW  B5
0982A:  MOVWF  xD3
0982C:  MOVLB  0
0982E:  CALL   0C04
09832:  MOVFF  02,6A1
09836:  MOVFF  01,6A0
0983A:  MOVLW  06
0983C:  MOVLB  6
0983E:  ADDWF  xA0,F
09840:  MOVLW  00
09842:  ADDWFC xA1,F
09844:  MOVLW  4B
09846:  ADDWF  xA0,W
09848:  MOVWF  01
0984A:  MOVLW  00
0984C:  ADDWFC xA1,W
0984E:  MOVWF  03
09850:  MOVF   01,W
09852:  ADDLW  08
09854:  MOVWF  01
09856:  MOVLW  02
09858:  ADDWFC 03,F
0985A:  MOVFF  01,6A0
0985E:  MOVFF  03,6A1
09862:  MOVFF  03,6A5
09866:  MOVFF  01,6A4
0986A:  MOVLB  0
0986C:  CALL   681E
09870:  MOVF   01,F
09872:  BNZ   987C
09874:  MOVLW  02
09876:  MOVWF  01
09878:  BRA    99A2
0987A:  BRA    98E2
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0987C:  MOVLB  6
0987E:  CLRF   xD2
09880:  MOVFF  68F,6D1
09884:  CLRF   xD4
09886:  MOVLW  B5
09888:  MOVWF  xD3
0988A:  MOVLB  0
0988C:  CALL   0C04
09890:  MOVFF  02,6A1
09894:  MOVFF  01,6A0
09898:  MOVLW  06
0989A:  MOVLB  6
0989C:  ADDWF  xA0,F
0989E:  MOVLW  00
098A0:  ADDWFC xA1,F
098A2:  MOVLW  4B
098A4:  ADDWF  xA0,W
098A6:  MOVWF  01
098A8:  MOVLW  00
098AA:  ADDWFC xA1,W
098AC:  MOVWF  03
098AE:  MOVF   01,W
098B0:  ADDLW  08
098B2:  MOVWF  01
098B4:  MOVLW  02
098B6:  ADDWFC 03,F
098B8:  MOVFF  01,6A0
098BC:  MOVFF  03,6A1
098C0:  MOVFF  03,6A5
098C4:  MOVFF  01,6A4
098C8:  CLRF   xA7
098CA:  CLRF   xA6
098CC:  MOVLB  0
098CE:  CALL   68E0
098D2:  MOVFF  03,69F
098D6:  MOVFF  02,69E
098DA:  MOVFF  01,69D
098DE:  MOVFF  00,69C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
098E2:  MOVLB  6
098E4:  CLRF   xDE
098E6:  CLRF   xDD
098E8:  MOVLW  7C
098EA:  MOVWF  xDC
098EC:  MOVLW  84
098EE:  MOVWF  xDB
098F0:  MOVFF  69F,6E2
098F4:  MOVFF  69E,6E1
098F8:  MOVFF  69D,6E0
098FC:  MOVFF  69C,6DF
09900:  MOVLB  0
09902:  CALL   1778
09906:  BNC   992C
09908:  MOVLW  01
0990A:  MOVLB  6
0990C:  SUBWF  x9B,W
0990E:  MULLW  04
09910:  MOVF   FF3,W
09912:  CLRF   03
09914:  ADDLW  EA
09916:  MOVWF  FE9
09918:  MOVLW  00
0991A:  ADDWFC 03,W
0991C:  MOVWF  FEA
0991E:  MOVLW  84
09920:  MOVWF  FEF
09922:  MOVLW  7C
09924:  MOVWF  FEC
09926:  CLRF   FEC
09928:  CLRF   FEC
0992A:  BRA    999C
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
0992C:  MOVFF  69F,6DE
09930:  MOVFF  69E,6DD
09934:  MOVFF  69D,6DC
09938:  MOVFF  69C,6DB
0993C:  MOVLB  6
0993E:  CLRF   xE2
09940:  CLRF   xE1
09942:  MOVLW  FC
09944:  MOVWF  xE0
09946:  MOVLW  84
09948:  MOVWF  xDF
0994A:  MOVLB  0
0994C:  CALL   1778
09950:  BNC   9976
09952:  MOVLW  01
09954:  MOVLB  6
09956:  SUBWF  x9B,W
09958:  MULLW  04
0995A:  MOVF   FF3,W
0995C:  CLRF   03
0995E:  ADDLW  EA
09960:  MOVWF  FE9
09962:  MOVLW  00
09964:  ADDWFC 03,W
09966:  MOVWF  FEA
09968:  MOVLW  84
0996A:  MOVWF  FEF
0996C:  MOVLW  FC
0996E:  MOVWF  FEC
09970:  CLRF   FEC
09972:  CLRF   FEC
09974:  BRA    999C
....................    else manualOutputValues[arg1-1] = arg2;
09976:  MOVLW  01
09978:  MOVLB  6
0997A:  SUBWF  x9B,W
0997C:  MULLW  04
0997E:  MOVF   FF3,W
09980:  CLRF   03
09982:  ADDLW  EA
09984:  MOVWF  FE9
09986:  MOVLW  00
09988:  ADDWFC 03,W
0998A:  MOVWF  FEA
0998C:  MOVFF  69C,FEF
09990:  MOVFF  69D,FEC
09994:  MOVFF  69E,FEC
09998:  MOVFF  69F,FEC
....................    
....................    return SUCCESS;
0999C:  MOVLW  00
0999E:  MOVWF  01
099A0:  MOVLB  0
099A2:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
099A4:  MOVLW  01
099A6:  MOVWF  01
099A8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
0681E:  MOVLB  6
06820:  BCF    xA6.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06822:  CLRF   xA7
06824:  MOVFF  6A5,6D2
06828:  MOVFF  6A4,6D1
0682C:  MOVLB  0
0682E:  CALL   542E
06832:  MOVFF  02,03
06836:  MOVF   01,W
06838:  MOVF   03,F
0683A:  BNZ   6846
0683C:  MOVF   01,W
0683E:  MOVLB  6
06840:  SUBWF  xA7,W
06842:  BC    68D8
06844:  MOVLB  0
....................       if (!isdigit(arg[i])){
06846:  MOVLB  6
06848:  MOVF   xA7,W
0684A:  ADDWF  xA4,W
0684C:  MOVWF  FE9
0684E:  MOVLW  00
06850:  ADDWFC xA5,W
06852:  MOVWF  FEA
06854:  MOVFF  FEF,6A8
06858:  MOVF   xA8,W
0685A:  SUBLW  2F
0685C:  BC    6864
0685E:  MOVF   xA8,W
06860:  SUBLW  39
06862:  BC    68D0
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06864:  MOVF   xA7,W
06866:  ADDWF  xA4,W
06868:  MOVWF  FE9
0686A:  MOVLW  00
0686C:  ADDWFC xA5,W
0686E:  MOVWF  FEA
06870:  MOVF   FEF,W
06872:  SUBLW  2D
06874:  BZ    68A0
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06876:  MOVF   xA7,W
06878:  ADDWF  xA4,W
0687A:  MOVWF  FE9
0687C:  MOVLW  00
0687E:  ADDWFC xA5,W
06880:  MOVWF  FEA
06882:  MOVF   FEF,W
06884:  SUBLW  2E
06886:  BZ    6890
06888:  MOVLW  00
0688A:  MOVWF  01
0688C:  BRA    68DC
0688E:  BRA    689E
....................             else if  (decimal) return FALSE;
06890:  BTFSS  xA6.0
06892:  BRA    689C
06894:  MOVLW  00
06896:  MOVWF  01
06898:  BRA    68DC
0689A:  BRA    689E
....................             else decimal = TRUE;
0689C:  BSF    xA6.0
....................          }
0689E:  BRA    68D0
....................          else if (0 != i) return FALSE;
068A0:  MOVF   xA7,F
068A2:  BZ    68AC
068A4:  MOVLW  00
068A6:  MOVWF  01
068A8:  BRA    68DC
068AA:  BRA    68D0
....................          else if (1 == strlen(arg)) return FALSE;
068AC:  MOVFF  6A5,6D2
068B0:  MOVFF  6A4,6D1
068B4:  MOVLB  0
068B6:  CALL   542E
068BA:  MOVFF  02,03
068BE:  MOVF   01,W
068C0:  SUBLW  01
068C2:  BNZ   68D2
068C4:  MOVF   03,F
068C6:  BNZ   68D2
068C8:  MOVLW  00
068CA:  MOVWF  01
068CC:  MOVLB  6
068CE:  BRA    68DC
068D0:  MOVLB  0
....................       }
068D2:  MOVLB  6
068D4:  INCF   xA7,F
068D6:  BRA    6824
....................    }
....................    return TRUE;
068D8:  MOVLW  01
068DA:  MOVWF  01
068DC:  MOVLB  0
068DE:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
055A6:  MOVFF  6C4,6D2
055AA:  MOVFF  6C3,6D1
055AE:  RCALL  542E
055B0:  MOVFF  02,03
055B4:  MOVF   01,W
055B6:  SUBLW  01
055B8:  BNZ   55BE
055BA:  MOVF   03,F
055BC:  BZ    55C6
055BE:  MOVLW  00
055C0:  MOVWF  01
055C2:  BRA    55F4
055C4:  BRA    55EC
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
055C6:  MOVLB  6
055C8:  MOVFF  6C3,FE9
055CC:  MOVFF  6C4,FEA
055D0:  MOVF   FEF,W
055D2:  SUBLW  31
055D4:  BZ    55EE
055D6:  MOVFF  6C3,FE9
055DA:  MOVFF  6C4,FEA
055DE:  MOVF   FEF,W
055E0:  SUBLW  32
055E2:  BZ    55EE
055E4:  MOVLW  00
055E6:  MOVWF  01
055E8:  MOVLB  0
055EA:  BRA    55F4
055EC:  MOVLB  6
....................     return TRUE;
055EE:  MOVLW  01
055F0:  MOVWF  01
055F2:  MOVLB  0
055F4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
053F4:  MOVLB  6
053F6:  MOVF   x9A,W
053F8:  SUBLW  2F
053FA:  BC    540C
053FC:  MOVF   x9A,W
053FE:  SUBLW  39
05400:  BNC   540C
05402:  MOVLW  30
05404:  SUBWF  x9A,W
05406:  MOVWF  01
05408:  BRA    5428
0540A:  BRA    5428
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
0540C:  MOVF   x9A,W
0540E:  SUBLW  40
05410:  BC    5424
05412:  MOVF   x9A,W
05414:  SUBLW  46
05416:  BNC   5424
05418:  MOVLW  41
0541A:  SUBWF  x9A,W
0541C:  ADDLW  0A
0541E:  MOVWF  01
05420:  BRA    5428
05422:  BRA    5428
....................    else return 0xFF;
05424:  MOVLW  FF
05426:  MOVWF  01
05428:  MOVLB  0
0542A:  GOTO   9A4E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
099AA:  MOVLB  6
099AC:  CLRF   xD2
099AE:  MOVFF  691,6D1
099B2:  CLRF   xD4
099B4:  MOVLW  B5
099B6:  MOVWF  xD3
099B8:  MOVLB  0
099BA:  CALL   0C04
099BE:  MOVFF  02,69A
099C2:  MOVFF  01,699
099C6:  MOVLW  06
099C8:  MOVLB  6
099CA:  ADDWF  x99,F
099CC:  MOVLW  00
099CE:  ADDWFC x9A,F
099D0:  MOVLW  08
099D2:  ADDWF  x99,W
099D4:  MOVWF  01
099D6:  MOVLW  02
099D8:  ADDWFC x9A,W
099DA:  MOVWF  03
099DC:  MOVFF  01,692
099E0:  MOVWF  x93
099E2:  CLRF   xD2
099E4:  MOVFF  691,6D1
099E8:  CLRF   xD4
099EA:  MOVLW  B5
099EC:  MOVWF  xD3
099EE:  MOVLB  0
099F0:  CALL   0C04
099F4:  MOVFF  02,69C
099F8:  MOVFF  01,69B
099FC:  MOVLW  06
099FE:  MOVLB  6
09A00:  ADDWF  x9B,F
09A02:  MOVLW  00
09A04:  ADDWFC x9C,F
09A06:  MOVLW  19
09A08:  ADDWF  x9B,W
09A0A:  MOVWF  01
09A0C:  MOVLW  00
09A0E:  ADDWFC x9C,W
09A10:  MOVWF  03
09A12:  MOVF   01,W
09A14:  ADDLW  08
09A16:  MOVWF  01
09A18:  MOVLW  02
09A1A:  ADDWFC 03,F
09A1C:  MOVFF  01,694
09A20:  MOVFF  03,695
09A24:  CLRF   x96
09A26:  CLRF   x97
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
09A28:  MOVFF  692,FE9
09A2C:  MOVFF  693,FEA
09A30:  MOVF   FEF,W
09A32:  SUBLW  44
09A34:  BTFSS  FD8.2
09A36:  BRA    9B26
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
09A38:  MOVLW  01
09A3A:  ADDWF  x92,W
09A3C:  MOVWF  FE9
09A3E:  MOVLW  00
09A40:  ADDWFC x93,W
09A42:  MOVWF  FEA
09A44:  MOVFF  FEF,69A
09A48:  MOVLB  0
09A4A:  GOTO   53F4
09A4E:  MOVFF  01,699
09A52:  MOVLB  6
09A54:  MOVF   x96,W
09A56:  ANDLW  0F
09A58:  SUBWF  01,W
09A5A:  BNZ   9B1E
....................          while (0 != strlen(cmd_list[i].cmd_name)){
09A5C:  MOVF   x97,W
09A5E:  MULLW  04
09A60:  MOVF   FF3,W
09A62:  CLRF   x9A
09A64:  MOVWF  x99
09A66:  MOVLW  88
09A68:  ADDWF  x99,W
09A6A:  MOVWF  FE9
09A6C:  MOVLW  05
09A6E:  ADDWFC x9A,W
09A70:  MOVWF  FEA
09A72:  MOVFF  FEC,6D2
09A76:  MOVF   FED,F
09A78:  MOVFF  FEF,6D1
09A7C:  MOVLB  0
09A7E:  CALL   542E
09A82:  MOVFF  02,03
09A86:  MOVF   01,W
09A88:  BNZ   9A8E
09A8A:  MOVF   03,F
09A8C:  BZ    9B14
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
09A8E:  MOVLB  6
09A90:  MOVF   x97,W
09A92:  MULLW  04
09A94:  MOVF   FF3,W
09A96:  CLRF   x9A
09A98:  MOVWF  x99
09A9A:  MOVLW  88
09A9C:  ADDWF  x99,W
09A9E:  MOVWF  FE9
09AA0:  MOVLW  05
09AA2:  ADDWFC x9A,W
09AA4:  MOVWF  FEA
09AA6:  MOVFF  FEC,6D4
09AAA:  MOVF   FED,F
09AAC:  MOVFF  FEF,6D3
09AB0:  MOVFF  695,6D2
09AB4:  MOVFF  694,6D1
09AB8:  MOVLB  0
09ABA:  CALL   5466
09ABE:  MOVF   01,F
09AC0:  BNZ   9B0C
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
09AC2:  MOVLB  6
09AC4:  MOVF   x97,W
09AC6:  MULLW  04
09AC8:  MOVF   FF3,W
09ACA:  CLRF   x9A
09ACC:  MOVWF  x99
09ACE:  MOVLW  02
09AD0:  ADDWF  x99,W
09AD2:  MOVWF  01
09AD4:  MOVLW  00
09AD6:  ADDWFC x9A,W
09AD8:  MOVWF  03
09ADA:  MOVF   01,W
09ADC:  ADDLW  88
09ADE:  MOVWF  01
09AE0:  MOVLW  05
09AE2:  ADDWFC 03,F
09AE4:  MOVFF  01,699
09AE8:  MOVFF  03,69A
09AEC:  MOVFF  03,FEA
09AF0:  MOVFF  01,FE9
09AF4:  MOVFF  691,68F
09AF8:  MOVLB  0
09AFA:  CALL   00BC
09AFE:  MOVFF  01,698
....................                return return_code;
09B02:  MOVLB  6
09B04:  MOVFF  698,01
09B08:  BRA    9B2A
09B0A:  MOVLB  0
....................             }
....................             i++;
09B0C:  MOVLB  6
09B0E:  INCF   x97,F
09B10:  BRA    9A5C
09B12:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
09B14:  MOVLW  01
09B16:  MOVWF  01
09B18:  MOVLB  6
09B1A:  BRA    9B2A
....................       } else return 254; // NOT THIS ADDRESS
09B1C:  BRA    9B24
09B1E:  MOVLW  FE
09B20:  MOVWF  01
09B22:  BRA    9B2A
....................    } else return 255; // NOT THIS DEVICE TYPE
09B24:  BRA    9B2A
09B26:  MOVLW  FF
09B28:  MOVWF  01
09B2A:  MOVLB  0
09B2C:  GOTO   9B66 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
09B58:  GOTO   539A
09B5C:  MOVF   01,F
09B5E:  BZ    9C4E
....................    {
....................       int8 return_code = command_parser(SRI);
09B60:  MOVFF  4DC,691
09B64:  BRA    99AA
09B66:  MOVFF  01,690
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
09B6A:  MOVLW  04
09B6C:  MOVLB  6
09B6E:  MOVWF  xD2
09B70:  MOVLW  DE
09B72:  MOVWF  xD1
09B74:  MOVLB  0
09B76:  CALL   542E
09B7A:  MOVF   01,W
09B7C:  ADDLW  DE
09B7E:  MOVLB  6
09B80:  MOVWF  x91
09B82:  MOVLW  04
09B84:  ADDWFC 02,W
09B86:  MOVWF  x92
09B88:  MOVF   x90,W
09B8A:  MULLW  03
09B8C:  MOVF   FF3,W
09B8E:  CLRF   x94
09B90:  MOVWF  x93
09B92:  MOVLW  01
09B94:  ADDWF  x93,W
09B96:  MOVWF  01
09B98:  MOVLW  00
09B9A:  ADDWFC x94,W
09B9C:  MOVWF  03
09B9E:  MOVF   01,W
09BA0:  ADDLW  57
09BA2:  MOVWF  FE9
09BA4:  MOVLW  06
09BA6:  ADDWFC 03,W
09BA8:  MOVWF  FEA
09BAA:  MOVFF  FEC,694
09BAE:  MOVF   FED,F
09BB0:  MOVFF  FEF,693
09BB4:  MOVFF  692,583
09BB8:  MOVFF  691,582
09BBC:  MOVFF  583,FEA
09BC0:  MOVFF  582,FE9
09BC4:  CLRF   FEF
09BC6:  MOVFF  694,FEA
09BCA:  MOVFF  693,FE9
09BCE:  MOVLB  0
09BD0:  BRA    9B30
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
09BD2:  MOVLB  6
09BD4:  CLRF   xD2
09BD6:  MOVFF  4DC,6D1
09BDA:  CLRF   xD4
09BDC:  MOVLW  B5
09BDE:  MOVWF  xD3
09BE0:  MOVLB  0
09BE2:  CALL   0C04
09BE6:  MOVFF  02,692
09BEA:  MOVFF  01,691
09BEE:  MOVLW  06
09BF0:  MOVLB  6
09BF2:  ADDWF  x91,F
09BF4:  MOVLW  00
09BF6:  ADDWFC x92,F
09BF8:  MOVLW  08
09BFA:  ADDWF  x91,W
09BFC:  MOVWF  01
09BFE:  MOVLW  02
09C00:  ADDWFC x92,W
09C02:  MOVWF  03
09C04:  MOVFF  01,693
09C08:  MOVWF  x94
09C0A:  MOVLW  24
09C0C:  MOVWF  xA6
09C0E:  MOVLB  0
09C10:  CALL   4A38
09C14:  MOVFF  694,FEA
09C18:  MOVFF  693,FE9
09C1C:  CALL   4A60
09C20:  MOVLW  2C
09C22:  MOVLB  6
09C24:  MOVWF  xA6
09C26:  MOVLB  0
09C28:  CALL   4A38
09C2C:  MOVLW  04
09C2E:  MOVWF  FEA
09C30:  MOVLW  DE
09C32:  MOVWF  FE9
09C34:  CALL   4A60
09C38:  MOVLW  0A
09C3A:  MOVLB  6
09C3C:  MOVWF  xA6
09C3E:  MOVLB  0
09C40:  CALL   4A38
....................       
....................       resetSERcmd(SRI);
09C44:  MOVFF  4DC,691
09C48:  CALL   0C26
09C4C:  BRA    9B58
....................    }
09C4E:  GOTO   A2DA (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
09C52:  CLRF   FF8
09C54:  BCF    FF2.5
09C56:  BSF    07.7
09C58:  MOVLB  E
09C5A:  MOVLW  55
09C5C:  MOVWF  x9B
09C5E:  MOVLW  AA
09C60:  MOVWF  x9B
09C62:  BCF    x9B.0
09C64:  MOVLW  17
09C66:  MOVWF  xB0
09C68:  MOVLW  13
09C6A:  MOVWF  xB2
09C6C:  MOVLW  09
09C6E:  MOVWF  x8A
09C70:  MOVLW  0A
09C72:  MOVWF  x8B
09C74:  MOVLW  11
09C76:  MOVWF  xEB
09C78:  MOVLW  12
09C7A:  MOVWF  xED
09C7C:  MOVLW  10
09C7E:  MOVWF  xF4
09C80:  MOVLW  0F
09C82:  MOVWF  xF5
09C84:  MOVLW  09
09C86:  MOVWF  xF8
09C88:  MOVLW  55
09C8A:  MOVWF  x9B
09C8C:  MOVLW  AA
09C8E:  MOVWF  x9B
09C90:  BSF    x9B.0
09C92:  CLRF   xD8
09C94:  CLRF   xD5
09C96:  CLRF   xD7
09C98:  MOVLW  08
09C9A:  MOVWF  xD9
09C9C:  MOVLW  60
09C9E:  MOVWF  xD3
09CA0:  MOVLW  AA
09CA2:  MOVLB  0
09CA4:  MOVWF  xF2
09CA6:  MOVLB  1
09CA8:  CLRF   x5A
09CAA:  CLRF   x59
09CAC:  CLRF   x58
09CAE:  CLRF   x57
09CB0:  CLRF   x5E
09CB2:  CLRF   x5D
09CB4:  CLRF   x5C
09CB6:  CLRF   x5B
09CB8:  CLRF   x62
09CBA:  CLRF   x61
09CBC:  CLRF   x60
09CBE:  CLRF   x5F
09CC0:  CLRF   x64
09CC2:  CLRF   x63
09CC4:  MOVLB  E
09CC6:  BCF    x91.5
09CC8:  MOVLW  00
09CCA:  MOVWF  x90
09CCC:  MOVLW  03
09CCE:  MOVWF  x8E
09CD0:  MOVLW  2A
09CD2:  MOVWF  x91
09CD4:  MOVLW  C4
09CD6:  MOVWF  F88
09CD8:  MOVWF  F88
09CDA:  MOVWF  F88
09CDC:  BCF    F95.5
09CDE:  MOVLW  40
09CE0:  MOVWF  F94
09CE2:  MOVLW  9F
09CE4:  MOVWF  F92
09CE6:  MOVLW  3A
09CE8:  MOVWF  F95
09CEA:  MOVLW  93
09CEC:  MOVWF  F89
09CEE:  MOVWF  F89
09CF0:  MOVLB  4
09CF2:  CLRF   xDC
09CF4:  CLRF   xDD
09CF6:  MOVLB  5
09CF8:  CLRF   x7E
09CFA:  CLRF   x7F
09CFC:  BCF    x80.0
09CFE:  CLRF   x81
09D00:  BSF    F9E.3
09D02:  MOVLW  7C
09D04:  MOVWF  F9A
09D06:  MOVLW  00
09D08:  MOVWF  F9B
09D0A:  MOVLW  A6
09D0C:  MOVWF  F9D
09D0E:  MOVLW  90
09D10:  MOVWF  F9C
09D12:  MOVLW  93
09D14:  MOVWF  F89
09D16:  BCF    F84.5
09D18:  CLRF   x83
09D1A:  CLRF   x82
09D1C:  CLRF   x87
09D1E:  CLRF   x86
09D20:  CLRF   x85
09D22:  CLRF   x84
09D24:  MOVLB  F
09D26:  CLRF   x0C
09D28:  CLRF   x14
09D2A:  CLRF   x1C
09D2C:  CLRF   x21
09D2E:  CLRF   x29
09D30:  CLRF   x35
09D32:  CLRF   x36
09D34:  CLRF   x37
09D36:  CLRF   x34
09D38:  CLRF   x31
09D3A:  CLRF   x32
09D3C:  CLRF   x33
09D3E:  CLRF   x30
09D40:  MOVLW  55
09D42:  MOVLB  5
09D44:  MOVWF  x8B
09D46:  MOVLW  1E
09D48:  MOVWF  x8A
09D4A:  MOVLW  55
09D4C:  MOVWF  x8F
09D4E:  MOVLW  62
09D50:  MOVWF  x8E
09D52:  MOVLW  5A
09D54:  MOVWF  x93
09D56:  MOVLW  56
09D58:  MOVWF  x92
09D5A:  MOVLW  5C
09D5C:  MOVWF  x97
09D5E:  MOVLW  34
09D60:  MOVWF  x96
09D62:  MOVLW  5E
09D64:  MOVWF  x9B
09D66:  MOVLW  0C
09D68:  MOVWF  x9A
09D6A:  MOVLW  5F
09D6C:  MOVWF  x9F
09D6E:  MOVLW  98
09D70:  MOVWF  x9E
09D72:  MOVLW  63
09D74:  MOVWF  xA3
09D76:  MOVLW  68
09D78:  MOVWF  xA2
09D7A:  MOVLW  6B
09D7C:  MOVWF  xA7
09D7E:  MOVLW  3A
09D80:  MOVWF  xA6
09D82:  MOVLW  6E
09D84:  MOVWF  xAB
09D86:  MOVLW  1A
09D88:  MOVWF  xAA
09D8A:  MOVLW  6F
09D8C:  MOVWF  xAF
09D8E:  MOVLW  7C
09D90:  MOVWF  xAE
09D92:  MOVLW  71
09D94:  MOVWF  xB3
09D96:  MOVLW  3A
09D98:  MOVWF  xB2
09D9A:  MOVLW  74
09D9C:  MOVWF  xB7
09D9E:  MOVLW  F0
09DA0:  MOVWF  xB6
09DA2:  MOVLW  7A
09DA4:  MOVWF  xBB
09DA6:  MOVLW  4C
09DA8:  MOVWF  xBA
09DAA:  MOVLW  7D
09DAC:  MOVWF  xBF
09DAE:  MOVLW  E4
09DB0:  MOVWF  xBE
09DB2:  MOVLW  83
09DB4:  MOVWF  xC3
09DB6:  MOVLW  10
09DB8:  MOVWF  xC2
09DBA:  MOVLW  83
09DBC:  MOVWF  xC7
09DBE:  MOVLW  16
09DC0:  MOVWF  xC6
09DC2:  MOVLW  89
09DC4:  MOVWF  xCB
09DC6:  MOVLW  8A
09DC8:  MOVWF  xCA
09DCA:  MOVLW  8E
09DCC:  MOVWF  xCF
09DCE:  MOVLW  EE
09DD0:  MOVWF  xCE
09DD2:  MOVLW  96
09DD4:  MOVWF  xD3
09DD6:  MOVLW  10
09DD8:  MOVWF  xD2
09DDA:  MOVLW  97
09DDC:  MOVWF  xD7
09DDE:  MOVLW  62
09DE0:  MOVWF  xD6
09DE2:  MOVLW  99
09DE4:  MOVWF  xDB
09DE6:  MOVLW  A4
09DE8:  MOVWF  xDA
09DEA:  BRA    9FB2
09DEC:  DATA 02,00
09DEE:  DATA 1A,00
09DF0:  DATA 00,0C
09DF2:  DATA 00,20
09DF4:  DATA 78,23
09DF6:  DATA D7,0A
09DF8:  DATA 7D,19
09DFA:  DATA 99,9A
09DFC:  DATA 7B,4C
09DFE:  DATA CC,CD
09E00:  DATA 14,C0
09E02:  DATA 00,0C
09E04:  DATA 80,78
09E06:  DATA 23,D7
09E08:  DATA 0A,7D
09E0A:  DATA 19,99
09E0C:  DATA 9A,7B
09E0E:  DATA 4C,CC
09E10:  DATA CD,14
09E12:  DATA C0,00
09E14:  DATA 01,80
09E16:  DATA 02,09
09E18:  DATA C0,00
09E1A:  DATA 05,80
09E1C:  DATA 7F,00
09E1E:  DATA 00,00
09E20:  DATA 7F,0B
09E22:  DATA C0,00
09E24:  DATA 05,80
09E26:  DATA 7F,00
09E28:  DATA 00,00
09E2A:  DATA 7F,07
09E2C:  DATA C0,00
09E2E:  DATA 01,80
09E30:  DATA 7F,17
09E32:  DATA C0,00
09E34:  DATA 01,80
09E36:  DATA 7F,17
09E38:  DATA C0,00
09E3A:  DATA 04,80
09E3C:  DATA 79,B7
09E3E:  DATA F3,BD
09E40:  DATA 04,C0
09E42:  DATA 00,04
09E44:  DATA 80,7C
09E46:  DATA 59,DF
09E48:  DATA 4E,04
09E4A:  DATA C0,00
09E4C:  DATA 04,80
09E4E:  DATA 78,0A
09E50:  DATA 28,88
09E52:  DATA 04,C0
09E54:  DATA 00,04
09E56:  DATA 80,78
09E58:  DATA 05,EA
09E5A:  DATA 16,04
09E5C:  DATA C0,00
09E5E:  DATA 04,80
09E60:  DATA 78,1E
09E62:  DATA 33,D7
09E64:  DATA 04,C0
09E66:  DATA 00,04
09E68:  DATA 80,77
09E6A:  DATA 68,7B
09E6C:  DATA BB,04
09E6E:  DATA C0,00
09E70:  DATA 04,80
09E72:  DATA 77,68
09E74:  DATA 0D,C6
09E76:  DATA 08,C0
09E78:  DATA 00,64
09E7A:  DATA 40,F3
09E7C:  DATA 00,05
09E7E:  DATA 01,E9
09E80:  DATA 00,65
09E82:  DATA 01,86
09E84:  DATA 01,09
09E86:  DATA C0,00
09E88:  DATA 04,80
09E8A:  DATA A7,01
09E8C:  DATA C8,01
09E8E:  DATA 0D,C0
09E90:  DATA 00,3C
09E92:  DATA 45,42
09E94:  DATA 00,02
09E96:  DATA 05,88
09E98:  DATA DC,05
09E9A:  DATA 02,05
09E9C:  DATA 8C,DF
09E9E:  DATA 05,02
09EA0:  DATA 05,90
09EA2:  DATA E2,05
09EA4:  DATA 02,05
09EA6:  DATA 94,E9
09EA8:  DATA 05,02
09EAA:  DATA 05,98
09EAC:  DATA F0,05
09EAE:  DATA 02,05
09EB0:  DATA 9C,F8
09EB2:  DATA 05,02
09EB4:  DATA 05,A0
09EB6:  DATA 00,06
09EB8:  DATA 02,05
09EBA:  DATA A4,05
09EBC:  DATA 06,02
09EBE:  DATA 05,A8
09EC0:  DATA 0A,06
09EC2:  DATA 02,05
09EC4:  DATA AC,0E
09EC6:  DATA 06,02
09EC8:  DATA 05,B0
09ECA:  DATA 12,06
09ECC:  DATA 02,05
09ECE:  DATA B4,19
09ED0:  DATA 06,02
09ED2:  DATA 05,B8
09ED4:  DATA 1F,06
09ED6:  DATA 02,05
09ED8:  DATA BC,25
09EDA:  DATA 06,02
09EDC:  DATA 05,C0
09EDE:  DATA 2B,06
09EE0:  DATA 02,05
09EE2:  DATA C4,31
09EE4:  DATA 06,02
09EE6:  DATA 05,C8
09EE8:  DATA 36,06
09EEA:  DATA 02,05
09EEC:  DATA CC,3F
09EEE:  DATA 06,02
09EF0:  DATA 05,D0
09EF2:  DATA 47,06
09EF4:  DATA 02,05
09EF6:  DATA D4,4E
09EF8:  DATA 06,02
09EFA:  DATA 05,D8
09EFC:  DATA 55,06
09EFE:  DATA 78,05
09F00:  DATA DC,67
09F02:  DATA 72,00
09F04:  DATA 67,73
09F06:  DATA 00,67
09F08:  DATA 43,68
09F0A:  DATA 4D,61
09F0C:  DATA 70,00
09F0E:  DATA 73,43
09F10:  DATA 68,4D
09F12:  DATA 61,70
09F14:  DATA 00,67
09F16:  DATA 43,68
09F18:  DATA 4D,6F
09F1A:  DATA 64,65
09F1C:  DATA 00,73
09F1E:  DATA 43,68
09F20:  DATA 4D,6F
09F22:  DATA 64,65
09F24:  DATA 00,67
09F26:  DATA 50,49
09F28:  DATA 44,00
09F2A:  DATA 73,50
09F2C:  DATA 49,44
09F2E:  DATA 00,67
09F30:  DATA 53,50
09F32:  DATA 00,73
09F34:  DATA 53,50
09F36:  DATA 00,67
09F38:  DATA 53,43
09F3A:  DATA 61,6C
09F3C:  DATA 73,00
09F3E:  DATA 67,53
09F40:  DATA 43,61
09F42:  DATA 6C,00
09F44:  DATA 73,53
09F46:  DATA 43,61
09F48:  DATA 6C,00
09F4A:  DATA 67,4D
09F4C:  DATA 43,61
09F4E:  DATA 6C,00
09F50:  DATA 73,4D
09F52:  DATA 43,61
09F54:  DATA 6C,00
09F56:  DATA 67,4D
09F58:  DATA 6F,6E
09F5A:  DATA 00,67
09F5C:  DATA 50,49
09F5E:  DATA 44,64
09F60:  DATA 61,74
09F62:  DATA 61,00
09F64:  DATA 67,49
09F66:  DATA 50,64
09F68:  DATA 61,74
09F6A:  DATA 61,00
09F6C:  DATA 67,4D
09F6E:  DATA 61,6E
09F70:  DATA 4F,50
09F72:  DATA 00,73
09F74:  DATA 4D,61
09F76:  DATA 6E,4F
09F78:  DATA 50,04
09F7A:  DATA C0,00
09F7C:  DATA 33,80
09F7E:  DATA 60,06
09F80:  DATA 01,68
09F82:  DATA 06,02
09F84:  DATA 78,06
09F86:  DATA 53,55
09F88:  DATA 43,43
09F8A:  DATA 45,53
09F8C:  DATA 53,00
09F8E:  DATA 49,4E
09F90:  DATA 56,41
09F92:  DATA 4C,49
09F94:  DATA 44,20
09F96:  DATA 43,4F
09F98:  DATA 4D,4D
09F9A:  DATA 41,4E
09F9C:  DATA 44,00
09F9E:  DATA 49,4E
09FA0:  DATA 56,41
09FA2:  DATA 4C,49
09FA4:  DATA 44,20
09FA6:  DATA 50,41
09FA8:  DATA 52,41
09FAA:  DATA 4D,45
09FAC:  DATA 54,45
09FAE:  DATA 52,00
09FB0:  DATA 00,00
09FB2:  MOVLW  00
09FB4:  MOVWF  FF8
09FB6:  MOVLW  9D
09FB8:  MOVWF  FF7
09FBA:  MOVLW  EC
09FBC:  MOVWF  FF6
09FBE:  TBLRD*+
09FC0:  MOVF   FF5,W
09FC2:  MOVWF  00
09FC4:  XORLW  00
09FC6:  BZ    9FEE
09FC8:  TBLRD*+
09FCA:  MOVF   FF5,W
09FCC:  MOVWF  01
09FCE:  BTFSC  FE8.7
09FD0:  BRA    9FDC
09FD2:  ANDLW  3F
09FD4:  MOVWF  FEA
09FD6:  TBLRD*+
09FD8:  MOVFF  FF5,FE9
09FDC:  BTFSC  01.6
09FDE:  TBLRD*+
09FE0:  BTFSS  01.6
09FE2:  TBLRD*+
09FE4:  MOVFF  FF5,FEE
09FE8:  DCFSNZ 00,F
09FEA:  BRA    9FBE
09FEC:  BRA    9FE0
09FEE:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
09FF0:  MOVLB  0
09FF2:  GOTO   039A
....................    params_init();                // load parameters
09FF6:  GOTO   0642
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
09FFA:  GOTO   0B48
....................    control_init();               // initialize the output control DACs
09FFE:  GOTO   0BE0
....................    serial_init();                // setup the serial port
0A002:  GOTO   0DA0
....................    event_timer_init();
0A006:  GOTO   0DC2
.................... //!   setup_wdt(WDT_512MS);
.................... //!   enable_interrupts(GLOBAL);
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A00A:  GOTO   11A0
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A00E:  GOTO   3EAA
....................       control_task();            //output control
0A012:  GOTO   49BC
....................       serial_task();             //serial port 
0A016:  GOTO   4A84
0A01A:  CLRF   19
0A01C:  BTFSC  FF2.7
0A01E:  BSF    19.7
0A020:  BCF    FF2.7
....................       
....................       sensor_monitor_interrupt_task();
0A022:  CALL   01B8
0A026:  BTFSC  19.7
0A028:  BSF    FF2.7
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A02A:  MOVLW  01
0A02C:  MOVLB  6
0A02E:  ADDWF  x8A,W
0A030:  MOVWF  x90
0A032:  MOVF   x8A,W
0A034:  MULLW  21
0A036:  MOVF   FF3,W
0A038:  CLRF   x92
0A03A:  MOVWF  x91
0A03C:  MOVLW  08
0A03E:  ADDWF  x91,W
0A040:  MOVWF  01
0A042:  MOVLW  00
0A044:  ADDWFC x92,W
0A046:  MOVWF  03
0A048:  MOVF   01,W
0A04A:  ADDLW  0F
0A04C:  MOVWF  FE9
0A04E:  MOVLW  01
0A050:  ADDWFC 03,W
0A052:  MOVWF  FEA
0A054:  MOVFF  FEF,691
0A058:  MOVFF  FEC,692
0A05C:  MOVFF  FEC,693
0A060:  MOVFF  FEC,694
0A064:  MOVF   x8A,W
0A066:  MULLW  21
0A068:  MOVF   FF3,W
0A06A:  CLRF   x96
0A06C:  MOVWF  x95
0A06E:  MOVLW  0C
0A070:  ADDWF  x95,W
0A072:  MOVWF  01
0A074:  MOVLW  00
0A076:  ADDWFC x96,W
0A078:  MOVWF  03
0A07A:  MOVF   01,W
0A07C:  ADDLW  0F
0A07E:  MOVWF  FE9
0A080:  MOVLW  01
0A082:  ADDWFC 03,W
0A084:  MOVWF  FEA
0A086:  MOVFF  FEF,695
0A08A:  MOVFF  FEC,696
0A08E:  MOVFF  FEC,697
0A092:  MOVFF  FEC,698
0A096:  MOVLW  4E
0A098:  MOVWF  FF6
0A09A:  MOVLW  03
0A09C:  MOVWF  FF7
0A09E:  MOVLW  08
0A0A0:  MOVWF  x99
0A0A2:  MOVLB  0
0A0A4:  CALL   4F7C
0A0A8:  MOVFF  690,699
0A0AC:  MOVLW  1B
0A0AE:  MOVLB  6
0A0B0:  MOVWF  x9A
0A0B2:  MOVLB  0
0A0B4:  CALL   4FD0
0A0B8:  MOVLW  2C
0A0BA:  MOVLB  6
0A0BC:  MOVWF  xA6
0A0BE:  MOVLB  0
0A0C0:  CALL   4A38
0A0C4:  MOVLW  89
0A0C6:  MOVWF  FE9
0A0C8:  MOVFF  694,69C
0A0CC:  MOVFF  693,69B
0A0D0:  MOVFF  692,69A
0A0D4:  MOVFF  691,699
0A0D8:  MOVLB  6
0A0DA:  CLRF   x9D
0A0DC:  MOVLB  0
0A0DE:  CALL   5122
0A0E2:  MOVLW  2C
0A0E4:  MOVLB  6
0A0E6:  MOVWF  xA6
0A0E8:  MOVLB  0
0A0EA:  CALL   4A38
0A0EE:  MOVLW  89
0A0F0:  MOVWF  FE9
0A0F2:  MOVFF  698,69C
0A0F6:  MOVFF  697,69B
0A0FA:  MOVFF  696,69A
0A0FE:  MOVFF  695,699
0A102:  MOVLB  6
0A104:  CLRF   x9D
0A106:  MOVLB  0
0A108:  CALL   5122
0A10C:  MOVLW  0A
0A10E:  MOVLB  6
0A110:  MOVWF  xA6
0A112:  MOVLB  0
0A114:  CALL   4A38
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0A118:  MOVLW  01
0A11A:  MOVLB  6
0A11C:  ADDWF  x8A,W
0A11E:  MOVWF  x90
0A120:  MOVF   x8A,W
0A122:  MULLW  21
0A124:  MOVF   FF3,W
0A126:  CLRF   x92
0A128:  MOVWF  x91
0A12A:  MOVLW  1D
0A12C:  ADDWF  x91,W
0A12E:  MOVWF  01
0A130:  MOVLW  00
0A132:  ADDWFC x92,W
0A134:  MOVWF  03
0A136:  MOVF   01,W
0A138:  ADDLW  0F
0A13A:  MOVWF  FE9
0A13C:  MOVLW  01
0A13E:  ADDWFC 03,W
0A140:  MOVWF  FEA
0A142:  MOVFF  FEF,691
0A146:  MOVFF  FEC,692
0A14A:  MOVFF  FEC,693
0A14E:  MOVFF  FEC,694
0A152:  MOVLW  64
0A154:  MOVWF  FF6
0A156:  MOVLW  03
0A158:  MOVWF  FF7
0A15A:  MOVLW  08
0A15C:  MOVWF  x99
0A15E:  MOVLB  0
0A160:  CALL   4F7C
0A164:  MOVFF  690,699
0A168:  MOVLW  1B
0A16A:  MOVLB  6
0A16C:  MOVWF  x9A
0A16E:  MOVLB  0
0A170:  CALL   4FD0
0A174:  MOVLW  2C
0A176:  MOVLB  6
0A178:  MOVWF  xA6
0A17A:  MOVLB  0
0A17C:  CALL   4A38
0A180:  MOVLW  89
0A182:  MOVWF  FE9
0A184:  MOVFF  694,69C
0A188:  MOVFF  693,69B
0A18C:  MOVFF  692,69A
0A190:  MOVFF  691,699
0A194:  MOVLW  03
0A196:  MOVLB  6
0A198:  MOVWF  x9D
0A19A:  MOVLB  0
0A19C:  CALL   5122
0A1A0:  MOVLW  0A
0A1A2:  MOVLB  6
0A1A4:  MOVWF  xA6
0A1A6:  MOVLB  0
0A1A8:  CALL   4A38
....................       if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0A1AC:  MOVLB  6
0A1AE:  MOVF   x8A,W
0A1B0:  MULLW  03
0A1B2:  MOVF   FF3,W
0A1B4:  CLRF   x91
0A1B6:  MOVWF  x90
0A1B8:  MOVLW  02
0A1BA:  ADDWF  x90,W
0A1BC:  MOVWF  01
0A1BE:  MOVLW  00
0A1C0:  ADDWFC x91,W
0A1C2:  MOVWF  03
0A1C4:  MOVF   01,W
0A1C6:  ADDLW  51
0A1C8:  MOVWF  FE9
0A1CA:  MOVLW  01
0A1CC:  ADDWFC 03,W
0A1CE:  MOVWF  FEA
0A1D0:  BTFSS  FEF.0
0A1D2:  BRA    A250
0A1D4:  MOVLW  01
0A1D6:  ADDWF  x8A,W
0A1D8:  MOVWF  x90
0A1DA:  MOVF   x8A,W
0A1DC:  MULLW  03
0A1DE:  MOVF   FF3,W
0A1E0:  CLRF   x92
0A1E2:  MOVWF  x91
0A1E4:  MOVLW  51
0A1E6:  ADDWF  x91,W
0A1E8:  MOVWF  FE9
0A1EA:  MOVLW  01
0A1EC:  ADDWFC x92,W
0A1EE:  MOVWF  FEA
0A1F0:  MOVFF  FEC,694
0A1F4:  MOVF   FED,F
0A1F6:  MOVFF  FEF,693
0A1FA:  MOVLW  76
0A1FC:  MOVWF  FF6
0A1FE:  MOVLW  03
0A200:  MOVWF  FF7
0A202:  MOVLW  08
0A204:  MOVWF  x99
0A206:  MOVLB  0
0A208:  CALL   4F7C
0A20C:  MOVFF  690,699
0A210:  MOVLW  1B
0A212:  MOVLB  6
0A214:  MOVWF  x9A
0A216:  MOVLB  0
0A218:  CALL   4FD0
0A21C:  MOVLW  80
0A21E:  MOVWF  FF6
0A220:  MOVLW  03
0A222:  MOVWF  FF7
0A224:  MOVLW  03
0A226:  MOVLB  6
0A228:  MOVWF  x99
0A22A:  MOVLB  0
0A22C:  CALL   4F7C
0A230:  MOVLW  10
0A232:  MOVWF  FE9
0A234:  MOVFF  694,696
0A238:  MOVFF  693,695
0A23C:  CALL   52D2
0A240:  MOVLW  0A
0A242:  MOVLB  6
0A244:  MOVWF  xA6
0A246:  MOVLB  0
0A248:  CALL   4A38
0A24C:  BRA    A2C8
0A24E:  MOVLB  6
....................       else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0A250:  MOVLW  01
0A252:  ADDWF  x8A,W
0A254:  MOVWF  x90
0A256:  MOVF   x8A,W
0A258:  MULLW  03
0A25A:  MOVF   FF3,W
0A25C:  CLRF   x92
0A25E:  MOVWF  x91
0A260:  MOVLW  51
0A262:  ADDWF  x91,W
0A264:  MOVWF  FE9
0A266:  MOVLW  01
0A268:  ADDWFC x92,W
0A26A:  MOVWF  FEA
0A26C:  MOVFF  FEC,694
0A270:  MOVF   FED,F
0A272:  MOVFF  FEF,693
0A276:  MOVLW  88
0A278:  MOVWF  FF6
0A27A:  MOVLW  03
0A27C:  MOVWF  FF7
0A27E:  MOVLW  08
0A280:  MOVWF  x99
0A282:  MOVLB  0
0A284:  CALL   4F7C
0A288:  MOVFF  690,699
0A28C:  MOVLW  1B
0A28E:  MOVLB  6
0A290:  MOVWF  x9A
0A292:  MOVLB  0
0A294:  CALL   4FD0
0A298:  MOVLW  92
0A29A:  MOVWF  FF6
0A29C:  MOVLW  03
0A29E:  MOVWF  FF7
0A2A0:  MOVLW  03
0A2A2:  MOVLB  6
0A2A4:  MOVWF  x99
0A2A6:  MOVLB  0
0A2A8:  CALL   4F7C
0A2AC:  MOVLW  10
0A2AE:  MOVWF  FE9
0A2B0:  MOVFF  694,696
0A2B4:  MOVFF  693,695
0A2B8:  CALL   52D2
0A2BC:  MOVLW  0A
0A2BE:  MOVLB  6
0A2C0:  MOVWF  xA6
0A2C2:  MOVLB  0
0A2C4:  CALL   4A38
....................       ch = !ch;
0A2C8:  MOVLB  6
0A2CA:  MOVF   x8A,F
0A2CC:  BZ    A2D2
0A2CE:  MOVLW  00
0A2D0:  BRA    A2D4
0A2D2:  MOVLW  01
0A2D4:  MOVWF  x8A
.................... //!      fprintf(SERIAL, "---------------\n");
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0A2D6:  MOVLB  0
0A2D8:  BRA    9B58
....................       
....................       delay_ms(250);
0A2DA:  MOVLW  FA
0A2DC:  MOVLB  6
0A2DE:  MOVWF  x98
0A2E0:  MOVLB  0
0A2E2:  CALL   0430
0A2E6:  BRA    A00A
....................    }
.................... }
0A2E8:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
