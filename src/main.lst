CCS PCH C Compiler, Version 5.117, 2138               25-Nov-25 16:18

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43788 bytes (67%)
                           Largest free fragment is 21746
               RAM used:   1601 (44%) at main() level
                           1718 (48%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A482
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025A
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0032E:  DATA 32,30
00330:  DATA 32,35
00332:  DATA 31,31
00334:  DATA 30,34
00336:  DATA 00,00
00338:  DATA 30,30
0033A:  DATA 30,30
0033C:  DATA 00,00
0033E:  DATA 25,64
00340:  DATA 2C,4D
00342:  DATA 41,4E
00344:  DATA 55,41
00346:  DATA 4C,2C
00348:  DATA 00,00
0034A:  DATA 25,64
0034C:  DATA 2C,4D
0034E:  DATA 41,47
00350:  DATA 53,4E
00352:  DATA 53,2C
00354:  DATA 00,00
00356:  DATA 23,44
00358:  DATA 30,2C
0035A:  DATA 43,4E
0035C:  DATA 54,2C
0035E:  DATA 25,75
00360:  DATA 2C,25
00362:  DATA 2E,30
00364:  DATA 66,2C
00366:  DATA 25,2E
00368:  DATA 30,66
0036A:  DATA 0A,00
0036C:  DATA 23,44
0036E:  DATA 30,2C
00370:  DATA 50,4F
00372:  DATA 53,2C
00374:  DATA 25,75
00376:  DATA 2C,25
00378:  DATA 33,2E
0037A:  DATA 33,66
0037C:  DATA 0A,00
0037E:  DATA 23,44
00380:  DATA 30,2C
00382:  DATA 4F,55
00384:  DATA 54,2C
00386:  DATA 25,75
00388:  DATA 2C,2D
0038A:  DATA 2C,25
0038C:  DATA 4C,75
0038E:  DATA 0A,00
00390:  DATA 23,44
00392:  DATA 30,2C
00394:  DATA 4F,55
00396:  DATA 54,2C
00398:  DATA 25,75
0039A:  DATA 2C,2B
0039C:  DATA 2C,25
0039E:  DATA 4C,75
003A0:  DATA 0A,00
*
006C8:  ADDWF  FE8,W
006CA:  CLRF   FF7
006CC:  RLCF   FF7,F
006CE:  ADDLW  E3
006D0:  MOVWF  FF6
006D2:  MOVLW  06
006D4:  ADDWFC FF7,F
006D6:  TBLRD*-
006D8:  MOVF   FF5,W
006DA:  MOVWF  FFA
006DC:  TBLRD*
006DE:  MOVF   FF5,W
006E0:  MOVWF  FF9
006E2:  DATA 92,06
006E4:  DATA 9C,06
006E6:  DATA A6,06
006E8:  DATA B0,06
*
00BBE:  MOVLB  6
00BC0:  MOVF   x79,W
00BC2:  MULWF  x7B
00BC4:  MOVFF  FF3,01
00BC8:  MOVFF  FF4,00
00BCC:  MULWF  x7C
00BCE:  MOVF   FF3,W
00BD0:  ADDWF  00,F
00BD2:  MOVF   x7A,W
00BD4:  MULWF  x7B
00BD6:  MOVF   FF3,W
00BD8:  ADDWFC 00,W
00BDA:  MOVWF  02
00BDC:  MOVLB  0
00BDE:  RETURN 0
*
00DB6:  MOVLW  8E
00DB8:  MOVWF  00
00DBA:  MOVFF  688,01
00DBE:  MOVFF  687,02
00DC2:  CLRF   03
00DC4:  MOVF   01,F
00DC6:  BNZ   0DDA
00DC8:  MOVFF  02,01
00DCC:  CLRF   02
00DCE:  MOVLW  08
00DD0:  SUBWF  00,F
00DD2:  MOVF   01,F
00DD4:  BNZ   0DDA
00DD6:  CLRF   00
00DD8:  BRA    0DEA
00DDA:  BCF    FD8.0
00DDC:  BTFSC  01.7
00DDE:  BRA    0DE8
00DE0:  RLCF   02,F
00DE2:  RLCF   01,F
00DE4:  DECF   00,F
00DE6:  BRA    0DDA
00DE8:  BCF    01.7
00DEA:  RETURN 0
00DEC:  MOVLB  6
00DEE:  MOVF   x88,W
00DF0:  BTFSC  FD8.2
00DF2:  BRA    0ED6
00DF4:  MOVWF  00
00DF6:  MOVF   x8C,W
00DF8:  BTFSC  FD8.2
00DFA:  BRA    0ED6
00DFC:  ADDWF  00,F
00DFE:  BNC   0E08
00E00:  MOVLW  81
00E02:  ADDWF  00,F
00E04:  BC    0ED6
00E06:  BRA    0E10
00E08:  MOVLW  7F
00E0A:  SUBWF  00,F
00E0C:  BNC   0ED6
00E0E:  BZ    0ED6
00E10:  MOVFF  689,690
00E14:  MOVF   x8D,W
00E16:  XORWF  x90,F
00E18:  BSF    x89.7
00E1A:  BSF    x8D.7
00E1C:  MOVF   x8B,W
00E1E:  MULWF  x8F
00E20:  MOVFF  FF4,692
00E24:  MOVF   x8A,W
00E26:  MULWF  x8E
00E28:  MOVFF  FF4,03
00E2C:  MOVFF  FF3,691
00E30:  MULWF  x8F
00E32:  MOVF   FF3,W
00E34:  ADDWF  x92,F
00E36:  MOVF   FF4,W
00E38:  ADDWFC x91,F
00E3A:  MOVLW  00
00E3C:  ADDWFC 03,F
00E3E:  MOVF   x8B,W
00E40:  MULWF  x8E
00E42:  MOVF   FF3,W
00E44:  ADDWF  x92,F
00E46:  MOVF   FF4,W
00E48:  ADDWFC x91,F
00E4A:  MOVLW  00
00E4C:  CLRF   02
00E4E:  ADDWFC 03,F
00E50:  ADDWFC 02,F
00E52:  MOVF   x89,W
00E54:  MULWF  x8F
00E56:  MOVF   FF3,W
00E58:  ADDWF  x91,F
00E5A:  MOVF   FF4,W
00E5C:  ADDWFC 03,F
00E5E:  MOVLW  00
00E60:  ADDWFC 02,F
00E62:  MOVF   x89,W
00E64:  MULWF  x8E
00E66:  MOVF   FF3,W
00E68:  ADDWF  03,F
00E6A:  MOVF   FF4,W
00E6C:  ADDWFC 02,F
00E6E:  MOVLW  00
00E70:  CLRF   01
00E72:  ADDWFC 01,F
00E74:  MOVF   x8B,W
00E76:  MULWF  x8D
00E78:  MOVF   FF3,W
00E7A:  ADDWF  x91,F
00E7C:  MOVF   FF4,W
00E7E:  ADDWFC 03,F
00E80:  MOVLW  00
00E82:  ADDWFC 02,F
00E84:  ADDWFC 01,F
00E86:  MOVF   x8A,W
00E88:  MULWF  x8D
00E8A:  MOVF   FF3,W
00E8C:  ADDWF  03,F
00E8E:  MOVF   FF4,W
00E90:  ADDWFC 02,F
00E92:  MOVLW  00
00E94:  ADDWFC 01,F
00E96:  MOVF   x89,W
00E98:  MULWF  x8D
00E9A:  MOVF   FF3,W
00E9C:  ADDWF  02,F
00E9E:  MOVF   FF4,W
00EA0:  ADDWFC 01,F
00EA2:  INCF   00,F
00EA4:  BTFSC  01.7
00EA6:  BRA    0EB2
00EA8:  RLCF   x91,F
00EAA:  RLCF   03,F
00EAC:  RLCF   02,F
00EAE:  RLCF   01,F
00EB0:  DECF   00,F
00EB2:  MOVLW  00
00EB4:  BTFSS  x91.7
00EB6:  BRA    0ECC
00EB8:  INCF   03,F
00EBA:  ADDWFC 02,F
00EBC:  ADDWFC 01,F
00EBE:  MOVF   01,W
00EC0:  BNZ   0ECC
00EC2:  MOVF   02,W
00EC4:  BNZ   0ECC
00EC6:  MOVF   03,W
00EC8:  BNZ   0ECC
00ECA:  INCF   00,F
00ECC:  BTFSC  x90.7
00ECE:  BSF    01.7
00ED0:  BTFSS  x90.7
00ED2:  BCF    01.7
00ED4:  BRA    0EDE
00ED6:  CLRF   00
00ED8:  CLRF   01
00EDA:  CLRF   02
00EDC:  CLRF   03
00EDE:  MOVLB  0
00EE0:  RETURN 0
00EE2:  MOVLW  80
00EE4:  BTFSS  FD8.1
00EE6:  BRA    0EEC
00EE8:  MOVLB  6
00EEA:  XORWF  x8C,F
00EEC:  MOVLB  6
00EEE:  CLRF   x91
00EF0:  CLRF   x92
00EF2:  MOVFF  688,690
00EF6:  MOVF   x8C,W
00EF8:  XORWF  x90,F
00EFA:  MOVF   x87,W
00EFC:  BTFSC  FD8.2
00EFE:  BRA    10BE
00F00:  MOVWF  x8F
00F02:  MOVWF  00
00F04:  MOVF   x8B,W
00F06:  BTFSC  FD8.2
00F08:  BRA    10D0
00F0A:  SUBWF  x8F,F
00F0C:  BTFSC  FD8.2
00F0E:  BRA    1016
00F10:  BNC   0F8E
00F12:  MOVFF  68C,695
00F16:  BSF    x95.7
00F18:  MOVFF  68D,694
00F1C:  MOVFF  68E,693
00F20:  CLRF   x92
00F22:  BCF    FD8.0
00F24:  RRCF   x95,F
00F26:  RRCF   x94,F
00F28:  RRCF   x93,F
00F2A:  RRCF   x92,F
00F2C:  DECFSZ x8F,F
00F2E:  BRA    0F20
00F30:  BTFSS  x90.7
00F32:  BRA    0F3A
00F34:  BSF    x91.0
00F36:  BRA    10F8
00F38:  BCF    x91.0
00F3A:  BCF    x8F.0
00F3C:  BSF    x91.4
00F3E:  MOVLW  06
00F40:  MOVWF  FEA
00F42:  MOVLW  8A
00F44:  MOVWF  FE9
00F46:  BRA    111E
00F48:  BCF    x91.4
00F4A:  BTFSC  x90.7
00F4C:  BRA    0F62
00F4E:  BTFSS  x8F.0
00F50:  BRA    0F78
00F52:  RRCF   x95,F
00F54:  RRCF   x94,F
00F56:  RRCF   x93,F
00F58:  RRCF   x92,F
00F5A:  INCF   00,F
00F5C:  BTFSC  FD8.2
00F5E:  BRA    10EE
00F60:  BRA    0F78
00F62:  BTFSC  x95.7
00F64:  BRA    0F7E
00F66:  BCF    FD8.0
00F68:  RLCF   x92,F
00F6A:  RLCF   x93,F
00F6C:  RLCF   x94,F
00F6E:  RLCF   x95,F
00F70:  DECF   00,F
00F72:  BTFSC  FD8.2
00F74:  BRA    10EE
00F76:  BRA    0F62
00F78:  BSF    x91.6
00F7A:  BRA    1056
00F7C:  BCF    x91.6
00F7E:  MOVFF  688,690
00F82:  BTFSS  x88.7
00F84:  BRA    0F8A
00F86:  BSF    x95.7
00F88:  BRA    10E0
00F8A:  BCF    x95.7
00F8C:  BRA    10E0
00F8E:  MOVFF  68B,68F
00F92:  MOVFF  68B,00
00F96:  MOVF   x87,W
00F98:  SUBWF  x8F,F
00F9A:  MOVFF  688,695
00F9E:  BSF    x95.7
00FA0:  MOVFF  689,694
00FA4:  MOVFF  68A,693
00FA8:  CLRF   x92
00FAA:  BCF    FD8.0
00FAC:  RRCF   x95,F
00FAE:  RRCF   x94,F
00FB0:  RRCF   x93,F
00FB2:  RRCF   x92,F
00FB4:  DECFSZ x8F,F
00FB6:  BRA    0FA8
00FB8:  BTFSS  x90.7
00FBA:  BRA    0FC2
00FBC:  BSF    x91.1
00FBE:  BRA    10F8
00FC0:  BCF    x91.1
00FC2:  BCF    x8F.0
00FC4:  BSF    x91.5
00FC6:  MOVLW  06
00FC8:  MOVWF  FEA
00FCA:  MOVLW  8E
00FCC:  MOVWF  FE9
00FCE:  BRA    111E
00FD0:  BCF    x91.5
00FD2:  BTFSC  x90.7
00FD4:  BRA    0FEA
00FD6:  BTFSS  x8F.0
00FD8:  BRA    1000
00FDA:  RRCF   x95,F
00FDC:  RRCF   x94,F
00FDE:  RRCF   x93,F
00FE0:  RRCF   x92,F
00FE2:  INCF   00,F
00FE4:  BTFSC  FD8.2
00FE6:  BRA    10EE
00FE8:  BRA    1000
00FEA:  BTFSC  x95.7
00FEC:  BRA    1006
00FEE:  BCF    FD8.0
00FF0:  RLCF   x92,F
00FF2:  RLCF   x93,F
00FF4:  RLCF   x94,F
00FF6:  RLCF   x95,F
00FF8:  DECF   00,F
00FFA:  BTFSC  FD8.2
00FFC:  BRA    10EE
00FFE:  BRA    0FEA
01000:  BSF    x91.7
01002:  BRA    1056
01004:  BCF    x91.7
01006:  MOVFF  68C,690
0100A:  BTFSS  x8C.7
0100C:  BRA    1012
0100E:  BSF    x95.7
01010:  BRA    10E0
01012:  BCF    x95.7
01014:  BRA    10E0
01016:  MOVFF  68C,695
0101A:  BSF    x95.7
0101C:  MOVFF  68D,694
01020:  MOVFF  68E,693
01024:  BTFSS  x90.7
01026:  BRA    1030
01028:  BCF    x95.7
0102A:  BSF    x91.2
0102C:  BRA    10F8
0102E:  BCF    x91.2
01030:  CLRF   x92
01032:  BCF    x8F.0
01034:  MOVLW  06
01036:  MOVWF  FEA
01038:  MOVLW  8A
0103A:  MOVWF  FE9
0103C:  BRA    111E
0103E:  BTFSC  x90.7
01040:  BRA    107A
01042:  MOVFF  688,690
01046:  BTFSS  x8F.0
01048:  BRA    1056
0104A:  RRCF   x95,F
0104C:  RRCF   x94,F
0104E:  RRCF   x93,F
01050:  RRCF   x92,F
01052:  INCF   00,F
01054:  BZ    10EE
01056:  BTFSS  x92.7
01058:  BRA    1070
0105A:  INCF   x93,F
0105C:  BNZ   1070
0105E:  INCF   x94,F
01060:  BNZ   1070
01062:  INCF   x95,F
01064:  BNZ   1070
01066:  RRCF   x95,F
01068:  RRCF   x94,F
0106A:  RRCF   x93,F
0106C:  INCF   00,F
0106E:  BZ    10EE
01070:  BTFSC  x91.6
01072:  BRA    0F7C
01074:  BTFSC  x91.7
01076:  BRA    1004
01078:  BRA    10B2
0107A:  MOVLW  80
0107C:  XORWF  x95,F
0107E:  BTFSS  x95.7
01080:  BRA    108A
01082:  BRA    10F8
01084:  MOVFF  68C,690
01088:  BRA    109E
0108A:  MOVFF  688,690
0108E:  MOVF   x95,F
01090:  BNZ   109E
01092:  MOVF   x94,F
01094:  BNZ   109E
01096:  MOVF   x93,F
01098:  BNZ   109E
0109A:  CLRF   00
0109C:  BRA    10E0
0109E:  BTFSC  x95.7
010A0:  BRA    10B2
010A2:  BCF    FD8.0
010A4:  RLCF   x92,F
010A6:  RLCF   x93,F
010A8:  RLCF   x94,F
010AA:  RLCF   x95,F
010AC:  DECFSZ 00,F
010AE:  BRA    109E
010B0:  BRA    10EE
010B2:  BTFSS  x90.7
010B4:  BRA    10BA
010B6:  BSF    x95.7
010B8:  BRA    10E0
010BA:  BCF    x95.7
010BC:  BRA    10E0
010BE:  MOVFF  68B,00
010C2:  MOVFF  68C,695
010C6:  MOVFF  68D,694
010CA:  MOVFF  68E,693
010CE:  BRA    10E0
010D0:  MOVFF  687,00
010D4:  MOVFF  688,695
010D8:  MOVFF  689,694
010DC:  MOVFF  68A,693
010E0:  MOVFF  695,01
010E4:  MOVFF  694,02
010E8:  MOVFF  693,03
010EC:  BRA    1156
010EE:  CLRF   00
010F0:  CLRF   01
010F2:  CLRF   02
010F4:  CLRF   03
010F6:  BRA    1156
010F8:  CLRF   x92
010FA:  COMF   x93,F
010FC:  COMF   x94,F
010FE:  COMF   x95,F
01100:  COMF   x92,F
01102:  INCF   x92,F
01104:  BNZ   1110
01106:  INCF   x93,F
01108:  BNZ   1110
0110A:  INCF   x94,F
0110C:  BNZ   1110
0110E:  INCF   x95,F
01110:  BTFSC  x91.0
01112:  BRA    0F38
01114:  BTFSC  x91.1
01116:  BRA    0FC0
01118:  BTFSC  x91.2
0111A:  BRA    102E
0111C:  BRA    1084
0111E:  MOVF   FEF,W
01120:  ADDWF  x93,F
01122:  BNC   112E
01124:  INCF   x94,F
01126:  BNZ   112E
01128:  INCF   x95,F
0112A:  BTFSC  FD8.2
0112C:  BSF    x8F.0
0112E:  MOVF   FED,F
01130:  MOVF   FEF,W
01132:  ADDWF  x94,F
01134:  BNC   113C
01136:  INCF   x95,F
01138:  BTFSC  FD8.2
0113A:  BSF    x8F.0
0113C:  MOVF   FED,F
0113E:  MOVF   FEF,W
01140:  BTFSC  FEF.7
01142:  BRA    1146
01144:  XORLW  80
01146:  ADDWF  x95,F
01148:  BTFSC  FD8.0
0114A:  BSF    x8F.0
0114C:  BTFSC  x91.4
0114E:  BRA    0F48
01150:  BTFSC  x91.5
01152:  BRA    0FD0
01154:  BRA    103E
01156:  MOVLB  0
01158:  RETURN 0
*
016B0:  ADDWF  FE8,W
016B2:  CLRF   FF7
016B4:  RLCF   FF7,F
016B6:  ADDLW  CB
016B8:  MOVWF  FF6
016BA:  MOVLW  16
016BC:  ADDWFC FF7,F
016BE:  TBLRD*-
016C0:  MOVF   FF5,W
016C2:  MOVWF  FFA
016C4:  TBLRD*
016C6:  MOVF   FF5,W
016C8:  MOVWF  FF9
016CA:  DATA 72,11
016CC:  DATA 32,12
016CE:  DATA F2,12
016D0:  DATA B2,13
016D2:  DATA 72,14
016D4:  DATA 32,15
016D6:  DATA F2,15
*
01F40:  MOVLW  B6
01F42:  MOVWF  00
01F44:  CLRF   03
01F46:  CLRF   02
01F48:  CLRF   01
01F4A:  MOVLB  6
01F4C:  BCF    x51.0
01F4E:  BTFSS  x50.7
01F50:  BRA    1F6A
01F52:  BSF    x51.0
01F54:  COMF   x4D,F
01F56:  COMF   x4E,F
01F58:  COMF   x4F,F
01F5A:  COMF   x50,F
01F5C:  INCF   x4D,F
01F5E:  BNZ   1F6A
01F60:  INCF   x4E,F
01F62:  BNZ   1F6A
01F64:  INCF   x4F,F
01F66:  BTFSC  FD8.2
01F68:  INCF   x50,F
01F6A:  MOVF   x4D,W
01F6C:  IORWF  x4E,W
01F6E:  IORWF  x4F,W
01F70:  IORWF  x50,W
01F72:  BNZ   1F78
01F74:  CLRF   00
01F76:  BRA    1F96
01F78:  BCF    FD8.0
01F7A:  BTFSC  01.7
01F7C:  BRA    1F90
01F7E:  RLCF   x4D,F
01F80:  RLCF   x4E,F
01F82:  RLCF   x4F,F
01F84:  RLCF   x50,F
01F86:  RLCF   03,F
01F88:  RLCF   02,F
01F8A:  RLCF   01,F
01F8C:  DECFSZ 00,F
01F8E:  BRA    1F78
01F90:  BCF    01.7
01F92:  BTFSC  x51.0
01F94:  BSF    01.7
01F96:  MOVLB  0
01F98:  RETURN 0
01F9A:  MOVFF  684,68B
01F9E:  MOVLB  6
01FA0:  MOVF   x88,W
01FA2:  XORWF  x8B,F
01FA4:  BTFSS  x8B.7
01FA6:  BRA    1FB2
01FA8:  BCF    FD8.2
01FAA:  BCF    FD8.0
01FAC:  BTFSC  x84.7
01FAE:  BSF    FD8.0
01FB0:  BRA    2010
01FB2:  MOVFF  684,68B
01FB6:  MOVFF  687,68C
01FBA:  MOVF   x83,W
01FBC:  SUBWF  x8C,F
01FBE:  BZ    1FCC
01FC0:  BTFSS  x8B.7
01FC2:  BRA    2010
01FC4:  MOVF   FD8,W
01FC6:  XORLW  01
01FC8:  MOVWF  FD8
01FCA:  BRA    2010
01FCC:  MOVFF  688,68C
01FD0:  MOVF   x84,W
01FD2:  SUBWF  x8C,F
01FD4:  BZ    1FE2
01FD6:  BTFSS  x8B.7
01FD8:  BRA    2010
01FDA:  MOVF   FD8,W
01FDC:  XORLW  01
01FDE:  MOVWF  FD8
01FE0:  BRA    2010
01FE2:  MOVFF  689,68C
01FE6:  MOVF   x85,W
01FE8:  SUBWF  x8C,F
01FEA:  BZ    1FF8
01FEC:  BTFSS  x8B.7
01FEE:  BRA    2010
01FF0:  MOVF   FD8,W
01FF2:  XORLW  01
01FF4:  MOVWF  FD8
01FF6:  BRA    2010
01FF8:  MOVFF  68A,68C
01FFC:  MOVF   x86,W
01FFE:  SUBWF  x8C,F
02000:  BZ    200E
02002:  BTFSS  x8B.7
02004:  BRA    2010
02006:  MOVF   FD8,W
02008:  XORLW  01
0200A:  MOVWF  FD8
0200C:  BRA    2010
0200E:  BCF    FD8.0
02010:  MOVLB  0
02012:  RETURN 0
02014:  MOVLB  6
02016:  MOVF   x7C,W
02018:  BTFSC  FD8.2
0201A:  BRA    2166
0201C:  MOVWF  x88
0201E:  MOVF   x80,W
02020:  BTFSC  FD8.2
02022:  BRA    2166
02024:  SUBWF  x88,F
02026:  BNC   2032
02028:  MOVLW  7F
0202A:  ADDWF  x88,F
0202C:  BTFSC  FD8.0
0202E:  BRA    2166
02030:  BRA    203E
02032:  MOVLW  81
02034:  SUBWF  x88,F
02036:  BTFSS  FD8.0
02038:  BRA    2166
0203A:  BTFSC  FD8.2
0203C:  BRA    2166
0203E:  MOVFF  688,00
02042:  CLRF   01
02044:  CLRF   02
02046:  CLRF   03
02048:  CLRF   x87
0204A:  MOVFF  67D,686
0204E:  BSF    x86.7
02050:  MOVFF  67E,685
02054:  MOVFF  67F,684
02058:  MOVLW  19
0205A:  MOVWF  x88
0205C:  MOVF   x83,W
0205E:  SUBWF  x84,F
02060:  BC    207C
02062:  MOVLW  01
02064:  SUBWF  x85,F
02066:  BC    207C
02068:  SUBWF  x86,F
0206A:  BC    207C
0206C:  SUBWF  x87,F
0206E:  BC    207C
02070:  INCF   x87,F
02072:  INCF   x86,F
02074:  INCF   x85,F
02076:  MOVF   x83,W
02078:  ADDWF  x84,F
0207A:  BRA    20CC
0207C:  MOVF   x82,W
0207E:  SUBWF  x85,F
02080:  BC    20A6
02082:  MOVLW  01
02084:  SUBWF  x86,F
02086:  BC    20A6
02088:  SUBWF  x87,F
0208A:  BC    20A6
0208C:  INCF   x87,F
0208E:  INCF   x86,F
02090:  MOVF   x82,W
02092:  ADDWF  x85,F
02094:  MOVF   x83,W
02096:  ADDWF  x84,F
02098:  BNC   20CC
0209A:  INCF   x85,F
0209C:  BNZ   20CC
0209E:  INCF   x86,F
020A0:  BNZ   20CC
020A2:  INCF   x87,F
020A4:  BRA    20CC
020A6:  MOVF   x81,W
020A8:  IORLW  80
020AA:  SUBWF  x86,F
020AC:  BC    20CA
020AE:  MOVLW  01
020B0:  SUBWF  x87,F
020B2:  BC    20CA
020B4:  INCF   x87,F
020B6:  MOVF   x81,W
020B8:  IORLW  80
020BA:  ADDWF  x86,F
020BC:  MOVF   x82,W
020BE:  ADDWF  x85,F
020C0:  BNC   2094
020C2:  INCF   x86,F
020C4:  BNZ   2094
020C6:  INCF   x87,F
020C8:  BRA    2094
020CA:  BSF    03.0
020CC:  DECFSZ x88,F
020CE:  BRA    20D2
020D0:  BRA    20E8
020D2:  BCF    FD8.0
020D4:  RLCF   x84,F
020D6:  RLCF   x85,F
020D8:  RLCF   x86,F
020DA:  RLCF   x87,F
020DC:  BCF    FD8.0
020DE:  RLCF   03,F
020E0:  RLCF   02,F
020E2:  RLCF   01,F
020E4:  RLCF   x89,F
020E6:  BRA    205C
020E8:  BTFSS  x89.0
020EA:  BRA    20F8
020EC:  BCF    FD8.0
020EE:  RRCF   01,F
020F0:  RRCF   02,F
020F2:  RRCF   03,F
020F4:  RRCF   x89,F
020F6:  BRA    20FC
020F8:  DECF   00,F
020FA:  BZ    2166
020FC:  BTFSC  x89.7
020FE:  BRA    213C
02100:  BCF    FD8.0
02102:  RLCF   x84,F
02104:  RLCF   x85,F
02106:  RLCF   x86,F
02108:  RLCF   x87,F
0210A:  MOVF   x83,W
0210C:  SUBWF  x84,F
0210E:  BC    211E
02110:  MOVLW  01
02112:  SUBWF  x85,F
02114:  BC    211E
02116:  SUBWF  x86,F
02118:  BC    211E
0211A:  SUBWF  x87,F
0211C:  BNC   2152
0211E:  MOVF   x82,W
02120:  SUBWF  x85,F
02122:  BC    212E
02124:  MOVLW  01
02126:  SUBWF  x86,F
02128:  BC    212E
0212A:  SUBWF  x87,F
0212C:  BNC   2152
0212E:  MOVF   x81,W
02130:  IORLW  80
02132:  SUBWF  x86,F
02134:  BC    213C
02136:  MOVLW  01
02138:  SUBWF  x87,F
0213A:  BNC   2152
0213C:  INCF   03,F
0213E:  BNZ   2152
02140:  INCF   02,F
02142:  BNZ   2152
02144:  INCF   01,F
02146:  BNZ   2152
02148:  INCF   00,F
0214A:  BZ    2166
0214C:  RRCF   01,F
0214E:  RRCF   02,F
02150:  RRCF   03,F
02152:  MOVFF  67D,688
02156:  MOVF   x81,W
02158:  XORWF  x88,F
0215A:  BTFSS  x88.7
0215C:  BRA    2162
0215E:  BSF    01.7
02160:  BRA    216E
02162:  BCF    01.7
02164:  BRA    216E
02166:  CLRF   00
02168:  CLRF   01
0216A:  CLRF   02
0216C:  CLRF   03
0216E:  MOVLB  0
02170:  RETURN 0
*
0291C:  ADDWF  FE8,W
0291E:  CLRF   FF7
02920:  RLCF   FF7,F
02922:  ADDLW  37
02924:  MOVWF  FF6
02926:  MOVLW  29
02928:  ADDWFC FF7,F
0292A:  TBLRD*-
0292C:  MOVF   FF5,W
0292E:  MOVWF  FFA
02930:  TBLRD*
02932:  MOVF   FF5,W
02934:  MOVWF  FF9
02936:  DATA 24,28
02938:  DATA 3E,28
0293A:  DATA 92,28
0293C:  DATA F6,28
0293E:  MOVLW  8E
02940:  MOVWF  00
02942:  MOVFF  67A,01
02946:  MOVFF  679,02
0294A:  CLRF   03
0294C:  BTFSS  01.7
0294E:  BRA    295A
02950:  COMF   01,F
02952:  COMF   02,F
02954:  INCF   02,F
02956:  BNZ   295A
02958:  INCF   01,F
0295A:  MOVF   01,F
0295C:  BNZ   2970
0295E:  MOVFF  02,01
02962:  CLRF   02
02964:  MOVLW  08
02966:  SUBWF  00,F
02968:  MOVF   01,F
0296A:  BNZ   2970
0296C:  CLRF   00
0296E:  BRA    298C
02970:  BCF    FD8.0
02972:  BTFSC  01.7
02974:  BRA    297E
02976:  RLCF   02,F
02978:  RLCF   01,F
0297A:  DECF   00,F
0297C:  BRA    2970
0297E:  MOVLB  6
02980:  BTFSS  x7A.7
02982:  BRA    2988
02984:  MOVLB  0
02986:  BRA    298C
02988:  BCF    01.7
0298A:  MOVLB  0
0298C:  RETURN 0
0298E:  MOVLW  8E
02990:  MOVWF  00
02992:  MOVLB  6
02994:  MOVF   x83,W
02996:  SUBWF  00,F
02998:  MOVFF  684,02
0299C:  MOVFF  685,01
029A0:  BSF    02.7
029A2:  MOVF   00,F
029A4:  BZ    29B8
029A6:  BCF    FD8.0
029A8:  MOVF   02,F
029AA:  BNZ   29B0
029AC:  MOVF   01,F
029AE:  BZ    29B8
029B0:  RRCF   02,F
029B2:  RRCF   01,F
029B4:  DECFSZ 00,F
029B6:  BRA    29A6
029B8:  BTFSS  x84.7
029BA:  BRA    29C6
029BC:  COMF   01,F
029BE:  COMF   02,F
029C0:  INCF   01,F
029C2:  BTFSC  FD8.2
029C4:  INCF   02,F
029C6:  MOVLB  0
029C8:  RETURN 0
*
04806:  MOVLB  6
04808:  MOVF   x45,W
0480A:  ANDLW  07
0480C:  MOVWF  00
0480E:  RRCF   x45,W
04810:  MOVWF  01
04812:  RRCF   01,F
04814:  RRCF   01,F
04816:  MOVLW  1F
04818:  ANDWF  01,F
0481A:  MOVF   01,W
0481C:  ADDWF  x46,W
0481E:  MOVWF  FE9
04820:  MOVLW  00
04822:  ADDWFC x47,W
04824:  MOVWF  FEA
04826:  MOVFF  FEF,01
0482A:  INCF   00,F
0482C:  BRA    4830
0482E:  RRCF   01,F
04830:  DECFSZ 00,F
04832:  BRA    482E
04834:  MOVLW  01
04836:  ANDWF  01,F
04838:  MOVLB  0
0483A:  RETURN 0
*
0523C:  MOVF   FEF,F
0523E:  BZ    525E
05240:  MOVFF  FEA,63E
05244:  MOVFF  FE9,63D
05248:  MOVFF  FEF,64E
0524C:  RCALL  5214
0524E:  MOVFF  63E,FEA
05252:  MOVFF  63D,FE9
05256:  INCF   FE9,F
05258:  BTFSC  FD8.2
0525A:  INCF   FEA,F
0525C:  BRA    523C
0525E:  RETURN 0
*
05758:  TBLRD*+
0575A:  MOVFF  FF6,642
0575E:  MOVFF  FF7,643
05762:  MOVFF  FF5,64E
05766:  RCALL  5214
05768:  MOVFF  642,FF6
0576C:  MOVFF  643,FF7
05770:  MOVLB  6
05772:  DECFSZ x41,F
05774:  BRA    5778
05776:  BRA    577C
05778:  MOVLB  0
0577A:  BRA    5758
0577C:  MOVLB  0
0577E:  RETURN 0
05780:  MOVLB  6
05782:  MOVF   x73,W
05784:  CLRF   01
05786:  SUBWF  x72,W
05788:  BC    5790
0578A:  MOVFF  672,00
0578E:  BRA    57A8
05790:  CLRF   00
05792:  MOVLW  08
05794:  MOVWF  x74
05796:  RLCF   x72,F
05798:  RLCF   00,F
0579A:  MOVF   x73,W
0579C:  SUBWF  00,W
0579E:  BTFSC  FD8.0
057A0:  MOVWF  00
057A2:  RLCF   01,F
057A4:  DECFSZ x74,F
057A6:  BRA    5796
057A8:  MOVLB  0
057AA:  RETURN 0
057AC:  MOVF   01,W
057AE:  MOVFF  641,672
057B2:  MOVLW  64
057B4:  MOVLB  6
057B6:  MOVWF  x73
057B8:  MOVLB  0
057BA:  RCALL  5780
057BC:  MOVFF  00,641
057C0:  MOVF   01,W
057C2:  MOVLW  30
057C4:  BNZ   57D6
057C6:  MOVLB  6
057C8:  BTFSS  x42.1
057CA:  BRA    57EA
057CC:  BTFSC  x42.3
057CE:  BRA    57EA
057D0:  BTFSC  x42.4
057D2:  MOVLW  20
057D4:  BRA    57DE
057D6:  MOVLB  6
057D8:  BCF    x42.3
057DA:  BCF    x42.4
057DC:  BSF    x42.0
057DE:  ADDWF  01,F
057E0:  MOVFF  01,64E
057E4:  MOVLB  0
057E6:  RCALL  5214
057E8:  MOVLB  6
057EA:  MOVFF  641,672
057EE:  MOVLW  0A
057F0:  MOVWF  x73
057F2:  MOVLB  0
057F4:  RCALL  5780
057F6:  MOVFF  00,641
057FA:  MOVF   01,W
057FC:  MOVLW  30
057FE:  BNZ   5810
05800:  MOVLB  6
05802:  BTFSC  x42.3
05804:  BRA    581A
05806:  BTFSS  x42.0
05808:  BRA    581A
0580A:  BTFSC  x42.4
0580C:  MOVLW  20
0580E:  MOVLB  0
05810:  ADDWF  01,F
05812:  MOVFF  01,64E
05816:  RCALL  5214
05818:  MOVLB  6
0581A:  MOVLW  30
0581C:  ADDWF  x41,F
0581E:  MOVFF  641,64E
05822:  MOVLB  0
05824:  RCALL  5214
05826:  RETURN 0
05828:  MOVLB  6
0582A:  MOVF   x88,W
0582C:  SUBLW  B6
0582E:  MOVWF  x88
05830:  CLRF   03
05832:  MOVFF  689,68C
05836:  BSF    x89.7
05838:  BCF    FD8.0
0583A:  RRCF   x89,F
0583C:  RRCF   x8A,F
0583E:  RRCF   x8B,F
05840:  RRCF   03,F
05842:  RRCF   02,F
05844:  RRCF   01,F
05846:  RRCF   00,F
05848:  DECFSZ x88,F
0584A:  BRA    5838
0584C:  BTFSS  x8C.7
0584E:  BRA    5866
05850:  COMF   00,F
05852:  COMF   01,F
05854:  COMF   02,F
05856:  COMF   03,F
05858:  INCF   00,F
0585A:  BTFSC  FD8.2
0585C:  INCF   01,F
0585E:  BTFSC  FD8.2
05860:  INCF   02,F
05862:  BTFSC  FD8.2
05864:  INCF   03,F
05866:  MOVLB  0
05868:  RETURN 0
0586A:  BTFSC  FD8.1
0586C:  BRA    5876
0586E:  MOVLW  06
05870:  MOVWF  FEA
05872:  MOVLW  90
05874:  MOVWF  FE9
05876:  CLRF   00
05878:  CLRF   01
0587A:  CLRF   02
0587C:  CLRF   03
0587E:  MOVLB  6
05880:  CLRF   x90
05882:  CLRF   x91
05884:  CLRF   x92
05886:  CLRF   x93
05888:  MOVF   x8F,W
0588A:  IORWF  x8E,W
0588C:  IORWF  x8D,W
0588E:  IORWF  x8C,W
05890:  BZ    58EA
05892:  MOVLW  20
05894:  MOVWF  x94
05896:  BCF    FD8.0
05898:  RLCF   x88,F
0589A:  RLCF   x89,F
0589C:  RLCF   x8A,F
0589E:  RLCF   x8B,F
058A0:  RLCF   x90,F
058A2:  RLCF   x91,F
058A4:  RLCF   x92,F
058A6:  RLCF   x93,F
058A8:  MOVF   x8F,W
058AA:  SUBWF  x93,W
058AC:  BNZ   58BE
058AE:  MOVF   x8E,W
058B0:  SUBWF  x92,W
058B2:  BNZ   58BE
058B4:  MOVF   x8D,W
058B6:  SUBWF  x91,W
058B8:  BNZ   58BE
058BA:  MOVF   x8C,W
058BC:  SUBWF  x90,W
058BE:  BNC   58DE
058C0:  MOVF   x8C,W
058C2:  SUBWF  x90,F
058C4:  MOVF   x8D,W
058C6:  BTFSS  FD8.0
058C8:  INCFSZ x8D,W
058CA:  SUBWF  x91,F
058CC:  MOVF   x8E,W
058CE:  BTFSS  FD8.0
058D0:  INCFSZ x8E,W
058D2:  SUBWF  x92,F
058D4:  MOVF   x8F,W
058D6:  BTFSS  FD8.0
058D8:  INCFSZ x8F,W
058DA:  SUBWF  x93,F
058DC:  BSF    FD8.0
058DE:  RLCF   00,F
058E0:  RLCF   01,F
058E2:  RLCF   02,F
058E4:  RLCF   03,F
058E6:  DECFSZ x94,F
058E8:  BRA    5896
058EA:  MOVFF  690,FEF
058EE:  MOVFF  691,FEC
058F2:  MOVFF  692,FEC
058F6:  MOVFF  693,FEC
058FA:  MOVLB  0
058FC:  RETURN 0
058FE:  MOVF   FE9,W
05900:  MOVLB  6
05902:  MOVWF  x46
05904:  MOVF   x45,W
05906:  MOVWF  x48
05908:  BZ    5942
0590A:  MOVFF  644,68B
0590E:  MOVFF  643,68A
05912:  MOVFF  642,689
05916:  MOVFF  641,688
0591A:  CLRF   x8F
0591C:  CLRF   x8E
0591E:  MOVLW  20
05920:  MOVWF  x8D
05922:  MOVLW  82
05924:  MOVWF  x8C
05926:  MOVLB  0
05928:  CALL   0DEC
0592C:  MOVFF  03,644
05930:  MOVFF  02,643
05934:  MOVFF  01,642
05938:  MOVFF  00,641
0593C:  MOVLB  6
0593E:  DECFSZ x48,F
05940:  BRA    590A
05942:  MOVFF  644,68B
05946:  MOVFF  643,68A
0594A:  MOVFF  642,689
0594E:  MOVFF  641,688
05952:  MOVLB  0
05954:  RCALL  5828
05956:  MOVFF  03,644
0595A:  MOVFF  02,643
0595E:  MOVFF  01,642
05962:  MOVFF  00,641
05966:  MOVLB  6
05968:  BTFSS  x44.7
0596A:  BRA    5986
0596C:  DECF   x46,F
0596E:  BSF    x46.5
05970:  COMF   x41,F
05972:  COMF   x42,F
05974:  COMF   x43,F
05976:  COMF   x44,F
05978:  INCF   x41,F
0597A:  BTFSC  FD8.2
0597C:  INCF   x42,F
0597E:  BTFSC  FD8.2
05980:  INCF   x43,F
05982:  BTFSC  FD8.2
05984:  INCF   x44,F
05986:  MOVLW  3B
05988:  MOVWF  x4D
0598A:  MOVLW  9A
0598C:  MOVWF  x4C
0598E:  MOVLW  CA
05990:  MOVWF  x4B
05992:  CLRF   x4A
05994:  MOVLW  0A
05996:  MOVWF  x48
05998:  MOVF   x45,W
0599A:  BTFSC  FD8.2
0599C:  INCF   x46,F
0599E:  BSF    FD8.1
059A0:  MOVLW  06
059A2:  MOVWF  FEA
059A4:  MOVLW  41
059A6:  MOVWF  FE9
059A8:  MOVFF  644,68B
059AC:  MOVFF  643,68A
059B0:  MOVFF  642,689
059B4:  MOVFF  641,688
059B8:  MOVFF  64D,68F
059BC:  MOVFF  64C,68E
059C0:  MOVFF  64B,68D
059C4:  MOVFF  64A,68C
059C8:  MOVLB  0
059CA:  RCALL  586A
059CC:  MOVF   01,W
059CE:  MOVF   00,F
059D0:  BNZ   59F8
059D2:  MOVLB  6
059D4:  INCF   x45,W
059D6:  SUBWF  x48,W
059D8:  BTFSS  FD8.2
059DA:  BRA    59E0
059DC:  MOVLB  0
059DE:  BRA    59F8
059E0:  MOVF   x46,W
059E2:  BZ    59FE
059E4:  ANDLW  0F
059E6:  SUBWF  x48,W
059E8:  BZ    59EC
059EA:  BC    5A74
059EC:  BTFSC  x46.7
059EE:  BRA    5A74
059F0:  BTFSC  x46.6
059F2:  BRA    59FE
059F4:  MOVLW  20
059F6:  BRA    5A66
059F8:  MOVLW  20
059FA:  MOVLB  6
059FC:  ANDWF  x46,F
059FE:  BTFSS  x46.5
05A00:  BRA    5A20
05A02:  BCF    x46.5
05A04:  MOVF   x45,W
05A06:  BTFSS  FD8.2
05A08:  DECF   x46,F
05A0A:  MOVF   00,W
05A0C:  MOVWF  x46
05A0E:  MOVLW  2D
05A10:  MOVWF  x4E
05A12:  MOVLB  0
05A14:  CALL   5214
05A18:  MOVLB  6
05A1A:  MOVF   x46,W
05A1C:  MOVWF  00
05A1E:  CLRF   x46
05A20:  MOVF   x45,W
05A22:  SUBWF  x48,W
05A24:  BNZ   5A40
05A26:  MOVF   00,W
05A28:  MOVWF  x46
05A2A:  MOVLW  2E
05A2C:  MOVWF  x4E
05A2E:  MOVLB  0
05A30:  CALL   5214
05A34:  MOVLB  6
05A36:  MOVF   x46,W
05A38:  MOVWF  00
05A3A:  MOVLW  20
05A3C:  ANDWF  x46,F
05A3E:  MOVLW  00
05A40:  MOVLW  30
05A42:  BTFSS  x46.5
05A44:  BRA    5A66
05A46:  BCF    x46.5
05A48:  MOVF   x45,W
05A4A:  BTFSS  FD8.2
05A4C:  DECF   x46,F
05A4E:  MOVF   00,W
05A50:  MOVWF  x46
05A52:  MOVLW  2D
05A54:  MOVWF  x4E
05A56:  MOVLB  0
05A58:  CALL   5214
05A5C:  MOVLB  6
05A5E:  MOVF   x46,W
05A60:  MOVWF  00
05A62:  CLRF   x46
05A64:  MOVLW  30
05A66:  ADDWF  00,F
05A68:  MOVFF  00,64E
05A6C:  MOVLB  0
05A6E:  CALL   5214
05A72:  MOVLB  6
05A74:  BCF    FD8.1
05A76:  MOVFF  64D,68B
05A7A:  MOVFF  64C,68A
05A7E:  MOVFF  64B,689
05A82:  MOVFF  64A,688
05A86:  CLRF   x8F
05A88:  CLRF   x8E
05A8A:  CLRF   x8D
05A8C:  MOVLW  0A
05A8E:  MOVWF  x8C
05A90:  MOVLB  0
05A92:  RCALL  586A
05A94:  MOVFF  03,64D
05A98:  MOVFF  02,64C
05A9C:  MOVFF  01,64B
05AA0:  MOVFF  00,64A
05AA4:  MOVLB  6
05AA6:  DECFSZ x48,F
05AA8:  BRA    599E
05AAA:  MOVLB  0
05AAC:  RETURN 0
05AAE:  MOVFF  FEA,645
05AB2:  MOVFF  FE9,644
05AB6:  MOVLB  6
05AB8:  SWAPF  x3E,W
05ABA:  IORLW  F0
05ABC:  MOVWF  x40
05ABE:  ADDWF  x40,F
05AC0:  ADDLW  E2
05AC2:  MOVWF  x41
05AC4:  ADDLW  32
05AC6:  MOVWF  x43
05AC8:  MOVF   x3E,W
05ACA:  ANDLW  0F
05ACC:  ADDWF  x41,F
05ACE:  ADDWF  x41,F
05AD0:  ADDWF  x43,F
05AD2:  ADDLW  E9
05AD4:  MOVWF  x42
05AD6:  ADDWF  x42,F
05AD8:  ADDWF  x42,F
05ADA:  SWAPF  x3D,W
05ADC:  ANDLW  0F
05ADE:  ADDWF  x42,F
05AE0:  ADDWF  x43,F
05AE2:  RLCF   x42,F
05AE4:  RLCF   x43,F
05AE6:  COMF   x43,F
05AE8:  RLCF   x43,F
05AEA:  MOVF   x3D,W
05AEC:  ANDLW  0F
05AEE:  ADDWF  x43,F
05AF0:  RLCF   x40,F
05AF2:  MOVLW  07
05AF4:  MOVWF  x3F
05AF6:  MOVLW  0A
05AF8:  DECF   x42,F
05AFA:  ADDWF  x43,F
05AFC:  BNC   5AF8
05AFE:  DECF   x41,F
05B00:  ADDWF  x42,F
05B02:  BNC   5AFE
05B04:  DECF   x40,F
05B06:  ADDWF  x41,F
05B08:  BNC   5B04
05B0A:  DECF   x3F,F
05B0C:  ADDWF  x40,F
05B0E:  BNC   5B0A
05B10:  MOVLW  06
05B12:  MOVWF  FEA
05B14:  MOVLW  3F
05B16:  MOVWF  FE9
05B18:  MOVLW  07
05B1A:  ANDWF  x44,W
05B1C:  BCF    x44.6
05B1E:  ADDWF  FE9,F
05B20:  MOVLW  00
05B22:  ADDWFC FEA,F
05B24:  MOVF   FE9,W
05B26:  SUBLW  43
05B28:  BNZ   5B32
05B2A:  MOVF   FEA,W
05B2C:  SUBLW  06
05B2E:  BNZ   5B32
05B30:  BSF    x44.6
05B32:  MOVF   FEF,W
05B34:  MOVWF  00
05B36:  BNZ   5B48
05B38:  BTFSC  x44.6
05B3A:  BRA    5B48
05B3C:  BTFSC  x44.4
05B3E:  BRA    5B6C
05B40:  BTFSC  x44.3
05B42:  BRA    5B48
05B44:  MOVLW  20
05B46:  BRA    5B4E
05B48:  BSF    x44.3
05B4A:  BCF    x44.4
05B4C:  MOVLW  30
05B4E:  ADDWF  00,F
05B50:  MOVFF  FEA,63E
05B54:  MOVFF  FE9,63D
05B58:  MOVFF  00,64E
05B5C:  MOVLB  0
05B5E:  CALL   5214
05B62:  MOVFF  63E,FEA
05B66:  MOVFF  63D,FE9
05B6A:  MOVLB  6
05B6C:  MOVF   FEE,W
05B6E:  BTFSS  x44.6
05B70:  BRA    5B24
05B72:  MOVLB  0
05B74:  RETURN 0
*
05CBA:  MOVFF  52F,FEA
05CBE:  MOVFF  52E,FE9
05CC2:  MOVFF  688,FEF
05CC6:  INCF   FE9,F
05CC8:  BTFSC  FD8.2
05CCA:  INCF   FEA,F
05CCC:  CLRF   FEF
05CCE:  MOVLB  5
05CD0:  INCF   x2E,F
05CD2:  BTFSC  FD8.2
05CD4:  INCF   x2F,F
05CD6:  MOVLB  0
05CD8:  RETURN 0
05CDA:  TBLRD*+
05CDC:  MOVF   FF5,F
05CDE:  BZ    5CF8
05CE0:  MOVFF  FF6,646
05CE4:  MOVFF  FF7,647
05CE8:  MOVFF  FF5,688
05CEC:  RCALL  5CBA
05CEE:  MOVFF  646,FF6
05CF2:  MOVFF  647,FF7
05CF6:  BRA    5CDA
05CF8:  RETURN 0
*
05E1C:  MOVLB  6
05E1E:  MOVF   xA0,W
05E20:  XORWF  xA2,W
05E22:  ANDLW  80
05E24:  MOVWF  xA4
05E26:  BTFSS  xA0.7
05E28:  BRA    5E34
05E2A:  COMF   x9F,F
05E2C:  COMF   xA0,F
05E2E:  INCF   x9F,F
05E30:  BTFSC  FD8.2
05E32:  INCF   xA0,F
05E34:  BTFSS  xA2.7
05E36:  BRA    5E42
05E38:  COMF   xA1,F
05E3A:  COMF   xA2,F
05E3C:  INCF   xA1,F
05E3E:  BTFSC  FD8.2
05E40:  INCF   xA2,F
05E42:  MOVF   x9F,W
05E44:  MULWF  xA1
05E46:  MOVFF  FF3,01
05E4A:  MOVFF  FF4,00
05E4E:  MULWF  xA2
05E50:  MOVF   FF3,W
05E52:  ADDWF  00,F
05E54:  MOVF   xA0,W
05E56:  MULWF  xA1
05E58:  MOVF   FF3,W
05E5A:  ADDWFC 00,W
05E5C:  MOVWF  02
05E5E:  BTFSS  xA4.7
05E60:  BRA    5E6C
05E62:  COMF   01,F
05E64:  COMF   02,F
05E66:  INCF   01,F
05E68:  BTFSC  FD8.2
05E6A:  INCF   02,F
05E6C:  MOVLB  0
05E6E:  GOTO   6102 (RETURN)
*
061C6:  MOVLW  20
061C8:  MOVLB  6
061CA:  BTFSS  x6D.4
061CC:  MOVLW  30
061CE:  MOVWF  x6E
061D0:  MOVFF  66C,00
061D4:  BTFSS  00.7
061D6:  BRA    61E8
061D8:  COMF   00,F
061DA:  INCF   00,F
061DC:  MOVFF  00,66C
061E0:  MOVLW  2D
061E2:  MOVWF  x6E
061E4:  BSF    x6D.7
061E6:  BSF    x6D.0
061E8:  MOVF   01,W
061EA:  MOVFF  66C,672
061EE:  MOVLW  64
061F0:  MOVWF  x73
061F2:  MOVLB  0
061F4:  CALL   5780
061F8:  MOVFF  00,66C
061FC:  MOVLW  30
061FE:  ADDWF  01,W
06200:  MOVLB  6
06202:  MOVWF  x6F
06204:  MOVFF  66C,672
06208:  MOVLW  0A
0620A:  MOVWF  x73
0620C:  MOVLB  0
0620E:  CALL   5780
06212:  MOVLW  30
06214:  ADDWF  00,W
06216:  MOVLB  6
06218:  MOVWF  x71
0621A:  MOVLW  30
0621C:  ADDWF  01,W
0621E:  MOVWF  x70
06220:  MOVFF  66E,00
06224:  MOVLW  30
06226:  SUBWF  x6F,W
06228:  BZ    6232
0622A:  BSF    x6D.1
0622C:  BTFSC  x6D.7
0622E:  BSF    x6D.2
06230:  BRA    6256
06232:  MOVFF  66E,66F
06236:  MOVLW  20
06238:  MOVWF  x6E
0623A:  MOVLW  30
0623C:  SUBWF  x70,W
0623E:  BZ    6248
06240:  BSF    x6D.0
06242:  BTFSC  x6D.7
06244:  BSF    x6D.1
06246:  BRA    6256
06248:  BTFSS  FD8.2
0624A:  BSF    x6D.0
0624C:  BNZ   6256
0624E:  MOVFF  66F,670
06252:  MOVLW  20
06254:  MOVWF  x6F
06256:  BTFSC  x6D.2
06258:  BRA    6264
0625A:  BTFSC  x6D.1
0625C:  BRA    626C
0625E:  BTFSC  x6D.0
06260:  BRA    6274
06262:  BRA    627C
06264:  MOVFF  66E,688
06268:  MOVLB  0
0626A:  RCALL  5CBA
0626C:  MOVFF  66F,688
06270:  MOVLB  0
06272:  RCALL  5CBA
06274:  MOVFF  670,688
06278:  MOVLB  0
0627A:  RCALL  5CBA
0627C:  MOVFF  671,688
06280:  MOVLB  0
06282:  RCALL  5CBA
06284:  RETURN 0
*
06422:  MOVLB  6
06424:  MOVF   x5A,W
06426:  ANDLW  07
06428:  MOVWF  00
0642A:  RRCF   x5A,W
0642C:  MOVWF  01
0642E:  RRCF   01,F
06430:  RRCF   01,F
06432:  MOVLW  1F
06434:  ANDWF  01,F
06436:  MOVF   01,W
06438:  ADDWF  x5C,W
0643A:  MOVWF  FE9
0643C:  MOVLW  00
0643E:  ADDWFC x5D,W
06440:  MOVWF  FEA
06442:  CLRF   01
06444:  INCF   01,F
06446:  INCF   00,F
06448:  BRA    644C
0644A:  RLCF   01,F
0644C:  DECFSZ 00,F
0644E:  BRA    644A
06450:  MOVF   x5B,F
06452:  BZ    645A
06454:  MOVF   01,W
06456:  IORWF  FEF,F
06458:  BRA    6460
0645A:  COMF   01,F
0645C:  MOVF   01,W
0645E:  ANDWF  FEF,F
06460:  MOVLB  0
06462:  RETURN 0
*
06612:  TBLRD*+
06614:  MOVFF  FF6,648
06618:  MOVFF  FF7,649
0661C:  MOVFF  FF5,688
06620:  CALL   5CBA
06624:  MOVFF  648,FF6
06628:  MOVFF  649,FF7
0662C:  MOVLB  6
0662E:  DECFSZ x47,F
06630:  BRA    6634
06632:  BRA    6638
06634:  MOVLB  0
06636:  BRA    6612
06638:  MOVLB  0
0663A:  RETURN 0
*
069E2:  MOVF   FE9,W
069E4:  MOVLB  6
069E6:  MOVWF  x80
069E8:  MOVF   x7F,W
069EA:  MOVWF  x82
069EC:  BZ    6A26
069EE:  MOVFF  67E,68B
069F2:  MOVFF  67D,68A
069F6:  MOVFF  67C,689
069FA:  MOVFF  67B,688
069FE:  CLRF   x8F
06A00:  CLRF   x8E
06A02:  MOVLW  20
06A04:  MOVWF  x8D
06A06:  MOVLW  82
06A08:  MOVWF  x8C
06A0A:  MOVLB  0
06A0C:  CALL   0DEC
06A10:  MOVFF  03,67E
06A14:  MOVFF  02,67D
06A18:  MOVFF  01,67C
06A1C:  MOVFF  00,67B
06A20:  MOVLB  6
06A22:  DECFSZ x82,F
06A24:  BRA    69EE
06A26:  MOVFF  67E,68B
06A2A:  MOVFF  67D,68A
06A2E:  MOVFF  67C,689
06A32:  MOVFF  67B,688
06A36:  MOVLB  0
06A38:  CALL   5828
06A3C:  MOVFF  03,67E
06A40:  MOVFF  02,67D
06A44:  MOVFF  01,67C
06A48:  MOVFF  00,67B
06A4C:  MOVLB  6
06A4E:  BTFSS  x7E.7
06A50:  BRA    6A6C
06A52:  DECF   x80,F
06A54:  BSF    x80.5
06A56:  COMF   x7B,F
06A58:  COMF   x7C,F
06A5A:  COMF   x7D,F
06A5C:  COMF   x7E,F
06A5E:  INCF   x7B,F
06A60:  BTFSC  FD8.2
06A62:  INCF   x7C,F
06A64:  BTFSC  FD8.2
06A66:  INCF   x7D,F
06A68:  BTFSC  FD8.2
06A6A:  INCF   x7E,F
06A6C:  MOVLW  3B
06A6E:  MOVWF  x87
06A70:  MOVLW  9A
06A72:  MOVWF  x86
06A74:  MOVLW  CA
06A76:  MOVWF  x85
06A78:  CLRF   x84
06A7A:  MOVLW  0A
06A7C:  MOVWF  x82
06A7E:  MOVF   x7F,W
06A80:  BTFSC  FD8.2
06A82:  INCF   x80,F
06A84:  BSF    FD8.1
06A86:  MOVLW  06
06A88:  MOVWF  FEA
06A8A:  MOVLW  7B
06A8C:  MOVWF  FE9
06A8E:  MOVFF  67E,68B
06A92:  MOVFF  67D,68A
06A96:  MOVFF  67C,689
06A9A:  MOVFF  67B,688
06A9E:  MOVFF  687,68F
06AA2:  MOVFF  686,68E
06AA6:  MOVFF  685,68D
06AAA:  MOVFF  684,68C
06AAE:  MOVLB  0
06AB0:  CALL   586A
06AB4:  MOVF   01,W
06AB6:  MOVF   00,F
06AB8:  BNZ   6AE0
06ABA:  MOVLB  6
06ABC:  INCF   x7F,W
06ABE:  SUBWF  x82,W
06AC0:  BTFSS  FD8.2
06AC2:  BRA    6AC8
06AC4:  MOVLB  0
06AC6:  BRA    6AE0
06AC8:  MOVF   x80,W
06ACA:  BZ    6AE6
06ACC:  ANDLW  0F
06ACE:  SUBWF  x82,W
06AD0:  BZ    6AD4
06AD2:  BC    6B5C
06AD4:  BTFSC  x80.7
06AD6:  BRA    6B5C
06AD8:  BTFSC  x80.6
06ADA:  BRA    6AE6
06ADC:  MOVLW  20
06ADE:  BRA    6B4E
06AE0:  MOVLW  20
06AE2:  MOVLB  6
06AE4:  ANDWF  x80,F
06AE6:  BTFSS  x80.5
06AE8:  BRA    6B08
06AEA:  BCF    x80.5
06AEC:  MOVF   x7F,W
06AEE:  BTFSS  FD8.2
06AF0:  DECF   x80,F
06AF2:  MOVF   00,W
06AF4:  MOVWF  x80
06AF6:  MOVLW  2D
06AF8:  MOVWF  x88
06AFA:  MOVLB  0
06AFC:  CALL   5CBA
06B00:  MOVLB  6
06B02:  MOVF   x80,W
06B04:  MOVWF  00
06B06:  CLRF   x80
06B08:  MOVF   x7F,W
06B0A:  SUBWF  x82,W
06B0C:  BNZ   6B28
06B0E:  MOVF   00,W
06B10:  MOVWF  x80
06B12:  MOVLW  2E
06B14:  MOVWF  x88
06B16:  MOVLB  0
06B18:  CALL   5CBA
06B1C:  MOVLB  6
06B1E:  MOVF   x80,W
06B20:  MOVWF  00
06B22:  MOVLW  20
06B24:  ANDWF  x80,F
06B26:  MOVLW  00
06B28:  MOVLW  30
06B2A:  BTFSS  x80.5
06B2C:  BRA    6B4E
06B2E:  BCF    x80.5
06B30:  MOVF   x7F,W
06B32:  BTFSS  FD8.2
06B34:  DECF   x80,F
06B36:  MOVF   00,W
06B38:  MOVWF  x80
06B3A:  MOVLW  2D
06B3C:  MOVWF  x88
06B3E:  MOVLB  0
06B40:  CALL   5CBA
06B44:  MOVLB  6
06B46:  MOVF   x80,W
06B48:  MOVWF  00
06B4A:  CLRF   x80
06B4C:  MOVLW  30
06B4E:  ADDWF  00,F
06B50:  MOVFF  00,688
06B54:  MOVLB  0
06B56:  CALL   5CBA
06B5A:  MOVLB  6
06B5C:  BCF    FD8.1
06B5E:  MOVFF  687,68B
06B62:  MOVFF  686,68A
06B66:  MOVFF  685,689
06B6A:  MOVFF  684,688
06B6E:  CLRF   x8F
06B70:  CLRF   x8E
06B72:  CLRF   x8D
06B74:  MOVLW  0A
06B76:  MOVWF  x8C
06B78:  MOVLB  0
06B7A:  CALL   586A
06B7E:  MOVFF  03,687
06B82:  MOVFF  02,686
06B86:  MOVFF  01,685
06B8A:  MOVFF  00,684
06B8E:  MOVLB  6
06B90:  DECFSZ x82,F
06B92:  BRA    6A84
06B94:  MOVLB  0
06B96:  RETURN 0
*
09600:  MOVF   FE9,W
09602:  MOVLB  6
09604:  MOVWF  x75
09606:  BTFSS  x74.7
09608:  BRA    9624
0960A:  DECF   x75,F
0960C:  BSF    x75.5
0960E:  COMF   x71,F
09610:  COMF   x72,F
09612:  COMF   x73,F
09614:  COMF   x74,F
09616:  INCF   x71,F
09618:  BTFSC  FD8.2
0961A:  INCF   x72,F
0961C:  BTFSC  FD8.2
0961E:  INCF   x73,F
09620:  BTFSC  FD8.2
09622:  INCF   x74,F
09624:  MOVLW  3B
09626:  MOVWF  x7C
09628:  MOVLW  9A
0962A:  MOVWF  x7B
0962C:  MOVLW  CA
0962E:  MOVWF  x7A
09630:  CLRF   x79
09632:  MOVLW  0A
09634:  MOVWF  x77
09636:  BSF    FD8.1
09638:  MOVLW  06
0963A:  MOVWF  FEA
0963C:  MOVLW  71
0963E:  MOVWF  FE9
09640:  MOVFF  674,68B
09644:  MOVFF  673,68A
09648:  MOVFF  672,689
0964C:  MOVFF  671,688
09650:  MOVFF  67C,68F
09654:  MOVFF  67B,68E
09658:  MOVFF  67A,68D
0965C:  MOVFF  679,68C
09660:  MOVLB  0
09662:  CALL   586A
09666:  MOVF   01,W
09668:  MOVF   00,F
0966A:  BNZ   9692
0966C:  MOVLB  6
0966E:  MOVF   x77,W
09670:  XORLW  01
09672:  BTFSS  FD8.2
09674:  BRA    967A
09676:  MOVLB  0
09678:  BRA    9692
0967A:  MOVF   x75,W
0967C:  BZ    9698
0967E:  ANDLW  0F
09680:  SUBWF  x77,W
09682:  BZ    9686
09684:  BC    96E2
09686:  BTFSC  x75.7
09688:  BRA    96E2
0968A:  BTFSC  x75.6
0968C:  BRA    9698
0968E:  MOVLW  20
09690:  BRA    96D4
09692:  MOVLW  20
09694:  MOVLB  6
09696:  ANDWF  x75,F
09698:  BTFSS  x75.5
0969A:  BRA    96B4
0969C:  BCF    x75.5
0969E:  MOVFF  00,675
096A2:  MOVLW  2D
096A4:  MOVWF  x88
096A6:  MOVLB  0
096A8:  CALL   5CBA
096AC:  MOVLB  6
096AE:  MOVFF  675,00
096B2:  CLRF   x75
096B4:  MOVLW  30
096B6:  BTFSS  x75.5
096B8:  BRA    96D4
096BA:  BCF    x75.5
096BC:  MOVFF  00,675
096C0:  MOVLW  2D
096C2:  MOVWF  x88
096C4:  MOVLB  0
096C6:  CALL   5CBA
096CA:  MOVLB  6
096CC:  MOVFF  675,00
096D0:  CLRF   x75
096D2:  MOVLW  30
096D4:  ADDWF  00,F
096D6:  MOVFF  00,688
096DA:  MOVLB  0
096DC:  CALL   5CBA
096E0:  MOVLB  6
096E2:  BCF    FD8.1
096E4:  MOVFF  67C,68B
096E8:  MOVFF  67B,68A
096EC:  MOVFF  67A,689
096F0:  MOVFF  679,688
096F4:  CLRF   x8F
096F6:  CLRF   x8E
096F8:  CLRF   x8D
096FA:  MOVLW  0A
096FC:  MOVWF  x8C
096FE:  MOVLB  0
09700:  CALL   586A
09704:  MOVFF  03,67C
09708:  MOVFF  02,67B
0970C:  MOVFF  01,67A
09710:  MOVFF  00,679
09714:  MOVLB  6
09716:  DECFSZ x77,F
09718:  BRA    9636
0971A:  MOVLB  0
0971C:  RETURN 0
*
0A360:  MOVF   FEF,F
0A362:  BZ    A384
0A364:  MOVFF  FEA,63E
0A368:  MOVFF  FE9,63D
0A36C:  MOVFF  FEF,688
0A370:  CALL   5CBA
0A374:  MOVFF  63E,FEA
0A378:  MOVFF  63D,FE9
0A37C:  INCF   FE9,F
0A37E:  BTFSC  FD8.2
0A380:  INCF   FEA,F
0A382:  BRA    A360
0A384:  GOTO   A402 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00438:  MOVLW  06
0043A:  MOVWF  FEA
0043C:  MOVLW  3E
0043E:  MOVWF  FE9
00440:  MOVF   FEF,W
00442:  BZ    0460
00444:  MOVLW  14
00446:  MOVWF  01
00448:  CLRF   00
0044A:  DECFSZ 00,F
0044C:  BRA    044A
0044E:  DECFSZ 01,F
00450:  BRA    0448
00452:  MOVLW  BF
00454:  MOVWF  00
00456:  DECFSZ 00,F
00458:  BRA    0456
0045A:  BRA    045C
0045C:  DECFSZ FEF,F
0045E:  BRA    0444
00460:  RETURN 0
*
00700:  MOVLW  01
00702:  MOVLB  6
00704:  SUBWF  x44,F
00706:  BNC   0720
00708:  MOVLW  06
0070A:  MOVWF  FEA
0070C:  MOVLW  44
0070E:  MOVWF  FE9
00710:  MOVF   FEF,W
00712:  BZ    0720
00714:  MOVLW  04
00716:  MOVWF  00
00718:  DECFSZ 00,F
0071A:  BRA    0718
0071C:  DECFSZ FEF,F
0071E:  BRA    0714
00720:  MOVLB  0
00722:  GOTO   0768 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003A2:  MOVLW  CF
003A4:  MOVWF  F87
003A6:  CLRF   F82
....................    output_b(portB_reset);
003A8:  MOVLW  C4
003AA:  MOVWF  F88
003AC:  CLRF   F83
....................    output_c(portC_reset);
003AE:  MOVLW  93
003B0:  MOVWF  F89
003B2:  CLRF   F84
....................    output_d(portD_reset);
003B4:  MOVLW  1F
003B6:  MOVWF  F8A
003B8:  CLRF   F85
....................    output_e(portE_reset);
003BA:  BCF    F8B.0
003BC:  BCF    F8B.1
003BE:  BCF    F8B.2
003C0:  BCF    F8B.3
003C2:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003C4:  MOVLB  F
003C6:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003C8:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003CA:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003CC:  SETF   x20
....................    port_e_pullups(portE_pullups);
003CE:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003D0:  MOVLW  40
003D2:  MOVWF  x0C
003D4:  CLRF   x14
003D6:  MOVLW  03
003D8:  MOVWF  x1C
003DA:  MOVLW  0F
003DC:  MOVWF  x21
003DE:  CLRF   x29
003E0:  MOVLB  0
003E2:  GOTO   A826 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05C42:  MOVFF  67A,FEA
05C46:  MOVLB  6
05C48:  MOVFF  679,FE9
05C4C:  MOVFF  FEF,67D
05C50:  MOVFF  67C,FEA
05C54:  MOVFF  67B,FE9
05C58:  MOVF   FEF,W
05C5A:  SUBWF  x7D,W
05C5C:  BNZ   5C8C
....................       if (*s1 == '\0')
05C5E:  MOVFF  67A,03
05C62:  MOVFF  679,FE9
05C66:  MOVFF  03,FEA
05C6A:  MOVF   FEF,F
05C6C:  BNZ   5C74
....................          return(0);
05C6E:  MOVLW  00
05C70:  MOVWF  01
05C72:  BRA    5CB6
05C74:  MOVFF  67A,03
05C78:  MOVF   x79,W
05C7A:  INCF   x79,F
05C7C:  BTFSC  FD8.2
05C7E:  INCF   x7A,F
05C80:  INCF   x7B,F
05C82:  BTFSC  FD8.2
05C84:  INCF   x7C,F
05C86:  MOVLB  0
05C88:  BRA    5C42
05C8A:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
05C8C:  MOVFF  67A,03
05C90:  MOVFF  679,FE9
05C94:  MOVFF  03,FEA
05C98:  MOVFF  FEF,67D
05C9C:  MOVFF  67C,03
05CA0:  MOVFF  67B,FE9
05CA4:  MOVFF  03,FEA
05CA8:  MOVF   FEF,W
05CAA:  SUBWF  x7D,W
05CAC:  BC    5CB2
05CAE:  MOVLW  FF
05CB0:  BRA    5CB4
05CB2:  MOVLW  01
05CB4:  MOVWF  01
05CB6:  MOVLB  0
05CB8:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05DD2:  MOVFF  6A0,6A3
....................    for(su=s;0<n;++su,--n)
05DD6:  MOVFF  69F,6A5
05DDA:  MOVFF  69E,6A4
05DDE:  MOVLB  6
05DE0:  MOVF   xA2,F
05DE2:  BNZ   5DEA
05DE4:  MOVF   xA1,W
05DE6:  SUBLW  00
05DE8:  BC    5E12
....................       if(*su==uc)
05DEA:  MOVFF  6A5,FEA
05DEE:  MOVFF  6A4,FE9
05DF2:  MOVF   xA3,W
05DF4:  SUBWF  FEF,W
05DF6:  BNZ   5E02
....................       return su;
05DF8:  MOVFF  6A4,01
05DFC:  MOVFF  6A5,02
05E00:  BRA    5E18
05E02:  INCF   xA4,F
05E04:  BTFSC  FD8.2
05E06:  INCF   xA5,F
05E08:  MOVF   xA1,W
05E0A:  BTFSC  FD8.2
05E0C:  DECF   xA2,F
05E0E:  DECF   xA1,F
05E10:  BRA    5DE0
....................    return NULL;
05E12:  MOVLW  00
05E14:  MOVWF  01
05E16:  MOVWF  02
05E18:  MOVLB  0
05E1A:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05C0A:  MOVFF  67A,67C
05C0E:  MOVFF  679,67B
05C12:  MOVFF  67C,FEA
05C16:  MOVLB  6
05C18:  MOVFF  67B,FE9
05C1C:  MOVF   FEF,F
05C1E:  BZ    5C2C
05C20:  INCF   x7B,F
05C22:  BTFSC  FD8.2
05C24:  INCF   x7C,F
05C26:  MOVLB  0
05C28:  BRA    5C12
05C2A:  MOVLB  6
....................    return(sc - s);
05C2C:  MOVF   x79,W
05C2E:  SUBWF  x7B,W
05C30:  MOVWF  00
05C32:  MOVF   x7A,W
05C34:  SUBWFB x7C,W
05C36:  MOVWF  03
05C38:  MOVFF  00,01
05C3C:  MOVWF  02
05C3E:  MOVLB  0
05C40:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
07110:  MOVLB  6
07112:  CLRF   x53
07114:  CLRF   x52
07116:  CLRF   x51
07118:  MOVLW  7F
0711A:  MOVWF  x50
0711C:  CLRF   x57
0711E:  CLRF   x56
07120:  CLRF   x55
07122:  CLRF   x54
07124:  BSF    x58.0
07126:  BCF    x58.1
07128:  BCF    x58.2
0712A:  CLRF   x5A
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
0712C:  MOVF   x4C,W
0712E:  IORWF  x4D,W
07130:  BNZ   713C
....................       return 0;
07132:  CLRF   00
07134:  CLRF   01
07136:  CLRF   02
07138:  CLRF   03
0713A:  BRA    7366
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
0713C:  MOVF   x5A,W
0713E:  INCF   x5A,F
07140:  ADDWF  x4C,W
07142:  MOVWF  FE9
07144:  MOVLW  00
07146:  ADDWFC x4D,W
07148:  MOVWF  FEA
0714A:  MOVFF  FEF,659
0714E:  MOVF   x59,F
07150:  BTFSC  FD8.2
07152:  BRA    72EA
....................    {
....................       if (skip && !isspace(c))
07154:  BTFSS  x58.0
07156:  BRA    7176
07158:  MOVF   x59,W
0715A:  SUBLW  20
0715C:  BZ    7176
....................       {
....................          skip = 0;
0715E:  BCF    x58.0
....................          if (c == '+')
07160:  MOVF   x59,W
07162:  SUBLW  2B
07164:  BNZ   716C
....................          {
....................             sign = 0;
07166:  BCF    x58.1
....................             continue;
07168:  BRA    72D2
....................          }            
0716A:  BRA    7176
....................          else if (c == '-')
0716C:  MOVF   x59,W
0716E:  SUBLW  2D
07170:  BNZ   7176
....................          {
....................             sign = 1;
07172:  BSF    x58.1
....................             continue;
07174:  BRA    72D2
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
07176:  BTFSC  x58.0
07178:  BRA    7188
0717A:  MOVF   x59,W
0717C:  SUBLW  2E
0717E:  BNZ   7188
07180:  BTFSC  x58.2
07182:  BRA    7188
....................          point = 1;
07184:  BSF    x58.2
07186:  BRA    72D2
....................       else if (!skip && isdigit(c))
07188:  BTFSC  x58.0
0718A:  BRA    72CC
0718C:  MOVF   x59,W
0718E:  SUBLW  2F
07190:  BTFSC  FD8.0
07192:  BRA    72CC
07194:  MOVF   x59,W
07196:  SUBLW  39
07198:  BTFSS  FD8.0
0719A:  BRA    72CC
....................       {
....................          c -= '0';
0719C:  MOVLW  30
0719E:  SUBWF  x59,F
....................          if (point)
071A0:  BTFSS  x58.2
071A2:  BRA    7252
....................          {
....................             pow10 = pow10 * 10.0;
071A4:  MOVFF  653,68B
071A8:  MOVFF  652,68A
071AC:  MOVFF  651,689
071B0:  MOVFF  650,688
071B4:  CLRF   x8F
071B6:  CLRF   x8E
071B8:  MOVLW  20
071BA:  MOVWF  x8D
071BC:  MOVLW  82
071BE:  MOVWF  x8C
071C0:  MOVLB  0
071C2:  CALL   0DEC
071C6:  MOVFF  03,653
071CA:  MOVFF  02,652
071CE:  MOVFF  01,651
071D2:  MOVFF  00,650
....................             result += (float)c / pow10;   
071D6:  MOVLB  6
071D8:  CLRF   x88
071DA:  MOVFF  659,687
071DE:  MOVLB  0
071E0:  CALL   0DB6
071E4:  MOVFF  03,65E
071E8:  MOVFF  02,65D
071EC:  MOVFF  01,65C
071F0:  MOVFF  00,65B
071F4:  MOVFF  03,67F
071F8:  MOVFF  02,67E
071FC:  MOVFF  01,67D
07200:  MOVFF  00,67C
07204:  MOVFF  653,683
07208:  MOVFF  652,682
0720C:  MOVFF  651,681
07210:  MOVFF  650,680
07214:  CALL   2014
07218:  BCF    FD8.1
0721A:  MOVFF  657,68A
0721E:  MOVFF  656,689
07222:  MOVFF  655,688
07226:  MOVFF  654,687
0722A:  MOVFF  03,68E
0722E:  MOVFF  02,68D
07232:  MOVFF  01,68C
07236:  MOVFF  00,68B
0723A:  CALL   0EE2
0723E:  MOVFF  03,657
07242:  MOVFF  02,656
07246:  MOVFF  01,655
0724A:  MOVFF  00,654
....................          }
0724E:  BRA    72C8
07250:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
07252:  CLRF   x8B
07254:  CLRF   x8A
07256:  MOVLW  20
07258:  MOVWF  x89
0725A:  MOVLW  82
0725C:  MOVWF  x88
0725E:  MOVFF  657,68F
07262:  MOVFF  656,68E
07266:  MOVFF  655,68D
0726A:  MOVFF  654,68C
0726E:  MOVLB  0
07270:  CALL   0DEC
07274:  MOVFF  03,65E
07278:  MOVFF  02,65D
0727C:  MOVFF  01,65C
07280:  MOVFF  00,65B
07284:  MOVLB  6
07286:  CLRF   x88
07288:  MOVFF  659,687
0728C:  MOVLB  0
0728E:  CALL   0DB6
07292:  BCF    FD8.1
07294:  MOVFF  65E,68A
07298:  MOVFF  65D,689
0729C:  MOVFF  65C,688
072A0:  MOVFF  65B,687
072A4:  MOVFF  03,68E
072A8:  MOVFF  02,68D
072AC:  MOVFF  01,68C
072B0:  MOVFF  00,68B
072B4:  CALL   0EE2
072B8:  MOVFF  03,657
072BC:  MOVFF  02,656
072C0:  MOVFF  01,655
072C4:  MOVFF  00,654
....................          }
....................       }
072C8:  BRA    72D4
072CA:  MOVLB  6
....................       else if (!skip)
072CC:  BTFSC  x58.0
072CE:  BRA    72D2
....................          break;
072D0:  BRA    72EA
072D2:  MOVLB  0
072D4:  MOVLB  6
072D6:  MOVF   x5A,W
072D8:  INCF   x5A,F
072DA:  ADDWF  x4C,W
072DC:  MOVWF  FE9
072DE:  MOVLW  00
072E0:  ADDWFC x4D,W
072E2:  MOVWF  FEA
072E4:  MOVFF  FEF,659
072E8:  BRA    714E
....................    }
.................... 
....................    if (sign)
072EA:  BTFSS  x58.1
072EC:  BRA    7322
....................       result = -1*result;
072EE:  CLRF   x8B
072F0:  CLRF   x8A
072F2:  MOVLW  80
072F4:  MOVWF  x89
072F6:  MOVLW  7F
072F8:  MOVWF  x88
072FA:  MOVFF  657,68F
072FE:  MOVFF  656,68E
07302:  MOVFF  655,68D
07306:  MOVFF  654,68C
0730A:  MOVLB  0
0730C:  CALL   0DEC
07310:  MOVFF  03,657
07314:  MOVFF  02,656
07318:  MOVFF  01,655
0731C:  MOVFF  00,654
07320:  MOVLB  6
....................       
....................    if(endptr)
07322:  MOVF   x4E,W
07324:  IORWF  x4F,W
07326:  BZ    7356
....................    {
....................       if (ptr) {
07328:  MOVF   x5A,F
0732A:  BZ    7344
....................          ptr--;
0732C:  DECF   x5A,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
0732E:  MOVFF  64F,FEA
07332:  MOVFF  64E,FE9
07336:  MOVF   x5A,W
07338:  ADDWF  x4C,W
0733A:  MOVWF  FEF
0733C:  MOVLW  00
0733E:  ADDWFC x4D,W
07340:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
07342:  BRA    7356
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
07344:  MOVFF  64F,FEA
07348:  MOVFF  64E,FE9
0734C:  MOVFF  64D,FEC
07350:  MOVF   FED,F
07352:  MOVFF  64C,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
07356:  MOVFF  654,00
0735A:  MOVFF  655,01
0735E:  MOVFF  656,02
07362:  MOVFF  657,03
07366:  MOVLB  0
07368:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05E72:  MOVLB  6
05E74:  CLRF   x77
05E76:  CLRF   x76
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05E78:  MOVLW  30
05E7A:  MOVWF  x79
05E7C:  MOVLW  31
05E7E:  MOVWF  x7A
05E80:  MOVLW  32
05E82:  MOVWF  x7B
05E84:  MOVLW  33
05E86:  MOVWF  x7C
05E88:  MOVLW  34
05E8A:  MOVWF  x7D
05E8C:  MOVLW  35
05E8E:  MOVWF  x7E
05E90:  MOVLW  36
05E92:  MOVWF  x7F
05E94:  MOVLW  37
05E96:  MOVWF  x80
05E98:  MOVLW  38
05E9A:  MOVWF  x81
05E9C:  MOVLW  39
05E9E:  MOVWF  x82
05EA0:  MOVLW  61
05EA2:  MOVWF  x83
05EA4:  MOVLW  62
05EA6:  MOVWF  x84
05EA8:  MOVLW  63
05EAA:  MOVWF  x85
05EAC:  MOVLW  64
05EAE:  MOVWF  x86
05EB0:  MOVLW  65
05EB2:  MOVWF  x87
05EB4:  MOVLW  66
05EB6:  MOVWF  x88
05EB8:  MOVLW  67
05EBA:  MOVWF  x89
05EBC:  MOVLW  68
05EBE:  MOVWF  x8A
05EC0:  MOVLW  69
05EC2:  MOVWF  x8B
05EC4:  MOVLW  6A
05EC6:  MOVWF  x8C
05EC8:  MOVLW  6B
05ECA:  MOVWF  x8D
05ECC:  MOVLW  6C
05ECE:  MOVWF  x8E
05ED0:  MOVLW  6D
05ED2:  MOVWF  x8F
05ED4:  MOVLW  6E
05ED6:  MOVWF  x90
05ED8:  MOVLW  6F
05EDA:  MOVWF  x91
05EDC:  MOVLW  70
05EDE:  MOVWF  x92
05EE0:  MOVLW  71
05EE2:  MOVWF  x93
05EE4:  MOVLW  73
05EE6:  MOVWF  x94
05EE8:  MOVLW  74
05EEA:  MOVWF  x95
05EEC:  MOVLW  75
05EEE:  MOVWF  x96
05EF0:  MOVLW  76
05EF2:  MOVWF  x97
05EF4:  MOVLW  77
05EF6:  MOVWF  x98
05EF8:  MOVLW  78
05EFA:  MOVWF  x99
05EFC:  MOVLW  79
05EFE:  MOVWF  x9A
05F00:  MOVLW  7A
05F02:  MOVWF  x9B
05F04:  CLRF   x9C
....................    for(sc=s;isspace(*sc);++sc);
05F06:  MOVFF  66C,671
05F0A:  MOVFF  66B,670
05F0E:  MOVFF  671,FEA
05F12:  MOVFF  670,FE9
05F16:  MOVF   FEF,W
05F18:  SUBLW  20
05F1A:  BNZ   5F24
05F1C:  INCF   x70,F
05F1E:  BTFSC  FD8.2
05F20:  INCF   x71,F
05F22:  BRA    5F0E
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05F24:  MOVFF  671,03
05F28:  MOVFF  670,FE9
05F2C:  MOVFF  03,FEA
05F30:  MOVF   FEF,W
05F32:  SUBLW  2D
05F34:  BZ    5F44
05F36:  MOVFF  671,FEA
05F3A:  MOVFF  670,FE9
05F3E:  MOVF   FEF,W
05F40:  SUBLW  2B
05F42:  BNZ   5F56
05F44:  MOVFF  671,FEA
05F48:  MOVF   x70,W
05F4A:  INCF   x70,F
05F4C:  BTFSC  FD8.2
05F4E:  INCF   x71,F
05F50:  MOVWF  FE9
05F52:  MOVF   FEF,W
05F54:  BRA    5F58
05F56:  MOVLW  2B
05F58:  MOVWF  x78
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05F5A:  MOVF   x78,W
05F5C:  SUBLW  2D
05F5E:  BZ    5F74
05F60:  BTFSC  x6F.7
05F62:  BRA    5F74
05F64:  DECFSZ x6F,W
05F66:  BRA    5F6A
05F68:  BRA    5F74
05F6A:  BTFSC  x6F.7
05F6C:  BRA    5F78
05F6E:  MOVF   x6F,W
05F70:  SUBLW  24
05F72:  BC    5F78
....................    goto StrtoulGO;
05F74:  BRA    6180
05F76:  BRA    6070
.................... 
....................    else if (base)
05F78:  MOVF   x6F,F
05F7A:  BZ    6008
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05F7C:  MOVF   x6F,W
05F7E:  SUBLW  10
05F80:  BNZ   5FBC
05F82:  MOVFF  671,FEA
05F86:  MOVFF  670,FE9
05F8A:  MOVF   FEF,W
05F8C:  SUBLW  30
05F8E:  BNZ   5FBC
05F90:  MOVLW  01
05F92:  ADDWF  x70,W
05F94:  MOVWF  FE9
05F96:  MOVLW  00
05F98:  ADDWFC x71,W
05F9A:  MOVWF  FEA
05F9C:  MOVF   FEF,W
05F9E:  SUBLW  78
05FA0:  BZ    5FB4
05FA2:  MOVLW  01
05FA4:  ADDWF  x70,W
05FA6:  MOVWF  FE9
05FA8:  MOVLW  00
05FAA:  ADDWFC x71,W
05FAC:  MOVWF  FEA
05FAE:  MOVF   FEF,W
05FB0:  SUBLW  58
05FB2:  BNZ   5FBC
....................          sc+=2;
05FB4:  MOVLW  02
05FB6:  ADDWF  x70,F
05FB8:  MOVLW  00
05FBA:  ADDWFC x71,F
....................       if(base==8 && *sc =='0')
05FBC:  MOVF   x6F,W
05FBE:  SUBLW  08
05FC0:  BNZ   5FD8
05FC2:  MOVFF  671,FEA
05FC6:  MOVFF  670,FE9
05FCA:  MOVF   FEF,W
05FCC:  SUBLW  30
05FCE:  BNZ   5FD8
....................          sc+=1;
05FD0:  MOVLW  01
05FD2:  ADDWF  x70,F
05FD4:  MOVLW  00
05FD6:  ADDWFC x71,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05FD8:  MOVF   x6F,W
05FDA:  SUBLW  02
05FDC:  BNZ   6006
05FDE:  MOVFF  671,FEA
05FE2:  MOVFF  670,FE9
05FE6:  MOVF   FEF,W
05FE8:  SUBLW  30
05FEA:  BNZ   6006
05FEC:  MOVLW  01
05FEE:  ADDWF  x70,W
05FF0:  MOVWF  FE9
05FF2:  MOVLW  00
05FF4:  ADDWFC x71,W
05FF6:  MOVWF  FEA
05FF8:  MOVF   FEF,W
05FFA:  SUBLW  62
05FFC:  BNZ   6006
....................          sc+=2;
05FFE:  MOVLW  02
06000:  ADDWF  x70,F
06002:  MOVLW  00
06004:  ADDWFC x71,F
.................... 
....................    }
06006:  BRA    6070
....................    else if(*sc!='0') // base is 0, find base
06008:  MOVFF  671,FEA
0600C:  MOVFF  670,FE9
06010:  MOVF   FEF,W
06012:  SUBLW  30
06014:  BZ    601C
....................       base=10;
06016:  MOVLW  0A
06018:  MOVWF  x6F
0601A:  BRA    6070
....................    else if (sc[1]=='x' || sc[1]=='X')
0601C:  MOVLW  01
0601E:  ADDWF  x70,W
06020:  MOVWF  FE9
06022:  MOVLW  00
06024:  ADDWFC x71,W
06026:  MOVWF  FEA
06028:  MOVF   FEF,W
0602A:  SUBLW  78
0602C:  BZ    6040
0602E:  MOVLW  01
06030:  ADDWF  x70,W
06032:  MOVWF  FE9
06034:  MOVLW  00
06036:  ADDWFC x71,W
06038:  MOVWF  FEA
0603A:  MOVF   FEF,W
0603C:  SUBLW  58
0603E:  BNZ   604E
....................       base =16,sc+=2;
06040:  MOVLW  10
06042:  MOVWF  x6F
06044:  MOVLW  02
06046:  ADDWF  x70,F
06048:  MOVLW  00
0604A:  ADDWFC x71,F
0604C:  BRA    6070
....................    else if(sc[1]=='b')
0604E:  MOVLW  01
06050:  ADDWF  x70,W
06052:  MOVWF  FE9
06054:  MOVLW  00
06056:  ADDWFC x71,W
06058:  MOVWF  FEA
0605A:  MOVF   FEF,W
0605C:  SUBLW  62
0605E:  BNZ   606C
....................       base=2,sc+=2;
06060:  MOVLW  02
06062:  MOVWF  x6F
06064:  ADDWF  x70,F
06066:  MOVLW  00
06068:  ADDWFC x71,F
0606A:  BRA    6070
....................    else
....................       base=8;
0606C:  MOVLW  08
0606E:  MOVWF  x6F
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
06070:  MOVFF  671,673
06074:  MOVFF  670,672
06078:  MOVFF  671,FEA
0607C:  MOVFF  670,FE9
06080:  MOVF   FEF,W
06082:  SUBLW  30
06084:  BNZ   608E
06086:  INCF   x70,F
06088:  BTFSC  FD8.2
0608A:  INCF   x71,F
0608C:  BRA    6078
....................    sd=memchr(digits,tolower(*sc),base);
0608E:  MOVFF  671,03
06092:  MOVFF  670,FE9
06096:  MOVFF  03,FEA
0609A:  MOVFF  FEF,69D
0609E:  MOVF   x9D,W
060A0:  SUBLW  40
060A2:  BC    60B0
060A4:  MOVF   x9D,W
060A6:  SUBLW  5A
060A8:  BNC   60B0
060AA:  MOVF   x9D,W
060AC:  IORLW  20
060AE:  BRA    60B2
060B0:  MOVF   x9D,W
060B2:  MOVWF  x9D
060B4:  MOVLW  06
060B6:  MOVWF  x9F
060B8:  MOVLW  79
060BA:  MOVWF  x9E
060BC:  MOVFF  69D,6A0
060C0:  CLRF   xA2
060C2:  MOVFF  66F,6A1
060C6:  BTFSC  xA1.7
060C8:  DECF   xA2,F
060CA:  MOVLB  0
060CC:  RCALL  5DD2
060CE:  MOVFF  02,675
060D2:  MOVFF  01,674
....................    for(; sd!=0; )
060D6:  MOVLB  6
060D8:  MOVF   x74,F
060DA:  BNZ   60E0
060DC:  MOVF   x75,F
060DE:  BZ    6174
....................    {
....................       x=x*base+(int16)(sd-digits);
060E0:  CLRF   03
060E2:  MOVF   x6F,W
060E4:  MOVWF  00
060E6:  BTFSC  FE8.7
060E8:  DECF   03,F
060EA:  MOVWF  x9D
060EC:  MOVFF  03,69E
060F0:  MOVFF  677,6A0
060F4:  MOVFF  676,69F
060F8:  MOVFF  03,6A2
060FC:  MOVWF  xA1
060FE:  MOVLB  0
06100:  BRA    5E1C
06102:  MOVFF  01,69D
06106:  MOVLW  79
06108:  MOVLB  6
0610A:  SUBWF  x74,W
0610C:  MOVWF  00
0610E:  MOVLW  06
06110:  SUBWFB x75,W
06112:  MOVWF  03
06114:  MOVF   00,W
06116:  ADDWF  01,W
06118:  MOVWF  01
0611A:  MOVF   02,W
0611C:  ADDWFC 03,F
0611E:  MOVFF  01,676
06122:  MOVFF  03,677
....................       ++sc;
06126:  INCF   x70,F
06128:  BTFSC  FD8.2
0612A:  INCF   x71,F
....................       sd=memchr(digits,tolower(*sc),base);
0612C:  MOVFF  671,FEA
06130:  MOVFF  670,FE9
06134:  MOVFF  FEF,69D
06138:  MOVF   x9D,W
0613A:  SUBLW  40
0613C:  BC    614A
0613E:  MOVF   x9D,W
06140:  SUBLW  5A
06142:  BNC   614A
06144:  MOVF   x9D,W
06146:  IORLW  20
06148:  BRA    614C
0614A:  MOVF   x9D,W
0614C:  MOVWF  x9D
0614E:  MOVLW  06
06150:  MOVWF  x9F
06152:  MOVLW  79
06154:  MOVWF  x9E
06156:  MOVFF  69D,6A0
0615A:  CLRF   xA2
0615C:  MOVFF  66F,6A1
06160:  BTFSC  xA1.7
06162:  DECF   xA2,F
06164:  MOVLB  0
06166:  RCALL  5DD2
06168:  MOVFF  02,675
0616C:  MOVFF  01,674
06170:  BRA    60D6
06172:  MOVLB  6
....................    }
....................    if(s1==sc)
06174:  MOVF   x70,W
06176:  SUBWF  x72,W
06178:  BNZ   61A2
0617A:  MOVF   x71,W
0617C:  SUBWF  x73,W
0617E:  BNZ   61A2
....................    {
....................    StrtoulGO:
....................       if (endptr)
06180:  MOVLB  6
06182:  MOVF   x6D,W
06184:  IORWF  x6E,W
06186:  BZ    619A
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06188:  MOVFF  66E,FEA
0618C:  MOVFF  66D,FE9
06190:  MOVFF  66C,FEC
06194:  MOVF   FED,F
06196:  MOVFF  66B,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
0619A:  MOVLW  00
0619C:  MOVWF  01
0619E:  MOVWF  02
061A0:  BRA    61C2
....................    }
....................    if (endptr)
061A2:  MOVF   x6D,W
061A4:  IORWF  x6E,W
061A6:  BZ    61BA
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
061A8:  MOVFF  66E,FEA
061AC:  MOVFF  66D,FE9
061B0:  MOVFF  671,FEC
061B4:  MOVF   FED,F
061B6:  MOVFF  670,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
061BA:  MOVFF  676,01
061BE:  MOVFF  677,02
061C2:  MOVLB  0
061C4:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00462:  MOVLB  6
00464:  CLRF   x3D
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00466:  CLRF   x3D
00468:  MOVF   x3C,W
0046A:  SUBWF  x3D,W
0046C:  BC    04C4
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0046E:  MOVF   x3D,W
00470:  ADDWF  x3A,W
00472:  MOVWF  x3E
00474:  MOVLW  00
00476:  ADDWFC x3B,W
00478:  MOVWF  x3F
0047A:  MOVF   x3D,W
0047C:  ADDWF  x38,W
0047E:  MOVWF  01
00480:  MOVLW  00
00482:  ADDWFC x39,W
00484:  MOVWF  03
00486:  MOVF   01,W
00488:  MOVWF  FE9
0048A:  MOVFF  03,FEA
0048E:  MOVFF  FEF,640
00492:  BSF    F7F.7
00494:  MOVF   FF2,W
00496:  MOVWF  00
00498:  BCF    FF2.7
0049A:  MOVFF  63F,F7A
0049E:  MOVFF  63E,F79
004A2:  MOVLW  31
004A4:  MOVWF  F7B
004A6:  MOVFF  640,F7C
004AA:  MOVLB  F
004AC:  MOVLW  55
004AE:  MOVWF  F81
004B0:  MOVLW  AA
004B2:  MOVWF  F81
004B4:  BSF    F80.4
004B6:  BTFSC  F80.4
004B8:  BRA    04B6
004BA:  MOVF   00,W
004BC:  IORWF  FF2,F
004BE:  MOVLB  6
004C0:  INCF   x3D,F
004C2:  BRA    0468
....................    }
004C4:  MOVLB  0
004C6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003E6:  MOVLB  6
003E8:  CLRF   x3D
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003EA:  CLRF   x3D
003EC:  MOVF   x3C,W
003EE:  SUBWF  x3D,W
003F0:  BC    0434
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003F2:  MOVF   x3D,W
003F4:  ADDWF  x38,W
003F6:  MOVWF  01
003F8:  MOVLW  00
003FA:  ADDWFC x39,W
003FC:  MOVWF  03
003FE:  MOVF   01,W
00400:  MOVWF  FE9
00402:  MOVFF  03,FEA
00406:  MOVF   x3D,W
00408:  ADDWF  x3A,W
0040A:  MOVWF  x40
0040C:  MOVLW  00
0040E:  ADDWFC x3B,W
00410:  MOVWF  x41
00412:  BSF    F7F.7
00414:  MOVFF  FF2,642
00418:  BCF    FF2.7
0041A:  MOVFF  641,F7A
0041E:  MOVFF  640,F79
00422:  MOVLW  31
00424:  MOVWF  F7B
00426:  BSF    F80.0
00428:  MOVF   F7C,W
0042A:  BTFSC  x42.7
0042C:  BSF    FF2.7
0042E:  MOVWF  FEF
00430:  INCF   x3D,F
00432:  BRA    03EC
....................    }
00434:  MOVLB  0
00436:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004C8:  MOVLB  6
004CA:  CLRF   x39
004CC:  MOVLW  20
004CE:  MOVWF  x38
004D0:  CLRF   x3B
004D2:  CLRF   x3A
004D4:  MOVLW  80
004D6:  MOVWF  x3C
004D8:  MOVLB  0
004DA:  RCALL  0462
....................    delay_ms(1);
004DC:  MOVLW  01
004DE:  MOVLB  6
004E0:  MOVWF  x3E
004E2:  MOVLB  0
004E4:  RCALL  0438
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E6:  MOVLB  6
004E8:  CLRF   x39
004EA:  MOVLW  60
004EC:  MOVWF  x38
004EE:  CLRF   x3B
004F0:  MOVLW  80
004F2:  MOVWF  x3A
004F4:  MOVLW  02
004F6:  MOVWF  x3C
004F8:  MOVLB  0
004FA:  RCALL  0462
....................    delay_ms(1);
004FC:  MOVLW  01
004FE:  MOVLB  6
00500:  MOVWF  x3E
00502:  MOVLB  0
00504:  RCALL  0438
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00506:  MOVLB  6
00508:  CLRF   x39
0050A:  MOVLW  61
0050C:  MOVWF  x38
0050E:  CLRF   x3B
00510:  MOVLW  90
00512:  MOVWF  x3A
00514:  MOVLW  02
00516:  MOVWF  x3C
00518:  MOVLB  0
0051A:  RCALL  0462
....................    delay_ms(1);
0051C:  MOVLW  01
0051E:  MOVLB  6
00520:  MOVWF  x3E
00522:  MOVLB  0
00524:  RCALL  0438
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00526:  MOVLB  6
00528:  CLRF   x39
0052A:  MOVLW  62
0052C:  MOVWF  x38
0052E:  CLRF   x3B
00530:  MOVLW  A0
00532:  MOVWF  x3A
00534:  MOVLW  20
00536:  MOVWF  x3C
00538:  MOVLB  0
0053A:  RCALL  0462
....................    delay_ms(1);
0053C:  MOVLW  01
0053E:  MOVLB  6
00540:  MOVWF  x3E
00542:  MOVLB  0
00544:  RCALL  0438
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00546:  MOVLB  6
00548:  CLRF   x39
0054A:  MOVLW  82
0054C:  MOVWF  x38
0054E:  CLRF   x3B
00550:  MOVLW  C0
00552:  MOVWF  x3A
00554:  MOVLW  30
00556:  MOVWF  x3C
00558:  MOVLB  0
0055A:  RCALL  0462
....................    delay_ms(1);
0055C:  MOVLW  01
0055E:  MOVLB  6
00560:  MOVWF  x3E
00562:  MOVLB  0
00564:  RCALL  0438
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00566:  MOVLB  6
00568:  CLRF   x39
0056A:  MOVLW  B2
0056C:  MOVWF  x38
0056E:  CLRF   x3B
00570:  MOVLW  F0
00572:  MOVWF  x3A
00574:  MOVLW  38
00576:  MOVWF  x3C
00578:  MOVLB  0
0057A:  RCALL  0462
....................    delay_ms(1);
0057C:  MOVLW  01
0057E:  MOVLB  6
00580:  MOVWF  x3E
00582:  MOVLB  0
00584:  RCALL  0438
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00586:  MOVLB  6
00588:  CLRF   x39
0058A:  MOVLW  F2
0058C:  MOVWF  x38
0058E:  MOVLW  01
00590:  MOVWF  x3B
00592:  MOVLW  40
00594:  MOVWF  x3A
00596:  MOVLW  01
00598:  MOVWF  x3C
0059A:  MOVLB  0
0059C:  RCALL  0462
....................    delay_ms(1);
0059E:  MOVLW  01
005A0:  MOVLB  6
005A2:  MOVWF  x3E
005A4:  MOVLB  0
005A6:  RCALL  0438
005A8:  GOTO   0678 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005AC:  MOVLB  6
005AE:  CLRF   x39
005B0:  MOVLW  20
005B2:  MOVWF  x38
005B4:  CLRF   x3B
005B6:  CLRF   x3A
005B8:  MOVLW  80
005BA:  MOVWF  x3C
005BC:  MOVLB  0
005BE:  RCALL  03E6
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005C0:  MOVLB  6
005C2:  CLRF   x39
005C4:  MOVLW  60
005C6:  MOVWF  x38
005C8:  CLRF   x3B
005CA:  MOVLW  80
005CC:  MOVWF  x3A
005CE:  MOVLW  02
005D0:  MOVWF  x3C
005D2:  MOVLB  0
005D4:  RCALL  03E6
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D6:  MOVLB  6
005D8:  CLRF   x39
005DA:  MOVLW  61
005DC:  MOVWF  x38
005DE:  CLRF   x3B
005E0:  MOVLW  90
005E2:  MOVWF  x3A
005E4:  MOVLW  02
005E6:  MOVWF  x3C
005E8:  MOVLB  0
005EA:  RCALL  03E6
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005EC:  MOVLB  6
005EE:  CLRF   x39
005F0:  MOVLW  62
005F2:  MOVWF  x38
005F4:  CLRF   x3B
005F6:  MOVLW  A0
005F8:  MOVWF  x3A
005FA:  MOVLW  20
005FC:  MOVWF  x3C
005FE:  MOVLB  0
00600:  RCALL  03E6
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00602:  MOVLB  6
00604:  CLRF   x39
00606:  MOVLW  82
00608:  MOVWF  x38
0060A:  CLRF   x3B
0060C:  MOVLW  C0
0060E:  MOVWF  x3A
00610:  MOVLW  30
00612:  MOVWF  x3C
00614:  MOVLB  0
00616:  RCALL  03E6
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00618:  MOVLB  6
0061A:  CLRF   x39
0061C:  MOVLW  B2
0061E:  MOVWF  x38
00620:  CLRF   x3B
00622:  MOVLW  F0
00624:  MOVWF  x3A
00626:  MOVLW  38
00628:  MOVWF  x3C
0062A:  MOVLB  0
0062C:  RCALL  03E6
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0062E:  MOVLB  6
00630:  CLRF   x39
00632:  MOVLW  F2
00634:  MOVWF  x38
00636:  MOVLW  01
00638:  MOVWF  x3B
0063A:  MOVLW  40
0063C:  MOVWF  x3A
0063E:  MOVLW  01
00640:  MOVWF  x3C
00642:  MOVLB  0
00644:  RCALL  03E6
00646:  GOTO   067C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064A:  MOVLB  6
0064C:  CLRF   x39
0064E:  MOVLW  F2
00650:  MOVWF  x38
00652:  MOVLW  01
00654:  MOVWF  x3B
00656:  MOVLW  40
00658:  MOVWF  x3A
0065A:  MOVLW  01
0065C:  MOVWF  x3C
0065E:  MOVLB  0
00660:  RCALL  03E6
....................    delay_ms(1);
00662:  MOVLW  01
00664:  MOVLB  6
00666:  MOVWF  x3E
00668:  MOVLB  0
0066A:  RCALL  0438
....................    if (paramsValid != isValid)
0066C:  MOVF   xF2,W
0066E:  SUBLW  AA
00670:  BZ    067A
....................    {
....................       paramsValid = isValid;
00672:  MOVLW  AA
00674:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00676:  BRA    04C8
....................    }
00678:  BRA    067C
....................    else
....................    {
....................       params_load_from_ee();
0067A:  BRA    05AC
....................    }
0067C:  GOTO   A82A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00680:  RCALL  0136
....................    switch(ch)
00682:  MOVLB  6
00684:  MOVF   x49,W
00686:  ADDLW  FC
00688:  BC    06BC
0068A:  ADDLW  04
0068C:  MOVLB  0
0068E:  GOTO   06C8
....................    {
....................       case 0:
....................          output_low(_CS0);
00692:  MOVLW  1F
00694:  MOVWF  F8A
00696:  BCF    F85.5
....................       break; 
00698:  MOVLB  6
0069A:  BRA    06BC
....................       case 1:
....................          output_low(_CS1);
0069C:  MOVLW  1F
0069E:  MOVWF  F8A
006A0:  BCF    F85.6
....................       break;   
006A2:  MOVLB  6
006A4:  BRA    06BC
....................       case 2:
....................          output_low(_CS2);
006A6:  MOVLW  1F
006A8:  MOVWF  F8A
006AA:  BCF    F85.7
....................       break;
006AC:  MOVLB  6
006AE:  BRA    06BC
....................       case 3:
....................          output_low(_CS3);
006B0:  MOVLW  C4
006B2:  MOVWF  F88
006B4:  BCF    F83.0
....................       break;              
006B6:  MOVLB  6
006B8:  BRA    06BC
006BA:  MOVLB  6
....................    }
....................    delay_us(10);
006BC:  MOVLW  35
006BE:  MOVWF  00
006C0:  DECFSZ 00,F
006C2:  BRA    06C0
006C4:  MOVLB  0
006C6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   xB5,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006EA:  MOVFF  647,649
006EE:  RCALL  0680
....................    spi_write2(command);
006F0:  MOVLB  E
006F2:  MOVF   x8D,W
006F4:  MOVFF  648,E8D
006F8:  RRCF   x90,W
006FA:  BNC   06F8
006FC:  MOVLB  0
006FE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  6B3,6B5
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  6B4,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
016D8:  MOVFF  646,649
016DC:  CALL   0680
....................    spi_read2(command);
016E0:  MOVLB  E
016E2:  MOVF   x8D,W
016E4:  MOVFF  647,E8D
016E8:  RRCF   x90,W
016EA:  BNC   16E8
016EC:  MOVLB  0
016EE:  GOTO   1700 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00726:  MOVLB  6
00728:  MOVF   x44,W
0072A:  IORLW  40
0072C:  MOVWF  x46
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0072E:  MOVFF  643,647
00732:  MOVFF  646,648
00736:  MOVLB  0
00738:  RCALL  06EA
....................    spi_write2(data);
0073A:  MOVLB  E
0073C:  MOVF   x8D,W
0073E:  MOVFF  645,E8D
00742:  RRCF   x90,W
00744:  BNC   0742
....................    ads_deselect_all();
00746:  MOVLB  0
00748:  RCALL  0136
0074A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  6B2,6B3
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  xB4
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(10);
001B0:  MOVLW  35
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
....................    ads_deselect_all();
001B8:  RCALL  0136
001BA:  GOTO   0200 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
016F2:  MOVFF  641,646
016F6:  MOVLW  10
016F8:  MOVLB  6
016FA:  MOVWF  x47
016FC:  MOVLB  0
016FE:  BRA    16D8
....................    data.dBytes[0] = 0;
01700:  MOVLB  6
01702:  CLRF   x42
....................    data.dBytes[3] = spi_read2(0);
01704:  MOVLB  E
01706:  MOVF   x8D,W
01708:  CLRF   x8D
0170A:  RRCF   x90,W
0170C:  BNC   170A
0170E:  MOVFF  E8D,645
....................    data.dBytes[2] = spi_read2(0);
01712:  MOVF   x8D,W
01714:  CLRF   x8D
01716:  RRCF   x90,W
01718:  BNC   1716
0171A:  MOVFF  E8D,644
....................    data.dBytes[1] = spi_read2(0);
0171E:  MOVF   x8D,W
01720:  CLRF   x8D
01722:  RRCF   x90,W
01724:  BNC   1722
01726:  MOVFF  E8D,643
....................    
....................    ads_deselect_all();
0172A:  MOVLB  0
0172C:  CALL   0136
....................    return data.dWord;
01730:  MOVFF  642,00
01734:  MOVFF  643,01
01738:  MOVFF  644,02
0173C:  MOVFF  645,03
01740:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0074C:  MOVFF  63E,647
00750:  MOVLW  06
00752:  MOVLB  6
00754:  MOVWF  x48
00756:  MOVLB  0
00758:  RCALL  06EA
....................    delay_us(300);                    
0075A:  MOVLW  02
0075C:  MOVLB  6
0075E:  MOVWF  x43
00760:  MOVLW  96
00762:  MOVWF  x44
00764:  MOVLB  0
00766:  BRA    0700
00768:  MOVLB  6
0076A:  DECFSZ x43,F
0076C:  BRA    0760
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0076E:  MOVFF  63E,643
00772:  CLRF   x44
00774:  MOVFF  63F,645
00778:  MOVLB  0
0077A:  RCALL  0726
....................    ads_write_reg(ch, reg1, rc1);
0077C:  MOVFF  63E,643
00780:  MOVLW  04
00782:  MOVLB  6
00784:  MOVWF  x44
00786:  MOVFF  640,645
0078A:  MOVLB  0
0078C:  RCALL  0726
....................    ads_write_reg(ch, reg2, rc2);
0078E:  MOVFF  63E,643
00792:  MOVLW  08
00794:  MOVLB  6
00796:  MOVWF  x44
00798:  MOVFF  641,645
0079C:  MOVLB  0
0079E:  RCALL  0726
....................    ads_write_reg(ch, reg3, rc3);  
007A0:  MOVFF  63E,643
007A4:  MOVLW  0C
007A6:  MOVLB  6
007A8:  MOVWF  x44
007AA:  MOVFF  642,645
007AE:  MOVLB  0
007B0:  RCALL  0726
007B2:  GOTO   07EE (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
029CA:  MOVLB  6
029CC:  BCF    x82.0
....................    y = x;
029CE:  MOVFF  676,67B
029D2:  MOVFF  675,67A
029D6:  MOVFF  674,679
029DA:  MOVFF  673,678
.................... 
....................    if (x < 0)
029DE:  MOVFF  676,686
029E2:  MOVFF  675,685
029E6:  MOVFF  674,684
029EA:  MOVFF  673,683
029EE:  CLRF   x8A
029F0:  CLRF   x89
029F2:  CLRF   x88
029F4:  CLRF   x87
029F6:  MOVLB  0
029F8:  CALL   1F9A
029FC:  BNC   2A0A
....................    {
....................       s = 1;
029FE:  MOVLB  6
02A00:  BSF    x82.0
....................       y = -y;
02A02:  MOVF   x79,W
02A04:  XORLW  80
02A06:  MOVWF  x79
02A08:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02A0A:  MOVFF  67B,686
02A0E:  MOVFF  67A,685
02A12:  MOVFF  679,684
02A16:  MOVFF  678,683
02A1A:  MOVLB  6
02A1C:  CLRF   x8A
02A1E:  CLRF   x89
02A20:  CLRF   x88
02A22:  MOVLW  8E
02A24:  MOVWF  x87
02A26:  MOVLB  0
02A28:  CALL   1F9A
02A2C:  BC    2A30
02A2E:  BNZ   2A60
....................       res = (float32)(unsigned int16)y;
02A30:  MOVFF  67B,686
02A34:  MOVFF  67A,685
02A38:  MOVFF  679,684
02A3C:  MOVFF  678,683
02A40:  RCALL  298E
02A42:  MOVFF  02,688
02A46:  MOVFF  01,687
02A4A:  CALL   0DB6
02A4E:  MOVFF  03,67F
02A52:  MOVFF  02,67E
02A56:  MOVFF  01,67D
02A5A:  MOVFF  00,67C
02A5E:  BRA    2C02
.................... 
....................  else if (y < 10000000.0)
02A60:  MOVFF  67B,686
02A64:  MOVFF  67A,685
02A68:  MOVFF  679,684
02A6C:  MOVFF  678,683
02A70:  MOVLW  80
02A72:  MOVLB  6
02A74:  MOVWF  x8A
02A76:  MOVLW  96
02A78:  MOVWF  x89
02A7A:  MOVLW  18
02A7C:  MOVWF  x88
02A7E:  MOVLW  96
02A80:  MOVWF  x87
02A82:  MOVLB  0
02A84:  CALL   1F9A
02A88:  BTFSS  FD8.0
02A8A:  BRA    2BF2
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02A8C:  MOVFF  67B,68B
02A90:  MOVFF  67A,68A
02A94:  MOVFF  679,689
02A98:  MOVFF  678,688
02A9C:  MOVLB  6
02A9E:  CLRF   x8F
02AA0:  CLRF   x8E
02AA2:  CLRF   x8D
02AA4:  MOVLW  70
02AA6:  MOVWF  x8C
02AA8:  MOVLB  0
02AAA:  CALL   0DEC
02AAE:  MOVFF  03,686
02AB2:  MOVFF  02,685
02AB6:  MOVFF  01,684
02ABA:  MOVFF  00,683
02ABE:  RCALL  298E
02AC0:  MOVFF  02,681
02AC4:  MOVFF  01,680
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02AC8:  MOVFF  67B,68B
02ACC:  MOVFF  67A,68A
02AD0:  MOVFF  679,689
02AD4:  MOVFF  678,688
02AD8:  MOVLB  6
02ADA:  CLRF   x8F
02ADC:  CLRF   x8E
02ADE:  CLRF   x8D
02AE0:  MOVLW  70
02AE2:  MOVWF  x8C
02AE4:  MOVLB  0
02AE6:  CALL   0DEC
02AEA:  MOVFF  03,686
02AEE:  MOVFF  02,685
02AF2:  MOVFF  01,684
02AF6:  MOVFF  00,683
02AFA:  MOVFF  681,688
02AFE:  MOVFF  680,687
02B02:  CALL   0DB6
02B06:  BSF    FD8.1
02B08:  MOVFF  686,68A
02B0C:  MOVFF  685,689
02B10:  MOVFF  684,688
02B14:  MOVFF  683,687
02B18:  MOVFF  03,68E
02B1C:  MOVFF  02,68D
02B20:  MOVFF  01,68C
02B24:  MOVFF  00,68B
02B28:  CALL   0EE2
02B2C:  MOVLB  6
02B2E:  CLRF   x8B
02B30:  CLRF   x8A
02B32:  CLRF   x89
02B34:  MOVLW  8E
02B36:  MOVWF  x88
02B38:  MOVFF  03,68F
02B3C:  MOVFF  02,68E
02B40:  MOVFF  01,68D
02B44:  MOVFF  00,68C
02B48:  MOVLB  0
02B4A:  CALL   0DEC
02B4E:  MOVFF  03,67B
02B52:  MOVFF  02,67A
02B56:  MOVFF  01,679
02B5A:  MOVFF  00,678
....................       res = 32768.0*(float32)l;
02B5E:  MOVFF  681,688
02B62:  MOVFF  680,687
02B66:  CALL   0DB6
02B6A:  MOVLB  6
02B6C:  CLRF   x8B
02B6E:  CLRF   x8A
02B70:  CLRF   x89
02B72:  MOVLW  8E
02B74:  MOVWF  x88
02B76:  MOVFF  03,68F
02B7A:  MOVFF  02,68E
02B7E:  MOVFF  01,68D
02B82:  MOVFF  00,68C
02B86:  MOVLB  0
02B88:  CALL   0DEC
02B8C:  MOVFF  03,67F
02B90:  MOVFF  02,67E
02B94:  MOVFF  01,67D
02B98:  MOVFF  00,67C
....................       res += (float32)(unsigned int16)y;
02B9C:  MOVFF  67B,686
02BA0:  MOVFF  67A,685
02BA4:  MOVFF  679,684
02BA8:  MOVFF  678,683
02BAC:  RCALL  298E
02BAE:  MOVFF  02,688
02BB2:  MOVFF  01,687
02BB6:  CALL   0DB6
02BBA:  BCF    FD8.1
02BBC:  MOVFF  67F,68A
02BC0:  MOVFF  67E,689
02BC4:  MOVFF  67D,688
02BC8:  MOVFF  67C,687
02BCC:  MOVFF  03,68E
02BD0:  MOVFF  02,68D
02BD4:  MOVFF  01,68C
02BD8:  MOVFF  00,68B
02BDC:  CALL   0EE2
02BE0:  MOVFF  03,67F
02BE4:  MOVFF  02,67E
02BE8:  MOVFF  01,67D
02BEC:  MOVFF  00,67C
....................    }
02BF0:  BRA    2C02
.................... 
....................  else
....................   res = y;
02BF2:  MOVFF  67B,67F
02BF6:  MOVFF  67A,67E
02BFA:  MOVFF  679,67D
02BFE:  MOVFF  678,67C
.................... 
....................  y = y - (float32)(unsigned int16)y;
02C02:  MOVFF  67B,686
02C06:  MOVFF  67A,685
02C0A:  MOVFF  679,684
02C0E:  MOVFF  678,683
02C12:  RCALL  298E
02C14:  MOVFF  02,688
02C18:  MOVFF  01,687
02C1C:  CALL   0DB6
02C20:  BSF    FD8.1
02C22:  MOVFF  67B,68A
02C26:  MOVFF  67A,689
02C2A:  MOVFF  679,688
02C2E:  MOVFF  678,687
02C32:  MOVFF  03,68E
02C36:  MOVFF  02,68D
02C3A:  MOVFF  01,68C
02C3E:  MOVFF  00,68B
02C42:  CALL   0EE2
02C46:  MOVFF  03,67B
02C4A:  MOVFF  02,67A
02C4E:  MOVFF  01,679
02C52:  MOVFF  00,678
.................... 
....................  if (s)
02C56:  MOVLB  6
02C58:  BTFSS  x82.0
02C5A:  BRA    2C62
....................   res = -res;
02C5C:  MOVF   x7D,W
02C5E:  XORLW  80
02C60:  MOVWF  x7D
.................... 
....................  if (y != 0)
02C62:  MOVFF  67B,686
02C66:  MOVFF  67A,685
02C6A:  MOVFF  679,684
02C6E:  MOVFF  678,683
02C72:  CLRF   x8A
02C74:  CLRF   x89
02C76:  CLRF   x88
02C78:  CLRF   x87
02C7A:  MOVLB  0
02C7C:  CALL   1F9A
02C80:  BZ    2CFA
....................  {
....................   if (s == 1 && n == 0)
02C82:  MOVLB  6
02C84:  BTFSS  x82.0
02C86:  BRA    2CC0
02C88:  MOVF   x77,F
02C8A:  BNZ   2CC0
....................    res -= 1.0;
02C8C:  BSF    FD8.1
02C8E:  MOVFF  67F,68A
02C92:  MOVFF  67E,689
02C96:  MOVFF  67D,688
02C9A:  MOVFF  67C,687
02C9E:  CLRF   x8E
02CA0:  CLRF   x8D
02CA2:  CLRF   x8C
02CA4:  MOVLW  7F
02CA6:  MOVWF  x8B
02CA8:  MOVLB  0
02CAA:  CALL   0EE2
02CAE:  MOVFF  03,67F
02CB2:  MOVFF  02,67E
02CB6:  MOVFF  01,67D
02CBA:  MOVFF  00,67C
02CBE:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
02CC0:  BTFSC  x82.0
02CC2:  BRA    2CFC
02CC4:  DECFSZ x77,W
02CC6:  BRA    2CFC
....................    res += 1.0;
02CC8:  BCF    FD8.1
02CCA:  MOVFF  67F,68A
02CCE:  MOVFF  67E,689
02CD2:  MOVFF  67D,688
02CD6:  MOVFF  67C,687
02CDA:  CLRF   x8E
02CDC:  CLRF   x8D
02CDE:  CLRF   x8C
02CE0:  MOVLW  7F
02CE2:  MOVWF  x8B
02CE4:  MOVLB  0
02CE6:  CALL   0EE2
02CEA:  MOVFF  03,67F
02CEE:  MOVFF  02,67E
02CF2:  MOVFF  01,67D
02CF6:  MOVFF  00,67C
02CFA:  MOVLB  6
....................  }
....................  if (x == 0)
02CFC:  MOVFF  676,686
02D00:  MOVFF  675,685
02D04:  MOVFF  674,684
02D08:  MOVFF  673,683
02D0C:  CLRF   x8A
02D0E:  CLRF   x89
02D10:  CLRF   x88
02D12:  CLRF   x87
02D14:  MOVLB  0
02D16:  CALL   1F9A
02D1A:  BNZ   2D28
....................     res = 0;
02D1C:  MOVLB  6
02D1E:  CLRF   x7F
02D20:  CLRF   x7E
02D22:  CLRF   x7D
02D24:  CLRF   x7C
02D26:  MOVLB  0
.................... 
....................  return (res);
02D28:  MOVFF  67C,00
02D2C:  MOVFF  67D,01
02D30:  MOVFF  67E,02
02D34:  MOVFF  67F,03
02D38:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02D58:  MOVFF  672,676
02D5C:  MOVFF  671,675
02D60:  MOVFF  670,674
02D64:  MOVFF  66F,673
02D68:  MOVLB  6
02D6A:  CLRF   x77
02D6C:  MOVLB  0
02D6E:  RCALL  29CA
02D70:  GOTO   2E7C (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02D3A:  MOVFF  672,676
02D3E:  MOVFF  671,675
02D42:  MOVFF  670,674
02D46:  MOVFF  66F,673
02D4A:  MOVLW  01
02D4C:  MOVLB  6
02D4E:  MOVWF  x77
02D50:  MOVLB  0
02D52:  RCALL  29CA
02D54:  GOTO   2E34 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02D74:  MOVFF  666,686
02D78:  MOVFF  665,685
02D7C:  MOVFF  664,684
02D80:  MOVFF  663,683
02D84:  MOVLB  6
02D86:  CLRF   x8A
02D88:  CLRF   x89
02D8A:  CLRF   x88
02D8C:  CLRF   x87
02D8E:  MOVLB  0
02D90:  CALL   1F9A
02D94:  BTFSC  FD8.2
02D96:  BRA    2ED8
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02D98:  MOVFF  662,67F
02D9C:  MOVFF  661,67E
02DA0:  MOVFF  660,67D
02DA4:  MOVFF  65F,67C
02DA8:  MOVFF  666,683
02DAC:  MOVFF  665,682
02DB0:  MOVFF  664,681
02DB4:  MOVFF  663,680
02DB8:  CALL   2014
02DBC:  MOVFF  03,66E
02DC0:  MOVFF  02,66D
02DC4:  MOVFF  01,66C
02DC8:  MOVFF  00,66B
02DCC:  MOVFF  03,686
02DD0:  MOVFF  02,685
02DD4:  MOVFF  01,684
02DD8:  MOVFF  00,683
02DDC:  MOVLB  6
02DDE:  CLRF   x8A
02DE0:  CLRF   x89
02DE2:  CLRF   x88
02DE4:  CLRF   x87
02DE6:  MOVLB  0
02DE8:  CALL   1F9A
02DEC:  BNC   2E36
02DEE:  MOVFF  662,67F
02DF2:  MOVFF  661,67E
02DF6:  MOVFF  660,67D
02DFA:  MOVFF  65F,67C
02DFE:  MOVFF  666,683
02E02:  MOVFF  665,682
02E06:  MOVFF  664,681
02E0A:  MOVFF  663,680
02E0E:  CALL   2014
02E12:  MOVFF  03,66E
02E16:  MOVFF  02,66D
02E1A:  MOVFF  01,66C
02E1E:  MOVFF  00,66B
02E22:  MOVFF  03,672
02E26:  MOVFF  02,671
02E2A:  MOVFF  01,670
02E2E:  MOVFF  00,66F
02E32:  BRA    2D3A
02E34:  BRA    2E7C
02E36:  MOVFF  662,67F
02E3A:  MOVFF  661,67E
02E3E:  MOVFF  660,67D
02E42:  MOVFF  65F,67C
02E46:  MOVFF  666,683
02E4A:  MOVFF  665,682
02E4E:  MOVFF  664,681
02E52:  MOVFF  663,680
02E56:  CALL   2014
02E5A:  MOVFF  03,66E
02E5E:  MOVFF  02,66D
02E62:  MOVFF  01,66C
02E66:  MOVFF  00,66B
02E6A:  MOVFF  03,672
02E6E:  MOVFF  02,671
02E72:  MOVFF  01,670
02E76:  MOVFF  00,66F
02E7A:  BRA    2D58
02E7C:  MOVFF  03,66A
02E80:  MOVFF  02,669
02E84:  MOVFF  01,668
02E88:  MOVFF  00,667
....................       return(x-(i*y));
02E8C:  MOVFF  66A,68B
02E90:  MOVFF  669,68A
02E94:  MOVFF  668,689
02E98:  MOVFF  667,688
02E9C:  MOVFF  666,68F
02EA0:  MOVFF  665,68E
02EA4:  MOVFF  664,68D
02EA8:  MOVFF  663,68C
02EAC:  CALL   0DEC
02EB0:  BSF    FD8.1
02EB2:  MOVFF  662,68A
02EB6:  MOVFF  661,689
02EBA:  MOVFF  660,688
02EBE:  MOVFF  65F,687
02EC2:  MOVFF  03,68E
02EC6:  MOVFF  02,68D
02ECA:  MOVFF  01,68C
02ECE:  MOVFF  00,68B
02ED2:  CALL   0EE2
02ED6:  BRA    2ED8
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02ED8:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
0326E:  MOVFF  666,68B
03272:  MOVFF  665,68A
03276:  MOVFF  664,689
0327A:  MOVFF  663,688
0327E:  MOVLW  3B
03280:  MOVLB  6
03282:  MOVWF  x8F
03284:  MOVLW  AA
03286:  MOVWF  x8E
03288:  MOVLW  38
0328A:  MOVWF  x8D
0328C:  MOVLW  7F
0328E:  MOVWF  x8C
03290:  MOVLB  0
03292:  CALL   0DEC
03296:  MOVFF  03,686
0329A:  MOVFF  02,685
0329E:  MOVFF  01,684
032A2:  MOVFF  00,683
032A6:  CALL   298E
032AA:  MOVFF  01,673
....................    s = 0;
032AE:  MOVLB  6
032B0:  BCF    x74.0
....................    y = x;
032B2:  MOVFF  666,66A
032B6:  MOVFF  665,669
032BA:  MOVFF  664,668
032BE:  MOVFF  663,667
.................... 
....................    if (x < 0)
032C2:  MOVFF  666,686
032C6:  MOVFF  665,685
032CA:  MOVFF  664,684
032CE:  MOVFF  663,683
032D2:  CLRF   x8A
032D4:  CLRF   x89
032D6:  CLRF   x88
032D8:  CLRF   x87
032DA:  MOVLB  0
032DC:  CALL   1F9A
032E0:  BNC   32F0
....................    {
....................       s = 1;
032E2:  MOVLB  6
032E4:  BSF    x74.0
....................       n = -n;
032E6:  NEGF   x73
....................       y = -y;
032E8:  MOVF   x68,W
032EA:  XORLW  80
032EC:  MOVWF  x68
032EE:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
032F0:  MOVLB  6
032F2:  CLRF   x6E
032F4:  CLRF   x6D
032F6:  CLRF   x6C
032F8:  CLRF   x6B
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
032FA:  MOVLW  06
032FC:  MOVWF  x76
032FE:  MOVLW  6B
03300:  MOVFF  676,FEA
03304:  MOVWF  FE9
03306:  MOVLW  7F
03308:  ADDWF  x73,W
0330A:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0330C:  MOVFF  66A,68B
03310:  MOVFF  669,68A
03314:  MOVFF  668,689
03318:  MOVFF  667,688
0331C:  MOVLW  3B
0331E:  MOVWF  x8F
03320:  MOVLW  AA
03322:  MOVWF  x8E
03324:  MOVLW  38
03326:  MOVWF  x8D
03328:  MOVLW  7F
0332A:  MOVWF  x8C
0332C:  MOVLB  0
0332E:  CALL   0DEC
03332:  MOVFF  03,678
03336:  MOVFF  02,677
0333A:  MOVFF  01,676
0333E:  MOVFF  00,675
03342:  MOVLB  6
03344:  CLRF   x7A
03346:  MOVFF  673,679
0334A:  BTFSC  x79.7
0334C:  DECF   x7A,F
0334E:  MOVLB  0
03350:  CALL   293E
03354:  BSF    FD8.1
03356:  MOVFF  678,68A
0335A:  MOVFF  677,689
0335E:  MOVFF  676,688
03362:  MOVFF  675,687
03366:  MOVFF  03,68E
0336A:  MOVFF  02,68D
0336E:  MOVFF  01,68C
03372:  MOVFF  00,68B
03376:  CALL   0EE2
0337A:  MOVFF  03,66A
0337E:  MOVFF  02,669
03382:  MOVFF  01,668
03386:  MOVFF  00,667
.................... 
....................    r = pe[0]*y + pe[1];
0338A:  MOVLW  7C
0338C:  MOVLB  6
0338E:  MOVWF  x8B
03390:  MOVLW  88
03392:  MOVWF  x8A
03394:  MOVLW  59
03396:  MOVWF  x89
03398:  MOVLW  72
0339A:  MOVWF  x88
0339C:  MOVFF  66A,68F
033A0:  MOVFF  669,68E
033A4:  MOVFF  668,68D
033A8:  MOVFF  667,68C
033AC:  MOVLB  0
033AE:  CALL   0DEC
033B2:  MOVFF  03,678
033B6:  MOVFF  02,677
033BA:  MOVFF  01,676
033BE:  MOVFF  00,675
033C2:  BCF    FD8.1
033C4:  MOVFF  03,68A
033C8:  MOVFF  02,689
033CC:  MOVFF  01,688
033D0:  MOVFF  00,687
033D4:  MOVLW  E0
033D6:  MOVLB  6
033D8:  MOVWF  x8E
033DA:  MOVLW  97
033DC:  MOVWF  x8D
033DE:  MOVLW  26
033E0:  MOVWF  x8C
033E2:  MOVLW  75
033E4:  MOVWF  x8B
033E6:  MOVLB  0
033E8:  CALL   0EE2
033EC:  MOVFF  03,672
033F0:  MOVFF  02,671
033F4:  MOVFF  01,670
033F8:  MOVFF  00,66F
....................    r = r*y + pe[2];
033FC:  MOVFF  672,68B
03400:  MOVFF  671,68A
03404:  MOVFF  670,689
03408:  MOVFF  66F,688
0340C:  MOVFF  66A,68F
03410:  MOVFF  669,68E
03414:  MOVFF  668,68D
03418:  MOVFF  667,68C
0341C:  CALL   0DEC
03420:  MOVFF  03,678
03424:  MOVFF  02,677
03428:  MOVFF  01,676
0342C:  MOVFF  00,675
03430:  BCF    FD8.1
03432:  MOVFF  03,68A
03436:  MOVFF  02,689
0343A:  MOVFF  01,688
0343E:  MOVFF  00,687
03442:  MOVLW  C4
03444:  MOVLB  6
03446:  MOVWF  x8E
03448:  MOVLW  1D
0344A:  MOVWF  x8D
0344C:  MOVLW  1E
0344E:  MOVWF  x8C
03450:  MOVLW  78
03452:  MOVWF  x8B
03454:  MOVLB  0
03456:  CALL   0EE2
0345A:  MOVFF  03,672
0345E:  MOVFF  02,671
03462:  MOVFF  01,670
03466:  MOVFF  00,66F
....................    r = r*y + pe[3];
0346A:  MOVFF  672,68B
0346E:  MOVFF  671,68A
03472:  MOVFF  670,689
03476:  MOVFF  66F,688
0347A:  MOVFF  66A,68F
0347E:  MOVFF  669,68E
03482:  MOVFF  668,68D
03486:  MOVFF  667,68C
0348A:  CALL   0DEC
0348E:  MOVFF  03,678
03492:  MOVFF  02,677
03496:  MOVFF  01,676
0349A:  MOVFF  00,675
0349E:  BCF    FD8.1
034A0:  MOVFF  03,68A
034A4:  MOVFF  02,689
034A8:  MOVFF  01,688
034AC:  MOVFF  00,687
034B0:  MOVLW  5E
034B2:  MOVLB  6
034B4:  MOVWF  x8E
034B6:  MOVLW  50
034B8:  MOVWF  x8D
034BA:  MOVLW  63
034BC:  MOVWF  x8C
034BE:  MOVLW  7A
034C0:  MOVWF  x8B
034C2:  MOVLB  0
034C4:  CALL   0EE2
034C8:  MOVFF  03,672
034CC:  MOVFF  02,671
034D0:  MOVFF  01,670
034D4:  MOVFF  00,66F
....................    r = r*y + pe[4];
034D8:  MOVFF  672,68B
034DC:  MOVFF  671,68A
034E0:  MOVFF  670,689
034E4:  MOVFF  66F,688
034E8:  MOVFF  66A,68F
034EC:  MOVFF  669,68E
034F0:  MOVFF  668,68D
034F4:  MOVFF  667,68C
034F8:  CALL   0DEC
034FC:  MOVFF  03,678
03500:  MOVFF  02,677
03504:  MOVFF  01,676
03508:  MOVFF  00,675
0350C:  BCF    FD8.1
0350E:  MOVFF  03,68A
03512:  MOVFF  02,689
03516:  MOVFF  01,688
0351A:  MOVFF  00,687
0351E:  MOVLW  1A
03520:  MOVLB  6
03522:  MOVWF  x8E
03524:  MOVLW  FE
03526:  MOVWF  x8D
03528:  MOVLW  75
0352A:  MOVWF  x8C
0352C:  MOVLW  7C
0352E:  MOVWF  x8B
03530:  MOVLB  0
03532:  CALL   0EE2
03536:  MOVFF  03,672
0353A:  MOVFF  02,671
0353E:  MOVFF  01,670
03542:  MOVFF  00,66F
....................    r = r*y + pe[5];
03546:  MOVFF  672,68B
0354A:  MOVFF  671,68A
0354E:  MOVFF  670,689
03552:  MOVFF  66F,688
03556:  MOVFF  66A,68F
0355A:  MOVFF  669,68E
0355E:  MOVFF  668,68D
03562:  MOVFF  667,68C
03566:  CALL   0DEC
0356A:  MOVFF  03,678
0356E:  MOVFF  02,677
03572:  MOVFF  01,676
03576:  MOVFF  00,675
0357A:  BCF    FD8.1
0357C:  MOVFF  03,68A
03580:  MOVFF  02,689
03584:  MOVFF  01,688
03588:  MOVFF  00,687
0358C:  MOVLW  18
0358E:  MOVLB  6
03590:  MOVWF  x8E
03592:  MOVLW  72
03594:  MOVWF  x8D
03596:  MOVLW  31
03598:  MOVWF  x8C
0359A:  MOVLW  7E
0359C:  MOVWF  x8B
0359E:  MOVLB  0
035A0:  CALL   0EE2
035A4:  MOVFF  03,672
035A8:  MOVFF  02,671
035AC:  MOVFF  01,670
035B0:  MOVFF  00,66F
.................... 
....................    res = res*(1.0 + y*r);
035B4:  MOVFF  66A,68B
035B8:  MOVFF  669,68A
035BC:  MOVFF  668,689
035C0:  MOVFF  667,688
035C4:  MOVFF  672,68F
035C8:  MOVFF  671,68E
035CC:  MOVFF  670,68D
035D0:  MOVFF  66F,68C
035D4:  CALL   0DEC
035D8:  BCF    FD8.1
035DA:  MOVLB  6
035DC:  CLRF   x8A
035DE:  CLRF   x89
035E0:  CLRF   x88
035E2:  MOVLW  7F
035E4:  MOVWF  x87
035E6:  MOVFF  03,68E
035EA:  MOVFF  02,68D
035EE:  MOVFF  01,68C
035F2:  MOVFF  00,68B
035F6:  MOVLB  0
035F8:  CALL   0EE2
035FC:  MOVFF  66E,68B
03600:  MOVFF  66D,68A
03604:  MOVFF  66C,689
03608:  MOVFF  66B,688
0360C:  MOVFF  03,68F
03610:  MOVFF  02,68E
03614:  MOVFF  01,68D
03618:  MOVFF  00,68C
0361C:  CALL   0DEC
03620:  MOVFF  03,66E
03624:  MOVFF  02,66D
03628:  MOVFF  01,66C
0362C:  MOVFF  00,66B
.................... 
....................    if (s)
03630:  MOVLB  6
03632:  BTFSS  x74.0
03634:  BRA    3668
....................       res = 1.0/res;
03636:  CLRF   x7F
03638:  CLRF   x7E
0363A:  CLRF   x7D
0363C:  MOVLW  7F
0363E:  MOVWF  x7C
03640:  MOVFF  66E,683
03644:  MOVFF  66D,682
03648:  MOVFF  66C,681
0364C:  MOVFF  66B,680
03650:  MOVLB  0
03652:  CALL   2014
03656:  MOVFF  03,66E
0365A:  MOVFF  02,66D
0365E:  MOVFF  01,66C
03662:  MOVFF  00,66B
03666:  MOVLB  6
....................    return(res);
03668:  MOVFF  66B,00
0366C:  MOVFF  66C,01
03670:  MOVFF  66D,02
03674:  MOVFF  66E,03
03678:  MOVLB  0
0367A:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02EDA:  MOVFF  666,66A
02EDE:  MOVFF  665,669
02EE2:  MOVFF  664,668
02EE6:  MOVFF  663,667
.................... 
....................    if (y != 1.0)
02EEA:  MOVFF  66A,686
02EEE:  MOVFF  669,685
02EF2:  MOVFF  668,684
02EF6:  MOVFF  667,683
02EFA:  MOVLB  6
02EFC:  CLRF   x8A
02EFE:  CLRF   x89
02F00:  CLRF   x88
02F02:  MOVLW  7F
02F04:  MOVWF  x87
02F06:  MOVLB  0
02F08:  CALL   1F9A
02F0C:  BTFSC  FD8.2
02F0E:  BRA    3250
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02F10:  MOVLW  06
02F12:  MOVLB  6
02F14:  MOVWF  x79
02F16:  MOVLW  67
02F18:  MOVFF  679,FEA
02F1C:  MOVWF  FE9
02F1E:  MOVLW  7E
02F20:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02F22:  BSF    FD8.1
02F24:  MOVFF  66A,68A
02F28:  MOVFF  669,689
02F2C:  MOVFF  668,688
02F30:  MOVFF  667,687
02F34:  CLRF   x8E
02F36:  CLRF   x8D
02F38:  CLRF   x8C
02F3A:  MOVLW  7F
02F3C:  MOVWF  x8B
02F3E:  MOVLB  0
02F40:  CALL   0EE2
02F44:  MOVFF  03,67B
02F48:  MOVFF  02,67A
02F4C:  MOVFF  01,679
02F50:  MOVFF  00,678
02F54:  BCF    FD8.1
02F56:  MOVFF  66A,68A
02F5A:  MOVFF  669,689
02F5E:  MOVFF  668,688
02F62:  MOVFF  667,687
02F66:  MOVLB  6
02F68:  CLRF   x8E
02F6A:  CLRF   x8D
02F6C:  CLRF   x8C
02F6E:  MOVLW  7F
02F70:  MOVWF  x8B
02F72:  MOVLB  0
02F74:  CALL   0EE2
02F78:  MOVFF  67B,67F
02F7C:  MOVFF  67A,67E
02F80:  MOVFF  679,67D
02F84:  MOVFF  678,67C
02F88:  MOVFF  03,683
02F8C:  MOVFF  02,682
02F90:  MOVFF  01,681
02F94:  MOVFF  00,680
02F98:  CALL   2014
02F9C:  MOVFF  03,66A
02FA0:  MOVFF  02,669
02FA4:  MOVFF  01,668
02FA8:  MOVFF  00,667
.................... 
....................       y2=y*y;
02FAC:  MOVFF  66A,68B
02FB0:  MOVFF  669,68A
02FB4:  MOVFF  668,689
02FB8:  MOVFF  667,688
02FBC:  MOVFF  66A,68F
02FC0:  MOVFF  669,68E
02FC4:  MOVFF  668,68D
02FC8:  MOVFF  667,68C
02FCC:  CALL   0DEC
02FD0:  MOVFF  03,676
02FD4:  MOVFF  02,675
02FD8:  MOVFF  01,674
02FDC:  MOVFF  00,673
.................... 
....................       res = pl[0]*y2 + pl[1];
02FE0:  MOVLW  99
02FE2:  MOVLB  6
02FE4:  MOVWF  x8B
02FE6:  MOVLW  47
02FE8:  MOVWF  x8A
02FEA:  MOVLW  8A
02FEC:  MOVWF  x89
02FEE:  MOVLW  7F
02FF0:  MOVWF  x88
02FF2:  MOVFF  676,68F
02FF6:  MOVFF  675,68E
02FFA:  MOVFF  674,68D
02FFE:  MOVFF  673,68C
03002:  MOVLB  0
03004:  CALL   0DEC
03008:  MOVFF  03,67B
0300C:  MOVFF  02,67A
03010:  MOVFF  01,679
03014:  MOVFF  00,678
03018:  BCF    FD8.1
0301A:  MOVFF  03,68A
0301E:  MOVFF  02,689
03022:  MOVFF  01,688
03026:  MOVFF  00,687
0302A:  MOVLB  6
0302C:  CLRF   x8E
0302E:  CLRF   x8D
03030:  CLRF   x8C
03032:  MOVLW  80
03034:  MOVWF  x8B
03036:  MOVLB  0
03038:  CALL   0EE2
0303C:  MOVFF  03,66E
03040:  MOVFF  02,66D
03044:  MOVFF  01,66C
03048:  MOVFF  00,66B
.................... 
....................       r = ql[0]*y2 + ql[1];
0304C:  MOVLW  4C
0304E:  MOVLB  6
03050:  MOVWF  x8B
03052:  MOVLW  F3
03054:  MOVWF  x8A
03056:  MOVLW  3A
03058:  MOVWF  x89
0305A:  MOVLW  7B
0305C:  MOVWF  x88
0305E:  MOVFF  676,68F
03062:  MOVFF  675,68E
03066:  MOVFF  674,68D
0306A:  MOVFF  673,68C
0306E:  MOVLB  0
03070:  CALL   0DEC
03074:  MOVFF  03,67B
03078:  MOVFF  02,67A
0307C:  MOVFF  01,679
03080:  MOVFF  00,678
03084:  BCF    FD8.1
03086:  MOVFF  03,68A
0308A:  MOVFF  02,689
0308E:  MOVFF  01,688
03092:  MOVFF  00,687
03096:  MOVLW  2B
03098:  MOVLB  6
0309A:  MOVWF  x8E
0309C:  MOVLW  9D
0309E:  MOVWF  x8D
030A0:  MOVLW  DF
030A2:  MOVWF  x8C
030A4:  MOVLW  7E
030A6:  MOVWF  x8B
030A8:  MOVLB  0
030AA:  CALL   0EE2
030AE:  MOVFF  03,672
030B2:  MOVFF  02,671
030B6:  MOVFF  01,670
030BA:  MOVFF  00,66F
....................       r = r*y2 + 1.0;
030BE:  MOVFF  672,68B
030C2:  MOVFF  671,68A
030C6:  MOVFF  670,689
030CA:  MOVFF  66F,688
030CE:  MOVFF  676,68F
030D2:  MOVFF  675,68E
030D6:  MOVFF  674,68D
030DA:  MOVFF  673,68C
030DE:  CALL   0DEC
030E2:  MOVFF  03,67B
030E6:  MOVFF  02,67A
030EA:  MOVFF  01,679
030EE:  MOVFF  00,678
030F2:  BCF    FD8.1
030F4:  MOVFF  03,68A
030F8:  MOVFF  02,689
030FC:  MOVFF  01,688
03100:  MOVFF  00,687
03104:  MOVLB  6
03106:  CLRF   x8E
03108:  CLRF   x8D
0310A:  CLRF   x8C
0310C:  MOVLW  7F
0310E:  MOVWF  x8B
03110:  MOVLB  0
03112:  CALL   0EE2
03116:  MOVFF  03,672
0311A:  MOVFF  02,671
0311E:  MOVFF  01,670
03122:  MOVFF  00,66F
.................... 
....................       res = y*res/r;
03126:  MOVFF  66A,68B
0312A:  MOVFF  669,68A
0312E:  MOVFF  668,689
03132:  MOVFF  667,688
03136:  MOVFF  66E,68F
0313A:  MOVFF  66D,68E
0313E:  MOVFF  66C,68D
03142:  MOVFF  66B,68C
03146:  CALL   0DEC
0314A:  MOVFF  03,67B
0314E:  MOVFF  02,67A
03152:  MOVFF  01,679
03156:  MOVFF  00,678
0315A:  MOVFF  03,67F
0315E:  MOVFF  02,67E
03162:  MOVFF  01,67D
03166:  MOVFF  00,67C
0316A:  MOVFF  672,683
0316E:  MOVFF  671,682
03172:  MOVFF  670,681
03176:  MOVFF  66F,680
0317A:  CALL   2014
0317E:  MOVFF  03,66E
03182:  MOVFF  02,66D
03186:  MOVFF  01,66C
0318A:  MOVFF  00,66B
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0318E:  MOVLW  06
03190:  MOVLB  6
03192:  MOVWF  x79
03194:  MOVLW  63
03196:  MOVFF  679,FEA
0319A:  MOVWF  FE9
0319C:  MOVLW  7E
0319E:  SUBWF  FEF,W
031A0:  MOVWF  x77
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
031A2:  BTFSS  x77.7
031A4:  BRA    31D0
....................          r = -(float32)-n;
031A6:  MOVLW  00
031A8:  BSF    FD8.0
031AA:  SUBFWB x77,W
031AC:  CLRF   x7A
031AE:  MOVWF  x79
031B0:  BTFSC  x79.7
031B2:  DECF   x7A,F
031B4:  MOVLB  0
031B6:  CALL   293E
031BA:  MOVFF  00,66F
031BE:  MOVF   01,W
031C0:  XORLW  80
031C2:  MOVLB  6
031C4:  MOVWF  x70
031C6:  MOVFF  02,671
031CA:  MOVFF  03,672
031CE:  BRA    31F2
....................       else
....................          r = (float32)n;
031D0:  CLRF   x7A
031D2:  MOVFF  677,679
031D6:  BTFSC  x79.7
031D8:  DECF   x7A,F
031DA:  MOVLB  0
031DC:  CALL   293E
031E0:  MOVFF  03,672
031E4:  MOVFF  02,671
031E8:  MOVFF  01,670
031EC:  MOVFF  00,66F
031F0:  MOVLB  6
.................... 
....................       res += r*LN2;
031F2:  MOVFF  672,68B
031F6:  MOVFF  671,68A
031FA:  MOVFF  670,689
031FE:  MOVFF  66F,688
03202:  MOVLW  18
03204:  MOVWF  x8F
03206:  MOVLW  72
03208:  MOVWF  x8E
0320A:  MOVLW  31
0320C:  MOVWF  x8D
0320E:  MOVLW  7E
03210:  MOVWF  x8C
03212:  MOVLB  0
03214:  CALL   0DEC
03218:  BCF    FD8.1
0321A:  MOVFF  66E,68A
0321E:  MOVFF  66D,689
03222:  MOVFF  66C,688
03226:  MOVFF  66B,687
0322A:  MOVFF  03,68E
0322E:  MOVFF  02,68D
03232:  MOVFF  01,68C
03236:  MOVFF  00,68B
0323A:  CALL   0EE2
0323E:  MOVFF  03,66E
03242:  MOVFF  02,66D
03246:  MOVFF  01,66C
0324A:  MOVFF  00,66B
....................    }
0324E:  BRA    325C
.................... 
....................    else
....................       res = 0.0;
03250:  MOVLB  6
03252:  CLRF   x6E
03254:  CLRF   x6D
03256:  CLRF   x6C
03258:  CLRF   x6B
0325A:  MOVLB  0
.................... 
....................    return(res);
0325C:  MOVFF  66B,00
03260:  MOVFF  66C,01
03264:  MOVFF  66D,02
03268:  MOVFF  66E,03
0326C:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
0367C:  MOVFF  65A,686
03680:  MOVFF  659,685
03684:  MOVFF  658,684
03688:  MOVFF  657,683
0368C:  MOVLB  6
0368E:  CLRF   x8A
03690:  CLRF   x89
03692:  CLRF   x88
03694:  CLRF   x87
03696:  MOVLB  0
03698:  CALL   1F9A
0369C:  BTFSS  FD8.0
0369E:  BRA    383A
036A0:  MOVFF  65E,662
036A4:  MOVFF  65D,661
036A8:  MOVFF  65C,660
036AC:  MOVFF  65B,65F
036B0:  MOVLB  6
036B2:  CLRF   x66
036B4:  CLRF   x65
036B6:  CLRF   x64
036B8:  MOVLW  7F
036BA:  MOVWF  x63
036BC:  MOVLB  0
036BE:  CALL   2D74
036C2:  MOVFF  03,662
036C6:  MOVFF  02,661
036CA:  MOVFF  01,660
036CE:  MOVFF  00,65F
036D2:  MOVFF  03,686
036D6:  MOVFF  02,685
036DA:  MOVFF  01,684
036DE:  MOVFF  00,683
036E2:  MOVLB  6
036E4:  CLRF   x8A
036E6:  CLRF   x89
036E8:  CLRF   x88
036EA:  CLRF   x87
036EC:  MOVLB  0
036EE:  CALL   1F9A
036F2:  BTFSS  FD8.2
036F4:  BRA    383A
....................       if(fmod(y, 2) == 0) {
036F6:  MOVFF  65E,662
036FA:  MOVFF  65D,661
036FE:  MOVFF  65C,660
03702:  MOVFF  65B,65F
03706:  MOVLB  6
03708:  CLRF   x66
0370A:  CLRF   x65
0370C:  CLRF   x64
0370E:  MOVLW  80
03710:  MOVWF  x63
03712:  MOVLB  0
03714:  CALL   2D74
03718:  MOVFF  03,662
0371C:  MOVFF  02,661
03720:  MOVFF  01,660
03724:  MOVFF  00,65F
03728:  MOVFF  03,686
0372C:  MOVFF  02,685
03730:  MOVFF  01,684
03734:  MOVFF  00,683
03738:  MOVLB  6
0373A:  CLRF   x8A
0373C:  CLRF   x89
0373E:  CLRF   x88
03740:  CLRF   x87
03742:  MOVLB  0
03744:  CALL   1F9A
03748:  BNZ   37C0
....................          return (exp(log(-x) * y));
0374A:  MOVLB  6
0374C:  MOVF   x58,W
0374E:  XORLW  80
03750:  MOVWF  x60
03752:  MOVFF  65A,666
03756:  MOVFF  659,665
0375A:  MOVWF  x64
0375C:  MOVFF  657,663
03760:  MOVLB  0
03762:  CALL   2EDA
03766:  MOVFF  03,662
0376A:  MOVFF  02,661
0376E:  MOVFF  01,660
03772:  MOVFF  00,65F
03776:  MOVFF  03,68B
0377A:  MOVFF  02,68A
0377E:  MOVFF  01,689
03782:  MOVFF  00,688
03786:  MOVFF  65E,68F
0378A:  MOVFF  65D,68E
0378E:  MOVFF  65C,68D
03792:  MOVFF  65B,68C
03796:  CALL   0DEC
0379A:  MOVFF  03,662
0379E:  MOVFF  02,661
037A2:  MOVFF  01,660
037A6:  MOVFF  00,65F
037AA:  MOVFF  03,666
037AE:  MOVFF  02,665
037B2:  MOVFF  01,664
037B6:  MOVFF  00,663
037BA:  RCALL  326E
037BC:  BRA    3978
....................       } else {
037BE:  BRA    3838
....................          return (-exp(log(-x) * y));
037C0:  MOVLB  6
037C2:  MOVF   x58,W
037C4:  XORLW  80
037C6:  MOVWF  x60
037C8:  MOVFF  65A,666
037CC:  MOVFF  659,665
037D0:  MOVWF  x64
037D2:  MOVFF  657,663
037D6:  MOVLB  0
037D8:  CALL   2EDA
037DC:  MOVFF  03,662
037E0:  MOVFF  02,661
037E4:  MOVFF  01,660
037E8:  MOVFF  00,65F
037EC:  MOVFF  03,68B
037F0:  MOVFF  02,68A
037F4:  MOVFF  01,689
037F8:  MOVFF  00,688
037FC:  MOVFF  65E,68F
03800:  MOVFF  65D,68E
03804:  MOVFF  65C,68D
03808:  MOVFF  65B,68C
0380C:  CALL   0DEC
03810:  MOVFF  03,662
03814:  MOVFF  02,661
03818:  MOVFF  01,660
0381C:  MOVFF  00,65F
03820:  MOVFF  03,666
03824:  MOVFF  02,665
03828:  MOVFF  01,664
0382C:  MOVFF  00,663
03830:  RCALL  326E
03832:  MOVLW  80
03834:  XORWF  01,F
03836:  BRA    3978
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03838:  BRA    3978
0383A:  MOVFF  65A,686
0383E:  MOVFF  659,685
03842:  MOVFF  658,684
03846:  MOVFF  657,683
0384A:  MOVLB  6
0384C:  CLRF   x8A
0384E:  CLRF   x89
03850:  CLRF   x88
03852:  CLRF   x87
03854:  MOVLB  0
03856:  CALL   1F9A
0385A:  BNC   38BC
0385C:  MOVFF  65E,662
03860:  MOVFF  65D,661
03864:  MOVFF  65C,660
03868:  MOVFF  65B,65F
0386C:  MOVLB  6
0386E:  CLRF   x66
03870:  CLRF   x65
03872:  CLRF   x64
03874:  MOVLW  7F
03876:  MOVWF  x63
03878:  MOVLB  0
0387A:  CALL   2D74
0387E:  MOVFF  03,662
03882:  MOVFF  02,661
03886:  MOVFF  01,660
0388A:  MOVFF  00,65F
0388E:  MOVFF  03,686
03892:  MOVFF  02,685
03896:  MOVFF  01,684
0389A:  MOVFF  00,683
0389E:  MOVLB  6
038A0:  CLRF   x8A
038A2:  CLRF   x89
038A4:  CLRF   x88
038A6:  CLRF   x87
038A8:  MOVLB  0
038AA:  CALL   1F9A
038AE:  BZ    38BC
....................       return 0;
038B0:  CLRF   00
038B2:  CLRF   01
038B4:  CLRF   02
038B6:  CLRF   03
038B8:  BRA    3978
....................    } else {
038BA:  BRA    3978
....................       if(x != 0 || 0 >= y) {
038BC:  MOVFF  65A,686
038C0:  MOVFF  659,685
038C4:  MOVFF  658,684
038C8:  MOVFF  657,683
038CC:  MOVLB  6
038CE:  CLRF   x8A
038D0:  CLRF   x89
038D2:  CLRF   x88
038D4:  CLRF   x87
038D6:  MOVLB  0
038D8:  CALL   1F9A
038DC:  BNZ   3902
038DE:  MOVFF  65E,686
038E2:  MOVFF  65D,685
038E6:  MOVFF  65C,684
038EA:  MOVFF  65B,683
038EE:  MOVLB  6
038F0:  CLRF   x8A
038F2:  CLRF   x89
038F4:  CLRF   x88
038F6:  CLRF   x87
038F8:  MOVLB  0
038FA:  CALL   1F9A
038FE:  BC    3902
03900:  BNZ   3970
....................          return (exp(log(x) * y));
03902:  MOVFF  65A,666
03906:  MOVFF  659,665
0390A:  MOVFF  658,664
0390E:  MOVFF  657,663
03912:  CALL   2EDA
03916:  MOVFF  03,662
0391A:  MOVFF  02,661
0391E:  MOVFF  01,660
03922:  MOVFF  00,65F
03926:  MOVFF  03,68B
0392A:  MOVFF  02,68A
0392E:  MOVFF  01,689
03932:  MOVFF  00,688
03936:  MOVFF  65E,68F
0393A:  MOVFF  65D,68E
0393E:  MOVFF  65C,68D
03942:  MOVFF  65B,68C
03946:  CALL   0DEC
0394A:  MOVFF  03,662
0394E:  MOVFF  02,661
03952:  MOVFF  01,660
03956:  MOVFF  00,65F
0395A:  MOVFF  03,666
0395E:  MOVFF  02,665
03962:  MOVFF  01,664
03966:  MOVFF  00,663
0396A:  RCALL  326E
0396C:  BRA    3978
....................       } else return 0;
0396E:  BRA    3978
03970:  CLRF   00
03972:  CLRF   01
03974:  CLRF   02
03976:  CLRF   03
....................    }
03978:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
02172:  MOVLB  6
02174:  BCF    x75.0
....................    flag = 0;
02176:  BCF    x75.1
....................    y = x;
02178:  MOVFF  668,66C
0217C:  MOVFF  667,66B
02180:  MOVFF  666,66A
02184:  MOVFF  665,669
.................... 
....................    if (x < 0)
02188:  MOVFF  668,686
0218C:  MOVFF  667,685
02190:  MOVFF  666,684
02194:  MOVFF  665,683
02198:  CLRF   x8A
0219A:  CLRF   x89
0219C:  CLRF   x88
0219E:  CLRF   x87
021A0:  MOVLB  0
021A2:  RCALL  1F9A
021A4:  BNC   21B2
....................    {
....................       s = 1;
021A6:  MOVLB  6
021A8:  BSF    x75.0
....................       y = -y;
021AA:  MOVF   x6A,W
021AC:  XORLW  80
021AE:  MOVWF  x6A
021B0:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
021B2:  MOVLB  6
021B4:  CLRF   x86
021B6:  CLRF   x85
021B8:  CLRF   x84
021BA:  MOVLW  7F
021BC:  MOVWF  x83
021BE:  MOVFF  66C,68A
021C2:  MOVFF  66B,689
021C6:  MOVFF  66A,688
021CA:  MOVFF  669,687
021CE:  MOVLB  0
021D0:  RCALL  1F9A
021D2:  BNC   220A
....................    {
....................       y = 1.0/y;
021D4:  MOVLB  6
021D6:  CLRF   x7F
021D8:  CLRF   x7E
021DA:  CLRF   x7D
021DC:  MOVLW  7F
021DE:  MOVWF  x7C
021E0:  MOVFF  66C,683
021E4:  MOVFF  66B,682
021E8:  MOVFF  66A,681
021EC:  MOVFF  669,680
021F0:  MOVLB  0
021F2:  RCALL  2014
021F4:  MOVFF  03,66C
021F8:  MOVFF  02,66B
021FC:  MOVFF  01,66A
02200:  MOVFF  00,669
....................       flag = 1;
02204:  MOVLB  6
02206:  BSF    x75.1
02208:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
0220A:  MOVLW  0A
0220C:  MOVLB  6
0220E:  MOVWF  x8B
02210:  MOVLW  89
02212:  MOVWF  x8A
02214:  MOVLW  34
02216:  MOVWF  x89
02218:  MOVLW  7C
0221A:  MOVWF  x88
0221C:  MOVFF  66C,68F
02220:  MOVFF  66B,68E
02224:  MOVFF  66A,68D
02228:  MOVFF  669,68C
0222C:  MOVLB  0
0222E:  CALL   0DEC
02232:  MOVFF  03,679
02236:  MOVFF  02,678
0223A:  MOVFF  01,677
0223E:  MOVFF  00,676
02242:  MOVFF  03,68B
02246:  MOVFF  02,68A
0224A:  MOVFF  01,689
0224E:  MOVFF  00,688
02252:  MOVFF  66C,68F
02256:  MOVFF  66B,68E
0225A:  MOVFF  66A,68D
0225E:  MOVFF  669,68C
02262:  CALL   0DEC
02266:  MOVFF  03,679
0226A:  MOVFF  02,678
0226E:  MOVFF  01,677
02272:  MOVFF  00,676
02276:  BCF    FD8.1
02278:  MOVFF  03,68A
0227C:  MOVFF  02,689
02280:  MOVFF  01,688
02284:  MOVFF  00,687
02288:  MOVLW  7C
0228A:  MOVLB  6
0228C:  MOVWF  x8E
0228E:  MOVLW  79
02290:  MOVWF  x8D
02292:  MOVLW  35
02294:  MOVWF  x8C
02296:  MOVLW  81
02298:  MOVWF  x8B
0229A:  MOVLB  0
0229C:  CALL   0EE2
022A0:  MOVFF  03,670
022A4:  MOVFF  02,66F
022A8:  MOVFF  01,66E
022AC:  MOVFF  00,66D
....................    res = res*y*y + pat[2];
022B0:  MOVFF  670,68B
022B4:  MOVFF  66F,68A
022B8:  MOVFF  66E,689
022BC:  MOVFF  66D,688
022C0:  MOVFF  66C,68F
022C4:  MOVFF  66B,68E
022C8:  MOVFF  66A,68D
022CC:  MOVFF  669,68C
022D0:  CALL   0DEC
022D4:  MOVFF  03,679
022D8:  MOVFF  02,678
022DC:  MOVFF  01,677
022E0:  MOVFF  00,676
022E4:  MOVFF  03,68B
022E8:  MOVFF  02,68A
022EC:  MOVFF  01,689
022F0:  MOVFF  00,688
022F4:  MOVFF  66C,68F
022F8:  MOVFF  66B,68E
022FC:  MOVFF  66A,68D
02300:  MOVFF  669,68C
02304:  CALL   0DEC
02308:  MOVFF  03,679
0230C:  MOVFF  02,678
02310:  MOVFF  01,677
02314:  MOVFF  00,676
02318:  BCF    FD8.1
0231A:  MOVFF  03,68A
0231E:  MOVFF  02,689
02322:  MOVFF  01,688
02326:  MOVFF  00,687
0232A:  MOVLW  3F
0232C:  MOVLB  6
0232E:  MOVWF  x8E
02330:  MOVLW  02
02332:  MOVWF  x8D
02334:  MOVLW  33
02336:  MOVWF  x8C
02338:  MOVLW  83
0233A:  MOVWF  x8B
0233C:  MOVLB  0
0233E:  CALL   0EE2
02342:  MOVFF  03,670
02346:  MOVFF  02,66F
0234A:  MOVFF  01,66E
0234E:  MOVFF  00,66D
....................    res = res*y*y + pat[3];
02352:  MOVFF  670,68B
02356:  MOVFF  66F,68A
0235A:  MOVFF  66E,689
0235E:  MOVFF  66D,688
02362:  MOVFF  66C,68F
02366:  MOVFF  66B,68E
0236A:  MOVFF  66A,68D
0236E:  MOVFF  669,68C
02372:  CALL   0DEC
02376:  MOVFF  03,679
0237A:  MOVFF  02,678
0237E:  MOVFF  01,677
02382:  MOVFF  00,676
02386:  MOVFF  03,68B
0238A:  MOVFF  02,68A
0238E:  MOVFF  01,689
02392:  MOVFF  00,688
02396:  MOVFF  66C,68F
0239A:  MOVFF  66B,68E
0239E:  MOVFF  66A,68D
023A2:  MOVFF  669,68C
023A6:  CALL   0DEC
023AA:  MOVFF  03,679
023AE:  MOVFF  02,678
023B2:  MOVFF  01,677
023B6:  MOVFF  00,676
023BA:  BCF    FD8.1
023BC:  MOVFF  03,68A
023C0:  MOVFF  02,689
023C4:  MOVFF  01,688
023C8:  MOVFF  00,687
023CC:  MOVLW  33
023CE:  MOVLB  6
023D0:  MOVWF  x8E
023D2:  MOVLW  8C
023D4:  MOVWF  x8D
023D6:  MOVLW  1E
023D8:  MOVWF  x8C
023DA:  MOVLW  83
023DC:  MOVWF  x8B
023DE:  MOVLB  0
023E0:  CALL   0EE2
023E4:  MOVFF  03,670
023E8:  MOVFF  02,66F
023EC:  MOVFF  01,66E
023F0:  MOVFF  00,66D
.................... 
....................    r = qat[0]*y*y + qat[1];
023F4:  MOVLB  6
023F6:  CLRF   x8B
023F8:  CLRF   x8A
023FA:  CLRF   x89
023FC:  MOVLW  7F
023FE:  MOVWF  x88
02400:  MOVFF  66C,68F
02404:  MOVFF  66B,68E
02408:  MOVFF  66A,68D
0240C:  MOVFF  669,68C
02410:  MOVLB  0
02412:  CALL   0DEC
02416:  MOVFF  03,679
0241A:  MOVFF  02,678
0241E:  MOVFF  01,677
02422:  MOVFF  00,676
02426:  MOVFF  03,68B
0242A:  MOVFF  02,68A
0242E:  MOVFF  01,689
02432:  MOVFF  00,688
02436:  MOVFF  66C,68F
0243A:  MOVFF  66B,68E
0243E:  MOVFF  66A,68D
02442:  MOVFF  669,68C
02446:  CALL   0DEC
0244A:  MOVFF  03,679
0244E:  MOVFF  02,678
02452:  MOVFF  01,677
02456:  MOVFF  00,676
0245A:  BCF    FD8.1
0245C:  MOVFF  03,68A
02460:  MOVFF  02,689
02464:  MOVFF  01,688
02468:  MOVFF  00,687
0246C:  MOVLW  1B
0246E:  MOVLB  6
02470:  MOVWF  x8E
02472:  MOVLW  E4
02474:  MOVWF  x8D
02476:  MOVLW  35
02478:  MOVWF  x8C
0247A:  MOVLW  82
0247C:  MOVWF  x8B
0247E:  MOVLB  0
02480:  CALL   0EE2
02484:  MOVFF  03,674
02488:  MOVFF  02,673
0248C:  MOVFF  01,672
02490:  MOVFF  00,671
....................    r = r*y*y + qat[2];
02494:  MOVFF  674,68B
02498:  MOVFF  673,68A
0249C:  MOVFF  672,689
024A0:  MOVFF  671,688
024A4:  MOVFF  66C,68F
024A8:  MOVFF  66B,68E
024AC:  MOVFF  66A,68D
024B0:  MOVFF  669,68C
024B4:  CALL   0DEC
024B8:  MOVFF  03,679
024BC:  MOVFF  02,678
024C0:  MOVFF  01,677
024C4:  MOVFF  00,676
024C8:  MOVFF  03,68B
024CC:  MOVFF  02,68A
024D0:  MOVFF  01,689
024D4:  MOVFF  00,688
024D8:  MOVFF  66C,68F
024DC:  MOVFF  66B,68E
024E0:  MOVFF  66A,68D
024E4:  MOVFF  669,68C
024E8:  CALL   0DEC
024EC:  MOVFF  03,679
024F0:  MOVFF  02,678
024F4:  MOVFF  01,677
024F8:  MOVFF  00,676
024FC:  BCF    FD8.1
024FE:  MOVFF  03,68A
02502:  MOVFF  02,689
02506:  MOVFF  01,688
0250A:  MOVFF  00,687
0250E:  MOVLW  A4
02510:  MOVLB  6
02512:  MOVWF  x8E
02514:  MOVLW  DB
02516:  MOVWF  x8D
02518:  MOVLW  67
0251A:  MOVWF  x8C
0251C:  MOVLW  83
0251E:  MOVWF  x8B
02520:  MOVLB  0
02522:  CALL   0EE2
02526:  MOVFF  03,674
0252A:  MOVFF  02,673
0252E:  MOVFF  01,672
02532:  MOVFF  00,671
....................    r = r*y*y + qat[3];
02536:  MOVFF  674,68B
0253A:  MOVFF  673,68A
0253E:  MOVFF  672,689
02542:  MOVFF  671,688
02546:  MOVFF  66C,68F
0254A:  MOVFF  66B,68E
0254E:  MOVFF  66A,68D
02552:  MOVFF  669,68C
02556:  CALL   0DEC
0255A:  MOVFF  03,679
0255E:  MOVFF  02,678
02562:  MOVFF  01,677
02566:  MOVFF  00,676
0256A:  MOVFF  03,68B
0256E:  MOVFF  02,68A
02572:  MOVFF  01,689
02576:  MOVFF  00,688
0257A:  MOVFF  66C,68F
0257E:  MOVFF  66B,68E
02582:  MOVFF  66A,68D
02586:  MOVFF  669,68C
0258A:  CALL   0DEC
0258E:  MOVFF  03,679
02592:  MOVFF  02,678
02596:  MOVFF  01,677
0259A:  MOVFF  00,676
0259E:  BCF    FD8.1
025A0:  MOVFF  03,68A
025A4:  MOVFF  02,689
025A8:  MOVFF  01,688
025AC:  MOVFF  00,687
025B0:  MOVLW  33
025B2:  MOVLB  6
025B4:  MOVWF  x8E
025B6:  MOVLW  8C
025B8:  MOVWF  x8D
025BA:  MOVLW  1E
025BC:  MOVWF  x8C
025BE:  MOVLW  83
025C0:  MOVWF  x8B
025C2:  MOVLB  0
025C4:  CALL   0EE2
025C8:  MOVFF  03,674
025CC:  MOVFF  02,673
025D0:  MOVFF  01,672
025D4:  MOVFF  00,671
.................... 
....................    res = y*res/r;
025D8:  MOVFF  66C,68B
025DC:  MOVFF  66B,68A
025E0:  MOVFF  66A,689
025E4:  MOVFF  669,688
025E8:  MOVFF  670,68F
025EC:  MOVFF  66F,68E
025F0:  MOVFF  66E,68D
025F4:  MOVFF  66D,68C
025F8:  CALL   0DEC
025FC:  MOVFF  03,679
02600:  MOVFF  02,678
02604:  MOVFF  01,677
02608:  MOVFF  00,676
0260C:  MOVFF  03,67F
02610:  MOVFF  02,67E
02614:  MOVFF  01,67D
02618:  MOVFF  00,67C
0261C:  MOVFF  674,683
02620:  MOVFF  673,682
02624:  MOVFF  672,681
02628:  MOVFF  671,680
0262C:  RCALL  2014
0262E:  MOVFF  03,670
02632:  MOVFF  02,66F
02636:  MOVFF  01,66E
0263A:  MOVFF  00,66D
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
0263E:  MOVLB  6
02640:  BTFSS  x75.1
02642:  BRA    267E
....................       res = PI_DIV_BY_TWO - res;
02644:  BSF    FD8.1
02646:  MOVLW  DB
02648:  MOVWF  x8A
0264A:  MOVLW  0F
0264C:  MOVWF  x89
0264E:  MOVLW  49
02650:  MOVWF  x88
02652:  MOVLW  7F
02654:  MOVWF  x87
02656:  MOVFF  670,68E
0265A:  MOVFF  66F,68D
0265E:  MOVFF  66E,68C
02662:  MOVFF  66D,68B
02666:  MOVLB  0
02668:  CALL   0EE2
0266C:  MOVFF  03,670
02670:  MOVFF  02,66F
02674:  MOVFF  01,66E
02678:  MOVFF  00,66D
0267C:  MOVLB  6
....................    if (s)
0267E:  BTFSS  x75.0
02680:  BRA    2688
....................       res = -res;
02682:  MOVF   x6E,W
02684:  XORLW  80
02686:  MOVWF  x6E
.................... 
....................    return(res);
02688:  MOVFF  66D,00
0268C:  MOVFF  66E,01
02690:  MOVFF  66F,02
02694:  MOVFF  670,03
02698:  MOVLB  0
0269A:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
0269C:  MOVLB  6
0269E:  BCF    x63.0
....................    quad=0; //quadrant
026A0:  CLRF   x64
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
026A2:  MOVFF  65A,686
026A6:  MOVFF  659,685
026AA:  MOVFF  658,684
026AE:  MOVFF  657,683
026B2:  CLRF   x8A
026B4:  CLRF   x89
026B6:  CLRF   x88
026B8:  CLRF   x87
026BA:  MOVLB  0
026BC:  RCALL  1F9A
026BE:  BC    26C2
026C0:  BNZ   26EC
026C2:  MOVFF  65E,686
026C6:  MOVFF  65D,685
026CA:  MOVFF  65C,684
026CE:  MOVFF  65B,683
026D2:  MOVLB  6
026D4:  CLRF   x8A
026D6:  CLRF   x89
026D8:  CLRF   x88
026DA:  CLRF   x87
026DC:  MOVLB  0
026DE:  RCALL  1F9A
026E0:  BC    26E4
026E2:  BNZ   26E8
026E4:  MOVLW  03
026E6:  BRA    26EA
026E8:  MOVLW  04
026EA:  BRA    2712
026EC:  MOVFF  65E,686
026F0:  MOVFF  65D,685
026F4:  MOVFF  65C,684
026F8:  MOVFF  65B,683
026FC:  MOVLB  6
026FE:  CLRF   x8A
02700:  CLRF   x89
02702:  CLRF   x88
02704:  CLRF   x87
02706:  MOVLB  0
02708:  RCALL  1F9A
0270A:  BNC   2710
0270C:  MOVLW  02
0270E:  BRA    2712
02710:  MOVLW  01
02712:  MOVLB  6
02714:  MOVWF  x64
....................    if(y<0.0)
02716:  MOVFF  65A,686
0271A:  MOVFF  659,685
0271E:  MOVFF  658,684
02722:  MOVFF  657,683
02726:  CLRF   x8A
02728:  CLRF   x89
0272A:  CLRF   x88
0272C:  CLRF   x87
0272E:  MOVLB  0
02730:  RCALL  1F9A
02732:  BNC   2740
....................    {
....................       sign=1;
02734:  MOVLB  6
02736:  BSF    x63.0
....................       y=-y;
02738:  MOVF   x58,W
0273A:  XORLW  80
0273C:  MOVWF  x58
0273E:  MOVLB  0
....................    }
....................    if(x<0.0)
02740:  MOVFF  65E,686
02744:  MOVFF  65D,685
02748:  MOVFF  65C,684
0274C:  MOVFF  65B,683
02750:  MOVLB  6
02752:  CLRF   x8A
02754:  CLRF   x89
02756:  CLRF   x88
02758:  CLRF   x87
0275A:  MOVLB  0
0275C:  RCALL  1F9A
0275E:  BNC   276A
....................    {
....................       x=-x;
02760:  MOVLB  6
02762:  MOVF   x5C,W
02764:  XORLW  80
02766:  MOVWF  x5C
02768:  MOVLB  0
....................    }
....................    if (x==0.0)
0276A:  MOVFF  65E,686
0276E:  MOVFF  65D,685
02772:  MOVFF  65C,684
02776:  MOVFF  65B,683
0277A:  MOVLB  6
0277C:  CLRF   x8A
0277E:  CLRF   x89
02780:  CLRF   x88
02782:  CLRF   x87
02784:  MOVLB  0
02786:  RCALL  1F9A
02788:  BNZ   27DE
....................    {
....................       if(y==0.0)
0278A:  MOVFF  65A,686
0278E:  MOVFF  659,685
02792:  MOVFF  658,684
02796:  MOVFF  657,683
0279A:  MOVLB  6
0279C:  CLRF   x8A
0279E:  CLRF   x89
027A0:  CLRF   x88
027A2:  CLRF   x87
027A4:  MOVLB  0
027A6:  CALL   1F9A
027AA:  BNZ   27AE
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
027AC:  BRA    27DC
....................       else
....................       {
....................          if(sign)
027AE:  MOVLB  6
027B0:  BTFSS  x63.0
027B2:  BRA    27C8
....................          {
....................          return (-(PI_DIV_BY_TWO));
027B4:  MOVLW  7F
027B6:  MOVWF  00
027B8:  MOVLW  C9
027BA:  MOVWF  01
027BC:  MOVLW  0F
027BE:  MOVWF  02
027C0:  MOVLW  DB
027C2:  MOVWF  03
027C4:  BRA    2916
....................          }
027C6:  BRA    27DA
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
027C8:  MOVLW  7F
027CA:  MOVWF  00
027CC:  MOVLW  49
027CE:  MOVWF  01
027D0:  MOVLW  0F
027D2:  MOVWF  02
027D4:  MOVLW  DB
027D6:  MOVWF  03
027D8:  BRA    2916
027DA:  MOVLB  0
....................          }
....................       }
....................    }
027DC:  BRA    2914
....................    else
....................    {
....................       z=y/x;
027DE:  MOVFF  65A,67F
027E2:  MOVFF  659,67E
027E6:  MOVFF  658,67D
027EA:  MOVFF  657,67C
027EE:  MOVFF  65E,683
027F2:  MOVFF  65D,682
027F6:  MOVFF  65C,681
027FA:  MOVFF  65B,680
027FE:  RCALL  2014
02800:  MOVFF  03,662
02804:  MOVFF  02,661
02808:  MOVFF  01,660
0280C:  MOVFF  00,65F
....................       switch(quad)
02810:  MOVLW  01
02812:  MOVLB  6
02814:  SUBWF  x64,W
02816:  ADDLW  FC
02818:  BTFSC  FD8.0
0281A:  BRA    2916
0281C:  ADDLW  04
0281E:  MOVLB  0
02820:  GOTO   291C
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02824:  MOVFF  662,668
02828:  MOVFF  661,667
0282C:  MOVFF  660,666
02830:  MOVFF  65F,665
02834:  RCALL  2172
02836:  MOVLB  6
02838:  BRA    2916
....................             break;
0283A:  BRA    2916
0283C:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
0283E:  MOVFF  662,668
02842:  MOVFF  661,667
02846:  MOVFF  660,666
0284A:  MOVFF  65F,665
0284E:  RCALL  2172
02850:  MOVFF  FEA,666
02854:  MOVFF  FE9,665
02858:  BSF    FD8.1
0285A:  MOVLW  DB
0285C:  MOVLB  6
0285E:  MOVWF  x8A
02860:  MOVLW  0F
02862:  MOVWF  x89
02864:  MOVLW  49
02866:  MOVWF  x88
02868:  MOVLW  80
0286A:  MOVWF  x87
0286C:  MOVFF  03,68E
02870:  MOVFF  02,68D
02874:  MOVFF  01,68C
02878:  MOVFF  00,68B
0287C:  MOVLB  0
0287E:  CALL   0EE2
02882:  MOVFF  666,FEA
02886:  MOVFF  665,FE9
0288A:  MOVLB  6
0288C:  BRA    2916
....................             break;
0288E:  BRA    2916
02890:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02892:  MOVFF  662,668
02896:  MOVFF  661,667
0289A:  MOVFF  660,666
0289E:  MOVFF  65F,665
028A2:  RCALL  2172
028A4:  MOVFF  03,668
028A8:  MOVFF  02,667
028AC:  MOVFF  01,666
028B0:  MOVFF  00,665
028B4:  MOVFF  FEA,66A
028B8:  MOVFF  FE9,669
028BC:  BSF    FD8.1
028BE:  MOVFF  03,68A
028C2:  MOVFF  02,689
028C6:  MOVFF  01,688
028CA:  MOVFF  00,687
028CE:  MOVLW  DB
028D0:  MOVLB  6
028D2:  MOVWF  x8E
028D4:  MOVLW  0F
028D6:  MOVWF  x8D
028D8:  MOVLW  49
028DA:  MOVWF  x8C
028DC:  MOVLW  80
028DE:  MOVWF  x8B
028E0:  MOVLB  0
028E2:  CALL   0EE2
028E6:  MOVFF  66A,FEA
028EA:  MOVFF  669,FE9
028EE:  MOVLB  6
028F0:  BRA    2916
....................             break;
028F2:  BRA    2916
028F4:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
028F6:  MOVFF  662,668
028FA:  MOVFF  661,667
028FE:  MOVFF  660,666
02902:  MOVFF  65F,665
02906:  RCALL  2172
02908:  MOVLW  80
0290A:  XORWF  01,F
0290C:  MOVLB  6
0290E:  BRA    2916
....................             break;
02910:  BRA    2916
02912:  MOVLB  0
02914:  MOVLB  6
....................          }
....................       }
....................    }
02916:  MOVLB  0
02918:  GOTO   4022 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 10
.................... typedef struct {
....................    int in;
....................    int out;
....................    int buff[BUFFER_SIZE];
.................... } buffer;
.................... 
.................... buffer sinQ_x;
.................... buffer cosQ_x;
.................... buffer sinQ_y;
.................... buffer cosQ_y;
.................... 
.................... #define incin(buff) ((buff->in==(BUFFER_SIZE-1))?0:buff->in+1)
.................... #define incout(buff) ((buff->out==(BUFFER_SIZE-1))?0:buff->out+1)
.................... #define isempty(buff) (buff->in==buff->out)
.................... #define hasdata(buff) (buff->in!=buff->out)
.................... #define isfull(buff) (incin(buff)==buff->out)
.................... 
.................... #define tobuff(bname,c) { bname->buff[bname->in]=c;\
....................    bname->in=incin(bname);\
....................    if (bname->in==bname->out) bname->out=incout(bname);\
....................    }
.................... #define frombuff(bname) (btemp##bname=bname->buff[bname->out],\
....................    bname->out=incout(bname), \
....................    btemp##bname)
.................... #define clrbuff(buff) buff->in=buff->out=0
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    buffer* sinQ;
....................    buffer* cosQ;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, &sinQ_x, &cosQ_x, 0, 0},
....................    {false, false, &sinQ_y, &cosQ_y, 0, 0}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
0115A:  MOVLB  F
0115C:  BTFSC  x5B.0
0115E:  BRA    16AA
....................    {
....................       switch (state)
01160:  MOVLB  1
01162:  MOVF   xAF,W
01164:  ADDLW  F9
01166:  BTFSC  FD8.0
01168:  BRA    16A8
0116A:  ADDLW  07
0116C:  MOVLB  0
0116E:  GOTO   16B0
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
01172:  MOVLB  F
01174:  BTFSC  x5B.0
01176:  BRA    1174
01178:  MOVFF  F5F,02
0117C:  MOVFF  F5E,01
01180:  MOVFF  02,639
01184:  MOVFF  01,638
01188:  MOVFF  02,688
0118C:  MOVFF  01,687
01190:  MOVLB  0
01192:  RCALL  0DB6
01194:  MOVFF  03,68B
01198:  MOVFF  02,68A
0119C:  MOVFF  01,689
011A0:  MOVFF  00,688
011A4:  MOVFF  B9,68F
011A8:  MOVFF  B8,68E
011AC:  MOVFF  B7,68D
011B0:  MOVFF  B6,68C
011B4:  RCALL  0DEC
011B6:  MOVFF  03,63B
011BA:  MOVFF  02,63A
011BE:  MOVFF  01,639
011C2:  MOVFF  00,638
011C6:  BCF    FD8.1
011C8:  MOVFF  03,68A
011CC:  MOVFF  02,689
011D0:  MOVFF  01,688
011D4:  MOVFF  00,687
011D8:  MOVFF  B5,68E
011DC:  MOVFF  B4,68D
011E0:  MOVFF  B3,68C
011E4:  MOVFF  B2,68B
011E8:  RCALL  0EE2
011EA:  MOVFF  03,F6
011EE:  MOVFF  02,F5
011F2:  MOVFF  01,F4
011F6:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
011FA:  MOVLB  F
011FC:  MOVF   x5A,W
011FE:  ANDLW  3F
01200:  MOVWF  01
01202:  MOVLW  10
01204:  MOVWF  x5A
01206:  BTFSS  x5B.7
01208:  BRA    1218
0120A:  MOVF   01,W
0120C:  SUBLW  10
0120E:  BZ    1218
01210:  BSF    x5B.0
01212:  NOP   
01214:  BTFSC  x5B.0
01216:  BRA    1214
....................             delay_ms(10);
01218:  MOVLW  0A
0121A:  MOVLB  6
0121C:  MOVWF  x3E
0121E:  MOVLB  0
01220:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01224:  MOVLB  F
01226:  BSF    x5B.0
01228:  NOP   
....................             state = 1;
0122A:  MOVLW  01
0122C:  MOVLB  1
0122E:  MOVWF  xAF
....................          break;
01230:  BRA    16A8
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01232:  MOVLB  F
01234:  BTFSC  x5B.0
01236:  BRA    1234
01238:  MOVFF  F5F,02
0123C:  MOVFF  F5E,01
01240:  MOVFF  02,639
01244:  MOVFF  01,638
01248:  MOVFF  02,688
0124C:  MOVFF  01,687
01250:  MOVLB  0
01252:  RCALL  0DB6
01254:  MOVFF  03,68B
01258:  MOVFF  02,68A
0125C:  MOVFF  01,689
01260:  MOVFF  00,688
01264:  MOVFF  C1,68F
01268:  MOVFF  C0,68E
0126C:  MOVFF  BF,68D
01270:  MOVFF  BE,68C
01274:  RCALL  0DEC
01276:  MOVFF  03,63B
0127A:  MOVFF  02,63A
0127E:  MOVFF  01,639
01282:  MOVFF  00,638
01286:  BCF    FD8.1
01288:  MOVFF  03,68A
0128C:  MOVFF  02,689
01290:  MOVFF  01,688
01294:  MOVFF  00,687
01298:  MOVFF  BD,68E
0129C:  MOVFF  BC,68D
012A0:  MOVFF  BB,68C
012A4:  MOVFF  BA,68B
012A8:  RCALL  0EE2
012AA:  MOVFF  03,FA
012AE:  MOVFF  02,F9
012B2:  MOVFF  01,F8
012B6:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
012BA:  MOVLB  F
012BC:  MOVF   x5A,W
012BE:  ANDLW  3F
012C0:  MOVWF  01
012C2:  MOVLW  18
012C4:  MOVWF  x5A
012C6:  BTFSS  x5B.7
012C8:  BRA    12D8
012CA:  MOVF   01,W
012CC:  SUBLW  18
012CE:  BZ    12D8
012D0:  BSF    x5B.0
012D2:  NOP   
012D4:  BTFSC  x5B.0
012D6:  BRA    12D4
....................             delay_ms(10);
012D8:  MOVLW  0A
012DA:  MOVLB  6
012DC:  MOVWF  x3E
012DE:  MOVLB  0
012E0:  CALL   0438
....................             read_adc(ADC_START_ONLY);
012E4:  MOVLB  F
012E6:  BSF    x5B.0
012E8:  NOP   
....................             state = 2;
012EA:  MOVLW  02
012EC:  MOVLB  1
012EE:  MOVWF  xAF
....................          break;
012F0:  BRA    16A8
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
012F2:  MOVLB  F
012F4:  BTFSC  x5B.0
012F6:  BRA    12F4
012F8:  MOVFF  F5F,02
012FC:  MOVFF  F5E,01
01300:  MOVFF  02,639
01304:  MOVFF  01,638
01308:  MOVFF  02,688
0130C:  MOVFF  01,687
01310:  MOVLB  0
01312:  RCALL  0DB6
01314:  MOVFF  03,68B
01318:  MOVFF  02,68A
0131C:  MOVFF  01,689
01320:  MOVFF  00,688
01324:  MOVFF  C9,68F
01328:  MOVFF  C8,68E
0132C:  MOVFF  C7,68D
01330:  MOVFF  C6,68C
01334:  RCALL  0DEC
01336:  MOVFF  03,63B
0133A:  MOVFF  02,63A
0133E:  MOVFF  01,639
01342:  MOVFF  00,638
01346:  BCF    FD8.1
01348:  MOVFF  03,68A
0134C:  MOVFF  02,689
01350:  MOVFF  01,688
01354:  MOVFF  00,687
01358:  MOVFF  C5,68E
0135C:  MOVFF  C4,68D
01360:  MOVFF  C3,68C
01364:  MOVFF  C2,68B
01368:  RCALL  0EE2
0136A:  MOVFF  03,FE
0136E:  MOVFF  02,FD
01372:  MOVFF  01,FC
01376:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
0137A:  MOVLB  F
0137C:  MOVF   x5A,W
0137E:  ANDLW  3F
01380:  MOVWF  01
01382:  MOVLW  19
01384:  MOVWF  x5A
01386:  BTFSS  x5B.7
01388:  BRA    1398
0138A:  MOVF   01,W
0138C:  SUBLW  19
0138E:  BZ    1398
01390:  BSF    x5B.0
01392:  NOP   
01394:  BTFSC  x5B.0
01396:  BRA    1394
....................             delay_ms(10);
01398:  MOVLW  0A
0139A:  MOVLB  6
0139C:  MOVWF  x3E
0139E:  MOVLB  0
013A0:  CALL   0438
....................             read_adc(ADC_START_ONLY);
013A4:  MOVLB  F
013A6:  BSF    x5B.0
013A8:  NOP   
....................             state = 3;
013AA:  MOVLW  03
013AC:  MOVLB  1
013AE:  MOVWF  xAF
....................          break;
013B0:  BRA    16A8
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
013B2:  MOVLB  F
013B4:  BTFSC  x5B.0
013B6:  BRA    13B4
013B8:  MOVFF  F5F,02
013BC:  MOVFF  F5E,01
013C0:  MOVFF  02,639
013C4:  MOVFF  01,638
013C8:  MOVFF  02,688
013CC:  MOVFF  01,687
013D0:  MOVLB  0
013D2:  RCALL  0DB6
013D4:  MOVFF  03,68B
013D8:  MOVFF  02,68A
013DC:  MOVFF  01,689
013E0:  MOVFF  00,688
013E4:  MOVFF  D1,68F
013E8:  MOVFF  D0,68E
013EC:  MOVFF  CF,68D
013F0:  MOVFF  CE,68C
013F4:  RCALL  0DEC
013F6:  MOVFF  03,63B
013FA:  MOVFF  02,63A
013FE:  MOVFF  01,639
01402:  MOVFF  00,638
01406:  BCF    FD8.1
01408:  MOVFF  03,68A
0140C:  MOVFF  02,689
01410:  MOVFF  01,688
01414:  MOVFF  00,687
01418:  MOVFF  CD,68E
0141C:  MOVFF  CC,68D
01420:  MOVFF  CB,68C
01424:  MOVFF  CA,68B
01428:  RCALL  0EE2
0142A:  MOVFF  03,102
0142E:  MOVFF  02,101
01432:  MOVFF  01,100
01436:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
0143A:  MOVLB  F
0143C:  MOVF   x5A,W
0143E:  ANDLW  3F
01440:  MOVWF  01
01442:  MOVLW  11
01444:  MOVWF  x5A
01446:  BTFSS  x5B.7
01448:  BRA    1458
0144A:  MOVF   01,W
0144C:  SUBLW  11
0144E:  BZ    1458
01450:  BSF    x5B.0
01452:  NOP   
01454:  BTFSC  x5B.0
01456:  BRA    1454
....................             delay_ms(10);
01458:  MOVLW  0A
0145A:  MOVLB  6
0145C:  MOVWF  x3E
0145E:  MOVLB  0
01460:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01464:  MOVLB  F
01466:  BSF    x5B.0
01468:  NOP   
....................             state = 4;
0146A:  MOVLW  04
0146C:  MOVLB  1
0146E:  MOVWF  xAF
....................          break;
01470:  BRA    16A8
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01472:  MOVLB  F
01474:  BTFSC  x5B.0
01476:  BRA    1474
01478:  MOVFF  F5F,02
0147C:  MOVFF  F5E,01
01480:  MOVFF  02,639
01484:  MOVFF  01,638
01488:  MOVFF  02,688
0148C:  MOVFF  01,687
01490:  MOVLB  0
01492:  RCALL  0DB6
01494:  MOVFF  03,68B
01498:  MOVFF  02,68A
0149C:  MOVFF  01,689
014A0:  MOVFF  00,688
014A4:  MOVFF  D9,68F
014A8:  MOVFF  D8,68E
014AC:  MOVFF  D7,68D
014B0:  MOVFF  D6,68C
014B4:  RCALL  0DEC
014B6:  MOVFF  03,63B
014BA:  MOVFF  02,63A
014BE:  MOVFF  01,639
014C2:  MOVFF  00,638
014C6:  BCF    FD8.1
014C8:  MOVFF  03,68A
014CC:  MOVFF  02,689
014D0:  MOVFF  01,688
014D4:  MOVFF  00,687
014D8:  MOVFF  D5,68E
014DC:  MOVFF  D4,68D
014E0:  MOVFF  D3,68C
014E4:  MOVFF  D2,68B
014E8:  RCALL  0EE2
014EA:  MOVFF  03,106
014EE:  MOVFF  02,105
014F2:  MOVFF  01,104
014F6:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
014FA:  MOVLB  F
014FC:  MOVF   x5A,W
014FE:  ANDLW  3F
01500:  MOVWF  01
01502:  MOVLW  1B
01504:  MOVWF  x5A
01506:  BTFSS  x5B.7
01508:  BRA    1518
0150A:  MOVF   01,W
0150C:  SUBLW  1B
0150E:  BZ    1518
01510:  BSF    x5B.0
01512:  NOP   
01514:  BTFSC  x5B.0
01516:  BRA    1514
....................             delay_ms(10);
01518:  MOVLW  0A
0151A:  MOVLB  6
0151C:  MOVWF  x3E
0151E:  MOVLB  0
01520:  CALL   0438
....................             read_adc(ADC_START_ONLY);
01524:  MOVLB  F
01526:  BSF    x5B.0
01528:  NOP   
....................             state = 5;
0152A:  MOVLW  05
0152C:  MOVLB  1
0152E:  MOVWF  xAF
....................          break;
01530:  BRA    16A8
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01532:  MOVLB  F
01534:  BTFSC  x5B.0
01536:  BRA    1534
01538:  MOVFF  F5F,02
0153C:  MOVFF  F5E,01
01540:  MOVFF  02,639
01544:  MOVFF  01,638
01548:  MOVFF  02,688
0154C:  MOVFF  01,687
01550:  MOVLB  0
01552:  RCALL  0DB6
01554:  MOVFF  03,68B
01558:  MOVFF  02,68A
0155C:  MOVFF  01,689
01560:  MOVFF  00,688
01564:  MOVFF  E1,68F
01568:  MOVFF  E0,68E
0156C:  MOVFF  DF,68D
01570:  MOVFF  DE,68C
01574:  RCALL  0DEC
01576:  MOVFF  03,63B
0157A:  MOVFF  02,63A
0157E:  MOVFF  01,639
01582:  MOVFF  00,638
01586:  BCF    FD8.1
01588:  MOVFF  03,68A
0158C:  MOVFF  02,689
01590:  MOVFF  01,688
01594:  MOVFF  00,687
01598:  MOVFF  DD,68E
0159C:  MOVFF  DC,68D
015A0:  MOVFF  DB,68C
015A4:  MOVFF  DA,68B
015A8:  RCALL  0EE2
015AA:  MOVFF  03,10A
015AE:  MOVFF  02,109
015B2:  MOVFF  01,108
015B6:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
015BA:  MOVLB  F
015BC:  MOVF   x5A,W
015BE:  ANDLW  3F
015C0:  MOVWF  01
015C2:  MOVLW  1A
015C4:  MOVWF  x5A
015C6:  BTFSS  x5B.7
015C8:  BRA    15D8
015CA:  MOVF   01,W
015CC:  SUBLW  1A
015CE:  BZ    15D8
015D0:  BSF    x5B.0
015D2:  NOP   
015D4:  BTFSC  x5B.0
015D6:  BRA    15D4
....................             delay_ms(10);
015D8:  MOVLW  0A
015DA:  MOVLB  6
015DC:  MOVWF  x3E
015DE:  MOVLB  0
015E0:  CALL   0438
....................             read_adc(ADC_START_ONLY);
015E4:  MOVLB  F
015E6:  BSF    x5B.0
015E8:  NOP   
....................             state = 6;
015EA:  MOVLW  06
015EC:  MOVLB  1
015EE:  MOVWF  xAF
....................          break;
015F0:  BRA    16A8
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
015F2:  MOVLB  F
015F4:  BTFSC  x5B.0
015F6:  BRA    15F4
015F8:  MOVFF  F5F,02
015FC:  MOVFF  F5E,01
01600:  MOVFF  02,639
01604:  MOVFF  01,638
01608:  MOVFF  02,688
0160C:  MOVFF  01,687
01610:  MOVLB  0
01612:  CALL   0DB6
01616:  MOVFF  03,68B
0161A:  MOVFF  02,68A
0161E:  MOVFF  01,689
01622:  MOVFF  00,688
01626:  MOVFF  E9,68F
0162A:  MOVFF  E8,68E
0162E:  MOVFF  E7,68D
01632:  MOVFF  E6,68C
01636:  CALL   0DEC
0163A:  MOVFF  03,63B
0163E:  MOVFF  02,63A
01642:  MOVFF  01,639
01646:  MOVFF  00,638
0164A:  BCF    FD8.1
0164C:  MOVFF  03,68A
01650:  MOVFF  02,689
01654:  MOVFF  01,688
01658:  MOVFF  00,687
0165C:  MOVFF  E5,68E
01660:  MOVFF  E4,68D
01664:  MOVFF  E3,68C
01668:  MOVFF  E2,68B
0166C:  RCALL  0EE2
0166E:  MOVFF  03,10E
01672:  MOVFF  02,10D
01676:  MOVFF  01,10C
0167A:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
0167E:  MOVLB  F
01680:  MOVF   x5A,W
01682:  ANDLW  3F
01684:  MOVWF  01
01686:  MOVLW  06
01688:  MOVWF  x5A
0168A:  BTFSS  x5B.7
0168C:  BRA    169C
0168E:  MOVF   01,W
01690:  SUBLW  06
01692:  BZ    169C
01694:  BSF    x5B.0
01696:  NOP   
01698:  BTFSC  x5B.0
0169A:  BRA    1698
....................             read_adc(ADC_START_ONLY);
0169C:  BSF    x5B.0
0169E:  NOP   
....................             state = 0;
016A0:  MOVLB  1
016A2:  CLRF   xAF
....................          break;   
016A4:  BRA    16A8
016A6:  MOVLB  1
016A8:  MOVLB  F
....................       }
....................    }
016AA:  MOVLB  0
016AC:  GOTO   A842 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch)//, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
0397A:  MOVLB  6
0397C:  MOVF   x40,W
0397E:  MULLW  21
03980:  MOVF   FF3,W
03982:  CLRF   x4A
03984:  MOVWF  x49
03986:  MOVLW  10
03988:  ADDWF  x49,W
0398A:  MOVWF  01
0398C:  MOVLW  00
0398E:  ADDWFC x4A,W
03990:  MOVWF  03
03992:  MOVF   01,W
03994:  ADDLW  0F
03996:  MOVWF  01
03998:  MOVLW  01
0399A:  ADDWFC 03,F
0399C:  MOVFF  01,649
039A0:  MOVFF  03,64A
039A4:  MOVF   x40,W
039A6:  MULLW  21
039A8:  MOVF   FF3,W
039AA:  CLRF   x4C
039AC:  MOVWF  x4B
039AE:  MOVLW  08
039B0:  ADDWF  x4B,W
039B2:  MOVWF  01
039B4:  MOVLW  00
039B6:  ADDWFC x4C,W
039B8:  MOVWF  03
039BA:  MOVF   01,W
039BC:  ADDLW  0F
039BE:  MOVWF  FE9
039C0:  MOVLW  01
039C2:  ADDWFC 03,W
039C4:  MOVWF  FEA
039C6:  MOVFF  FEF,00
039CA:  MOVFF  FEC,01
039CE:  MOVFF  FEC,02
039D2:  MOVFF  FEC,03
039D6:  MOVFF  64A,FEA
039DA:  MOVFF  649,FE9
039DE:  MOVFF  00,FEF
039E2:  MOVFF  01,FEC
039E6:  MOVFF  02,FEC
039EA:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
039EE:  MOVF   x40,W
039F0:  MULLW  21
039F2:  MOVF   FF3,W
039F4:  CLRF   x4A
039F6:  MOVWF  x49
039F8:  MOVLW  14
039FA:  ADDWF  x49,W
039FC:  MOVWF  01
039FE:  MOVLW  00
03A00:  ADDWFC x4A,W
03A02:  MOVWF  03
03A04:  MOVF   01,W
03A06:  ADDLW  0F
03A08:  MOVWF  01
03A0A:  MOVLW  01
03A0C:  ADDWFC 03,F
03A0E:  MOVFF  01,649
03A12:  MOVFF  03,64A
03A16:  MOVF   x40,W
03A18:  MULLW  21
03A1A:  MOVF   FF3,W
03A1C:  CLRF   x4C
03A1E:  MOVWF  x4B
03A20:  MOVLW  0C
03A22:  ADDWF  x4B,W
03A24:  MOVWF  01
03A26:  MOVLW  00
03A28:  ADDWFC x4C,W
03A2A:  MOVWF  03
03A2C:  MOVF   01,W
03A2E:  ADDLW  0F
03A30:  MOVWF  FE9
03A32:  MOVLW  01
03A34:  ADDWFC 03,W
03A36:  MOVWF  FEA
03A38:  MOVFF  FEF,00
03A3C:  MOVFF  FEC,01
03A40:  MOVFF  FEC,02
03A44:  MOVFF  FEC,03
03A48:  MOVFF  64A,FEA
03A4C:  MOVFF  649,FE9
03A50:  MOVFF  00,FEF
03A54:  MOVFF  01,FEC
03A58:  MOVFF  02,FEC
03A5C:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
03A60:  MOVF   x40,W
03A62:  MULLW  21
03A64:  MOVF   FF3,W
03A66:  CLRF   x4A
03A68:  MOVWF  x49
03A6A:  MOVLW  0F
03A6C:  ADDWF  x49,W
03A6E:  MOVWF  01
03A70:  MOVLW  01
03A72:  ADDWFC x4A,W
03A74:  MOVWF  03
03A76:  MOVFF  01,64B
03A7A:  MOVWF  x4C
03A7C:  MOVF   x40,W
03A7E:  MULLW  0D
03A80:  MOVF   FF3,W
03A82:  CLRF   x4E
03A84:  MOVWF  x4D
03A86:  MOVLW  05
03A88:  ADDWF  x4D,W
03A8A:  MOVWF  01
03A8C:  MOVLW  00
03A8E:  ADDWFC x4E,W
03A90:  MOVWF  03
03A92:  MOVF   01,W
03A94:  ADDLW  95
03A96:  MOVWF  FE9
03A98:  MOVLW  01
03A9A:  ADDWFC 03,W
03A9C:  MOVWF  FEA
03A9E:  MOVFF  FEF,64D
03AA2:  MOVFF  FEC,01
03AA6:  MOVFF  FEC,02
03AAA:  MOVFF  FEC,03
03AAE:  MOVFF  03,650
03AB2:  MOVFF  02,64F
03AB6:  MOVFF  01,64E
03ABA:  MOVLB  0
03ABC:  CALL   1F40
03AC0:  MOVFF  64C,FEA
03AC4:  MOVFF  64B,FE9
03AC8:  MOVFF  00,FEF
03ACC:  MOVFF  01,FEC
03AD0:  MOVFF  02,FEC
03AD4:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03AD8:  MOVLB  6
03ADA:  MOVF   x40,W
03ADC:  MULLW  21
03ADE:  MOVF   FF3,W
03AE0:  CLRF   x4A
03AE2:  MOVWF  x49
03AE4:  MOVLW  04
03AE6:  ADDWF  x49,W
03AE8:  MOVWF  01
03AEA:  MOVLW  00
03AEC:  ADDWFC x4A,W
03AEE:  MOVWF  03
03AF0:  MOVF   01,W
03AF2:  ADDLW  0F
03AF4:  MOVWF  01
03AF6:  MOVLW  01
03AF8:  ADDWFC 03,F
03AFA:  MOVFF  01,649
03AFE:  MOVFF  03,64A
03B02:  MOVF   x40,W
03B04:  MULLW  0D
03B06:  MOVF   FF3,W
03B08:  CLRF   x4C
03B0A:  MOVWF  x4B
03B0C:  MOVLW  09
03B0E:  ADDWF  x4B,W
03B10:  MOVWF  01
03B12:  MOVLW  00
03B14:  ADDWFC x4C,W
03B16:  MOVWF  03
03B18:  MOVF   01,W
03B1A:  ADDLW  95
03B1C:  MOVWF  FE9
03B1E:  MOVLW  01
03B20:  ADDWFC 03,W
03B22:  MOVWF  FEA
03B24:  MOVFF  FEF,64D
03B28:  MOVFF  FEC,01
03B2C:  MOVFF  FEC,02
03B30:  MOVFF  FEC,03
03B34:  MOVFF  03,650
03B38:  MOVFF  02,64F
03B3C:  MOVFF  01,64E
03B40:  MOVLB  0
03B42:  CALL   1F40
03B46:  MOVFF  64A,FEA
03B4A:  MOVFF  649,FE9
03B4E:  MOVFF  00,FEF
03B52:  MOVFF  01,FEC
03B56:  MOVFF  02,FEC
03B5A:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
03B5E:  MOVLB  6
03B60:  MOVF   x40,W
03B62:  MULLW  21
03B64:  MOVF   FF3,W
03B66:  CLRF   x4A
03B68:  MOVWF  x49
03B6A:  MOVLW  08
03B6C:  ADDWF  x49,W
03B6E:  MOVWF  01
03B70:  MOVLW  00
03B72:  ADDWFC x4A,W
03B74:  MOVWF  03
03B76:  MOVF   01,W
03B78:  ADDLW  0F
03B7A:  MOVWF  01
03B7C:  MOVLW  01
03B7E:  ADDWFC 03,F
03B80:  MOVFF  01,649
03B84:  MOVFF  03,64A
03B88:  MOVF   x40,W
03B8A:  MULLW  21
03B8C:  MOVF   FF3,W
03B8E:  CLRF   x4C
03B90:  MOVWF  x4B
03B92:  MOVLW  0F
03B94:  ADDWF  x4B,W
03B96:  MOVWF  FE9
03B98:  MOVLW  01
03B9A:  ADDWFC x4C,W
03B9C:  MOVWF  FEA
03B9E:  MOVFF  FEF,688
03BA2:  MOVFF  FEC,689
03BA6:  MOVFF  FEC,68A
03BAA:  MOVFF  FEC,68B
03BAE:  MOVF   x40,W
03BB0:  MULLW  10
03BB2:  MOVF   FF3,W
03BB4:  CLRF   x52
03BB6:  MOVWF  x51
03BB8:  MOVLW  08
03BBA:  ADDWF  x51,W
03BBC:  MOVWF  01
03BBE:  MOVLW  00
03BC0:  ADDWFC x52,W
03BC2:  MOVWF  03
03BC4:  MOVF   01,W
03BC6:  ADDLW  62
03BC8:  MOVWF  FE9
03BCA:  MOVLW  00
03BCC:  ADDWFC 03,W
03BCE:  MOVWF  FEA
03BD0:  MOVFF  FEF,68C
03BD4:  MOVFF  FEC,01
03BD8:  MOVFF  FEC,02
03BDC:  MOVFF  FEC,03
03BE0:  MOVFF  03,68F
03BE4:  MOVFF  02,68E
03BE8:  MOVFF  01,68D
03BEC:  MOVLB  0
03BEE:  CALL   0DEC
03BF2:  MOVFF  03,68A
03BF6:  MOVFF  02,689
03BFA:  MOVFF  01,688
03BFE:  MOVFF  00,687
03C02:  MOVLB  6
03C04:  MOVF   x40,W
03C06:  MULLW  10
03C08:  MOVF   FF3,W
03C0A:  CLRF   x52
03C0C:  MOVWF  x51
03C0E:  MOVLW  62
03C10:  ADDWF  x51,W
03C12:  MOVWF  FE9
03C14:  MOVLW  00
03C16:  ADDWFC x52,W
03C18:  MOVWF  FEA
03C1A:  MOVFF  FEF,68B
03C1E:  MOVFF  FEC,01
03C22:  MOVFF  FEC,02
03C26:  MOVFF  FEC,03
03C2A:  BCF    FD8.1
03C2C:  MOVFF  03,68E
03C30:  MOVFF  02,68D
03C34:  MOVFF  01,68C
03C38:  MOVLB  0
03C3A:  CALL   0EE2
03C3E:  MOVFF  64A,FEA
03C42:  MOVFF  649,FE9
03C46:  MOVFF  00,FEF
03C4A:  MOVFF  01,FEC
03C4E:  MOVFF  02,FEC
03C52:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
03C56:  MOVLB  6
03C58:  MOVF   x40,W
03C5A:  MULLW  21
03C5C:  MOVF   FF3,W
03C5E:  CLRF   x4A
03C60:  MOVWF  x49
03C62:  MOVLW  0C
03C64:  ADDWF  x49,W
03C66:  MOVWF  01
03C68:  MOVLW  00
03C6A:  ADDWFC x4A,W
03C6C:  MOVWF  03
03C6E:  MOVF   01,W
03C70:  ADDLW  0F
03C72:  MOVWF  01
03C74:  MOVLW  01
03C76:  ADDWFC 03,F
03C78:  MOVFF  01,649
03C7C:  MOVFF  03,64A
03C80:  MOVF   x40,W
03C82:  MULLW  21
03C84:  MOVF   FF3,W
03C86:  CLRF   x4C
03C88:  MOVWF  x4B
03C8A:  MOVLW  04
03C8C:  ADDWF  x4B,W
03C8E:  MOVWF  01
03C90:  MOVLW  00
03C92:  ADDWFC x4C,W
03C94:  MOVWF  03
03C96:  MOVF   01,W
03C98:  ADDLW  0F
03C9A:  MOVWF  FE9
03C9C:  MOVLW  01
03C9E:  ADDWFC 03,W
03CA0:  MOVWF  FEA
03CA2:  MOVFF  FEF,688
03CA6:  MOVFF  FEC,689
03CAA:  MOVFF  FEC,68A
03CAE:  MOVFF  FEC,68B
03CB2:  MOVF   x40,W
03CB4:  MULLW  10
03CB6:  MOVF   FF3,W
03CB8:  CLRF   x50
03CBA:  MOVWF  x4F
03CBC:  MOVLW  0C
03CBE:  ADDWF  x4F,W
03CC0:  MOVWF  01
03CC2:  MOVLW  00
03CC4:  ADDWFC x50,W
03CC6:  MOVWF  03
03CC8:  MOVF   01,W
03CCA:  ADDLW  62
03CCC:  MOVWF  FE9
03CCE:  MOVLW  00
03CD0:  ADDWFC 03,W
03CD2:  MOVWF  FEA
03CD4:  MOVFF  FEF,68C
03CD8:  MOVFF  FEC,01
03CDC:  MOVFF  FEC,02
03CE0:  MOVFF  FEC,03
03CE4:  MOVFF  03,68F
03CE8:  MOVFF  02,68E
03CEC:  MOVFF  01,68D
03CF0:  MOVLB  0
03CF2:  CALL   0DEC
03CF6:  MOVFF  03,68A
03CFA:  MOVFF  02,689
03CFE:  MOVFF  01,688
03D02:  MOVFF  00,687
03D06:  MOVLB  6
03D08:  MOVF   x40,W
03D0A:  MULLW  10
03D0C:  MOVF   FF3,W
03D0E:  CLRF   x50
03D10:  MOVWF  x4F
03D12:  MOVLW  04
03D14:  ADDWF  x4F,W
03D16:  MOVWF  01
03D18:  MOVLW  00
03D1A:  ADDWFC x50,W
03D1C:  MOVWF  03
03D1E:  MOVF   01,W
03D20:  ADDLW  62
03D22:  MOVWF  FE9
03D24:  MOVLW  00
03D26:  ADDWFC 03,W
03D28:  MOVWF  FEA
03D2A:  MOVFF  FEF,68B
03D2E:  MOVFF  FEC,01
03D32:  MOVFF  FEC,02
03D36:  MOVFF  FEC,03
03D3A:  BCF    FD8.1
03D3C:  MOVFF  03,68E
03D40:  MOVFF  02,68D
03D44:  MOVFF  01,68C
03D48:  MOVLB  0
03D4A:  CALL   0EE2
03D4E:  MOVFF  64A,FEA
03D52:  MOVFF  649,FE9
03D56:  MOVFF  00,FEF
03D5A:  MOVFF  01,FEC
03D5E:  MOVFF  02,FEC
03D62:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03D66:  MOVLB  6
03D68:  CLRF   x44
03D6A:  CLRF   x43
03D6C:  CLRF   x42
03D6E:  CLRF   x41
03D70:  CLRF   x48
03D72:  CLRF   x47
03D74:  CLRF   x46
03D76:  MOVLW  7F
03D78:  MOVWF  x45
....................    
....................    if (adcVals[ch].cosCounts < 0){
03D7A:  MOVF   x40,W
03D7C:  MULLW  21
03D7E:  MOVF   FF3,W
03D80:  CLRF   x4A
03D82:  MOVWF  x49
03D84:  MOVLW  0C
03D86:  ADDWF  x49,W
03D88:  MOVWF  01
03D8A:  MOVLW  00
03D8C:  ADDWFC x4A,W
03D8E:  MOVWF  03
03D90:  MOVF   01,W
03D92:  ADDLW  0F
03D94:  MOVWF  FE9
03D96:  MOVLW  01
03D98:  ADDWFC 03,W
03D9A:  MOVWF  FEA
03D9C:  MOVFF  FEF,683
03DA0:  MOVFF  FEC,684
03DA4:  MOVFF  FEC,685
03DA8:  MOVFF  FEC,686
03DAC:  CLRF   x8A
03DAE:  CLRF   x89
03DB0:  CLRF   x88
03DB2:  CLRF   x87
03DB4:  MOVLB  0
03DB6:  CALL   1F9A
03DBA:  BTFSS  FD8.0
03DBC:  BRA    3F26
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03DBE:  MOVLB  6
03DC0:  MOVF   x40,W
03DC2:  MULLW  21
03DC4:  MOVF   FF3,W
03DC6:  CLRF   x4A
03DC8:  MOVWF  x49
03DCA:  MOVLW  08
03DCC:  ADDWF  x49,W
03DCE:  MOVWF  01
03DD0:  MOVLW  00
03DD2:  ADDWFC x4A,W
03DD4:  MOVWF  03
03DD6:  MOVF   01,W
03DD8:  ADDLW  0F
03DDA:  MOVWF  FE9
03DDC:  MOVLW  01
03DDE:  ADDWFC 03,W
03DE0:  MOVWF  FEA
03DE2:  MOVFF  FEF,687
03DE6:  MOVFF  FEC,64A
03DEA:  MOVFF  FEC,689
03DEE:  MOVFF  FEC,68A
03DF2:  CLRF   x86
03DF4:  CLRF   x85
03DF6:  CLRF   x84
03DF8:  CLRF   x83
03DFA:  MOVFF  64A,688
03DFE:  MOVLB  0
03E00:  CALL   1F9A
03E04:  BNC   3E72
03E06:  MOVLB  6
03E08:  MOVF   x40,W
03E0A:  MULLW  21
03E0C:  MOVF   FF3,W
03E0E:  CLRF   x4A
03E10:  MOVWF  x49
03E12:  MOVLW  10
03E14:  ADDWF  x49,W
03E16:  MOVWF  01
03E18:  MOVLW  00
03E1A:  ADDWFC x4A,W
03E1C:  MOVWF  03
03E1E:  MOVF   01,W
03E20:  ADDLW  0F
03E22:  MOVWF  FE9
03E24:  MOVLW  01
03E26:  ADDWFC 03,W
03E28:  MOVWF  FEA
03E2A:  MOVFF  FEF,683
03E2E:  MOVFF  FEC,684
03E32:  MOVFF  FEC,685
03E36:  MOVFF  FEC,686
03E3A:  CLRF   x8A
03E3C:  CLRF   x89
03E3E:  CLRF   x88
03E40:  CLRF   x87
03E42:  MOVLB  0
03E44:  CALL   1F9A
03E48:  BNC   3E72
....................          adcVals[ch].npoles--;
03E4A:  MOVLB  6
03E4C:  MOVF   x40,W
03E4E:  MULLW  21
03E50:  MOVF   FF3,W
03E52:  CLRF   x4A
03E54:  MOVWF  x49
03E56:  MOVLW  1C
03E58:  ADDWF  x49,W
03E5A:  MOVWF  01
03E5C:  MOVLW  00
03E5E:  ADDWFC x4A,W
03E60:  MOVWF  03
03E62:  MOVF   01,W
03E64:  ADDLW  0F
03E66:  MOVWF  FE9
03E68:  MOVLW  01
03E6A:  ADDWFC 03,W
03E6C:  MOVWF  FEA
03E6E:  DECF   FEF,F
....................       }
03E70:  BRA    3F24
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03E72:  MOVLB  6
03E74:  MOVF   x40,W
03E76:  MULLW  21
03E78:  MOVF   FF3,W
03E7A:  CLRF   x4A
03E7C:  MOVWF  x49
03E7E:  MOVLW  08
03E80:  ADDWF  x49,W
03E82:  MOVWF  01
03E84:  MOVLW  00
03E86:  ADDWFC x4A,W
03E88:  MOVWF  03
03E8A:  MOVF   01,W
03E8C:  ADDLW  0F
03E8E:  MOVWF  FE9
03E90:  MOVLW  01
03E92:  ADDWFC 03,W
03E94:  MOVWF  FEA
03E96:  MOVFF  FEF,683
03E9A:  MOVFF  FEC,64A
03E9E:  MOVFF  FEC,685
03EA2:  MOVFF  FEC,686
03EA6:  MOVFF  64A,684
03EAA:  CLRF   x8A
03EAC:  CLRF   x89
03EAE:  CLRF   x88
03EB0:  CLRF   x87
03EB2:  MOVLB  0
03EB4:  CALL   1F9A
03EB8:  BNC   3F26
03EBA:  MOVLB  6
03EBC:  MOVF   x40,W
03EBE:  MULLW  21
03EC0:  MOVF   FF3,W
03EC2:  CLRF   x4A
03EC4:  MOVWF  x49
03EC6:  MOVLW  10
03EC8:  ADDWF  x49,W
03ECA:  MOVWF  01
03ECC:  MOVLW  00
03ECE:  ADDWFC x4A,W
03ED0:  MOVWF  03
03ED2:  MOVF   01,W
03ED4:  ADDLW  0F
03ED6:  MOVWF  FE9
03ED8:  MOVLW  01
03EDA:  ADDWFC 03,W
03EDC:  MOVWF  FEA
03EDE:  MOVFF  FEF,687
03EE2:  MOVFF  FEC,688
03EE6:  MOVFF  FEC,689
03EEA:  MOVFF  FEC,68A
03EEE:  CLRF   x86
03EF0:  CLRF   x85
03EF2:  CLRF   x84
03EF4:  CLRF   x83
03EF6:  MOVLB  0
03EF8:  CALL   1F9A
03EFC:  BNC   3F26
....................          adcVals[ch].npoles++;
03EFE:  MOVLB  6
03F00:  MOVF   x40,W
03F02:  MULLW  21
03F04:  MOVF   FF3,W
03F06:  CLRF   x4A
03F08:  MOVWF  x49
03F0A:  MOVLW  1C
03F0C:  ADDWF  x49,W
03F0E:  MOVWF  01
03F10:  MOVLW  00
03F12:  ADDWFC x4A,W
03F14:  MOVWF  03
03F16:  MOVF   01,W
03F18:  ADDLW  0F
03F1A:  MOVWF  FE9
03F1C:  MOVLW  01
03F1E:  ADDWFC 03,W
03F20:  MOVWF  FEA
03F22:  INCF   FEF,F
03F24:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03F26:  MOVLB  6
03F28:  MOVF   x40,W
03F2A:  MULLW  21
03F2C:  MOVF   FF3,W
03F2E:  CLRF   x4A
03F30:  MOVWF  x49
03F32:  MOVLW  18
03F34:  ADDWF  x49,W
03F36:  MOVWF  01
03F38:  MOVLW  00
03F3A:  ADDWFC x4A,W
03F3C:  MOVWF  03
03F3E:  MOVF   01,W
03F40:  ADDLW  0F
03F42:  MOVWF  01
03F44:  MOVLW  01
03F46:  ADDWFC 03,F
03F48:  MOVFF  01,649
03F4C:  MOVFF  03,64A
03F50:  MOVFF  648,68B
03F54:  MOVFF  647,68A
03F58:  MOVFF  646,689
03F5C:  MOVFF  645,688
03F60:  MOVLW  AA
03F62:  MOVWF  x8F
03F64:  MOVLW  27
03F66:  MOVWF  x8E
03F68:  MOVLW  1F
03F6A:  MOVWF  x8D
03F6C:  MOVLW  86
03F6E:  MOVWF  x8C
03F70:  MOVLB  0
03F72:  CALL   0DEC
03F76:  MOVFF  03,64E
03F7A:  MOVFF  02,64D
03F7E:  MOVFF  01,64C
03F82:  MOVFF  00,64B
03F86:  MOVLB  6
03F88:  MOVF   x40,W
03F8A:  MULLW  21
03F8C:  MOVF   FF3,W
03F8E:  CLRF   x50
03F90:  MOVWF  x4F
03F92:  MOVLW  08
03F94:  ADDWF  x4F,W
03F96:  MOVWF  01
03F98:  MOVLW  00
03F9A:  ADDWFC x50,W
03F9C:  MOVWF  03
03F9E:  MOVF   01,W
03FA0:  ADDLW  0F
03FA2:  MOVWF  FE9
03FA4:  MOVLW  01
03FA6:  ADDWFC 03,W
03FA8:  MOVWF  FEA
03FAA:  MOVFF  FEF,64F
03FAE:  MOVFF  FEC,650
03FB2:  MOVFF  FEC,651
03FB6:  MOVFF  FEC,652
03FBA:  MOVF   x40,W
03FBC:  MULLW  21
03FBE:  MOVF   FF3,W
03FC0:  CLRF   x54
03FC2:  MOVWF  x53
03FC4:  MOVLW  0C
03FC6:  ADDWF  x53,W
03FC8:  MOVWF  01
03FCA:  MOVLW  00
03FCC:  ADDWFC x54,W
03FCE:  MOVWF  03
03FD0:  MOVF   01,W
03FD2:  ADDLW  0F
03FD4:  MOVWF  FE9
03FD6:  MOVLW  01
03FD8:  ADDWFC 03,W
03FDA:  MOVWF  FEA
03FDC:  MOVFF  FEF,00
03FE0:  MOVFF  FEC,01
03FE4:  MOVFF  FEC,02
03FE8:  MOVFF  FEC,03
03FEC:  MOVFF  03,656
03FF0:  MOVFF  02,655
03FF4:  MOVFF  01,654
03FF8:  MOVFF  00,653
03FFC:  MOVFF  652,65A
04000:  MOVFF  651,659
04004:  MOVFF  650,658
04008:  MOVFF  64F,657
0400C:  MOVFF  03,65E
04010:  MOVFF  02,65D
04014:  MOVFF  01,65C
04018:  MOVFF  00,65B
0401C:  MOVLB  0
0401E:  GOTO   269C
04022:  MOVFF  64E,68B
04026:  MOVFF  64D,68A
0402A:  MOVFF  64C,689
0402E:  MOVFF  64B,688
04032:  MOVFF  03,68F
04036:  MOVFF  02,68E
0403A:  MOVFF  01,68D
0403E:  MOVFF  00,68C
04042:  CALL   0DEC
04046:  MOVFF  64A,FEA
0404A:  MOVFF  649,FE9
0404E:  MOVFF  00,FEF
04052:  MOVFF  01,FEC
04056:  MOVFF  02,FEC
0405A:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
0405E:  MOVLB  6
04060:  MOVF   x40,W
04062:  MULLW  21
04064:  MOVF   FF3,W
04066:  CLRF   x4A
04068:  MOVWF  x49
0406A:  MOVLW  18
0406C:  ADDWF  x49,W
0406E:  MOVWF  01
04070:  MOVLW  00
04072:  ADDWFC x4A,W
04074:  MOVWF  03
04076:  MOVF   01,W
04078:  ADDLW  0F
0407A:  MOVWF  FE9
0407C:  MOVLW  01
0407E:  ADDWFC 03,W
04080:  MOVWF  FEA
04082:  MOVFF  FEF,649
04086:  MOVFF  FEC,64A
0408A:  MOVFF  FEC,64B
0408E:  MOVFF  FEC,64C
04092:  CLRF   x8B
04094:  CLRF   x8A
04096:  MOVLW  7A
04098:  MOVWF  x89
0409A:  MOVLW  88
0409C:  MOVWF  x88
0409E:  MOVFF  648,68F
040A2:  MOVFF  647,68E
040A6:  MOVFF  646,68D
040AA:  MOVFF  645,68C
040AE:  MOVLB  0
040B0:  CALL   0DEC
040B4:  MOVFF  03,650
040B8:  MOVFF  02,64F
040BC:  MOVFF  01,64E
040C0:  MOVFF  00,64D
040C4:  MOVLB  6
040C6:  MOVF   x40,W
040C8:  MULLW  21
040CA:  MOVF   FF3,W
040CC:  CLRF   x52
040CE:  MOVWF  x51
040D0:  MOVLW  1C
040D2:  ADDWF  x51,W
040D4:  MOVWF  01
040D6:  MOVLW  00
040D8:  ADDWFC x52,W
040DA:  MOVWF  03
040DC:  MOVF   01,W
040DE:  ADDLW  0F
040E0:  MOVWF  FE9
040E2:  MOVLW  01
040E4:  ADDWFC 03,W
040E6:  MOVWF  FEA
040E8:  MOVF   FEF,W
040EA:  CLRF   x7A
040EC:  MOVWF  x79
040EE:  BTFSC  x79.7
040F0:  DECF   x7A,F
040F2:  MOVLB  0
040F4:  CALL   293E
040F8:  MOVFF  650,68B
040FC:  MOVFF  64F,68A
04100:  MOVFF  64E,689
04104:  MOVFF  64D,688
04108:  MOVFF  03,68F
0410C:  MOVFF  02,68E
04110:  MOVFF  01,68D
04114:  MOVFF  00,68C
04118:  CALL   0DEC
0411C:  MOVFF  FEA,64E
04120:  MOVFF  FE9,64D
04124:  BCF    FD8.1
04126:  MOVFF  64C,68A
0412A:  MOVFF  64B,689
0412E:  MOVFF  64A,688
04132:  MOVFF  649,687
04136:  MOVFF  03,68E
0413A:  MOVFF  02,68D
0413E:  MOVFF  01,68C
04142:  MOVFF  00,68B
04146:  CALL   0EE2
0414A:  MOVFF  64E,FEA
0414E:  MOVFF  64D,FE9
04152:  MOVFF  03,644
04156:  MOVFF  02,643
0415A:  MOVFF  01,642
0415E:  MOVFF  00,641
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
04162:  MOVLB  6
04164:  MOVF   x40,W
04166:  MULLW  21
04168:  MOVF   FF3,W
0416A:  CLRF   x4A
0416C:  MOVWF  x49
0416E:  MOVLW  1D
04170:  ADDWF  x49,W
04172:  MOVWF  01
04174:  MOVLW  00
04176:  ADDWFC x4A,W
04178:  MOVWF  03
0417A:  MOVF   01,W
0417C:  ADDLW  0F
0417E:  MOVWF  01
04180:  MOVLW  01
04182:  ADDWFC 03,F
04184:  MOVFF  01,649
04188:  MOVFF  03,64A
0418C:  MOVF   x40,W
0418E:  MULLW  18
04190:  MOVF   FF3,W
04192:  CLRF   x4C
04194:  MOVWF  x4B
04196:  MOVLW  14
04198:  ADDWF  x4B,W
0419A:  MOVWF  01
0419C:  MOVLW  00
0419E:  ADDWFC x4C,W
041A0:  MOVWF  03
041A2:  MOVF   01,W
041A4:  ADDLW  82
041A6:  MOVWF  FE9
041A8:  MOVLW  00
041AA:  ADDWFC 03,W
041AC:  MOVWF  FEA
041AE:  MOVFF  FEF,68C
041B2:  MOVFF  FEC,01
041B6:  MOVFF  FEC,02
041BA:  MOVFF  FEC,03
041BE:  MOVFF  644,68B
041C2:  MOVFF  643,68A
041C6:  MOVFF  642,689
041CA:  MOVFF  641,688
041CE:  MOVFF  03,68F
041D2:  MOVFF  02,68E
041D6:  MOVFF  01,68D
041DA:  MOVLB  0
041DC:  CALL   0DEC
041E0:  MOVFF  03,64E
041E4:  MOVFF  02,64D
041E8:  MOVFF  01,64C
041EC:  MOVFF  00,64B
041F0:  MOVFF  03,65A
041F4:  MOVFF  02,659
041F8:  MOVFF  01,658
041FC:  MOVFF  00,657
04200:  MOVLB  6
04202:  CLRF   x5E
04204:  CLRF   x5D
04206:  MOVLW  20
04208:  MOVWF  x5C
0420A:  MOVLW  81
0420C:  MOVWF  x5B
0420E:  MOVLB  0
04210:  CALL   367C
04214:  MOVFF  03,64E
04218:  MOVFF  02,64D
0421C:  MOVFF  01,64C
04220:  MOVFF  00,64B
04224:  MOVLB  6
04226:  MOVF   x40,W
04228:  MULLW  18
0422A:  MOVF   FF3,W
0422C:  CLRF   x50
0422E:  MOVWF  x4F
04230:  MOVLW  10
04232:  ADDWF  x4F,W
04234:  MOVWF  01
04236:  MOVLW  00
04238:  ADDWFC x50,W
0423A:  MOVWF  03
0423C:  MOVF   01,W
0423E:  ADDLW  82
04240:  MOVWF  FE9
04242:  MOVLW  00
04244:  ADDWFC 03,W
04246:  MOVWF  FEA
04248:  MOVFF  FEF,68C
0424C:  MOVFF  FEC,01
04250:  MOVFF  FEC,02
04254:  MOVFF  FEC,03
04258:  MOVFF  644,68B
0425C:  MOVFF  643,68A
04260:  MOVFF  642,689
04264:  MOVFF  641,688
04268:  MOVFF  03,68F
0426C:  MOVFF  02,68E
04270:  MOVFF  01,68D
04274:  MOVLB  0
04276:  CALL   0DEC
0427A:  MOVFF  03,652
0427E:  MOVFF  02,651
04282:  MOVFF  01,650
04286:  MOVFF  00,64F
0428A:  MOVFF  03,65A
0428E:  MOVFF  02,659
04292:  MOVFF  01,658
04296:  MOVFF  00,657
0429A:  MOVLB  6
0429C:  CLRF   x5E
0429E:  CLRF   x5D
042A0:  CLRF   x5C
042A2:  MOVLW  81
042A4:  MOVWF  x5B
042A6:  MOVLB  0
042A8:  CALL   367C
042AC:  MOVFF  FEA,650
042B0:  MOVFF  FE9,64F
042B4:  BCF    FD8.1
042B6:  MOVFF  64E,68A
042BA:  MOVFF  64D,689
042BE:  MOVFF  64C,688
042C2:  MOVFF  64B,687
042C6:  MOVFF  03,68E
042CA:  MOVFF  02,68D
042CE:  MOVFF  01,68C
042D2:  MOVFF  00,68B
042D6:  CALL   0EE2
042DA:  MOVFF  650,FEA
042DE:  MOVFF  64F,FE9
042E2:  MOVFF  03,64E
042E6:  MOVFF  02,64D
042EA:  MOVFF  01,64C
042EE:  MOVFF  00,64B
042F2:  MOVLB  6
042F4:  MOVF   x40,W
042F6:  MULLW  18
042F8:  MOVF   FF3,W
042FA:  CLRF   x52
042FC:  MOVWF  x51
042FE:  MOVLW  0C
04300:  ADDWF  x51,W
04302:  MOVWF  01
04304:  MOVLW  00
04306:  ADDWFC x52,W
04308:  MOVWF  03
0430A:  MOVF   01,W
0430C:  ADDLW  82
0430E:  MOVWF  FE9
04310:  MOVLW  00
04312:  ADDWFC 03,W
04314:  MOVWF  FEA
04316:  MOVFF  FEF,68C
0431A:  MOVFF  FEC,01
0431E:  MOVFF  FEC,02
04322:  MOVFF  FEC,03
04326:  MOVFF  644,68B
0432A:  MOVFF  643,68A
0432E:  MOVFF  642,689
04332:  MOVFF  641,688
04336:  MOVFF  03,68F
0433A:  MOVFF  02,68E
0433E:  MOVFF  01,68D
04342:  MOVLB  0
04344:  CALL   0DEC
04348:  MOVFF  03,654
0434C:  MOVFF  02,653
04350:  MOVFF  01,652
04354:  MOVFF  00,651
04358:  MOVFF  03,65A
0435C:  MOVFF  02,659
04360:  MOVFF  01,658
04364:  MOVFF  00,657
04368:  MOVLB  6
0436A:  CLRF   x5E
0436C:  CLRF   x5D
0436E:  MOVLW  40
04370:  MOVWF  x5C
04372:  MOVLW  80
04374:  MOVWF  x5B
04376:  MOVLB  0
04378:  CALL   367C
0437C:  MOVFF  FEA,652
04380:  MOVFF  FE9,651
04384:  BCF    FD8.1
04386:  MOVFF  64E,68A
0438A:  MOVFF  64D,689
0438E:  MOVFF  64C,688
04392:  MOVFF  64B,687
04396:  MOVFF  03,68E
0439A:  MOVFF  02,68D
0439E:  MOVFF  01,68C
043A2:  MOVFF  00,68B
043A6:  CALL   0EE2
043AA:  MOVFF  652,FEA
043AE:  MOVFF  651,FE9
043B2:  MOVFF  03,64E
043B6:  MOVFF  02,64D
043BA:  MOVFF  01,64C
043BE:  MOVFF  00,64B
043C2:  MOVLB  6
043C4:  MOVF   x40,W
043C6:  MULLW  18
043C8:  MOVF   FF3,W
043CA:  CLRF   x54
043CC:  MOVWF  x53
043CE:  MOVLW  08
043D0:  ADDWF  x53,W
043D2:  MOVWF  01
043D4:  MOVLW  00
043D6:  ADDWFC x54,W
043D8:  MOVWF  03
043DA:  MOVF   01,W
043DC:  ADDLW  82
043DE:  MOVWF  FE9
043E0:  MOVLW  00
043E2:  ADDWFC 03,W
043E4:  MOVWF  FEA
043E6:  MOVFF  FEF,68C
043EA:  MOVFF  FEC,01
043EE:  MOVFF  FEC,02
043F2:  MOVFF  FEC,03
043F6:  MOVFF  644,68B
043FA:  MOVFF  643,68A
043FE:  MOVFF  642,689
04402:  MOVFF  641,688
04406:  MOVFF  03,68F
0440A:  MOVFF  02,68E
0440E:  MOVFF  01,68D
04412:  MOVLB  0
04414:  CALL   0DEC
04418:  MOVFF  03,656
0441C:  MOVFF  02,655
04420:  MOVFF  01,654
04424:  MOVFF  00,653
04428:  MOVFF  03,65A
0442C:  MOVFF  02,659
04430:  MOVFF  01,658
04434:  MOVFF  00,657
04438:  MOVLB  6
0443A:  CLRF   x5E
0443C:  CLRF   x5D
0443E:  CLRF   x5C
04440:  MOVLW  80
04442:  MOVWF  x5B
04444:  MOVLB  0
04446:  CALL   367C
0444A:  MOVFF  FEA,654
0444E:  MOVFF  FE9,653
04452:  BCF    FD8.1
04454:  MOVFF  64E,68A
04458:  MOVFF  64D,689
0445C:  MOVFF  64C,688
04460:  MOVFF  64B,687
04464:  MOVFF  03,68E
04468:  MOVFF  02,68D
0446C:  MOVFF  01,68C
04470:  MOVFF  00,68B
04474:  CALL   0EE2
04478:  MOVFF  654,FEA
0447C:  MOVFF  653,FE9
04480:  MOVFF  03,64E
04484:  MOVFF  02,64D
04488:  MOVFF  01,64C
0448C:  MOVFF  00,64B
04490:  MOVLB  6
04492:  MOVF   x40,W
04494:  MULLW  18
04496:  MOVF   FF3,W
04498:  CLRF   x56
0449A:  MOVWF  x55
0449C:  MOVLW  04
0449E:  ADDWF  x55,W
044A0:  MOVWF  01
044A2:  MOVLW  00
044A4:  ADDWFC x56,W
044A6:  MOVWF  03
044A8:  MOVF   01,W
044AA:  ADDLW  82
044AC:  MOVWF  FE9
044AE:  MOVLW  00
044B0:  ADDWFC 03,W
044B2:  MOVWF  FEA
044B4:  MOVFF  FEF,68C
044B8:  MOVFF  FEC,01
044BC:  MOVFF  FEC,02
044C0:  MOVFF  FEC,03
044C4:  MOVFF  644,68B
044C8:  MOVFF  643,68A
044CC:  MOVFF  642,689
044D0:  MOVFF  641,688
044D4:  MOVFF  03,68F
044D8:  MOVFF  02,68E
044DC:  MOVFF  01,68D
044E0:  MOVLB  0
044E2:  CALL   0DEC
044E6:  MOVFF  FEA,656
044EA:  MOVFF  FE9,655
044EE:  BCF    FD8.1
044F0:  MOVFF  64E,68A
044F4:  MOVFF  64D,689
044F8:  MOVFF  64C,688
044FC:  MOVFF  64B,687
04500:  MOVFF  03,68E
04504:  MOVFF  02,68D
04508:  MOVFF  01,68C
0450C:  MOVFF  00,68B
04510:  CALL   0EE2
04514:  MOVFF  656,FEA
04518:  MOVFF  655,FE9
0451C:  MOVFF  03,68A
04520:  MOVFF  02,689
04524:  MOVFF  01,688
04528:  MOVFF  00,687
0452C:  MOVLB  6
0452E:  MOVF   x40,W
04530:  MULLW  18
04532:  MOVF   FF3,W
04534:  CLRF   x58
04536:  MOVWF  x57
04538:  MOVLW  82
0453A:  ADDWF  x57,W
0453C:  MOVWF  FE9
0453E:  MOVLW  00
04540:  ADDWFC x58,W
04542:  MOVWF  FEA
04544:  MOVFF  FEF,68B
04548:  MOVFF  FEC,01
0454C:  MOVFF  FEC,02
04550:  MOVFF  FEC,03
04554:  BCF    FD8.1
04556:  MOVFF  03,68E
0455A:  MOVFF  02,68D
0455E:  MOVFF  01,68C
04562:  MOVLB  0
04564:  CALL   0EE2
04568:  MOVFF  64A,FEA
0456C:  MOVFF  649,FE9
04570:  MOVFF  00,FEF
04574:  MOVFF  01,FEC
04578:  MOVFF  02,FEC
0457C:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04580:  MOVLB  6
04582:  MOVF   x40,F
04584:  BNZ   45E2
04586:  MOVF   x40,W
04588:  MULLW  21
0458A:  MOVF   FF3,W
0458C:  CLRF   x4A
0458E:  MOVWF  x49
04590:  MOVLW  1D
04592:  ADDWF  x49,W
04594:  MOVWF  01
04596:  MOVLW  00
04598:  ADDWFC x4A,W
0459A:  MOVWF  03
0459C:  MOVF   01,W
0459E:  ADDLW  0F
045A0:  MOVWF  FE9
045A2:  MOVLW  01
045A4:  ADDWFC 03,W
045A6:  MOVWF  FEA
045A8:  MOVFF  FEF,688
045AC:  MOVFF  FEC,689
045B0:  MOVFF  FEC,68A
045B4:  MOVFF  FEC,68B
045B8:  MOVF   FED,F
045BA:  MOVF   FED,F
045BC:  MOVF   FED,F
045BE:  CLRF   x8F
045C0:  CLRF   x8E
045C2:  MOVLW  80
045C4:  MOVWF  x8D
045C6:  MOVLW  7F
045C8:  MOVWF  x8C
045CA:  MOVLB  0
045CC:  CALL   0DEC
045D0:  MOVFF  00,FEF
045D4:  MOVFF  01,FEC
045D8:  MOVFF  02,FEC
045DC:  MOVFF  03,FEC
045E0:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
045E2:  MOVF   x40,W
045E4:  MULLW  20
045E6:  MOVF   FF3,W
045E8:  CLRF   x4A
045EA:  MOVWF  x49
045EC:  MOVLW  14
045EE:  ADDWF  x49,W
045F0:  MOVWF  01
045F2:  MOVLW  00
045F4:  ADDWFC x4A,W
045F6:  MOVWF  03
045F8:  MOVF   01,W
045FA:  ADDLW  20
045FC:  MOVWF  01
045FE:  MOVLW  00
04600:  ADDWFC 03,F
04602:  MOVFF  01,649
04606:  MOVFF  03,64A
0460A:  MOVF   x40,W
0460C:  MULLW  20
0460E:  MOVF   FF3,W
04610:  CLRF   x4C
04612:  MOVWF  x4B
04614:  MOVLW  10
04616:  ADDWF  x4B,W
04618:  MOVWF  01
0461A:  MOVLW  00
0461C:  ADDWFC x4C,W
0461E:  MOVWF  03
04620:  MOVF   01,W
04622:  ADDLW  20
04624:  MOVWF  FE9
04626:  MOVLW  00
04628:  ADDWFC 03,W
0462A:  MOVWF  FEA
0462C:  MOVFF  FEF,00
04630:  MOVFF  FEC,01
04634:  MOVFF  FEC,02
04638:  MOVFF  FEC,03
0463C:  MOVFF  64A,FEA
04640:  MOVFF  649,FE9
04644:  MOVFF  00,FEF
04648:  MOVFF  01,FEC
0464C:  MOVFF  02,FEC
04650:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04654:  MOVF   x40,W
04656:  MULLW  20
04658:  MOVF   FF3,W
0465A:  CLRF   x4A
0465C:  MOVWF  x49
0465E:  MOVLW  10
04660:  ADDWF  x49,W
04662:  MOVWF  01
04664:  MOVLW  00
04666:  ADDWFC x4A,W
04668:  MOVWF  03
0466A:  MOVF   01,W
0466C:  ADDLW  20
0466E:  MOVWF  01
04670:  MOVLW  00
04672:  ADDWFC 03,F
04674:  MOVFF  01,649
04678:  MOVFF  03,64A
0467C:  MOVF   x40,W
0467E:  MULLW  21
04680:  MOVF   FF3,W
04682:  CLRF   x4C
04684:  MOVWF  x4B
04686:  MOVLW  1D
04688:  ADDWF  x4B,W
0468A:  MOVWF  01
0468C:  MOVLW  00
0468E:  ADDWFC x4C,W
04690:  MOVWF  03
04692:  MOVF   01,W
04694:  ADDLW  0F
04696:  MOVWF  FE9
04698:  MOVLW  01
0469A:  ADDWFC 03,W
0469C:  MOVWF  FEA
0469E:  MOVFF  FEF,00
046A2:  MOVFF  FEC,01
046A6:  MOVFF  FEC,02
046AA:  MOVFF  FEC,03
046AE:  MOVFF  64A,FEA
046B2:  MOVFF  649,FE9
046B6:  MOVFF  00,FEF
046BA:  MOVFF  01,FEC
046BE:  MOVFF  02,FEC
046C2:  MOVFF  03,FEC
046C6:  MOVLB  0
046C8:  GOTO   47AC (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001BE:  MOVLB  1
001C0:  MOVF   xB0,W
001C2:  MULLW  0D
001C4:  MOVF   FF3,W
001C6:  MOVLB  6
001C8:  CLRF   xB3
001CA:  MOVWF  xB2
001CC:  MOVLW  95
001CE:  ADDWF  xB2,W
001D0:  MOVWF  FE9
001D2:  MOVLW  01
001D4:  ADDWFC xB3,W
001D6:  MOVWF  FEA
001D8:  BTFSC  FEF.1
001DA:  BRA    0254
....................    {
....................       smData[ch].adcBusy = true;
001DC:  MOVLB  1
001DE:  MOVF   xB0,W
001E0:  MULLW  0D
001E2:  MOVF   FF3,W
001E4:  MOVLB  6
001E6:  CLRF   xB3
001E8:  MOVWF  xB2
001EA:  MOVLW  95
001EC:  ADDWF  xB2,W
001EE:  MOVWF  FE9
001F0:  MOVLW  01
001F2:  ADDWFC xB3,W
001F4:  MOVWF  FEA
001F6:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001F8:  MOVFF  1B0,6B2
001FC:  MOVLB  0
001FE:  BRA    01A2
....................       ch = !ch;
00200:  MOVLB  1
00202:  MOVF   xB0,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVWF  xB0
....................       
....................       smData[!ch].dataReady = true;
0020E:  MOVF   xB0,F
00210:  BZ    0216
00212:  MOVLW  00
00214:  BRA    0218
00216:  MOVLW  01
00218:  MULLW  0D
0021A:  MOVF   FF3,W
0021C:  MOVLB  6
0021E:  CLRF   xB3
00220:  MOVWF  xB2
00222:  MOVLW  95
00224:  ADDWF  xB2,W
00226:  MOVWF  FE9
00228:  MOVLW  01
0022A:  ADDWFC xB3,W
0022C:  MOVWF  FEA
0022E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00230:  MOVLB  1
00232:  MOVF   xB0,F
00234:  BZ    023A
00236:  MOVLW  00
00238:  BRA    023C
0023A:  MOVLW  01
0023C:  MULLW  0D
0023E:  MOVF   FF3,W
00240:  MOVLB  6
00242:  CLRF   xB3
00244:  MOVWF  xB2
00246:  MOVLW  95
00248:  ADDWF  xB2,W
0024A:  MOVWF  FE9
0024C:  MOVLW  01
0024E:  ADDWFC xB3,W
00250:  MOVWF  FEA
00252:  BCF    FEF.1
....................    }
00254:  MOVLB  0
00256:  GOTO   0318 (RETURN)
.................... }
.................... 
.................... signed int8 compar(signed int32 *arg1,signed int32 *arg2);
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts)
*
01742:  MOVLB  6
01744:  CLRF   x9C
01746:  CLRF   x9B
01748:  CLRF   x9A
0174A:  CLRF   x99
0174C:  CLRF   xA0
0174E:  CLRF   x9F
01750:  CLRF   x9E
01752:  CLRF   x9D
.................... {
....................    /* 
....................    -  copy data out to IQM buffer
....................    -  sort IQM buffer
....................    -  average values from middle quartile
....................    **************************************/
....................    signed int32 iqmBufSin[BUFFER_SIZE];
....................    signed int32 iqmBufCos[BUFFER_SIZE];
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    tobuff(smData[ch].sinQ, sinCnts); // push new data into queues
01754:  MOVF   x40,W
01756:  MULLW  0D
01758:  MOVF   FF3,W
0175A:  CLRF   xA4
0175C:  MOVWF  xA3
0175E:  MOVLW  01
01760:  ADDWF  xA3,W
01762:  MOVWF  01
01764:  MOVLW  00
01766:  ADDWFC xA4,W
01768:  MOVWF  03
0176A:  MOVF   01,W
0176C:  ADDLW  95
0176E:  MOVWF  01
01770:  MOVLW  01
01772:  ADDWFC 03,F
01774:  MOVFF  01,6A3
01778:  MOVFF  03,6A4
0177C:  MOVFF  03,FEA
01780:  MOVFF  01,FE9
01784:  MOVFF  FEC,6A6
01788:  MOVF   FED,F
0178A:  MOVFF  FEF,6A5
0178E:  MOVF   x40,W
01790:  MULLW  0D
01792:  MOVF   FF3,W
01794:  CLRF   xA8
01796:  MOVWF  xA7
01798:  MOVLW  01
0179A:  ADDWF  xA7,W
0179C:  MOVWF  01
0179E:  MOVLW  00
017A0:  ADDWFC xA8,W
017A2:  MOVWF  03
017A4:  MOVF   01,W
017A6:  ADDLW  95
017A8:  MOVWF  01
017AA:  MOVLW  01
017AC:  ADDWFC 03,F
017AE:  MOVFF  01,6A7
017B2:  MOVFF  03,6A8
017B6:  MOVFF  03,FEA
017BA:  MOVFF  01,FE9
017BE:  MOVFF  FEC,6AA
017C2:  MOVF   FED,F
017C4:  MOVFF  FEF,6A9
017C8:  MOVFF  6A9,FE9
017CC:  MOVFF  6AA,FEA
017D0:  MOVLW  02
017D2:  ADDWF  FEF,W
017D4:  ADDWF  xA5,W
017D6:  MOVWF  FE9
017D8:  MOVLW  00
017DA:  ADDWFC xA6,W
017DC:  MOVWF  FEA
017DE:  MOVFF  641,FEF
017E2:  MOVF   x40,W
017E4:  MULLW  0D
017E6:  MOVF   FF3,W
017E8:  CLRF   xA4
017EA:  MOVWF  xA3
017EC:  MOVLW  01
017EE:  ADDWF  xA3,W
017F0:  MOVWF  01
017F2:  MOVLW  00
017F4:  ADDWFC xA4,W
017F6:  MOVWF  03
017F8:  MOVF   01,W
017FA:  ADDLW  95
017FC:  MOVWF  01
017FE:  MOVLW  01
01800:  ADDWFC 03,F
01802:  MOVFF  01,6A3
01806:  MOVFF  03,6A4
0180A:  MOVFF  03,FEA
0180E:  MOVFF  01,FE9
01812:  MOVFF  FEC,03
01816:  MOVF   FED,F
01818:  MOVFF  FEF,01
0181C:  MOVFF  01,6A7
01820:  MOVFF  03,6A8
01824:  MOVF   x40,W
01826:  MULLW  0D
01828:  MOVF   FF3,W
0182A:  CLRF   xAA
0182C:  MOVWF  xA9
0182E:  MOVLW  01
01830:  ADDWF  xA9,W
01832:  MOVWF  01
01834:  MOVLW  00
01836:  ADDWFC xAA,W
01838:  MOVWF  03
0183A:  MOVF   01,W
0183C:  ADDLW  95
0183E:  MOVWF  01
01840:  MOVLW  01
01842:  ADDWFC 03,F
01844:  MOVFF  01,6A9
01848:  MOVFF  03,6AA
0184C:  MOVFF  03,FEA
01850:  MOVFF  01,FE9
01854:  MOVFF  FEC,6AC
01858:  MOVF   FED,F
0185A:  MOVFF  FEF,6AB
0185E:  MOVFF  6AB,FE9
01862:  MOVFF  6AC,FEA
01866:  MOVF   FEF,W
01868:  SUBLW  09
0186A:  BNZ   1870
0186C:  MOVLW  00
0186E:  BRA    18B6
01870:  MOVF   x40,W
01872:  MULLW  0D
01874:  MOVF   FF3,W
01876:  CLRF   xAE
01878:  MOVWF  xAD
0187A:  MOVLW  01
0187C:  ADDWF  xAD,W
0187E:  MOVWF  01
01880:  MOVLW  00
01882:  ADDWFC xAE,W
01884:  MOVWF  03
01886:  MOVF   01,W
01888:  ADDLW  95
0188A:  MOVWF  01
0188C:  MOVLW  01
0188E:  ADDWFC 03,F
01890:  MOVFF  01,6AD
01894:  MOVFF  03,6AE
01898:  MOVFF  03,FEA
0189C:  MOVFF  01,FE9
018A0:  MOVFF  FEC,6B0
018A4:  MOVF   FED,F
018A6:  MOVFF  FEF,6AF
018AA:  MOVFF  6AF,FE9
018AE:  MOVFF  6B0,FEA
018B2:  MOVLW  01
018B4:  ADDWF  FEF,W
018B6:  MOVWF  xB1
018B8:  MOVFF  6A8,FEA
018BC:  MOVFF  6A7,FE9
018C0:  MOVWF  FEF
018C2:  MOVF   x40,W
018C4:  MULLW  0D
018C6:  MOVF   FF3,W
018C8:  CLRF   xA4
018CA:  MOVWF  xA3
018CC:  MOVLW  01
018CE:  ADDWF  xA3,W
018D0:  MOVWF  01
018D2:  MOVLW  00
018D4:  ADDWFC xA4,W
018D6:  MOVWF  03
018D8:  MOVF   01,W
018DA:  ADDLW  95
018DC:  MOVWF  01
018DE:  MOVLW  01
018E0:  ADDWFC 03,F
018E2:  MOVFF  01,6A3
018E6:  MOVFF  03,6A4
018EA:  MOVFF  03,FEA
018EE:  MOVFF  01,FE9
018F2:  MOVFF  FEC,6A6
018F6:  MOVF   FED,F
018F8:  MOVFF  FEF,6A5
018FC:  MOVFF  6A5,FE9
01900:  MOVFF  6A6,FEA
01904:  MOVFF  FEF,6A7
01908:  MOVF   x40,W
0190A:  MULLW  0D
0190C:  MOVF   FF3,W
0190E:  CLRF   xA9
01910:  MOVWF  xA8
01912:  MOVLW  01
01914:  ADDWF  xA8,W
01916:  MOVWF  01
01918:  MOVLW  00
0191A:  ADDWFC xA9,W
0191C:  MOVWF  03
0191E:  MOVF   01,W
01920:  ADDLW  95
01922:  MOVWF  01
01924:  MOVLW  01
01926:  ADDWFC 03,F
01928:  MOVFF  01,6A8
0192C:  MOVFF  03,6A9
01930:  MOVFF  03,FEA
01934:  MOVFF  01,FE9
01938:  MOVFF  FEC,6AB
0193C:  MOVF   FED,F
0193E:  MOVFF  FEF,6AA
01942:  MOVLW  01
01944:  ADDWF  xAA,W
01946:  MOVWF  FE9
01948:  MOVLW  00
0194A:  ADDWFC xAB,W
0194C:  MOVWF  FEA
0194E:  MOVF   FEF,W
01950:  SUBWF  xA7,W
01952:  BNZ   1A44
01954:  MOVF   x40,W
01956:  MULLW  0D
01958:  MOVF   FF3,W
0195A:  CLRF   xA4
0195C:  MOVWF  xA3
0195E:  MOVLW  01
01960:  ADDWF  xA3,W
01962:  MOVWF  01
01964:  MOVLW  00
01966:  ADDWFC xA4,W
01968:  MOVWF  03
0196A:  MOVF   01,W
0196C:  ADDLW  95
0196E:  MOVWF  01
01970:  MOVLW  01
01972:  ADDWFC 03,F
01974:  MOVFF  01,6A3
01978:  MOVFF  03,6A4
0197C:  MOVFF  03,FEA
01980:  MOVFF  01,FE9
01984:  MOVFF  FEC,6A6
01988:  MOVF   FED,F
0198A:  MOVFF  FEF,6A5
0198E:  MOVLW  01
01990:  ADDWF  xA5,W
01992:  MOVWF  01
01994:  MOVLW  00
01996:  ADDWFC xA6,W
01998:  MOVWF  03
0199A:  MOVFF  01,6A7
0199E:  MOVWF  xA8
019A0:  MOVF   x40,W
019A2:  MULLW  0D
019A4:  MOVF   FF3,W
019A6:  CLRF   xAA
019A8:  MOVWF  xA9
019AA:  MOVLW  01
019AC:  ADDWF  xA9,W
019AE:  MOVWF  01
019B0:  MOVLW  00
019B2:  ADDWFC xAA,W
019B4:  MOVWF  03
019B6:  MOVF   01,W
019B8:  ADDLW  95
019BA:  MOVWF  01
019BC:  MOVLW  01
019BE:  ADDWFC 03,F
019C0:  MOVFF  01,6A9
019C4:  MOVFF  03,6AA
019C8:  MOVFF  03,FEA
019CC:  MOVFF  01,FE9
019D0:  MOVFF  FEC,6AC
019D4:  MOVF   FED,F
019D6:  MOVFF  FEF,6AB
019DA:  MOVLW  01
019DC:  ADDWF  xAB,W
019DE:  MOVWF  FE9
019E0:  MOVLW  00
019E2:  ADDWFC xAC,W
019E4:  MOVWF  FEA
019E6:  MOVF   FEF,W
019E8:  SUBLW  09
019EA:  BNZ   19F0
019EC:  MOVLW  00
019EE:  BRA    1A3A
019F0:  MOVF   x40,W
019F2:  MULLW  0D
019F4:  MOVF   FF3,W
019F6:  CLRF   xAE
019F8:  MOVWF  xAD
019FA:  MOVLW  01
019FC:  ADDWF  xAD,W
019FE:  MOVWF  01
01A00:  MOVLW  00
01A02:  ADDWFC xAE,W
01A04:  MOVWF  03
01A06:  MOVF   01,W
01A08:  ADDLW  95
01A0A:  MOVWF  01
01A0C:  MOVLW  01
01A0E:  ADDWFC 03,F
01A10:  MOVFF  01,6AD
01A14:  MOVFF  03,6AE
01A18:  MOVFF  03,FEA
01A1C:  MOVFF  01,FE9
01A20:  MOVFF  FEC,6B0
01A24:  MOVF   FED,F
01A26:  MOVFF  FEF,6AF
01A2A:  MOVLW  01
01A2C:  ADDWF  xAF,W
01A2E:  MOVWF  FE9
01A30:  MOVLW  00
01A32:  ADDWFC xB0,W
01A34:  MOVWF  FEA
01A36:  MOVLW  01
01A38:  ADDWF  FEF,W
01A3A:  MOVFF  6A8,FEA
01A3E:  MOVFF  6A7,FE9
01A42:  MOVWF  FEF
....................    tobuff(smData[ch].cosQ, cosCnts);
01A44:  MOVF   x40,W
01A46:  MULLW  0D
01A48:  MOVF   FF3,W
01A4A:  CLRF   xA4
01A4C:  MOVWF  xA3
01A4E:  MOVLW  03
01A50:  ADDWF  xA3,W
01A52:  MOVWF  01
01A54:  MOVLW  00
01A56:  ADDWFC xA4,W
01A58:  MOVWF  03
01A5A:  MOVF   01,W
01A5C:  ADDLW  95
01A5E:  MOVWF  01
01A60:  MOVLW  01
01A62:  ADDWFC 03,F
01A64:  MOVFF  01,6A3
01A68:  MOVFF  03,6A4
01A6C:  MOVFF  03,FEA
01A70:  MOVFF  01,FE9
01A74:  MOVFF  FEC,6A6
01A78:  MOVF   FED,F
01A7A:  MOVFF  FEF,6A5
01A7E:  MOVF   x40,W
01A80:  MULLW  0D
01A82:  MOVF   FF3,W
01A84:  CLRF   xA8
01A86:  MOVWF  xA7
01A88:  MOVLW  03
01A8A:  ADDWF  xA7,W
01A8C:  MOVWF  01
01A8E:  MOVLW  00
01A90:  ADDWFC xA8,W
01A92:  MOVWF  03
01A94:  MOVF   01,W
01A96:  ADDLW  95
01A98:  MOVWF  01
01A9A:  MOVLW  01
01A9C:  ADDWFC 03,F
01A9E:  MOVFF  01,6A7
01AA2:  MOVFF  03,6A8
01AA6:  MOVFF  03,FEA
01AAA:  MOVFF  01,FE9
01AAE:  MOVFF  FEC,6AA
01AB2:  MOVF   FED,F
01AB4:  MOVFF  FEF,6A9
01AB8:  MOVFF  6A9,FE9
01ABC:  MOVFF  6AA,FEA
01AC0:  MOVLW  02
01AC2:  ADDWF  FEF,W
01AC4:  ADDWF  xA5,W
01AC6:  MOVWF  FE9
01AC8:  MOVLW  00
01ACA:  ADDWFC xA6,W
01ACC:  MOVWF  FEA
01ACE:  MOVFF  645,FEF
01AD2:  MOVF   x40,W
01AD4:  MULLW  0D
01AD6:  MOVF   FF3,W
01AD8:  CLRF   xA4
01ADA:  MOVWF  xA3
01ADC:  MOVLW  03
01ADE:  ADDWF  xA3,W
01AE0:  MOVWF  01
01AE2:  MOVLW  00
01AE4:  ADDWFC xA4,W
01AE6:  MOVWF  03
01AE8:  MOVF   01,W
01AEA:  ADDLW  95
01AEC:  MOVWF  01
01AEE:  MOVLW  01
01AF0:  ADDWFC 03,F
01AF2:  MOVFF  01,6A3
01AF6:  MOVFF  03,6A4
01AFA:  MOVFF  03,FEA
01AFE:  MOVFF  01,FE9
01B02:  MOVFF  FEC,03
01B06:  MOVF   FED,F
01B08:  MOVFF  FEF,01
01B0C:  MOVFF  01,6A7
01B10:  MOVFF  03,6A8
01B14:  MOVF   x40,W
01B16:  MULLW  0D
01B18:  MOVF   FF3,W
01B1A:  CLRF   xAA
01B1C:  MOVWF  xA9
01B1E:  MOVLW  03
01B20:  ADDWF  xA9,W
01B22:  MOVWF  01
01B24:  MOVLW  00
01B26:  ADDWFC xAA,W
01B28:  MOVWF  03
01B2A:  MOVF   01,W
01B2C:  ADDLW  95
01B2E:  MOVWF  01
01B30:  MOVLW  01
01B32:  ADDWFC 03,F
01B34:  MOVFF  01,6A9
01B38:  MOVFF  03,6AA
01B3C:  MOVFF  03,FEA
01B40:  MOVFF  01,FE9
01B44:  MOVFF  FEC,6AC
01B48:  MOVF   FED,F
01B4A:  MOVFF  FEF,6AB
01B4E:  MOVFF  6AB,FE9
01B52:  MOVFF  6AC,FEA
01B56:  MOVF   FEF,W
01B58:  SUBLW  09
01B5A:  BNZ   1B60
01B5C:  MOVLW  00
01B5E:  BRA    1BA6
01B60:  MOVF   x40,W
01B62:  MULLW  0D
01B64:  MOVF   FF3,W
01B66:  CLRF   xAE
01B68:  MOVWF  xAD
01B6A:  MOVLW  03
01B6C:  ADDWF  xAD,W
01B6E:  MOVWF  01
01B70:  MOVLW  00
01B72:  ADDWFC xAE,W
01B74:  MOVWF  03
01B76:  MOVF   01,W
01B78:  ADDLW  95
01B7A:  MOVWF  01
01B7C:  MOVLW  01
01B7E:  ADDWFC 03,F
01B80:  MOVFF  01,6AD
01B84:  MOVFF  03,6AE
01B88:  MOVFF  03,FEA
01B8C:  MOVFF  01,FE9
01B90:  MOVFF  FEC,6B0
01B94:  MOVF   FED,F
01B96:  MOVFF  FEF,6AF
01B9A:  MOVFF  6AF,FE9
01B9E:  MOVFF  6B0,FEA
01BA2:  MOVLW  01
01BA4:  ADDWF  FEF,W
01BA6:  MOVWF  xB1
01BA8:  MOVFF  6A8,FEA
01BAC:  MOVFF  6A7,FE9
01BB0:  MOVWF  FEF
01BB2:  MOVF   x40,W
01BB4:  MULLW  0D
01BB6:  MOVF   FF3,W
01BB8:  CLRF   xA4
01BBA:  MOVWF  xA3
01BBC:  MOVLW  03
01BBE:  ADDWF  xA3,W
01BC0:  MOVWF  01
01BC2:  MOVLW  00
01BC4:  ADDWFC xA4,W
01BC6:  MOVWF  03
01BC8:  MOVF   01,W
01BCA:  ADDLW  95
01BCC:  MOVWF  01
01BCE:  MOVLW  01
01BD0:  ADDWFC 03,F
01BD2:  MOVFF  01,6A3
01BD6:  MOVFF  03,6A4
01BDA:  MOVFF  03,FEA
01BDE:  MOVFF  01,FE9
01BE2:  MOVFF  FEC,6A6
01BE6:  MOVF   FED,F
01BE8:  MOVFF  FEF,6A5
01BEC:  MOVFF  6A5,FE9
01BF0:  MOVFF  6A6,FEA
01BF4:  MOVFF  FEF,6A7
01BF8:  MOVF   x40,W
01BFA:  MULLW  0D
01BFC:  MOVF   FF3,W
01BFE:  CLRF   xA9
01C00:  MOVWF  xA8
01C02:  MOVLW  03
01C04:  ADDWF  xA8,W
01C06:  MOVWF  01
01C08:  MOVLW  00
01C0A:  ADDWFC xA9,W
01C0C:  MOVWF  03
01C0E:  MOVF   01,W
01C10:  ADDLW  95
01C12:  MOVWF  01
01C14:  MOVLW  01
01C16:  ADDWFC 03,F
01C18:  MOVFF  01,6A8
01C1C:  MOVFF  03,6A9
01C20:  MOVFF  03,FEA
01C24:  MOVFF  01,FE9
01C28:  MOVFF  FEC,6AB
01C2C:  MOVF   FED,F
01C2E:  MOVFF  FEF,6AA
01C32:  MOVLW  01
01C34:  ADDWF  xAA,W
01C36:  MOVWF  FE9
01C38:  MOVLW  00
01C3A:  ADDWFC xAB,W
01C3C:  MOVWF  FEA
01C3E:  MOVF   FEF,W
01C40:  SUBWF  xA7,W
01C42:  BNZ   1D34
01C44:  MOVF   x40,W
01C46:  MULLW  0D
01C48:  MOVF   FF3,W
01C4A:  CLRF   xA4
01C4C:  MOVWF  xA3
01C4E:  MOVLW  03
01C50:  ADDWF  xA3,W
01C52:  MOVWF  01
01C54:  MOVLW  00
01C56:  ADDWFC xA4,W
01C58:  MOVWF  03
01C5A:  MOVF   01,W
01C5C:  ADDLW  95
01C5E:  MOVWF  01
01C60:  MOVLW  01
01C62:  ADDWFC 03,F
01C64:  MOVFF  01,6A3
01C68:  MOVFF  03,6A4
01C6C:  MOVFF  03,FEA
01C70:  MOVFF  01,FE9
01C74:  MOVFF  FEC,6A6
01C78:  MOVF   FED,F
01C7A:  MOVFF  FEF,6A5
01C7E:  MOVLW  01
01C80:  ADDWF  xA5,W
01C82:  MOVWF  01
01C84:  MOVLW  00
01C86:  ADDWFC xA6,W
01C88:  MOVWF  03
01C8A:  MOVFF  01,6A7
01C8E:  MOVWF  xA8
01C90:  MOVF   x40,W
01C92:  MULLW  0D
01C94:  MOVF   FF3,W
01C96:  CLRF   xAA
01C98:  MOVWF  xA9
01C9A:  MOVLW  03
01C9C:  ADDWF  xA9,W
01C9E:  MOVWF  01
01CA0:  MOVLW  00
01CA2:  ADDWFC xAA,W
01CA4:  MOVWF  03
01CA6:  MOVF   01,W
01CA8:  ADDLW  95
01CAA:  MOVWF  01
01CAC:  MOVLW  01
01CAE:  ADDWFC 03,F
01CB0:  MOVFF  01,6A9
01CB4:  MOVFF  03,6AA
01CB8:  MOVFF  03,FEA
01CBC:  MOVFF  01,FE9
01CC0:  MOVFF  FEC,6AC
01CC4:  MOVF   FED,F
01CC6:  MOVFF  FEF,6AB
01CCA:  MOVLW  01
01CCC:  ADDWF  xAB,W
01CCE:  MOVWF  FE9
01CD0:  MOVLW  00
01CD2:  ADDWFC xAC,W
01CD4:  MOVWF  FEA
01CD6:  MOVF   FEF,W
01CD8:  SUBLW  09
01CDA:  BNZ   1CE0
01CDC:  MOVLW  00
01CDE:  BRA    1D2A
01CE0:  MOVF   x40,W
01CE2:  MULLW  0D
01CE4:  MOVF   FF3,W
01CE6:  CLRF   xAE
01CE8:  MOVWF  xAD
01CEA:  MOVLW  03
01CEC:  ADDWF  xAD,W
01CEE:  MOVWF  01
01CF0:  MOVLW  00
01CF2:  ADDWFC xAE,W
01CF4:  MOVWF  03
01CF6:  MOVF   01,W
01CF8:  ADDLW  95
01CFA:  MOVWF  01
01CFC:  MOVLW  01
01CFE:  ADDWFC 03,F
01D00:  MOVFF  01,6AD
01D04:  MOVFF  03,6AE
01D08:  MOVFF  03,FEA
01D0C:  MOVFF  01,FE9
01D10:  MOVFF  FEC,6B0
01D14:  MOVF   FED,F
01D16:  MOVFF  FEF,6AF
01D1A:  MOVLW  01
01D1C:  ADDWF  xAF,W
01D1E:  MOVWF  FE9
01D20:  MOVLW  00
01D22:  ADDWFC xB0,W
01D24:  MOVWF  FEA
01D26:  MOVLW  01
01D28:  ADDWF  FEF,W
01D2A:  MOVFF  6A8,FEA
01D2E:  MOVFF  6A7,FE9
01D32:  MOVWF  FEF
....................    
....................    // copy queue contents out to buffer for qsorting
....................    for (int8 i=0; i<BUFFER_SIZE; i++){
01D34:  CLRF   xA1
01D36:  MOVF   xA1,W
01D38:  SUBLW  09
01D3A:  BNC   1E1C
....................       iqmBufSin[i] = smData[ch].sinQ->buff[i];   
01D3C:  MOVF   xA1,W
01D3E:  MULLW  04
01D40:  MOVF   FF3,W
01D42:  CLRF   03
01D44:  ADDLW  49
01D46:  MOVWF  01
01D48:  MOVLW  06
01D4A:  ADDWFC 03,F
01D4C:  MOVFF  01,6A3
01D50:  MOVFF  03,6A4
01D54:  MOVF   x40,W
01D56:  MULLW  0D
01D58:  MOVF   FF3,W
01D5A:  CLRF   xA6
01D5C:  MOVWF  xA5
01D5E:  MOVLW  01
01D60:  ADDWF  xA5,W
01D62:  MOVWF  01
01D64:  MOVLW  00
01D66:  ADDWFC xA6,W
01D68:  MOVWF  03
01D6A:  MOVF   01,W
01D6C:  ADDLW  95
01D6E:  MOVWF  01
01D70:  MOVLW  01
01D72:  ADDWFC 03,F
01D74:  MOVFF  03,FEA
01D78:  MOVFF  01,FE9
01D7C:  MOVFF  FEC,6A8
01D80:  MOVF   FED,F
01D82:  MOVFF  FEF,6A7
01D86:  MOVLW  02
01D88:  ADDWF  xA1,W
01D8A:  ADDWF  xA7,W
01D8C:  MOVWF  FE9
01D8E:  MOVLW  00
01D90:  ADDWFC xA8,W
01D92:  MOVWF  FEA
01D94:  MOVFF  FEF,00
01D98:  MOVFF  6A4,FEA
01D9C:  MOVFF  6A3,FE9
01DA0:  MOVFF  00,FEF
01DA4:  CLRF   FEC
01DA6:  CLRF   FEC
01DA8:  CLRF   FEC
....................       iqmBufCos[i] = smData[ch].cosQ->buff[i];   
01DAA:  MOVF   xA1,W
01DAC:  MULLW  04
01DAE:  MOVF   FF3,W
01DB0:  CLRF   03
01DB2:  ADDLW  71
01DB4:  MOVWF  01
01DB6:  MOVLW  06
01DB8:  ADDWFC 03,F
01DBA:  MOVFF  01,6A3
01DBE:  MOVFF  03,6A4
01DC2:  MOVF   x40,W
01DC4:  MULLW  0D
01DC6:  MOVF   FF3,W
01DC8:  CLRF   xA6
01DCA:  MOVWF  xA5
01DCC:  MOVLW  03
01DCE:  ADDWF  xA5,W
01DD0:  MOVWF  01
01DD2:  MOVLW  00
01DD4:  ADDWFC xA6,W
01DD6:  MOVWF  03
01DD8:  MOVF   01,W
01DDA:  ADDLW  95
01DDC:  MOVWF  01
01DDE:  MOVLW  01
01DE0:  ADDWFC 03,F
01DE2:  MOVFF  03,FEA
01DE6:  MOVFF  01,FE9
01DEA:  MOVFF  FEC,6A8
01DEE:  MOVF   FED,F
01DF0:  MOVFF  FEF,6A7
01DF4:  MOVLW  02
01DF6:  ADDWF  xA1,W
01DF8:  ADDWF  xA7,W
01DFA:  MOVWF  FE9
01DFC:  MOVLW  00
01DFE:  ADDWFC xA8,W
01E00:  MOVWF  FEA
01E02:  MOVFF  FEF,00
01E06:  MOVFF  6A4,FEA
01E0A:  MOVFF  6A3,FE9
01E0E:  MOVFF  00,FEF
01E12:  CLRF   FEC
01E14:  CLRF   FEC
01E16:  CLRF   FEC
01E18:  INCF   xA1,F
01E1A:  BRA    1D36
....................    }
....................    
.................... //!   qsort(iqmBufSin, BUFFER_SIZE, sizeof(*iqmBufSin), compar);
.................... //!   qsort(iqmBufCos, BUFFER_SIZE, sizeof(*iqmBufCos), compar);
....................    
....................    for (int8 i=1; i<BUFFER_SIZE-1; i++){
01E1C:  MOVLW  01
01E1E:  MOVWF  xA2
01E20:  MOVF   xA2,W
01E22:  SUBLW  08
01E24:  BNC   1E8E
....................       sumSin+=iqmBufSin[i];
01E26:  MOVF   xA2,W
01E28:  MULLW  04
01E2A:  MOVF   FF3,W
01E2C:  CLRF   03
01E2E:  ADDLW  49
01E30:  MOVWF  FE9
01E32:  MOVLW  06
01E34:  ADDWFC 03,W
01E36:  MOVWF  FEA
01E38:  MOVFF  FEF,00
01E3C:  MOVFF  FEC,01
01E40:  MOVFF  FEC,02
01E44:  MOVFF  FEC,03
01E48:  MOVF   00,W
01E4A:  ADDWF  x99,F
01E4C:  MOVF   01,W
01E4E:  ADDWFC x9A,F
01E50:  MOVF   02,W
01E52:  ADDWFC x9B,F
01E54:  MOVF   03,W
01E56:  ADDWFC x9C,F
....................       sumCos+=iqmBufCos[i];
01E58:  MOVF   xA2,W
01E5A:  MULLW  04
01E5C:  MOVF   FF3,W
01E5E:  CLRF   03
01E60:  ADDLW  71
01E62:  MOVWF  FE9
01E64:  MOVLW  06
01E66:  ADDWFC 03,W
01E68:  MOVWF  FEA
01E6A:  MOVFF  FEF,00
01E6E:  MOVFF  FEC,01
01E72:  MOVFF  FEC,02
01E76:  MOVFF  FEC,03
01E7A:  MOVF   00,W
01E7C:  ADDWF  x9D,F
01E7E:  MOVF   01,W
01E80:  ADDWFC x9E,F
01E82:  MOVF   02,W
01E84:  ADDWFC x9F,F
01E86:  MOVF   03,W
01E88:  ADDWFC xA0,F
01E8A:  INCF   xA2,F
01E8C:  BRA    1E20
....................    }
....................    smData[ch].avgSin = sumSin >> 3;
01E8E:  MOVF   x40,W
01E90:  MULLW  0D
01E92:  MOVF   FF3,W
01E94:  CLRF   xA4
01E96:  MOVWF  xA3
01E98:  MOVLW  05
01E9A:  ADDWF  xA3,W
01E9C:  MOVWF  01
01E9E:  MOVLW  00
01EA0:  ADDWFC xA4,W
01EA2:  MOVWF  03
01EA4:  MOVF   01,W
01EA6:  ADDLW  95
01EA8:  MOVWF  FE9
01EAA:  MOVLW  01
01EAC:  ADDWFC 03,W
01EAE:  MOVWF  FEA
01EB0:  RRCF   x9C,W
01EB2:  MOVWF  03
01EB4:  RRCF   x9B,W
01EB6:  MOVWF  02
01EB8:  RRCF   x9A,W
01EBA:  MOVWF  01
01EBC:  RRCF   x99,W
01EBE:  MOVWF  00
01EC0:  RRCF   03,F
01EC2:  RRCF   02,F
01EC4:  RRCF   01,F
01EC6:  RRCF   00,F
01EC8:  RRCF   03,F
01ECA:  RRCF   02,F
01ECC:  RRCF   01,F
01ECE:  RRCF   00,F
01ED0:  MOVLW  1F
01ED2:  ANDWF  03,F
01ED4:  MOVFF  00,FEF
01ED8:  MOVFF  01,FEC
01EDC:  MOVFF  02,FEC
01EE0:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos >> 3;
01EE4:  MOVF   x40,W
01EE6:  MULLW  0D
01EE8:  MOVF   FF3,W
01EEA:  CLRF   xA4
01EEC:  MOVWF  xA3
01EEE:  MOVLW  09
01EF0:  ADDWF  xA3,W
01EF2:  MOVWF  01
01EF4:  MOVLW  00
01EF6:  ADDWFC xA4,W
01EF8:  MOVWF  03
01EFA:  MOVF   01,W
01EFC:  ADDLW  95
01EFE:  MOVWF  FE9
01F00:  MOVLW  01
01F02:  ADDWFC 03,W
01F04:  MOVWF  FEA
01F06:  RRCF   xA0,W
01F08:  MOVWF  03
01F0A:  RRCF   x9F,W
01F0C:  MOVWF  02
01F0E:  RRCF   x9E,W
01F10:  MOVWF  01
01F12:  RRCF   x9D,W
01F14:  MOVWF  00
01F16:  RRCF   03,F
01F18:  RRCF   02,F
01F1A:  RRCF   01,F
01F1C:  RRCF   00,F
01F1E:  RRCF   03,F
01F20:  RRCF   02,F
01F22:  RRCF   01,F
01F24:  RRCF   00,F
01F26:  MOVLW  1F
01F28:  ANDWF  03,F
01F2A:  MOVFF  00,FEF
01F2E:  MOVFF  01,FEC
01F32:  MOVFF  02,FEC
01F36:  MOVFF  03,FEC
01F3A:  MOVLB  0
01F3C:  GOTO   47A4 (RETURN)
.................... }
.................... 
.................... signed int8 compar(signed int32 *arg1,signed int32 *arg2)  {
....................    if (* (signed int32 *) arg1 < (* (signed int32 *) arg2)) return -1;
....................    else if (* (signed int32 *) arg1 == (* (signed int32 *) arg2)) return 0;
....................    else return 1;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
046CC:  MOVLB  6
046CE:  CLRF   x3B
046D0:  CLRF   x3A
046D2:  CLRF   x39
046D4:  CLRF   x38
046D6:  CLRF   x3F
046D8:  CLRF   x3E
046DA:  CLRF   x3D
046DC:  CLRF   x3C
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
046DE:  MOVLB  1
046E0:  MOVF   xB1,W
046E2:  MULLW  0D
046E4:  MOVF   FF3,W
046E6:  MOVLB  6
046E8:  CLRF   x41
046EA:  MOVWF  x40
046EC:  MOVLW  95
046EE:  ADDWF  x40,W
046F0:  MOVWF  FE9
046F2:  MOVLW  01
046F4:  ADDWFC x41,W
046F6:  MOVWF  FEA
046F8:  BTFSC  FEF.1
046FA:  BRA    4800
046FC:  MOVLB  1
046FE:  MOVF   xB1,W
04700:  MULLW  0D
04702:  MOVF   FF3,W
04704:  MOVLB  6
04706:  CLRF   x43
04708:  MOVWF  x42
0470A:  MOVLW  95
0470C:  ADDWF  x42,W
0470E:  MOVWF  FE9
04710:  MOVLW  01
04712:  ADDWFC x43,W
04714:  MOVWF  FEA
04716:  BTFSS  FEF.0
04718:  BRA    4800
....................       smData[ch].adcBusy = true;
0471A:  MOVLB  1
0471C:  MOVF   xB1,W
0471E:  MULLW  0D
04720:  MOVF   FF3,W
04722:  MOVLB  6
04724:  CLRF   x41
04726:  MOVWF  x40
04728:  MOVLW  95
0472A:  ADDWF  x40,W
0472C:  MOVWF  FE9
0472E:  MOVLW  01
04730:  ADDWFC x41,W
04732:  MOVWF  FEA
04734:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04736:  BCF    FD8.0
04738:  MOVLB  1
0473A:  RLCF   xB1,W
0473C:  MOVLB  6
0473E:  MOVWF  x40
04740:  MOVWF  x41
04742:  MOVLB  0
04744:  CALL   16F2
04748:  MOVFF  03,63B
0474C:  MOVFF  02,63A
04750:  MOVFF  01,639
04754:  MOVFF  00,638
....................       cosNew = ads_read_data(ch*2+1);      
04758:  BCF    FD8.0
0475A:  MOVLB  1
0475C:  RLCF   xB1,W
0475E:  ADDLW  01
04760:  MOVLB  6
04762:  MOVWF  x40
04764:  MOVWF  x41
04766:  MOVLB  0
04768:  CALL   16F2
0476C:  MOVFF  03,63F
04770:  MOVFF  02,63E
04774:  MOVFF  01,63D
04778:  MOVFF  00,63C
....................       
....................       iqm_ring_buffer(ch, sinNew, cosNew);
0477C:  MOVFF  1B1,640
04780:  MOVFF  63B,644
04784:  MOVFF  63A,643
04788:  MOVFF  639,642
0478C:  MOVFF  638,641
04790:  MOVFF  63F,648
04794:  MOVFF  63E,647
04798:  MOVFF  63D,646
0479C:  MOVFF  63C,645
047A0:  GOTO   1742
....................       
....................       sensor_process_data(ch);
047A4:  MOVFF  1B1,640
047A8:  GOTO   397A
....................       ch = !ch;
047AC:  MOVLB  1
047AE:  MOVF   xB1,F
047B0:  BZ    47B6
047B2:  MOVLW  00
047B4:  BRA    47B8
047B6:  MOVLW  01
047B8:  MOVWF  xB1
....................       
....................       smData[!ch].dataReady = false;
047BA:  MOVF   xB1,F
047BC:  BZ    47C2
047BE:  MOVLW  00
047C0:  BRA    47C4
047C2:  MOVLW  01
047C4:  MULLW  0D
047C6:  MOVF   FF3,W
047C8:  MOVLB  6
047CA:  CLRF   x41
047CC:  MOVWF  x40
047CE:  MOVLW  95
047D0:  ADDWF  x40,W
047D2:  MOVWF  FE9
047D4:  MOVLW  01
047D6:  ADDWFC x41,W
047D8:  MOVWF  FEA
047DA:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
047DC:  MOVLB  1
047DE:  MOVF   xB1,F
047E0:  BZ    47E6
047E2:  MOVLW  00
047E4:  BRA    47E8
047E6:  MOVLW  01
047E8:  MULLW  0D
047EA:  MOVF   FF3,W
047EC:  MOVLB  6
047EE:  CLRF   x41
047F0:  MOVWF  x40
047F2:  MOVLW  95
047F4:  ADDWF  x40,W
047F6:  MOVWF  FE9
047F8:  MOVLW  01
047FA:  ADDWFC x41,W
047FC:  MOVWF  FEA
047FE:  BCF    FEF.1
....................    }
04800:  MOVLB  0
04802:  GOTO   A846 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
007B6:  MOVLB  6
007B8:  CLRF   x38
007BA:  CLRF   x39
007BC:  CLRF   x3A
007BE:  CLRF   x3B
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
007C0:  CLRF   x3C
007C2:  MOVF   x3C,W
007C4:  SUBLW  03
007C6:  BNC   07FE
....................    {
....................       rc0=reg0config;
007C8:  MOVLW  30
007CA:  MOVWF  x38
....................       rc1=reg1config;
007CC:  MOVLW  10
007CE:  MOVWF  x39
....................       rc2=reg2config;
007D0:  MOVLW  30
007D2:  MOVWF  x3A
....................       rc3=reg3config;
007D4:  CLRF   x3B
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
007D6:  MOVFF  63C,63E
007DA:  MOVFF  638,63F
007DE:  MOVFF  639,640
007E2:  MOVFF  63A,641
007E6:  MOVFF  63B,642
007EA:  MOVLB  0
007EC:  BRA    074C
....................       delay_ms(1);
007EE:  MOVLW  01
007F0:  MOVLB  6
007F2:  MOVWF  x3E
007F4:  MOVLB  0
007F6:  RCALL  0438
007F8:  MOVLB  6
007FA:  INCF   x3C,F
007FC:  BRA    07C2
....................    }
....................    
....................    for(int8 i = 0; i < BUFFER_SIZE; i++){
007FE:  CLRF   x3D
00800:  MOVF   x3D,W
00802:  SUBLW  09
00804:  BTFSS  FD8.0
00806:  BRA    0AFC
....................       tobuff(smData[0].sinQ, 0);
00808:  MOVLB  1
0080A:  MOVFF  196,FE9
0080E:  MOVFF  197,FEA
00812:  MOVLW  02
00814:  ADDWF  FEF,W
00816:  ADDWF  x96,W
00818:  MOVWF  FE9
0081A:  MOVLW  00
0081C:  ADDWFC x97,W
0081E:  MOVWF  FEA
00820:  CLRF   FEF
00822:  MOVFF  196,63E
00826:  MOVFF  197,63F
0082A:  MOVLB  1
0082C:  MOVFF  196,FE9
00830:  MOVFF  197,FEA
00834:  MOVF   FEF,W
00836:  SUBLW  09
00838:  BNZ   083E
0083A:  MOVLW  00
0083C:  BRA    084A
0083E:  MOVFF  196,FE9
00842:  MOVFF  197,FEA
00846:  MOVLW  01
00848:  ADDWF  FEF,W
0084A:  MOVLB  6
0084C:  MOVWF  x40
0084E:  MOVFF  63F,FEA
00852:  MOVFF  63E,FE9
00856:  MOVWF  FEF
00858:  MOVLB  1
0085A:  MOVFF  196,FE9
0085E:  MOVFF  197,FEA
00862:  MOVFF  FEF,63E
00866:  MOVLW  01
00868:  ADDWF  x96,W
0086A:  MOVWF  FE9
0086C:  MOVLW  00
0086E:  ADDWFC x97,W
00870:  MOVWF  FEA
00872:  MOVF   FEF,W
00874:  MOVLB  6
00876:  SUBWF  x3E,W
00878:  BNZ   08C4
0087A:  MOVLW  01
0087C:  MOVLB  1
0087E:  ADDWF  x96,W
00880:  MOVWF  01
00882:  MOVLW  00
00884:  ADDWFC x97,W
00886:  MOVWF  03
00888:  MOVFF  01,63E
0088C:  MOVLB  6
0088E:  MOVWF  x3F
00890:  MOVLW  01
00892:  MOVLB  1
00894:  ADDWF  x96,W
00896:  MOVWF  FE9
00898:  MOVLW  00
0089A:  ADDWFC x97,W
0089C:  MOVWF  FEA
0089E:  MOVF   FEF,W
008A0:  SUBLW  09
008A2:  BNZ   08A8
008A4:  MOVLW  00
008A6:  BRA    08B8
008A8:  MOVLW  01
008AA:  ADDWF  x96,W
008AC:  MOVWF  FE9
008AE:  MOVLW  00
008B0:  ADDWFC x97,W
008B2:  MOVWF  FEA
008B4:  MOVLW  01
008B6:  ADDWF  FEF,W
008B8:  MOVLB  6
008BA:  MOVFF  63F,FEA
008BE:  MOVFF  63E,FE9
008C2:  MOVWF  FEF
....................       tobuff(smData[0].cosQ, 0);
008C4:  MOVLB  1
008C6:  MOVFF  198,FE9
008CA:  MOVFF  199,FEA
008CE:  MOVLW  02
008D0:  ADDWF  FEF,W
008D2:  ADDWF  x98,W
008D4:  MOVWF  FE9
008D6:  MOVLW  00
008D8:  ADDWFC x99,W
008DA:  MOVWF  FEA
008DC:  CLRF   FEF
008DE:  MOVFF  198,63E
008E2:  MOVFF  199,63F
008E6:  MOVLB  1
008E8:  MOVFF  198,FE9
008EC:  MOVFF  199,FEA
008F0:  MOVF   FEF,W
008F2:  SUBLW  09
008F4:  BNZ   08FA
008F6:  MOVLW  00
008F8:  BRA    0906
008FA:  MOVFF  198,FE9
008FE:  MOVFF  199,FEA
00902:  MOVLW  01
00904:  ADDWF  FEF,W
00906:  MOVLB  6
00908:  MOVWF  x40
0090A:  MOVFF  63F,FEA
0090E:  MOVFF  63E,FE9
00912:  MOVWF  FEF
00914:  MOVLB  1
00916:  MOVFF  198,FE9
0091A:  MOVFF  199,FEA
0091E:  MOVFF  FEF,63E
00922:  MOVLW  01
00924:  ADDWF  x98,W
00926:  MOVWF  FE9
00928:  MOVLW  00
0092A:  ADDWFC x99,W
0092C:  MOVWF  FEA
0092E:  MOVF   FEF,W
00930:  MOVLB  6
00932:  SUBWF  x3E,W
00934:  BNZ   0980
00936:  MOVLW  01
00938:  MOVLB  1
0093A:  ADDWF  x98,W
0093C:  MOVWF  01
0093E:  MOVLW  00
00940:  ADDWFC x99,W
00942:  MOVWF  03
00944:  MOVFF  01,63E
00948:  MOVLB  6
0094A:  MOVWF  x3F
0094C:  MOVLW  01
0094E:  MOVLB  1
00950:  ADDWF  x98,W
00952:  MOVWF  FE9
00954:  MOVLW  00
00956:  ADDWFC x99,W
00958:  MOVWF  FEA
0095A:  MOVF   FEF,W
0095C:  SUBLW  09
0095E:  BNZ   0964
00960:  MOVLW  00
00962:  BRA    0974
00964:  MOVLW  01
00966:  ADDWF  x98,W
00968:  MOVWF  FE9
0096A:  MOVLW  00
0096C:  ADDWFC x99,W
0096E:  MOVWF  FEA
00970:  MOVLW  01
00972:  ADDWF  FEF,W
00974:  MOVLB  6
00976:  MOVFF  63F,FEA
0097A:  MOVFF  63E,FE9
0097E:  MOVWF  FEF
....................       tobuff(smData[1].sinQ, 0);
00980:  MOVLB  1
00982:  MOVFF  1A3,FE9
00986:  MOVFF  1A4,FEA
0098A:  MOVLW  02
0098C:  ADDWF  FEF,W
0098E:  ADDWF  xA3,W
00990:  MOVWF  FE9
00992:  MOVLW  00
00994:  ADDWFC xA4,W
00996:  MOVWF  FEA
00998:  CLRF   FEF
0099A:  MOVFF  1A3,63E
0099E:  MOVFF  1A4,63F
009A2:  MOVLB  1
009A4:  MOVFF  1A3,FE9
009A8:  MOVFF  1A4,FEA
009AC:  MOVF   FEF,W
009AE:  SUBLW  09
009B0:  BNZ   09B6
009B2:  MOVLW  00
009B4:  BRA    09C2
009B6:  MOVFF  1A3,FE9
009BA:  MOVFF  1A4,FEA
009BE:  MOVLW  01
009C0:  ADDWF  FEF,W
009C2:  MOVLB  6
009C4:  MOVWF  x40
009C6:  MOVFF  63F,FEA
009CA:  MOVFF  63E,FE9
009CE:  MOVWF  FEF
009D0:  MOVLB  1
009D2:  MOVFF  1A3,FE9
009D6:  MOVFF  1A4,FEA
009DA:  MOVFF  FEF,63E
009DE:  MOVLW  01
009E0:  ADDWF  xA3,W
009E2:  MOVWF  FE9
009E4:  MOVLW  00
009E6:  ADDWFC xA4,W
009E8:  MOVWF  FEA
009EA:  MOVF   FEF,W
009EC:  MOVLB  6
009EE:  SUBWF  x3E,W
009F0:  BNZ   0A3C
009F2:  MOVLW  01
009F4:  MOVLB  1
009F6:  ADDWF  xA3,W
009F8:  MOVWF  01
009FA:  MOVLW  00
009FC:  ADDWFC xA4,W
009FE:  MOVWF  03
00A00:  MOVFF  01,63E
00A04:  MOVLB  6
00A06:  MOVWF  x3F
00A08:  MOVLW  01
00A0A:  MOVLB  1
00A0C:  ADDWF  xA3,W
00A0E:  MOVWF  FE9
00A10:  MOVLW  00
00A12:  ADDWFC xA4,W
00A14:  MOVWF  FEA
00A16:  MOVF   FEF,W
00A18:  SUBLW  09
00A1A:  BNZ   0A20
00A1C:  MOVLW  00
00A1E:  BRA    0A30
00A20:  MOVLW  01
00A22:  ADDWF  xA3,W
00A24:  MOVWF  FE9
00A26:  MOVLW  00
00A28:  ADDWFC xA4,W
00A2A:  MOVWF  FEA
00A2C:  MOVLW  01
00A2E:  ADDWF  FEF,W
00A30:  MOVLB  6
00A32:  MOVFF  63F,FEA
00A36:  MOVFF  63E,FE9
00A3A:  MOVWF  FEF
....................       tobuff(smData[1].cosQ, 0);      
00A3C:  MOVLB  1
00A3E:  MOVFF  1A5,FE9
00A42:  MOVFF  1A6,FEA
00A46:  MOVLW  02
00A48:  ADDWF  FEF,W
00A4A:  ADDWF  xA5,W
00A4C:  MOVWF  FE9
00A4E:  MOVLW  00
00A50:  ADDWFC xA6,W
00A52:  MOVWF  FEA
00A54:  CLRF   FEF
00A56:  MOVFF  1A5,63E
00A5A:  MOVFF  1A6,63F
00A5E:  MOVLB  1
00A60:  MOVFF  1A5,FE9
00A64:  MOVFF  1A6,FEA
00A68:  MOVF   FEF,W
00A6A:  SUBLW  09
00A6C:  BNZ   0A72
00A6E:  MOVLW  00
00A70:  BRA    0A7E
00A72:  MOVFF  1A5,FE9
00A76:  MOVFF  1A6,FEA
00A7A:  MOVLW  01
00A7C:  ADDWF  FEF,W
00A7E:  MOVLB  6
00A80:  MOVWF  x40
00A82:  MOVFF  63F,FEA
00A86:  MOVFF  63E,FE9
00A8A:  MOVWF  FEF
00A8C:  MOVLB  1
00A8E:  MOVFF  1A5,FE9
00A92:  MOVFF  1A6,FEA
00A96:  MOVFF  FEF,63E
00A9A:  MOVLW  01
00A9C:  ADDWF  xA5,W
00A9E:  MOVWF  FE9
00AA0:  MOVLW  00
00AA2:  ADDWFC xA6,W
00AA4:  MOVWF  FEA
00AA6:  MOVF   FEF,W
00AA8:  MOVLB  6
00AAA:  SUBWF  x3E,W
00AAC:  BNZ   0AF8
00AAE:  MOVLW  01
00AB0:  MOVLB  1
00AB2:  ADDWF  xA5,W
00AB4:  MOVWF  01
00AB6:  MOVLW  00
00AB8:  ADDWFC xA6,W
00ABA:  MOVWF  03
00ABC:  MOVFF  01,63E
00AC0:  MOVLB  6
00AC2:  MOVWF  x3F
00AC4:  MOVLW  01
00AC6:  MOVLB  1
00AC8:  ADDWF  xA5,W
00ACA:  MOVWF  FE9
00ACC:  MOVLW  00
00ACE:  ADDWFC xA6,W
00AD0:  MOVWF  FEA
00AD2:  MOVF   FEF,W
00AD4:  SUBLW  09
00AD6:  BNZ   0ADC
00AD8:  MOVLW  00
00ADA:  BRA    0AEC
00ADC:  MOVLW  01
00ADE:  ADDWF  xA5,W
00AE0:  MOVWF  FE9
00AE2:  MOVLW  00
00AE4:  ADDWFC xA6,W
00AE6:  MOVWF  FEA
00AE8:  MOVLW  01
00AEA:  ADDWF  FEF,W
00AEC:  MOVLB  6
00AEE:  MOVFF  63F,FEA
00AF2:  MOVFF  63E,FE9
00AF6:  MOVWF  FEF
00AF8:  INCF   x3D,F
00AFA:  BRA    0800
....................    }
00AFC:  MOVLB  0
00AFE:  GOTO   0B62 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00B02:  MOVLW  00
00B04:  MOVLB  F
00B06:  MOVWF  x53
00B08:  MOVLW  40
00B0A:  MOVWF  x0C
00B0C:  MOVLW  00
00B0E:  MOVWF  x14
00B10:  MOVLW  03
00B12:  MOVWF  x1C
00B14:  MOVLW  0F
00B16:  MOVWF  x21
00B18:  MOVLW  00
00B1A:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00B1C:  MOVLW  08
00B1E:  MOVWF  x55
00B20:  CLRF   x56
00B22:  CLRF   x52
00B24:  SETF   x57
00B26:  CLRF   F61
00B28:  MOVLW  94
00B2A:  MOVWF  x5B
....................    output_high(EN_EXC);
00B2C:  MOVLW  E8
00B2E:  MOVWF  F8B
00B30:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B32:  MOVF   x5A,W
00B34:  ANDLW  3F
00B36:  MOVWF  01
00B38:  MOVLW  06
00B3A:  MOVWF  x5A
00B3C:  BTFSS  x5B.7
00B3E:  BRA    0B4E
00B40:  MOVF   01,W
00B42:  SUBLW  06
00B44:  BZ    0B4E
00B46:  BSF    x5B.0
00B48:  NOP   
00B4A:  BTFSC  x5B.0
00B4C:  BRA    0B4A
....................    delay_ms(10);
00B4E:  MOVLW  0A
00B50:  MOVLB  6
00B52:  MOVWF  x3E
00B54:  MOVLB  0
00B56:  RCALL  0438
....................    read_adc(ADC_START_ONLY);
00B58:  MOVLB  F
00B5A:  BSF    x5B.0
00B5C:  NOP   
....................    setup_external_ADCs();
00B5E:  MOVLB  0
00B60:  BRA    07B6
....................    intTimeoutReg = sensorSampleRate;
00B62:  MOVLB  1
00B64:  CLRF   x64
00B66:  MOVLW  32
00B68:  MOVWF  x63
00B6A:  MOVLB  0
00B6C:  GOTO   A82E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
048E0:  MOVLB  6
048E2:  MOVF   x3C,W
048E4:  MULLW  20
048E6:  MOVF   FF3,W
048E8:  CLRF   x4A
048EA:  MOVWF  x49
048EC:  MOVLW  0C
048EE:  ADDWF  x49,W
048F0:  MOVWF  01
048F2:  MOVLW  00
048F4:  ADDWFC x4A,W
048F6:  MOVWF  03
048F8:  MOVF   01,W
048FA:  ADDLW  20
048FC:  MOVWF  FE9
048FE:  MOVLW  00
04900:  ADDWFC 03,W
04902:  MOVWF  FEA
04904:  MOVFF  FEF,687
04908:  MOVFF  FEC,688
0490C:  MOVFF  FEC,689
04910:  MOVFF  FEC,68A
04914:  MOVF   x3C,W
04916:  MULLW  20
04918:  MOVF   FF3,W
0491A:  CLRF   x4E
0491C:  MOVWF  x4D
0491E:  MOVLW  10
04920:  ADDWF  x4D,W
04922:  MOVWF  01
04924:  MOVLW  00
04926:  ADDWFC x4E,W
04928:  MOVWF  03
0492A:  MOVF   01,W
0492C:  ADDLW  20
0492E:  MOVWF  FE9
04930:  MOVLW  00
04932:  ADDWFC 03,W
04934:  MOVWF  FEA
04936:  MOVFF  FEF,68B
0493A:  MOVFF  FEC,01
0493E:  MOVFF  FEC,02
04942:  MOVFF  FEC,03
04946:  MOVFF  FEA,64E
0494A:  MOVFF  FE9,64D
0494E:  BSF    FD8.1
04950:  MOVFF  03,68E
04954:  MOVFF  02,68D
04958:  MOVFF  01,68C
0495C:  MOVLB  0
0495E:  CALL   0EE2
04962:  MOVFF  64E,FEA
04966:  MOVFF  64D,FE9
0496A:  MOVFF  03,640
0496E:  MOVFF  02,63F
04972:  MOVFF  01,63E
04976:  MOVFF  00,63D
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
0497A:  MOVLB  6
0497C:  MOVF   x3C,W
0497E:  MULLW  20
04980:  MOVF   FF3,W
04982:  CLRF   x4A
04984:  MOVWF  x49
04986:  MOVLW  1C
04988:  ADDWF  x49,W
0498A:  MOVWF  01
0498C:  MOVLW  00
0498E:  ADDWFC x4A,W
04990:  MOVWF  03
04992:  MOVF   01,W
04994:  ADDLW  20
04996:  MOVWF  01
04998:  MOVLW  00
0499A:  ADDWFC 03,F
0499C:  MOVFF  01,649
049A0:  MOVFF  03,64A
049A4:  MOVFF  03,FEA
049A8:  MOVFF  01,FE9
049AC:  MOVFF  FEF,64B
049B0:  MOVFF  FEC,64C
049B4:  MOVFF  FEC,64D
049B8:  MOVFF  FEC,64E
049BC:  MOVF   x3C,W
049BE:  MULLW  20
049C0:  MOVF   FF3,W
049C2:  CLRF   x50
049C4:  MOVWF  x4F
049C6:  MOVLW  04
049C8:  ADDWF  x4F,W
049CA:  MOVWF  01
049CC:  MOVLW  00
049CE:  ADDWFC x50,W
049D0:  MOVWF  03
049D2:  MOVF   01,W
049D4:  ADDLW  20
049D6:  MOVWF  FE9
049D8:  MOVLW  00
049DA:  ADDWFC 03,W
049DC:  MOVWF  FEA
049DE:  MOVFF  FEF,68C
049E2:  MOVFF  FEC,01
049E6:  MOVFF  FEC,02
049EA:  MOVFF  FEC,03
049EE:  MOVFF  640,68B
049F2:  MOVFF  63F,68A
049F6:  MOVFF  63E,689
049FA:  MOVFF  63D,688
049FE:  MOVFF  03,68F
04A02:  MOVFF  02,68E
04A06:  MOVFF  01,68D
04A0A:  MOVLB  0
04A0C:  CALL   0DEC
04A10:  BCF    FD8.1
04A12:  MOVFF  64E,68A
04A16:  MOVFF  64D,689
04A1A:  MOVFF  64C,688
04A1E:  MOVFF  64B,687
04A22:  MOVFF  03,68E
04A26:  MOVFF  02,68D
04A2A:  MOVFF  01,68C
04A2E:  MOVFF  00,68B
04A32:  CALL   0EE2
04A36:  MOVFF  64A,FEA
04A3A:  MOVFF  649,FE9
04A3E:  MOVFF  00,FEF
04A42:  MOVFF  01,FEC
04A46:  MOVFF  02,FEC
04A4A:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
04A4E:  MOVLB  6
04A50:  MOVF   x3C,W
04A52:  MULLW  20
04A54:  MOVF   FF3,W
04A56:  CLRF   x4A
04A58:  MOVWF  x49
04A5A:  MOVLW  1C
04A5C:  ADDWF  x49,W
04A5E:  MOVWF  01
04A60:  MOVLW  00
04A62:  ADDWFC x4A,W
04A64:  MOVWF  03
04A66:  MOVF   01,W
04A68:  ADDLW  20
04A6A:  MOVWF  FE9
04A6C:  MOVLW  00
04A6E:  ADDWFC 03,W
04A70:  MOVWF  FEA
04A72:  MOVFF  FEF,687
04A76:  MOVFF  FEC,64A
04A7A:  MOVFF  FEC,689
04A7E:  MOVFF  FEC,68A
04A82:  CLRF   x86
04A84:  CLRF   x85
04A86:  MOVLW  7C
04A88:  MOVWF  x84
04A8A:  MOVLW  84
04A8C:  MOVWF  x83
04A8E:  MOVFF  64A,688
04A92:  MOVLB  0
04A94:  CALL   1F9A
04A98:  BNC   4ACC
04A9A:  MOVLB  6
04A9C:  MOVF   x3C,W
04A9E:  MULLW  20
04AA0:  MOVF   FF3,W
04AA2:  CLRF   x4A
04AA4:  MOVWF  x49
04AA6:  MOVLW  1C
04AA8:  ADDWF  x49,W
04AAA:  MOVWF  01
04AAC:  MOVLW  00
04AAE:  ADDWFC x4A,W
04AB0:  MOVWF  03
04AB2:  MOVF   01,W
04AB4:  ADDLW  20
04AB6:  MOVWF  FE9
04AB8:  MOVLW  00
04ABA:  ADDWFC 03,W
04ABC:  MOVWF  FEA
04ABE:  MOVLW  84
04AC0:  MOVWF  FEF
04AC2:  MOVLW  7C
04AC4:  MOVWF  FEC
04AC6:  CLRF   FEC
04AC8:  CLRF   FEC
04ACA:  BRA    4B48
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
04ACC:  MOVLB  6
04ACE:  MOVF   x3C,W
04AD0:  MULLW  20
04AD2:  MOVF   FF3,W
04AD4:  CLRF   x4A
04AD6:  MOVWF  x49
04AD8:  MOVLW  1C
04ADA:  ADDWF  x49,W
04ADC:  MOVWF  01
04ADE:  MOVLW  00
04AE0:  ADDWFC x4A,W
04AE2:  MOVWF  03
04AE4:  MOVF   01,W
04AE6:  ADDLW  20
04AE8:  MOVWF  FE9
04AEA:  MOVLW  00
04AEC:  ADDWFC 03,W
04AEE:  MOVWF  FEA
04AF0:  MOVFF  FEF,683
04AF4:  MOVFF  FEC,64A
04AF8:  MOVFF  FEC,685
04AFC:  MOVFF  FEC,686
04B00:  MOVFF  64A,684
04B04:  CLRF   x8A
04B06:  CLRF   x89
04B08:  MOVLW  FC
04B0A:  MOVWF  x88
04B0C:  MOVLW  84
04B0E:  MOVWF  x87
04B10:  MOVLB  0
04B12:  CALL   1F9A
04B16:  BNC   4B4A
04B18:  MOVLB  6
04B1A:  MOVF   x3C,W
04B1C:  MULLW  20
04B1E:  MOVF   FF3,W
04B20:  CLRF   x4A
04B22:  MOVWF  x49
04B24:  MOVLW  1C
04B26:  ADDWF  x49,W
04B28:  MOVWF  01
04B2A:  MOVLW  00
04B2C:  ADDWFC x4A,W
04B2E:  MOVWF  03
04B30:  MOVF   01,W
04B32:  ADDLW  20
04B34:  MOVWF  FE9
04B36:  MOVLW  00
04B38:  ADDWFC 03,W
04B3A:  MOVWF  FEA
04B3C:  MOVLW  84
04B3E:  MOVWF  FEF
04B40:  MOVLW  FC
04B42:  MOVWF  FEC
04B44:  CLRF   FEC
04B46:  CLRF   FEC
04B48:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04B4A:  MOVLB  6
04B4C:  MOVF   x3C,W
04B4E:  MULLW  20
04B50:  MOVF   FF3,W
04B52:  CLRF   x4A
04B54:  MOVWF  x49
04B56:  MOVLW  20
04B58:  ADDWF  x49,W
04B5A:  MOVWF  FE9
04B5C:  MOVLW  00
04B5E:  ADDWFC x4A,W
04B60:  MOVWF  FEA
04B62:  MOVFF  FEF,68C
04B66:  MOVFF  FEC,01
04B6A:  MOVFF  FEC,02
04B6E:  MOVFF  FEC,03
04B72:  MOVFF  640,68B
04B76:  MOVFF  63F,68A
04B7A:  MOVFF  63E,689
04B7E:  MOVFF  63D,688
04B82:  MOVFF  03,68F
04B86:  MOVFF  02,68E
04B8A:  MOVFF  01,68D
04B8E:  MOVLB  0
04B90:  CALL   0DEC
04B94:  MOVFF  03,644
04B98:  MOVFF  02,643
04B9C:  MOVFF  01,642
04BA0:  MOVFF  00,641
04BA4:  MOVLB  6
04BA6:  MOVF   x3C,W
04BA8:  MULLW  20
04BAA:  MOVF   FF3,W
04BAC:  CLRF   x4C
04BAE:  MOVWF  x4B
04BB0:  MOVLW  08
04BB2:  ADDWF  x4B,W
04BB4:  MOVWF  01
04BB6:  MOVLW  00
04BB8:  ADDWFC x4C,W
04BBA:  MOVWF  03
04BBC:  MOVF   01,W
04BBE:  ADDLW  20
04BC0:  MOVWF  FE9
04BC2:  MOVLW  00
04BC4:  ADDWFC 03,W
04BC6:  MOVWF  FEA
04BC8:  MOVFF  FEF,64B
04BCC:  MOVFF  FEC,64C
04BD0:  MOVFF  FEC,64D
04BD4:  MOVFF  FEC,64E
04BD8:  MOVF   x3C,W
04BDA:  MULLW  20
04BDC:  MOVF   FF3,W
04BDE:  CLRF   x50
04BE0:  MOVWF  x4F
04BE2:  MOVLW  10
04BE4:  ADDWF  x4F,W
04BE6:  MOVWF  01
04BE8:  MOVLW  00
04BEA:  ADDWFC x50,W
04BEC:  MOVWF  03
04BEE:  MOVF   01,W
04BF0:  ADDLW  20
04BF2:  MOVWF  FE9
04BF4:  MOVLW  00
04BF6:  ADDWFC 03,W
04BF8:  MOVWF  FEA
04BFA:  MOVFF  FEF,687
04BFE:  MOVFF  FEC,688
04C02:  MOVFF  FEC,689
04C06:  MOVFF  FEC,68A
04C0A:  MOVF   x3C,W
04C0C:  MULLW  20
04C0E:  MOVF   FF3,W
04C10:  CLRF   x54
04C12:  MOVWF  x53
04C14:  MOVLW  14
04C16:  ADDWF  x53,W
04C18:  MOVWF  01
04C1A:  MOVLW  00
04C1C:  ADDWFC x54,W
04C1E:  MOVWF  03
04C20:  MOVF   01,W
04C22:  ADDLW  20
04C24:  MOVWF  FE9
04C26:  MOVLW  00
04C28:  ADDWFC 03,W
04C2A:  MOVWF  FEA
04C2C:  MOVFF  FEF,68B
04C30:  MOVFF  FEC,01
04C34:  MOVFF  FEC,02
04C38:  MOVFF  FEC,03
04C3C:  MOVFF  FEA,654
04C40:  MOVFF  FE9,653
04C44:  BSF    FD8.1
04C46:  MOVFF  03,68E
04C4A:  MOVFF  02,68D
04C4E:  MOVFF  01,68C
04C52:  MOVLB  0
04C54:  CALL   0EE2
04C58:  MOVFF  654,FEA
04C5C:  MOVFF  653,FE9
04C60:  MOVFF  64E,68B
04C64:  MOVFF  64D,68A
04C68:  MOVFF  64C,689
04C6C:  MOVFF  64B,688
04C70:  MOVFF  03,68F
04C74:  MOVFF  02,68E
04C78:  MOVFF  01,68D
04C7C:  MOVFF  00,68C
04C80:  CALL   0DEC
04C84:  MOVFF  03,648
04C88:  MOVFF  02,647
04C8C:  MOVFF  01,646
04C90:  MOVFF  00,645
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04C94:  MOVLB  6
04C96:  MOVF   x3C,W
04C98:  MULLW  20
04C9A:  MOVF   FF3,W
04C9C:  CLRF   x4A
04C9E:  MOVWF  x49
04CA0:  MOVLW  18
04CA2:  ADDWF  x49,W
04CA4:  MOVWF  01
04CA6:  MOVLW  00
04CA8:  ADDWFC x4A,W
04CAA:  MOVWF  03
04CAC:  MOVF   01,W
04CAE:  ADDLW  20
04CB0:  MOVWF  01
04CB2:  MOVLW  00
04CB4:  ADDWFC 03,F
04CB6:  MOVFF  01,649
04CBA:  MOVFF  03,64A
04CBE:  MOVF   x3C,W
04CC0:  MULLW  20
04CC2:  MOVF   FF3,W
04CC4:  CLRF   x4C
04CC6:  MOVWF  x4B
04CC8:  MOVLW  1C
04CCA:  ADDWF  x4B,W
04CCC:  MOVWF  01
04CCE:  MOVLW  00
04CD0:  ADDWFC x4C,W
04CD2:  MOVWF  03
04CD4:  MOVF   01,W
04CD6:  ADDLW  20
04CD8:  MOVWF  FE9
04CDA:  MOVLW  00
04CDC:  ADDWFC 03,W
04CDE:  MOVWF  FEA
04CE0:  MOVFF  FEF,68B
04CE4:  MOVFF  FEC,01
04CE8:  MOVFF  FEC,02
04CEC:  MOVFF  FEC,03
04CF0:  MOVFF  FEA,64C
04CF4:  MOVFF  FE9,64B
04CF8:  BCF    FD8.1
04CFA:  MOVFF  644,68A
04CFE:  MOVFF  643,689
04D02:  MOVFF  642,688
04D06:  MOVFF  641,687
04D0A:  MOVFF  03,68E
04D0E:  MOVFF  02,68D
04D12:  MOVFF  01,68C
04D16:  MOVLB  0
04D18:  CALL   0EE2
04D1C:  MOVFF  64C,FEA
04D20:  MOVFF  64B,FE9
04D24:  MOVFF  03,650
04D28:  MOVFF  02,64F
04D2C:  MOVFF  01,64E
04D30:  MOVFF  00,64D
04D34:  BCF    FD8.1
04D36:  MOVFF  03,68A
04D3A:  MOVFF  02,689
04D3E:  MOVFF  01,688
04D42:  MOVFF  00,687
04D46:  MOVFF  648,68E
04D4A:  MOVFF  647,68D
04D4E:  MOVFF  646,68C
04D52:  MOVFF  645,68B
04D56:  CALL   0EE2
04D5A:  MOVFF  64A,FEA
04D5E:  MOVFF  649,FE9
04D62:  MOVFF  00,FEF
04D66:  MOVFF  01,FEC
04D6A:  MOVFF  02,FEC
04D6E:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04D72:  MOVLB  6
04D74:  MOVF   x3C,W
04D76:  MULLW  20
04D78:  MOVF   FF3,W
04D7A:  CLRF   x4A
04D7C:  MOVWF  x49
04D7E:  MOVLW  18
04D80:  ADDWF  x49,W
04D82:  MOVWF  01
04D84:  MOVLW  00
04D86:  ADDWFC x4A,W
04D88:  MOVWF  03
04D8A:  MOVF   01,W
04D8C:  ADDLW  20
04D8E:  MOVWF  FE9
04D90:  MOVLW  00
04D92:  ADDWFC 03,W
04D94:  MOVWF  FEA
04D96:  MOVFF  FEF,687
04D9A:  MOVFF  FEC,64A
04D9E:  MOVFF  FEC,689
04DA2:  MOVFF  FEC,68A
04DA6:  CLRF   x86
04DA8:  CLRF   x85
04DAA:  MOVLW  7C
04DAC:  MOVWF  x84
04DAE:  MOVLW  84
04DB0:  MOVWF  x83
04DB2:  MOVFF  64A,688
04DB6:  MOVLB  0
04DB8:  CALL   1F9A
04DBC:  BNC   4DF0
04DBE:  MOVLB  6
04DC0:  MOVF   x3C,W
04DC2:  MULLW  20
04DC4:  MOVF   FF3,W
04DC6:  CLRF   x4A
04DC8:  MOVWF  x49
04DCA:  MOVLW  18
04DCC:  ADDWF  x49,W
04DCE:  MOVWF  01
04DD0:  MOVLW  00
04DD2:  ADDWFC x4A,W
04DD4:  MOVWF  03
04DD6:  MOVF   01,W
04DD8:  ADDLW  20
04DDA:  MOVWF  FE9
04DDC:  MOVLW  00
04DDE:  ADDWFC 03,W
04DE0:  MOVWF  FEA
04DE2:  MOVLW  84
04DE4:  MOVWF  FEF
04DE6:  MOVLW  7C
04DE8:  MOVWF  FEC
04DEA:  CLRF   FEC
04DEC:  CLRF   FEC
04DEE:  BRA    4E6C
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04DF0:  MOVLB  6
04DF2:  MOVF   x3C,W
04DF4:  MULLW  20
04DF6:  MOVF   FF3,W
04DF8:  CLRF   x4A
04DFA:  MOVWF  x49
04DFC:  MOVLW  18
04DFE:  ADDWF  x49,W
04E00:  MOVWF  01
04E02:  MOVLW  00
04E04:  ADDWFC x4A,W
04E06:  MOVWF  03
04E08:  MOVF   01,W
04E0A:  ADDLW  20
04E0C:  MOVWF  FE9
04E0E:  MOVLW  00
04E10:  ADDWFC 03,W
04E12:  MOVWF  FEA
04E14:  MOVFF  FEF,683
04E18:  MOVFF  FEC,64A
04E1C:  MOVFF  FEC,685
04E20:  MOVFF  FEC,686
04E24:  MOVFF  64A,684
04E28:  CLRF   x8A
04E2A:  CLRF   x89
04E2C:  MOVLW  FC
04E2E:  MOVWF  x88
04E30:  MOVLW  84
04E32:  MOVWF  x87
04E34:  MOVLB  0
04E36:  CALL   1F9A
04E3A:  BNC   4E6C
04E3C:  MOVLB  6
04E3E:  MOVF   x3C,W
04E40:  MULLW  20
04E42:  MOVF   FF3,W
04E44:  CLRF   x4A
04E46:  MOVWF  x49
04E48:  MOVLW  18
04E4A:  ADDWF  x49,W
04E4C:  MOVWF  01
04E4E:  MOVLW  00
04E50:  ADDWFC x4A,W
04E52:  MOVWF  03
04E54:  MOVF   01,W
04E56:  ADDLW  20
04E58:  MOVWF  FE9
04E5A:  MOVLW  00
04E5C:  ADDWFC 03,W
04E5E:  MOVWF  FEA
04E60:  MOVLW  84
04E62:  MOVWF  FEF
04E64:  MOVLW  FC
04E66:  MOVWF  FEC
04E68:  CLRF   FEC
04E6A:  CLRF   FEC
04E6C:  MOVLB  0
04E6E:  GOTO   4EE6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04E72:  MOVLB  6
04E74:  MOVF   x3B,W
04E76:  MULLW  20
04E78:  MOVF   FF3,W
04E7A:  CLRF   x3D
04E7C:  MOVWF  x3C
04E7E:  MOVLW  0C
04E80:  ADDWF  x3C,W
04E82:  MOVWF  01
04E84:  MOVLW  00
04E86:  ADDWFC x3D,W
04E88:  MOVWF  03
04E8A:  MOVF   01,W
04E8C:  ADDLW  20
04E8E:  MOVWF  FE9
04E90:  MOVLW  00
04E92:  ADDWFC 03,W
04E94:  MOVWF  FEA
04E96:  MOVFF  FEF,683
04E9A:  MOVFF  FEC,684
04E9E:  MOVFF  FEC,685
04EA2:  MOVFF  FEC,686
04EA6:  MOVF   x3B,W
04EA8:  MULLW  20
04EAA:  MOVF   FF3,W
04EAC:  CLRF   x41
04EAE:  MOVWF  x40
04EB0:  MOVLW  10
04EB2:  ADDWF  x40,W
04EB4:  MOVWF  01
04EB6:  MOVLW  00
04EB8:  ADDWFC x41,W
04EBA:  MOVWF  03
04EBC:  MOVF   01,W
04EBE:  ADDLW  20
04EC0:  MOVWF  FE9
04EC2:  MOVLW  00
04EC4:  ADDWFC 03,W
04EC6:  MOVWF  FEA
04EC8:  MOVFF  FEF,687
04ECC:  MOVFF  FEC,688
04ED0:  MOVFF  FEC,689
04ED4:  MOVFF  FEC,68A
04ED8:  MOVLB  0
04EDA:  CALL   1F9A
04EDE:  BZ    4EE6
04EE0:  MOVFF  63B,63C
04EE4:  BRA    48E0
....................    if ((index++) >= numChannels) index = 0;
04EE6:  MOVLB  1
04EE8:  MOVF   xB2,W
04EEA:  INCF   xB2,F
04EEC:  SUBLW  01
04EEE:  BC    4EF2
04EF0:  CLRF   xB2
04EF2:  MOVLB  0
04EF4:  GOTO   4FE0 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B70:  CLRF   03
00B72:  MOVF   F91,W
00B74:  MOVFF  63D,F91
00B78:  RRCF   F94,W
00B7A:  BNC   0B78
00B7C:  MOVF   F91,W
00B7E:  MOVWF  02
00B80:  MOVFF  63C,F91
00B84:  RRCF   F94,W
00B86:  BNC   0B84
00B88:  MOVF   F91,W
00B8A:  MOVWF  01
00B8C:  MOVFF  63B,F91
00B90:  RRCF   F94,W
00B92:  BNC   0B90
00B94:  MOVFF  F91,00
00B98:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
0483C:  MOVLB  6
0483E:  MOVF   x3C,F
04840:  BZ    4890
....................       if (chMap[0] == ch) output_low(INV_HVX);
04842:  MOVLW  00
04844:  MOVLB  0
04846:  BTFSC  x60.0
04848:  MOVLW  01
0484A:  MOVLB  6
0484C:  SUBWF  x3B,W
0484E:  BNZ   4856
04850:  MOVLW  C4
04852:  MOVWF  F88
04854:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
04856:  MOVLW  00
04858:  MOVLB  0
0485A:  BTFSC  x60.1
0485C:  MOVLW  01
0485E:  MOVLB  6
04860:  SUBWF  x3B,W
04862:  BNZ   486A
04864:  MOVLW  C4
04866:  MOVWF  F88
04868:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
0486A:  MOVF   x3B,W
0486C:  MULLW  03
0486E:  MOVF   FF3,W
04870:  CLRF   x3E
04872:  MOVWF  x3D
04874:  MOVLW  02
04876:  ADDWF  x3D,W
04878:  MOVWF  01
0487A:  MOVLW  00
0487C:  ADDWFC x3E,W
0487E:  MOVWF  03
04880:  MOVF   01,W
04882:  ADDLW  51
04884:  MOVWF  FE9
04886:  MOVLW  01
04888:  ADDWFC 03,W
0488A:  MOVWF  FEA
0488C:  BSF    FEF.0
....................    }
0488E:  BRA    48DC
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
04890:  MOVLW  00
04892:  MOVLB  0
04894:  BTFSC  x60.0
04896:  MOVLW  01
04898:  MOVLB  6
0489A:  SUBWF  x3B,W
0489C:  BNZ   48A4
0489E:  MOVLW  C4
048A0:  MOVWF  F88
048A2:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
048A4:  MOVLW  00
048A6:  MOVLB  0
048A8:  BTFSC  x60.1
048AA:  MOVLW  01
048AC:  MOVLB  6
048AE:  SUBWF  x3B,W
048B0:  BNZ   48B8
048B2:  MOVLW  C4
048B4:  MOVWF  F88
048B6:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
048B8:  MOVF   x3B,W
048BA:  MULLW  03
048BC:  MOVF   FF3,W
048BE:  CLRF   x3E
048C0:  MOVWF  x3D
048C2:  MOVLW  02
048C4:  ADDWF  x3D,W
048C6:  MOVWF  01
048C8:  MOVLW  00
048CA:  ADDWFC x3E,W
048CC:  MOVWF  03
048CE:  MOVF   01,W
048D0:  ADDLW  51
048D2:  MOVWF  FE9
048D4:  MOVLW  01
048D6:  ADDWFC 03,W
048D8:  MOVWF  FEA
048DA:  BCF    FEF.0
....................    }
048DC:  MOVLB  0
048DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04EF8:  MOVLB  6
04EFA:  CLRF   x3A
04EFC:  CLRF   x39
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04EFE:  MOVFF  638,645
04F02:  CLRF   x47
04F04:  MOVLW  61
04F06:  MOVWF  x46
04F08:  MOVLB  0
04F0A:  RCALL  4806
04F0C:  MOVF   01,F
04F0E:  BNZ   4FDA
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04F10:  MOVLB  6
04F12:  MOVF   x38,W
04F14:  MULLW  04
04F16:  MOVF   FF3,W
04F18:  CLRF   03
04F1A:  ADDLW  EA
04F1C:  MOVWF  FE9
04F1E:  MOVLW  00
04F20:  ADDWFC 03,W
04F22:  MOVWF  FEA
04F24:  MOVFF  FEF,683
04F28:  MOVFF  FEC,684
04F2C:  MOVFF  FEC,685
04F30:  MOVFF  FEC,686
04F34:  CLRF   x8A
04F36:  CLRF   x89
04F38:  CLRF   x88
04F3A:  CLRF   x87
04F3C:  MOVLB  0
04F3E:  CALL   1F9A
04F42:  BNC   4F54
04F44:  MOVFF  638,63B
04F48:  MOVLW  01
04F4A:  MOVLB  6
04F4C:  MOVWF  x3C
04F4E:  MOVLB  0
04F50:  RCALL  483C
04F52:  BRA    4F60
....................       else                             invert_voltage(ch, FALSE);
04F54:  MOVFF  638,63B
04F58:  MOVLB  6
04F5A:  CLRF   x3C
04F5C:  MOVLB  0
04F5E:  RCALL  483C
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04F60:  MOVLB  6
04F62:  MOVF   x38,W
04F64:  MULLW  04
04F66:  MOVF   FF3,W
04F68:  CLRF   03
04F6A:  ADDLW  EA
04F6C:  MOVWF  FE9
04F6E:  MOVLW  00
04F70:  ADDWFC 03,W
04F72:  MOVWF  FEA
04F74:  MOVFF  FEF,00
04F78:  MOVFF  FEC,01
04F7C:  MOVFF  FEC,02
04F80:  MOVFF  FEC,03
04F84:  BCF    01.7
04F86:  MOVFF  03,63E
04F8A:  MOVFF  02,63D
04F8E:  MOVFF  01,63C
04F92:  MOVFF  00,63B
04F96:  MOVFF  03,68B
04F9A:  MOVFF  02,68A
04F9E:  MOVFF  01,689
04FA2:  MOVFF  00,688
04FA6:  MOVLW  66
04FA8:  MOVWF  x8F
04FAA:  MOVLW  D6
04FAC:  MOVWF  x8E
04FAE:  MOVLW  23
04FB0:  MOVWF  x8D
04FB2:  MOVLW  88
04FB4:  MOVWF  x8C
04FB6:  MOVLB  0
04FB8:  CALL   0DEC
04FBC:  MOVFF  03,686
04FC0:  MOVFF  02,685
04FC4:  MOVFF  01,684
04FC8:  MOVFF  00,683
04FCC:  CALL   298E
04FD0:  MOVFF  02,63A
04FD4:  MOVFF  01,639
....................    }
04FD8:  BRA    50CA
....................    else {
....................       pid_task(ch);
04FDA:  MOVFF  638,63B
04FDE:  BRA    4E72
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04FE0:  MOVLB  6
04FE2:  MOVF   x38,W
04FE4:  MULLW  20
04FE6:  MOVF   FF3,W
04FE8:  CLRF   x3C
04FEA:  MOVWF  x3B
04FEC:  MOVLW  18
04FEE:  ADDWF  x3B,W
04FF0:  MOVWF  01
04FF2:  MOVLW  00
04FF4:  ADDWFC x3C,W
04FF6:  MOVWF  03
04FF8:  MOVF   01,W
04FFA:  ADDLW  20
04FFC:  MOVWF  FE9
04FFE:  MOVLW  00
05000:  ADDWFC 03,W
05002:  MOVWF  FEA
05004:  MOVFF  FEF,683
05008:  MOVFF  FEC,684
0500C:  MOVFF  FEC,685
05010:  MOVFF  FEC,686
05014:  CLRF   x8A
05016:  CLRF   x89
05018:  CLRF   x88
0501A:  CLRF   x87
0501C:  MOVLB  0
0501E:  CALL   1F9A
05022:  BNC   5034
05024:  MOVFF  638,63B
05028:  MOVLW  01
0502A:  MOVLB  6
0502C:  MOVWF  x3C
0502E:  MOVLB  0
05030:  RCALL  483C
05032:  BRA    5042
....................       else                       invert_voltage(ch, FALSE);
05034:  MOVFF  638,63B
05038:  MOVLB  6
0503A:  CLRF   x3C
0503C:  MOVLB  0
0503E:  CALL   483C
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
05042:  MOVLB  6
05044:  MOVF   x38,W
05046:  MULLW  20
05048:  MOVF   FF3,W
0504A:  CLRF   x3C
0504C:  MOVWF  x3B
0504E:  MOVLW  18
05050:  ADDWF  x3B,W
05052:  MOVWF  01
05054:  MOVLW  00
05056:  ADDWFC x3C,W
05058:  MOVWF  03
0505A:  MOVF   01,W
0505C:  ADDLW  20
0505E:  MOVWF  FE9
05060:  MOVLW  00
05062:  ADDWFC 03,W
05064:  MOVWF  FEA
05066:  MOVFF  FEF,00
0506A:  MOVFF  FEC,01
0506E:  MOVFF  FEC,02
05072:  MOVFF  FEC,03
05076:  BCF    01.7
05078:  MOVFF  03,63E
0507C:  MOVFF  02,63D
05080:  MOVFF  01,63C
05084:  MOVFF  00,63B
05088:  MOVFF  03,68B
0508C:  MOVFF  02,68A
05090:  MOVFF  01,689
05094:  MOVFF  00,688
05098:  MOVLW  66
0509A:  MOVWF  x8F
0509C:  MOVLW  D6
0509E:  MOVWF  x8E
050A0:  MOVLW  23
050A2:  MOVWF  x8D
050A4:  MOVLW  88
050A6:  MOVWF  x8C
050A8:  MOVLB  0
050AA:  CALL   0DEC
050AE:  MOVFF  03,686
050B2:  MOVFF  02,685
050B6:  MOVFF  01,684
050BA:  MOVFF  00,683
050BE:  CALL   298E
050C2:  MOVFF  02,63A
050C6:  MOVFF  01,639
....................    }
....................    
....................    dacVals[ch].val = txData;
050CA:  MOVLB  6
050CC:  MOVF   x38,W
050CE:  MULLW  03
050D0:  MOVF   FF3,W
050D2:  CLRF   x3C
050D4:  MOVWF  x3B
050D6:  MOVLW  51
050D8:  ADDWF  x3B,W
050DA:  MOVWF  FE9
050DC:  MOVLW  01
050DE:  ADDWFC x3C,W
050E0:  MOVWF  FEA
050E2:  MOVFF  63A,FEC
050E6:  MOVF   FED,F
050E8:  MOVFF  639,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
050EC:  MOVLW  00
050EE:  MOVLB  0
050F0:  BTFSC  x60.0
050F2:  MOVLW  01
050F4:  MOVLB  6
050F6:  SUBWF  x38,W
050F8:  BNZ   5100
050FA:  MOVLW  E8
050FC:  MOVWF  F8B
050FE:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
05100:  MOVLW  00
05102:  MOVLB  0
05104:  BTFSC  x60.1
05106:  MOVLW  01
05108:  MOVLB  6
0510A:  SUBWF  x38,W
0510C:  BNZ   5114
0510E:  MOVLW  E8
05110:  MOVWF  F8B
05112:  BSF    F86.1
....................    
....................    delay_ms(1);
05114:  MOVLW  01
05116:  MOVWF  x3E
05118:  MOVLB  0
0511A:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
0511E:  MOVLW  00
05120:  BTFSC  x60.0
05122:  MOVLW  01
05124:  MOVLB  6
05126:  SUBWF  x38,W
05128:  BNZ   5130
0512A:  MOVLW  E8
0512C:  MOVWF  F8B
0512E:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
05130:  MOVLW  00
05132:  MOVLB  0
05134:  BTFSC  x60.1
05136:  MOVLW  01
05138:  MOVLB  6
0513A:  SUBWF  x38,W
0513C:  BNZ   5144
0513E:  MOVLW  E8
05140:  MOVWF  F8B
05142:  BCF    F86.1
....................    delay_ms(1);
05144:  MOVLW  01
05146:  MOVWF  x3E
05148:  MOVLB  0
0514A:  CALL   0438
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
0514E:  MOVLB  6
05150:  CLRF   x3E
05152:  CLRF   x3D
05154:  MOVFF  63A,63C
05158:  MOVFF  639,63B
0515C:  MOVLB  0
0515E:  CALL   0B70
....................    delay_ms(1);
05162:  MOVLW  01
05164:  MOVLB  6
05166:  MOVWF  x3E
05168:  MOVLB  0
0516A:  CALL   0438
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
0516E:  MOVLW  00
05170:  BTFSC  x60.0
05172:  MOVLW  01
05174:  MOVLB  6
05176:  SUBWF  x38,W
05178:  BNZ   5180
0517A:  MOVLW  E8
0517C:  MOVWF  F8B
0517E:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
05180:  MOVLW  00
05182:  MOVLB  0
05184:  BTFSC  x60.1
05186:  MOVLW  01
05188:  MOVLB  6
0518A:  SUBWF  x38,W
0518C:  BNZ   5194
0518E:  MOVLW  E8
05190:  MOVWF  F8B
05192:  BSF    F86.1
05194:  MOVLB  0
05196:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
05198:  MOVLB  1
0519A:  MOVF   xB3,W
0519C:  XORLW  00
0519E:  MOVLB  0
051A0:  BZ    51A8
051A2:  XORLW  01
051A4:  BZ    51BA
051A6:  BRA    51CA
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
051A8:  MOVLB  6
051AA:  CLRF   x38
051AC:  MOVLB  0
051AE:  RCALL  4EF8
....................          state = 1;
051B0:  MOVLW  01
051B2:  MOVLB  1
051B4:  MOVWF  xB3
....................       break;
051B6:  MOVLB  0
051B8:  BRA    51CA
....................       case 1:
....................          set_nanoDAC_outputs(chY);
051BA:  MOVLW  01
051BC:  MOVLB  6
051BE:  MOVWF  x38
051C0:  MOVLB  0
051C2:  RCALL  4EF8
....................          state = 0;
051C4:  MOVLB  1
051C6:  CLRF   xB3
....................       break;
051C8:  MOVLB  0
....................    }
051CA:  GOTO   A84A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B9A:  MOVLB  6
00B9C:  CLRF   x3E
00B9E:  CLRF   x3D
00BA0:  CLRF   x3C
00BA2:  CLRF   x3B
00BA4:  MOVLB  0
00BA6:  RCALL  0B70
....................    output_low(_SYNC_X);
00BA8:  MOVLW  E8
00BAA:  MOVWF  F8B
00BAC:  BCF    F86.2
....................    output_low(_SYNC_Y);
00BAE:  MOVWF  F8B
00BB0:  BCF    F86.1
....................    output_high(_SYNC_X);
00BB2:  MOVWF  F8B
00BB4:  BSF    F86.2
....................    output_high(_SYNC_Y);
00BB6:  MOVWF  F8B
00BB8:  BSF    F86.1
00BBA:  GOTO   A832 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
00BE0:  MOVLB  6
00BE2:  MOVF   x39,W
00BE4:  SUBLW  03
00BE6:  BTFSS  FD8.0
00BE8:  BRA    0D56
....................    {
....................       for (int i = 0; i <numParam; i ++)
00BEA:  CLRF   x3A
00BEC:  MOVF   x3A,W
00BEE:  SUBLW  06
00BF0:  BNC   0C40
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00BF2:  CLRF   x7A
00BF4:  MOVFF  639,679
00BF8:  CLRF   x7C
00BFA:  MOVLW  B5
00BFC:  MOVWF  x7B
00BFE:  MOVLB  0
00C00:  RCALL  0BBE
00C02:  MOVFF  02,63C
00C06:  MOVFF  01,63B
00C0A:  MOVLW  06
00C0C:  MOVLB  6
00C0E:  ADDWF  x3B,F
00C10:  MOVLW  00
00C12:  ADDWFC x3C,F
00C14:  CLRF   x7A
00C16:  MOVFF  63A,679
00C1A:  CLRF   x7C
00C1C:  MOVLW  19
00C1E:  MOVWF  x7B
00C20:  MOVLB  0
00C22:  RCALL  0BBE
00C24:  MOVF   01,W
00C26:  MOVLB  6
00C28:  ADDWF  x3B,F
00C2A:  MOVF   02,W
00C2C:  ADDWFC x3C,F
00C2E:  MOVLW  B4
00C30:  ADDWF  x3B,W
00C32:  MOVWF  FE9
00C34:  MOVLW  01
00C36:  ADDWFC x3C,W
00C38:  MOVWF  FEA
00C3A:  CLRF   FEF
00C3C:  INCF   x3A,F
00C3E:  BRA    0BEC
....................       }
....................       SERcmd[recNum].t = 0;
00C40:  CLRF   x7A
00C42:  MOVFF  639,679
00C46:  CLRF   x7C
00C48:  MOVLW  B5
00C4A:  MOVWF  x7B
00C4C:  MOVLB  0
00C4E:  RCALL  0BBE
00C50:  MOVFF  01,63B
00C54:  MOVLW  05
00C56:  MOVLB  6
00C58:  ADDWF  01,W
00C5A:  MOVWF  01
00C5C:  MOVLW  00
00C5E:  ADDWFC 02,W
00C60:  MOVWF  03
00C62:  MOVF   01,W
00C64:  ADDLW  B4
00C66:  MOVWF  FE9
00C68:  MOVLW  01
00C6A:  ADDWFC 03,W
00C6C:  MOVWF  FEA
00C6E:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C70:  CLRF   x7A
00C72:  MOVFF  639,679
00C76:  CLRF   x7C
00C78:  MOVLW  B5
00C7A:  MOVWF  x7B
00C7C:  MOVLB  0
00C7E:  RCALL  0BBE
00C80:  MOVFF  01,63B
00C84:  MOVLW  01
00C86:  MOVLB  6
00C88:  ADDWF  01,W
00C8A:  MOVWF  01
00C8C:  MOVLW  00
00C8E:  ADDWFC 02,W
00C90:  MOVWF  03
00C92:  MOVF   01,W
00C94:  ADDLW  B4
00C96:  MOVWF  FE9
00C98:  MOVLW  01
00C9A:  ADDWFC 03,W
00C9C:  MOVWF  FEA
00C9E:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00CA0:  CLRF   x7A
00CA2:  MOVFF  639,679
00CA6:  CLRF   x7C
00CA8:  MOVLW  B5
00CAA:  MOVWF  x7B
00CAC:  MOVLB  0
00CAE:  RCALL  0BBE
00CB0:  MOVFF  01,63B
00CB4:  MOVLW  02
00CB6:  MOVLB  6
00CB8:  ADDWF  01,W
00CBA:  MOVWF  01
00CBC:  MOVLW  00
00CBE:  ADDWFC 02,W
00CC0:  MOVWF  03
00CC2:  MOVF   01,W
00CC4:  ADDLW  B4
00CC6:  MOVWF  FE9
00CC8:  MOVLW  01
00CCA:  ADDWFC 03,W
00CCC:  MOVWF  FEA
00CCE:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00CD0:  CLRF   x7A
00CD2:  MOVFF  639,679
00CD6:  CLRF   x7C
00CD8:  MOVLW  B5
00CDA:  MOVWF  x7B
00CDC:  MOVLB  0
00CDE:  RCALL  0BBE
00CE0:  MOVFF  01,63B
00CE4:  MOVLW  03
00CE6:  MOVLB  6
00CE8:  ADDWF  01,W
00CEA:  MOVWF  01
00CEC:  MOVLW  00
00CEE:  ADDWFC 02,W
00CF0:  MOVWF  03
00CF2:  MOVF   01,W
00CF4:  ADDLW  B4
00CF6:  MOVWF  FE9
00CF8:  MOVLW  01
00CFA:  ADDWFC 03,W
00CFC:  MOVWF  FEA
00CFE:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00D00:  CLRF   x7A
00D02:  MOVFF  639,679
00D06:  CLRF   x7C
00D08:  MOVLW  B5
00D0A:  MOVWF  x7B
00D0C:  MOVLB  0
00D0E:  RCALL  0BBE
00D10:  MOVFF  01,63B
00D14:  MOVLW  04
00D16:  MOVLB  6
00D18:  ADDWF  01,W
00D1A:  MOVWF  01
00D1C:  MOVLW  00
00D1E:  ADDWFC 02,W
00D20:  MOVWF  03
00D22:  MOVF   01,W
00D24:  ADDLW  B4
00D26:  MOVWF  FE9
00D28:  MOVLW  01
00D2A:  ADDWFC 03,W
00D2C:  MOVWF  FEA
00D2E:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00D30:  CLRF   x7A
00D32:  MOVFF  639,679
00D36:  CLRF   x7C
00D38:  MOVLW  B5
00D3A:  MOVWF  x7B
00D3C:  MOVLB  0
00D3E:  RCALL  0BBE
00D40:  MOVLW  B4
00D42:  MOVLB  6
00D44:  ADDWF  01,W
00D46:  MOVWF  FE9
00D48:  MOVLW  01
00D4A:  ADDWFC 02,W
00D4C:  MOVWF  FEA
00D4E:  BCF    FEF.0
....................       retData[0] = '\0';
00D50:  MOVLB  4
00D52:  CLRF   x8A
00D54:  MOVLB  6
....................    }
00D56:  MOVLB  0
00D58:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05B76:  MOVLB  6
05B78:  CLRF   x7A
05B7A:  MOVFF  488,679
05B7E:  CLRF   x7C
05B80:  MOVLW  B5
05B82:  MOVWF  x7B
05B84:  MOVLB  0
05B86:  CALL   0BBE
05B8A:  MOVFF  02,63A
05B8E:  MOVFF  01,639
05B92:  MOVLW  B4
05B94:  MOVLB  6
05B96:  ADDWF  01,W
05B98:  MOVWF  FE9
05B9A:  MOVLW  01
05B9C:  ADDWFC 02,W
05B9E:  MOVWF  FEA
05BA0:  BTFSC  FEF.0
05BA2:  BRA    5BC4
....................    {
....................       if (SRI == SWI) return FALSE;
05BA4:  MOVLB  4
05BA6:  MOVF   x89,W
05BA8:  SUBWF  x88,W
05BAA:  BNZ   5BB2
05BAC:  MOVLW  00
05BAE:  MOVWF  01
05BB0:  BRA    5BCA
....................       SRI +=1;
05BB2:  MOVLW  01
05BB4:  ADDWF  x88,F
....................       if (SRI >= numRecords) SRI=0;
05BB6:  MOVF   x88,W
05BB8:  SUBLW  03
05BBA:  BC    5BBE
05BBC:  CLRF   x88
05BBE:  MOVLB  0
05BC0:  BRA    5B76
05BC2:  MOVLB  6
....................    }
....................    return TRUE;
05BC4:  MOVLW  01
05BC6:  MOVWF  01
05BC8:  MOVLB  4
05BCA:  MOVLB  0
05BCC:  GOTO   A38C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05202:  MOVLW  01
05204:  MOVLB  4
05206:  ADDWF  x89,F
....................    if (SWI >= numRecords) SWI=0;
05208:  MOVF   x89,W
0520A:  SUBLW  03
0520C:  BC    5210
0520E:  CLRF   x89
05210:  MOVLB  0
05212:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,52D
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x2D.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
05214:  MOVLW  93
05216:  MOVWF  F89
05218:  BSF    F84.5
0521A:  MOVLB  E
0521C:  BTFSS  xC8.4
0521E:  BRA    521C
05220:  MOVLW  93
05222:  MOVWF  F89
05224:  BSF    F84.5
05226:  MOVLB  6
05228:  MOVFF  64E,F99
0522C:  NOP   
0522E:  BTFSS  F9D.1
05230:  BRA    522E
05232:  MOVLW  93
05234:  MOVWF  F89
05236:  BCF    F84.5
05238:  MOVLB  0
0523A:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x2A,W
000F6:  ADDLW  EE
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,6B5
00104:  MOVFF  FE9,6B4
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  6B5,FEA
00110:  MOVFF  6B4,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x2A,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x2A,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x2A
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    x2C.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
051CE:  CLRF   03
051D0:  MOVLB  5
051D2:  MOVF   x2B,W
051D4:  ADDLW  EE
051D6:  MOVWF  FE9
051D8:  MOVLW  04
051DA:  ADDWFC 03,W
051DC:  MOVWF  FEA
051DE:  MOVFF  FEF,639
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
051E2:  MOVLW  01
051E4:  ADDWF  x2B,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
051E6:  MOVF   x2B,W
051E8:  SUBLW  3B
051EA:  BC    51EE
051EC:  CLRF   x2B
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
051EE:  MOVF   x2A,W
051F0:  SUBWF  x2B,W
051F2:  BNZ   51F6
051F4:  BCF    x2C.0
....................    return data;
051F6:  MOVLB  6
051F8:  MOVFF  639,01
051FC:  MOVLB  0
051FE:  GOTO   52A2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05260:  MOVLB  5
05262:  BTFSS  x2C.0
05264:  BRA    5752
05266:  MOVLB  6
05268:  CLRF   x7A
0526A:  MOVFF  489,679
0526E:  CLRF   x7C
05270:  MOVLW  B5
05272:  MOVWF  x7B
05274:  MOVLB  0
05276:  CALL   0BBE
0527A:  MOVFF  02,63A
0527E:  MOVFF  01,639
05282:  MOVLW  B4
05284:  MOVLB  6
05286:  ADDWF  01,W
05288:  MOVWF  01
0528A:  MOVLW  01
0528C:  ADDWFC 02,W
0528E:  MOVWF  03
05290:  MOVFF  01,FE9
05294:  MOVWF  FEA
05296:  BTFSS  FEF.0
05298:  BRA    529E
0529A:  MOVLB  5
0529C:  BRA    5752
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
0529E:  MOVLB  0
052A0:  BRA    51CE
052A2:  MOVFF  01,638
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
052A6:  MOVLB  6
052A8:  MOVF   x38,W
052AA:  SUBLW  0D
052AC:  BZ    52B4
052AE:  MOVF   x38,W
052B0:  SUBLW  20
052B2:  BNZ   52B6
....................       {
....................       }
052B4:  BRA    574C
....................       else if (rxChar == UART_SOT_CHAR)
052B6:  MOVF   x38,W
052B8:  SUBLW  7E
052BA:  BNZ   52FE
....................       {
....................          resetSERcmd(SWI);
052BC:  MOVFF  489,639
052C0:  MOVLB  0
052C2:  CALL   0BE0
....................          SERcmd[SWI].t = rxChar;
052C6:  MOVLB  6
052C8:  CLRF   x7A
052CA:  MOVFF  489,679
052CE:  CLRF   x7C
052D0:  MOVLW  B5
052D2:  MOVWF  x7B
052D4:  MOVLB  0
052D6:  CALL   0BBE
052DA:  MOVFF  01,639
052DE:  MOVLW  05
052E0:  MOVLB  6
052E2:  ADDWF  01,W
052E4:  MOVWF  01
052E6:  MOVLW  00
052E8:  ADDWFC 02,W
052EA:  MOVWF  03
052EC:  MOVF   01,W
052EE:  ADDLW  B4
052F0:  MOVWF  FE9
052F2:  MOVLW  01
052F4:  ADDWFC 03,W
052F6:  MOVWF  FEA
052F8:  MOVFF  638,FEF
....................       }
052FC:  BRA    574C
....................       else if (rxChar >= oneByteCmdTestValue)
052FE:  MOVF   x38,W
05300:  SUBLW  7F
05302:  BC    536E
....................       {
....................          resetSERcmd(SWI);
05304:  MOVFF  489,639
05308:  MOVLB  0
0530A:  CALL   0BE0
....................          SERcmd[SWI].t = rxChar;
0530E:  MOVLB  6
05310:  CLRF   x7A
05312:  MOVFF  489,679
05316:  CLRF   x7C
05318:  MOVLW  B5
0531A:  MOVWF  x7B
0531C:  MOVLB  0
0531E:  CALL   0BBE
05322:  MOVFF  01,639
05326:  MOVLW  05
05328:  MOVLB  6
0532A:  ADDWF  01,W
0532C:  MOVWF  01
0532E:  MOVLW  00
05330:  ADDWFC 02,W
05332:  MOVWF  03
05334:  MOVF   01,W
05336:  ADDLW  B4
05338:  MOVWF  FE9
0533A:  MOVLW  01
0533C:  ADDWFC 03,W
0533E:  MOVWF  FEA
05340:  MOVFF  638,FEF
....................          SERcmd[SWI].full = TRUE;
05344:  CLRF   x7A
05346:  MOVFF  489,679
0534A:  CLRF   x7C
0534C:  MOVLW  B5
0534E:  MOVWF  x7B
05350:  MOVLB  0
05352:  CALL   0BBE
05356:  MOVLW  B4
05358:  MOVLB  6
0535A:  ADDWF  01,W
0535C:  MOVWF  FE9
0535E:  MOVLW  01
05360:  ADDWFC 02,W
05362:  MOVWF  FEA
05364:  BSF    FEF.0
....................          setNextSERWriteIndex();
05366:  MOVLB  0
05368:  RCALL  5202
....................       }
0536A:  BRA    574A
0536C:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
0536E:  MOVF   x38,W
05370:  SUBLW  0A
05372:  BTFSS  FD8.2
05374:  BRA    547A
....................       {
....................          SERcmd[SWI].full = TRUE;
05376:  CLRF   x7A
05378:  MOVFF  489,679
0537C:  CLRF   x7C
0537E:  MOVLW  B5
05380:  MOVWF  x7B
05382:  MOVLB  0
05384:  CALL   0BBE
05388:  MOVLW  B4
0538A:  MOVLB  6
0538C:  ADDWF  01,W
0538E:  MOVWF  FE9
05390:  MOVLW  01
05392:  ADDWFC 02,W
05394:  MOVWF  FEA
05396:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05398:  CLRF   x7A
0539A:  MOVFF  489,679
0539E:  CLRF   x7C
053A0:  MOVLW  B5
053A2:  MOVWF  x7B
053A4:  MOVLB  0
053A6:  CALL   0BBE
053AA:  MOVFF  01,639
053AE:  MOVLW  04
053B0:  MOVLB  6
053B2:  ADDWF  01,W
053B4:  MOVWF  01
053B6:  MOVLW  00
053B8:  ADDWFC 02,W
053BA:  MOVWF  03
053BC:  MOVF   01,W
053BE:  ADDLW  B4
053C0:  MOVWF  01
053C2:  MOVLW  01
053C4:  ADDWFC 03,F
053C6:  MOVFF  01,639
053CA:  MOVFF  03,63A
053CE:  CLRF   x7A
053D0:  MOVFF  489,679
053D4:  CLRF   x7C
053D6:  MOVLW  B5
053D8:  MOVWF  x7B
053DA:  MOVLB  0
053DC:  CALL   0BBE
053E0:  MOVFF  01,63B
053E4:  MOVLW  02
053E6:  MOVLB  6
053E8:  ADDWF  01,W
053EA:  MOVWF  01
053EC:  MOVLW  00
053EE:  ADDWFC 02,W
053F0:  MOVWF  03
053F2:  MOVF   01,W
053F4:  ADDLW  B4
053F6:  MOVWF  FE9
053F8:  MOVLW  01
053FA:  ADDWFC 03,W
053FC:  MOVWF  FEA
053FE:  MOVFF  FEF,63B
05402:  MOVFF  63A,FEA
05406:  MOVFF  639,FE9
0540A:  MOVFF  63B,FEF
....................          SERcmd[SWI].chrIndex = 0;
0540E:  CLRF   x7A
05410:  MOVFF  489,679
05414:  CLRF   x7C
05416:  MOVLW  B5
05418:  MOVWF  x7B
0541A:  MOVLB  0
0541C:  CALL   0BBE
05420:  MOVFF  01,639
05424:  MOVLW  01
05426:  MOVLB  6
05428:  ADDWF  01,W
0542A:  MOVWF  01
0542C:  MOVLW  00
0542E:  ADDWFC 02,W
05430:  MOVWF  03
05432:  MOVF   01,W
05434:  ADDLW  B4
05436:  MOVWF  FE9
05438:  MOVLW  01
0543A:  ADDWFC 03,W
0543C:  MOVWF  FEA
0543E:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
05440:  CLRF   x7A
05442:  MOVFF  489,679
05446:  CLRF   x7C
05448:  MOVLW  B5
0544A:  MOVWF  x7B
0544C:  MOVLB  0
0544E:  CALL   0BBE
05452:  MOVFF  01,639
05456:  MOVLW  02
05458:  MOVLB  6
0545A:  ADDWF  01,W
0545C:  MOVWF  01
0545E:  MOVLW  00
05460:  ADDWFC 02,W
05462:  MOVWF  03
05464:  MOVF   01,W
05466:  ADDLW  B4
05468:  MOVWF  FE9
0546A:  MOVLW  01
0546C:  ADDWFC 03,W
0546E:  MOVWF  FEA
05470:  CLRF   FEF
....................          setNextSERWriteIndex();
05472:  MOVLB  0
05474:  RCALL  5202
....................       }
05476:  BRA    574A
05478:  MOVLB  6
....................       else if (rxChar == delimiter)
0547A:  MOVF   x38,W
0547C:  SUBLW  2C
0547E:  BNZ   553C
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
05480:  CLRF   x7A
05482:  MOVFF  489,679
05486:  CLRF   x7C
05488:  MOVLW  B5
0548A:  MOVWF  x7B
0548C:  MOVLB  0
0548E:  CALL   0BBE
05492:  MOVFF  02,63A
05496:  MOVFF  01,639
0549A:  MOVLW  02
0549C:  MOVLB  6
0549E:  ADDWF  01,W
054A0:  MOVWF  01
054A2:  MOVLW  00
054A4:  ADDWFC 02,W
054A6:  MOVWF  03
054A8:  MOVF   01,W
054AA:  ADDLW  B4
054AC:  MOVWF  FE9
054AE:  MOVLW  01
054B0:  ADDWFC 03,W
054B2:  MOVWF  FEA
054B4:  MOVF   FEF,W
054B6:  SUBLW  05
054B8:  BNC   5524
....................          {
....................             SERcmd[SWI].paramIndex +=1;
054BA:  CLRF   x7A
054BC:  MOVFF  489,679
054C0:  CLRF   x7C
054C2:  MOVLW  B5
054C4:  MOVWF  x7B
054C6:  MOVLB  0
054C8:  CALL   0BBE
054CC:  MOVFF  01,639
054D0:  MOVLW  02
054D2:  MOVLB  6
054D4:  ADDWF  01,W
054D6:  MOVWF  01
054D8:  MOVLW  00
054DA:  ADDWFC 02,W
054DC:  MOVWF  03
054DE:  MOVF   01,W
054E0:  ADDLW  B4
054E2:  MOVWF  FE9
054E4:  MOVLW  01
054E6:  ADDWFC 03,W
054E8:  MOVWF  FEA
054EA:  MOVLW  01
054EC:  ADDWF  FEF,W
054EE:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
054F0:  CLRF   x7A
054F2:  MOVFF  489,679
054F6:  CLRF   x7C
054F8:  MOVLW  B5
054FA:  MOVWF  x7B
054FC:  MOVLB  0
054FE:  CALL   0BBE
05502:  MOVFF  01,639
05506:  MOVLW  01
05508:  MOVLB  6
0550A:  ADDWF  01,W
0550C:  MOVWF  01
0550E:  MOVLW  00
05510:  ADDWFC 02,W
05512:  MOVWF  03
05514:  MOVF   01,W
05516:  ADDLW  B4
05518:  MOVWF  FE9
0551A:  MOVLW  01
0551C:  ADDWFC 03,W
0551E:  MOVWF  FEA
05520:  CLRF   FEF
....................          }
05522:  BRA    553A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05524:  MOVFF  489,639
05528:  MOVLB  0
0552A:  CALL   0BE0
....................             fprintf(SERIAL, retData);
0552E:  MOVLW  04
05530:  MOVWF  FEA
05532:  MOVLW  8A
05534:  MOVWF  FE9
05536:  RCALL  523C
05538:  MOVLB  6
....................          }
....................       }
0553A:  BRA    574C
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
0553C:  CLRF   x7A
0553E:  MOVFF  489,679
05542:  CLRF   x7C
05544:  MOVLW  B5
05546:  MOVWF  x7B
05548:  MOVLB  0
0554A:  CALL   0BBE
0554E:  MOVFF  02,63A
05552:  MOVFF  01,639
05556:  MOVLW  01
05558:  MOVLB  6
0555A:  ADDWF  01,W
0555C:  MOVWF  01
0555E:  MOVLW  00
05560:  ADDWFC 02,W
05562:  MOVWF  03
05564:  MOVF   01,W
05566:  ADDLW  B4
05568:  MOVWF  FE9
0556A:  MOVLW  01
0556C:  ADDWFC 03,W
0556E:  MOVWF  FEA
05570:  MOVF   FEF,W
05572:  SUBLW  18
05574:  BTFSS  FD8.0
05576:  BRA    5736
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
05578:  CLRF   x7A
0557A:  MOVFF  489,679
0557E:  CLRF   x7C
05580:  MOVLW  B5
05582:  MOVWF  x7B
05584:  MOVLB  0
05586:  CALL   0BBE
0558A:  MOVFF  02,63A
0558E:  MOVFF  01,639
05592:  MOVLW  06
05594:  MOVLB  6
05596:  ADDWF  x39,F
05598:  MOVLW  00
0559A:  ADDWFC x3A,F
0559C:  CLRF   x7A
0559E:  MOVFF  489,679
055A2:  CLRF   x7C
055A4:  MOVLW  B5
055A6:  MOVWF  x7B
055A8:  MOVLB  0
055AA:  CALL   0BBE
055AE:  MOVFF  02,63C
055B2:  MOVFF  01,63B
055B6:  MOVLW  02
055B8:  MOVLB  6
055BA:  ADDWF  01,W
055BC:  MOVWF  01
055BE:  MOVLW  00
055C0:  ADDWFC 02,W
055C2:  MOVWF  03
055C4:  MOVF   01,W
055C6:  ADDLW  B4
055C8:  MOVWF  FE9
055CA:  MOVLW  01
055CC:  ADDWFC 03,W
055CE:  MOVWF  FEA
055D0:  CLRF   x7A
055D2:  MOVFF  FEF,679
055D6:  CLRF   x7C
055D8:  MOVLW  19
055DA:  MOVWF  x7B
055DC:  MOVLB  0
055DE:  CALL   0BBE
055E2:  MOVFF  02,03
055E6:  MOVF   01,W
055E8:  MOVLB  6
055EA:  ADDWF  x39,F
055EC:  MOVF   02,W
055EE:  ADDWFC x3A,F
055F0:  CLRF   x7A
055F2:  MOVFF  489,679
055F6:  CLRF   x7C
055F8:  MOVLW  B5
055FA:  MOVWF  x7B
055FC:  MOVLB  0
055FE:  CALL   0BBE
05602:  MOVFF  01,63B
05606:  MOVLW  01
05608:  MOVLB  6
0560A:  ADDWF  01,W
0560C:  MOVWF  01
0560E:  MOVLW  00
05610:  ADDWFC 02,W
05612:  MOVWF  03
05614:  MOVF   01,W
05616:  ADDLW  B4
05618:  MOVWF  FE9
0561A:  MOVLW  01
0561C:  ADDWFC 03,W
0561E:  MOVWF  FEA
05620:  MOVF   FEF,W
05622:  ADDWF  x39,W
05624:  MOVWF  01
05626:  MOVLW  00
05628:  ADDWFC x3A,W
0562A:  MOVWF  03
0562C:  MOVF   01,W
0562E:  ADDLW  B4
05630:  MOVWF  FE9
05632:  MOVLW  01
05634:  ADDWFC 03,W
05636:  MOVWF  FEA
05638:  MOVFF  638,FEF
....................             SERcmd[SWI].chrIndex += 1;
0563C:  CLRF   x7A
0563E:  MOVFF  489,679
05642:  CLRF   x7C
05644:  MOVLW  B5
05646:  MOVWF  x7B
05648:  MOVLB  0
0564A:  CALL   0BBE
0564E:  MOVFF  01,639
05652:  MOVLW  01
05654:  MOVLB  6
05656:  ADDWF  01,W
05658:  MOVWF  01
0565A:  MOVLW  00
0565C:  ADDWFC 02,W
0565E:  MOVWF  03
05660:  MOVF   01,W
05662:  ADDLW  B4
05664:  MOVWF  FE9
05666:  MOVLW  01
05668:  ADDWFC 03,W
0566A:  MOVWF  FEA
0566C:  MOVLW  01
0566E:  ADDWF  FEF,W
05670:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05672:  CLRF   x7A
05674:  MOVFF  489,679
05678:  CLRF   x7C
0567A:  MOVLW  B5
0567C:  MOVWF  x7B
0567E:  MOVLB  0
05680:  CALL   0BBE
05684:  MOVFF  02,63A
05688:  MOVFF  01,639
0568C:  MOVLW  06
0568E:  MOVLB  6
05690:  ADDWF  x39,F
05692:  MOVLW  00
05694:  ADDWFC x3A,F
05696:  CLRF   x7A
05698:  MOVFF  489,679
0569C:  CLRF   x7C
0569E:  MOVLW  B5
056A0:  MOVWF  x7B
056A2:  MOVLB  0
056A4:  CALL   0BBE
056A8:  MOVFF  02,63C
056AC:  MOVFF  01,63B
056B0:  MOVLW  02
056B2:  MOVLB  6
056B4:  ADDWF  01,W
056B6:  MOVWF  01
056B8:  MOVLW  00
056BA:  ADDWFC 02,W
056BC:  MOVWF  03
056BE:  MOVF   01,W
056C0:  ADDLW  B4
056C2:  MOVWF  FE9
056C4:  MOVLW  01
056C6:  ADDWFC 03,W
056C8:  MOVWF  FEA
056CA:  CLRF   x7A
056CC:  MOVFF  FEF,679
056D0:  CLRF   x7C
056D2:  MOVLW  19
056D4:  MOVWF  x7B
056D6:  MOVLB  0
056D8:  CALL   0BBE
056DC:  MOVFF  02,03
056E0:  MOVF   01,W
056E2:  MOVLB  6
056E4:  ADDWF  x39,F
056E6:  MOVF   02,W
056E8:  ADDWFC x3A,F
056EA:  CLRF   x7A
056EC:  MOVFF  489,679
056F0:  CLRF   x7C
056F2:  MOVLW  B5
056F4:  MOVWF  x7B
056F6:  MOVLB  0
056F8:  CALL   0BBE
056FC:  MOVFF  01,63B
05700:  MOVLW  01
05702:  MOVLB  6
05704:  ADDWF  01,W
05706:  MOVWF  01
05708:  MOVLW  00
0570A:  ADDWFC 02,W
0570C:  MOVWF  03
0570E:  MOVF   01,W
05710:  ADDLW  B4
05712:  MOVWF  FE9
05714:  MOVLW  01
05716:  ADDWFC 03,W
05718:  MOVWF  FEA
0571A:  MOVF   FEF,W
0571C:  ADDWF  x39,W
0571E:  MOVWF  01
05720:  MOVLW  00
05722:  ADDWFC x3A,W
05724:  MOVWF  03
05726:  MOVF   01,W
05728:  ADDLW  B4
0572A:  MOVWF  FE9
0572C:  MOVLW  01
0572E:  ADDWFC 03,W
05730:  MOVWF  FEA
05732:  CLRF   FEF
....................          }
05734:  BRA    574C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05736:  MOVFF  489,639
0573A:  MOVLB  0
0573C:  CALL   0BE0
....................             fprintf(SERIAL, retData);
05740:  MOVLW  04
05742:  MOVWF  FEA
05744:  MOVLW  8A
05746:  MOVWF  FE9
05748:  RCALL  523C
0574A:  MOVLB  6
....................          }
....................       }
0574C:  MOVLB  0
0574E:  BRA    5260
05750:  MOVLB  5
....................    }          
05752:  MOVLB  0
05754:  GOTO   A84E (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00D5A:  MOVLB  6
00D5C:  CLRF   x38
00D5E:  MOVF   x38,W
00D60:  SUBLW  03
00D62:  BNC   0D72
....................    {
....................       resetSERcmd(i);
00D64:  MOVFF  638,639
00D68:  MOVLB  0
00D6A:  RCALL  0BE0
00D6C:  MOVLB  6
00D6E:  INCF   x38,F
00D70:  BRA    0D5E
....................    }
....................    enable_interrupts(INT_RDA);
00D72:  MOVLB  E
00D74:  BSF    xC0.5
00D76:  MOVLB  0
00D78:  GOTO   A836 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D7C:  MOVLB  E
00D7E:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D80:  MOVLW  01
00D82:  MOVWF  FD1
00D84:  MOVLW  07
00D86:  MOVWF  FCE
00D88:  CLRF   FCF
00D8A:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D8C:  MOVLB  1
00D8E:  CLRF   x5A
00D90:  CLRF   x59
00D92:  CLRF   x58
00D94:  CLRF   x57
....................    timeoutReg1 = 0;
00D96:  CLRF   x5E
00D98:  CLRF   x5D
00D9A:  CLRF   x5C
00D9C:  CLRF   x5B
....................    timeoutReg2 = 0;
00D9E:  CLRF   x62
00DA0:  CLRF   x61
00DA2:  CLRF   x60
00DA4:  CLRF   x5F
....................    intTimeoutReg = 50;
00DA6:  CLRF   x64
00DA8:  MOVLW  32
00DAA:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
00DAC:  MOVLB  E
00DAE:  BSF    xC1.0
00DB0:  MOVLB  0
00DB2:  GOTO   A83A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025A:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025C:  MOVLW  0B
0025E:  MOVWF  FCD
00260:  MOVLW  DB
00262:  MOVWF  FCC
00264:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00266:  MOVLB  1
00268:  MOVF   x5A,F
0026A:  BNZ   027A
0026C:  MOVF   x59,F
0026E:  BNZ   027A
00270:  MOVF   x58,F
00272:  BNZ   027A
00274:  MOVF   x57,W
00276:  SUBLW  0A
00278:  BC    0288
0027A:  MOVLW  0A
0027C:  SUBWF  x57,F
0027E:  MOVLW  00
00280:  SUBWFB x58,F
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  BRA    0290
00288:  CLRF   x5A
0028A:  CLRF   x59
0028C:  CLRF   x58
0028E:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00290:  MOVF   x5E,F
00292:  BNZ   02A2
00294:  MOVF   x5D,F
00296:  BNZ   02A2
00298:  MOVF   x5C,F
0029A:  BNZ   02A2
0029C:  MOVF   x5B,W
0029E:  SUBLW  0A
002A0:  BC    02B0
002A2:  MOVLW  0A
002A4:  SUBWF  x5B,F
002A6:  MOVLW  00
002A8:  SUBWFB x5C,F
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  BRA    02B8
002B0:  CLRF   x5E
002B2:  CLRF   x5D
002B4:  CLRF   x5C
002B6:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002B8:  MOVF   x62,F
002BA:  BNZ   02CA
002BC:  MOVF   x61,F
002BE:  BNZ   02CA
002C0:  MOVF   x60,F
002C2:  BNZ   02CA
002C4:  MOVF   x5F,W
002C6:  SUBLW  0A
002C8:  BC    02D8
002CA:  MOVLW  0A
002CC:  SUBWF  x5F,F
002CE:  MOVLW  00
002D0:  SUBWFB x60,F
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  BRA    02E0
002D8:  CLRF   x62
002DA:  CLRF   x61
002DC:  CLRF   x60
002DE:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E0:  MOVF   x63,F
002E2:  BNZ   02E8
002E4:  MOVF   x64,F
002E6:  BZ    0324
....................    {
....................       timeCounter+=10;
002E8:  MOVLW  0A
002EA:  MOVLB  5
002EC:  ADDWF  x30,F
002EE:  MOVLW  00
002F0:  ADDWFC x31,F
002F2:  ADDWFC x32,F
002F4:  ADDWFC x33,F
....................       if (timeCounter >= intTimeoutReg)
002F6:  MOVF   x33,F
002F8:  BNZ   0314
002FA:  MOVF   x32,F
002FC:  BNZ   0314
002FE:  MOVLB  1
00300:  MOVF   x64,W
00302:  MOVLB  5
00304:  SUBWF  x31,W
00306:  BNC   0322
00308:  BNZ   0314
0030A:  MOVLB  1
0030C:  MOVF   x63,W
0030E:  MOVLB  5
00310:  SUBWF  x30,W
00312:  BNC   0322
....................       {
....................          sensor_monitor_interrupt_task();
00314:  MOVLB  0
00316:  BRA    01BE
....................          timeCounter = 0;
00318:  MOVLB  5
0031A:  CLRF   x33
0031C:  CLRF   x32
0031E:  CLRF   x31
00320:  CLRF   x30
00322:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00324:  MOVLB  E
00326:  BCF    xC9.0
00328:  MOVLB  0
0032A:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05CFA:  MOVLW  04
05CFC:  MOVLB  6
05CFE:  MOVWF  x7A
05D00:  MOVLW  8A
05D02:  MOVWF  x79
05D04:  MOVLB  0
05D06:  RCALL  5C0A
05D08:  MOVFF  02,03
05D0C:  MOVF   01,W
05D0E:  ADDLW  8A
05D10:  MOVLB  6
05D12:  MOVWF  x43
05D14:  MOVLW  04
05D16:  ADDWFC 02,W
05D18:  MOVWF  x44
05D1A:  MOVFF  FE8,52F
05D1E:  MOVFF  643,52E
05D22:  MOVLW  2E
05D24:  MOVWF  FF6
05D26:  MOVLW  03
05D28:  MOVWF  FF7
05D2A:  MOVLB  0
05D2C:  RCALL  5CDA
05D2E:  MOVLW  2C
05D30:  MOVLB  6
05D32:  MOVWF  x88
05D34:  MOVLB  0
05D36:  RCALL  5CBA
....................    return SUCCESS;
05D38:  MOVLW  00
05D3A:  MOVWF  01
05D3C:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05D3E:  MOVLW  04
05D40:  MOVLB  6
05D42:  MOVWF  x7A
05D44:  MOVLW  8A
05D46:  MOVWF  x79
05D48:  MOVLB  0
05D4A:  RCALL  5C0A
05D4C:  MOVFF  02,03
05D50:  MOVF   01,W
05D52:  ADDLW  8A
05D54:  MOVLB  6
05D56:  MOVWF  x43
05D58:  MOVLW  04
05D5A:  ADDWFC 02,W
05D5C:  MOVWF  x44
05D5E:  MOVFF  FE8,52F
05D62:  MOVFF  643,52E
05D66:  MOVLW  38
05D68:  MOVWF  FF6
05D6A:  MOVLW  03
05D6C:  MOVWF  FF7
05D6E:  MOVLB  0
05D70:  RCALL  5CDA
05D72:  MOVLW  2C
05D74:  MOVLB  6
05D76:  MOVWF  x88
05D78:  MOVLB  0
05D7A:  RCALL  5CBA
....................    return SUCCESS;
05D7C:  MOVLW  00
05D7E:  MOVWF  01
05D80:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06286:  MOVLB  6
06288:  CLRF   x7A
0628A:  MOVFF  637,679
0628E:  CLRF   x7C
06290:  MOVLW  B5
06292:  MOVWF  x7B
06294:  MOVLB  0
06296:  CALL   0BBE
0629A:  MOVFF  02,645
0629E:  MOVFF  01,644
062A2:  MOVLW  06
062A4:  MOVLB  6
062A6:  ADDWF  x44,F
062A8:  MOVLW  00
062AA:  ADDWFC x45,F
062AC:  MOVLW  32
062AE:  ADDWF  x44,W
062B0:  MOVWF  01
062B2:  MOVLW  00
062B4:  ADDWFC x45,W
062B6:  MOVWF  03
062B8:  MOVF   01,W
062BA:  ADDLW  B4
062BC:  MOVWF  01
062BE:  MOVLW  01
062C0:  ADDWFC 03,F
062C2:  MOVFF  01,644
062C6:  MOVFF  03,645
062CA:  MOVFF  03,66C
062CE:  MOVFF  01,66B
062D2:  MOVLB  0
062D4:  RCALL  5D82
062D6:  MOVF   01,F
062D8:  BNZ   62E2
062DA:  MOVLW  02
062DC:  MOVWF  01
062DE:  BRA    6420
062E0:  BRA    633E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
062E2:  MOVLB  6
062E4:  CLRF   x7A
062E6:  MOVFF  637,679
062EA:  CLRF   x7C
062EC:  MOVLW  B5
062EE:  MOVWF  x7B
062F0:  MOVLB  0
062F2:  CALL   0BBE
062F6:  MOVFF  02,645
062FA:  MOVFF  01,644
062FE:  MOVLW  06
06300:  MOVLB  6
06302:  ADDWF  x44,F
06304:  MOVLW  00
06306:  ADDWFC x45,F
06308:  MOVLW  32
0630A:  ADDWF  x44,W
0630C:  MOVWF  01
0630E:  MOVLW  00
06310:  ADDWFC x45,W
06312:  MOVWF  03
06314:  MOVF   01,W
06316:  ADDLW  B4
06318:  MOVWF  01
0631A:  MOVLW  01
0631C:  ADDWFC 03,F
0631E:  MOVFF  01,644
06322:  MOVFF  03,645
06326:  MOVFF  03,66C
0632A:  MOVFF  01,66B
0632E:  CLRF   x6E
06330:  CLRF   x6D
06332:  MOVLW  0A
06334:  MOVWF  x6F
06336:  MOVLB  0
06338:  RCALL  5E72
0633A:  MOVFF  01,643
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
0633E:  MOVLW  01
06340:  MOVLB  6
06342:  SUBWF  x43,W
06344:  MOVWF  x45
06346:  CLRF   x47
06348:  MOVLW  60
0634A:  MOVWF  x46
0634C:  MOVLB  0
0634E:  CALL   4806
06352:  BTFSC  01.0
06354:  BRA    63AA
06356:  MOVLW  04
06358:  MOVLB  6
0635A:  MOVWF  x7A
0635C:  MOVLW  8A
0635E:  MOVWF  x79
06360:  MOVLB  0
06362:  RCALL  5C0A
06364:  MOVFF  02,03
06368:  MOVF   01,W
0636A:  ADDLW  8A
0636C:  MOVLB  6
0636E:  MOVWF  x44
06370:  MOVLW  04
06372:  ADDWFC 02,W
06374:  MOVWF  x45
06376:  MOVFF  FE8,52F
0637A:  MOVFF  644,52E
0637E:  MOVFF  643,66C
06382:  MOVLW  18
06384:  MOVWF  x6D
06386:  MOVLB  0
06388:  RCALL  61C6
0638A:  MOVLW  2C
0638C:  MOVLB  6
0638E:  MOVWF  x88
06390:  MOVLB  0
06392:  RCALL  5CBA
06394:  MOVLW  58
06396:  MOVLB  6
06398:  MOVWF  x88
0639A:  MOVLB  0
0639C:  RCALL  5CBA
0639E:  MOVLW  2C
063A0:  MOVLB  6
063A2:  MOVWF  x88
063A4:  MOVLB  0
063A6:  RCALL  5CBA
063A8:  BRA    641C
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
063AA:  MOVLW  01
063AC:  MOVLB  6
063AE:  SUBWF  x43,W
063B0:  MOVWF  x45
063B2:  CLRF   x47
063B4:  MOVLW  60
063B6:  MOVWF  x46
063B8:  MOVLB  0
063BA:  CALL   4806
063BE:  BTFSS  01.0
063C0:  BRA    6416
063C2:  MOVLW  04
063C4:  MOVLB  6
063C6:  MOVWF  x7A
063C8:  MOVLW  8A
063CA:  MOVWF  x79
063CC:  MOVLB  0
063CE:  RCALL  5C0A
063D0:  MOVFF  02,03
063D4:  MOVF   01,W
063D6:  ADDLW  8A
063D8:  MOVLB  6
063DA:  MOVWF  x44
063DC:  MOVLW  04
063DE:  ADDWFC 02,W
063E0:  MOVWF  x45
063E2:  MOVFF  FE8,52F
063E6:  MOVFF  644,52E
063EA:  MOVFF  643,66C
063EE:  MOVLW  18
063F0:  MOVWF  x6D
063F2:  MOVLB  0
063F4:  RCALL  61C6
063F6:  MOVLW  2C
063F8:  MOVLB  6
063FA:  MOVWF  x88
063FC:  MOVLB  0
063FE:  RCALL  5CBA
06400:  MOVLW  59
06402:  MOVLB  6
06404:  MOVWF  x88
06406:  MOVLB  0
06408:  RCALL  5CBA
0640A:  MOVLW  2C
0640C:  MOVLB  6
0640E:  MOVWF  x88
06410:  MOVLB  0
06412:  RCALL  5CBA
06414:  BRA    641C
....................    else return INV_PARAM;
06416:  MOVLW  02
06418:  MOVWF  01
0641A:  BRA    6420
....................    
....................    return SUCCESS;
0641C:  MOVLW  00
0641E:  MOVWF  01
06420:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06464:  MOVLB  6
06466:  CLRF   x7A
06468:  MOVFF  637,679
0646C:  CLRF   x7C
0646E:  MOVLW  B5
06470:  MOVWF  x7B
06472:  MOVLB  0
06474:  CALL   0BBE
06478:  MOVFF  02,646
0647C:  MOVFF  01,645
06480:  MOVLW  06
06482:  MOVLB  6
06484:  ADDWF  x45,F
06486:  MOVLW  00
06488:  ADDWFC x46,F
0648A:  MOVLW  32
0648C:  ADDWF  x45,W
0648E:  MOVWF  01
06490:  MOVLW  00
06492:  ADDWFC x46,W
06494:  MOVWF  03
06496:  MOVF   01,W
06498:  ADDLW  B4
0649A:  MOVWF  01
0649C:  MOVLW  01
0649E:  ADDWFC 03,F
064A0:  MOVFF  01,645
064A4:  MOVFF  03,646
064A8:  MOVFF  03,66C
064AC:  MOVFF  01,66B
064B0:  MOVLB  0
064B2:  RCALL  5D82
064B4:  MOVF   01,F
064B6:  BNZ   64C0
064B8:  MOVLW  02
064BA:  MOVWF  01
064BC:  BRA    6610
064BE:  BRA    651C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
064C0:  MOVLB  6
064C2:  CLRF   x7A
064C4:  MOVFF  637,679
064C8:  CLRF   x7C
064CA:  MOVLW  B5
064CC:  MOVWF  x7B
064CE:  MOVLB  0
064D0:  CALL   0BBE
064D4:  MOVFF  02,646
064D8:  MOVFF  01,645
064DC:  MOVLW  06
064DE:  MOVLB  6
064E0:  ADDWF  x45,F
064E2:  MOVLW  00
064E4:  ADDWFC x46,F
064E6:  MOVLW  32
064E8:  ADDWF  x45,W
064EA:  MOVWF  01
064EC:  MOVLW  00
064EE:  ADDWFC x46,W
064F0:  MOVWF  03
064F2:  MOVF   01,W
064F4:  ADDLW  B4
064F6:  MOVWF  01
064F8:  MOVLW  01
064FA:  ADDWFC 03,F
064FC:  MOVFF  01,645
06500:  MOVFF  03,646
06504:  MOVFF  03,66C
06508:  MOVFF  01,66B
0650C:  CLRF   x6E
0650E:  CLRF   x6D
06510:  MOVLW  0A
06512:  MOVWF  x6F
06514:  MOVLB  0
06516:  RCALL  5E72
06518:  MOVFF  01,643
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0651C:  MOVLB  6
0651E:  CLRF   x7A
06520:  MOVFF  637,679
06524:  CLRF   x7C
06526:  MOVLW  B5
06528:  MOVWF  x7B
0652A:  MOVLB  0
0652C:  CALL   0BBE
06530:  MOVFF  02,646
06534:  MOVFF  01,645
06538:  MOVLW  06
0653A:  MOVLB  6
0653C:  ADDWF  x45,F
0653E:  MOVLW  00
06540:  ADDWFC x46,F
06542:  MOVLW  4B
06544:  ADDWF  x45,W
06546:  MOVWF  01
06548:  MOVLW  00
0654A:  ADDWFC x46,W
0654C:  MOVWF  03
0654E:  MOVF   01,W
06550:  ADDLW  B4
06552:  MOVWF  01
06554:  MOVLW  01
06556:  ADDWFC 03,F
06558:  MOVFF  01,645
0655C:  MOVFF  03,646
06560:  MOVFF  03,67A
06564:  MOVFF  01,679
06568:  MOVLB  0
0656A:  CALL   5C0A
0656E:  MOVFF  02,03
06572:  MOVF   01,W
06574:  SUBLW  01
06576:  BNZ   657C
06578:  MOVF   03,F
0657A:  BZ    6584
0657C:  MOVLW  02
0657E:  MOVWF  01
06580:  BRA    6610
06582:  BRA    65C4
....................    else arg2 = SERcmd[rec].p[3][0];
06584:  MOVLB  6
06586:  CLRF   x7A
06588:  MOVFF  637,679
0658C:  CLRF   x7C
0658E:  MOVLW  B5
06590:  MOVWF  x7B
06592:  MOVLB  0
06594:  CALL   0BBE
06598:  MOVFF  02,646
0659C:  MOVFF  01,645
065A0:  MOVLW  06
065A2:  MOVLB  6
065A4:  ADDWF  x45,F
065A6:  MOVLW  00
065A8:  ADDWFC x46,F
065AA:  MOVLW  4B
065AC:  ADDWF  x45,F
065AE:  MOVLW  00
065B0:  ADDWFC x46,F
065B2:  MOVLW  B4
065B4:  ADDWF  x45,W
065B6:  MOVWF  FE9
065B8:  MOVLW  01
065BA:  ADDWFC x46,W
065BC:  MOVWF  FEA
065BE:  MOVFF  FEF,644
065C2:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
065C4:  MOVLB  6
065C6:  MOVF   x44,W
065C8:  SUBLW  58
065CA:  BNZ   65E4
065CC:  MOVLW  01
065CE:  SUBWF  x43,W
065D0:  MOVWF  x45
065D2:  MOVWF  x5A
065D4:  CLRF   x5B
065D6:  CLRF   x5D
065D8:  MOVLW  60
065DA:  MOVWF  x5C
065DC:  MOVLB  0
065DE:  RCALL  6422
065E0:  BRA    660C
065E2:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
065E4:  MOVF   x44,W
065E6:  SUBLW  59
065E8:  BNZ   6604
065EA:  MOVLW  01
065EC:  SUBWF  x43,W
065EE:  MOVWF  x45
065F0:  MOVWF  x5A
065F2:  MOVLW  01
065F4:  MOVWF  x5B
065F6:  CLRF   x5D
065F8:  MOVLW  60
065FA:  MOVWF  x5C
065FC:  MOVLB  0
065FE:  RCALL  6422
06600:  BRA    660C
06602:  MOVLB  6
....................    else return INV_PARAM;
06604:  MOVLW  02
06606:  MOVWF  01
06608:  MOVLB  0
0660A:  BRA    6610
....................    
....................    return SUCCESS;
0660C:  MOVLW  00
0660E:  MOVWF  01
06610:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0663C:  MOVLB  6
0663E:  CLRF   x7A
06640:  MOVFF  637,679
06644:  CLRF   x7C
06646:  MOVLW  B5
06648:  MOVWF  x7B
0664A:  MOVLB  0
0664C:  CALL   0BBE
06650:  MOVFF  02,645
06654:  MOVFF  01,644
06658:  MOVLW  06
0665A:  MOVLB  6
0665C:  ADDWF  x44,F
0665E:  MOVLW  00
06660:  ADDWFC x45,F
06662:  MOVLW  32
06664:  ADDWF  x44,W
06666:  MOVWF  01
06668:  MOVLW  00
0666A:  ADDWFC x45,W
0666C:  MOVWF  03
0666E:  MOVF   01,W
06670:  ADDLW  B4
06672:  MOVWF  01
06674:  MOVLW  01
06676:  ADDWFC 03,F
06678:  MOVFF  01,644
0667C:  MOVFF  03,645
06680:  MOVFF  03,66C
06684:  MOVFF  01,66B
06688:  MOVLB  0
0668A:  CALL   5D82
0668E:  MOVF   01,F
06690:  BNZ   669A
06692:  MOVLW  02
06694:  MOVWF  01
06696:  BRA    67C6
06698:  BRA    66F8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0669A:  MOVLB  6
0669C:  CLRF   x7A
0669E:  MOVFF  637,679
066A2:  CLRF   x7C
066A4:  MOVLW  B5
066A6:  MOVWF  x7B
066A8:  MOVLB  0
066AA:  CALL   0BBE
066AE:  MOVFF  02,645
066B2:  MOVFF  01,644
066B6:  MOVLW  06
066B8:  MOVLB  6
066BA:  ADDWF  x44,F
066BC:  MOVLW  00
066BE:  ADDWFC x45,F
066C0:  MOVLW  32
066C2:  ADDWF  x44,W
066C4:  MOVWF  01
066C6:  MOVLW  00
066C8:  ADDWFC x45,W
066CA:  MOVWF  03
066CC:  MOVF   01,W
066CE:  ADDLW  B4
066D0:  MOVWF  01
066D2:  MOVLW  01
066D4:  ADDWFC 03,F
066D6:  MOVFF  01,644
066DA:  MOVFF  03,645
066DE:  MOVFF  03,66C
066E2:  MOVFF  01,66B
066E6:  CLRF   x6E
066E8:  CLRF   x6D
066EA:  MOVLW  0A
066EC:  MOVWF  x6F
066EE:  MOVLB  0
066F0:  CALL   5E72
066F4:  MOVFF  01,643
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
066F8:  MOVLW  01
066FA:  MOVLB  6
066FC:  SUBWF  x43,W
066FE:  MOVWF  x45
06700:  CLRF   x47
06702:  MOVLW  61
06704:  MOVWF  x46
06706:  MOVLB  0
06708:  CALL   4806
0670C:  BTFSC  01.0
0670E:  BRA    675A
06710:  MOVLW  04
06712:  MOVLB  6
06714:  MOVWF  x7A
06716:  MOVLW  8A
06718:  MOVWF  x79
0671A:  MOVLB  0
0671C:  CALL   5C0A
06720:  MOVFF  02,03
06724:  MOVF   01,W
06726:  ADDLW  8A
06728:  MOVLB  6
0672A:  MOVWF  x44
0672C:  MOVLW  04
0672E:  ADDWFC 02,W
06730:  MOVWF  x45
06732:  MOVFF  FE8,52F
06736:  MOVFF  644,52E
0673A:  MOVFF  643,66C
0673E:  MOVLW  18
06740:  MOVWF  x6D
06742:  MOVLB  0
06744:  RCALL  61C6
06746:  MOVLW  40
06748:  MOVWF  FF6
0674A:  MOVLW  03
0674C:  MOVWF  FF7
0674E:  MOVLW  08
06750:  MOVLB  6
06752:  MOVWF  x47
06754:  MOVLB  0
06756:  RCALL  6612
06758:  BRA    67C2
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
0675A:  MOVLW  01
0675C:  MOVLB  6
0675E:  SUBWF  x43,W
06760:  MOVWF  x45
06762:  CLRF   x47
06764:  MOVLW  61
06766:  MOVWF  x46
06768:  MOVLB  0
0676A:  CALL   4806
0676E:  BTFSS  01.0
06770:  BRA    67BC
06772:  MOVLW  04
06774:  MOVLB  6
06776:  MOVWF  x7A
06778:  MOVLW  8A
0677A:  MOVWF  x79
0677C:  MOVLB  0
0677E:  CALL   5C0A
06782:  MOVFF  02,03
06786:  MOVF   01,W
06788:  ADDLW  8A
0678A:  MOVLB  6
0678C:  MOVWF  x44
0678E:  MOVLW  04
06790:  ADDWFC 02,W
06792:  MOVWF  x45
06794:  MOVFF  FE8,52F
06798:  MOVFF  644,52E
0679C:  MOVFF  643,66C
067A0:  MOVLW  18
067A2:  MOVWF  x6D
067A4:  MOVLB  0
067A6:  RCALL  61C6
067A8:  MOVLW  4C
067AA:  MOVWF  FF6
067AC:  MOVLW  03
067AE:  MOVWF  FF7
067B0:  MOVLW  08
067B2:  MOVLB  6
067B4:  MOVWF  x47
067B6:  MOVLB  0
067B8:  RCALL  6612
067BA:  BRA    67C2
....................    else return INV_PARAM;
067BC:  MOVLW  02
067BE:  MOVWF  01
067C0:  BRA    67C6
....................    
....................    return SUCCESS;
067C2:  MOVLW  00
067C4:  MOVWF  01
067C6:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
067C8:  MOVLW  4D
067CA:  MOVLB  6
067CC:  MOVWF  x48
067CE:  MOVLW  41
067D0:  MOVWF  x49
067D2:  MOVLW  4E
067D4:  MOVWF  x4A
067D6:  MOVLW  55
067D8:  MOVWF  x4B
067DA:  MOVLW  41
067DC:  MOVWF  x4C
067DE:  MOVLW  4C
067E0:  MOVWF  x4D
067E2:  CLRF   x4E
067E4:  MOVLW  06
067E6:  MOVWF  x47
067E8:  MOVLW  48
067EA:  MOVWF  x46
....................    char *s_magsns = "MAGSNS";
067EC:  MOVLW  4D
067EE:  MOVWF  x51
067F0:  MOVLW  41
067F2:  MOVWF  x52
067F4:  MOVLW  47
067F6:  MOVWF  x53
067F8:  MOVLW  53
067FA:  MOVWF  x54
067FC:  MOVLW  4E
067FE:  MOVWF  x55
06800:  MOVLW  53
06802:  MOVWF  x56
06804:  CLRF   x57
06806:  MOVLW  06
06808:  MOVWF  x50
0680A:  MOVLW  51
0680C:  MOVWF  x4F
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0680E:  CLRF   x7A
06810:  MOVFF  637,679
06814:  CLRF   x7C
06816:  MOVLW  B5
06818:  MOVWF  x7B
0681A:  MOVLB  0
0681C:  CALL   0BBE
06820:  MOVFF  02,659
06824:  MOVFF  01,658
06828:  MOVLW  06
0682A:  MOVLB  6
0682C:  ADDWF  x58,F
0682E:  MOVLW  00
06830:  ADDWFC x59,F
06832:  MOVLW  32
06834:  ADDWF  x58,W
06836:  MOVWF  01
06838:  MOVLW  00
0683A:  ADDWFC x59,W
0683C:  MOVWF  03
0683E:  MOVF   01,W
06840:  ADDLW  B4
06842:  MOVWF  01
06844:  MOVLW  01
06846:  ADDWFC 03,F
06848:  MOVFF  01,658
0684C:  MOVFF  03,659
06850:  MOVFF  03,66C
06854:  MOVFF  01,66B
06858:  MOVLB  0
0685A:  CALL   5D82
0685E:  MOVF   01,F
06860:  BNZ   686A
06862:  MOVLW  02
06864:  MOVWF  01
06866:  BRA    69E0
06868:  BRA    68C8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0686A:  MOVLB  6
0686C:  CLRF   x7A
0686E:  MOVFF  637,679
06872:  CLRF   x7C
06874:  MOVLW  B5
06876:  MOVWF  x7B
06878:  MOVLB  0
0687A:  CALL   0BBE
0687E:  MOVFF  02,659
06882:  MOVFF  01,658
06886:  MOVLW  06
06888:  MOVLB  6
0688A:  ADDWF  x58,F
0688C:  MOVLW  00
0688E:  ADDWFC x59,F
06890:  MOVLW  32
06892:  ADDWF  x58,W
06894:  MOVWF  01
06896:  MOVLW  00
06898:  ADDWFC x59,W
0689A:  MOVWF  03
0689C:  MOVF   01,W
0689E:  ADDLW  B4
068A0:  MOVWF  01
068A2:  MOVLW  01
068A4:  ADDWFC 03,F
068A6:  MOVFF  01,658
068AA:  MOVFF  03,659
068AE:  MOVFF  03,66C
068B2:  MOVFF  01,66B
068B6:  CLRF   x6E
068B8:  CLRF   x6D
068BA:  MOVLW  0A
068BC:  MOVWF  x6F
068BE:  MOVLB  0
068C0:  CALL   5E72
068C4:  MOVFF  01,643
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
068C8:  MOVLB  6
068CA:  CLRF   x7A
068CC:  MOVFF  637,679
068D0:  CLRF   x7C
068D2:  MOVLW  B5
068D4:  MOVWF  x7B
068D6:  MOVLB  0
068D8:  CALL   0BBE
068DC:  MOVFF  02,659
068E0:  MOVFF  01,658
068E4:  MOVLW  06
068E6:  MOVLB  6
068E8:  ADDWF  x58,F
068EA:  MOVLW  00
068EC:  ADDWFC x59,F
068EE:  MOVLW  4B
068F0:  ADDWF  x58,W
068F2:  MOVWF  01
068F4:  MOVLW  00
068F6:  ADDWFC x59,W
068F8:  MOVWF  03
068FA:  MOVF   01,W
068FC:  ADDLW  B4
068FE:  MOVWF  01
06900:  MOVLW  01
06902:  ADDWFC 03,F
06904:  MOVFF  01,658
06908:  MOVFF  03,659
0690C:  MOVFF  03,67A
06910:  MOVFF  01,679
06914:  MOVLB  0
06916:  CALL   5C0A
0691A:  MOVFF  02,03
0691E:  MOVF   01,W
06920:  BNZ   692E
06922:  MOVF   03,F
06924:  BNZ   692E
06926:  MOVLW  02
06928:  MOVWF  01
0692A:  BRA    69E0
0692C:  BRA    6974
....................    else arg2 = SERcmd[rec].p[3];
0692E:  MOVLB  6
06930:  CLRF   x7A
06932:  MOVFF  637,679
06936:  CLRF   x7C
06938:  MOVLW  B5
0693A:  MOVWF  x7B
0693C:  MOVLB  0
0693E:  CALL   0BBE
06942:  MOVFF  02,659
06946:  MOVFF  01,658
0694A:  MOVLW  06
0694C:  MOVLB  6
0694E:  ADDWF  x58,F
06950:  MOVLW  00
06952:  ADDWFC x59,F
06954:  MOVLW  4B
06956:  ADDWF  x58,W
06958:  MOVWF  01
0695A:  MOVLW  00
0695C:  ADDWFC x59,W
0695E:  MOVWF  03
06960:  MOVF   01,W
06962:  ADDLW  B4
06964:  MOVWF  01
06966:  MOVLW  01
06968:  ADDWFC 03,F
0696A:  MOVFF  01,644
0696E:  MOVFF  03,645
06972:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06974:  MOVFF  647,67A
06978:  MOVFF  646,679
0697C:  MOVFF  645,67C
06980:  MOVFF  644,67B
06984:  CALL   5C42
06988:  MOVF   01,F
0698A:  BNZ   69A4
0698C:  MOVLW  01
0698E:  MOVLB  6
06990:  SUBWF  x43,W
06992:  MOVWF  x58
06994:  MOVWF  x5A
06996:  CLRF   x5B
06998:  CLRF   x5D
0699A:  MOVLW  61
0699C:  MOVWF  x5C
0699E:  MOVLB  0
069A0:  RCALL  6422
069A2:  BRA    69DC
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
069A4:  MOVFF  650,67A
069A8:  MOVFF  64F,679
069AC:  MOVFF  645,67C
069B0:  MOVFF  644,67B
069B4:  CALL   5C42
069B8:  MOVF   01,F
069BA:  BNZ   69D6
069BC:  MOVLW  01
069BE:  MOVLB  6
069C0:  SUBWF  x43,W
069C2:  MOVWF  x58
069C4:  MOVWF  x5A
069C6:  MOVLW  01
069C8:  MOVWF  x5B
069CA:  CLRF   x5D
069CC:  MOVLW  61
069CE:  MOVWF  x5C
069D0:  MOVLB  0
069D2:  RCALL  6422
069D4:  BRA    69DC
....................    else return INV_PARAM;
069D6:  MOVLW  02
069D8:  MOVWF  01
069DA:  BRA    69E0
....................    
....................    return SUCCESS;
069DC:  MOVLW  00
069DE:  MOVWF  01
069E0:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06B98:  MOVLB  6
06B9A:  CLRF   x7A
06B9C:  MOVFF  637,679
06BA0:  CLRF   x7C
06BA2:  MOVLW  B5
06BA4:  MOVWF  x7B
06BA6:  MOVLB  0
06BA8:  CALL   0BBE
06BAC:  MOVFF  02,646
06BB0:  MOVFF  01,645
06BB4:  MOVLW  06
06BB6:  MOVLB  6
06BB8:  ADDWF  x45,F
06BBA:  MOVLW  00
06BBC:  ADDWFC x46,F
06BBE:  MOVLW  32
06BC0:  ADDWF  x45,W
06BC2:  MOVWF  01
06BC4:  MOVLW  00
06BC6:  ADDWFC x46,W
06BC8:  MOVWF  03
06BCA:  MOVF   01,W
06BCC:  ADDLW  B4
06BCE:  MOVWF  01
06BD0:  MOVLW  01
06BD2:  ADDWFC 03,F
06BD4:  MOVFF  01,645
06BD8:  MOVFF  03,646
06BDC:  MOVFF  03,66C
06BE0:  MOVFF  01,66B
06BE4:  MOVLB  0
06BE6:  CALL   5D82
06BEA:  MOVF   01,F
06BEC:  BNZ   6BF6
06BEE:  MOVLW  02
06BF0:  MOVWF  01
06BF2:  BRA    704C
06BF4:  BRA    6C54
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06BF6:  MOVLB  6
06BF8:  CLRF   x7A
06BFA:  MOVFF  637,679
06BFE:  CLRF   x7C
06C00:  MOVLW  B5
06C02:  MOVWF  x7B
06C04:  MOVLB  0
06C06:  CALL   0BBE
06C0A:  MOVFF  02,646
06C0E:  MOVFF  01,645
06C12:  MOVLW  06
06C14:  MOVLB  6
06C16:  ADDWF  x45,F
06C18:  MOVLW  00
06C1A:  ADDWFC x46,F
06C1C:  MOVLW  32
06C1E:  ADDWF  x45,W
06C20:  MOVWF  01
06C22:  MOVLW  00
06C24:  ADDWFC x46,W
06C26:  MOVWF  03
06C28:  MOVF   01,W
06C2A:  ADDLW  B4
06C2C:  MOVWF  01
06C2E:  MOVLW  01
06C30:  ADDWFC 03,F
06C32:  MOVFF  01,645
06C36:  MOVFF  03,646
06C3A:  MOVFF  03,66C
06C3E:  MOVFF  01,66B
06C42:  CLRF   x6E
06C44:  CLRF   x6D
06C46:  MOVLW  0A
06C48:  MOVWF  x6F
06C4A:  MOVLB  0
06C4C:  CALL   5E72
06C50:  MOVFF  01,643
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06C54:  MOVLB  6
06C56:  CLRF   x7A
06C58:  MOVFF  637,679
06C5C:  CLRF   x7C
06C5E:  MOVLW  B5
06C60:  MOVWF  x7B
06C62:  MOVLB  0
06C64:  CALL   0BBE
06C68:  MOVFF  02,646
06C6C:  MOVFF  01,645
06C70:  MOVLW  06
06C72:  MOVLB  6
06C74:  ADDWF  x45,F
06C76:  MOVLW  00
06C78:  ADDWFC x46,F
06C7A:  MOVLW  4B
06C7C:  ADDWF  x45,W
06C7E:  MOVWF  01
06C80:  MOVLW  00
06C82:  ADDWFC x46,W
06C84:  MOVWF  03
06C86:  MOVF   01,W
06C88:  ADDLW  B4
06C8A:  MOVWF  01
06C8C:  MOVLW  01
06C8E:  ADDWFC 03,F
06C90:  MOVFF  01,645
06C94:  MOVFF  03,646
06C98:  MOVFF  03,67A
06C9C:  MOVFF  01,679
06CA0:  MOVLB  0
06CA2:  CALL   5C0A
06CA6:  MOVFF  02,03
06CAA:  MOVF   01,W
06CAC:  SUBLW  01
06CAE:  BNZ   6CB4
06CB0:  MOVF   03,F
06CB2:  BZ    6CBC
06CB4:  MOVLW  02
06CB6:  MOVWF  01
06CB8:  BRA    704C
06CBA:  BRA    6CFC
....................    else arg2 = SERcmd[rec].p[3][0];
06CBC:  MOVLB  6
06CBE:  CLRF   x7A
06CC0:  MOVFF  637,679
06CC4:  CLRF   x7C
06CC6:  MOVLW  B5
06CC8:  MOVWF  x7B
06CCA:  MOVLB  0
06CCC:  CALL   0BBE
06CD0:  MOVFF  02,646
06CD4:  MOVFF  01,645
06CD8:  MOVLW  06
06CDA:  MOVLB  6
06CDC:  ADDWF  x45,F
06CDE:  MOVLW  00
06CE0:  ADDWFC x46,F
06CE2:  MOVLW  4B
06CE4:  ADDWF  x45,F
06CE6:  MOVLW  00
06CE8:  ADDWFC x46,F
06CEA:  MOVLW  B4
06CEC:  ADDWF  x45,W
06CEE:  MOVWF  FE9
06CF0:  MOVLW  01
06CF2:  ADDWFC x46,W
06CF4:  MOVWF  FEA
06CF6:  MOVFF  FEF,644
06CFA:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06CFC:  MOVLB  6
06CFE:  MOVF   x44,W
06D00:  SUBLW  50
06D02:  BNZ   6D9C
06D04:  MOVLW  04
06D06:  MOVWF  x7A
06D08:  MOVLW  8A
06D0A:  MOVWF  x79
06D0C:  MOVLB  0
06D0E:  CALL   5C0A
06D12:  MOVFF  02,03
06D16:  MOVF   01,W
06D18:  ADDLW  8A
06D1A:  MOVLB  6
06D1C:  MOVWF  x45
06D1E:  MOVLW  04
06D20:  ADDWFC 02,W
06D22:  MOVWF  x46
06D24:  MOVLW  01
06D26:  SUBWF  x43,W
06D28:  MULLW  20
06D2A:  MOVF   FF3,W
06D2C:  CLRF   x48
06D2E:  MOVWF  x47
06D30:  MOVLW  20
06D32:  ADDWF  x47,W
06D34:  MOVWF  FE9
06D36:  MOVLW  00
06D38:  ADDWFC x48,W
06D3A:  MOVWF  FEA
06D3C:  MOVFF  FEF,649
06D40:  MOVFF  FEC,64A
06D44:  MOVFF  FEC,64B
06D48:  MOVFF  FEC,64C
06D4C:  MOVFF  646,52F
06D50:  MOVFF  645,52E
06D54:  MOVFF  643,66C
06D58:  MOVLW  18
06D5A:  MOVWF  x6D
06D5C:  MOVLB  0
06D5E:  CALL   61C6
06D62:  MOVLW  2C
06D64:  MOVLB  6
06D66:  MOVWF  x88
06D68:  MOVLB  0
06D6A:  CALL   5CBA
06D6E:  MOVLW  89
06D70:  MOVWF  FE9
06D72:  MOVFF  64C,67E
06D76:  MOVFF  64B,67D
06D7A:  MOVFF  64A,67C
06D7E:  MOVFF  649,67B
06D82:  MOVLW  02
06D84:  MOVLB  6
06D86:  MOVWF  x7F
06D88:  MOVLB  0
06D8A:  RCALL  69E2
06D8C:  MOVLW  2C
06D8E:  MOVLB  6
06D90:  MOVWF  x88
06D92:  MOVLB  0
06D94:  CALL   5CBA
06D98:  BRA    7048
06D9A:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06D9C:  MOVF   x44,W
06D9E:  SUBLW  49
06DA0:  BNZ   6E42
06DA2:  MOVLW  04
06DA4:  MOVWF  x7A
06DA6:  MOVLW  8A
06DA8:  MOVWF  x79
06DAA:  MOVLB  0
06DAC:  CALL   5C0A
06DB0:  MOVF   01,W
06DB2:  ADDLW  8A
06DB4:  MOVLB  6
06DB6:  MOVWF  x45
06DB8:  MOVLW  04
06DBA:  ADDWFC 02,W
06DBC:  MOVWF  x46
06DBE:  MOVLW  01
06DC0:  SUBWF  x43,W
06DC2:  MULLW  20
06DC4:  MOVF   FF3,W
06DC6:  CLRF   x48
06DC8:  MOVWF  x47
06DCA:  MOVLW  04
06DCC:  ADDWF  x47,W
06DCE:  MOVWF  01
06DD0:  MOVLW  00
06DD2:  ADDWFC x48,W
06DD4:  MOVWF  03
06DD6:  MOVF   01,W
06DD8:  ADDLW  20
06DDA:  MOVWF  FE9
06DDC:  MOVLW  00
06DDE:  ADDWFC 03,W
06DE0:  MOVWF  FEA
06DE2:  MOVFF  FEF,647
06DE6:  MOVFF  FEC,648
06DEA:  MOVFF  FEC,649
06DEE:  MOVFF  FEC,64A
06DF2:  MOVFF  646,52F
06DF6:  MOVFF  645,52E
06DFA:  MOVFF  643,66C
06DFE:  MOVLW  18
06E00:  MOVWF  x6D
06E02:  MOVLB  0
06E04:  CALL   61C6
06E08:  MOVLW  2C
06E0A:  MOVLB  6
06E0C:  MOVWF  x88
06E0E:  MOVLB  0
06E10:  CALL   5CBA
06E14:  MOVLW  89
06E16:  MOVWF  FE9
06E18:  MOVFF  64A,67E
06E1C:  MOVFF  649,67D
06E20:  MOVFF  648,67C
06E24:  MOVFF  647,67B
06E28:  MOVLW  02
06E2A:  MOVLB  6
06E2C:  MOVWF  x7F
06E2E:  MOVLB  0
06E30:  RCALL  69E2
06E32:  MOVLW  2C
06E34:  MOVLB  6
06E36:  MOVWF  x88
06E38:  MOVLB  0
06E3A:  CALL   5CBA
06E3E:  BRA    7048
06E40:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06E42:  MOVF   x44,W
06E44:  SUBLW  44
06E46:  BNZ   6EE8
06E48:  MOVLW  04
06E4A:  MOVWF  x7A
06E4C:  MOVLW  8A
06E4E:  MOVWF  x79
06E50:  MOVLB  0
06E52:  CALL   5C0A
06E56:  MOVF   01,W
06E58:  ADDLW  8A
06E5A:  MOVLB  6
06E5C:  MOVWF  x45
06E5E:  MOVLW  04
06E60:  ADDWFC 02,W
06E62:  MOVWF  x46
06E64:  MOVLW  01
06E66:  SUBWF  x43,W
06E68:  MULLW  20
06E6A:  MOVF   FF3,W
06E6C:  CLRF   x48
06E6E:  MOVWF  x47
06E70:  MOVLW  08
06E72:  ADDWF  x47,W
06E74:  MOVWF  01
06E76:  MOVLW  00
06E78:  ADDWFC x48,W
06E7A:  MOVWF  03
06E7C:  MOVF   01,W
06E7E:  ADDLW  20
06E80:  MOVWF  FE9
06E82:  MOVLW  00
06E84:  ADDWFC 03,W
06E86:  MOVWF  FEA
06E88:  MOVFF  FEF,647
06E8C:  MOVFF  FEC,648
06E90:  MOVFF  FEC,649
06E94:  MOVFF  FEC,64A
06E98:  MOVFF  646,52F
06E9C:  MOVFF  645,52E
06EA0:  MOVFF  643,66C
06EA4:  MOVLW  18
06EA6:  MOVWF  x6D
06EA8:  MOVLB  0
06EAA:  CALL   61C6
06EAE:  MOVLW  2C
06EB0:  MOVLB  6
06EB2:  MOVWF  x88
06EB4:  MOVLB  0
06EB6:  CALL   5CBA
06EBA:  MOVLW  89
06EBC:  MOVWF  FE9
06EBE:  MOVFF  64A,67E
06EC2:  MOVFF  649,67D
06EC6:  MOVFF  648,67C
06ECA:  MOVFF  647,67B
06ECE:  MOVLW  02
06ED0:  MOVLB  6
06ED2:  MOVWF  x7F
06ED4:  MOVLB  0
06ED6:  RCALL  69E2
06ED8:  MOVLW  2C
06EDA:  MOVLB  6
06EDC:  MOVWF  x88
06EDE:  MOVLB  0
06EE0:  CALL   5CBA
06EE4:  BRA    7048
06EE6:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06EE8:  MOVF   x44,W
06EEA:  SUBLW  41
06EEC:  BTFSS  FD8.2
06EEE:  BRA    7040
06EF0:  MOVLW  04
06EF2:  MOVWF  x7A
06EF4:  MOVLW  8A
06EF6:  MOVWF  x79
06EF8:  MOVLB  0
06EFA:  CALL   5C0A
06EFE:  MOVF   01,W
06F00:  ADDLW  8A
06F02:  MOVLB  6
06F04:  MOVWF  x45
06F06:  MOVLW  04
06F08:  ADDWFC 02,W
06F0A:  MOVWF  x46
06F0C:  MOVLW  01
06F0E:  SUBWF  x43,W
06F10:  MULLW  20
06F12:  MOVF   FF3,W
06F14:  CLRF   x48
06F16:  MOVWF  x47
06F18:  MOVLW  20
06F1A:  ADDWF  x47,W
06F1C:  MOVWF  FE9
06F1E:  MOVLW  00
06F20:  ADDWFC x48,W
06F22:  MOVWF  FEA
06F24:  MOVFF  FEF,649
06F28:  MOVFF  FEC,64A
06F2C:  MOVFF  FEC,64B
06F30:  MOVFF  FEC,64C
06F34:  MOVLW  01
06F36:  SUBWF  x43,W
06F38:  MULLW  20
06F3A:  MOVF   FF3,W
06F3C:  CLRF   x4E
06F3E:  MOVWF  x4D
06F40:  MOVLW  04
06F42:  ADDWF  x4D,W
06F44:  MOVWF  01
06F46:  MOVLW  00
06F48:  ADDWFC x4E,W
06F4A:  MOVWF  03
06F4C:  MOVF   01,W
06F4E:  ADDLW  20
06F50:  MOVWF  FE9
06F52:  MOVLW  00
06F54:  ADDWFC 03,W
06F56:  MOVWF  FEA
06F58:  MOVFF  FEF,64D
06F5C:  MOVFF  FEC,64E
06F60:  MOVFF  FEC,64F
06F64:  MOVFF  FEC,650
06F68:  MOVLW  01
06F6A:  SUBWF  x43,W
06F6C:  MULLW  20
06F6E:  MOVF   FF3,W
06F70:  CLRF   x52
06F72:  MOVWF  x51
06F74:  MOVLW  08
06F76:  ADDWF  x51,W
06F78:  MOVWF  01
06F7A:  MOVLW  00
06F7C:  ADDWFC x52,W
06F7E:  MOVWF  03
06F80:  MOVF   01,W
06F82:  ADDLW  20
06F84:  MOVWF  FE9
06F86:  MOVLW  00
06F88:  ADDWFC 03,W
06F8A:  MOVWF  FEA
06F8C:  MOVFF  FEF,651
06F90:  MOVFF  FEC,652
06F94:  MOVFF  FEC,653
06F98:  MOVFF  FEC,654
06F9C:  MOVFF  646,52F
06FA0:  MOVFF  645,52E
06FA4:  MOVFF  643,66C
06FA8:  MOVLW  18
06FAA:  MOVWF  x6D
06FAC:  MOVLB  0
06FAE:  CALL   61C6
06FB2:  MOVLW  2C
06FB4:  MOVLB  6
06FB6:  MOVWF  x88
06FB8:  MOVLB  0
06FBA:  CALL   5CBA
06FBE:  MOVLW  89
06FC0:  MOVWF  FE9
06FC2:  MOVFF  64C,67E
06FC6:  MOVFF  64B,67D
06FCA:  MOVFF  64A,67C
06FCE:  MOVFF  649,67B
06FD2:  MOVLW  02
06FD4:  MOVLB  6
06FD6:  MOVWF  x7F
06FD8:  MOVLB  0
06FDA:  RCALL  69E2
06FDC:  MOVLW  2C
06FDE:  MOVLB  6
06FE0:  MOVWF  x88
06FE2:  MOVLB  0
06FE4:  CALL   5CBA
06FE8:  MOVLW  89
06FEA:  MOVWF  FE9
06FEC:  MOVFF  650,67E
06FF0:  MOVFF  64F,67D
06FF4:  MOVFF  64E,67C
06FF8:  MOVFF  64D,67B
06FFC:  MOVLW  02
06FFE:  MOVLB  6
07000:  MOVWF  x7F
07002:  MOVLB  0
07004:  RCALL  69E2
07006:  MOVLW  2C
07008:  MOVLB  6
0700A:  MOVWF  x88
0700C:  MOVLB  0
0700E:  CALL   5CBA
07012:  MOVLW  89
07014:  MOVWF  FE9
07016:  MOVFF  654,67E
0701A:  MOVFF  653,67D
0701E:  MOVFF  652,67C
07022:  MOVFF  651,67B
07026:  MOVLW  02
07028:  MOVLB  6
0702A:  MOVWF  x7F
0702C:  MOVLB  0
0702E:  RCALL  69E2
07030:  MOVLW  2C
07032:  MOVLB  6
07034:  MOVWF  x88
07036:  MOVLB  0
07038:  CALL   5CBA
0703C:  BRA    7048
0703E:  MOVLB  6
....................    else return INV_PARAM;
07040:  MOVLW  02
07042:  MOVWF  01
07044:  MOVLB  0
07046:  BRA    704C
....................    
....................    return SUCCESS;
07048:  MOVLW  00
0704A:  MOVWF  01
0704C:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0736A:  MOVLB  6
0736C:  CLRF   x7A
0736E:  MOVFF  637,679
07372:  CLRF   x7C
07374:  MOVLW  B5
07376:  MOVWF  x7B
07378:  MOVLB  0
0737A:  CALL   0BBE
0737E:  MOVFF  02,64A
07382:  MOVFF  01,649
07386:  MOVLW  06
07388:  MOVLB  6
0738A:  ADDWF  x49,F
0738C:  MOVLW  00
0738E:  ADDWFC x4A,F
07390:  MOVLW  32
07392:  ADDWF  x49,W
07394:  MOVWF  01
07396:  MOVLW  00
07398:  ADDWFC x4A,W
0739A:  MOVWF  03
0739C:  MOVF   01,W
0739E:  ADDLW  B4
073A0:  MOVWF  01
073A2:  MOVLW  01
073A4:  ADDWFC 03,F
073A6:  MOVFF  01,649
073AA:  MOVFF  03,64A
073AE:  MOVFF  03,66C
073B2:  MOVFF  01,66B
073B6:  MOVLB  0
073B8:  CALL   5D82
073BC:  MOVF   01,F
073BE:  BNZ   73C8
073C0:  MOVLW  02
073C2:  MOVWF  01
073C4:  BRA    7648
073C6:  BRA    7426
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
073C8:  MOVLB  6
073CA:  CLRF   x7A
073CC:  MOVFF  637,679
073D0:  CLRF   x7C
073D2:  MOVLW  B5
073D4:  MOVWF  x7B
073D6:  MOVLB  0
073D8:  CALL   0BBE
073DC:  MOVFF  02,64A
073E0:  MOVFF  01,649
073E4:  MOVLW  06
073E6:  MOVLB  6
073E8:  ADDWF  x49,F
073EA:  MOVLW  00
073EC:  ADDWFC x4A,F
073EE:  MOVLW  32
073F0:  ADDWF  x49,W
073F2:  MOVWF  01
073F4:  MOVLW  00
073F6:  ADDWFC x4A,W
073F8:  MOVWF  03
073FA:  MOVF   01,W
073FC:  ADDLW  B4
073FE:  MOVWF  01
07400:  MOVLW  01
07402:  ADDWFC 03,F
07404:  MOVFF  01,649
07408:  MOVFF  03,64A
0740C:  MOVFF  03,66C
07410:  MOVFF  01,66B
07414:  CLRF   x6E
07416:  CLRF   x6D
07418:  MOVLW  0A
0741A:  MOVWF  x6F
0741C:  MOVLB  0
0741E:  CALL   5E72
07422:  MOVFF  01,643
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07426:  MOVLB  6
07428:  CLRF   x7A
0742A:  MOVFF  637,679
0742E:  CLRF   x7C
07430:  MOVLW  B5
07432:  MOVWF  x7B
07434:  MOVLB  0
07436:  CALL   0BBE
0743A:  MOVFF  02,64A
0743E:  MOVFF  01,649
07442:  MOVLW  06
07444:  MOVLB  6
07446:  ADDWF  x49,F
07448:  MOVLW  00
0744A:  ADDWFC x4A,F
0744C:  MOVLW  4B
0744E:  ADDWF  x49,W
07450:  MOVWF  01
07452:  MOVLW  00
07454:  ADDWFC x4A,W
07456:  MOVWF  03
07458:  MOVF   01,W
0745A:  ADDLW  B4
0745C:  MOVWF  01
0745E:  MOVLW  01
07460:  ADDWFC 03,F
07462:  MOVFF  01,649
07466:  MOVFF  03,64A
0746A:  MOVFF  03,67A
0746E:  MOVFF  01,679
07472:  MOVLB  0
07474:  CALL   5C0A
07478:  MOVFF  02,03
0747C:  MOVF   01,W
0747E:  SUBLW  01
07480:  BNZ   7486
07482:  MOVF   03,F
07484:  BZ    748E
07486:  MOVLW  02
07488:  MOVWF  01
0748A:  BRA    7648
0748C:  BRA    74CE
....................    else arg2 = SERcmd[rec].p[3][0];
0748E:  MOVLB  6
07490:  CLRF   x7A
07492:  MOVFF  637,679
07496:  CLRF   x7C
07498:  MOVLW  B5
0749A:  MOVWF  x7B
0749C:  MOVLB  0
0749E:  CALL   0BBE
074A2:  MOVFF  02,64A
074A6:  MOVFF  01,649
074AA:  MOVLW  06
074AC:  MOVLB  6
074AE:  ADDWF  x49,F
074B0:  MOVLW  00
074B2:  ADDWFC x4A,F
074B4:  MOVLW  4B
074B6:  ADDWF  x49,F
074B8:  MOVLW  00
074BA:  ADDWFC x4A,F
074BC:  MOVLW  B4
074BE:  ADDWF  x49,W
074C0:  MOVWF  FE9
074C2:  MOVLW  01
074C4:  ADDWFC x4A,W
074C6:  MOVWF  FEA
074C8:  MOVFF  FEF,644
074CC:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
074CE:  MOVLB  6
074D0:  CLRF   x7A
074D2:  MOVFF  637,679
074D6:  CLRF   x7C
074D8:  MOVLW  B5
074DA:  MOVWF  x7B
074DC:  MOVLB  0
074DE:  CALL   0BBE
074E2:  MOVFF  02,64A
074E6:  MOVFF  01,649
074EA:  MOVLW  06
074EC:  MOVLB  6
074EE:  ADDWF  x49,F
074F0:  MOVLW  00
074F2:  ADDWFC x4A,F
074F4:  MOVLW  64
074F6:  ADDWF  x49,W
074F8:  MOVWF  01
074FA:  MOVLW  00
074FC:  ADDWFC x4A,W
074FE:  MOVWF  03
07500:  MOVF   01,W
07502:  ADDLW  B4
07504:  MOVWF  01
07506:  MOVLW  01
07508:  ADDWFC 03,F
0750A:  MOVFF  01,649
0750E:  MOVFF  03,64A
07512:  MOVFF  03,64D
07516:  MOVFF  01,64C
0751A:  MOVLB  0
0751C:  RCALL  704E
0751E:  MOVF   01,F
07520:  BNZ   752A
07522:  MOVLW  02
07524:  MOVWF  01
07526:  BRA    7648
07528:  BRA    758E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0752A:  MOVLB  6
0752C:  CLRF   x7A
0752E:  MOVFF  637,679
07532:  CLRF   x7C
07534:  MOVLW  B5
07536:  MOVWF  x7B
07538:  MOVLB  0
0753A:  CALL   0BBE
0753E:  MOVFF  02,64A
07542:  MOVFF  01,649
07546:  MOVLW  06
07548:  MOVLB  6
0754A:  ADDWF  x49,F
0754C:  MOVLW  00
0754E:  ADDWFC x4A,F
07550:  MOVLW  64
07552:  ADDWF  x49,W
07554:  MOVWF  01
07556:  MOVLW  00
07558:  ADDWFC x4A,W
0755A:  MOVWF  03
0755C:  MOVF   01,W
0755E:  ADDLW  B4
07560:  MOVWF  01
07562:  MOVLW  01
07564:  ADDWFC 03,F
07566:  MOVFF  01,649
0756A:  MOVFF  03,64A
0756E:  MOVFF  03,64D
07572:  MOVFF  01,64C
07576:  CLRF   x4F
07578:  CLRF   x4E
0757A:  MOVLB  0
0757C:  RCALL  7110
0757E:  MOVFF  03,648
07582:  MOVFF  02,647
07586:  MOVFF  01,646
0758A:  MOVFF  00,645
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
0758E:  MOVLB  6
07590:  MOVF   x44,W
07592:  SUBLW  50
07594:  BNZ   75C0
07596:  MOVLW  01
07598:  SUBWF  x43,W
0759A:  MULLW  20
0759C:  MOVF   FF3,W
0759E:  CLRF   x4A
075A0:  MOVWF  x49
075A2:  MOVLW  20
075A4:  ADDWF  x49,W
075A6:  MOVWF  FE9
075A8:  MOVLW  00
075AA:  ADDWFC x4A,W
075AC:  MOVWF  FEA
075AE:  MOVFF  645,FEF
075B2:  MOVFF  646,FEC
075B6:  MOVFF  647,FEC
075BA:  MOVFF  648,FEC
075BE:  BRA    7642
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
075C0:  MOVF   x44,W
075C2:  SUBLW  49
075C4:  BNZ   75FC
075C6:  MOVLW  01
075C8:  SUBWF  x43,W
075CA:  MULLW  20
075CC:  MOVF   FF3,W
075CE:  CLRF   x4A
075D0:  MOVWF  x49
075D2:  MOVLW  04
075D4:  ADDWF  x49,W
075D6:  MOVWF  01
075D8:  MOVLW  00
075DA:  ADDWFC x4A,W
075DC:  MOVWF  03
075DE:  MOVF   01,W
075E0:  ADDLW  20
075E2:  MOVWF  FE9
075E4:  MOVLW  00
075E6:  ADDWFC 03,W
075E8:  MOVWF  FEA
075EA:  MOVFF  645,FEF
075EE:  MOVFF  646,FEC
075F2:  MOVFF  647,FEC
075F6:  MOVFF  648,FEC
075FA:  BRA    7642
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
075FC:  MOVF   x44,W
075FE:  SUBLW  44
07600:  BNZ   7638
07602:  MOVLW  01
07604:  SUBWF  x43,W
07606:  MULLW  20
07608:  MOVF   FF3,W
0760A:  CLRF   x4A
0760C:  MOVWF  x49
0760E:  MOVLW  08
07610:  ADDWF  x49,W
07612:  MOVWF  01
07614:  MOVLW  00
07616:  ADDWFC x4A,W
07618:  MOVWF  03
0761A:  MOVF   01,W
0761C:  ADDLW  20
0761E:  MOVWF  FE9
07620:  MOVLW  00
07622:  ADDWFC 03,W
07624:  MOVWF  FEA
07626:  MOVFF  645,FEF
0762A:  MOVFF  646,FEC
0762E:  MOVFF  647,FEC
07632:  MOVFF  648,FEC
07636:  BRA    7642
....................    else return INV_PARAM;
07638:  MOVLW  02
0763A:  MOVWF  01
0763C:  MOVLB  0
0763E:  BRA    7648
07640:  MOVLB  6
....................    
....................    return SUCCESS;
07642:  MOVLW  00
07644:  MOVWF  01
07646:  MOVLB  0
07648:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0764A:  MOVLB  6
0764C:  CLRF   x7A
0764E:  MOVFF  637,679
07652:  CLRF   x7C
07654:  MOVLW  B5
07656:  MOVWF  x7B
07658:  MOVLB  0
0765A:  CALL   0BBE
0765E:  MOVFF  02,645
07662:  MOVFF  01,644
07666:  MOVLW  06
07668:  MOVLB  6
0766A:  ADDWF  x44,F
0766C:  MOVLW  00
0766E:  ADDWFC x45,F
07670:  MOVLW  32
07672:  ADDWF  x44,W
07674:  MOVWF  01
07676:  MOVLW  00
07678:  ADDWFC x45,W
0767A:  MOVWF  03
0767C:  MOVF   01,W
0767E:  ADDLW  B4
07680:  MOVWF  01
07682:  MOVLW  01
07684:  ADDWFC 03,F
07686:  MOVFF  01,644
0768A:  MOVFF  03,645
0768E:  MOVFF  03,66C
07692:  MOVFF  01,66B
07696:  MOVLB  0
07698:  CALL   5D82
0769C:  MOVF   01,F
0769E:  BNZ   76A8
076A0:  MOVLW  02
076A2:  MOVWF  01
076A4:  BRA    77AA
076A6:  BRA    7706
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
076A8:  MOVLB  6
076AA:  CLRF   x7A
076AC:  MOVFF  637,679
076B0:  CLRF   x7C
076B2:  MOVLW  B5
076B4:  MOVWF  x7B
076B6:  MOVLB  0
076B8:  CALL   0BBE
076BC:  MOVFF  02,645
076C0:  MOVFF  01,644
076C4:  MOVLW  06
076C6:  MOVLB  6
076C8:  ADDWF  x44,F
076CA:  MOVLW  00
076CC:  ADDWFC x45,F
076CE:  MOVLW  32
076D0:  ADDWF  x44,W
076D2:  MOVWF  01
076D4:  MOVLW  00
076D6:  ADDWFC x45,W
076D8:  MOVWF  03
076DA:  MOVF   01,W
076DC:  ADDLW  B4
076DE:  MOVWF  01
076E0:  MOVLW  01
076E2:  ADDWFC 03,F
076E4:  MOVFF  01,644
076E8:  MOVFF  03,645
076EC:  MOVFF  03,66C
076F0:  MOVFF  01,66B
076F4:  CLRF   x6E
076F6:  CLRF   x6D
076F8:  MOVLW  0A
076FA:  MOVWF  x6F
076FC:  MOVLB  0
076FE:  CALL   5E72
07702:  MOVFF  01,643
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07706:  MOVLW  04
07708:  MOVLB  6
0770A:  MOVWF  x7A
0770C:  MOVLW  8A
0770E:  MOVWF  x79
07710:  MOVLB  0
07712:  CALL   5C0A
07716:  MOVF   01,W
07718:  ADDLW  8A
0771A:  MOVLB  6
0771C:  MOVWF  x44
0771E:  MOVLW  04
07720:  ADDWFC 02,W
07722:  MOVWF  x45
07724:  MOVLW  01
07726:  SUBWF  x43,W
07728:  MULLW  20
0772A:  MOVF   FF3,W
0772C:  CLRF   x47
0772E:  MOVWF  x46
07730:  MOVLW  0C
07732:  ADDWF  x46,W
07734:  MOVWF  01
07736:  MOVLW  00
07738:  ADDWFC x47,W
0773A:  MOVWF  03
0773C:  MOVF   01,W
0773E:  ADDLW  20
07740:  MOVWF  FE9
07742:  MOVLW  00
07744:  ADDWFC 03,W
07746:  MOVWF  FEA
07748:  MOVFF  FEF,646
0774C:  MOVFF  FEC,647
07750:  MOVFF  FEC,648
07754:  MOVFF  FEC,649
07758:  MOVFF  645,52F
0775C:  MOVFF  644,52E
07760:  MOVFF  643,66C
07764:  MOVLW  18
07766:  MOVWF  x6D
07768:  MOVLB  0
0776A:  CALL   61C6
0776E:  MOVLW  2C
07770:  MOVLB  6
07772:  MOVWF  x88
07774:  MOVLB  0
07776:  CALL   5CBA
0777A:  MOVLW  89
0777C:  MOVWF  FE9
0777E:  MOVFF  649,67E
07782:  MOVFF  648,67D
07786:  MOVFF  647,67C
0778A:  MOVFF  646,67B
0778E:  MOVLW  02
07790:  MOVLB  6
07792:  MOVWF  x7F
07794:  MOVLB  0
07796:  CALL   69E2
0779A:  MOVLW  2C
0779C:  MOVLB  6
0779E:  MOVWF  x88
077A0:  MOVLB  0
077A2:  CALL   5CBA
....................    return SUCCESS;
077A6:  MOVLW  00
077A8:  MOVWF  01
077AA:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
077AC:  MOVLB  6
077AE:  CLRF   x7A
077B0:  MOVFF  637,679
077B4:  CLRF   x7C
077B6:  MOVLW  B5
077B8:  MOVWF  x7B
077BA:  MOVLB  0
077BC:  CALL   0BBE
077C0:  MOVFF  02,649
077C4:  MOVFF  01,648
077C8:  MOVLW  06
077CA:  MOVLB  6
077CC:  ADDWF  x48,F
077CE:  MOVLW  00
077D0:  ADDWFC x49,F
077D2:  MOVLW  32
077D4:  ADDWF  x48,W
077D6:  MOVWF  01
077D8:  MOVLW  00
077DA:  ADDWFC x49,W
077DC:  MOVWF  03
077DE:  MOVF   01,W
077E0:  ADDLW  B4
077E2:  MOVWF  01
077E4:  MOVLW  01
077E6:  ADDWFC 03,F
077E8:  MOVFF  01,648
077EC:  MOVFF  03,649
077F0:  MOVFF  03,66C
077F4:  MOVFF  01,66B
077F8:  MOVLB  0
077FA:  CALL   5D82
077FE:  MOVF   01,F
07800:  BNZ   780A
07802:  MOVLW  02
07804:  MOVWF  01
07806:  BRA    7968
07808:  BRA    7868
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0780A:  MOVLB  6
0780C:  CLRF   x7A
0780E:  MOVFF  637,679
07812:  CLRF   x7C
07814:  MOVLW  B5
07816:  MOVWF  x7B
07818:  MOVLB  0
0781A:  CALL   0BBE
0781E:  MOVFF  02,649
07822:  MOVFF  01,648
07826:  MOVLW  06
07828:  MOVLB  6
0782A:  ADDWF  x48,F
0782C:  MOVLW  00
0782E:  ADDWFC x49,F
07830:  MOVLW  32
07832:  ADDWF  x48,W
07834:  MOVWF  01
07836:  MOVLW  00
07838:  ADDWFC x49,W
0783A:  MOVWF  03
0783C:  MOVF   01,W
0783E:  ADDLW  B4
07840:  MOVWF  01
07842:  MOVLW  01
07844:  ADDWFC 03,F
07846:  MOVFF  01,648
0784A:  MOVFF  03,649
0784E:  MOVFF  03,66C
07852:  MOVFF  01,66B
07856:  CLRF   x6E
07858:  CLRF   x6D
0785A:  MOVLW  0A
0785C:  MOVWF  x6F
0785E:  MOVLB  0
07860:  CALL   5E72
07864:  MOVFF  01,643
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07868:  MOVLB  6
0786A:  CLRF   x7A
0786C:  MOVFF  637,679
07870:  CLRF   x7C
07872:  MOVLW  B5
07874:  MOVWF  x7B
07876:  MOVLB  0
07878:  CALL   0BBE
0787C:  MOVFF  02,649
07880:  MOVFF  01,648
07884:  MOVLW  06
07886:  MOVLB  6
07888:  ADDWF  x48,F
0788A:  MOVLW  00
0788C:  ADDWFC x49,F
0788E:  MOVLW  4B
07890:  ADDWF  x48,W
07892:  MOVWF  01
07894:  MOVLW  00
07896:  ADDWFC x49,W
07898:  MOVWF  03
0789A:  MOVF   01,W
0789C:  ADDLW  B4
0789E:  MOVWF  01
078A0:  MOVLW  01
078A2:  ADDWFC 03,F
078A4:  MOVFF  01,648
078A8:  MOVFF  03,649
078AC:  MOVFF  03,64D
078B0:  MOVFF  01,64C
078B4:  MOVLB  0
078B6:  CALL   704E
078BA:  MOVF   01,F
078BC:  BNZ   78C6
078BE:  MOVLW  02
078C0:  MOVWF  01
078C2:  BRA    7968
078C4:  BRA    792C
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
078C6:  MOVLB  6
078C8:  CLRF   x7A
078CA:  MOVFF  637,679
078CE:  CLRF   x7C
078D0:  MOVLW  B5
078D2:  MOVWF  x7B
078D4:  MOVLB  0
078D6:  CALL   0BBE
078DA:  MOVFF  02,649
078DE:  MOVFF  01,648
078E2:  MOVLW  06
078E4:  MOVLB  6
078E6:  ADDWF  x48,F
078E8:  MOVLW  00
078EA:  ADDWFC x49,F
078EC:  MOVLW  4B
078EE:  ADDWF  x48,W
078F0:  MOVWF  01
078F2:  MOVLW  00
078F4:  ADDWFC x49,W
078F6:  MOVWF  03
078F8:  MOVF   01,W
078FA:  ADDLW  B4
078FC:  MOVWF  01
078FE:  MOVLW  01
07900:  ADDWFC 03,F
07902:  MOVFF  01,648
07906:  MOVFF  03,649
0790A:  MOVFF  03,64D
0790E:  MOVFF  01,64C
07912:  CLRF   x4F
07914:  CLRF   x4E
07916:  MOVLB  0
07918:  CALL   7110
0791C:  MOVFF  03,647
07920:  MOVFF  02,646
07924:  MOVFF  01,645
07928:  MOVFF  00,644
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0792C:  MOVLW  01
0792E:  MOVLB  6
07930:  SUBWF  x43,W
07932:  MULLW  20
07934:  MOVF   FF3,W
07936:  CLRF   x49
07938:  MOVWF  x48
0793A:  MOVLW  0C
0793C:  ADDWF  x48,W
0793E:  MOVWF  01
07940:  MOVLW  00
07942:  ADDWFC x49,W
07944:  MOVWF  03
07946:  MOVF   01,W
07948:  ADDLW  20
0794A:  MOVWF  FE9
0794C:  MOVLW  00
0794E:  ADDWFC 03,W
07950:  MOVWF  FEA
07952:  MOVFF  644,FEF
07956:  MOVFF  645,FEC
0795A:  MOVFF  646,FEC
0795E:  MOVFF  647,FEC
....................    
....................    return SUCCESS;
07962:  MOVLW  00
07964:  MOVWF  01
07966:  MOVLB  0
07968:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0796A:  MOVLB  6
0796C:  CLRF   x7A
0796E:  MOVFF  637,679
07972:  CLRF   x7C
07974:  MOVLW  B5
07976:  MOVWF  x7B
07978:  MOVLB  0
0797A:  CALL   0BBE
0797E:  MOVFF  02,645
07982:  MOVFF  01,644
07986:  MOVLW  06
07988:  MOVLB  6
0798A:  ADDWF  x44,F
0798C:  MOVLW  00
0798E:  ADDWFC x45,F
07990:  MOVLW  32
07992:  ADDWF  x44,W
07994:  MOVWF  01
07996:  MOVLW  00
07998:  ADDWFC x45,W
0799A:  MOVWF  03
0799C:  MOVF   01,W
0799E:  ADDLW  B4
079A0:  MOVWF  01
079A2:  MOVLW  01
079A4:  ADDWFC 03,F
079A6:  MOVFF  01,644
079AA:  MOVFF  03,645
079AE:  MOVFF  03,66C
079B2:  MOVFF  01,66B
079B6:  MOVLB  0
079B8:  CALL   5D82
079BC:  MOVF   01,F
079BE:  BNZ   79C8
079C0:  MOVLW  02
079C2:  MOVWF  01
079C4:  BRA    7D1E
079C6:  BRA    7A26
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
079C8:  MOVLB  6
079CA:  CLRF   x7A
079CC:  MOVFF  637,679
079D0:  CLRF   x7C
079D2:  MOVLW  B5
079D4:  MOVWF  x7B
079D6:  MOVLB  0
079D8:  CALL   0BBE
079DC:  MOVFF  02,645
079E0:  MOVFF  01,644
079E4:  MOVLW  06
079E6:  MOVLB  6
079E8:  ADDWF  x44,F
079EA:  MOVLW  00
079EC:  ADDWFC x45,F
079EE:  MOVLW  32
079F0:  ADDWF  x44,W
079F2:  MOVWF  01
079F4:  MOVLW  00
079F6:  ADDWFC x45,W
079F8:  MOVWF  03
079FA:  MOVF   01,W
079FC:  ADDLW  B4
079FE:  MOVWF  01
07A00:  MOVLW  01
07A02:  ADDWFC 03,F
07A04:  MOVFF  01,644
07A08:  MOVFF  03,645
07A0C:  MOVFF  03,66C
07A10:  MOVFF  01,66B
07A14:  CLRF   x6E
07A16:  CLRF   x6D
07A18:  MOVLW  0A
07A1A:  MOVWF  x6F
07A1C:  MOVLB  0
07A1E:  CALL   5E72
07A22:  MOVFF  01,643
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07A26:  MOVLW  04
07A28:  MOVLB  6
07A2A:  MOVWF  x7A
07A2C:  MOVLW  8A
07A2E:  MOVWF  x79
07A30:  MOVLB  0
07A32:  CALL   5C0A
07A36:  MOVFF  02,03
07A3A:  MOVF   01,W
07A3C:  ADDLW  8A
07A3E:  MOVLB  6
07A40:  MOVWF  x44
07A42:  MOVLW  04
07A44:  ADDWFC 02,W
07A46:  MOVWF  x45
07A48:  MOVFF  FE8,52F
07A4C:  MOVFF  644,52E
07A50:  MOVFF  643,66C
07A54:  MOVLW  18
07A56:  MOVWF  x6D
07A58:  MOVLB  0
07A5A:  CALL   61C6
07A5E:  MOVLW  2C
07A60:  MOVLB  6
07A62:  MOVWF  x88
07A64:  MOVLB  0
07A66:  CALL   5CBA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07A6A:  MOVLW  04
07A6C:  MOVLB  6
07A6E:  MOVWF  x7A
07A70:  MOVLW  8A
07A72:  MOVWF  x79
07A74:  MOVLB  0
07A76:  CALL   5C0A
07A7A:  MOVFF  02,03
07A7E:  MOVF   01,W
07A80:  ADDLW  8A
07A82:  MOVLB  6
07A84:  MOVWF  x44
07A86:  MOVLW  04
07A88:  ADDWFC 02,W
07A8A:  MOVWF  x45
07A8C:  MOVLW  01
07A8E:  SUBWF  x43,W
07A90:  MULLW  18
07A92:  MOVF   FF3,W
07A94:  CLRF   x47
07A96:  MOVWF  x46
07A98:  MOVLW  82
07A9A:  ADDWF  x46,W
07A9C:  MOVWF  FE9
07A9E:  MOVLW  00
07AA0:  ADDWFC x47,W
07AA2:  MOVWF  FEA
07AA4:  MOVFF  FEF,67B
07AA8:  MOVFF  FEC,67C
07AAC:  MOVFF  FEC,67D
07AB0:  MOVFF  FEC,67E
07AB4:  MOVFF  645,52F
07AB8:  MOVFF  644,52E
07ABC:  MOVLW  89
07ABE:  MOVWF  FE9
07AC0:  MOVLW  02
07AC2:  MOVWF  x7F
07AC4:  MOVLB  0
07AC6:  CALL   69E2
07ACA:  MOVLW  2C
07ACC:  MOVLB  6
07ACE:  MOVWF  x88
07AD0:  MOVLB  0
07AD2:  CALL   5CBA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07AD6:  MOVLW  04
07AD8:  MOVLB  6
07ADA:  MOVWF  x7A
07ADC:  MOVLW  8A
07ADE:  MOVWF  x79
07AE0:  MOVLB  0
07AE2:  CALL   5C0A
07AE6:  MOVF   01,W
07AE8:  ADDLW  8A
07AEA:  MOVLB  6
07AEC:  MOVWF  x44
07AEE:  MOVLW  04
07AF0:  ADDWFC 02,W
07AF2:  MOVWF  x45
07AF4:  MOVLW  01
07AF6:  SUBWF  x43,W
07AF8:  MULLW  18
07AFA:  MOVF   FF3,W
07AFC:  CLRF   x47
07AFE:  MOVWF  x46
07B00:  MOVLW  04
07B02:  ADDWF  x46,W
07B04:  MOVWF  01
07B06:  MOVLW  00
07B08:  ADDWFC x47,W
07B0A:  MOVWF  03
07B0C:  MOVF   01,W
07B0E:  ADDLW  82
07B10:  MOVWF  FE9
07B12:  MOVLW  00
07B14:  ADDWFC 03,W
07B16:  MOVWF  FEA
07B18:  MOVFF  FEF,67B
07B1C:  MOVFF  FEC,67C
07B20:  MOVFF  FEC,67D
07B24:  MOVFF  FEC,67E
07B28:  MOVFF  645,52F
07B2C:  MOVFF  644,52E
07B30:  MOVLW  89
07B32:  MOVWF  FE9
07B34:  MOVLW  02
07B36:  MOVWF  x7F
07B38:  MOVLB  0
07B3A:  CALL   69E2
07B3E:  MOVLW  2C
07B40:  MOVLB  6
07B42:  MOVWF  x88
07B44:  MOVLB  0
07B46:  CALL   5CBA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07B4A:  MOVLW  04
07B4C:  MOVLB  6
07B4E:  MOVWF  x7A
07B50:  MOVLW  8A
07B52:  MOVWF  x79
07B54:  MOVLB  0
07B56:  CALL   5C0A
07B5A:  MOVF   01,W
07B5C:  ADDLW  8A
07B5E:  MOVLB  6
07B60:  MOVWF  x44
07B62:  MOVLW  04
07B64:  ADDWFC 02,W
07B66:  MOVWF  x45
07B68:  MOVLW  01
07B6A:  SUBWF  x43,W
07B6C:  MULLW  18
07B6E:  MOVF   FF3,W
07B70:  CLRF   x47
07B72:  MOVWF  x46
07B74:  MOVLW  08
07B76:  ADDWF  x46,W
07B78:  MOVWF  01
07B7A:  MOVLW  00
07B7C:  ADDWFC x47,W
07B7E:  MOVWF  03
07B80:  MOVF   01,W
07B82:  ADDLW  82
07B84:  MOVWF  FE9
07B86:  MOVLW  00
07B88:  ADDWFC 03,W
07B8A:  MOVWF  FEA
07B8C:  MOVFF  FEF,67B
07B90:  MOVFF  FEC,67C
07B94:  MOVFF  FEC,67D
07B98:  MOVFF  FEC,67E
07B9C:  MOVFF  645,52F
07BA0:  MOVFF  644,52E
07BA4:  MOVLW  89
07BA6:  MOVWF  FE9
07BA8:  MOVLW  02
07BAA:  MOVWF  x7F
07BAC:  MOVLB  0
07BAE:  CALL   69E2
07BB2:  MOVLW  2C
07BB4:  MOVLB  6
07BB6:  MOVWF  x88
07BB8:  MOVLB  0
07BBA:  CALL   5CBA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
07BBE:  MOVLW  04
07BC0:  MOVLB  6
07BC2:  MOVWF  x7A
07BC4:  MOVLW  8A
07BC6:  MOVWF  x79
07BC8:  MOVLB  0
07BCA:  CALL   5C0A
07BCE:  MOVF   01,W
07BD0:  ADDLW  8A
07BD2:  MOVLB  6
07BD4:  MOVWF  x44
07BD6:  MOVLW  04
07BD8:  ADDWFC 02,W
07BDA:  MOVWF  x45
07BDC:  MOVLW  01
07BDE:  SUBWF  x43,W
07BE0:  MULLW  18
07BE2:  MOVF   FF3,W
07BE4:  CLRF   x47
07BE6:  MOVWF  x46
07BE8:  MOVLW  0C
07BEA:  ADDWF  x46,W
07BEC:  MOVWF  01
07BEE:  MOVLW  00
07BF0:  ADDWFC x47,W
07BF2:  MOVWF  03
07BF4:  MOVF   01,W
07BF6:  ADDLW  82
07BF8:  MOVWF  FE9
07BFA:  MOVLW  00
07BFC:  ADDWFC 03,W
07BFE:  MOVWF  FEA
07C00:  MOVFF  FEF,67B
07C04:  MOVFF  FEC,67C
07C08:  MOVFF  FEC,67D
07C0C:  MOVFF  FEC,67E
07C10:  MOVFF  645,52F
07C14:  MOVFF  644,52E
07C18:  MOVLW  89
07C1A:  MOVWF  FE9
07C1C:  MOVLW  02
07C1E:  MOVWF  x7F
07C20:  MOVLB  0
07C22:  CALL   69E2
07C26:  MOVLW  2C
07C28:  MOVLB  6
07C2A:  MOVWF  x88
07C2C:  MOVLB  0
07C2E:  CALL   5CBA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07C32:  MOVLW  04
07C34:  MOVLB  6
07C36:  MOVWF  x7A
07C38:  MOVLW  8A
07C3A:  MOVWF  x79
07C3C:  MOVLB  0
07C3E:  CALL   5C0A
07C42:  MOVF   01,W
07C44:  ADDLW  8A
07C46:  MOVLB  6
07C48:  MOVWF  x44
07C4A:  MOVLW  04
07C4C:  ADDWFC 02,W
07C4E:  MOVWF  x45
07C50:  MOVLW  01
07C52:  SUBWF  x43,W
07C54:  MULLW  18
07C56:  MOVF   FF3,W
07C58:  CLRF   x47
07C5A:  MOVWF  x46
07C5C:  MOVLW  10
07C5E:  ADDWF  x46,W
07C60:  MOVWF  01
07C62:  MOVLW  00
07C64:  ADDWFC x47,W
07C66:  MOVWF  03
07C68:  MOVF   01,W
07C6A:  ADDLW  82
07C6C:  MOVWF  FE9
07C6E:  MOVLW  00
07C70:  ADDWFC 03,W
07C72:  MOVWF  FEA
07C74:  MOVFF  FEF,67B
07C78:  MOVFF  FEC,67C
07C7C:  MOVFF  FEC,67D
07C80:  MOVFF  FEC,67E
07C84:  MOVFF  645,52F
07C88:  MOVFF  644,52E
07C8C:  MOVLW  89
07C8E:  MOVWF  FE9
07C90:  MOVLW  02
07C92:  MOVWF  x7F
07C94:  MOVLB  0
07C96:  CALL   69E2
07C9A:  MOVLW  2C
07C9C:  MOVLB  6
07C9E:  MOVWF  x88
07CA0:  MOVLB  0
07CA2:  CALL   5CBA
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07CA6:  MOVLW  04
07CA8:  MOVLB  6
07CAA:  MOVWF  x7A
07CAC:  MOVLW  8A
07CAE:  MOVWF  x79
07CB0:  MOVLB  0
07CB2:  CALL   5C0A
07CB6:  MOVF   01,W
07CB8:  ADDLW  8A
07CBA:  MOVLB  6
07CBC:  MOVWF  x44
07CBE:  MOVLW  04
07CC0:  ADDWFC 02,W
07CC2:  MOVWF  x45
07CC4:  MOVLW  01
07CC6:  SUBWF  x43,W
07CC8:  MULLW  18
07CCA:  MOVF   FF3,W
07CCC:  CLRF   x47
07CCE:  MOVWF  x46
07CD0:  MOVLW  14
07CD2:  ADDWF  x46,W
07CD4:  MOVWF  01
07CD6:  MOVLW  00
07CD8:  ADDWFC x47,W
07CDA:  MOVWF  03
07CDC:  MOVF   01,W
07CDE:  ADDLW  82
07CE0:  MOVWF  FE9
07CE2:  MOVLW  00
07CE4:  ADDWFC 03,W
07CE6:  MOVWF  FEA
07CE8:  MOVFF  FEF,67B
07CEC:  MOVFF  FEC,67C
07CF0:  MOVFF  FEC,67D
07CF4:  MOVFF  FEC,67E
07CF8:  MOVFF  645,52F
07CFC:  MOVFF  644,52E
07D00:  MOVLW  89
07D02:  MOVWF  FE9
07D04:  MOVLW  02
07D06:  MOVWF  x7F
07D08:  MOVLB  0
07D0A:  CALL   69E2
07D0E:  MOVLW  2C
07D10:  MOVLB  6
07D12:  MOVWF  x88
07D14:  MOVLB  0
07D16:  CALL   5CBA
....................    
....................    return SUCCESS;
07D1A:  MOVLW  00
07D1C:  MOVWF  01
07D1E:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07D20:  MOVLB  6
07D22:  CLRF   x7A
07D24:  MOVFF  637,679
07D28:  CLRF   x7C
07D2A:  MOVLW  B5
07D2C:  MOVWF  x7B
07D2E:  MOVLB  0
07D30:  CALL   0BBE
07D34:  MOVFF  02,646
07D38:  MOVFF  01,645
07D3C:  MOVLW  06
07D3E:  MOVLB  6
07D40:  ADDWF  x45,F
07D42:  MOVLW  00
07D44:  ADDWFC x46,F
07D46:  MOVLW  32
07D48:  ADDWF  x45,W
07D4A:  MOVWF  01
07D4C:  MOVLW  00
07D4E:  ADDWFC x46,W
07D50:  MOVWF  03
07D52:  MOVF   01,W
07D54:  ADDLW  B4
07D56:  MOVWF  01
07D58:  MOVLW  01
07D5A:  ADDWFC 03,F
07D5C:  MOVFF  01,645
07D60:  MOVFF  03,646
07D64:  MOVFF  03,66C
07D68:  MOVFF  01,66B
07D6C:  MOVLB  0
07D6E:  CALL   5D82
07D72:  MOVF   01,F
07D74:  BNZ   7D7E
07D76:  MOVLW  02
07D78:  MOVWF  01
07D7A:  BRA    827A
07D7C:  BRA    7DDC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07D7E:  MOVLB  6
07D80:  CLRF   x7A
07D82:  MOVFF  637,679
07D86:  CLRF   x7C
07D88:  MOVLW  B5
07D8A:  MOVWF  x7B
07D8C:  MOVLB  0
07D8E:  CALL   0BBE
07D92:  MOVFF  02,646
07D96:  MOVFF  01,645
07D9A:  MOVLW  06
07D9C:  MOVLB  6
07D9E:  ADDWF  x45,F
07DA0:  MOVLW  00
07DA2:  ADDWFC x46,F
07DA4:  MOVLW  32
07DA6:  ADDWF  x45,W
07DA8:  MOVWF  01
07DAA:  MOVLW  00
07DAC:  ADDWFC x46,W
07DAE:  MOVWF  03
07DB0:  MOVF   01,W
07DB2:  ADDLW  B4
07DB4:  MOVWF  01
07DB6:  MOVLW  01
07DB8:  ADDWFC 03,F
07DBA:  MOVFF  01,645
07DBE:  MOVFF  03,646
07DC2:  MOVFF  03,66C
07DC6:  MOVFF  01,66B
07DCA:  CLRF   x6E
07DCC:  CLRF   x6D
07DCE:  MOVLW  0A
07DD0:  MOVWF  x6F
07DD2:  MOVLB  0
07DD4:  CALL   5E72
07DD8:  MOVFF  01,643
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07DDC:  MOVLB  6
07DDE:  CLRF   x7A
07DE0:  MOVFF  637,679
07DE4:  CLRF   x7C
07DE6:  MOVLW  B5
07DE8:  MOVWF  x7B
07DEA:  MOVLB  0
07DEC:  CALL   0BBE
07DF0:  MOVFF  02,646
07DF4:  MOVFF  01,645
07DF8:  MOVLW  06
07DFA:  MOVLB  6
07DFC:  ADDWF  x45,F
07DFE:  MOVLW  00
07E00:  ADDWFC x46,F
07E02:  MOVLW  4B
07E04:  ADDWF  x45,W
07E06:  MOVWF  01
07E08:  MOVLW  00
07E0A:  ADDWFC x46,W
07E0C:  MOVWF  03
07E0E:  MOVF   01,W
07E10:  ADDLW  B4
07E12:  MOVWF  01
07E14:  MOVLW  01
07E16:  ADDWFC 03,F
07E18:  MOVFF  01,645
07E1C:  MOVFF  03,646
07E20:  MOVFF  03,67A
07E24:  MOVFF  01,679
07E28:  MOVLB  0
07E2A:  CALL   5C0A
07E2E:  MOVFF  02,03
07E32:  MOVF   01,W
07E34:  SUBLW  01
07E36:  BNZ   7E3C
07E38:  MOVF   03,F
07E3A:  BZ    7E44
07E3C:  MOVLW  02
07E3E:  MOVWF  01
07E40:  BRA    827A
07E42:  BRA    7E84
....................    else arg2 = SERcmd[rec].p[3][0];
07E44:  MOVLB  6
07E46:  CLRF   x7A
07E48:  MOVFF  637,679
07E4C:  CLRF   x7C
07E4E:  MOVLW  B5
07E50:  MOVWF  x7B
07E52:  MOVLB  0
07E54:  CALL   0BBE
07E58:  MOVFF  02,646
07E5C:  MOVFF  01,645
07E60:  MOVLW  06
07E62:  MOVLB  6
07E64:  ADDWF  x45,F
07E66:  MOVLW  00
07E68:  ADDWFC x46,F
07E6A:  MOVLW  4B
07E6C:  ADDWF  x45,F
07E6E:  MOVLW  00
07E70:  ADDWFC x46,F
07E72:  MOVLW  B4
07E74:  ADDWF  x45,W
07E76:  MOVWF  FE9
07E78:  MOVLW  01
07E7A:  ADDWFC x46,W
07E7C:  MOVWF  FEA
07E7E:  MOVFF  FEF,644
07E82:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07E84:  MOVLB  6
07E86:  MOVF   x44,W
07E88:  SUBLW  30
07E8A:  BNZ   7F26
07E8C:  MOVLW  04
07E8E:  MOVWF  x7A
07E90:  MOVLW  8A
07E92:  MOVWF  x79
07E94:  MOVLB  0
07E96:  CALL   5C0A
07E9A:  MOVFF  02,03
07E9E:  MOVF   01,W
07EA0:  ADDLW  8A
07EA2:  MOVLB  6
07EA4:  MOVWF  x45
07EA6:  MOVLW  04
07EA8:  ADDWFC 02,W
07EAA:  MOVWF  x46
07EAC:  MOVLW  01
07EAE:  SUBWF  x43,W
07EB0:  MULLW  18
07EB2:  MOVF   FF3,W
07EB4:  CLRF   x48
07EB6:  MOVWF  x47
07EB8:  MOVLW  82
07EBA:  ADDWF  x47,W
07EBC:  MOVWF  FE9
07EBE:  MOVLW  00
07EC0:  ADDWFC x48,W
07EC2:  MOVWF  FEA
07EC4:  MOVFF  FEF,649
07EC8:  MOVFF  FEC,64A
07ECC:  MOVFF  FEC,64B
07ED0:  MOVFF  FEC,64C
07ED4:  MOVFF  646,52F
07ED8:  MOVFF  645,52E
07EDC:  MOVFF  643,66C
07EE0:  MOVLW  18
07EE2:  MOVWF  x6D
07EE4:  MOVLB  0
07EE6:  CALL   61C6
07EEA:  MOVLW  2C
07EEC:  MOVLB  6
07EEE:  MOVWF  x88
07EF0:  MOVLB  0
07EF2:  CALL   5CBA
07EF6:  MOVLW  89
07EF8:  MOVWF  FE9
07EFA:  MOVFF  64C,67E
07EFE:  MOVFF  64B,67D
07F02:  MOVFF  64A,67C
07F06:  MOVFF  649,67B
07F0A:  MOVLW  02
07F0C:  MOVLB  6
07F0E:  MOVWF  x7F
07F10:  MOVLB  0
07F12:  CALL   69E2
07F16:  MOVLW  2C
07F18:  MOVLB  6
07F1A:  MOVWF  x88
07F1C:  MOVLB  0
07F1E:  CALL   5CBA
07F22:  BRA    8276
07F24:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07F26:  MOVF   x44,W
07F28:  SUBLW  31
07F2A:  BNZ   7FCE
07F2C:  MOVLW  04
07F2E:  MOVWF  x7A
07F30:  MOVLW  8A
07F32:  MOVWF  x79
07F34:  MOVLB  0
07F36:  CALL   5C0A
07F3A:  MOVF   01,W
07F3C:  ADDLW  8A
07F3E:  MOVLB  6
07F40:  MOVWF  x45
07F42:  MOVLW  04
07F44:  ADDWFC 02,W
07F46:  MOVWF  x46
07F48:  MOVLW  01
07F4A:  SUBWF  x43,W
07F4C:  MULLW  18
07F4E:  MOVF   FF3,W
07F50:  CLRF   x48
07F52:  MOVWF  x47
07F54:  MOVLW  04
07F56:  ADDWF  x47,W
07F58:  MOVWF  01
07F5A:  MOVLW  00
07F5C:  ADDWFC x48,W
07F5E:  MOVWF  03
07F60:  MOVF   01,W
07F62:  ADDLW  82
07F64:  MOVWF  FE9
07F66:  MOVLW  00
07F68:  ADDWFC 03,W
07F6A:  MOVWF  FEA
07F6C:  MOVFF  FEF,647
07F70:  MOVFF  FEC,648
07F74:  MOVFF  FEC,649
07F78:  MOVFF  FEC,64A
07F7C:  MOVFF  646,52F
07F80:  MOVFF  645,52E
07F84:  MOVFF  643,66C
07F88:  MOVLW  18
07F8A:  MOVWF  x6D
07F8C:  MOVLB  0
07F8E:  CALL   61C6
07F92:  MOVLW  2C
07F94:  MOVLB  6
07F96:  MOVWF  x88
07F98:  MOVLB  0
07F9A:  CALL   5CBA
07F9E:  MOVLW  89
07FA0:  MOVWF  FE9
07FA2:  MOVFF  64A,67E
07FA6:  MOVFF  649,67D
07FAA:  MOVFF  648,67C
07FAE:  MOVFF  647,67B
07FB2:  MOVLW  02
07FB4:  MOVLB  6
07FB6:  MOVWF  x7F
07FB8:  MOVLB  0
07FBA:  CALL   69E2
07FBE:  MOVLW  2C
07FC0:  MOVLB  6
07FC2:  MOVWF  x88
07FC4:  MOVLB  0
07FC6:  CALL   5CBA
07FCA:  BRA    8276
07FCC:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07FCE:  MOVF   x44,W
07FD0:  SUBLW  32
07FD2:  BNZ   8076
07FD4:  MOVLW  04
07FD6:  MOVWF  x7A
07FD8:  MOVLW  8A
07FDA:  MOVWF  x79
07FDC:  MOVLB  0
07FDE:  CALL   5C0A
07FE2:  MOVF   01,W
07FE4:  ADDLW  8A
07FE6:  MOVLB  6
07FE8:  MOVWF  x45
07FEA:  MOVLW  04
07FEC:  ADDWFC 02,W
07FEE:  MOVWF  x46
07FF0:  MOVLW  01
07FF2:  SUBWF  x43,W
07FF4:  MULLW  18
07FF6:  MOVF   FF3,W
07FF8:  CLRF   x48
07FFA:  MOVWF  x47
07FFC:  MOVLW  08
07FFE:  ADDWF  x47,W
08000:  MOVWF  01
08002:  MOVLW  00
08004:  ADDWFC x48,W
08006:  MOVWF  03
08008:  MOVF   01,W
0800A:  ADDLW  82
0800C:  MOVWF  FE9
0800E:  MOVLW  00
08010:  ADDWFC 03,W
08012:  MOVWF  FEA
08014:  MOVFF  FEF,647
08018:  MOVFF  FEC,648
0801C:  MOVFF  FEC,649
08020:  MOVFF  FEC,64A
08024:  MOVFF  646,52F
08028:  MOVFF  645,52E
0802C:  MOVFF  643,66C
08030:  MOVLW  18
08032:  MOVWF  x6D
08034:  MOVLB  0
08036:  CALL   61C6
0803A:  MOVLW  2C
0803C:  MOVLB  6
0803E:  MOVWF  x88
08040:  MOVLB  0
08042:  CALL   5CBA
08046:  MOVLW  89
08048:  MOVWF  FE9
0804A:  MOVFF  64A,67E
0804E:  MOVFF  649,67D
08052:  MOVFF  648,67C
08056:  MOVFF  647,67B
0805A:  MOVLW  02
0805C:  MOVLB  6
0805E:  MOVWF  x7F
08060:  MOVLB  0
08062:  CALL   69E2
08066:  MOVLW  2C
08068:  MOVLB  6
0806A:  MOVWF  x88
0806C:  MOVLB  0
0806E:  CALL   5CBA
08072:  BRA    8276
08074:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
08076:  MOVF   x44,W
08078:  SUBLW  33
0807A:  BNZ   811E
0807C:  MOVLW  04
0807E:  MOVWF  x7A
08080:  MOVLW  8A
08082:  MOVWF  x79
08084:  MOVLB  0
08086:  CALL   5C0A
0808A:  MOVF   01,W
0808C:  ADDLW  8A
0808E:  MOVLB  6
08090:  MOVWF  x45
08092:  MOVLW  04
08094:  ADDWFC 02,W
08096:  MOVWF  x46
08098:  MOVLW  01
0809A:  SUBWF  x43,W
0809C:  MULLW  18
0809E:  MOVF   FF3,W
080A0:  CLRF   x48
080A2:  MOVWF  x47
080A4:  MOVLW  0C
080A6:  ADDWF  x47,W
080A8:  MOVWF  01
080AA:  MOVLW  00
080AC:  ADDWFC x48,W
080AE:  MOVWF  03
080B0:  MOVF   01,W
080B2:  ADDLW  82
080B4:  MOVWF  FE9
080B6:  MOVLW  00
080B8:  ADDWFC 03,W
080BA:  MOVWF  FEA
080BC:  MOVFF  FEF,647
080C0:  MOVFF  FEC,648
080C4:  MOVFF  FEC,649
080C8:  MOVFF  FEC,64A
080CC:  MOVFF  646,52F
080D0:  MOVFF  645,52E
080D4:  MOVFF  643,66C
080D8:  MOVLW  18
080DA:  MOVWF  x6D
080DC:  MOVLB  0
080DE:  CALL   61C6
080E2:  MOVLW  2C
080E4:  MOVLB  6
080E6:  MOVWF  x88
080E8:  MOVLB  0
080EA:  CALL   5CBA
080EE:  MOVLW  89
080F0:  MOVWF  FE9
080F2:  MOVFF  64A,67E
080F6:  MOVFF  649,67D
080FA:  MOVFF  648,67C
080FE:  MOVFF  647,67B
08102:  MOVLW  02
08104:  MOVLB  6
08106:  MOVWF  x7F
08108:  MOVLB  0
0810A:  CALL   69E2
0810E:  MOVLW  2C
08110:  MOVLB  6
08112:  MOVWF  x88
08114:  MOVLB  0
08116:  CALL   5CBA
0811A:  BRA    8276
0811C:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
0811E:  MOVF   x44,W
08120:  SUBLW  34
08122:  BNZ   81C6
08124:  MOVLW  04
08126:  MOVWF  x7A
08128:  MOVLW  8A
0812A:  MOVWF  x79
0812C:  MOVLB  0
0812E:  CALL   5C0A
08132:  MOVF   01,W
08134:  ADDLW  8A
08136:  MOVLB  6
08138:  MOVWF  x45
0813A:  MOVLW  04
0813C:  ADDWFC 02,W
0813E:  MOVWF  x46
08140:  MOVLW  01
08142:  SUBWF  x43,W
08144:  MULLW  18
08146:  MOVF   FF3,W
08148:  CLRF   x48
0814A:  MOVWF  x47
0814C:  MOVLW  10
0814E:  ADDWF  x47,W
08150:  MOVWF  01
08152:  MOVLW  00
08154:  ADDWFC x48,W
08156:  MOVWF  03
08158:  MOVF   01,W
0815A:  ADDLW  82
0815C:  MOVWF  FE9
0815E:  MOVLW  00
08160:  ADDWFC 03,W
08162:  MOVWF  FEA
08164:  MOVFF  FEF,647
08168:  MOVFF  FEC,648
0816C:  MOVFF  FEC,649
08170:  MOVFF  FEC,64A
08174:  MOVFF  646,52F
08178:  MOVFF  645,52E
0817C:  MOVFF  643,66C
08180:  MOVLW  18
08182:  MOVWF  x6D
08184:  MOVLB  0
08186:  CALL   61C6
0818A:  MOVLW  2C
0818C:  MOVLB  6
0818E:  MOVWF  x88
08190:  MOVLB  0
08192:  CALL   5CBA
08196:  MOVLW  89
08198:  MOVWF  FE9
0819A:  MOVFF  64A,67E
0819E:  MOVFF  649,67D
081A2:  MOVFF  648,67C
081A6:  MOVFF  647,67B
081AA:  MOVLW  02
081AC:  MOVLB  6
081AE:  MOVWF  x7F
081B0:  MOVLB  0
081B2:  CALL   69E2
081B6:  MOVLW  2C
081B8:  MOVLB  6
081BA:  MOVWF  x88
081BC:  MOVLB  0
081BE:  CALL   5CBA
081C2:  BRA    8276
081C4:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
081C6:  MOVF   x44,W
081C8:  SUBLW  35
081CA:  BNZ   826E
081CC:  MOVLW  04
081CE:  MOVWF  x7A
081D0:  MOVLW  8A
081D2:  MOVWF  x79
081D4:  MOVLB  0
081D6:  CALL   5C0A
081DA:  MOVF   01,W
081DC:  ADDLW  8A
081DE:  MOVLB  6
081E0:  MOVWF  x45
081E2:  MOVLW  04
081E4:  ADDWFC 02,W
081E6:  MOVWF  x46
081E8:  MOVLW  01
081EA:  SUBWF  x43,W
081EC:  MULLW  18
081EE:  MOVF   FF3,W
081F0:  CLRF   x48
081F2:  MOVWF  x47
081F4:  MOVLW  14
081F6:  ADDWF  x47,W
081F8:  MOVWF  01
081FA:  MOVLW  00
081FC:  ADDWFC x48,W
081FE:  MOVWF  03
08200:  MOVF   01,W
08202:  ADDLW  82
08204:  MOVWF  FE9
08206:  MOVLW  00
08208:  ADDWFC 03,W
0820A:  MOVWF  FEA
0820C:  MOVFF  FEF,647
08210:  MOVFF  FEC,648
08214:  MOVFF  FEC,649
08218:  MOVFF  FEC,64A
0821C:  MOVFF  646,52F
08220:  MOVFF  645,52E
08224:  MOVFF  643,66C
08228:  MOVLW  18
0822A:  MOVWF  x6D
0822C:  MOVLB  0
0822E:  CALL   61C6
08232:  MOVLW  2C
08234:  MOVLB  6
08236:  MOVWF  x88
08238:  MOVLB  0
0823A:  CALL   5CBA
0823E:  MOVLW  89
08240:  MOVWF  FE9
08242:  MOVFF  64A,67E
08246:  MOVFF  649,67D
0824A:  MOVFF  648,67C
0824E:  MOVFF  647,67B
08252:  MOVLW  02
08254:  MOVLB  6
08256:  MOVWF  x7F
08258:  MOVLB  0
0825A:  CALL   69E2
0825E:  MOVLW  2C
08260:  MOVLB  6
08262:  MOVWF  x88
08264:  MOVLB  0
08266:  CALL   5CBA
0826A:  BRA    8276
0826C:  MOVLB  6
....................    else return INV_PARAM;
0826E:  MOVLW  02
08270:  MOVWF  01
08272:  MOVLB  0
08274:  BRA    827A
....................    
....................    return SUCCESS;
08276:  MOVLW  00
08278:  MOVWF  01
0827A:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0827C:  MOVLB  6
0827E:  CLRF   x7A
08280:  MOVFF  637,679
08284:  CLRF   x7C
08286:  MOVLW  B5
08288:  MOVWF  x7B
0828A:  MOVLB  0
0828C:  CALL   0BBE
08290:  MOVFF  02,64A
08294:  MOVFF  01,649
08298:  MOVLW  06
0829A:  MOVLB  6
0829C:  ADDWF  x49,F
0829E:  MOVLW  00
082A0:  ADDWFC x4A,F
082A2:  MOVLW  32
082A4:  ADDWF  x49,W
082A6:  MOVWF  01
082A8:  MOVLW  00
082AA:  ADDWFC x4A,W
082AC:  MOVWF  03
082AE:  MOVF   01,W
082B0:  ADDLW  B4
082B2:  MOVWF  01
082B4:  MOVLW  01
082B6:  ADDWFC 03,F
082B8:  MOVFF  01,649
082BC:  MOVFF  03,64A
082C0:  MOVFF  03,66C
082C4:  MOVFF  01,66B
082C8:  MOVLB  0
082CA:  CALL   5D82
082CE:  MOVF   01,F
082D0:  BNZ   82DA
082D2:  MOVLW  02
082D4:  MOVWF  01
082D6:  BRA    8612
082D8:  BRA    8338
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
082DA:  MOVLB  6
082DC:  CLRF   x7A
082DE:  MOVFF  637,679
082E2:  CLRF   x7C
082E4:  MOVLW  B5
082E6:  MOVWF  x7B
082E8:  MOVLB  0
082EA:  CALL   0BBE
082EE:  MOVFF  02,64A
082F2:  MOVFF  01,649
082F6:  MOVLW  06
082F8:  MOVLB  6
082FA:  ADDWF  x49,F
082FC:  MOVLW  00
082FE:  ADDWFC x4A,F
08300:  MOVLW  32
08302:  ADDWF  x49,W
08304:  MOVWF  01
08306:  MOVLW  00
08308:  ADDWFC x4A,W
0830A:  MOVWF  03
0830C:  MOVF   01,W
0830E:  ADDLW  B4
08310:  MOVWF  01
08312:  MOVLW  01
08314:  ADDWFC 03,F
08316:  MOVFF  01,649
0831A:  MOVFF  03,64A
0831E:  MOVFF  03,66C
08322:  MOVFF  01,66B
08326:  CLRF   x6E
08328:  CLRF   x6D
0832A:  MOVLW  0A
0832C:  MOVWF  x6F
0832E:  MOVLB  0
08330:  CALL   5E72
08334:  MOVFF  01,643
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08338:  MOVLB  6
0833A:  CLRF   x7A
0833C:  MOVFF  637,679
08340:  CLRF   x7C
08342:  MOVLW  B5
08344:  MOVWF  x7B
08346:  MOVLB  0
08348:  CALL   0BBE
0834C:  MOVFF  02,64A
08350:  MOVFF  01,649
08354:  MOVLW  06
08356:  MOVLB  6
08358:  ADDWF  x49,F
0835A:  MOVLW  00
0835C:  ADDWFC x4A,F
0835E:  MOVLW  4B
08360:  ADDWF  x49,W
08362:  MOVWF  01
08364:  MOVLW  00
08366:  ADDWFC x4A,W
08368:  MOVWF  03
0836A:  MOVF   01,W
0836C:  ADDLW  B4
0836E:  MOVWF  01
08370:  MOVLW  01
08372:  ADDWFC 03,F
08374:  MOVFF  01,649
08378:  MOVFF  03,64A
0837C:  MOVFF  03,67A
08380:  MOVFF  01,679
08384:  MOVLB  0
08386:  CALL   5C0A
0838A:  MOVFF  02,03
0838E:  MOVF   01,W
08390:  SUBLW  01
08392:  BNZ   8398
08394:  MOVF   03,F
08396:  BZ    83A0
08398:  MOVLW  02
0839A:  MOVWF  01
0839C:  BRA    8612
0839E:  BRA    83E0
....................    else arg2 = SERcmd[rec].p[3][0];
083A0:  MOVLB  6
083A2:  CLRF   x7A
083A4:  MOVFF  637,679
083A8:  CLRF   x7C
083AA:  MOVLW  B5
083AC:  MOVWF  x7B
083AE:  MOVLB  0
083B0:  CALL   0BBE
083B4:  MOVFF  02,64A
083B8:  MOVFF  01,649
083BC:  MOVLW  06
083BE:  MOVLB  6
083C0:  ADDWF  x49,F
083C2:  MOVLW  00
083C4:  ADDWFC x4A,F
083C6:  MOVLW  4B
083C8:  ADDWF  x49,F
083CA:  MOVLW  00
083CC:  ADDWFC x4A,F
083CE:  MOVLW  B4
083D0:  ADDWF  x49,W
083D2:  MOVWF  FE9
083D4:  MOVLW  01
083D6:  ADDWFC x4A,W
083D8:  MOVWF  FEA
083DA:  MOVFF  FEF,644
083DE:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
083E0:  MOVLB  6
083E2:  CLRF   x7A
083E4:  MOVFF  637,679
083E8:  CLRF   x7C
083EA:  MOVLW  B5
083EC:  MOVWF  x7B
083EE:  MOVLB  0
083F0:  CALL   0BBE
083F4:  MOVFF  02,64A
083F8:  MOVFF  01,649
083FC:  MOVLW  06
083FE:  MOVLB  6
08400:  ADDWF  x49,F
08402:  MOVLW  00
08404:  ADDWFC x4A,F
08406:  MOVLW  64
08408:  ADDWF  x49,W
0840A:  MOVWF  01
0840C:  MOVLW  00
0840E:  ADDWFC x4A,W
08410:  MOVWF  03
08412:  MOVF   01,W
08414:  ADDLW  B4
08416:  MOVWF  01
08418:  MOVLW  01
0841A:  ADDWFC 03,F
0841C:  MOVFF  01,649
08420:  MOVFF  03,64A
08424:  MOVFF  03,64D
08428:  MOVFF  01,64C
0842C:  MOVLB  0
0842E:  CALL   704E
08432:  MOVF   01,F
08434:  BNZ   843E
08436:  MOVLW  02
08438:  MOVWF  01
0843A:  BRA    8612
0843C:  BRA    84A4
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0843E:  MOVLB  6
08440:  CLRF   x7A
08442:  MOVFF  637,679
08446:  CLRF   x7C
08448:  MOVLW  B5
0844A:  MOVWF  x7B
0844C:  MOVLB  0
0844E:  CALL   0BBE
08452:  MOVFF  02,64A
08456:  MOVFF  01,649
0845A:  MOVLW  06
0845C:  MOVLB  6
0845E:  ADDWF  x49,F
08460:  MOVLW  00
08462:  ADDWFC x4A,F
08464:  MOVLW  64
08466:  ADDWF  x49,W
08468:  MOVWF  01
0846A:  MOVLW  00
0846C:  ADDWFC x4A,W
0846E:  MOVWF  03
08470:  MOVF   01,W
08472:  ADDLW  B4
08474:  MOVWF  01
08476:  MOVLW  01
08478:  ADDWFC 03,F
0847A:  MOVFF  01,649
0847E:  MOVFF  03,64A
08482:  MOVFF  03,64D
08486:  MOVFF  01,64C
0848A:  CLRF   x4F
0848C:  CLRF   x4E
0848E:  MOVLB  0
08490:  CALL   7110
08494:  MOVFF  03,648
08498:  MOVFF  02,647
0849C:  MOVFF  01,646
084A0:  MOVFF  00,645
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
084A4:  MOVLB  6
084A6:  MOVF   x44,W
084A8:  SUBLW  30
084AA:  BNZ   84D6
084AC:  MOVLW  01
084AE:  SUBWF  x43,W
084B0:  MULLW  18
084B2:  MOVF   FF3,W
084B4:  CLRF   x4A
084B6:  MOVWF  x49
084B8:  MOVLW  82
084BA:  ADDWF  x49,W
084BC:  MOVWF  FE9
084BE:  MOVLW  00
084C0:  ADDWFC x4A,W
084C2:  MOVWF  FEA
084C4:  MOVFF  645,FEF
084C8:  MOVFF  646,FEC
084CC:  MOVFF  647,FEC
084D0:  MOVFF  648,FEC
084D4:  BRA    860C
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
084D6:  MOVF   x44,W
084D8:  SUBLW  31
084DA:  BNZ   8512
084DC:  MOVLW  01
084DE:  SUBWF  x43,W
084E0:  MULLW  18
084E2:  MOVF   FF3,W
084E4:  CLRF   x4A
084E6:  MOVWF  x49
084E8:  MOVLW  04
084EA:  ADDWF  x49,W
084EC:  MOVWF  01
084EE:  MOVLW  00
084F0:  ADDWFC x4A,W
084F2:  MOVWF  03
084F4:  MOVF   01,W
084F6:  ADDLW  82
084F8:  MOVWF  FE9
084FA:  MOVLW  00
084FC:  ADDWFC 03,W
084FE:  MOVWF  FEA
08500:  MOVFF  645,FEF
08504:  MOVFF  646,FEC
08508:  MOVFF  647,FEC
0850C:  MOVFF  648,FEC
08510:  BRA    860C
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08512:  MOVF   x44,W
08514:  SUBLW  32
08516:  BNZ   854E
08518:  MOVLW  01
0851A:  SUBWF  x43,W
0851C:  MULLW  18
0851E:  MOVF   FF3,W
08520:  CLRF   x4A
08522:  MOVWF  x49
08524:  MOVLW  08
08526:  ADDWF  x49,W
08528:  MOVWF  01
0852A:  MOVLW  00
0852C:  ADDWFC x4A,W
0852E:  MOVWF  03
08530:  MOVF   01,W
08532:  ADDLW  82
08534:  MOVWF  FE9
08536:  MOVLW  00
08538:  ADDWFC 03,W
0853A:  MOVWF  FEA
0853C:  MOVFF  645,FEF
08540:  MOVFF  646,FEC
08544:  MOVFF  647,FEC
08548:  MOVFF  648,FEC
0854C:  BRA    860C
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
0854E:  MOVF   x44,W
08550:  SUBLW  33
08552:  BNZ   858A
08554:  MOVLW  01
08556:  SUBWF  x43,W
08558:  MULLW  18
0855A:  MOVF   FF3,W
0855C:  CLRF   x4A
0855E:  MOVWF  x49
08560:  MOVLW  0C
08562:  ADDWF  x49,W
08564:  MOVWF  01
08566:  MOVLW  00
08568:  ADDWFC x4A,W
0856A:  MOVWF  03
0856C:  MOVF   01,W
0856E:  ADDLW  82
08570:  MOVWF  FE9
08572:  MOVLW  00
08574:  ADDWFC 03,W
08576:  MOVWF  FEA
08578:  MOVFF  645,FEF
0857C:  MOVFF  646,FEC
08580:  MOVFF  647,FEC
08584:  MOVFF  648,FEC
08588:  BRA    860C
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
0858A:  MOVF   x44,W
0858C:  SUBLW  34
0858E:  BNZ   85C6
08590:  MOVLW  01
08592:  SUBWF  x43,W
08594:  MULLW  18
08596:  MOVF   FF3,W
08598:  CLRF   x4A
0859A:  MOVWF  x49
0859C:  MOVLW  10
0859E:  ADDWF  x49,W
085A0:  MOVWF  01
085A2:  MOVLW  00
085A4:  ADDWFC x4A,W
085A6:  MOVWF  03
085A8:  MOVF   01,W
085AA:  ADDLW  82
085AC:  MOVWF  FE9
085AE:  MOVLW  00
085B0:  ADDWFC 03,W
085B2:  MOVWF  FEA
085B4:  MOVFF  645,FEF
085B8:  MOVFF  646,FEC
085BC:  MOVFF  647,FEC
085C0:  MOVFF  648,FEC
085C4:  BRA    860C
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
085C6:  MOVF   x44,W
085C8:  SUBLW  35
085CA:  BNZ   8602
085CC:  MOVLW  01
085CE:  SUBWF  x43,W
085D0:  MULLW  18
085D2:  MOVF   FF3,W
085D4:  CLRF   x4A
085D6:  MOVWF  x49
085D8:  MOVLW  14
085DA:  ADDWF  x49,W
085DC:  MOVWF  01
085DE:  MOVLW  00
085E0:  ADDWFC x4A,W
085E2:  MOVWF  03
085E4:  MOVF   01,W
085E6:  ADDLW  82
085E8:  MOVWF  FE9
085EA:  MOVLW  00
085EC:  ADDWFC 03,W
085EE:  MOVWF  FEA
085F0:  MOVFF  645,FEF
085F4:  MOVFF  646,FEC
085F8:  MOVFF  647,FEC
085FC:  MOVFF  648,FEC
08600:  BRA    860C
....................    else return INV_PARAM;
08602:  MOVLW  02
08604:  MOVWF  01
08606:  MOVLB  0
08608:  BRA    8612
0860A:  MOVLB  6
....................    
....................    return SUCCESS;
0860C:  MOVLW  00
0860E:  MOVWF  01
08610:  MOVLB  0
08612:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08614:  MOVLW  4E
08616:  MOVLB  6
08618:  MOVWF  x47
0861A:  MOVLW  31
0861C:  MOVWF  x48
0861E:  MOVLW  35
08620:  MOVWF  x49
08622:  CLRF   x4A
08624:  MOVLW  06
08626:  MOVWF  x46
08628:  MOVLW  47
0862A:  MOVWF  x45
....................    char *s_200 = "200";
0862C:  MOVLW  32
0862E:  MOVWF  x4D
08630:  MOVLW  30
08632:  MOVWF  x4E
08634:  MOVWF  x4F
08636:  CLRF   x50
08638:  MOVLW  06
0863A:  MOVWF  x4C
0863C:  MOVLW  4D
0863E:  MOVWF  x4B
....................    char *s_5V6 = "5V6";
08640:  MOVLW  35
08642:  MOVWF  x53
08644:  MOVLW  56
08646:  MOVWF  x54
08648:  MOVLW  36
0864A:  MOVWF  x55
0864C:  CLRF   x56
0864E:  MOVLW  06
08650:  MOVWF  x52
08652:  MOVLW  53
08654:  MOVWF  x51
....................    char *s_5VA = "5VA";
08656:  MOVLW  35
08658:  MOVWF  x59
0865A:  MOVLW  56
0865C:  MOVWF  x5A
0865E:  MOVLW  41
08660:  MOVWF  x5B
08662:  CLRF   x5C
08664:  MOVLW  06
08666:  MOVWF  x58
08668:  MOVLW  59
0866A:  MOVWF  x57
....................    char *s_3V6X = "3V6X";
0866C:  MOVLW  33
0866E:  MOVWF  x5F
08670:  MOVLW  56
08672:  MOVWF  x60
08674:  MOVLW  36
08676:  MOVWF  x61
08678:  MOVLW  58
0867A:  MOVWF  x62
0867C:  CLRF   x63
0867E:  MOVLW  06
08680:  MOVWF  x5E
08682:  MOVLW  5F
08684:  MOVWF  x5D
....................    char *s_3V3A = "3V3A";
08686:  MOVLW  33
08688:  MOVWF  x66
0868A:  MOVLW  56
0868C:  MOVWF  x67
0868E:  MOVLW  33
08690:  MOVWF  x68
08692:  MOVLW  41
08694:  MOVWF  x69
08696:  CLRF   x6A
08698:  MOVLW  06
0869A:  MOVWF  x65
0869C:  MOVLW  66
0869E:  MOVWF  x64
....................    char *s_3V3D = "3V3D";
086A0:  MOVLW  33
086A2:  MOVWF  x6D
086A4:  MOVLW  56
086A6:  MOVWF  x6E
086A8:  MOVLW  33
086AA:  MOVWF  x6F
086AC:  MOVLW  44
086AE:  MOVWF  x70
086B0:  CLRF   x71
086B2:  MOVLW  06
086B4:  MOVWF  x6C
086B6:  MOVLW  6D
086B8:  MOVWF  x6B
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
086BA:  CLRF   x7A
086BC:  MOVFF  637,679
086C0:  CLRF   x7C
086C2:  MOVLW  B5
086C4:  MOVWF  x7B
086C6:  MOVLB  0
086C8:  CALL   0BBE
086CC:  MOVFF  02,673
086D0:  MOVFF  01,672
086D4:  MOVLW  06
086D6:  MOVLB  6
086D8:  ADDWF  x72,F
086DA:  MOVLW  00
086DC:  ADDWFC x73,F
086DE:  MOVLW  32
086E0:  ADDWF  x72,W
086E2:  MOVWF  01
086E4:  MOVLW  00
086E6:  ADDWFC x73,W
086E8:  MOVWF  03
086EA:  MOVF   01,W
086EC:  ADDLW  B4
086EE:  MOVWF  01
086F0:  MOVLW  01
086F2:  ADDWFC 03,F
086F4:  MOVFF  01,643
086F8:  MOVFF  03,644
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
086FC:  MOVFF  646,67A
08700:  MOVFF  645,679
08704:  MOVFF  644,67C
08708:  MOVFF  643,67B
0870C:  MOVLB  0
0870E:  CALL   5C42
08712:  MOVF   01,F
08714:  BNZ   8798
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08716:  MOVLW  04
08718:  MOVLB  6
0871A:  MOVWF  x7A
0871C:  MOVLW  8A
0871E:  MOVWF  x79
08720:  MOVLB  0
08722:  CALL   5C0A
08726:  MOVFF  02,03
0872A:  MOVF   01,W
0872C:  ADDLW  8A
0872E:  MOVLB  6
08730:  MOVWF  x72
08732:  MOVLW  04
08734:  ADDWFC 02,W
08736:  MOVWF  x73
08738:  MOVFF  FE8,52F
0873C:  MOVFF  672,52E
08740:  MOVLW  89
08742:  MOVWF  FE9
08744:  MOVFF  B5,67E
08748:  MOVFF  B4,67D
0874C:  MOVFF  B3,67C
08750:  MOVFF  B2,67B
08754:  MOVLW  02
08756:  MOVWF  x7F
08758:  MOVLB  0
0875A:  CALL   69E2
0875E:  MOVLW  2C
08760:  MOVLB  6
08762:  MOVWF  x88
08764:  MOVLB  0
08766:  CALL   5CBA
0876A:  MOVLW  89
0876C:  MOVWF  FE9
0876E:  MOVFF  B9,67E
08772:  MOVFF  B8,67D
08776:  MOVFF  B7,67C
0877A:  MOVFF  B6,67B
0877E:  MOVLW  02
08780:  MOVLB  6
08782:  MOVWF  x7F
08784:  MOVLB  0
08786:  CALL   69E2
0878A:  MOVLW  2C
0878C:  MOVLB  6
0878E:  MOVWF  x88
08790:  MOVLB  0
08792:  CALL   5CBA
....................    }
08796:  BRA    8B3A
....................    else if (0 == strcmp(s_200, arg1)) {
08798:  MOVFF  64C,67A
0879C:  MOVFF  64B,679
087A0:  MOVFF  644,67C
087A4:  MOVFF  643,67B
087A8:  CALL   5C42
087AC:  MOVF   01,F
087AE:  BNZ   8832
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
087B0:  MOVLW  04
087B2:  MOVLB  6
087B4:  MOVWF  x7A
087B6:  MOVLW  8A
087B8:  MOVWF  x79
087BA:  MOVLB  0
087BC:  CALL   5C0A
087C0:  MOVFF  02,03
087C4:  MOVF   01,W
087C6:  ADDLW  8A
087C8:  MOVLB  6
087CA:  MOVWF  x72
087CC:  MOVLW  04
087CE:  ADDWFC 02,W
087D0:  MOVWF  x73
087D2:  MOVFF  FE8,52F
087D6:  MOVFF  672,52E
087DA:  MOVLW  89
087DC:  MOVWF  FE9
087DE:  MOVFF  BD,67E
087E2:  MOVFF  BC,67D
087E6:  MOVFF  BB,67C
087EA:  MOVFF  BA,67B
087EE:  MOVLW  02
087F0:  MOVWF  x7F
087F2:  MOVLB  0
087F4:  CALL   69E2
087F8:  MOVLW  2C
087FA:  MOVLB  6
087FC:  MOVWF  x88
087FE:  MOVLB  0
08800:  CALL   5CBA
08804:  MOVLW  89
08806:  MOVWF  FE9
08808:  MOVFF  C1,67E
0880C:  MOVFF  C0,67D
08810:  MOVFF  BF,67C
08814:  MOVFF  BE,67B
08818:  MOVLW  02
0881A:  MOVLB  6
0881C:  MOVWF  x7F
0881E:  MOVLB  0
08820:  CALL   69E2
08824:  MOVLW  2C
08826:  MOVLB  6
08828:  MOVWF  x88
0882A:  MOVLB  0
0882C:  CALL   5CBA
....................    }
08830:  BRA    8B3A
....................    else if (0 == strcmp(s_5V6, arg1)) {
08832:  MOVFF  652,67A
08836:  MOVFF  651,679
0883A:  MOVFF  644,67C
0883E:  MOVFF  643,67B
08842:  CALL   5C42
08846:  MOVF   01,F
08848:  BNZ   88CC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
0884A:  MOVLW  04
0884C:  MOVLB  6
0884E:  MOVWF  x7A
08850:  MOVLW  8A
08852:  MOVWF  x79
08854:  MOVLB  0
08856:  CALL   5C0A
0885A:  MOVFF  02,03
0885E:  MOVF   01,W
08860:  ADDLW  8A
08862:  MOVLB  6
08864:  MOVWF  x72
08866:  MOVLW  04
08868:  ADDWFC 02,W
0886A:  MOVWF  x73
0886C:  MOVFF  FE8,52F
08870:  MOVFF  672,52E
08874:  MOVLW  89
08876:  MOVWF  FE9
08878:  MOVFF  C5,67E
0887C:  MOVFF  C4,67D
08880:  MOVFF  C3,67C
08884:  MOVFF  C2,67B
08888:  MOVLW  02
0888A:  MOVWF  x7F
0888C:  MOVLB  0
0888E:  CALL   69E2
08892:  MOVLW  2C
08894:  MOVLB  6
08896:  MOVWF  x88
08898:  MOVLB  0
0889A:  CALL   5CBA
0889E:  MOVLW  89
088A0:  MOVWF  FE9
088A2:  MOVFF  C9,67E
088A6:  MOVFF  C8,67D
088AA:  MOVFF  C7,67C
088AE:  MOVFF  C6,67B
088B2:  MOVLW  02
088B4:  MOVLB  6
088B6:  MOVWF  x7F
088B8:  MOVLB  0
088BA:  CALL   69E2
088BE:  MOVLW  2C
088C0:  MOVLB  6
088C2:  MOVWF  x88
088C4:  MOVLB  0
088C6:  CALL   5CBA
....................    }
088CA:  BRA    8B3A
....................    else if (0 == strcmp(s_5VA, arg1)) {
088CC:  MOVFF  658,67A
088D0:  MOVFF  657,679
088D4:  MOVFF  644,67C
088D8:  MOVFF  643,67B
088DC:  CALL   5C42
088E0:  MOVF   01,F
088E2:  BNZ   8966
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
088E4:  MOVLW  04
088E6:  MOVLB  6
088E8:  MOVWF  x7A
088EA:  MOVLW  8A
088EC:  MOVWF  x79
088EE:  MOVLB  0
088F0:  CALL   5C0A
088F4:  MOVFF  02,03
088F8:  MOVF   01,W
088FA:  ADDLW  8A
088FC:  MOVLB  6
088FE:  MOVWF  x72
08900:  MOVLW  04
08902:  ADDWFC 02,W
08904:  MOVWF  x73
08906:  MOVFF  FE8,52F
0890A:  MOVFF  672,52E
0890E:  MOVLW  89
08910:  MOVWF  FE9
08912:  MOVFF  CD,67E
08916:  MOVFF  CC,67D
0891A:  MOVFF  CB,67C
0891E:  MOVFF  CA,67B
08922:  MOVLW  02
08924:  MOVWF  x7F
08926:  MOVLB  0
08928:  CALL   69E2
0892C:  MOVLW  2C
0892E:  MOVLB  6
08930:  MOVWF  x88
08932:  MOVLB  0
08934:  CALL   5CBA
08938:  MOVLW  89
0893A:  MOVWF  FE9
0893C:  MOVFF  D1,67E
08940:  MOVFF  D0,67D
08944:  MOVFF  CF,67C
08948:  MOVFF  CE,67B
0894C:  MOVLW  02
0894E:  MOVLB  6
08950:  MOVWF  x7F
08952:  MOVLB  0
08954:  CALL   69E2
08958:  MOVLW  2C
0895A:  MOVLB  6
0895C:  MOVWF  x88
0895E:  MOVLB  0
08960:  CALL   5CBA
....................    }
08964:  BRA    8B3A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08966:  MOVFF  65E,67A
0896A:  MOVFF  65D,679
0896E:  MOVFF  644,67C
08972:  MOVFF  643,67B
08976:  CALL   5C42
0897A:  MOVF   01,F
0897C:  BNZ   8A00
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
0897E:  MOVLW  04
08980:  MOVLB  6
08982:  MOVWF  x7A
08984:  MOVLW  8A
08986:  MOVWF  x79
08988:  MOVLB  0
0898A:  CALL   5C0A
0898E:  MOVFF  02,03
08992:  MOVF   01,W
08994:  ADDLW  8A
08996:  MOVLB  6
08998:  MOVWF  x72
0899A:  MOVLW  04
0899C:  ADDWFC 02,W
0899E:  MOVWF  x73
089A0:  MOVFF  FE8,52F
089A4:  MOVFF  672,52E
089A8:  MOVLW  89
089AA:  MOVWF  FE9
089AC:  MOVFF  D5,67E
089B0:  MOVFF  D4,67D
089B4:  MOVFF  D3,67C
089B8:  MOVFF  D2,67B
089BC:  MOVLW  02
089BE:  MOVWF  x7F
089C0:  MOVLB  0
089C2:  CALL   69E2
089C6:  MOVLW  2C
089C8:  MOVLB  6
089CA:  MOVWF  x88
089CC:  MOVLB  0
089CE:  CALL   5CBA
089D2:  MOVLW  89
089D4:  MOVWF  FE9
089D6:  MOVFF  D9,67E
089DA:  MOVFF  D8,67D
089DE:  MOVFF  D7,67C
089E2:  MOVFF  D6,67B
089E6:  MOVLW  02
089E8:  MOVLB  6
089EA:  MOVWF  x7F
089EC:  MOVLB  0
089EE:  CALL   69E2
089F2:  MOVLW  2C
089F4:  MOVLB  6
089F6:  MOVWF  x88
089F8:  MOVLB  0
089FA:  CALL   5CBA
....................    }
089FE:  BRA    8B3A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08A00:  MOVFF  665,67A
08A04:  MOVFF  664,679
08A08:  MOVFF  644,67C
08A0C:  MOVFF  643,67B
08A10:  CALL   5C42
08A14:  MOVF   01,F
08A16:  BNZ   8A9A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08A18:  MOVLW  04
08A1A:  MOVLB  6
08A1C:  MOVWF  x7A
08A1E:  MOVLW  8A
08A20:  MOVWF  x79
08A22:  MOVLB  0
08A24:  CALL   5C0A
08A28:  MOVFF  02,03
08A2C:  MOVF   01,W
08A2E:  ADDLW  8A
08A30:  MOVLB  6
08A32:  MOVWF  x72
08A34:  MOVLW  04
08A36:  ADDWFC 02,W
08A38:  MOVWF  x73
08A3A:  MOVFF  FE8,52F
08A3E:  MOVFF  672,52E
08A42:  MOVLW  89
08A44:  MOVWF  FE9
08A46:  MOVFF  DD,67E
08A4A:  MOVFF  DC,67D
08A4E:  MOVFF  DB,67C
08A52:  MOVFF  DA,67B
08A56:  MOVLW  02
08A58:  MOVWF  x7F
08A5A:  MOVLB  0
08A5C:  CALL   69E2
08A60:  MOVLW  2C
08A62:  MOVLB  6
08A64:  MOVWF  x88
08A66:  MOVLB  0
08A68:  CALL   5CBA
08A6C:  MOVLW  89
08A6E:  MOVWF  FE9
08A70:  MOVFF  E1,67E
08A74:  MOVFF  E0,67D
08A78:  MOVFF  DF,67C
08A7C:  MOVFF  DE,67B
08A80:  MOVLW  02
08A82:  MOVLB  6
08A84:  MOVWF  x7F
08A86:  MOVLB  0
08A88:  CALL   69E2
08A8C:  MOVLW  2C
08A8E:  MOVLB  6
08A90:  MOVWF  x88
08A92:  MOVLB  0
08A94:  CALL   5CBA
....................    }
08A98:  BRA    8B3A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08A9A:  MOVFF  66C,67A
08A9E:  MOVFF  66B,679
08AA2:  MOVFF  644,67C
08AA6:  MOVFF  643,67B
08AAA:  CALL   5C42
08AAE:  MOVF   01,F
08AB0:  BNZ   8B34
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08AB2:  MOVLW  04
08AB4:  MOVLB  6
08AB6:  MOVWF  x7A
08AB8:  MOVLW  8A
08ABA:  MOVWF  x79
08ABC:  MOVLB  0
08ABE:  CALL   5C0A
08AC2:  MOVFF  02,03
08AC6:  MOVF   01,W
08AC8:  ADDLW  8A
08ACA:  MOVLB  6
08ACC:  MOVWF  x72
08ACE:  MOVLW  04
08AD0:  ADDWFC 02,W
08AD2:  MOVWF  x73
08AD4:  MOVFF  FE8,52F
08AD8:  MOVFF  672,52E
08ADC:  MOVLW  89
08ADE:  MOVWF  FE9
08AE0:  MOVFF  E5,67E
08AE4:  MOVFF  E4,67D
08AE8:  MOVFF  E3,67C
08AEC:  MOVFF  E2,67B
08AF0:  MOVLW  02
08AF2:  MOVWF  x7F
08AF4:  MOVLB  0
08AF6:  CALL   69E2
08AFA:  MOVLW  2C
08AFC:  MOVLB  6
08AFE:  MOVWF  x88
08B00:  MOVLB  0
08B02:  CALL   5CBA
08B06:  MOVLW  89
08B08:  MOVWF  FE9
08B0A:  MOVFF  E9,67E
08B0E:  MOVFF  E8,67D
08B12:  MOVFF  E7,67C
08B16:  MOVFF  E6,67B
08B1A:  MOVLW  02
08B1C:  MOVLB  6
08B1E:  MOVWF  x7F
08B20:  MOVLB  0
08B22:  CALL   69E2
08B26:  MOVLW  2C
08B28:  MOVLB  6
08B2A:  MOVWF  x88
08B2C:  MOVLB  0
08B2E:  CALL   5CBA
....................    }
08B32:  BRA    8B3A
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
08B34:  MOVLW  02
08B36:  MOVWF  01
08B38:  BRA    8B3E
....................    
....................    return SUCCESS;
08B3A:  MOVLW  00
08B3C:  MOVWF  01
08B3E:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
08B40:  MOVLW  00
08B42:  MOVWF  01
08B44:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08B46:  MOVLW  4E
08B48:  MOVLB  6
08B4A:  MOVWF  x47
08B4C:  MOVLW  31
08B4E:  MOVWF  x48
08B50:  MOVLW  35
08B52:  MOVWF  x49
08B54:  CLRF   x4A
08B56:  MOVLW  06
08B58:  MOVWF  x46
08B5A:  MOVLW  47
08B5C:  MOVWF  x45
....................    char *s_200 = "200";
08B5E:  MOVLW  32
08B60:  MOVWF  x4D
08B62:  MOVLW  30
08B64:  MOVWF  x4E
08B66:  MOVWF  x4F
08B68:  CLRF   x50
08B6A:  MOVLW  06
08B6C:  MOVWF  x4C
08B6E:  MOVLW  4D
08B70:  MOVWF  x4B
....................    char *s_5V6 = "5V6";
08B72:  MOVLW  35
08B74:  MOVWF  x53
08B76:  MOVLW  56
08B78:  MOVWF  x54
08B7A:  MOVLW  36
08B7C:  MOVWF  x55
08B7E:  CLRF   x56
08B80:  MOVLW  06
08B82:  MOVWF  x52
08B84:  MOVLW  53
08B86:  MOVWF  x51
....................    char *s_5VA = "5VA";
08B88:  MOVLW  35
08B8A:  MOVWF  x59
08B8C:  MOVLW  56
08B8E:  MOVWF  x5A
08B90:  MOVLW  41
08B92:  MOVWF  x5B
08B94:  CLRF   x5C
08B96:  MOVLW  06
08B98:  MOVWF  x58
08B9A:  MOVLW  59
08B9C:  MOVWF  x57
....................    char *s_3V6X = "3V6X";
08B9E:  MOVLW  33
08BA0:  MOVWF  x5F
08BA2:  MOVLW  56
08BA4:  MOVWF  x60
08BA6:  MOVLW  36
08BA8:  MOVWF  x61
08BAA:  MOVLW  58
08BAC:  MOVWF  x62
08BAE:  CLRF   x63
08BB0:  MOVLW  06
08BB2:  MOVWF  x5E
08BB4:  MOVLW  5F
08BB6:  MOVWF  x5D
....................    char *s_3V3A = "3V3A";
08BB8:  MOVLW  33
08BBA:  MOVWF  x66
08BBC:  MOVLW  56
08BBE:  MOVWF  x67
08BC0:  MOVLW  33
08BC2:  MOVWF  x68
08BC4:  MOVLW  41
08BC6:  MOVWF  x69
08BC8:  CLRF   x6A
08BCA:  MOVLW  06
08BCC:  MOVWF  x65
08BCE:  MOVLW  66
08BD0:  MOVWF  x64
....................    char *s_3V3D = "3V3D";
08BD2:  MOVLW  33
08BD4:  MOVWF  x6D
08BD6:  MOVLW  56
08BD8:  MOVWF  x6E
08BDA:  MOVLW  33
08BDC:  MOVWF  x6F
08BDE:  MOVLW  44
08BE0:  MOVWF  x70
08BE2:  CLRF   x71
08BE4:  MOVLW  06
08BE6:  MOVWF  x6C
08BE8:  MOVLW  6D
08BEA:  MOVWF  x6B
....................    char *s_all = "all";
08BEC:  MOVLW  61
08BEE:  MOVWF  x74
08BF0:  MOVLW  6C
08BF2:  MOVWF  x75
08BF4:  MOVWF  x76
08BF6:  CLRF   x77
08BF8:  MOVLW  06
08BFA:  MOVWF  x73
08BFC:  MOVLW  74
08BFE:  MOVWF  x72
....................    
....................    arg1 = SERcmd[rec].p[2];
08C00:  CLRF   x7A
08C02:  MOVFF  637,679
08C06:  CLRF   x7C
08C08:  MOVLW  B5
08C0A:  MOVWF  x7B
08C0C:  MOVLB  0
08C0E:  CALL   0BBE
08C12:  MOVFF  02,679
08C16:  MOVFF  01,678
08C1A:  MOVLW  06
08C1C:  MOVLB  6
08C1E:  ADDWF  x78,F
08C20:  MOVLW  00
08C22:  ADDWFC x79,F
08C24:  MOVLW  32
08C26:  ADDWF  x78,W
08C28:  MOVWF  01
08C2A:  MOVLW  00
08C2C:  ADDWFC x79,W
08C2E:  MOVWF  03
08C30:  MOVF   01,W
08C32:  ADDLW  B4
08C34:  MOVWF  01
08C36:  MOVLW  01
08C38:  ADDWFC 03,F
08C3A:  MOVFF  01,643
08C3E:  MOVFF  03,644
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08C42:  MOVFF  646,67A
08C46:  MOVFF  645,679
08C4A:  MOVFF  644,67C
08C4E:  MOVFF  643,67B
08C52:  MOVLB  0
08C54:  CALL   5C42
08C58:  MOVF   01,F
08C5A:  BNZ   8CB2
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08C5C:  MOVLW  04
08C5E:  MOVLB  6
08C60:  MOVWF  x7A
08C62:  MOVLW  8A
08C64:  MOVWF  x79
08C66:  MOVLB  0
08C68:  CALL   5C0A
08C6C:  MOVFF  02,03
08C70:  MOVF   01,W
08C72:  ADDLW  8A
08C74:  MOVLB  6
08C76:  MOVWF  x78
08C78:  MOVLW  04
08C7A:  ADDWFC 02,W
08C7C:  MOVWF  x79
08C7E:  MOVFF  FE8,52F
08C82:  MOVFF  678,52E
08C86:  MOVLW  89
08C88:  MOVWF  FE9
08C8A:  MOVFF  F6,67E
08C8E:  MOVFF  F5,67D
08C92:  MOVFF  F4,67C
08C96:  MOVFF  F3,67B
08C9A:  MOVLW  02
08C9C:  MOVWF  x7F
08C9E:  MOVLB  0
08CA0:  CALL   69E2
08CA4:  MOVLW  2C
08CA6:  MOVLB  6
08CA8:  MOVWF  x88
08CAA:  MOVLB  0
08CAC:  CALL   5CBA
....................    }
08CB0:  BRA    91B4
....................    else if (0 == strcmp(s_200, arg1)) {
08CB2:  MOVFF  64C,67A
08CB6:  MOVFF  64B,679
08CBA:  MOVFF  644,67C
08CBE:  MOVFF  643,67B
08CC2:  CALL   5C42
08CC6:  MOVF   01,F
08CC8:  BNZ   8D20
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08CCA:  MOVLW  04
08CCC:  MOVLB  6
08CCE:  MOVWF  x7A
08CD0:  MOVLW  8A
08CD2:  MOVWF  x79
08CD4:  MOVLB  0
08CD6:  CALL   5C0A
08CDA:  MOVFF  02,03
08CDE:  MOVF   01,W
08CE0:  ADDLW  8A
08CE2:  MOVLB  6
08CE4:  MOVWF  x78
08CE6:  MOVLW  04
08CE8:  ADDWFC 02,W
08CEA:  MOVWF  x79
08CEC:  MOVFF  FE8,52F
08CF0:  MOVFF  678,52E
08CF4:  MOVLW  89
08CF6:  MOVWF  FE9
08CF8:  MOVFF  FA,67E
08CFC:  MOVFF  F9,67D
08D00:  MOVFF  F8,67C
08D04:  MOVFF  F7,67B
08D08:  MOVLW  01
08D0A:  MOVWF  x7F
08D0C:  MOVLB  0
08D0E:  CALL   69E2
08D12:  MOVLW  2C
08D14:  MOVLB  6
08D16:  MOVWF  x88
08D18:  MOVLB  0
08D1A:  CALL   5CBA
....................    }
08D1E:  BRA    91B4
....................    else if (0 == strcmp(s_5V6, arg1)) {
08D20:  MOVFF  652,67A
08D24:  MOVFF  651,679
08D28:  MOVFF  644,67C
08D2C:  MOVFF  643,67B
08D30:  CALL   5C42
08D34:  MOVF   01,F
08D36:  BNZ   8D8E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08D38:  MOVLW  04
08D3A:  MOVLB  6
08D3C:  MOVWF  x7A
08D3E:  MOVLW  8A
08D40:  MOVWF  x79
08D42:  MOVLB  0
08D44:  CALL   5C0A
08D48:  MOVFF  02,03
08D4C:  MOVF   01,W
08D4E:  ADDLW  8A
08D50:  MOVLB  6
08D52:  MOVWF  x78
08D54:  MOVLW  04
08D56:  ADDWFC 02,W
08D58:  MOVWF  x79
08D5A:  MOVFF  FE8,52F
08D5E:  MOVFF  678,52E
08D62:  MOVLW  89
08D64:  MOVWF  FE9
08D66:  MOVFF  FE,67E
08D6A:  MOVFF  FD,67D
08D6E:  MOVFF  FC,67C
08D72:  MOVFF  FB,67B
08D76:  MOVLW  03
08D78:  MOVWF  x7F
08D7A:  MOVLB  0
08D7C:  CALL   69E2
08D80:  MOVLW  2C
08D82:  MOVLB  6
08D84:  MOVWF  x88
08D86:  MOVLB  0
08D88:  CALL   5CBA
....................    }
08D8C:  BRA    91B4
....................    else if (0 == strcmp(s_5VA, arg1)) {
08D8E:  MOVFF  658,67A
08D92:  MOVFF  657,679
08D96:  MOVFF  644,67C
08D9A:  MOVFF  643,67B
08D9E:  CALL   5C42
08DA2:  MOVF   01,F
08DA4:  BNZ   8DFC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08DA6:  MOVLW  04
08DA8:  MOVLB  6
08DAA:  MOVWF  x7A
08DAC:  MOVLW  8A
08DAE:  MOVWF  x79
08DB0:  MOVLB  0
08DB2:  CALL   5C0A
08DB6:  MOVFF  02,03
08DBA:  MOVF   01,W
08DBC:  ADDLW  8A
08DBE:  MOVLB  6
08DC0:  MOVWF  x78
08DC2:  MOVLW  04
08DC4:  ADDWFC 02,W
08DC6:  MOVWF  x79
08DC8:  MOVFF  FE8,52F
08DCC:  MOVFF  678,52E
08DD0:  MOVLW  89
08DD2:  MOVWF  FE9
08DD4:  MOVFF  102,67E
08DD8:  MOVFF  101,67D
08DDC:  MOVFF  100,67C
08DE0:  MOVFF  FF,67B
08DE4:  MOVLW  03
08DE6:  MOVWF  x7F
08DE8:  MOVLB  0
08DEA:  CALL   69E2
08DEE:  MOVLW  2C
08DF0:  MOVLB  6
08DF2:  MOVWF  x88
08DF4:  MOVLB  0
08DF6:  CALL   5CBA
....................    }
08DFA:  BRA    91B4
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08DFC:  MOVFF  65E,67A
08E00:  MOVFF  65D,679
08E04:  MOVFF  644,67C
08E08:  MOVFF  643,67B
08E0C:  CALL   5C42
08E10:  MOVF   01,F
08E12:  BNZ   8E6A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08E14:  MOVLW  04
08E16:  MOVLB  6
08E18:  MOVWF  x7A
08E1A:  MOVLW  8A
08E1C:  MOVWF  x79
08E1E:  MOVLB  0
08E20:  CALL   5C0A
08E24:  MOVFF  02,03
08E28:  MOVF   01,W
08E2A:  ADDLW  8A
08E2C:  MOVLB  6
08E2E:  MOVWF  x78
08E30:  MOVLW  04
08E32:  ADDWFC 02,W
08E34:  MOVWF  x79
08E36:  MOVFF  FE8,52F
08E3A:  MOVFF  678,52E
08E3E:  MOVLW  89
08E40:  MOVWF  FE9
08E42:  MOVFF  106,67E
08E46:  MOVFF  105,67D
08E4A:  MOVFF  104,67C
08E4E:  MOVFF  103,67B
08E52:  MOVLW  03
08E54:  MOVWF  x7F
08E56:  MOVLB  0
08E58:  CALL   69E2
08E5C:  MOVLW  2C
08E5E:  MOVLB  6
08E60:  MOVWF  x88
08E62:  MOVLB  0
08E64:  CALL   5CBA
....................    }
08E68:  BRA    91B4
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08E6A:  MOVFF  665,67A
08E6E:  MOVFF  664,679
08E72:  MOVFF  644,67C
08E76:  MOVFF  643,67B
08E7A:  CALL   5C42
08E7E:  MOVF   01,F
08E80:  BNZ   8ED8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08E82:  MOVLW  04
08E84:  MOVLB  6
08E86:  MOVWF  x7A
08E88:  MOVLW  8A
08E8A:  MOVWF  x79
08E8C:  MOVLB  0
08E8E:  CALL   5C0A
08E92:  MOVFF  02,03
08E96:  MOVF   01,W
08E98:  ADDLW  8A
08E9A:  MOVLB  6
08E9C:  MOVWF  x78
08E9E:  MOVLW  04
08EA0:  ADDWFC 02,W
08EA2:  MOVWF  x79
08EA4:  MOVFF  FE8,52F
08EA8:  MOVFF  678,52E
08EAC:  MOVLW  89
08EAE:  MOVWF  FE9
08EB0:  MOVFF  10A,67E
08EB4:  MOVFF  109,67D
08EB8:  MOVFF  108,67C
08EBC:  MOVFF  107,67B
08EC0:  MOVLW  03
08EC2:  MOVWF  x7F
08EC4:  MOVLB  0
08EC6:  CALL   69E2
08ECA:  MOVLW  2C
08ECC:  MOVLB  6
08ECE:  MOVWF  x88
08ED0:  MOVLB  0
08ED2:  CALL   5CBA
....................    }
08ED6:  BRA    91B4
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08ED8:  MOVFF  66C,67A
08EDC:  MOVFF  66B,679
08EE0:  MOVFF  644,67C
08EE4:  MOVFF  643,67B
08EE8:  CALL   5C42
08EEC:  MOVF   01,F
08EEE:  BNZ   8F46
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08EF0:  MOVLW  04
08EF2:  MOVLB  6
08EF4:  MOVWF  x7A
08EF6:  MOVLW  8A
08EF8:  MOVWF  x79
08EFA:  MOVLB  0
08EFC:  CALL   5C0A
08F00:  MOVFF  02,03
08F04:  MOVF   01,W
08F06:  ADDLW  8A
08F08:  MOVLB  6
08F0A:  MOVWF  x78
08F0C:  MOVLW  04
08F0E:  ADDWFC 02,W
08F10:  MOVWF  x79
08F12:  MOVFF  FE8,52F
08F16:  MOVFF  678,52E
08F1A:  MOVLW  89
08F1C:  MOVWF  FE9
08F1E:  MOVFF  10E,67E
08F22:  MOVFF  10D,67D
08F26:  MOVFF  10C,67C
08F2A:  MOVFF  10B,67B
08F2E:  MOVLW  03
08F30:  MOVWF  x7F
08F32:  MOVLB  0
08F34:  CALL   69E2
08F38:  MOVLW  2C
08F3A:  MOVLB  6
08F3C:  MOVWF  x88
08F3E:  MOVLB  0
08F40:  CALL   5CBA
....................    }
08F44:  BRA    91B4
....................    else if (0 == strcmp(s_all, arg1)) {
08F46:  MOVFF  673,67A
08F4A:  MOVFF  672,679
08F4E:  MOVFF  644,67C
08F52:  MOVFF  643,67B
08F56:  CALL   5C42
08F5A:  MOVF   01,F
08F5C:  BTFSS  FD8.2
08F5E:  BRA    91AE
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08F60:  MOVLW  04
08F62:  MOVLB  6
08F64:  MOVWF  x7A
08F66:  MOVLW  8A
08F68:  MOVWF  x79
08F6A:  MOVLB  0
08F6C:  CALL   5C0A
08F70:  MOVFF  02,03
08F74:  MOVF   01,W
08F76:  ADDLW  8A
08F78:  MOVLB  6
08F7A:  MOVWF  x78
08F7C:  MOVLW  04
08F7E:  ADDWFC 02,W
08F80:  MOVWF  x79
08F82:  MOVFF  FE8,52F
08F86:  MOVFF  678,52E
08F8A:  MOVLW  89
08F8C:  MOVWF  FE9
08F8E:  MOVFF  F6,67E
08F92:  MOVFF  F5,67D
08F96:  MOVFF  F4,67C
08F9A:  MOVFF  F3,67B
08F9E:  MOVLW  02
08FA0:  MOVWF  x7F
08FA2:  MOVLB  0
08FA4:  CALL   69E2
08FA8:  MOVLW  2C
08FAA:  MOVLB  6
08FAC:  MOVWF  x88
08FAE:  MOVLB  0
08FB0:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08FB4:  MOVLW  04
08FB6:  MOVLB  6
08FB8:  MOVWF  x7A
08FBA:  MOVLW  8A
08FBC:  MOVWF  x79
08FBE:  MOVLB  0
08FC0:  CALL   5C0A
08FC4:  MOVFF  02,03
08FC8:  MOVF   01,W
08FCA:  ADDLW  8A
08FCC:  MOVLB  6
08FCE:  MOVWF  x78
08FD0:  MOVLW  04
08FD2:  ADDWFC 02,W
08FD4:  MOVWF  x79
08FD6:  MOVFF  FE8,52F
08FDA:  MOVFF  678,52E
08FDE:  MOVLW  89
08FE0:  MOVWF  FE9
08FE2:  MOVFF  FA,67E
08FE6:  MOVFF  F9,67D
08FEA:  MOVFF  F8,67C
08FEE:  MOVFF  F7,67B
08FF2:  MOVLW  01
08FF4:  MOVWF  x7F
08FF6:  MOVLB  0
08FF8:  CALL   69E2
08FFC:  MOVLW  2C
08FFE:  MOVLB  6
09000:  MOVWF  x88
09002:  MOVLB  0
09004:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
09008:  MOVLW  04
0900A:  MOVLB  6
0900C:  MOVWF  x7A
0900E:  MOVLW  8A
09010:  MOVWF  x79
09012:  MOVLB  0
09014:  CALL   5C0A
09018:  MOVFF  02,03
0901C:  MOVF   01,W
0901E:  ADDLW  8A
09020:  MOVLB  6
09022:  MOVWF  x78
09024:  MOVLW  04
09026:  ADDWFC 02,W
09028:  MOVWF  x79
0902A:  MOVFF  FE8,52F
0902E:  MOVFF  678,52E
09032:  MOVLW  89
09034:  MOVWF  FE9
09036:  MOVFF  FE,67E
0903A:  MOVFF  FD,67D
0903E:  MOVFF  FC,67C
09042:  MOVFF  FB,67B
09046:  MOVLW  03
09048:  MOVWF  x7F
0904A:  MOVLB  0
0904C:  CALL   69E2
09050:  MOVLW  2C
09052:  MOVLB  6
09054:  MOVWF  x88
09056:  MOVLB  0
09058:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
0905C:  MOVLW  04
0905E:  MOVLB  6
09060:  MOVWF  x7A
09062:  MOVLW  8A
09064:  MOVWF  x79
09066:  MOVLB  0
09068:  CALL   5C0A
0906C:  MOVFF  02,03
09070:  MOVF   01,W
09072:  ADDLW  8A
09074:  MOVLB  6
09076:  MOVWF  x78
09078:  MOVLW  04
0907A:  ADDWFC 02,W
0907C:  MOVWF  x79
0907E:  MOVFF  FE8,52F
09082:  MOVFF  678,52E
09086:  MOVLW  89
09088:  MOVWF  FE9
0908A:  MOVFF  102,67E
0908E:  MOVFF  101,67D
09092:  MOVFF  100,67C
09096:  MOVFF  FF,67B
0909A:  MOVLW  03
0909C:  MOVWF  x7F
0909E:  MOVLB  0
090A0:  CALL   69E2
090A4:  MOVLW  2C
090A6:  MOVLB  6
090A8:  MOVWF  x88
090AA:  MOVLB  0
090AC:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
090B0:  MOVLW  04
090B2:  MOVLB  6
090B4:  MOVWF  x7A
090B6:  MOVLW  8A
090B8:  MOVWF  x79
090BA:  MOVLB  0
090BC:  CALL   5C0A
090C0:  MOVFF  02,03
090C4:  MOVF   01,W
090C6:  ADDLW  8A
090C8:  MOVLB  6
090CA:  MOVWF  x78
090CC:  MOVLW  04
090CE:  ADDWFC 02,W
090D0:  MOVWF  x79
090D2:  MOVFF  FE8,52F
090D6:  MOVFF  678,52E
090DA:  MOVLW  89
090DC:  MOVWF  FE9
090DE:  MOVFF  106,67E
090E2:  MOVFF  105,67D
090E6:  MOVFF  104,67C
090EA:  MOVFF  103,67B
090EE:  MOVLW  03
090F0:  MOVWF  x7F
090F2:  MOVLB  0
090F4:  CALL   69E2
090F8:  MOVLW  2C
090FA:  MOVLB  6
090FC:  MOVWF  x88
090FE:  MOVLB  0
09100:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
09104:  MOVLW  04
09106:  MOVLB  6
09108:  MOVWF  x7A
0910A:  MOVLW  8A
0910C:  MOVWF  x79
0910E:  MOVLB  0
09110:  CALL   5C0A
09114:  MOVFF  02,03
09118:  MOVF   01,W
0911A:  ADDLW  8A
0911C:  MOVLB  6
0911E:  MOVWF  x78
09120:  MOVLW  04
09122:  ADDWFC 02,W
09124:  MOVWF  x79
09126:  MOVFF  FE8,52F
0912A:  MOVFF  678,52E
0912E:  MOVLW  89
09130:  MOVWF  FE9
09132:  MOVFF  10A,67E
09136:  MOVFF  109,67D
0913A:  MOVFF  108,67C
0913E:  MOVFF  107,67B
09142:  MOVLW  03
09144:  MOVWF  x7F
09146:  MOVLB  0
09148:  CALL   69E2
0914C:  MOVLW  2C
0914E:  MOVLB  6
09150:  MOVWF  x88
09152:  MOVLB  0
09154:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
09158:  MOVLW  04
0915A:  MOVLB  6
0915C:  MOVWF  x7A
0915E:  MOVLW  8A
09160:  MOVWF  x79
09162:  MOVLB  0
09164:  CALL   5C0A
09168:  MOVFF  02,03
0916C:  MOVF   01,W
0916E:  ADDLW  8A
09170:  MOVLB  6
09172:  MOVWF  x78
09174:  MOVLW  04
09176:  ADDWFC 02,W
09178:  MOVWF  x79
0917A:  MOVFF  FE8,52F
0917E:  MOVFF  678,52E
09182:  MOVLW  89
09184:  MOVWF  FE9
09186:  MOVFF  10E,67E
0918A:  MOVFF  10D,67D
0918E:  MOVFF  10C,67C
09192:  MOVFF  10B,67B
09196:  MOVLW  03
09198:  MOVWF  x7F
0919A:  MOVLB  0
0919C:  CALL   69E2
091A0:  MOVLW  2C
091A2:  MOVLB  6
091A4:  MOVWF  x88
091A6:  MOVLB  0
091A8:  CALL   5CBA
....................    }
091AC:  BRA    91B4
....................    else return INV_PARAM;
091AE:  MOVLW  02
091B0:  MOVWF  01
091B2:  BRA    91B8
....................    
....................    return SUCCESS;
091B4:  MOVLW  00
091B6:  MOVWF  01
091B8:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
091BA:  MOVLW  50
091BC:  MOVLB  6
091BE:  MOVWF  x48
091C0:  MOVLW  56
091C2:  MOVWF  x49
091C4:  CLRF   x4A
091C6:  MOVLW  06
091C8:  MOVWF  x47
091CA:  MOVLW  48
091CC:  MOVWF  x46
....................    char *s_CV = "CV";
091CE:  MOVLW  43
091D0:  MOVWF  x4D
091D2:  MOVLW  56
091D4:  MOVWF  x4E
091D6:  CLRF   x4F
091D8:  MOVLW  06
091DA:  MOVWF  x4C
091DC:  MOVLW  4D
091DE:  MOVWF  x4B
....................    char *s_PVold = "PVold";
091E0:  MOVLW  50
091E2:  MOVWF  x52
091E4:  MOVLW  56
091E6:  MOVWF  x53
091E8:  MOVLW  6F
091EA:  MOVWF  x54
091EC:  MOVLW  6C
091EE:  MOVWF  x55
091F0:  MOVLW  64
091F2:  MOVWF  x56
091F4:  CLRF   x57
091F6:  MOVLW  06
091F8:  MOVWF  x51
091FA:  MOVLW  52
091FC:  MOVWF  x50
....................    char *s_I = "I";
091FE:  MOVLW  49
09200:  MOVWF  x5A
09202:  CLRF   x5B
09204:  MOVLW  06
09206:  MOVWF  x59
09208:  MOVLW  5A
0920A:  MOVWF  x58
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0920C:  CLRF   x7A
0920E:  MOVFF  637,679
09212:  CLRF   x7C
09214:  MOVLW  B5
09216:  MOVWF  x7B
09218:  MOVLB  0
0921A:  CALL   0BBE
0921E:  MOVFF  02,65D
09222:  MOVFF  01,65C
09226:  MOVLW  06
09228:  MOVLB  6
0922A:  ADDWF  x5C,F
0922C:  MOVLW  00
0922E:  ADDWFC x5D,F
09230:  MOVLW  32
09232:  ADDWF  x5C,W
09234:  MOVWF  01
09236:  MOVLW  00
09238:  ADDWFC x5D,W
0923A:  MOVWF  03
0923C:  MOVF   01,W
0923E:  ADDLW  B4
09240:  MOVWF  01
09242:  MOVLW  01
09244:  ADDWFC 03,F
09246:  MOVFF  01,65C
0924A:  MOVFF  03,65D
0924E:  MOVFF  03,66C
09252:  MOVFF  01,66B
09256:  MOVLB  0
09258:  CALL   5D82
0925C:  MOVF   01,F
0925E:  BNZ   9268
09260:  MOVLW  02
09262:  MOVWF  01
09264:  BRA    95FE
09266:  BRA    92C6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09268:  MOVLB  6
0926A:  CLRF   x7A
0926C:  MOVFF  637,679
09270:  CLRF   x7C
09272:  MOVLW  B5
09274:  MOVWF  x7B
09276:  MOVLB  0
09278:  CALL   0BBE
0927C:  MOVFF  02,65D
09280:  MOVFF  01,65C
09284:  MOVLW  06
09286:  MOVLB  6
09288:  ADDWF  x5C,F
0928A:  MOVLW  00
0928C:  ADDWFC x5D,F
0928E:  MOVLW  32
09290:  ADDWF  x5C,W
09292:  MOVWF  01
09294:  MOVLW  00
09296:  ADDWFC x5D,W
09298:  MOVWF  03
0929A:  MOVF   01,W
0929C:  ADDLW  B4
0929E:  MOVWF  01
092A0:  MOVLW  01
092A2:  ADDWFC 03,F
092A4:  MOVFF  01,65C
092A8:  MOVFF  03,65D
092AC:  MOVFF  03,66C
092B0:  MOVFF  01,66B
092B4:  CLRF   x6E
092B6:  CLRF   x6D
092B8:  MOVLW  0A
092BA:  MOVWF  x6F
092BC:  MOVLB  0
092BE:  CALL   5E72
092C2:  MOVFF  01,643
....................    
....................    arg2 = SERcmd[rec].p[3];
092C6:  MOVLB  6
092C8:  CLRF   x7A
092CA:  MOVFF  637,679
092CE:  CLRF   x7C
092D0:  MOVLW  B5
092D2:  MOVWF  x7B
092D4:  MOVLB  0
092D6:  CALL   0BBE
092DA:  MOVFF  02,65D
092DE:  MOVFF  01,65C
092E2:  MOVLW  06
092E4:  MOVLB  6
092E6:  ADDWF  x5C,F
092E8:  MOVLW  00
092EA:  ADDWFC x5D,F
092EC:  MOVLW  4B
092EE:  ADDWF  x5C,W
092F0:  MOVWF  01
092F2:  MOVLW  00
092F4:  ADDWFC x5D,W
092F6:  MOVWF  03
092F8:  MOVF   01,W
092FA:  ADDLW  B4
092FC:  MOVWF  01
092FE:  MOVLW  01
09300:  ADDWFC 03,F
09302:  MOVFF  01,644
09306:  MOVFF  03,645
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
0930A:  MOVFF  647,67A
0930E:  MOVFF  646,679
09312:  MOVFF  645,67C
09316:  MOVFF  644,67B
0931A:  MOVLB  0
0931C:  CALL   5C42
09320:  MOVF   01,F
09322:  BNZ   93C6
09324:  MOVLW  04
09326:  MOVLB  6
09328:  MOVWF  x7A
0932A:  MOVLW  8A
0932C:  MOVWF  x79
0932E:  MOVLB  0
09330:  CALL   5C0A
09334:  MOVF   01,W
09336:  ADDLW  8A
09338:  MOVLB  6
0933A:  MOVWF  x5C
0933C:  MOVLW  04
0933E:  ADDWFC 02,W
09340:  MOVWF  x5D
09342:  MOVLW  01
09344:  SUBWF  x43,W
09346:  MULLW  20
09348:  MOVF   FF3,W
0934A:  CLRF   x5F
0934C:  MOVWF  x5E
0934E:  MOVLW  10
09350:  ADDWF  x5E,W
09352:  MOVWF  01
09354:  MOVLW  00
09356:  ADDWFC x5F,W
09358:  MOVWF  03
0935A:  MOVF   01,W
0935C:  ADDLW  20
0935E:  MOVWF  FE9
09360:  MOVLW  00
09362:  ADDWFC 03,W
09364:  MOVWF  FEA
09366:  MOVFF  FEF,65E
0936A:  MOVFF  FEC,65F
0936E:  MOVFF  FEC,660
09372:  MOVFF  FEC,661
09376:  MOVFF  65D,52F
0937A:  MOVFF  65C,52E
0937E:  MOVFF  643,66C
09382:  MOVLW  18
09384:  MOVWF  x6D
09386:  MOVLB  0
09388:  CALL   61C6
0938C:  MOVLW  2C
0938E:  MOVLB  6
09390:  MOVWF  x88
09392:  MOVLB  0
09394:  CALL   5CBA
09398:  MOVLW  89
0939A:  MOVWF  FE9
0939C:  MOVFF  661,67E
093A0:  MOVFF  660,67D
093A4:  MOVFF  65F,67C
093A8:  MOVFF  65E,67B
093AC:  MOVLW  02
093AE:  MOVLB  6
093B0:  MOVWF  x7F
093B2:  MOVLB  0
093B4:  CALL   69E2
093B8:  MOVLW  2C
093BA:  MOVLB  6
093BC:  MOVWF  x88
093BE:  MOVLB  0
093C0:  CALL   5CBA
093C4:  BRA    95FA
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
093C6:  MOVFF  64C,67A
093CA:  MOVFF  64B,679
093CE:  MOVFF  645,67C
093D2:  MOVFF  644,67B
093D6:  CALL   5C42
093DA:  MOVF   01,F
093DC:  BNZ   9480
093DE:  MOVLW  04
093E0:  MOVLB  6
093E2:  MOVWF  x7A
093E4:  MOVLW  8A
093E6:  MOVWF  x79
093E8:  MOVLB  0
093EA:  CALL   5C0A
093EE:  MOVF   01,W
093F0:  ADDLW  8A
093F2:  MOVLB  6
093F4:  MOVWF  x5C
093F6:  MOVLW  04
093F8:  ADDWFC 02,W
093FA:  MOVWF  x5D
093FC:  MOVLW  01
093FE:  SUBWF  x43,W
09400:  MULLW  20
09402:  MOVF   FF3,W
09404:  CLRF   x5F
09406:  MOVWF  x5E
09408:  MOVLW  18
0940A:  ADDWF  x5E,W
0940C:  MOVWF  01
0940E:  MOVLW  00
09410:  ADDWFC x5F,W
09412:  MOVWF  03
09414:  MOVF   01,W
09416:  ADDLW  20
09418:  MOVWF  FE9
0941A:  MOVLW  00
0941C:  ADDWFC 03,W
0941E:  MOVWF  FEA
09420:  MOVFF  FEF,65E
09424:  MOVFF  FEC,65F
09428:  MOVFF  FEC,660
0942C:  MOVFF  FEC,661
09430:  MOVFF  65D,52F
09434:  MOVFF  65C,52E
09438:  MOVFF  643,66C
0943C:  MOVLW  18
0943E:  MOVWF  x6D
09440:  MOVLB  0
09442:  CALL   61C6
09446:  MOVLW  2C
09448:  MOVLB  6
0944A:  MOVWF  x88
0944C:  MOVLB  0
0944E:  CALL   5CBA
09452:  MOVLW  89
09454:  MOVWF  FE9
09456:  MOVFF  661,67E
0945A:  MOVFF  660,67D
0945E:  MOVFF  65F,67C
09462:  MOVFF  65E,67B
09466:  MOVLW  02
09468:  MOVLB  6
0946A:  MOVWF  x7F
0946C:  MOVLB  0
0946E:  CALL   69E2
09472:  MOVLW  2C
09474:  MOVLB  6
09476:  MOVWF  x88
09478:  MOVLB  0
0947A:  CALL   5CBA
0947E:  BRA    95FA
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09480:  MOVFF  651,67A
09484:  MOVFF  650,679
09488:  MOVFF  645,67C
0948C:  MOVFF  644,67B
09490:  CALL   5C42
09494:  MOVF   01,F
09496:  BNZ   953A
09498:  MOVLW  04
0949A:  MOVLB  6
0949C:  MOVWF  x7A
0949E:  MOVLW  8A
094A0:  MOVWF  x79
094A2:  MOVLB  0
094A4:  CALL   5C0A
094A8:  MOVF   01,W
094AA:  ADDLW  8A
094AC:  MOVLB  6
094AE:  MOVWF  x5C
094B0:  MOVLW  04
094B2:  ADDWFC 02,W
094B4:  MOVWF  x5D
094B6:  MOVLW  01
094B8:  SUBWF  x43,W
094BA:  MULLW  20
094BC:  MOVF   FF3,W
094BE:  CLRF   x5F
094C0:  MOVWF  x5E
094C2:  MOVLW  14
094C4:  ADDWF  x5E,W
094C6:  MOVWF  01
094C8:  MOVLW  00
094CA:  ADDWFC x5F,W
094CC:  MOVWF  03
094CE:  MOVF   01,W
094D0:  ADDLW  20
094D2:  MOVWF  FE9
094D4:  MOVLW  00
094D6:  ADDWFC 03,W
094D8:  MOVWF  FEA
094DA:  MOVFF  FEF,65E
094DE:  MOVFF  FEC,65F
094E2:  MOVFF  FEC,660
094E6:  MOVFF  FEC,661
094EA:  MOVFF  65D,52F
094EE:  MOVFF  65C,52E
094F2:  MOVFF  643,66C
094F6:  MOVLW  18
094F8:  MOVWF  x6D
094FA:  MOVLB  0
094FC:  CALL   61C6
09500:  MOVLW  2C
09502:  MOVLB  6
09504:  MOVWF  x88
09506:  MOVLB  0
09508:  CALL   5CBA
0950C:  MOVLW  89
0950E:  MOVWF  FE9
09510:  MOVFF  661,67E
09514:  MOVFF  660,67D
09518:  MOVFF  65F,67C
0951C:  MOVFF  65E,67B
09520:  MOVLW  02
09522:  MOVLB  6
09524:  MOVWF  x7F
09526:  MOVLB  0
09528:  CALL   69E2
0952C:  MOVLW  2C
0952E:  MOVLB  6
09530:  MOVWF  x88
09532:  MOVLB  0
09534:  CALL   5CBA
09538:  BRA    95FA
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
0953A:  MOVFF  659,67A
0953E:  MOVFF  658,679
09542:  MOVFF  645,67C
09546:  MOVFF  644,67B
0954A:  CALL   5C42
0954E:  MOVF   01,F
09550:  BNZ   95F4
09552:  MOVLW  04
09554:  MOVLB  6
09556:  MOVWF  x7A
09558:  MOVLW  8A
0955A:  MOVWF  x79
0955C:  MOVLB  0
0955E:  CALL   5C0A
09562:  MOVF   01,W
09564:  ADDLW  8A
09566:  MOVLB  6
09568:  MOVWF  x5C
0956A:  MOVLW  04
0956C:  ADDWFC 02,W
0956E:  MOVWF  x5D
09570:  MOVLW  01
09572:  SUBWF  x43,W
09574:  MULLW  20
09576:  MOVF   FF3,W
09578:  CLRF   x5F
0957A:  MOVWF  x5E
0957C:  MOVLW  1C
0957E:  ADDWF  x5E,W
09580:  MOVWF  01
09582:  MOVLW  00
09584:  ADDWFC x5F,W
09586:  MOVWF  03
09588:  MOVF   01,W
0958A:  ADDLW  20
0958C:  MOVWF  FE9
0958E:  MOVLW  00
09590:  ADDWFC 03,W
09592:  MOVWF  FEA
09594:  MOVFF  FEF,65E
09598:  MOVFF  FEC,65F
0959C:  MOVFF  FEC,660
095A0:  MOVFF  FEC,661
095A4:  MOVFF  65D,52F
095A8:  MOVFF  65C,52E
095AC:  MOVFF  643,66C
095B0:  MOVLW  18
095B2:  MOVWF  x6D
095B4:  MOVLB  0
095B6:  CALL   61C6
095BA:  MOVLW  2C
095BC:  MOVLB  6
095BE:  MOVWF  x88
095C0:  MOVLB  0
095C2:  CALL   5CBA
095C6:  MOVLW  89
095C8:  MOVWF  FE9
095CA:  MOVFF  661,67E
095CE:  MOVFF  660,67D
095D2:  MOVFF  65F,67C
095D6:  MOVFF  65E,67B
095DA:  MOVLW  02
095DC:  MOVLB  6
095DE:  MOVWF  x7F
095E0:  MOVLB  0
095E2:  CALL   69E2
095E6:  MOVLW  2C
095E8:  MOVLB  6
095EA:  MOVWF  x88
095EC:  MOVLB  0
095EE:  CALL   5CBA
095F2:  BRA    95FA
....................    else return INV_PARAM;
095F4:  MOVLW  02
095F6:  MOVWF  01
095F8:  BRA    95FE
....................    
....................    return SUCCESS;
095FA:  MOVLW  00
095FC:  MOVWF  01
095FE:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
0971E:  MOVLW  72
09720:  MOVLB  6
09722:  MOVWF  x48
09724:  MOVLW  61
09726:  MOVWF  x49
09728:  MOVLW  77
0972A:  MOVWF  x4A
0972C:  CLRF   x4B
0972E:  MOVLW  06
09730:  MOVWF  x47
09732:  MOVLW  48
09734:  MOVWF  x46
....................    char *s_calibrated = "calib";
09736:  MOVLW  63
09738:  MOVWF  x4E
0973A:  MOVLW  61
0973C:  MOVWF  x4F
0973E:  MOVLW  6C
09740:  MOVWF  x50
09742:  MOVLW  69
09744:  MOVWF  x51
09746:  MOVLW  62
09748:  MOVWF  x52
0974A:  CLRF   x53
0974C:  MOVLW  06
0974E:  MOVWF  x4D
09750:  MOVLW  4E
09752:  MOVWF  x4C
....................    char *s_p0 = "p0";
09754:  MOVLW  70
09756:  MOVWF  x56
09758:  MOVLW  30
0975A:  MOVWF  x57
0975C:  CLRF   x58
0975E:  MOVLW  06
09760:  MOVWF  x55
09762:  MOVLW  56
09764:  MOVWF  x54
....................    char *s_poles = "poles";
09766:  MOVLW  70
09768:  MOVWF  x5B
0976A:  MOVLW  6F
0976C:  MOVWF  x5C
0976E:  MOVLW  6C
09770:  MOVWF  x5D
09772:  MOVLW  65
09774:  MOVWF  x5E
09776:  MOVLW  73
09778:  MOVWF  x5F
0977A:  CLRF   x60
0977C:  MOVLW  06
0977E:  MOVWF  x5A
09780:  MOVLW  5B
09782:  MOVWF  x59
....................    char *s_real = "real";
09784:  MOVLW  72
09786:  MOVWF  x63
09788:  MOVLW  65
0978A:  MOVWF  x64
0978C:  MOVLW  61
0978E:  MOVWF  x65
09790:  MOVLW  6C
09792:  MOVWF  x66
09794:  CLRF   x67
09796:  MOVLW  06
09798:  MOVWF  x62
0979A:  MOVLW  63
0979C:  MOVWF  x61
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0979E:  CLRF   x7A
097A0:  MOVFF  637,679
097A4:  CLRF   x7C
097A6:  MOVLW  B5
097A8:  MOVWF  x7B
097AA:  MOVLB  0
097AC:  CALL   0BBE
097B0:  MOVFF  02,669
097B4:  MOVFF  01,668
097B8:  MOVLW  06
097BA:  MOVLB  6
097BC:  ADDWF  x68,F
097BE:  MOVLW  00
097C0:  ADDWFC x69,F
097C2:  MOVLW  32
097C4:  ADDWF  x68,W
097C6:  MOVWF  01
097C8:  MOVLW  00
097CA:  ADDWFC x69,W
097CC:  MOVWF  03
097CE:  MOVF   01,W
097D0:  ADDLW  B4
097D2:  MOVWF  01
097D4:  MOVLW  01
097D6:  ADDWFC 03,F
097D8:  MOVFF  01,668
097DC:  MOVFF  03,669
097E0:  MOVFF  03,66C
097E4:  MOVFF  01,66B
097E8:  MOVLB  0
097EA:  CALL   5D82
097EE:  MOVF   01,F
097F0:  BNZ   97FA
097F2:  MOVLW  02
097F4:  MOVWF  01
097F6:  BRA    9E3E
097F8:  BRA    9858
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
097FA:  MOVLB  6
097FC:  CLRF   x7A
097FE:  MOVFF  637,679
09802:  CLRF   x7C
09804:  MOVLW  B5
09806:  MOVWF  x7B
09808:  MOVLB  0
0980A:  CALL   0BBE
0980E:  MOVFF  02,669
09812:  MOVFF  01,668
09816:  MOVLW  06
09818:  MOVLB  6
0981A:  ADDWF  x68,F
0981C:  MOVLW  00
0981E:  ADDWFC x69,F
09820:  MOVLW  32
09822:  ADDWF  x68,W
09824:  MOVWF  01
09826:  MOVLW  00
09828:  ADDWFC x69,W
0982A:  MOVWF  03
0982C:  MOVF   01,W
0982E:  ADDLW  B4
09830:  MOVWF  01
09832:  MOVLW  01
09834:  ADDWFC 03,F
09836:  MOVFF  01,668
0983A:  MOVFF  03,669
0983E:  MOVFF  03,66C
09842:  MOVFF  01,66B
09846:  CLRF   x6E
09848:  CLRF   x6D
0984A:  MOVLW  0A
0984C:  MOVWF  x6F
0984E:  MOVLB  0
09850:  CALL   5E72
09854:  MOVFF  01,643
....................    
....................    arg2 = SERcmd[rec].p[3];
09858:  MOVLB  6
0985A:  CLRF   x7A
0985C:  MOVFF  637,679
09860:  CLRF   x7C
09862:  MOVLW  B5
09864:  MOVWF  x7B
09866:  MOVLB  0
09868:  CALL   0BBE
0986C:  MOVFF  02,669
09870:  MOVFF  01,668
09874:  MOVLW  06
09876:  MOVLB  6
09878:  ADDWF  x68,F
0987A:  MOVLW  00
0987C:  ADDWFC x69,F
0987E:  MOVLW  4B
09880:  ADDWF  x68,W
09882:  MOVWF  01
09884:  MOVLW  00
09886:  ADDWFC x69,W
09888:  MOVWF  03
0988A:  MOVF   01,W
0988C:  ADDLW  B4
0988E:  MOVWF  01
09890:  MOVLW  01
09892:  ADDWFC 03,F
09894:  MOVFF  01,644
09898:  MOVFF  03,645
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0989C:  MOVFF  647,67A
098A0:  MOVFF  646,679
098A4:  MOVFF  645,67C
098A8:  MOVFF  644,67B
098AC:  MOVLB  0
098AE:  CALL   5C42
098B2:  MOVF   01,F
098B4:  BTFSS  FD8.2
098B6:  BRA    9A32
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098B8:  MOVLW  04
098BA:  MOVLB  6
098BC:  MOVWF  x7A
098BE:  MOVLW  8A
098C0:  MOVWF  x79
098C2:  MOVLB  0
098C4:  CALL   5C0A
098C8:  MOVFF  02,03
098CC:  MOVF   01,W
098CE:  ADDLW  8A
098D0:  MOVLB  6
098D2:  MOVWF  x68
098D4:  MOVLW  04
098D6:  ADDWFC 02,W
098D8:  MOVWF  x69
098DA:  MOVFF  FE8,52F
098DE:  MOVFF  668,52E
098E2:  MOVFF  643,66C
098E6:  MOVLW  18
098E8:  MOVWF  x6D
098EA:  MOVLB  0
098EC:  CALL   61C6
098F0:  MOVLW  2C
098F2:  MOVLB  6
098F4:  MOVWF  x88
098F6:  MOVLB  0
098F8:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
098FC:  MOVLW  04
098FE:  MOVLB  6
09900:  MOVWF  x7A
09902:  MOVLW  8A
09904:  MOVWF  x79
09906:  MOVLB  0
09908:  CALL   5C0A
0990C:  MOVFF  02,03
09910:  MOVF   01,W
09912:  ADDLW  8A
09914:  MOVLB  6
09916:  MOVWF  x68
09918:  MOVLW  04
0991A:  ADDWFC 02,W
0991C:  MOVWF  x69
0991E:  MOVLW  01
09920:  SUBWF  x43,W
09922:  MULLW  21
09924:  MOVF   FF3,W
09926:  CLRF   x6B
09928:  MOVWF  x6A
0992A:  MOVLW  0F
0992C:  ADDWF  x6A,W
0992E:  MOVWF  FE9
09930:  MOVLW  01
09932:  ADDWFC x6B,W
09934:  MOVWF  FEA
09936:  MOVFF  FEF,688
0993A:  MOVFF  FEC,01
0993E:  MOVFF  FEC,02
09942:  MOVFF  FEC,03
09946:  MOVFF  03,68B
0994A:  MOVFF  02,68A
0994E:  MOVFF  01,689
09952:  MOVLB  0
09954:  CALL   5828
09958:  MOVFF  03,66F
0995C:  MOVFF  02,66E
09960:  MOVFF  01,66D
09964:  MOVFF  00,66C
09968:  MOVFF  669,52F
0996C:  MOVFF  668,52E
09970:  MOVLW  41
09972:  MOVWF  FE9
09974:  MOVFF  03,674
09978:  MOVFF  02,673
0997C:  MOVFF  01,672
09980:  MOVFF  00,671
09984:  RCALL  9600
09986:  MOVLW  2C
09988:  MOVLB  6
0998A:  MOVWF  x88
0998C:  MOVLB  0
0998E:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09992:  MOVLW  04
09994:  MOVLB  6
09996:  MOVWF  x7A
09998:  MOVLW  8A
0999A:  MOVWF  x79
0999C:  MOVLB  0
0999E:  CALL   5C0A
099A2:  MOVF   01,W
099A4:  ADDLW  8A
099A6:  MOVLB  6
099A8:  MOVWF  x68
099AA:  MOVLW  04
099AC:  ADDWFC 02,W
099AE:  MOVWF  x69
099B0:  MOVLW  01
099B2:  SUBWF  x43,W
099B4:  MULLW  21
099B6:  MOVF   FF3,W
099B8:  CLRF   x6B
099BA:  MOVWF  x6A
099BC:  MOVLW  04
099BE:  ADDWF  x6A,W
099C0:  MOVWF  01
099C2:  MOVLW  00
099C4:  ADDWFC x6B,W
099C6:  MOVWF  03
099C8:  MOVF   01,W
099CA:  ADDLW  0F
099CC:  MOVWF  FE9
099CE:  MOVLW  01
099D0:  ADDWFC 03,W
099D2:  MOVWF  FEA
099D4:  MOVFF  FEF,688
099D8:  MOVFF  FEC,01
099DC:  MOVFF  FEC,02
099E0:  MOVFF  FEC,03
099E4:  MOVFF  03,68B
099E8:  MOVFF  02,68A
099EC:  MOVFF  01,689
099F0:  MOVLB  0
099F2:  CALL   5828
099F6:  MOVFF  03,66D
099FA:  MOVFF  02,66C
099FE:  MOVFF  01,66B
09A02:  MOVFF  00,66A
09A06:  MOVFF  669,52F
09A0A:  MOVFF  668,52E
09A0E:  MOVLW  41
09A10:  MOVWF  FE9
09A12:  MOVFF  03,674
09A16:  MOVFF  02,673
09A1A:  MOVFF  01,672
09A1E:  MOVFF  00,671
09A22:  RCALL  9600
09A24:  MOVLW  2C
09A26:  MOVLB  6
09A28:  MOVWF  x88
09A2A:  MOVLB  0
09A2C:  CALL   5CBA
....................    }
09A30:  BRA    9E3A
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09A32:  MOVFF  64D,67A
09A36:  MOVFF  64C,679
09A3A:  MOVFF  645,67C
09A3E:  MOVFF  644,67B
09A42:  CALL   5C42
09A46:  MOVF   01,F
09A48:  BTFSS  FD8.2
09A4A:  BRA    9BCE
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A4C:  MOVLW  04
09A4E:  MOVLB  6
09A50:  MOVWF  x7A
09A52:  MOVLW  8A
09A54:  MOVWF  x79
09A56:  MOVLB  0
09A58:  CALL   5C0A
09A5C:  MOVFF  02,03
09A60:  MOVF   01,W
09A62:  ADDLW  8A
09A64:  MOVLB  6
09A66:  MOVWF  x68
09A68:  MOVLW  04
09A6A:  ADDWFC 02,W
09A6C:  MOVWF  x69
09A6E:  MOVFF  FE8,52F
09A72:  MOVFF  668,52E
09A76:  MOVFF  643,66C
09A7A:  MOVLW  18
09A7C:  MOVWF  x6D
09A7E:  MOVLB  0
09A80:  CALL   61C6
09A84:  MOVLW  2C
09A86:  MOVLB  6
09A88:  MOVWF  x88
09A8A:  MOVLB  0
09A8C:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09A90:  MOVLW  04
09A92:  MOVLB  6
09A94:  MOVWF  x7A
09A96:  MOVLW  8A
09A98:  MOVWF  x79
09A9A:  MOVLB  0
09A9C:  CALL   5C0A
09AA0:  MOVF   01,W
09AA2:  ADDLW  8A
09AA4:  MOVLB  6
09AA6:  MOVWF  x68
09AA8:  MOVLW  04
09AAA:  ADDWFC 02,W
09AAC:  MOVWF  x69
09AAE:  MOVLW  01
09AB0:  SUBWF  x43,W
09AB2:  MULLW  21
09AB4:  MOVF   FF3,W
09AB6:  CLRF   x6B
09AB8:  MOVWF  x6A
09ABA:  MOVLW  08
09ABC:  ADDWF  x6A,W
09ABE:  MOVWF  01
09AC0:  MOVLW  00
09AC2:  ADDWFC x6B,W
09AC4:  MOVWF  03
09AC6:  MOVF   01,W
09AC8:  ADDLW  0F
09ACA:  MOVWF  FE9
09ACC:  MOVLW  01
09ACE:  ADDWFC 03,W
09AD0:  MOVWF  FEA
09AD2:  MOVFF  FEF,688
09AD6:  MOVFF  FEC,01
09ADA:  MOVFF  FEC,02
09ADE:  MOVFF  FEC,03
09AE2:  MOVFF  03,68B
09AE6:  MOVFF  02,68A
09AEA:  MOVFF  01,689
09AEE:  MOVLB  0
09AF0:  CALL   5828
09AF4:  MOVFF  03,66D
09AF8:  MOVFF  02,66C
09AFC:  MOVFF  01,66B
09B00:  MOVFF  00,66A
09B04:  MOVFF  669,52F
09B08:  MOVFF  668,52E
09B0C:  MOVLW  41
09B0E:  MOVWF  FE9
09B10:  MOVFF  03,674
09B14:  MOVFF  02,673
09B18:  MOVFF  01,672
09B1C:  MOVFF  00,671
09B20:  RCALL  9600
09B22:  MOVLW  2C
09B24:  MOVLB  6
09B26:  MOVWF  x88
09B28:  MOVLB  0
09B2A:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09B2E:  MOVLW  04
09B30:  MOVLB  6
09B32:  MOVWF  x7A
09B34:  MOVLW  8A
09B36:  MOVWF  x79
09B38:  MOVLB  0
09B3A:  CALL   5C0A
09B3E:  MOVF   01,W
09B40:  ADDLW  8A
09B42:  MOVLB  6
09B44:  MOVWF  x68
09B46:  MOVLW  04
09B48:  ADDWFC 02,W
09B4A:  MOVWF  x69
09B4C:  MOVLW  01
09B4E:  SUBWF  x43,W
09B50:  MULLW  21
09B52:  MOVF   FF3,W
09B54:  CLRF   x6B
09B56:  MOVWF  x6A
09B58:  MOVLW  0C
09B5A:  ADDWF  x6A,W
09B5C:  MOVWF  01
09B5E:  MOVLW  00
09B60:  ADDWFC x6B,W
09B62:  MOVWF  03
09B64:  MOVF   01,W
09B66:  ADDLW  0F
09B68:  MOVWF  FE9
09B6A:  MOVLW  01
09B6C:  ADDWFC 03,W
09B6E:  MOVWF  FEA
09B70:  MOVFF  FEF,688
09B74:  MOVFF  FEC,01
09B78:  MOVFF  FEC,02
09B7C:  MOVFF  FEC,03
09B80:  MOVFF  03,68B
09B84:  MOVFF  02,68A
09B88:  MOVFF  01,689
09B8C:  MOVLB  0
09B8E:  CALL   5828
09B92:  MOVFF  03,66D
09B96:  MOVFF  02,66C
09B9A:  MOVFF  01,66B
09B9E:  MOVFF  00,66A
09BA2:  MOVFF  669,52F
09BA6:  MOVFF  668,52E
09BAA:  MOVLW  41
09BAC:  MOVWF  FE9
09BAE:  MOVFF  03,674
09BB2:  MOVFF  02,673
09BB6:  MOVFF  01,672
09BBA:  MOVFF  00,671
09BBE:  RCALL  9600
09BC0:  MOVLW  2C
09BC2:  MOVLB  6
09BC4:  MOVWF  x88
09BC6:  MOVLB  0
09BC8:  CALL   5CBA
....................    }
09BCC:  BRA    9E3A
....................    else if (0 == strcmp(s_p0, arg2)) {
09BCE:  MOVFF  655,67A
09BD2:  MOVFF  654,679
09BD6:  MOVFF  645,67C
09BDA:  MOVFF  644,67B
09BDE:  CALL   5C42
09BE2:  MOVF   01,F
09BE4:  BNZ   9CA0
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09BE6:  MOVLW  04
09BE8:  MOVLB  6
09BEA:  MOVWF  x7A
09BEC:  MOVLW  8A
09BEE:  MOVWF  x79
09BF0:  MOVLB  0
09BF2:  CALL   5C0A
09BF6:  MOVFF  02,03
09BFA:  MOVF   01,W
09BFC:  ADDLW  8A
09BFE:  MOVLB  6
09C00:  MOVWF  x68
09C02:  MOVLW  04
09C04:  ADDWFC 02,W
09C06:  MOVWF  x69
09C08:  MOVFF  FE8,52F
09C0C:  MOVFF  668,52E
09C10:  MOVFF  643,66C
09C14:  MOVLW  18
09C16:  MOVWF  x6D
09C18:  MOVLB  0
09C1A:  CALL   61C6
09C1E:  MOVLW  2C
09C20:  MOVLB  6
09C22:  MOVWF  x88
09C24:  MOVLB  0
09C26:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09C2A:  MOVLW  04
09C2C:  MOVLB  6
09C2E:  MOVWF  x7A
09C30:  MOVLW  8A
09C32:  MOVWF  x79
09C34:  MOVLB  0
09C36:  CALL   5C0A
09C3A:  MOVF   01,W
09C3C:  ADDLW  8A
09C3E:  MOVLB  6
09C40:  MOVWF  x68
09C42:  MOVLW  04
09C44:  ADDWFC 02,W
09C46:  MOVWF  x69
09C48:  MOVLW  01
09C4A:  SUBWF  x43,W
09C4C:  MULLW  21
09C4E:  MOVF   FF3,W
09C50:  CLRF   x6B
09C52:  MOVWF  x6A
09C54:  MOVLW  18
09C56:  ADDWF  x6A,W
09C58:  MOVWF  01
09C5A:  MOVLW  00
09C5C:  ADDWFC x6B,W
09C5E:  MOVWF  03
09C60:  MOVF   01,W
09C62:  ADDLW  0F
09C64:  MOVWF  FE9
09C66:  MOVLW  01
09C68:  ADDWFC 03,W
09C6A:  MOVWF  FEA
09C6C:  MOVFF  FEF,67B
09C70:  MOVFF  FEC,67C
09C74:  MOVFF  FEC,67D
09C78:  MOVFF  FEC,67E
09C7C:  MOVFF  669,52F
09C80:  MOVFF  668,52E
09C84:  MOVLW  89
09C86:  MOVWF  FE9
09C88:  MOVLW  02
09C8A:  MOVWF  x7F
09C8C:  MOVLB  0
09C8E:  CALL   69E2
09C92:  MOVLW  2C
09C94:  MOVLB  6
09C96:  MOVWF  x88
09C98:  MOVLB  0
09C9A:  CALL   5CBA
....................    }
09C9E:  BRA    9E3A
....................    else if (0 == strcmp(s_poles, arg2)) {
09CA0:  MOVFF  65A,67A
09CA4:  MOVFF  659,679
09CA8:  MOVFF  645,67C
09CAC:  MOVFF  644,67B
09CB0:  CALL   5C42
09CB4:  MOVF   01,F
09CB6:  BNZ   9D62
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09CB8:  MOVLW  04
09CBA:  MOVLB  6
09CBC:  MOVWF  x7A
09CBE:  MOVLW  8A
09CC0:  MOVWF  x79
09CC2:  MOVLB  0
09CC4:  CALL   5C0A
09CC8:  MOVFF  02,03
09CCC:  MOVF   01,W
09CCE:  ADDLW  8A
09CD0:  MOVLB  6
09CD2:  MOVWF  x68
09CD4:  MOVLW  04
09CD6:  ADDWFC 02,W
09CD8:  MOVWF  x69
09CDA:  MOVFF  FE8,52F
09CDE:  MOVFF  668,52E
09CE2:  MOVFF  643,66C
09CE6:  MOVLW  18
09CE8:  MOVWF  x6D
09CEA:  MOVLB  0
09CEC:  CALL   61C6
09CF0:  MOVLW  2C
09CF2:  MOVLB  6
09CF4:  MOVWF  x88
09CF6:  MOVLB  0
09CF8:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09CFC:  MOVLW  04
09CFE:  MOVLB  6
09D00:  MOVWF  x7A
09D02:  MOVLW  8A
09D04:  MOVWF  x79
09D06:  MOVLB  0
09D08:  CALL   5C0A
09D0C:  MOVF   01,W
09D0E:  ADDLW  8A
09D10:  MOVLB  6
09D12:  MOVWF  x68
09D14:  MOVLW  04
09D16:  ADDWFC 02,W
09D18:  MOVWF  x69
09D1A:  MOVLW  01
09D1C:  SUBWF  x43,W
09D1E:  MULLW  21
09D20:  MOVF   FF3,W
09D22:  CLRF   x6B
09D24:  MOVWF  x6A
09D26:  MOVLW  1C
09D28:  ADDWF  x6A,W
09D2A:  MOVWF  01
09D2C:  MOVLW  00
09D2E:  ADDWFC x6B,W
09D30:  MOVWF  03
09D32:  MOVF   01,W
09D34:  ADDLW  0F
09D36:  MOVWF  FE9
09D38:  MOVLW  01
09D3A:  ADDWFC 03,W
09D3C:  MOVWF  FEA
09D3E:  MOVFF  FEF,66C
09D42:  MOVFF  669,52F
09D46:  MOVFF  668,52E
09D4A:  MOVLW  18
09D4C:  MOVWF  x6D
09D4E:  MOVLB  0
09D50:  CALL   61C6
09D54:  MOVLW  2C
09D56:  MOVLB  6
09D58:  MOVWF  x88
09D5A:  MOVLB  0
09D5C:  CALL   5CBA
....................    }
09D60:  BRA    9E3A
....................    else if (0 == strcmp(s_real, arg2)) {
09D62:  MOVFF  662,67A
09D66:  MOVFF  661,679
09D6A:  MOVFF  645,67C
09D6E:  MOVFF  644,67B
09D72:  CALL   5C42
09D76:  MOVF   01,F
09D78:  BNZ   9E34
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09D7A:  MOVLW  04
09D7C:  MOVLB  6
09D7E:  MOVWF  x7A
09D80:  MOVLW  8A
09D82:  MOVWF  x79
09D84:  MOVLB  0
09D86:  CALL   5C0A
09D8A:  MOVFF  02,03
09D8E:  MOVF   01,W
09D90:  ADDLW  8A
09D92:  MOVLB  6
09D94:  MOVWF  x68
09D96:  MOVLW  04
09D98:  ADDWFC 02,W
09D9A:  MOVWF  x69
09D9C:  MOVFF  FE8,52F
09DA0:  MOVFF  668,52E
09DA4:  MOVFF  643,66C
09DA8:  MOVLW  18
09DAA:  MOVWF  x6D
09DAC:  MOVLB  0
09DAE:  CALL   61C6
09DB2:  MOVLW  2C
09DB4:  MOVLB  6
09DB6:  MOVWF  x88
09DB8:  MOVLB  0
09DBA:  CALL   5CBA
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09DBE:  MOVLW  04
09DC0:  MOVLB  6
09DC2:  MOVWF  x7A
09DC4:  MOVLW  8A
09DC6:  MOVWF  x79
09DC8:  MOVLB  0
09DCA:  CALL   5C0A
09DCE:  MOVF   01,W
09DD0:  ADDLW  8A
09DD2:  MOVLB  6
09DD4:  MOVWF  x68
09DD6:  MOVLW  04
09DD8:  ADDWFC 02,W
09DDA:  MOVWF  x69
09DDC:  MOVLW  01
09DDE:  SUBWF  x43,W
09DE0:  MULLW  21
09DE2:  MOVF   FF3,W
09DE4:  CLRF   x6B
09DE6:  MOVWF  x6A
09DE8:  MOVLW  1D
09DEA:  ADDWF  x6A,W
09DEC:  MOVWF  01
09DEE:  MOVLW  00
09DF0:  ADDWFC x6B,W
09DF2:  MOVWF  03
09DF4:  MOVF   01,W
09DF6:  ADDLW  0F
09DF8:  MOVWF  FE9
09DFA:  MOVLW  01
09DFC:  ADDWFC 03,W
09DFE:  MOVWF  FEA
09E00:  MOVFF  FEF,67B
09E04:  MOVFF  FEC,67C
09E08:  MOVFF  FEC,67D
09E0C:  MOVFF  FEC,67E
09E10:  MOVFF  669,52F
09E14:  MOVFF  668,52E
09E18:  MOVLW  89
09E1A:  MOVWF  FE9
09E1C:  MOVLW  02
09E1E:  MOVWF  x7F
09E20:  MOVLB  0
09E22:  CALL   69E2
09E26:  MOVLW  2C
09E28:  MOVLB  6
09E2A:  MOVWF  x88
09E2C:  MOVLB  0
09E2E:  CALL   5CBA
....................    }
09E32:  BRA    9E3A
....................    else return INV_PARAM;
09E34:  MOVLW  02
09E36:  MOVWF  01
09E38:  BRA    9E3E
....................    
....................    return SUCCESS;
09E3A:  MOVLW  00
09E3C:  MOVWF  01
09E3E:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09E40:  MOVLB  6
09E42:  CLRF   x7A
09E44:  MOVFF  637,679
09E48:  CLRF   x7C
09E4A:  MOVLW  B5
09E4C:  MOVWF  x7B
09E4E:  MOVLB  0
09E50:  CALL   0BBE
09E54:  MOVFF  02,645
09E58:  MOVFF  01,644
09E5C:  MOVLW  06
09E5E:  MOVLB  6
09E60:  ADDWF  x44,F
09E62:  MOVLW  00
09E64:  ADDWFC x45,F
09E66:  MOVLW  32
09E68:  ADDWF  x44,W
09E6A:  MOVWF  01
09E6C:  MOVLW  00
09E6E:  ADDWFC x45,W
09E70:  MOVWF  03
09E72:  MOVF   01,W
09E74:  ADDLW  B4
09E76:  MOVWF  01
09E78:  MOVLW  01
09E7A:  ADDWFC 03,F
09E7C:  MOVFF  01,644
09E80:  MOVFF  03,645
09E84:  MOVFF  03,66C
09E88:  MOVFF  01,66B
09E8C:  MOVLB  0
09E8E:  CALL   5D82
09E92:  MOVF   01,F
09E94:  BNZ   9E9E
09E96:  MOVLW  02
09E98:  MOVWF  01
09E9A:  BRA    9F90
09E9C:  BRA    9EFC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09E9E:  MOVLB  6
09EA0:  CLRF   x7A
09EA2:  MOVFF  637,679
09EA6:  CLRF   x7C
09EA8:  MOVLW  B5
09EAA:  MOVWF  x7B
09EAC:  MOVLB  0
09EAE:  CALL   0BBE
09EB2:  MOVFF  02,645
09EB6:  MOVFF  01,644
09EBA:  MOVLW  06
09EBC:  MOVLB  6
09EBE:  ADDWF  x44,F
09EC0:  MOVLW  00
09EC2:  ADDWFC x45,F
09EC4:  MOVLW  32
09EC6:  ADDWF  x44,W
09EC8:  MOVWF  01
09ECA:  MOVLW  00
09ECC:  ADDWFC x45,W
09ECE:  MOVWF  03
09ED0:  MOVF   01,W
09ED2:  ADDLW  B4
09ED4:  MOVWF  01
09ED6:  MOVLW  01
09ED8:  ADDWFC 03,F
09EDA:  MOVFF  01,644
09EDE:  MOVFF  03,645
09EE2:  MOVFF  03,66C
09EE6:  MOVFF  01,66B
09EEA:  CLRF   x6E
09EEC:  CLRF   x6D
09EEE:  MOVLW  0A
09EF0:  MOVWF  x6F
09EF2:  MOVLB  0
09EF4:  CALL   5E72
09EF8:  MOVFF  01,643
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
09EFC:  MOVLW  04
09EFE:  MOVLB  6
09F00:  MOVWF  x7A
09F02:  MOVLW  8A
09F04:  MOVWF  x79
09F06:  MOVLB  0
09F08:  CALL   5C0A
09F0C:  MOVF   01,W
09F0E:  ADDLW  8A
09F10:  MOVLB  6
09F12:  MOVWF  x44
09F14:  MOVLW  04
09F16:  ADDWFC 02,W
09F18:  MOVWF  x45
09F1A:  MOVLW  01
09F1C:  SUBWF  x43,W
09F1E:  MULLW  04
09F20:  MOVF   FF3,W
09F22:  CLRF   03
09F24:  ADDLW  EA
09F26:  MOVWF  FE9
09F28:  MOVLW  00
09F2A:  ADDWFC 03,W
09F2C:  MOVWF  FEA
09F2E:  MOVFF  FEF,646
09F32:  MOVFF  FEC,647
09F36:  MOVFF  FEC,648
09F3A:  MOVFF  FEC,649
09F3E:  MOVFF  645,52F
09F42:  MOVFF  644,52E
09F46:  MOVFF  643,66C
09F4A:  MOVLW  18
09F4C:  MOVWF  x6D
09F4E:  MOVLB  0
09F50:  CALL   61C6
09F54:  MOVLW  2C
09F56:  MOVLB  6
09F58:  MOVWF  x88
09F5A:  MOVLB  0
09F5C:  CALL   5CBA
09F60:  MOVLW  89
09F62:  MOVWF  FE9
09F64:  MOVFF  649,67E
09F68:  MOVFF  648,67D
09F6C:  MOVFF  647,67C
09F70:  MOVFF  646,67B
09F74:  MOVLW  02
09F76:  MOVLB  6
09F78:  MOVWF  x7F
09F7A:  MOVLB  0
09F7C:  CALL   69E2
09F80:  MOVLW  2C
09F82:  MOVLB  6
09F84:  MOVWF  x88
09F86:  MOVLB  0
09F88:  CALL   5CBA
....................    
....................    return SUCCESS;
09F8C:  MOVLW  00
09F8E:  MOVWF  01
09F90:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09F92:  MOVLB  6
09F94:  CLRF   x7A
09F96:  MOVFF  637,679
09F9A:  CLRF   x7C
09F9C:  MOVLW  B5
09F9E:  MOVWF  x7B
09FA0:  MOVLB  0
09FA2:  CALL   0BBE
09FA6:  MOVFF  02,649
09FAA:  MOVFF  01,648
09FAE:  MOVLW  06
09FB0:  MOVLB  6
09FB2:  ADDWF  x48,F
09FB4:  MOVLW  00
09FB6:  ADDWFC x49,F
09FB8:  MOVLW  32
09FBA:  ADDWF  x48,W
09FBC:  MOVWF  01
09FBE:  MOVLW  00
09FC0:  ADDWFC x49,W
09FC2:  MOVWF  03
09FC4:  MOVF   01,W
09FC6:  ADDLW  B4
09FC8:  MOVWF  01
09FCA:  MOVLW  01
09FCC:  ADDWFC 03,F
09FCE:  MOVFF  01,648
09FD2:  MOVFF  03,649
09FD6:  MOVFF  03,66C
09FDA:  MOVFF  01,66B
09FDE:  MOVLB  0
09FE0:  CALL   5D82
09FE4:  MOVF   01,F
09FE6:  BNZ   9FF0
09FE8:  MOVLW  02
09FEA:  MOVWF  01
09FEC:  BRA    A1D2
09FEE:  BRA    A04E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09FF0:  MOVLB  6
09FF2:  CLRF   x7A
09FF4:  MOVFF  637,679
09FF8:  CLRF   x7C
09FFA:  MOVLW  B5
09FFC:  MOVWF  x7B
09FFE:  MOVLB  0
0A000:  CALL   0BBE
0A004:  MOVFF  02,649
0A008:  MOVFF  01,648
0A00C:  MOVLW  06
0A00E:  MOVLB  6
0A010:  ADDWF  x48,F
0A012:  MOVLW  00
0A014:  ADDWFC x49,F
0A016:  MOVLW  32
0A018:  ADDWF  x48,W
0A01A:  MOVWF  01
0A01C:  MOVLW  00
0A01E:  ADDWFC x49,W
0A020:  MOVWF  03
0A022:  MOVF   01,W
0A024:  ADDLW  B4
0A026:  MOVWF  01
0A028:  MOVLW  01
0A02A:  ADDWFC 03,F
0A02C:  MOVFF  01,648
0A030:  MOVFF  03,649
0A034:  MOVFF  03,66C
0A038:  MOVFF  01,66B
0A03C:  CLRF   x6E
0A03E:  CLRF   x6D
0A040:  MOVLW  0A
0A042:  MOVWF  x6F
0A044:  MOVLB  0
0A046:  CALL   5E72
0A04A:  MOVFF  01,643
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
0A04E:  MOVLB  6
0A050:  CLRF   x7A
0A052:  MOVFF  637,679
0A056:  CLRF   x7C
0A058:  MOVLW  B5
0A05A:  MOVWF  x7B
0A05C:  MOVLB  0
0A05E:  CALL   0BBE
0A062:  MOVFF  02,649
0A066:  MOVFF  01,648
0A06A:  MOVLW  06
0A06C:  MOVLB  6
0A06E:  ADDWF  x48,F
0A070:  MOVLW  00
0A072:  ADDWFC x49,F
0A074:  MOVLW  4B
0A076:  ADDWF  x48,W
0A078:  MOVWF  01
0A07A:  MOVLW  00
0A07C:  ADDWFC x49,W
0A07E:  MOVWF  03
0A080:  MOVF   01,W
0A082:  ADDLW  B4
0A084:  MOVWF  01
0A086:  MOVLW  01
0A088:  ADDWFC 03,F
0A08A:  MOVFF  01,648
0A08E:  MOVFF  03,649
0A092:  MOVFF  03,64D
0A096:  MOVFF  01,64C
0A09A:  MOVLB  0
0A09C:  CALL   704E
0A0A0:  MOVF   01,F
0A0A2:  BNZ   A0AC
0A0A4:  MOVLW  02
0A0A6:  MOVWF  01
0A0A8:  BRA    A1D2
0A0AA:  BRA    A112
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0A0AC:  MOVLB  6
0A0AE:  CLRF   x7A
0A0B0:  MOVFF  637,679
0A0B4:  CLRF   x7C
0A0B6:  MOVLW  B5
0A0B8:  MOVWF  x7B
0A0BA:  MOVLB  0
0A0BC:  CALL   0BBE
0A0C0:  MOVFF  02,649
0A0C4:  MOVFF  01,648
0A0C8:  MOVLW  06
0A0CA:  MOVLB  6
0A0CC:  ADDWF  x48,F
0A0CE:  MOVLW  00
0A0D0:  ADDWFC x49,F
0A0D2:  MOVLW  4B
0A0D4:  ADDWF  x48,W
0A0D6:  MOVWF  01
0A0D8:  MOVLW  00
0A0DA:  ADDWFC x49,W
0A0DC:  MOVWF  03
0A0DE:  MOVF   01,W
0A0E0:  ADDLW  B4
0A0E2:  MOVWF  01
0A0E4:  MOVLW  01
0A0E6:  ADDWFC 03,F
0A0E8:  MOVFF  01,648
0A0EC:  MOVFF  03,649
0A0F0:  MOVFF  03,64D
0A0F4:  MOVFF  01,64C
0A0F8:  CLRF   x4F
0A0FA:  CLRF   x4E
0A0FC:  MOVLB  0
0A0FE:  CALL   7110
0A102:  MOVFF  03,647
0A106:  MOVFF  02,646
0A10A:  MOVFF  01,645
0A10E:  MOVFF  00,644
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
0A112:  MOVLB  6
0A114:  CLRF   x86
0A116:  CLRF   x85
0A118:  MOVLW  7C
0A11A:  MOVWF  x84
0A11C:  MOVLW  84
0A11E:  MOVWF  x83
0A120:  MOVFF  647,68A
0A124:  MOVFF  646,689
0A128:  MOVFF  645,688
0A12C:  MOVFF  644,687
0A130:  MOVLB  0
0A132:  CALL   1F9A
0A136:  BNC   A15C
0A138:  MOVLW  01
0A13A:  MOVLB  6
0A13C:  SUBWF  x43,W
0A13E:  MULLW  04
0A140:  MOVF   FF3,W
0A142:  CLRF   03
0A144:  ADDLW  EA
0A146:  MOVWF  FE9
0A148:  MOVLW  00
0A14A:  ADDWFC 03,W
0A14C:  MOVWF  FEA
0A14E:  MOVLW  84
0A150:  MOVWF  FEF
0A152:  MOVLW  7C
0A154:  MOVWF  FEC
0A156:  CLRF   FEC
0A158:  CLRF   FEC
0A15A:  BRA    A1CC
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
0A15C:  MOVFF  647,686
0A160:  MOVFF  646,685
0A164:  MOVFF  645,684
0A168:  MOVFF  644,683
0A16C:  MOVLB  6
0A16E:  CLRF   x8A
0A170:  CLRF   x89
0A172:  MOVLW  FC
0A174:  MOVWF  x88
0A176:  MOVLW  84
0A178:  MOVWF  x87
0A17A:  MOVLB  0
0A17C:  CALL   1F9A
0A180:  BNC   A1A6
0A182:  MOVLW  01
0A184:  MOVLB  6
0A186:  SUBWF  x43,W
0A188:  MULLW  04
0A18A:  MOVF   FF3,W
0A18C:  CLRF   03
0A18E:  ADDLW  EA
0A190:  MOVWF  FE9
0A192:  MOVLW  00
0A194:  ADDWFC 03,W
0A196:  MOVWF  FEA
0A198:  MOVLW  84
0A19A:  MOVWF  FEF
0A19C:  MOVLW  FC
0A19E:  MOVWF  FEC
0A1A0:  CLRF   FEC
0A1A2:  CLRF   FEC
0A1A4:  BRA    A1CC
....................    else manualOutputValues[arg1-1] = arg2;
0A1A6:  MOVLW  01
0A1A8:  MOVLB  6
0A1AA:  SUBWF  x43,W
0A1AC:  MULLW  04
0A1AE:  MOVF   FF3,W
0A1B0:  CLRF   03
0A1B2:  ADDLW  EA
0A1B4:  MOVWF  FE9
0A1B6:  MOVLW  00
0A1B8:  ADDWFC 03,W
0A1BA:  MOVWF  FEA
0A1BC:  MOVFF  644,FEF
0A1C0:  MOVFF  645,FEC
0A1C4:  MOVFF  646,FEC
0A1C8:  MOVFF  647,FEC
....................    
....................    return SUCCESS;
0A1CC:  MOVLW  00
0A1CE:  MOVWF  01
0A1D0:  MOVLB  0
0A1D2:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A1D4:  MOVLW  01
0A1D6:  MOVWF  01
0A1D8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
0704E:  MOVLB  6
07050:  BCF    x4E.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
07052:  CLRF   x4F
07054:  MOVFF  64D,67A
07058:  MOVFF  64C,679
0705C:  MOVLB  0
0705E:  CALL   5C0A
07062:  MOVFF  02,03
07066:  MOVF   01,W
07068:  MOVF   03,F
0706A:  BNZ   7076
0706C:  MOVF   01,W
0706E:  MOVLB  6
07070:  SUBWF  x4F,W
07072:  BC    7108
07074:  MOVLB  0
....................       if (!isdigit(arg[i])){
07076:  MOVLB  6
07078:  MOVF   x4F,W
0707A:  ADDWF  x4C,W
0707C:  MOVWF  FE9
0707E:  MOVLW  00
07080:  ADDWFC x4D,W
07082:  MOVWF  FEA
07084:  MOVFF  FEF,650
07088:  MOVF   x50,W
0708A:  SUBLW  2F
0708C:  BC    7094
0708E:  MOVF   x50,W
07090:  SUBLW  39
07092:  BC    7100
....................          // Check for negative sign
....................          if ('-' != arg[i]){
07094:  MOVF   x4F,W
07096:  ADDWF  x4C,W
07098:  MOVWF  FE9
0709A:  MOVLW  00
0709C:  ADDWFC x4D,W
0709E:  MOVWF  FEA
070A0:  MOVF   FEF,W
070A2:  SUBLW  2D
070A4:  BZ    70D0
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
070A6:  MOVF   x4F,W
070A8:  ADDWF  x4C,W
070AA:  MOVWF  FE9
070AC:  MOVLW  00
070AE:  ADDWFC x4D,W
070B0:  MOVWF  FEA
070B2:  MOVF   FEF,W
070B4:  SUBLW  2E
070B6:  BZ    70C0
070B8:  MOVLW  00
070BA:  MOVWF  01
070BC:  BRA    710C
070BE:  BRA    70CE
....................             else if  (decimal) return FALSE;
070C0:  BTFSS  x4E.0
070C2:  BRA    70CC
070C4:  MOVLW  00
070C6:  MOVWF  01
070C8:  BRA    710C
070CA:  BRA    70CE
....................             else decimal = TRUE;
070CC:  BSF    x4E.0
....................          }
070CE:  BRA    7100
....................          else if (0 != i) return FALSE;
070D0:  MOVF   x4F,F
070D2:  BZ    70DC
070D4:  MOVLW  00
070D6:  MOVWF  01
070D8:  BRA    710C
070DA:  BRA    7100
....................          else if (1 == strlen(arg)) return FALSE;
070DC:  MOVFF  64D,67A
070E0:  MOVFF  64C,679
070E4:  MOVLB  0
070E6:  CALL   5C0A
070EA:  MOVFF  02,03
070EE:  MOVF   01,W
070F0:  SUBLW  01
070F2:  BNZ   7102
070F4:  MOVF   03,F
070F6:  BNZ   7102
070F8:  MOVLW  00
070FA:  MOVWF  01
070FC:  MOVLB  6
070FE:  BRA    710C
07100:  MOVLB  0
....................       }
07102:  MOVLB  6
07104:  INCF   x4F,F
07106:  BRA    7054
....................    }
....................    return TRUE;
07108:  MOVLW  01
0710A:  MOVWF  01
0710C:  MOVLB  0
0710E:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05D82:  MOVFF  66C,67A
05D86:  MOVFF  66B,679
05D8A:  RCALL  5C0A
05D8C:  MOVFF  02,03
05D90:  MOVF   01,W
05D92:  SUBLW  01
05D94:  BNZ   5D9A
05D96:  MOVF   03,F
05D98:  BZ    5DA2
05D9A:  MOVLW  00
05D9C:  MOVWF  01
05D9E:  BRA    5DD0
05DA0:  BRA    5DC8
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05DA2:  MOVLB  6
05DA4:  MOVFF  66B,FE9
05DA8:  MOVFF  66C,FEA
05DAC:  MOVF   FEF,W
05DAE:  SUBLW  31
05DB0:  BZ    5DCA
05DB2:  MOVFF  66B,FE9
05DB6:  MOVFF  66C,FEA
05DBA:  MOVF   FEF,W
05DBC:  SUBLW  32
05DBE:  BZ    5DCA
05DC0:  MOVLW  00
05DC2:  MOVWF  01
05DC4:  MOVLB  0
05DC6:  BRA    5DD0
05DC8:  MOVLB  6
....................     return TRUE;
05DCA:  MOVLW  01
05DCC:  MOVWF  01
05DCE:  MOVLB  0
05DD0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05BD0:  MOVLB  6
05BD2:  MOVF   x42,W
05BD4:  SUBLW  2F
05BD6:  BC    5BE8
05BD8:  MOVF   x42,W
05BDA:  SUBLW  39
05BDC:  BNC   5BE8
05BDE:  MOVLW  30
05BE0:  SUBWF  x42,W
05BE2:  MOVWF  01
05BE4:  BRA    5C04
05BE6:  BRA    5C04
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05BE8:  MOVF   x42,W
05BEA:  SUBLW  40
05BEC:  BC    5C00
05BEE:  MOVF   x42,W
05BF0:  SUBLW  46
05BF2:  BNC   5C00
05BF4:  MOVLW  41
05BF6:  SUBWF  x42,W
05BF8:  ADDLW  0A
05BFA:  MOVWF  01
05BFC:  BRA    5C04
05BFE:  BRA    5C04
....................    else return 0xFF;
05C00:  MOVLW  FF
05C02:  MOVWF  01
05C04:  MOVLB  0
05C06:  GOTO   A27E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A1DA:  MOVLB  6
0A1DC:  CLRF   x7A
0A1DE:  MOVFF  639,679
0A1E2:  CLRF   x7C
0A1E4:  MOVLW  B5
0A1E6:  MOVWF  x7B
0A1E8:  MOVLB  0
0A1EA:  CALL   0BBE
0A1EE:  MOVFF  02,642
0A1F2:  MOVFF  01,641
0A1F6:  MOVLW  06
0A1F8:  MOVLB  6
0A1FA:  ADDWF  x41,F
0A1FC:  MOVLW  00
0A1FE:  ADDWFC x42,F
0A200:  MOVLW  B4
0A202:  ADDWF  x41,W
0A204:  MOVWF  01
0A206:  MOVLW  01
0A208:  ADDWFC x42,W
0A20A:  MOVWF  03
0A20C:  MOVFF  01,63A
0A210:  MOVWF  x3B
0A212:  CLRF   x7A
0A214:  MOVFF  639,679
0A218:  CLRF   x7C
0A21A:  MOVLW  B5
0A21C:  MOVWF  x7B
0A21E:  MOVLB  0
0A220:  CALL   0BBE
0A224:  MOVFF  02,644
0A228:  MOVFF  01,643
0A22C:  MOVLW  06
0A22E:  MOVLB  6
0A230:  ADDWF  x43,F
0A232:  MOVLW  00
0A234:  ADDWFC x44,F
0A236:  MOVLW  19
0A238:  ADDWF  x43,W
0A23A:  MOVWF  01
0A23C:  MOVLW  00
0A23E:  ADDWFC x44,W
0A240:  MOVWF  03
0A242:  MOVF   01,W
0A244:  ADDLW  B4
0A246:  MOVWF  01
0A248:  MOVLW  01
0A24A:  ADDWFC 03,F
0A24C:  MOVFF  01,63C
0A250:  MOVFF  03,63D
0A254:  CLRF   x3E
0A256:  CLRF   x3F
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A258:  MOVFF  63A,FE9
0A25C:  MOVFF  63B,FEA
0A260:  MOVF   FEF,W
0A262:  SUBLW  44
0A264:  BTFSS  FD8.2
0A266:  BRA    A356
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A268:  MOVLW  01
0A26A:  ADDWF  x3A,W
0A26C:  MOVWF  FE9
0A26E:  MOVLW  00
0A270:  ADDWFC x3B,W
0A272:  MOVWF  FEA
0A274:  MOVFF  FEF,642
0A278:  MOVLB  0
0A27A:  GOTO   5BD0
0A27E:  MOVFF  01,641
0A282:  MOVLB  6
0A284:  MOVF   x3E,W
0A286:  ANDLW  0F
0A288:  SUBWF  01,W
0A28A:  BNZ   A34E
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A28C:  MOVF   x3F,W
0A28E:  MULLW  04
0A290:  MOVF   FF3,W
0A292:  CLRF   x42
0A294:  MOVWF  x41
0A296:  MOVLW  34
0A298:  ADDWF  x41,W
0A29A:  MOVWF  FE9
0A29C:  MOVLW  05
0A29E:  ADDWFC x42,W
0A2A0:  MOVWF  FEA
0A2A2:  MOVFF  FEC,67A
0A2A6:  MOVF   FED,F
0A2A8:  MOVFF  FEF,679
0A2AC:  MOVLB  0
0A2AE:  CALL   5C0A
0A2B2:  MOVFF  02,03
0A2B6:  MOVF   01,W
0A2B8:  BNZ   A2BE
0A2BA:  MOVF   03,F
0A2BC:  BZ    A344
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A2BE:  MOVLB  6
0A2C0:  MOVF   x3F,W
0A2C2:  MULLW  04
0A2C4:  MOVF   FF3,W
0A2C6:  CLRF   x42
0A2C8:  MOVWF  x41
0A2CA:  MOVLW  34
0A2CC:  ADDWF  x41,W
0A2CE:  MOVWF  FE9
0A2D0:  MOVLW  05
0A2D2:  ADDWFC x42,W
0A2D4:  MOVWF  FEA
0A2D6:  MOVFF  FEC,67C
0A2DA:  MOVF   FED,F
0A2DC:  MOVFF  FEF,67B
0A2E0:  MOVFF  63D,67A
0A2E4:  MOVFF  63C,679
0A2E8:  MOVLB  0
0A2EA:  CALL   5C42
0A2EE:  MOVF   01,F
0A2F0:  BNZ   A33C
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A2F2:  MOVLB  6
0A2F4:  MOVF   x3F,W
0A2F6:  MULLW  04
0A2F8:  MOVF   FF3,W
0A2FA:  CLRF   x42
0A2FC:  MOVWF  x41
0A2FE:  MOVLW  02
0A300:  ADDWF  x41,W
0A302:  MOVWF  01
0A304:  MOVLW  00
0A306:  ADDWFC x42,W
0A308:  MOVWF  03
0A30A:  MOVF   01,W
0A30C:  ADDLW  34
0A30E:  MOVWF  01
0A310:  MOVLW  05
0A312:  ADDWFC 03,F
0A314:  MOVFF  01,641
0A318:  MOVFF  03,642
0A31C:  MOVFF  03,FEA
0A320:  MOVFF  01,FE9
0A324:  MOVFF  639,637
0A328:  MOVLB  0
0A32A:  CALL   00BC
0A32E:  MOVFF  01,640
....................                return return_code;
0A332:  MOVLB  6
0A334:  MOVFF  640,01
0A338:  BRA    A35A
0A33A:  MOVLB  0
....................             }
....................             i++;
0A33C:  MOVLB  6
0A33E:  INCF   x3F,F
0A340:  BRA    A28C
0A342:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A344:  MOVLW  01
0A346:  MOVWF  01
0A348:  MOVLB  6
0A34A:  BRA    A35A
....................       } else return 254; // NOT THIS ADDRESS
0A34C:  BRA    A354
0A34E:  MOVLW  FE
0A350:  MOVWF  01
0A352:  BRA    A35A
....................    } else return 255; // NOT THIS DEVICE TYPE
0A354:  BRA    A35A
0A356:  MOVLW  FF
0A358:  MOVWF  01
0A35A:  MOVLB  0
0A35C:  GOTO   A396 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A388:  GOTO   5B76
0A38C:  MOVF   01,F
0A38E:  BZ    A47E
....................    {
....................       int8 return_code = command_parser(SRI);
0A390:  MOVFF  488,639
0A394:  BRA    A1DA
0A396:  MOVFF  01,638
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A39A:  MOVLW  04
0A39C:  MOVLB  6
0A39E:  MOVWF  x7A
0A3A0:  MOVLW  8A
0A3A2:  MOVWF  x79
0A3A4:  MOVLB  0
0A3A6:  CALL   5C0A
0A3AA:  MOVF   01,W
0A3AC:  ADDLW  8A
0A3AE:  MOVLB  6
0A3B0:  MOVWF  x39
0A3B2:  MOVLW  04
0A3B4:  ADDWFC 02,W
0A3B6:  MOVWF  x3A
0A3B8:  MOVF   x38,W
0A3BA:  MULLW  03
0A3BC:  MOVF   FF3,W
0A3BE:  CLRF   x3C
0A3C0:  MOVWF  x3B
0A3C2:  MOVLW  01
0A3C4:  ADDWF  x3B,W
0A3C6:  MOVWF  01
0A3C8:  MOVLW  00
0A3CA:  ADDWFC x3C,W
0A3CC:  MOVWF  03
0A3CE:  MOVF   01,W
0A3D0:  ADDLW  03
0A3D2:  MOVWF  FE9
0A3D4:  MOVLW  06
0A3D6:  ADDWFC 03,W
0A3D8:  MOVWF  FEA
0A3DA:  MOVFF  FEC,63C
0A3DE:  MOVF   FED,F
0A3E0:  MOVFF  FEF,63B
0A3E4:  MOVFF  63A,52F
0A3E8:  MOVFF  639,52E
0A3EC:  MOVFF  52F,FEA
0A3F0:  MOVFF  52E,FE9
0A3F4:  CLRF   FEF
0A3F6:  MOVFF  63C,FEA
0A3FA:  MOVFF  63B,FE9
0A3FE:  MOVLB  0
0A400:  BRA    A360
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
0A402:  MOVLB  6
0A404:  CLRF   x7A
0A406:  MOVFF  488,679
0A40A:  CLRF   x7C
0A40C:  MOVLW  B5
0A40E:  MOVWF  x7B
0A410:  MOVLB  0
0A412:  CALL   0BBE
0A416:  MOVFF  02,63A
0A41A:  MOVFF  01,639
0A41E:  MOVLW  06
0A420:  MOVLB  6
0A422:  ADDWF  x39,F
0A424:  MOVLW  00
0A426:  ADDWFC x3A,F
0A428:  MOVLW  B4
0A42A:  ADDWF  x39,W
0A42C:  MOVWF  01
0A42E:  MOVLW  01
0A430:  ADDWFC x3A,W
0A432:  MOVWF  03
0A434:  MOVFF  01,63B
0A438:  MOVWF  x3C
0A43A:  MOVLW  24
0A43C:  MOVWF  x4E
0A43E:  MOVLB  0
0A440:  CALL   5214
0A444:  MOVFF  63C,FEA
0A448:  MOVFF  63B,FE9
0A44C:  CALL   523C
0A450:  MOVLW  2C
0A452:  MOVLB  6
0A454:  MOVWF  x4E
0A456:  MOVLB  0
0A458:  CALL   5214
0A45C:  MOVLW  04
0A45E:  MOVWF  FEA
0A460:  MOVLW  8A
0A462:  MOVWF  FE9
0A464:  CALL   523C
0A468:  MOVLW  0A
0A46A:  MOVLB  6
0A46C:  MOVWF  x4E
0A46E:  MOVLB  0
0A470:  CALL   5214
....................       
....................       resetSERcmd(SRI);
0A474:  MOVFF  488,639
0A478:  CALL   0BE0
0A47C:  BRA    A388
....................    }
0A47E:  GOTO   AAFE (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A482:  CLRF   FF8
0A484:  BCF    FF2.5
0A486:  BSF    07.7
0A488:  MOVLB  E
0A48A:  MOVLW  55
0A48C:  MOVWF  x9B
0A48E:  MOVLW  AA
0A490:  MOVWF  x9B
0A492:  BCF    x9B.0
0A494:  MOVLW  17
0A496:  MOVWF  xB0
0A498:  MOVLW  13
0A49A:  MOVWF  xB2
0A49C:  MOVLW  09
0A49E:  MOVWF  x8A
0A4A0:  MOVLW  0A
0A4A2:  MOVWF  x8B
0A4A4:  MOVLW  11
0A4A6:  MOVWF  xEB
0A4A8:  MOVLW  12
0A4AA:  MOVWF  xED
0A4AC:  MOVLW  10
0A4AE:  MOVWF  xF4
0A4B0:  MOVLW  0F
0A4B2:  MOVWF  xF5
0A4B4:  MOVLW  09
0A4B6:  MOVWF  xF8
0A4B8:  MOVLW  55
0A4BA:  MOVWF  x9B
0A4BC:  MOVLW  AA
0A4BE:  MOVWF  x9B
0A4C0:  BSF    x9B.0
0A4C2:  CLRF   xD8
0A4C4:  CLRF   xD5
0A4C6:  CLRF   xD7
0A4C8:  MOVLW  08
0A4CA:  MOVWF  xD9
0A4CC:  MOVLW  60
0A4CE:  MOVWF  xD3
0A4D0:  MOVLW  AA
0A4D2:  MOVLB  0
0A4D4:  MOVWF  xF2
0A4D6:  MOVLB  1
0A4D8:  CLRF   x5A
0A4DA:  CLRF   x59
0A4DC:  CLRF   x58
0A4DE:  CLRF   x57
0A4E0:  CLRF   x5E
0A4E2:  CLRF   x5D
0A4E4:  CLRF   x5C
0A4E6:  CLRF   x5B
0A4E8:  CLRF   x62
0A4EA:  CLRF   x61
0A4EC:  CLRF   x60
0A4EE:  CLRF   x5F
0A4F0:  CLRF   x64
0A4F2:  CLRF   x63
0A4F4:  MOVLB  E
0A4F6:  BCF    x91.5
0A4F8:  MOVLW  00
0A4FA:  MOVWF  x90
0A4FC:  MOVLW  0F
0A4FE:  MOVWF  x8E
0A500:  MOVLW  2A
0A502:  MOVWF  x91
0A504:  MOVLW  C4
0A506:  MOVWF  F88
0A508:  MOVWF  F88
0A50A:  MOVWF  F88
0A50C:  BCF    F95.5
0A50E:  MOVLW  40
0A510:  MOVWF  F94
0A512:  MOVLW  9F
0A514:  MOVWF  F92
0A516:  MOVLW  3A
0A518:  MOVWF  F95
0A51A:  MOVLW  93
0A51C:  MOVWF  F89
0A51E:  MOVWF  F89
0A520:  MOVLB  4
0A522:  CLRF   x88
0A524:  CLRF   x89
0A526:  MOVLB  5
0A528:  CLRF   x2A
0A52A:  CLRF   x2B
0A52C:  BCF    x2C.0
0A52E:  CLRF   x2D
0A530:  BSF    F9E.3
0A532:  MOVLW  7C
0A534:  MOVWF  F9A
0A536:  MOVLW  00
0A538:  MOVWF  F9B
0A53A:  MOVLW  A6
0A53C:  MOVWF  F9D
0A53E:  MOVLW  90
0A540:  MOVWF  F9C
0A542:  MOVLW  93
0A544:  MOVWF  F89
0A546:  BCF    F84.5
0A548:  CLRF   x2F
0A54A:  CLRF   x2E
0A54C:  CLRF   x33
0A54E:  CLRF   x32
0A550:  CLRF   x31
0A552:  CLRF   x30
0A554:  MOVLB  F
0A556:  CLRF   x0C
0A558:  CLRF   x14
0A55A:  CLRF   x1C
0A55C:  CLRF   x21
0A55E:  CLRF   x29
0A560:  CLRF   x35
0A562:  CLRF   x36
0A564:  CLRF   x37
0A566:  CLRF   x34
0A568:  CLRF   x31
0A56A:  CLRF   x32
0A56C:  CLRF   x33
0A56E:  CLRF   x30
0A570:  MOVLW  5C
0A572:  MOVLB  5
0A574:  MOVWF  x37
0A576:  MOVLW  FA
0A578:  MOVWF  x36
0A57A:  MOVLW  5D
0A57C:  MOVWF  x3B
0A57E:  MOVLW  3E
0A580:  MOVWF  x3A
0A582:  MOVLW  62
0A584:  MOVWF  x3F
0A586:  MOVLW  86
0A588:  MOVWF  x3E
0A58A:  MOVLW  64
0A58C:  MOVWF  x43
0A58E:  MOVLW  64
0A590:  MOVWF  x42
0A592:  MOVLW  66
0A594:  MOVWF  x47
0A596:  MOVLW  3C
0A598:  MOVWF  x46
0A59A:  MOVLW  67
0A59C:  MOVWF  x4B
0A59E:  MOVLW  C8
0A5A0:  MOVWF  x4A
0A5A2:  MOVLW  6B
0A5A4:  MOVWF  x4F
0A5A6:  MOVLW  98
0A5A8:  MOVWF  x4E
0A5AA:  MOVLW  73
0A5AC:  MOVWF  x53
0A5AE:  MOVLW  6A
0A5B0:  MOVWF  x52
0A5B2:  MOVLW  76
0A5B4:  MOVWF  x57
0A5B6:  MOVLW  4A
0A5B8:  MOVWF  x56
0A5BA:  MOVLW  77
0A5BC:  MOVWF  x5B
0A5BE:  MOVLW  AC
0A5C0:  MOVWF  x5A
0A5C2:  MOVLW  79
0A5C4:  MOVWF  x5F
0A5C6:  MOVLW  6A
0A5C8:  MOVWF  x5E
0A5CA:  MOVLW  7D
0A5CC:  MOVWF  x63
0A5CE:  MOVLW  20
0A5D0:  MOVWF  x62
0A5D2:  MOVLW  82
0A5D4:  MOVWF  x67
0A5D6:  MOVLW  7C
0A5D8:  MOVWF  x66
0A5DA:  MOVLW  86
0A5DC:  MOVWF  x6B
0A5DE:  MOVLW  14
0A5E0:  MOVWF  x6A
0A5E2:  MOVLW  8B
0A5E4:  MOVWF  x6F
0A5E6:  MOVLW  40
0A5E8:  MOVWF  x6E
0A5EA:  MOVLW  8B
0A5EC:  MOVWF  x73
0A5EE:  MOVLW  46
0A5F0:  MOVWF  x72
0A5F2:  MOVLW  91
0A5F4:  MOVWF  x77
0A5F6:  MOVLW  BA
0A5F8:  MOVWF  x76
0A5FA:  MOVLW  97
0A5FC:  MOVWF  x7B
0A5FE:  MOVLW  1E
0A600:  MOVWF  x7A
0A602:  MOVLW  9E
0A604:  MOVWF  x7F
0A606:  MOVLW  40
0A608:  MOVWF  x7E
0A60A:  MOVLW  9F
0A60C:  MOVWF  x83
0A60E:  MOVLW  92
0A610:  MOVWF  x82
0A612:  MOVLW  A1
0A614:  MOVWF  x87
0A616:  MOVLW  D4
0A618:  MOVWF  x86
0A61A:  BRA    A7E2
0A61C:  DATA 02,00
0A61E:  DATA 1A,00
0A620:  DATA 00,0C
0A622:  DATA 00,20
0A624:  DATA 78,23
0A626:  DATA D7,0A
0A628:  DATA 7D,19
0A62A:  DATA 99,9A
0A62C:  DATA 7B,4C
0A62E:  DATA CC,CD
0A630:  DATA 14,C0
0A632:  DATA 00,0C
0A634:  DATA 80,78
0A636:  DATA 23,D7
0A638:  DATA 0A,7D
0A63A:  DATA 19,99
0A63C:  DATA 9A,7B
0A63E:  DATA 4C,CC
0A640:  DATA CD,14
0A642:  DATA C0,00
0A644:  DATA 01,80
0A646:  DATA 02,09
0A648:  DATA C0,00
0A64A:  DATA 05,80
0A64C:  DATA 7F,00
0A64E:  DATA 00,00
0A650:  DATA 7F,0B
0A652:  DATA C0,00
0A654:  DATA 05,80
0A656:  DATA 7F,00
0A658:  DATA 00,00
0A65A:  DATA 7F,07
0A65C:  DATA C0,00
0A65E:  DATA 01,80
0A660:  DATA 7F,17
0A662:  DATA C0,00
0A664:  DATA 01,80
0A666:  DATA 7F,17
0A668:  DATA C0,00
0A66A:  DATA 04,80
0A66C:  DATA 79,B7
0A66E:  DATA F3,BD
0A670:  DATA 04,C0
0A672:  DATA 00,04
0A674:  DATA 80,7C
0A676:  DATA 59,DF
0A678:  DATA 4E,04
0A67A:  DATA C0,00
0A67C:  DATA 04,80
0A67E:  DATA 78,0A
0A680:  DATA 28,88
0A682:  DATA 04,C0
0A684:  DATA 00,04
0A686:  DATA 80,78
0A688:  DATA 05,EA
0A68A:  DATA 16,04
0A68C:  DATA C0,00
0A68E:  DATA 04,80
0A690:  DATA 78,1E
0A692:  DATA 33,D7
0A694:  DATA 04,C0
0A696:  DATA 00,04
0A698:  DATA 80,77
0A69A:  DATA 68,7B
0A69C:  DATA BB,04
0A69E:  DATA C0,00
0A6A0:  DATA 04,80
0A6A2:  DATA 77,68
0A6A4:  DATA 0D,C6
0A6A6:  DATA 08,C0
0A6A8:  DATA 00,64
0A6AA:  DATA 40,F3
0A6AC:  DATA 00,05
0A6AE:  DATA 01,95
0A6B0:  DATA 00,65
0A6B2:  DATA 01,71
0A6B4:  DATA 01,09
0A6B6:  DATA C0,00
0A6B8:  DATA 04,80
0A6BA:  DATA 7D,01
0A6BC:  DATA 89,01
0A6BE:  DATA 0D,C0
0A6C0:  DATA 00,3C
0A6C2:  DATA 44,EE
0A6C4:  DATA 00,02
0A6C6:  DATA 05,34
0A6C8:  DATA 88,05
0A6CA:  DATA 02,05
0A6CC:  DATA 38,8B
0A6CE:  DATA 05,02
0A6D0:  DATA 05,3C
0A6D2:  DATA 8E,05
0A6D4:  DATA 02,05
0A6D6:  DATA 40,95
0A6D8:  DATA 05,02
0A6DA:  DATA 05,44
0A6DC:  DATA 9C,05
0A6DE:  DATA 02,05
0A6E0:  DATA 48,A4
0A6E2:  DATA 05,02
0A6E4:  DATA 05,4C
0A6E6:  DATA AC,05
0A6E8:  DATA 02,05
0A6EA:  DATA 50,B1
0A6EC:  DATA 05,02
0A6EE:  DATA 05,54
0A6F0:  DATA B6,05
0A6F2:  DATA 02,05
0A6F4:  DATA 58,BA
0A6F6:  DATA 05,02
0A6F8:  DATA 05,5C
0A6FA:  DATA BE,05
0A6FC:  DATA 02,05
0A6FE:  DATA 60,C5
0A700:  DATA 05,02
0A702:  DATA 05,64
0A704:  DATA CB,05
0A706:  DATA 02,05
0A708:  DATA 68,D1
0A70A:  DATA 05,02
0A70C:  DATA 05,6C
0A70E:  DATA D7,05
0A710:  DATA 02,05
0A712:  DATA 70,DD
0A714:  DATA 05,02
0A716:  DATA 05,74
0A718:  DATA E2,05
0A71A:  DATA 02,05
0A71C:  DATA 78,EB
0A71E:  DATA 05,02
0A720:  DATA 05,7C
0A722:  DATA F3,05
0A724:  DATA 02,05
0A726:  DATA 80,FA
0A728:  DATA 05,02
0A72A:  DATA 05,84
0A72C:  DATA 01,06
0A72E:  DATA 78,05
0A730:  DATA 88,67
0A732:  DATA 72,00
0A734:  DATA 67,73
0A736:  DATA 00,67
0A738:  DATA 43,68
0A73A:  DATA 4D,61
0A73C:  DATA 70,00
0A73E:  DATA 73,43
0A740:  DATA 68,4D
0A742:  DATA 61,70
0A744:  DATA 00,67
0A746:  DATA 43,68
0A748:  DATA 4D,6F
0A74A:  DATA 64,65
0A74C:  DATA 00,73
0A74E:  DATA 43,68
0A750:  DATA 4D,6F
0A752:  DATA 64,65
0A754:  DATA 00,67
0A756:  DATA 50,49
0A758:  DATA 44,00
0A75A:  DATA 73,50
0A75C:  DATA 49,44
0A75E:  DATA 00,67
0A760:  DATA 53,50
0A762:  DATA 00,73
0A764:  DATA 53,50
0A766:  DATA 00,67
0A768:  DATA 53,43
0A76A:  DATA 61,6C
0A76C:  DATA 73,00
0A76E:  DATA 67,53
0A770:  DATA 43,61
0A772:  DATA 6C,00
0A774:  DATA 73,53
0A776:  DATA 43,61
0A778:  DATA 6C,00
0A77A:  DATA 67,4D
0A77C:  DATA 43,61
0A77E:  DATA 6C,00
0A780:  DATA 73,4D
0A782:  DATA 43,61
0A784:  DATA 6C,00
0A786:  DATA 67,4D
0A788:  DATA 6F,6E
0A78A:  DATA 00,67
0A78C:  DATA 50,49
0A78E:  DATA 44,64
0A790:  DATA 61,74
0A792:  DATA 61,00
0A794:  DATA 67,49
0A796:  DATA 50,64
0A798:  DATA 61,74
0A79A:  DATA 61,00
0A79C:  DATA 67,4D
0A79E:  DATA 61,6E
0A7A0:  DATA 4F,50
0A7A2:  DATA 00,73
0A7A4:  DATA 4D,61
0A7A6:  DATA 6E,4F
0A7A8:  DATA 50,04
0A7AA:  DATA C0,00
0A7AC:  DATA 33,80
0A7AE:  DATA 0C,06
0A7B0:  DATA 01,14
0A7B2:  DATA 06,02
0A7B4:  DATA 24,06
0A7B6:  DATA 53,55
0A7B8:  DATA 43,43
0A7BA:  DATA 45,53
0A7BC:  DATA 53,00
0A7BE:  DATA 49,4E
0A7C0:  DATA 56,41
0A7C2:  DATA 4C,49
0A7C4:  DATA 44,20
0A7C6:  DATA 43,4F
0A7C8:  DATA 4D,4D
0A7CA:  DATA 41,4E
0A7CC:  DATA 44,00
0A7CE:  DATA 49,4E
0A7D0:  DATA 56,41
0A7D2:  DATA 4C,49
0A7D4:  DATA 44,20
0A7D6:  DATA 50,41
0A7D8:  DATA 52,41
0A7DA:  DATA 4D,45
0A7DC:  DATA 54,45
0A7DE:  DATA 52,00
0A7E0:  DATA 00,00
0A7E2:  MOVLW  00
0A7E4:  MOVWF  FF8
0A7E6:  MOVLW  A6
0A7E8:  MOVWF  FF7
0A7EA:  MOVLW  1C
0A7EC:  MOVWF  FF6
0A7EE:  TBLRD*+
0A7F0:  MOVF   FF5,W
0A7F2:  MOVWF  00
0A7F4:  XORLW  00
0A7F6:  BZ    A81E
0A7F8:  TBLRD*+
0A7FA:  MOVF   FF5,W
0A7FC:  MOVWF  01
0A7FE:  BTFSC  FE8.7
0A800:  BRA    A80C
0A802:  ANDLW  3F
0A804:  MOVWF  FEA
0A806:  TBLRD*+
0A808:  MOVFF  FF5,FE9
0A80C:  BTFSC  01.6
0A80E:  TBLRD*+
0A810:  BTFSS  01.6
0A812:  TBLRD*+
0A814:  MOVFF  FF5,FEE
0A818:  DCFSNZ 00,F
0A81A:  BRA    A7EE
0A81C:  BRA    A810
0A81E:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
0A820:  MOVLB  0
0A822:  GOTO   03A2
....................    params_init();                // load parameters
0A826:  GOTO   064A
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0A82A:  GOTO   0B02
....................    control_init();               // initialize the output control DACs
0A82E:  GOTO   0B9A
....................    serial_init();                // setup the serial port
0A832:  GOTO   0D5A
....................    event_timer_init();
0A836:  GOTO   0D7C
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0A83A:  MOVLW  C0
0A83C:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A83E:  GOTO   115A
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A842:  GOTO   46CC
....................       control_task();            //output control
0A846:  GOTO   5198
....................       serial_task();             //serial port 
0A84A:  GOTO   5260
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A84E:  MOVLW  01
0A850:  MOVLB  6
0A852:  ADDWF  x36,W
0A854:  MOVWF  x38
0A856:  MOVF   x36,W
0A858:  MULLW  21
0A85A:  MOVF   FF3,W
0A85C:  CLRF   x3A
0A85E:  MOVWF  x39
0A860:  MOVLW  08
0A862:  ADDWF  x39,W
0A864:  MOVWF  01
0A866:  MOVLW  00
0A868:  ADDWFC x3A,W
0A86A:  MOVWF  03
0A86C:  MOVF   01,W
0A86E:  ADDLW  0F
0A870:  MOVWF  FE9
0A872:  MOVLW  01
0A874:  ADDWFC 03,W
0A876:  MOVWF  FEA
0A878:  MOVFF  FEF,639
0A87C:  MOVFF  FEC,63A
0A880:  MOVFF  FEC,63B
0A884:  MOVFF  FEC,63C
0A888:  MOVF   x36,W
0A88A:  MULLW  21
0A88C:  MOVF   FF3,W
0A88E:  CLRF   x3E
0A890:  MOVWF  x3D
0A892:  MOVLW  0C
0A894:  ADDWF  x3D,W
0A896:  MOVWF  01
0A898:  MOVLW  00
0A89A:  ADDWFC x3E,W
0A89C:  MOVWF  03
0A89E:  MOVF   01,W
0A8A0:  ADDLW  0F
0A8A2:  MOVWF  FE9
0A8A4:  MOVLW  01
0A8A6:  ADDWFC 03,W
0A8A8:  MOVWF  FEA
0A8AA:  MOVFF  FEF,63D
0A8AE:  MOVFF  FEC,63E
0A8B2:  MOVFF  FEC,63F
0A8B6:  MOVFF  FEC,640
0A8BA:  MOVLW  56
0A8BC:  MOVWF  FF6
0A8BE:  MOVLW  03
0A8C0:  MOVWF  FF7
0A8C2:  MOVLW  08
0A8C4:  MOVWF  x41
0A8C6:  MOVLB  0
0A8C8:  CALL   5758
0A8CC:  MOVFF  638,641
0A8D0:  MOVLW  1B
0A8D2:  MOVLB  6
0A8D4:  MOVWF  x42
0A8D6:  MOVLB  0
0A8D8:  CALL   57AC
0A8DC:  MOVLW  2C
0A8DE:  MOVLB  6
0A8E0:  MOVWF  x4E
0A8E2:  MOVLB  0
0A8E4:  CALL   5214
0A8E8:  MOVLW  89
0A8EA:  MOVWF  FE9
0A8EC:  MOVFF  63C,644
0A8F0:  MOVFF  63B,643
0A8F4:  MOVFF  63A,642
0A8F8:  MOVFF  639,641
0A8FC:  MOVLB  6
0A8FE:  CLRF   x45
0A900:  MOVLB  0
0A902:  CALL   58FE
0A906:  MOVLW  2C
0A908:  MOVLB  6
0A90A:  MOVWF  x4E
0A90C:  MOVLB  0
0A90E:  CALL   5214
0A912:  MOVLW  89
0A914:  MOVWF  FE9
0A916:  MOVFF  640,644
0A91A:  MOVFF  63F,643
0A91E:  MOVFF  63E,642
0A922:  MOVFF  63D,641
0A926:  MOVLB  6
0A928:  CLRF   x45
0A92A:  MOVLB  0
0A92C:  CALL   58FE
0A930:  MOVLW  0A
0A932:  MOVLB  6
0A934:  MOVWF  x4E
0A936:  MOVLB  0
0A938:  CALL   5214
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0A93C:  MOVLW  01
0A93E:  MOVLB  6
0A940:  ADDWF  x36,W
0A942:  MOVWF  x38
0A944:  MOVF   x36,W
0A946:  MULLW  21
0A948:  MOVF   FF3,W
0A94A:  CLRF   x3A
0A94C:  MOVWF  x39
0A94E:  MOVLW  1D
0A950:  ADDWF  x39,W
0A952:  MOVWF  01
0A954:  MOVLW  00
0A956:  ADDWFC x3A,W
0A958:  MOVWF  03
0A95A:  MOVF   01,W
0A95C:  ADDLW  0F
0A95E:  MOVWF  FE9
0A960:  MOVLW  01
0A962:  ADDWFC 03,W
0A964:  MOVWF  FEA
0A966:  MOVFF  FEF,639
0A96A:  MOVFF  FEC,63A
0A96E:  MOVFF  FEC,63B
0A972:  MOVFF  FEC,63C
0A976:  MOVLW  6C
0A978:  MOVWF  FF6
0A97A:  MOVLW  03
0A97C:  MOVWF  FF7
0A97E:  MOVLW  08
0A980:  MOVWF  x41
0A982:  MOVLB  0
0A984:  CALL   5758
0A988:  MOVFF  638,641
0A98C:  MOVLW  1B
0A98E:  MOVLB  6
0A990:  MOVWF  x42
0A992:  MOVLB  0
0A994:  CALL   57AC
0A998:  MOVLW  2C
0A99A:  MOVLB  6
0A99C:  MOVWF  x4E
0A99E:  MOVLB  0
0A9A0:  CALL   5214
0A9A4:  MOVLW  89
0A9A6:  MOVWF  FE9
0A9A8:  MOVFF  63C,644
0A9AC:  MOVFF  63B,643
0A9B0:  MOVFF  63A,642
0A9B4:  MOVFF  639,641
0A9B8:  MOVLW  03
0A9BA:  MOVLB  6
0A9BC:  MOVWF  x45
0A9BE:  MOVLB  0
0A9C0:  CALL   58FE
0A9C4:  MOVLW  0A
0A9C6:  MOVLB  6
0A9C8:  MOVWF  x4E
0A9CA:  MOVLB  0
0A9CC:  CALL   5214
....................       if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0A9D0:  MOVLB  6
0A9D2:  MOVF   x36,W
0A9D4:  MULLW  03
0A9D6:  MOVF   FF3,W
0A9D8:  CLRF   x39
0A9DA:  MOVWF  x38
0A9DC:  MOVLW  02
0A9DE:  ADDWF  x38,W
0A9E0:  MOVWF  01
0A9E2:  MOVLW  00
0A9E4:  ADDWFC x39,W
0A9E6:  MOVWF  03
0A9E8:  MOVF   01,W
0A9EA:  ADDLW  51
0A9EC:  MOVWF  FE9
0A9EE:  MOVLW  01
0A9F0:  ADDWFC 03,W
0A9F2:  MOVWF  FEA
0A9F4:  BTFSS  FEF.0
0A9F6:  BRA    AA74
0A9F8:  MOVLW  01
0A9FA:  ADDWF  x36,W
0A9FC:  MOVWF  x38
0A9FE:  MOVF   x36,W
0AA00:  MULLW  03
0AA02:  MOVF   FF3,W
0AA04:  CLRF   x3A
0AA06:  MOVWF  x39
0AA08:  MOVLW  51
0AA0A:  ADDWF  x39,W
0AA0C:  MOVWF  FE9
0AA0E:  MOVLW  01
0AA10:  ADDWFC x3A,W
0AA12:  MOVWF  FEA
0AA14:  MOVFF  FEC,63C
0AA18:  MOVF   FED,F
0AA1A:  MOVFF  FEF,63B
0AA1E:  MOVLW  7E
0AA20:  MOVWF  FF6
0AA22:  MOVLW  03
0AA24:  MOVWF  FF7
0AA26:  MOVLW  08
0AA28:  MOVWF  x41
0AA2A:  MOVLB  0
0AA2C:  CALL   5758
0AA30:  MOVFF  638,641
0AA34:  MOVLW  1B
0AA36:  MOVLB  6
0AA38:  MOVWF  x42
0AA3A:  MOVLB  0
0AA3C:  CALL   57AC
0AA40:  MOVLW  88
0AA42:  MOVWF  FF6
0AA44:  MOVLW  03
0AA46:  MOVWF  FF7
0AA48:  MOVLW  03
0AA4A:  MOVLB  6
0AA4C:  MOVWF  x41
0AA4E:  MOVLB  0
0AA50:  CALL   5758
0AA54:  MOVLW  10
0AA56:  MOVWF  FE9
0AA58:  MOVFF  63C,63E
0AA5C:  MOVFF  63B,63D
0AA60:  CALL   5AAE
0AA64:  MOVLW  0A
0AA66:  MOVLB  6
0AA68:  MOVWF  x4E
0AA6A:  MOVLB  0
0AA6C:  CALL   5214
0AA70:  BRA    AAEC
0AA72:  MOVLB  6
....................       else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0AA74:  MOVLW  01
0AA76:  ADDWF  x36,W
0AA78:  MOVWF  x38
0AA7A:  MOVF   x36,W
0AA7C:  MULLW  03
0AA7E:  MOVF   FF3,W
0AA80:  CLRF   x3A
0AA82:  MOVWF  x39
0AA84:  MOVLW  51
0AA86:  ADDWF  x39,W
0AA88:  MOVWF  FE9
0AA8A:  MOVLW  01
0AA8C:  ADDWFC x3A,W
0AA8E:  MOVWF  FEA
0AA90:  MOVFF  FEC,63C
0AA94:  MOVF   FED,F
0AA96:  MOVFF  FEF,63B
0AA9A:  MOVLW  90
0AA9C:  MOVWF  FF6
0AA9E:  MOVLW  03
0AAA0:  MOVWF  FF7
0AAA2:  MOVLW  08
0AAA4:  MOVWF  x41
0AAA6:  MOVLB  0
0AAA8:  CALL   5758
0AAAC:  MOVFF  638,641
0AAB0:  MOVLW  1B
0AAB2:  MOVLB  6
0AAB4:  MOVWF  x42
0AAB6:  MOVLB  0
0AAB8:  CALL   57AC
0AABC:  MOVLW  9A
0AABE:  MOVWF  FF6
0AAC0:  MOVLW  03
0AAC2:  MOVWF  FF7
0AAC4:  MOVLW  03
0AAC6:  MOVLB  6
0AAC8:  MOVWF  x41
0AACA:  MOVLB  0
0AACC:  CALL   5758
0AAD0:  MOVLW  10
0AAD2:  MOVWF  FE9
0AAD4:  MOVFF  63C,63E
0AAD8:  MOVFF  63B,63D
0AADC:  CALL   5AAE
0AAE0:  MOVLW  0A
0AAE2:  MOVLB  6
0AAE4:  MOVWF  x4E
0AAE6:  MOVLB  0
0AAE8:  CALL   5214
....................       ch = !ch;
0AAEC:  MOVLB  6
0AAEE:  MOVF   x36,F
0AAF0:  BZ    AAF6
0AAF2:  MOVLW  00
0AAF4:  BRA    AAF8
0AAF6:  MOVLW  01
0AAF8:  MOVWF  x36
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0AAFA:  MOVLB  0
0AAFC:  BRA    A388
....................       
....................       delay_ms(250);
0AAFE:  MOVLW  FA
0AB00:  MOVLB  6
0AB02:  MOVWF  x3E
0AB04:  MOVLB  0
0AB06:  CALL   0438
0AB0A:  BRA    A83E
....................    }
.................... }
0AB0C:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
