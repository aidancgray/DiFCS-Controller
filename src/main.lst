CCS PCH C Compiler, Version 5.117, 2138               09-Dec-25 19:02

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   42520 bytes (65%)
                           Largest free fragment is 23014
               RAM used:   1775 (49%) at main() level
                           1896 (52%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A1CA
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,32
00336:  DATA 30,38
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
*
0067E:  ADDWF  FE8,W
00680:  CLRF   FF7
00682:  RLCF   FF7,F
00684:  ADDLW  99
00686:  MOVWF  FF6
00688:  MOVLW  06
0068A:  ADDWFC FF7,F
0068C:  TBLRD*-
0068E:  MOVF   FF5,W
00690:  MOVWF  FFA
00692:  TBLRD*
00694:  MOVF   FF5,W
00696:  MOVWF  FF9
00698:  DATA 48,06
0069A:  DATA 52,06
0069C:  DATA 5C,06
0069E:  DATA 66,06
*
00828:  MOVLB  7
0082A:  MOVF   x2F,W
0082C:  MULWF  x31
0082E:  MOVFF  FF3,01
00832:  MOVFF  FF4,00
00836:  MULWF  x32
00838:  MOVF   FF3,W
0083A:  ADDWF  00,F
0083C:  MOVF   x30,W
0083E:  MULWF  x31
00840:  MOVF   FF3,W
00842:  ADDWFC 00,W
00844:  MOVWF  02
00846:  MOVLB  0
00848:  RETURN 0
0084A:  MOVLB  7
0084C:  MOVF   x30,W
0084E:  CLRF   01
00850:  SUBWF  x2F,W
00852:  BC    085A
00854:  MOVFF  72F,00
00858:  BRA    0872
0085A:  CLRF   00
0085C:  MOVLW  08
0085E:  MOVWF  x31
00860:  RLCF   x2F,F
00862:  RLCF   00,F
00864:  MOVF   x30,W
00866:  SUBWF  00,W
00868:  BTFSC  FD8.0
0086A:  MOVWF  00
0086C:  RLCF   01,F
0086E:  DECFSZ x31,F
00870:  BRA    0860
00872:  MOVLB  0
00874:  RETURN 0
*
00CEA:  MOVLW  8E
00CEC:  MOVWF  00
00CEE:  MOVFF  748,01
00CF2:  MOVFF  747,02
00CF6:  CLRF   03
00CF8:  MOVF   01,F
00CFA:  BNZ   0D0E
00CFC:  MOVFF  02,01
00D00:  CLRF   02
00D02:  MOVLW  08
00D04:  SUBWF  00,F
00D06:  MOVF   01,F
00D08:  BNZ   0D0E
00D0A:  CLRF   00
00D0C:  BRA    0D1E
00D0E:  BCF    FD8.0
00D10:  BTFSC  01.7
00D12:  BRA    0D1C
00D14:  RLCF   02,F
00D16:  RLCF   01,F
00D18:  DECF   00,F
00D1A:  BRA    0D0E
00D1C:  BCF    01.7
00D1E:  RETURN 0
00D20:  MOVLB  7
00D22:  MOVF   x43,W
00D24:  BTFSC  FD8.2
00D26:  BRA    0E0A
00D28:  MOVWF  00
00D2A:  MOVF   x47,W
00D2C:  BTFSC  FD8.2
00D2E:  BRA    0E0A
00D30:  ADDWF  00,F
00D32:  BNC   0D3C
00D34:  MOVLW  81
00D36:  ADDWF  00,F
00D38:  BC    0E0A
00D3A:  BRA    0D44
00D3C:  MOVLW  7F
00D3E:  SUBWF  00,F
00D40:  BNC   0E0A
00D42:  BZ    0E0A
00D44:  MOVFF  744,74B
00D48:  MOVF   x48,W
00D4A:  XORWF  x4B,F
00D4C:  BSF    x44.7
00D4E:  BSF    x48.7
00D50:  MOVF   x46,W
00D52:  MULWF  x4A
00D54:  MOVFF  FF4,74D
00D58:  MOVF   x45,W
00D5A:  MULWF  x49
00D5C:  MOVFF  FF4,03
00D60:  MOVFF  FF3,74C
00D64:  MULWF  x4A
00D66:  MOVF   FF3,W
00D68:  ADDWF  x4D,F
00D6A:  MOVF   FF4,W
00D6C:  ADDWFC x4C,F
00D6E:  MOVLW  00
00D70:  ADDWFC 03,F
00D72:  MOVF   x46,W
00D74:  MULWF  x49
00D76:  MOVF   FF3,W
00D78:  ADDWF  x4D,F
00D7A:  MOVF   FF4,W
00D7C:  ADDWFC x4C,F
00D7E:  MOVLW  00
00D80:  CLRF   02
00D82:  ADDWFC 03,F
00D84:  ADDWFC 02,F
00D86:  MOVF   x44,W
00D88:  MULWF  x4A
00D8A:  MOVF   FF3,W
00D8C:  ADDWF  x4C,F
00D8E:  MOVF   FF4,W
00D90:  ADDWFC 03,F
00D92:  MOVLW  00
00D94:  ADDWFC 02,F
00D96:  MOVF   x44,W
00D98:  MULWF  x49
00D9A:  MOVF   FF3,W
00D9C:  ADDWF  03,F
00D9E:  MOVF   FF4,W
00DA0:  ADDWFC 02,F
00DA2:  MOVLW  00
00DA4:  CLRF   01
00DA6:  ADDWFC 01,F
00DA8:  MOVF   x46,W
00DAA:  MULWF  x48
00DAC:  MOVF   FF3,W
00DAE:  ADDWF  x4C,F
00DB0:  MOVF   FF4,W
00DB2:  ADDWFC 03,F
00DB4:  MOVLW  00
00DB6:  ADDWFC 02,F
00DB8:  ADDWFC 01,F
00DBA:  MOVF   x45,W
00DBC:  MULWF  x48
00DBE:  MOVF   FF3,W
00DC0:  ADDWF  03,F
00DC2:  MOVF   FF4,W
00DC4:  ADDWFC 02,F
00DC6:  MOVLW  00
00DC8:  ADDWFC 01,F
00DCA:  MOVF   x44,W
00DCC:  MULWF  x48
00DCE:  MOVF   FF3,W
00DD0:  ADDWF  02,F
00DD2:  MOVF   FF4,W
00DD4:  ADDWFC 01,F
00DD6:  INCF   00,F
00DD8:  BTFSC  01.7
00DDA:  BRA    0DE6
00DDC:  RLCF   x4C,F
00DDE:  RLCF   03,F
00DE0:  RLCF   02,F
00DE2:  RLCF   01,F
00DE4:  DECF   00,F
00DE6:  MOVLW  00
00DE8:  BTFSS  x4C.7
00DEA:  BRA    0E00
00DEC:  INCF   03,F
00DEE:  ADDWFC 02,F
00DF0:  ADDWFC 01,F
00DF2:  MOVF   01,W
00DF4:  BNZ   0E00
00DF6:  MOVF   02,W
00DF8:  BNZ   0E00
00DFA:  MOVF   03,W
00DFC:  BNZ   0E00
00DFE:  INCF   00,F
00E00:  BTFSC  x4B.7
00E02:  BSF    01.7
00E04:  BTFSS  x4B.7
00E06:  BCF    01.7
00E08:  BRA    0E12
00E0A:  CLRF   00
00E0C:  CLRF   01
00E0E:  CLRF   02
00E10:  CLRF   03
00E12:  MOVLB  0
00E14:  RETURN 0
00E16:  MOVLW  80
00E18:  BTFSS  FD8.1
00E1A:  BRA    0E20
00E1C:  MOVLB  7
00E1E:  XORWF  x4C,F
00E20:  MOVLB  7
00E22:  CLRF   x51
00E24:  CLRF   x52
00E26:  MOVFF  748,750
00E2A:  MOVF   x4C,W
00E2C:  XORWF  x50,F
00E2E:  MOVF   x47,W
00E30:  BTFSC  FD8.2
00E32:  BRA    0FF2
00E34:  MOVWF  x4F
00E36:  MOVWF  00
00E38:  MOVF   x4B,W
00E3A:  BTFSC  FD8.2
00E3C:  BRA    1004
00E3E:  SUBWF  x4F,F
00E40:  BTFSC  FD8.2
00E42:  BRA    0F4A
00E44:  BNC   0EC2
00E46:  MOVFF  74C,755
00E4A:  BSF    x55.7
00E4C:  MOVFF  74D,754
00E50:  MOVFF  74E,753
00E54:  CLRF   x52
00E56:  BCF    FD8.0
00E58:  RRCF   x55,F
00E5A:  RRCF   x54,F
00E5C:  RRCF   x53,F
00E5E:  RRCF   x52,F
00E60:  DECFSZ x4F,F
00E62:  BRA    0E54
00E64:  BTFSS  x50.7
00E66:  BRA    0E6E
00E68:  BSF    x51.0
00E6A:  BRA    102C
00E6C:  BCF    x51.0
00E6E:  BCF    x4F.0
00E70:  BSF    x51.4
00E72:  MOVLW  07
00E74:  MOVWF  FEA
00E76:  MOVLW  4A
00E78:  MOVWF  FE9
00E7A:  BRA    1052
00E7C:  BCF    x51.4
00E7E:  BTFSC  x50.7
00E80:  BRA    0E96
00E82:  BTFSS  x4F.0
00E84:  BRA    0EAC
00E86:  RRCF   x55,F
00E88:  RRCF   x54,F
00E8A:  RRCF   x53,F
00E8C:  RRCF   x52,F
00E8E:  INCF   00,F
00E90:  BTFSC  FD8.2
00E92:  BRA    1022
00E94:  BRA    0EAC
00E96:  BTFSC  x55.7
00E98:  BRA    0EB2
00E9A:  BCF    FD8.0
00E9C:  RLCF   x52,F
00E9E:  RLCF   x53,F
00EA0:  RLCF   x54,F
00EA2:  RLCF   x55,F
00EA4:  DECF   00,F
00EA6:  BTFSC  FD8.2
00EA8:  BRA    1022
00EAA:  BRA    0E96
00EAC:  BSF    x51.6
00EAE:  BRA    0F8A
00EB0:  BCF    x51.6
00EB2:  MOVFF  748,750
00EB6:  BTFSS  x48.7
00EB8:  BRA    0EBE
00EBA:  BSF    x55.7
00EBC:  BRA    1014
00EBE:  BCF    x55.7
00EC0:  BRA    1014
00EC2:  MOVFF  74B,74F
00EC6:  MOVFF  74B,00
00ECA:  MOVF   x47,W
00ECC:  SUBWF  x4F,F
00ECE:  MOVFF  748,755
00ED2:  BSF    x55.7
00ED4:  MOVFF  749,754
00ED8:  MOVFF  74A,753
00EDC:  CLRF   x52
00EDE:  BCF    FD8.0
00EE0:  RRCF   x55,F
00EE2:  RRCF   x54,F
00EE4:  RRCF   x53,F
00EE6:  RRCF   x52,F
00EE8:  DECFSZ x4F,F
00EEA:  BRA    0EDC
00EEC:  BTFSS  x50.7
00EEE:  BRA    0EF6
00EF0:  BSF    x51.1
00EF2:  BRA    102C
00EF4:  BCF    x51.1
00EF6:  BCF    x4F.0
00EF8:  BSF    x51.5
00EFA:  MOVLW  07
00EFC:  MOVWF  FEA
00EFE:  MOVLW  4E
00F00:  MOVWF  FE9
00F02:  BRA    1052
00F04:  BCF    x51.5
00F06:  BTFSC  x50.7
00F08:  BRA    0F1E
00F0A:  BTFSS  x4F.0
00F0C:  BRA    0F34
00F0E:  RRCF   x55,F
00F10:  RRCF   x54,F
00F12:  RRCF   x53,F
00F14:  RRCF   x52,F
00F16:  INCF   00,F
00F18:  BTFSC  FD8.2
00F1A:  BRA    1022
00F1C:  BRA    0F34
00F1E:  BTFSC  x55.7
00F20:  BRA    0F3A
00F22:  BCF    FD8.0
00F24:  RLCF   x52,F
00F26:  RLCF   x53,F
00F28:  RLCF   x54,F
00F2A:  RLCF   x55,F
00F2C:  DECF   00,F
00F2E:  BTFSC  FD8.2
00F30:  BRA    1022
00F32:  BRA    0F1E
00F34:  BSF    x51.7
00F36:  BRA    0F8A
00F38:  BCF    x51.7
00F3A:  MOVFF  74C,750
00F3E:  BTFSS  x4C.7
00F40:  BRA    0F46
00F42:  BSF    x55.7
00F44:  BRA    1014
00F46:  BCF    x55.7
00F48:  BRA    1014
00F4A:  MOVFF  74C,755
00F4E:  BSF    x55.7
00F50:  MOVFF  74D,754
00F54:  MOVFF  74E,753
00F58:  BTFSS  x50.7
00F5A:  BRA    0F64
00F5C:  BCF    x55.7
00F5E:  BSF    x51.2
00F60:  BRA    102C
00F62:  BCF    x51.2
00F64:  CLRF   x52
00F66:  BCF    x4F.0
00F68:  MOVLW  07
00F6A:  MOVWF  FEA
00F6C:  MOVLW  4A
00F6E:  MOVWF  FE9
00F70:  BRA    1052
00F72:  BTFSC  x50.7
00F74:  BRA    0FAE
00F76:  MOVFF  748,750
00F7A:  BTFSS  x4F.0
00F7C:  BRA    0F8A
00F7E:  RRCF   x55,F
00F80:  RRCF   x54,F
00F82:  RRCF   x53,F
00F84:  RRCF   x52,F
00F86:  INCF   00,F
00F88:  BZ    1022
00F8A:  BTFSS  x52.7
00F8C:  BRA    0FA4
00F8E:  INCF   x53,F
00F90:  BNZ   0FA4
00F92:  INCF   x54,F
00F94:  BNZ   0FA4
00F96:  INCF   x55,F
00F98:  BNZ   0FA4
00F9A:  RRCF   x55,F
00F9C:  RRCF   x54,F
00F9E:  RRCF   x53,F
00FA0:  INCF   00,F
00FA2:  BZ    1022
00FA4:  BTFSC  x51.6
00FA6:  BRA    0EB0
00FA8:  BTFSC  x51.7
00FAA:  BRA    0F38
00FAC:  BRA    0FE6
00FAE:  MOVLW  80
00FB0:  XORWF  x55,F
00FB2:  BTFSS  x55.7
00FB4:  BRA    0FBE
00FB6:  BRA    102C
00FB8:  MOVFF  74C,750
00FBC:  BRA    0FD2
00FBE:  MOVFF  748,750
00FC2:  MOVF   x55,F
00FC4:  BNZ   0FD2
00FC6:  MOVF   x54,F
00FC8:  BNZ   0FD2
00FCA:  MOVF   x53,F
00FCC:  BNZ   0FD2
00FCE:  CLRF   00
00FD0:  BRA    1014
00FD2:  BTFSC  x55.7
00FD4:  BRA    0FE6
00FD6:  BCF    FD8.0
00FD8:  RLCF   x52,F
00FDA:  RLCF   x53,F
00FDC:  RLCF   x54,F
00FDE:  RLCF   x55,F
00FE0:  DECFSZ 00,F
00FE2:  BRA    0FD2
00FE4:  BRA    1022
00FE6:  BTFSS  x50.7
00FE8:  BRA    0FEE
00FEA:  BSF    x55.7
00FEC:  BRA    1014
00FEE:  BCF    x55.7
00FF0:  BRA    1014
00FF2:  MOVFF  74B,00
00FF6:  MOVFF  74C,755
00FFA:  MOVFF  74D,754
00FFE:  MOVFF  74E,753
01002:  BRA    1014
01004:  MOVFF  747,00
01008:  MOVFF  748,755
0100C:  MOVFF  749,754
01010:  MOVFF  74A,753
01014:  MOVFF  755,01
01018:  MOVFF  754,02
0101C:  MOVFF  753,03
01020:  BRA    108A
01022:  CLRF   00
01024:  CLRF   01
01026:  CLRF   02
01028:  CLRF   03
0102A:  BRA    108A
0102C:  CLRF   x52
0102E:  COMF   x53,F
01030:  COMF   x54,F
01032:  COMF   x55,F
01034:  COMF   x52,F
01036:  INCF   x52,F
01038:  BNZ   1044
0103A:  INCF   x53,F
0103C:  BNZ   1044
0103E:  INCF   x54,F
01040:  BNZ   1044
01042:  INCF   x55,F
01044:  BTFSC  x51.0
01046:  BRA    0E6C
01048:  BTFSC  x51.1
0104A:  BRA    0EF4
0104C:  BTFSC  x51.2
0104E:  BRA    0F62
01050:  BRA    0FB8
01052:  MOVF   FEF,W
01054:  ADDWF  x53,F
01056:  BNC   1062
01058:  INCF   x54,F
0105A:  BNZ   1062
0105C:  INCF   x55,F
0105E:  BTFSC  FD8.2
01060:  BSF    x4F.0
01062:  MOVF   FED,F
01064:  MOVF   FEF,W
01066:  ADDWF  x54,F
01068:  BNC   1070
0106A:  INCF   x55,F
0106C:  BTFSC  FD8.2
0106E:  BSF    x4F.0
01070:  MOVF   FED,F
01072:  MOVF   FEF,W
01074:  BTFSC  FEF.7
01076:  BRA    107A
01078:  XORLW  80
0107A:  ADDWF  x55,F
0107C:  BTFSC  FD8.0
0107E:  BSF    x4F.0
01080:  BTFSC  x51.4
01082:  BRA    0E7C
01084:  BTFSC  x51.5
01086:  BRA    0F04
01088:  BRA    0F72
0108A:  MOVLB  0
0108C:  RETURN 0
*
015E4:  ADDWF  FE8,W
015E6:  CLRF   FF7
015E8:  RLCF   FF7,F
015EA:  ADDLW  FF
015EC:  MOVWF  FF6
015EE:  MOVLW  15
015F0:  ADDWFC FF7,F
015F2:  TBLRD*-
015F4:  MOVF   FF5,W
015F6:  MOVWF  FFA
015F8:  TBLRD*
015FA:  MOVF   FF5,W
015FC:  MOVWF  FF9
015FE:  DATA A6,10
01600:  DATA 66,11
01602:  DATA 26,12
01604:  DATA E6,12
01606:  DATA A6,13
01608:  DATA 66,14
0160A:  DATA 26,15
0160C:  BTFSC  FD8.1
0160E:  BRA    1618
01610:  MOVLW  07
01612:  MOVWF  FEA
01614:  MOVLW  2C
01616:  MOVWF  FE9
01618:  MOVLB  7
0161A:  MOVF   x27,W
0161C:  XORWF  x2B,W
0161E:  ANDLW  80
01620:  MOVWF  x31
01622:  BTFSS  x27.7
01624:  BRA    163C
01626:  COMF   x24,F
01628:  COMF   x25,F
0162A:  COMF   x26,F
0162C:  COMF   x27,F
0162E:  INCF   x24,F
01630:  BTFSC  FD8.2
01632:  INCF   x25,F
01634:  BTFSC  FD8.2
01636:  INCF   x26,F
01638:  BTFSC  FD8.2
0163A:  INCF   x27,F
0163C:  BTFSS  x2B.7
0163E:  BRA    1656
01640:  COMF   x28,F
01642:  COMF   x29,F
01644:  COMF   x2A,F
01646:  COMF   x2B,F
01648:  INCF   x28,F
0164A:  BTFSC  FD8.2
0164C:  INCF   x29,F
0164E:  BTFSC  FD8.2
01650:  INCF   x2A,F
01652:  BTFSC  FD8.2
01654:  INCF   x2B,F
01656:  CLRF   00
01658:  CLRF   01
0165A:  CLRF   02
0165C:  CLRF   03
0165E:  CLRF   x2C
01660:  CLRF   x2D
01662:  CLRF   x2E
01664:  CLRF   x2F
01666:  MOVF   x2B,W
01668:  IORWF  x2A,W
0166A:  IORWF  x29,W
0166C:  IORWF  x28,W
0166E:  BZ    16C8
01670:  MOVLW  20
01672:  MOVWF  x30
01674:  BCF    FD8.0
01676:  RLCF   x24,F
01678:  RLCF   x25,F
0167A:  RLCF   x26,F
0167C:  RLCF   x27,F
0167E:  RLCF   x2C,F
01680:  RLCF   x2D,F
01682:  RLCF   x2E,F
01684:  RLCF   x2F,F
01686:  MOVF   x2B,W
01688:  SUBWF  x2F,W
0168A:  BNZ   169C
0168C:  MOVF   x2A,W
0168E:  SUBWF  x2E,W
01690:  BNZ   169C
01692:  MOVF   x29,W
01694:  SUBWF  x2D,W
01696:  BNZ   169C
01698:  MOVF   x28,W
0169A:  SUBWF  x2C,W
0169C:  BNC   16BC
0169E:  MOVF   x28,W
016A0:  SUBWF  x2C,F
016A2:  MOVF   x29,W
016A4:  BTFSS  FD8.0
016A6:  INCFSZ x29,W
016A8:  SUBWF  x2D,F
016AA:  MOVF   x2A,W
016AC:  BTFSS  FD8.0
016AE:  INCFSZ x2A,W
016B0:  SUBWF  x2E,F
016B2:  MOVF   x2B,W
016B4:  BTFSS  FD8.0
016B6:  INCFSZ x2B,W
016B8:  SUBWF  x2F,F
016BA:  BSF    FD8.0
016BC:  RLCF   00,F
016BE:  RLCF   01,F
016C0:  RLCF   02,F
016C2:  RLCF   03,F
016C4:  DECFSZ x30,F
016C6:  BRA    1674
016C8:  BTFSS  x31.7
016CA:  BRA    16E2
016CC:  COMF   00,F
016CE:  COMF   01,F
016D0:  COMF   02,F
016D2:  COMF   03,F
016D4:  INCF   00,F
016D6:  BTFSC  FD8.2
016D8:  INCF   01,F
016DA:  BTFSC  FD8.2
016DC:  INCF   02,F
016DE:  BTFSC  FD8.2
016E0:  INCF   03,F
016E2:  MOVFF  72C,FEF
016E6:  MOVFF  72D,FEC
016EA:  MOVFF  72E,FEC
016EE:  MOVFF  72F,FEC
016F2:  MOVLB  0
016F4:  RETURN 0
*
01C76:  MOVLW  B6
01C78:  MOVWF  00
01C7A:  CLRF   03
01C7C:  CLRF   02
01C7E:  CLRF   01
01C80:  MOVLB  7
01C82:  BCF    x11.0
01C84:  BTFSS  x10.7
01C86:  BRA    1CA0
01C88:  BSF    x11.0
01C8A:  COMF   x0D,F
01C8C:  COMF   x0E,F
01C8E:  COMF   x0F,F
01C90:  COMF   x10,F
01C92:  INCF   x0D,F
01C94:  BNZ   1CA0
01C96:  INCF   x0E,F
01C98:  BNZ   1CA0
01C9A:  INCF   x0F,F
01C9C:  BTFSC  FD8.2
01C9E:  INCF   x10,F
01CA0:  MOVF   x0D,W
01CA2:  IORWF  x0E,W
01CA4:  IORWF  x0F,W
01CA6:  IORWF  x10,W
01CA8:  BNZ   1CAE
01CAA:  CLRF   00
01CAC:  BRA    1CCC
01CAE:  BCF    FD8.0
01CB0:  BTFSC  01.7
01CB2:  BRA    1CC6
01CB4:  RLCF   x0D,F
01CB6:  RLCF   x0E,F
01CB8:  RLCF   x0F,F
01CBA:  RLCF   x10,F
01CBC:  RLCF   03,F
01CBE:  RLCF   02,F
01CC0:  RLCF   01,F
01CC2:  DECFSZ 00,F
01CC4:  BRA    1CAE
01CC6:  BCF    01.7
01CC8:  BTFSC  x11.0
01CCA:  BSF    01.7
01CCC:  MOVLB  0
01CCE:  RETURN 0
01CD0:  MOVFF  744,74B
01CD4:  MOVLB  7
01CD6:  MOVF   x48,W
01CD8:  XORWF  x4B,F
01CDA:  BTFSS  x4B.7
01CDC:  BRA    1CE8
01CDE:  BCF    FD8.2
01CE0:  BCF    FD8.0
01CE2:  BTFSC  x44.7
01CE4:  BSF    FD8.0
01CE6:  BRA    1D46
01CE8:  MOVFF  744,74B
01CEC:  MOVFF  747,74C
01CF0:  MOVF   x43,W
01CF2:  SUBWF  x4C,F
01CF4:  BZ    1D02
01CF6:  BTFSS  x4B.7
01CF8:  BRA    1D46
01CFA:  MOVF   FD8,W
01CFC:  XORLW  01
01CFE:  MOVWF  FD8
01D00:  BRA    1D46
01D02:  MOVFF  748,74C
01D06:  MOVF   x44,W
01D08:  SUBWF  x4C,F
01D0A:  BZ    1D18
01D0C:  BTFSS  x4B.7
01D0E:  BRA    1D46
01D10:  MOVF   FD8,W
01D12:  XORLW  01
01D14:  MOVWF  FD8
01D16:  BRA    1D46
01D18:  MOVFF  749,74C
01D1C:  MOVF   x45,W
01D1E:  SUBWF  x4C,F
01D20:  BZ    1D2E
01D22:  BTFSS  x4B.7
01D24:  BRA    1D46
01D26:  MOVF   FD8,W
01D28:  XORLW  01
01D2A:  MOVWF  FD8
01D2C:  BRA    1D46
01D2E:  MOVFF  74A,74C
01D32:  MOVF   x46,W
01D34:  SUBWF  x4C,F
01D36:  BZ    1D44
01D38:  BTFSS  x4B.7
01D3A:  BRA    1D46
01D3C:  MOVF   FD8,W
01D3E:  XORLW  01
01D40:  MOVWF  FD8
01D42:  BRA    1D46
01D44:  BCF    FD8.0
01D46:  MOVLB  0
01D48:  RETURN 0
01D4A:  MOVLB  7
01D4C:  MOVF   x3C,W
01D4E:  BTFSC  FD8.2
01D50:  BRA    1E9C
01D52:  MOVWF  x48
01D54:  MOVF   x40,W
01D56:  BTFSC  FD8.2
01D58:  BRA    1E9C
01D5A:  SUBWF  x48,F
01D5C:  BNC   1D68
01D5E:  MOVLW  7F
01D60:  ADDWF  x48,F
01D62:  BTFSC  FD8.0
01D64:  BRA    1E9C
01D66:  BRA    1D74
01D68:  MOVLW  81
01D6A:  SUBWF  x48,F
01D6C:  BTFSS  FD8.0
01D6E:  BRA    1E9C
01D70:  BTFSC  FD8.2
01D72:  BRA    1E9C
01D74:  MOVFF  748,00
01D78:  CLRF   01
01D7A:  CLRF   02
01D7C:  CLRF   03
01D7E:  CLRF   x47
01D80:  MOVFF  73D,746
01D84:  BSF    x46.7
01D86:  MOVFF  73E,745
01D8A:  MOVFF  73F,744
01D8E:  MOVLW  19
01D90:  MOVWF  x48
01D92:  MOVF   x43,W
01D94:  SUBWF  x44,F
01D96:  BC    1DB2
01D98:  MOVLW  01
01D9A:  SUBWF  x45,F
01D9C:  BC    1DB2
01D9E:  SUBWF  x46,F
01DA0:  BC    1DB2
01DA2:  SUBWF  x47,F
01DA4:  BC    1DB2
01DA6:  INCF   x47,F
01DA8:  INCF   x46,F
01DAA:  INCF   x45,F
01DAC:  MOVF   x43,W
01DAE:  ADDWF  x44,F
01DB0:  BRA    1E02
01DB2:  MOVF   x42,W
01DB4:  SUBWF  x45,F
01DB6:  BC    1DDC
01DB8:  MOVLW  01
01DBA:  SUBWF  x46,F
01DBC:  BC    1DDC
01DBE:  SUBWF  x47,F
01DC0:  BC    1DDC
01DC2:  INCF   x47,F
01DC4:  INCF   x46,F
01DC6:  MOVF   x42,W
01DC8:  ADDWF  x45,F
01DCA:  MOVF   x43,W
01DCC:  ADDWF  x44,F
01DCE:  BNC   1E02
01DD0:  INCF   x45,F
01DD2:  BNZ   1E02
01DD4:  INCF   x46,F
01DD6:  BNZ   1E02
01DD8:  INCF   x47,F
01DDA:  BRA    1E02
01DDC:  MOVF   x41,W
01DDE:  IORLW  80
01DE0:  SUBWF  x46,F
01DE2:  BC    1E00
01DE4:  MOVLW  01
01DE6:  SUBWF  x47,F
01DE8:  BC    1E00
01DEA:  INCF   x47,F
01DEC:  MOVF   x41,W
01DEE:  IORLW  80
01DF0:  ADDWF  x46,F
01DF2:  MOVF   x42,W
01DF4:  ADDWF  x45,F
01DF6:  BNC   1DCA
01DF8:  INCF   x46,F
01DFA:  BNZ   1DCA
01DFC:  INCF   x47,F
01DFE:  BRA    1DCA
01E00:  BSF    03.0
01E02:  DECFSZ x48,F
01E04:  BRA    1E08
01E06:  BRA    1E1E
01E08:  BCF    FD8.0
01E0A:  RLCF   x44,F
01E0C:  RLCF   x45,F
01E0E:  RLCF   x46,F
01E10:  RLCF   x47,F
01E12:  BCF    FD8.0
01E14:  RLCF   03,F
01E16:  RLCF   02,F
01E18:  RLCF   01,F
01E1A:  RLCF   x49,F
01E1C:  BRA    1D92
01E1E:  BTFSS  x49.0
01E20:  BRA    1E2E
01E22:  BCF    FD8.0
01E24:  RRCF   01,F
01E26:  RRCF   02,F
01E28:  RRCF   03,F
01E2A:  RRCF   x49,F
01E2C:  BRA    1E32
01E2E:  DECF   00,F
01E30:  BZ    1E9C
01E32:  BTFSC  x49.7
01E34:  BRA    1E72
01E36:  BCF    FD8.0
01E38:  RLCF   x44,F
01E3A:  RLCF   x45,F
01E3C:  RLCF   x46,F
01E3E:  RLCF   x47,F
01E40:  MOVF   x43,W
01E42:  SUBWF  x44,F
01E44:  BC    1E54
01E46:  MOVLW  01
01E48:  SUBWF  x45,F
01E4A:  BC    1E54
01E4C:  SUBWF  x46,F
01E4E:  BC    1E54
01E50:  SUBWF  x47,F
01E52:  BNC   1E88
01E54:  MOVF   x42,W
01E56:  SUBWF  x45,F
01E58:  BC    1E64
01E5A:  MOVLW  01
01E5C:  SUBWF  x46,F
01E5E:  BC    1E64
01E60:  SUBWF  x47,F
01E62:  BNC   1E88
01E64:  MOVF   x41,W
01E66:  IORLW  80
01E68:  SUBWF  x46,F
01E6A:  BC    1E72
01E6C:  MOVLW  01
01E6E:  SUBWF  x47,F
01E70:  BNC   1E88
01E72:  INCF   03,F
01E74:  BNZ   1E88
01E76:  INCF   02,F
01E78:  BNZ   1E88
01E7A:  INCF   01,F
01E7C:  BNZ   1E88
01E7E:  INCF   00,F
01E80:  BZ    1E9C
01E82:  RRCF   01,F
01E84:  RRCF   02,F
01E86:  RRCF   03,F
01E88:  MOVFF  73D,748
01E8C:  MOVF   x41,W
01E8E:  XORWF  x48,F
01E90:  BTFSS  x48.7
01E92:  BRA    1E98
01E94:  BSF    01.7
01E96:  BRA    1EA4
01E98:  BCF    01.7
01E9A:  BRA    1EA4
01E9C:  CLRF   00
01E9E:  CLRF   01
01EA0:  CLRF   02
01EA2:  CLRF   03
01EA4:  MOVLB  0
01EA6:  RETURN 0
*
02652:  ADDWF  FE8,W
02654:  CLRF   FF7
02656:  RLCF   FF7,F
02658:  ADDLW  6D
0265A:  MOVWF  FF6
0265C:  MOVLW  26
0265E:  ADDWFC FF7,F
02660:  TBLRD*-
02662:  MOVF   FF5,W
02664:  MOVWF  FFA
02666:  TBLRD*
02668:  MOVF   FF5,W
0266A:  MOVWF  FF9
0266C:  DATA 5A,25
0266E:  DATA 74,25
02670:  DATA C8,25
02672:  DATA 2C,26
02674:  MOVLW  8E
02676:  MOVWF  00
02678:  MOVFF  73A,01
0267C:  MOVFF  739,02
02680:  CLRF   03
02682:  BTFSS  01.7
02684:  BRA    2690
02686:  COMF   01,F
02688:  COMF   02,F
0268A:  INCF   02,F
0268C:  BNZ   2690
0268E:  INCF   01,F
02690:  MOVF   01,F
02692:  BNZ   26A6
02694:  MOVFF  02,01
02698:  CLRF   02
0269A:  MOVLW  08
0269C:  SUBWF  00,F
0269E:  MOVF   01,F
026A0:  BNZ   26A6
026A2:  CLRF   00
026A4:  BRA    26C2
026A6:  BCF    FD8.0
026A8:  BTFSC  01.7
026AA:  BRA    26B4
026AC:  RLCF   02,F
026AE:  RLCF   01,F
026B0:  DECF   00,F
026B2:  BRA    26A6
026B4:  MOVLB  7
026B6:  BTFSS  x3A.7
026B8:  BRA    26BE
026BA:  MOVLB  0
026BC:  BRA    26C2
026BE:  BCF    01.7
026C0:  MOVLB  0
026C2:  RETURN 0
026C4:  MOVLW  8E
026C6:  MOVWF  00
026C8:  MOVLB  7
026CA:  MOVF   x43,W
026CC:  SUBWF  00,F
026CE:  MOVFF  744,02
026D2:  MOVFF  745,01
026D6:  BSF    02.7
026D8:  MOVF   00,F
026DA:  BZ    26EE
026DC:  BCF    FD8.0
026DE:  MOVF   02,F
026E0:  BNZ   26E6
026E2:  MOVF   01,F
026E4:  BZ    26EE
026E6:  RRCF   02,F
026E8:  RRCF   01,F
026EA:  DECFSZ 00,F
026EC:  BRA    26DC
026EE:  BTFSS  x44.7
026F0:  BRA    26FC
026F2:  COMF   01,F
026F4:  COMF   02,F
026F6:  INCF   01,F
026F8:  BTFSC  FD8.2
026FA:  INCF   02,F
026FC:  MOVLB  0
026FE:  RETURN 0
*
04622:  MOVLB  6
04624:  MOVF   xFB,W
04626:  ANDLW  07
04628:  MOVWF  00
0462A:  RRCF   xFB,W
0462C:  MOVWF  01
0462E:  RRCF   01,F
04630:  RRCF   01,F
04632:  MOVLW  1F
04634:  ANDWF  01,F
04636:  MOVF   01,W
04638:  ADDWF  xFC,W
0463A:  MOVWF  FE9
0463C:  MOVLW  00
0463E:  ADDWFC xFD,W
04640:  MOVWF  FEA
04642:  MOVFF  FEF,01
04646:  INCF   00,F
04648:  BRA    464C
0464A:  RRCF   01,F
0464C:  DECFSZ 00,F
0464E:  BRA    464A
04650:  MOVLW  01
04652:  ANDWF  01,F
04654:  MOVLB  0
04656:  RETURN 0
*
0509C:  MOVF   FEF,F
0509E:  BZ    50C4
050A0:  MOVFF  FEA,6F2
050A4:  MOVFF  FE9,6F1
050A8:  MOVF   FEF,W
050AA:  MOVLB  E
050AC:  BTFSS  xC8.4
050AE:  BRA    50AC
050B0:  MOVWF  F99
050B2:  MOVFF  6F2,FEA
050B6:  MOVFF  6F1,FE9
050BA:  INCF   FE9,F
050BC:  BTFSC  FD8.2
050BE:  INCF   FEA,F
050C0:  MOVLB  0
050C2:  BRA    509C
050C4:  RETURN 0
*
05670:  MOVFF  563,FEA
05674:  MOVFF  562,FE9
05678:  MOVFF  73E,FEF
0567C:  INCF   FE9,F
0567E:  BTFSC  FD8.2
05680:  INCF   FEA,F
05682:  CLRF   FEF
05684:  MOVLB  5
05686:  INCF   x62,F
05688:  BTFSC  FD8.2
0568A:  INCF   x63,F
0568C:  MOVLB  0
0568E:  RETURN 0
05690:  MOVF   FEF,F
05692:  BZ    56B2
05694:  MOVFF  FEA,6F6
05698:  MOVFF  FE9,6F5
0569C:  MOVFF  FEF,73E
056A0:  RCALL  5670
056A2:  MOVFF  6F6,FEA
056A6:  MOVFF  6F5,FE9
056AA:  INCF   FE9,F
056AC:  BTFSC  FD8.2
056AE:  INCF   FEA,F
056B0:  BRA    5690
056B2:  RETURN 0
*
05766:  TBLRD*+
05768:  MOVF   FF5,F
0576A:  BZ    5784
0576C:  MOVFF  FF6,6FC
05770:  MOVFF  FF7,6FD
05774:  MOVFF  FF5,73E
05778:  RCALL  5670
0577A:  MOVFF  6FC,FF6
0577E:  MOVFF  6FD,FF7
05782:  BRA    5766
05784:  RETURN 0
*
058A8:  MOVLB  7
058AA:  MOVF   x5D,W
058AC:  XORWF  x5F,W
058AE:  ANDLW  80
058B0:  MOVWF  x61
058B2:  BTFSS  x5D.7
058B4:  BRA    58C0
058B6:  COMF   x5C,F
058B8:  COMF   x5D,F
058BA:  INCF   x5C,F
058BC:  BTFSC  FD8.2
058BE:  INCF   x5D,F
058C0:  BTFSS  x5F.7
058C2:  BRA    58CE
058C4:  COMF   x5E,F
058C6:  COMF   x5F,F
058C8:  INCF   x5E,F
058CA:  BTFSC  FD8.2
058CC:  INCF   x5F,F
058CE:  MOVF   x5C,W
058D0:  MULWF  x5E
058D2:  MOVFF  FF3,01
058D6:  MOVFF  FF4,00
058DA:  MULWF  x5F
058DC:  MOVF   FF3,W
058DE:  ADDWF  00,F
058E0:  MOVF   x5D,W
058E2:  MULWF  x5E
058E4:  MOVF   FF3,W
058E6:  ADDWFC 00,W
058E8:  MOVWF  02
058EA:  BTFSS  x61.7
058EC:  BRA    58F8
058EE:  COMF   01,F
058F0:  COMF   02,F
058F2:  INCF   01,F
058F4:  BTFSC  FD8.2
058F6:  INCF   02,F
058F8:  MOVLB  0
058FA:  GOTO   5B8E (RETURN)
*
05C52:  MOVLW  20
05C54:  MOVLB  7
05C56:  BTFSS  x2A.4
05C58:  MOVLW  30
05C5A:  MOVWF  x2B
05C5C:  MOVFF  729,00
05C60:  BTFSS  00.7
05C62:  BRA    5C74
05C64:  COMF   00,F
05C66:  INCF   00,F
05C68:  MOVFF  00,729
05C6C:  MOVLW  2D
05C6E:  MOVWF  x2B
05C70:  BSF    x2A.7
05C72:  BSF    x2A.0
05C74:  MOVF   01,W
05C76:  MOVFF  729,72F
05C7A:  MOVLW  64
05C7C:  MOVWF  x30
05C7E:  MOVLB  0
05C80:  CALL   084A
05C84:  MOVFF  00,729
05C88:  MOVLW  30
05C8A:  ADDWF  01,W
05C8C:  MOVLB  7
05C8E:  MOVWF  x2C
05C90:  MOVFF  729,72F
05C94:  MOVLW  0A
05C96:  MOVWF  x30
05C98:  MOVLB  0
05C9A:  CALL   084A
05C9E:  MOVLW  30
05CA0:  ADDWF  00,W
05CA2:  MOVLB  7
05CA4:  MOVWF  x2E
05CA6:  MOVLW  30
05CA8:  ADDWF  01,W
05CAA:  MOVWF  x2D
05CAC:  MOVFF  72B,00
05CB0:  MOVLW  30
05CB2:  SUBWF  x2C,W
05CB4:  BZ    5CBE
05CB6:  BSF    x2A.1
05CB8:  BTFSC  x2A.7
05CBA:  BSF    x2A.2
05CBC:  BRA    5CE2
05CBE:  MOVFF  72B,72C
05CC2:  MOVLW  20
05CC4:  MOVWF  x2B
05CC6:  MOVLW  30
05CC8:  SUBWF  x2D,W
05CCA:  BZ    5CD4
05CCC:  BSF    x2A.0
05CCE:  BTFSC  x2A.7
05CD0:  BSF    x2A.1
05CD2:  BRA    5CE2
05CD4:  BTFSS  FD8.2
05CD6:  BSF    x2A.0
05CD8:  BNZ   5CE2
05CDA:  MOVFF  72C,72D
05CDE:  MOVLW  20
05CE0:  MOVWF  x2C
05CE2:  BTFSC  x2A.2
05CE4:  BRA    5CF0
05CE6:  BTFSC  x2A.1
05CE8:  BRA    5CF8
05CEA:  BTFSC  x2A.0
05CEC:  BRA    5D00
05CEE:  BRA    5D08
05CF0:  MOVFF  72B,73E
05CF4:  MOVLB  0
05CF6:  RCALL  5670
05CF8:  MOVFF  72C,73E
05CFC:  MOVLB  0
05CFE:  RCALL  5670
05D00:  MOVFF  72D,73E
05D04:  MOVLB  0
05D06:  RCALL  5670
05D08:  MOVFF  72E,73E
05D0C:  MOVLB  0
05D0E:  RCALL  5670
05D10:  RETURN 0
*
05EBC:  MOVLB  7
05EBE:  MOVF   x10,W
05EC0:  ANDLW  07
05EC2:  MOVWF  00
05EC4:  RRCF   x10,W
05EC6:  MOVWF  01
05EC8:  RRCF   01,F
05ECA:  RRCF   01,F
05ECC:  MOVLW  1F
05ECE:  ANDWF  01,F
05ED0:  MOVF   01,W
05ED2:  ADDWF  x12,W
05ED4:  MOVWF  FE9
05ED6:  MOVLW  00
05ED8:  ADDWFC x13,W
05EDA:  MOVWF  FEA
05EDC:  CLRF   01
05EDE:  INCF   01,F
05EE0:  INCF   00,F
05EE2:  BRA    5EE6
05EE4:  RLCF   01,F
05EE6:  DECFSZ 00,F
05EE8:  BRA    5EE4
05EEA:  MOVF   x11,F
05EEC:  BZ    5EF4
05EEE:  MOVF   01,W
05EF0:  IORWF  FEF,F
05EF2:  BRA    5EFA
05EF4:  COMF   01,F
05EF6:  MOVF   01,W
05EF8:  ANDWF  FEF,F
05EFA:  MOVLB  0
05EFC:  RETURN 0
*
060B6:  TBLRD*+
060B8:  MOVFF  FF6,6FE
060BC:  MOVFF  FF7,6FF
060C0:  MOVFF  FF5,73E
060C4:  CALL   5670
060C8:  MOVFF  6FE,FF6
060CC:  MOVFF  6FF,FF7
060D0:  MOVLB  6
060D2:  DECFSZ xFD,F
060D4:  BRA    60D8
060D6:  BRA    60DC
060D8:  MOVLB  0
060DA:  BRA    60B6
060DC:  MOVLB  0
060DE:  RETURN 0
*
06494:  MOVLB  7
06496:  MOVF   x3E,W
06498:  SUBLW  B6
0649A:  MOVWF  x3E
0649C:  CLRF   03
0649E:  MOVFF  73F,742
064A2:  BSF    x3F.7
064A4:  BCF    FD8.0
064A6:  RRCF   x3F,F
064A8:  RRCF   x40,F
064AA:  RRCF   x41,F
064AC:  RRCF   03,F
064AE:  RRCF   02,F
064B0:  RRCF   01,F
064B2:  RRCF   00,F
064B4:  DECFSZ x3E,F
064B6:  BRA    64A4
064B8:  BTFSS  x42.7
064BA:  BRA    64D2
064BC:  COMF   00,F
064BE:  COMF   01,F
064C0:  COMF   02,F
064C2:  COMF   03,F
064C4:  INCF   00,F
064C6:  BTFSC  FD8.2
064C8:  INCF   01,F
064CA:  BTFSC  FD8.2
064CC:  INCF   02,F
064CE:  BTFSC  FD8.2
064D0:  INCF   03,F
064D2:  MOVLB  0
064D4:  RETURN 0
064D6:  BTFSC  FD8.1
064D8:  BRA    64E2
064DA:  MOVLW  07
064DC:  MOVWF  FEA
064DE:  MOVLW  46
064E0:  MOVWF  FE9
064E2:  CLRF   00
064E4:  CLRF   01
064E6:  CLRF   02
064E8:  CLRF   03
064EA:  MOVLB  7
064EC:  CLRF   x46
064EE:  CLRF   x47
064F0:  CLRF   x48
064F2:  CLRF   x49
064F4:  MOVF   x45,W
064F6:  IORWF  x44,W
064F8:  IORWF  x43,W
064FA:  IORWF  x42,W
064FC:  BZ    6556
064FE:  MOVLW  20
06500:  MOVWF  x4A
06502:  BCF    FD8.0
06504:  RLCF   x3E,F
06506:  RLCF   x3F,F
06508:  RLCF   x40,F
0650A:  RLCF   x41,F
0650C:  RLCF   x46,F
0650E:  RLCF   x47,F
06510:  RLCF   x48,F
06512:  RLCF   x49,F
06514:  MOVF   x45,W
06516:  SUBWF  x49,W
06518:  BNZ   652A
0651A:  MOVF   x44,W
0651C:  SUBWF  x48,W
0651E:  BNZ   652A
06520:  MOVF   x43,W
06522:  SUBWF  x47,W
06524:  BNZ   652A
06526:  MOVF   x42,W
06528:  SUBWF  x46,W
0652A:  BNC   654A
0652C:  MOVF   x42,W
0652E:  SUBWF  x46,F
06530:  MOVF   x43,W
06532:  BTFSS  FD8.0
06534:  INCFSZ x43,W
06536:  SUBWF  x47,F
06538:  MOVF   x44,W
0653A:  BTFSS  FD8.0
0653C:  INCFSZ x44,W
0653E:  SUBWF  x48,F
06540:  MOVF   x45,W
06542:  BTFSS  FD8.0
06544:  INCFSZ x45,W
06546:  SUBWF  x49,F
06548:  BSF    FD8.0
0654A:  RLCF   00,F
0654C:  RLCF   01,F
0654E:  RLCF   02,F
06550:  RLCF   03,F
06552:  DECFSZ x4A,F
06554:  BRA    6502
06556:  MOVFF  746,FEF
0655A:  MOVFF  747,FEC
0655E:  MOVFF  748,FEC
06562:  MOVFF  749,FEC
06566:  MOVLB  0
06568:  RETURN 0
0656A:  MOVF   FE9,W
0656C:  MOVLB  7
0656E:  MOVWF  x36
06570:  MOVF   x35,W
06572:  MOVWF  x38
06574:  BZ    65AE
06576:  MOVFF  734,746
0657A:  MOVFF  733,745
0657E:  MOVFF  732,744
06582:  MOVFF  731,743
06586:  CLRF   x4A
06588:  CLRF   x49
0658A:  MOVLW  20
0658C:  MOVWF  x48
0658E:  MOVLW  82
06590:  MOVWF  x47
06592:  MOVLB  0
06594:  CALL   0D20
06598:  MOVFF  03,734
0659C:  MOVFF  02,733
065A0:  MOVFF  01,732
065A4:  MOVFF  00,731
065A8:  MOVLB  7
065AA:  DECFSZ x38,F
065AC:  BRA    6576
065AE:  MOVFF  734,741
065B2:  MOVFF  733,740
065B6:  MOVFF  732,73F
065BA:  MOVFF  731,73E
065BE:  MOVLB  0
065C0:  RCALL  6494
065C2:  MOVFF  03,734
065C6:  MOVFF  02,733
065CA:  MOVFF  01,732
065CE:  MOVFF  00,731
065D2:  MOVLB  7
065D4:  BTFSS  x34.7
065D6:  BRA    65F2
065D8:  DECF   x36,F
065DA:  BSF    x36.5
065DC:  COMF   x31,F
065DE:  COMF   x32,F
065E0:  COMF   x33,F
065E2:  COMF   x34,F
065E4:  INCF   x31,F
065E6:  BTFSC  FD8.2
065E8:  INCF   x32,F
065EA:  BTFSC  FD8.2
065EC:  INCF   x33,F
065EE:  BTFSC  FD8.2
065F0:  INCF   x34,F
065F2:  MOVLW  3B
065F4:  MOVWF  x3D
065F6:  MOVLW  9A
065F8:  MOVWF  x3C
065FA:  MOVLW  CA
065FC:  MOVWF  x3B
065FE:  CLRF   x3A
06600:  MOVLW  0A
06602:  MOVWF  x38
06604:  MOVF   x35,W
06606:  BTFSC  FD8.2
06608:  INCF   x36,F
0660A:  BSF    FD8.1
0660C:  MOVLW  07
0660E:  MOVWF  FEA
06610:  MOVLW  31
06612:  MOVWF  FE9
06614:  MOVFF  734,741
06618:  MOVFF  733,740
0661C:  MOVFF  732,73F
06620:  MOVFF  731,73E
06624:  MOVFF  73D,745
06628:  MOVFF  73C,744
0662C:  MOVFF  73B,743
06630:  MOVFF  73A,742
06634:  MOVLB  0
06636:  RCALL  64D6
06638:  MOVF   01,W
0663A:  MOVF   00,F
0663C:  BNZ   6664
0663E:  MOVLB  7
06640:  INCF   x35,W
06642:  SUBWF  x38,W
06644:  BTFSS  FD8.2
06646:  BRA    664C
06648:  MOVLB  0
0664A:  BRA    6664
0664C:  MOVF   x36,W
0664E:  BZ    666A
06650:  ANDLW  0F
06652:  SUBWF  x38,W
06654:  BZ    6658
06656:  BC    66E0
06658:  BTFSC  x36.7
0665A:  BRA    66E0
0665C:  BTFSC  x36.6
0665E:  BRA    666A
06660:  MOVLW  20
06662:  BRA    66D2
06664:  MOVLW  20
06666:  MOVLB  7
06668:  ANDWF  x36,F
0666A:  BTFSS  x36.5
0666C:  BRA    668C
0666E:  BCF    x36.5
06670:  MOVF   x35,W
06672:  BTFSS  FD8.2
06674:  DECF   x36,F
06676:  MOVF   00,W
06678:  MOVWF  x36
0667A:  MOVLW  2D
0667C:  MOVWF  x3E
0667E:  MOVLB  0
06680:  CALL   5670
06684:  MOVLB  7
06686:  MOVF   x36,W
06688:  MOVWF  00
0668A:  CLRF   x36
0668C:  MOVF   x35,W
0668E:  SUBWF  x38,W
06690:  BNZ   66AC
06692:  MOVF   00,W
06694:  MOVWF  x36
06696:  MOVLW  2E
06698:  MOVWF  x3E
0669A:  MOVLB  0
0669C:  CALL   5670
066A0:  MOVLB  7
066A2:  MOVF   x36,W
066A4:  MOVWF  00
066A6:  MOVLW  20
066A8:  ANDWF  x36,F
066AA:  MOVLW  00
066AC:  MOVLW  30
066AE:  BTFSS  x36.5
066B0:  BRA    66D2
066B2:  BCF    x36.5
066B4:  MOVF   x35,W
066B6:  BTFSS  FD8.2
066B8:  DECF   x36,F
066BA:  MOVF   00,W
066BC:  MOVWF  x36
066BE:  MOVLW  2D
066C0:  MOVWF  x3E
066C2:  MOVLB  0
066C4:  CALL   5670
066C8:  MOVLB  7
066CA:  MOVF   x36,W
066CC:  MOVWF  00
066CE:  CLRF   x36
066D0:  MOVLW  30
066D2:  ADDWF  00,F
066D4:  MOVFF  00,73E
066D8:  MOVLB  0
066DA:  CALL   5670
066DE:  MOVLB  7
066E0:  BCF    FD8.1
066E2:  MOVFF  73D,741
066E6:  MOVFF  73C,740
066EA:  MOVFF  73B,73F
066EE:  MOVFF  73A,73E
066F2:  CLRF   x45
066F4:  CLRF   x44
066F6:  CLRF   x43
066F8:  MOVLW  0A
066FA:  MOVWF  x42
066FC:  MOVLB  0
066FE:  RCALL  64D6
06700:  MOVFF  03,73D
06704:  MOVFF  02,73C
06708:  MOVFF  01,73B
0670C:  MOVFF  00,73A
06710:  MOVLB  7
06712:  DECFSZ x38,F
06714:  BRA    660A
06716:  MOVLB  0
06718:  RETURN 0
*
092AE:  MOVF   FE9,W
092B0:  MOVLB  7
092B2:  MOVWF  x32
092B4:  BTFSS  x31.7
092B6:  BRA    92D2
092B8:  DECF   x32,F
092BA:  BSF    x32.5
092BC:  COMF   x2E,F
092BE:  COMF   x2F,F
092C0:  COMF   x30,F
092C2:  COMF   x31,F
092C4:  INCF   x2E,F
092C6:  BTFSC  FD8.2
092C8:  INCF   x2F,F
092CA:  BTFSC  FD8.2
092CC:  INCF   x30,F
092CE:  BTFSC  FD8.2
092D0:  INCF   x31,F
092D2:  MOVLW  3B
092D4:  MOVWF  x39
092D6:  MOVLW  9A
092D8:  MOVWF  x38
092DA:  MOVLW  CA
092DC:  MOVWF  x37
092DE:  CLRF   x36
092E0:  MOVLW  0A
092E2:  MOVWF  x34
092E4:  BSF    FD8.1
092E6:  MOVLW  07
092E8:  MOVWF  FEA
092EA:  MOVLW  2E
092EC:  MOVWF  FE9
092EE:  MOVFF  731,741
092F2:  MOVFF  730,740
092F6:  MOVFF  72F,73F
092FA:  MOVFF  72E,73E
092FE:  MOVFF  739,745
09302:  MOVFF  738,744
09306:  MOVFF  737,743
0930A:  MOVFF  736,742
0930E:  MOVLB  0
09310:  CALL   64D6
09314:  MOVF   01,W
09316:  MOVF   00,F
09318:  BNZ   9340
0931A:  MOVLB  7
0931C:  MOVF   x34,W
0931E:  XORLW  01
09320:  BTFSS  FD8.2
09322:  BRA    9328
09324:  MOVLB  0
09326:  BRA    9340
09328:  MOVF   x32,W
0932A:  BZ    9346
0932C:  ANDLW  0F
0932E:  SUBWF  x34,W
09330:  BZ    9334
09332:  BC    9390
09334:  BTFSC  x32.7
09336:  BRA    9390
09338:  BTFSC  x32.6
0933A:  BRA    9346
0933C:  MOVLW  20
0933E:  BRA    9382
09340:  MOVLW  20
09342:  MOVLB  7
09344:  ANDWF  x32,F
09346:  BTFSS  x32.5
09348:  BRA    9362
0934A:  BCF    x32.5
0934C:  MOVFF  00,732
09350:  MOVLW  2D
09352:  MOVWF  x3E
09354:  MOVLB  0
09356:  CALL   5670
0935A:  MOVLB  7
0935C:  MOVFF  732,00
09360:  CLRF   x32
09362:  MOVLW  30
09364:  BTFSS  x32.5
09366:  BRA    9382
09368:  BCF    x32.5
0936A:  MOVFF  00,732
0936E:  MOVLW  2D
09370:  MOVWF  x3E
09372:  MOVLB  0
09374:  CALL   5670
09378:  MOVLB  7
0937A:  MOVFF  732,00
0937E:  CLRF   x32
09380:  MOVLW  30
09382:  ADDWF  00,F
09384:  MOVFF  00,73E
09388:  MOVLB  0
0938A:  CALL   5670
0938E:  MOVLB  7
09390:  BCF    FD8.1
09392:  MOVFF  739,741
09396:  MOVFF  738,740
0939A:  MOVFF  737,73F
0939E:  MOVFF  736,73E
093A2:  CLRF   x45
093A4:  CLRF   x44
093A6:  CLRF   x43
093A8:  MOVLW  0A
093AA:  MOVWF  x42
093AC:  MOVLB  0
093AE:  CALL   64D6
093B2:  MOVFF  03,739
093B6:  MOVFF  02,738
093BA:  MOVFF  01,737
093BE:  MOVFF  00,736
093C2:  MOVLB  7
093C4:  DECFSZ x34,F
093C6:  BRA    92E4
093C8:  MOVLB  0
093CA:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003EE:  MOVLW  06
003F0:  MOVWF  FEA
003F2:  MOVLW  F4
003F4:  MOVWF  FE9
003F6:  MOVF   FEF,W
003F8:  BZ    0416
003FA:  MOVLW  14
003FC:  MOVWF  01
003FE:  CLRF   00
00400:  DECFSZ 00,F
00402:  BRA    0400
00404:  DECFSZ 01,F
00406:  BRA    03FE
00408:  MOVLW  BF
0040A:  MOVWF  00
0040C:  DECFSZ 00,F
0040E:  BRA    040C
00410:  BRA    0412
00412:  DECFSZ FEF,F
00414:  BRA    03FA
00416:  RETURN 0
*
006B6:  MOVLW  01
006B8:  MOVLB  6
006BA:  SUBWF  xFA,F
006BC:  BNC   06D6
006BE:  MOVLW  06
006C0:  MOVWF  FEA
006C2:  MOVLW  FA
006C4:  MOVWF  FE9
006C6:  MOVF   FEF,W
006C8:  BZ    06D6
006CA:  MOVLW  04
006CC:  MOVWF  00
006CE:  DECFSZ 00,F
006D0:  BRA    06CE
006D2:  DECFSZ FEF,F
006D4:  BRA    06CA
006D6:  MOVLB  0
006D8:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00358:  MOVLW  CF
0035A:  MOVWF  F87
0035C:  CLRF   F82
....................    output_b(portB_reset);
0035E:  MOVLW  C4
00360:  MOVWF  F88
00362:  CLRF   F83
....................    output_c(portC_reset);
00364:  MOVLW  93
00366:  MOVWF  F89
00368:  CLRF   F84
....................    output_d(portD_reset);
0036A:  MOVLW  1F
0036C:  MOVWF  F8A
0036E:  CLRF   F85
....................    output_e(portE_reset);
00370:  BCF    F8B.0
00372:  BCF    F8B.1
00374:  BCF    F8B.2
00376:  BCF    F8B.3
00378:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
0037A:  MOVLB  F
0037C:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0037E:  CLRF   x13
....................    port_c_pullups(portC_pullups);
00380:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00382:  SETF   x20
....................    port_e_pullups(portE_pullups);
00384:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00386:  MOVLW  40
00388:  MOVWF  x0C
0038A:  CLRF   x14
0038C:  MOVLW  03
0038E:  MOVWF  x1C
00390:  MOVLW  0F
00392:  MOVWF  x21
00394:  CLRF   x29
00396:  MOVLB  0
00398:  GOTO   A5A4 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
056EE:  MOVFF  730,FEA
056F2:  MOVLB  7
056F4:  MOVFF  72F,FE9
056F8:  MOVFF  FEF,733
056FC:  MOVFF  732,FEA
05700:  MOVFF  731,FE9
05704:  MOVF   FEF,W
05706:  SUBWF  x33,W
05708:  BNZ   5738
....................       if (*s1 == '\0')
0570A:  MOVFF  730,03
0570E:  MOVFF  72F,FE9
05712:  MOVFF  03,FEA
05716:  MOVF   FEF,F
05718:  BNZ   5720
....................          return(0);
0571A:  MOVLW  00
0571C:  MOVWF  01
0571E:  BRA    5762
05720:  MOVFF  730,03
05724:  MOVF   x2F,W
05726:  INCF   x2F,F
05728:  BTFSC  FD8.2
0572A:  INCF   x30,F
0572C:  INCF   x31,F
0572E:  BTFSC  FD8.2
05730:  INCF   x32,F
05732:  MOVLB  0
05734:  BRA    56EE
05736:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05738:  MOVFF  730,03
0573C:  MOVFF  72F,FE9
05740:  MOVFF  03,FEA
05744:  MOVFF  FEF,733
05748:  MOVFF  732,03
0574C:  MOVFF  731,FE9
05750:  MOVFF  03,FEA
05754:  MOVF   FEF,W
05756:  SUBWF  x33,W
05758:  BC    575E
0575A:  MOVLW  FF
0575C:  BRA    5760
0575E:  MOVLW  01
05760:  MOVWF  01
05762:  MOVLB  0
05764:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
0585E:  MOVFF  75D,760
....................    for(su=s;0<n;++su,--n)
05862:  MOVFF  75C,762
05866:  MOVFF  75B,761
0586A:  MOVLB  7
0586C:  MOVF   x5F,F
0586E:  BNZ   5876
05870:  MOVF   x5E,W
05872:  SUBLW  00
05874:  BC    589E
....................       if(*su==uc)
05876:  MOVFF  762,FEA
0587A:  MOVFF  761,FE9
0587E:  MOVF   x60,W
05880:  SUBWF  FEF,W
05882:  BNZ   588E
....................       return su;
05884:  MOVFF  761,01
05888:  MOVFF  762,02
0588C:  BRA    58A4
0588E:  INCF   x61,F
05890:  BTFSC  FD8.2
05892:  INCF   x62,F
05894:  MOVF   x5E,W
05896:  BTFSC  FD8.2
05898:  DECF   x5F,F
0589A:  DECF   x5E,F
0589C:  BRA    586C
....................    return NULL;
0589E:  MOVLW  00
058A0:  MOVWF  01
058A2:  MOVWF  02
058A4:  MOVLB  0
058A6:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05638:  MOVFF  730,732
0563C:  MOVFF  72F,731
05640:  MOVFF  732,FEA
05644:  MOVLB  7
05646:  MOVFF  731,FE9
0564A:  MOVF   FEF,F
0564C:  BZ    565A
0564E:  INCF   x31,F
05650:  BTFSC  FD8.2
05652:  INCF   x32,F
05654:  MOVLB  0
05656:  BRA    5640
05658:  MOVLB  7
....................    return(sc - s);
0565A:  MOVF   x2F,W
0565C:  SUBWF  x31,W
0565E:  MOVWF  00
05660:  MOVF   x30,W
05662:  SUBWFB x32,W
05664:  MOVWF  03
05666:  MOVFF  00,01
0566A:  MOVWF  02
0566C:  MOVLB  0
0566E:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06CB2:  MOVLB  7
06CB4:  CLRF   x09
06CB6:  CLRF   x08
06CB8:  CLRF   x07
06CBA:  MOVLW  7F
06CBC:  MOVWF  x06
06CBE:  CLRF   x0D
06CC0:  CLRF   x0C
06CC2:  CLRF   x0B
06CC4:  CLRF   x0A
06CC6:  BSF    x0E.0
06CC8:  BCF    x0E.1
06CCA:  BCF    x0E.2
06CCC:  CLRF   x10
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06CCE:  MOVF   x02,W
06CD0:  IORWF  x03,W
06CD2:  BNZ   6CDE
....................       return 0;
06CD4:  CLRF   00
06CD6:  CLRF   01
06CD8:  CLRF   02
06CDA:  CLRF   03
06CDC:  BRA    6F08
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06CDE:  MOVF   x10,W
06CE0:  INCF   x10,F
06CE2:  ADDWF  x02,W
06CE4:  MOVWF  FE9
06CE6:  MOVLW  00
06CE8:  ADDWFC x03,W
06CEA:  MOVWF  FEA
06CEC:  MOVFF  FEF,70F
06CF0:  MOVF   x0F,F
06CF2:  BTFSC  FD8.2
06CF4:  BRA    6E8C
....................    {
....................       if (skip && !isspace(c))
06CF6:  BTFSS  x0E.0
06CF8:  BRA    6D18
06CFA:  MOVF   x0F,W
06CFC:  SUBLW  20
06CFE:  BZ    6D18
....................       {
....................          skip = 0;
06D00:  BCF    x0E.0
....................          if (c == '+')
06D02:  MOVF   x0F,W
06D04:  SUBLW  2B
06D06:  BNZ   6D0E
....................          {
....................             sign = 0;
06D08:  BCF    x0E.1
....................             continue;
06D0A:  BRA    6E74
....................          }            
06D0C:  BRA    6D18
....................          else if (c == '-')
06D0E:  MOVF   x0F,W
06D10:  SUBLW  2D
06D12:  BNZ   6D18
....................          {
....................             sign = 1;
06D14:  BSF    x0E.1
....................             continue;
06D16:  BRA    6E74
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06D18:  BTFSC  x0E.0
06D1A:  BRA    6D2A
06D1C:  MOVF   x0F,W
06D1E:  SUBLW  2E
06D20:  BNZ   6D2A
06D22:  BTFSC  x0E.2
06D24:  BRA    6D2A
....................          point = 1;
06D26:  BSF    x0E.2
06D28:  BRA    6E74
....................       else if (!skip && isdigit(c))
06D2A:  BTFSC  x0E.0
06D2C:  BRA    6E6E
06D2E:  MOVF   x0F,W
06D30:  SUBLW  2F
06D32:  BTFSC  FD8.0
06D34:  BRA    6E6E
06D36:  MOVF   x0F,W
06D38:  SUBLW  39
06D3A:  BTFSS  FD8.0
06D3C:  BRA    6E6E
....................       {
....................          c -= '0';
06D3E:  MOVLW  30
06D40:  SUBWF  x0F,F
....................          if (point)
06D42:  BTFSS  x0E.2
06D44:  BRA    6DF4
....................          {
....................             pow10 = pow10 * 10.0;
06D46:  MOVFF  709,746
06D4A:  MOVFF  708,745
06D4E:  MOVFF  707,744
06D52:  MOVFF  706,743
06D56:  CLRF   x4A
06D58:  CLRF   x49
06D5A:  MOVLW  20
06D5C:  MOVWF  x48
06D5E:  MOVLW  82
06D60:  MOVWF  x47
06D62:  MOVLB  0
06D64:  CALL   0D20
06D68:  MOVFF  03,709
06D6C:  MOVFF  02,708
06D70:  MOVFF  01,707
06D74:  MOVFF  00,706
....................             result += (float)c / pow10;   
06D78:  MOVLB  7
06D7A:  CLRF   x48
06D7C:  MOVFF  70F,747
06D80:  MOVLB  0
06D82:  CALL   0CEA
06D86:  MOVFF  03,714
06D8A:  MOVFF  02,713
06D8E:  MOVFF  01,712
06D92:  MOVFF  00,711
06D96:  MOVFF  03,73F
06D9A:  MOVFF  02,73E
06D9E:  MOVFF  01,73D
06DA2:  MOVFF  00,73C
06DA6:  MOVFF  709,743
06DAA:  MOVFF  708,742
06DAE:  MOVFF  707,741
06DB2:  MOVFF  706,740
06DB6:  CALL   1D4A
06DBA:  BCF    FD8.1
06DBC:  MOVFF  70D,74A
06DC0:  MOVFF  70C,749
06DC4:  MOVFF  70B,748
06DC8:  MOVFF  70A,747
06DCC:  MOVFF  03,74E
06DD0:  MOVFF  02,74D
06DD4:  MOVFF  01,74C
06DD8:  MOVFF  00,74B
06DDC:  CALL   0E16
06DE0:  MOVFF  03,70D
06DE4:  MOVFF  02,70C
06DE8:  MOVFF  01,70B
06DEC:  MOVFF  00,70A
....................          }
06DF0:  BRA    6E6A
06DF2:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06DF4:  CLRF   x46
06DF6:  CLRF   x45
06DF8:  MOVLW  20
06DFA:  MOVWF  x44
06DFC:  MOVLW  82
06DFE:  MOVWF  x43
06E00:  MOVFF  70D,74A
06E04:  MOVFF  70C,749
06E08:  MOVFF  70B,748
06E0C:  MOVFF  70A,747
06E10:  MOVLB  0
06E12:  CALL   0D20
06E16:  MOVFF  03,714
06E1A:  MOVFF  02,713
06E1E:  MOVFF  01,712
06E22:  MOVFF  00,711
06E26:  MOVLB  7
06E28:  CLRF   x48
06E2A:  MOVFF  70F,747
06E2E:  MOVLB  0
06E30:  CALL   0CEA
06E34:  BCF    FD8.1
06E36:  MOVFF  714,74A
06E3A:  MOVFF  713,749
06E3E:  MOVFF  712,748
06E42:  MOVFF  711,747
06E46:  MOVFF  03,74E
06E4A:  MOVFF  02,74D
06E4E:  MOVFF  01,74C
06E52:  MOVFF  00,74B
06E56:  CALL   0E16
06E5A:  MOVFF  03,70D
06E5E:  MOVFF  02,70C
06E62:  MOVFF  01,70B
06E66:  MOVFF  00,70A
....................          }
....................       }
06E6A:  BRA    6E76
06E6C:  MOVLB  7
....................       else if (!skip)
06E6E:  BTFSC  x0E.0
06E70:  BRA    6E74
....................          break;
06E72:  BRA    6E8C
06E74:  MOVLB  0
06E76:  MOVLB  7
06E78:  MOVF   x10,W
06E7A:  INCF   x10,F
06E7C:  ADDWF  x02,W
06E7E:  MOVWF  FE9
06E80:  MOVLW  00
06E82:  ADDWFC x03,W
06E84:  MOVWF  FEA
06E86:  MOVFF  FEF,70F
06E8A:  BRA    6CF0
....................    }
.................... 
....................    if (sign)
06E8C:  BTFSS  x0E.1
06E8E:  BRA    6EC4
....................       result = -1*result;
06E90:  CLRF   x46
06E92:  CLRF   x45
06E94:  MOVLW  80
06E96:  MOVWF  x44
06E98:  MOVLW  7F
06E9A:  MOVWF  x43
06E9C:  MOVFF  70D,74A
06EA0:  MOVFF  70C,749
06EA4:  MOVFF  70B,748
06EA8:  MOVFF  70A,747
06EAC:  MOVLB  0
06EAE:  CALL   0D20
06EB2:  MOVFF  03,70D
06EB6:  MOVFF  02,70C
06EBA:  MOVFF  01,70B
06EBE:  MOVFF  00,70A
06EC2:  MOVLB  7
....................       
....................    if(endptr)
06EC4:  MOVF   x04,W
06EC6:  IORWF  x05,W
06EC8:  BZ    6EF8
....................    {
....................       if (ptr) {
06ECA:  MOVF   x10,F
06ECC:  BZ    6EE6
....................          ptr--;
06ECE:  DECF   x10,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06ED0:  MOVFF  705,FEA
06ED4:  MOVFF  704,FE9
06ED8:  MOVF   x10,W
06EDA:  ADDWF  x02,W
06EDC:  MOVWF  FEF
06EDE:  MOVLW  00
06EE0:  ADDWFC x03,W
06EE2:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06EE4:  BRA    6EF8
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
06EE6:  MOVFF  705,FEA
06EEA:  MOVFF  704,FE9
06EEE:  MOVFF  703,FEC
06EF2:  MOVF   FED,F
06EF4:  MOVFF  702,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
06EF8:  MOVFF  70A,00
06EFC:  MOVFF  70B,01
06F00:  MOVFF  70C,02
06F04:  MOVFF  70D,03
06F08:  MOVLB  0
06F0A:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
058FE:  MOVLB  7
05900:  CLRF   x34
05902:  CLRF   x33
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05904:  MOVLW  30
05906:  MOVWF  x36
05908:  MOVLW  31
0590A:  MOVWF  x37
0590C:  MOVLW  32
0590E:  MOVWF  x38
05910:  MOVLW  33
05912:  MOVWF  x39
05914:  MOVLW  34
05916:  MOVWF  x3A
05918:  MOVLW  35
0591A:  MOVWF  x3B
0591C:  MOVLW  36
0591E:  MOVWF  x3C
05920:  MOVLW  37
05922:  MOVWF  x3D
05924:  MOVLW  38
05926:  MOVWF  x3E
05928:  MOVLW  39
0592A:  MOVWF  x3F
0592C:  MOVLW  61
0592E:  MOVWF  x40
05930:  MOVLW  62
05932:  MOVWF  x41
05934:  MOVLW  63
05936:  MOVWF  x42
05938:  MOVLW  64
0593A:  MOVWF  x43
0593C:  MOVLW  65
0593E:  MOVWF  x44
05940:  MOVLW  66
05942:  MOVWF  x45
05944:  MOVLW  67
05946:  MOVWF  x46
05948:  MOVLW  68
0594A:  MOVWF  x47
0594C:  MOVLW  69
0594E:  MOVWF  x48
05950:  MOVLW  6A
05952:  MOVWF  x49
05954:  MOVLW  6B
05956:  MOVWF  x4A
05958:  MOVLW  6C
0595A:  MOVWF  x4B
0595C:  MOVLW  6D
0595E:  MOVWF  x4C
05960:  MOVLW  6E
05962:  MOVWF  x4D
05964:  MOVLW  6F
05966:  MOVWF  x4E
05968:  MOVLW  70
0596A:  MOVWF  x4F
0596C:  MOVLW  71
0596E:  MOVWF  x50
05970:  MOVLW  73
05972:  MOVWF  x51
05974:  MOVLW  74
05976:  MOVWF  x52
05978:  MOVLW  75
0597A:  MOVWF  x53
0597C:  MOVLW  76
0597E:  MOVWF  x54
05980:  MOVLW  77
05982:  MOVWF  x55
05984:  MOVLW  78
05986:  MOVWF  x56
05988:  MOVLW  79
0598A:  MOVWF  x57
0598C:  MOVLW  7A
0598E:  MOVWF  x58
05990:  CLRF   x59
....................    for(sc=s;isspace(*sc);++sc);
05992:  MOVFF  729,72E
05996:  MOVFF  728,72D
0599A:  MOVFF  72E,FEA
0599E:  MOVFF  72D,FE9
059A2:  MOVF   FEF,W
059A4:  SUBLW  20
059A6:  BNZ   59B0
059A8:  INCF   x2D,F
059AA:  BTFSC  FD8.2
059AC:  INCF   x2E,F
059AE:  BRA    599A
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
059B0:  MOVFF  72E,03
059B4:  MOVFF  72D,FE9
059B8:  MOVFF  03,FEA
059BC:  MOVF   FEF,W
059BE:  SUBLW  2D
059C0:  BZ    59D0
059C2:  MOVFF  72E,FEA
059C6:  MOVFF  72D,FE9
059CA:  MOVF   FEF,W
059CC:  SUBLW  2B
059CE:  BNZ   59E2
059D0:  MOVFF  72E,FEA
059D4:  MOVF   x2D,W
059D6:  INCF   x2D,F
059D8:  BTFSC  FD8.2
059DA:  INCF   x2E,F
059DC:  MOVWF  FE9
059DE:  MOVF   FEF,W
059E0:  BRA    59E4
059E2:  MOVLW  2B
059E4:  MOVWF  x35
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
059E6:  MOVF   x35,W
059E8:  SUBLW  2D
059EA:  BZ    5A00
059EC:  BTFSC  x2C.7
059EE:  BRA    5A00
059F0:  DECFSZ x2C,W
059F2:  BRA    59F6
059F4:  BRA    5A00
059F6:  BTFSC  x2C.7
059F8:  BRA    5A04
059FA:  MOVF   x2C,W
059FC:  SUBLW  24
059FE:  BC    5A04
....................    goto StrtoulGO;
05A00:  BRA    5C0C
05A02:  BRA    5AFC
.................... 
....................    else if (base)
05A04:  MOVF   x2C,F
05A06:  BZ    5A94
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05A08:  MOVF   x2C,W
05A0A:  SUBLW  10
05A0C:  BNZ   5A48
05A0E:  MOVFF  72E,FEA
05A12:  MOVFF  72D,FE9
05A16:  MOVF   FEF,W
05A18:  SUBLW  30
05A1A:  BNZ   5A48
05A1C:  MOVLW  01
05A1E:  ADDWF  x2D,W
05A20:  MOVWF  FE9
05A22:  MOVLW  00
05A24:  ADDWFC x2E,W
05A26:  MOVWF  FEA
05A28:  MOVF   FEF,W
05A2A:  SUBLW  78
05A2C:  BZ    5A40
05A2E:  MOVLW  01
05A30:  ADDWF  x2D,W
05A32:  MOVWF  FE9
05A34:  MOVLW  00
05A36:  ADDWFC x2E,W
05A38:  MOVWF  FEA
05A3A:  MOVF   FEF,W
05A3C:  SUBLW  58
05A3E:  BNZ   5A48
....................          sc+=2;
05A40:  MOVLW  02
05A42:  ADDWF  x2D,F
05A44:  MOVLW  00
05A46:  ADDWFC x2E,F
....................       if(base==8 && *sc =='0')
05A48:  MOVF   x2C,W
05A4A:  SUBLW  08
05A4C:  BNZ   5A64
05A4E:  MOVFF  72E,FEA
05A52:  MOVFF  72D,FE9
05A56:  MOVF   FEF,W
05A58:  SUBLW  30
05A5A:  BNZ   5A64
....................          sc+=1;
05A5C:  MOVLW  01
05A5E:  ADDWF  x2D,F
05A60:  MOVLW  00
05A62:  ADDWFC x2E,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05A64:  MOVF   x2C,W
05A66:  SUBLW  02
05A68:  BNZ   5A92
05A6A:  MOVFF  72E,FEA
05A6E:  MOVFF  72D,FE9
05A72:  MOVF   FEF,W
05A74:  SUBLW  30
05A76:  BNZ   5A92
05A78:  MOVLW  01
05A7A:  ADDWF  x2D,W
05A7C:  MOVWF  FE9
05A7E:  MOVLW  00
05A80:  ADDWFC x2E,W
05A82:  MOVWF  FEA
05A84:  MOVF   FEF,W
05A86:  SUBLW  62
05A88:  BNZ   5A92
....................          sc+=2;
05A8A:  MOVLW  02
05A8C:  ADDWF  x2D,F
05A8E:  MOVLW  00
05A90:  ADDWFC x2E,F
.................... 
....................    }
05A92:  BRA    5AFC
....................    else if(*sc!='0') // base is 0, find base
05A94:  MOVFF  72E,FEA
05A98:  MOVFF  72D,FE9
05A9C:  MOVF   FEF,W
05A9E:  SUBLW  30
05AA0:  BZ    5AA8
....................       base=10;
05AA2:  MOVLW  0A
05AA4:  MOVWF  x2C
05AA6:  BRA    5AFC
....................    else if (sc[1]=='x' || sc[1]=='X')
05AA8:  MOVLW  01
05AAA:  ADDWF  x2D,W
05AAC:  MOVWF  FE9
05AAE:  MOVLW  00
05AB0:  ADDWFC x2E,W
05AB2:  MOVWF  FEA
05AB4:  MOVF   FEF,W
05AB6:  SUBLW  78
05AB8:  BZ    5ACC
05ABA:  MOVLW  01
05ABC:  ADDWF  x2D,W
05ABE:  MOVWF  FE9
05AC0:  MOVLW  00
05AC2:  ADDWFC x2E,W
05AC4:  MOVWF  FEA
05AC6:  MOVF   FEF,W
05AC8:  SUBLW  58
05ACA:  BNZ   5ADA
....................       base =16,sc+=2;
05ACC:  MOVLW  10
05ACE:  MOVWF  x2C
05AD0:  MOVLW  02
05AD2:  ADDWF  x2D,F
05AD4:  MOVLW  00
05AD6:  ADDWFC x2E,F
05AD8:  BRA    5AFC
....................    else if(sc[1]=='b')
05ADA:  MOVLW  01
05ADC:  ADDWF  x2D,W
05ADE:  MOVWF  FE9
05AE0:  MOVLW  00
05AE2:  ADDWFC x2E,W
05AE4:  MOVWF  FEA
05AE6:  MOVF   FEF,W
05AE8:  SUBLW  62
05AEA:  BNZ   5AF8
....................       base=2,sc+=2;
05AEC:  MOVLW  02
05AEE:  MOVWF  x2C
05AF0:  ADDWF  x2D,F
05AF2:  MOVLW  00
05AF4:  ADDWFC x2E,F
05AF6:  BRA    5AFC
....................    else
....................       base=8;
05AF8:  MOVLW  08
05AFA:  MOVWF  x2C
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05AFC:  MOVFF  72E,730
05B00:  MOVFF  72D,72F
05B04:  MOVFF  72E,FEA
05B08:  MOVFF  72D,FE9
05B0C:  MOVF   FEF,W
05B0E:  SUBLW  30
05B10:  BNZ   5B1A
05B12:  INCF   x2D,F
05B14:  BTFSC  FD8.2
05B16:  INCF   x2E,F
05B18:  BRA    5B04
....................    sd=memchr(digits,tolower(*sc),base);
05B1A:  MOVFF  72E,03
05B1E:  MOVFF  72D,FE9
05B22:  MOVFF  03,FEA
05B26:  MOVFF  FEF,75A
05B2A:  MOVF   x5A,W
05B2C:  SUBLW  40
05B2E:  BC    5B3C
05B30:  MOVF   x5A,W
05B32:  SUBLW  5A
05B34:  BNC   5B3C
05B36:  MOVF   x5A,W
05B38:  IORLW  20
05B3A:  BRA    5B3E
05B3C:  MOVF   x5A,W
05B3E:  MOVWF  x5A
05B40:  MOVLW  07
05B42:  MOVWF  x5C
05B44:  MOVLW  36
05B46:  MOVWF  x5B
05B48:  MOVFF  75A,75D
05B4C:  CLRF   x5F
05B4E:  MOVFF  72C,75E
05B52:  BTFSC  x5E.7
05B54:  DECF   x5F,F
05B56:  MOVLB  0
05B58:  RCALL  585E
05B5A:  MOVFF  02,732
05B5E:  MOVFF  01,731
....................    for(; sd!=0; )
05B62:  MOVLB  7
05B64:  MOVF   x31,F
05B66:  BNZ   5B6C
05B68:  MOVF   x32,F
05B6A:  BZ    5C00
....................    {
....................       x=x*base+(int16)(sd-digits);
05B6C:  CLRF   03
05B6E:  MOVF   x2C,W
05B70:  MOVWF  00
05B72:  BTFSC  FE8.7
05B74:  DECF   03,F
05B76:  MOVWF  x5A
05B78:  MOVFF  03,75B
05B7C:  MOVFF  734,75D
05B80:  MOVFF  733,75C
05B84:  MOVFF  03,75F
05B88:  MOVWF  x5E
05B8A:  MOVLB  0
05B8C:  BRA    58A8
05B8E:  MOVFF  01,75A
05B92:  MOVLW  36
05B94:  MOVLB  7
05B96:  SUBWF  x31,W
05B98:  MOVWF  00
05B9A:  MOVLW  07
05B9C:  SUBWFB x32,W
05B9E:  MOVWF  03
05BA0:  MOVF   00,W
05BA2:  ADDWF  01,W
05BA4:  MOVWF  01
05BA6:  MOVF   02,W
05BA8:  ADDWFC 03,F
05BAA:  MOVFF  01,733
05BAE:  MOVFF  03,734
....................       ++sc;
05BB2:  INCF   x2D,F
05BB4:  BTFSC  FD8.2
05BB6:  INCF   x2E,F
....................       sd=memchr(digits,tolower(*sc),base);
05BB8:  MOVFF  72E,FEA
05BBC:  MOVFF  72D,FE9
05BC0:  MOVFF  FEF,75A
05BC4:  MOVF   x5A,W
05BC6:  SUBLW  40
05BC8:  BC    5BD6
05BCA:  MOVF   x5A,W
05BCC:  SUBLW  5A
05BCE:  BNC   5BD6
05BD0:  MOVF   x5A,W
05BD2:  IORLW  20
05BD4:  BRA    5BD8
05BD6:  MOVF   x5A,W
05BD8:  MOVWF  x5A
05BDA:  MOVLW  07
05BDC:  MOVWF  x5C
05BDE:  MOVLW  36
05BE0:  MOVWF  x5B
05BE2:  MOVFF  75A,75D
05BE6:  CLRF   x5F
05BE8:  MOVFF  72C,75E
05BEC:  BTFSC  x5E.7
05BEE:  DECF   x5F,F
05BF0:  MOVLB  0
05BF2:  RCALL  585E
05BF4:  MOVFF  02,732
05BF8:  MOVFF  01,731
05BFC:  BRA    5B62
05BFE:  MOVLB  7
....................    }
....................    if(s1==sc)
05C00:  MOVF   x2D,W
05C02:  SUBWF  x2F,W
05C04:  BNZ   5C2E
05C06:  MOVF   x2E,W
05C08:  SUBWF  x30,W
05C0A:  BNZ   5C2E
....................    {
....................    StrtoulGO:
....................       if (endptr)
05C0C:  MOVLB  7
05C0E:  MOVF   x2A,W
05C10:  IORWF  x2B,W
05C12:  BZ    5C26
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05C14:  MOVFF  72B,FEA
05C18:  MOVFF  72A,FE9
05C1C:  MOVFF  729,FEC
05C20:  MOVF   FED,F
05C22:  MOVFF  728,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05C26:  MOVLW  00
05C28:  MOVWF  01
05C2A:  MOVWF  02
05C2C:  BRA    5C4E
....................    }
....................    if (endptr)
05C2E:  MOVF   x2A,W
05C30:  IORWF  x2B,W
05C32:  BZ    5C46
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05C34:  MOVFF  72B,FEA
05C38:  MOVFF  72A,FE9
05C3C:  MOVFF  72E,FEC
05C40:  MOVF   FED,F
05C42:  MOVFF  72D,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05C46:  MOVFF  733,01
05C4A:  MOVFF  734,02
05C4E:  MOVLB  0
05C50:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00418:  MOVLB  6
0041A:  CLRF   xF3
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0041C:  CLRF   xF3
0041E:  MOVF   xF2,W
00420:  SUBWF  xF3,W
00422:  BC    047A
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00424:  MOVF   xF3,W
00426:  ADDWF  xF0,W
00428:  MOVWF  xF4
0042A:  MOVLW  00
0042C:  ADDWFC xF1,W
0042E:  MOVWF  xF5
00430:  MOVF   xF3,W
00432:  ADDWF  xEE,W
00434:  MOVWF  01
00436:  MOVLW  00
00438:  ADDWFC xEF,W
0043A:  MOVWF  03
0043C:  MOVF   01,W
0043E:  MOVWF  FE9
00440:  MOVFF  03,FEA
00444:  MOVFF  FEF,6F6
00448:  BSF    F7F.7
0044A:  MOVF   FF2,W
0044C:  MOVWF  00
0044E:  BCF    FF2.7
00450:  MOVFF  6F5,F7A
00454:  MOVFF  6F4,F79
00458:  MOVLW  31
0045A:  MOVWF  F7B
0045C:  MOVFF  6F6,F7C
00460:  MOVLB  F
00462:  MOVLW  55
00464:  MOVWF  F81
00466:  MOVLW  AA
00468:  MOVWF  F81
0046A:  BSF    F80.4
0046C:  BTFSC  F80.4
0046E:  BRA    046C
00470:  MOVF   00,W
00472:  IORWF  FF2,F
00474:  MOVLB  6
00476:  INCF   xF3,F
00478:  BRA    041E
....................    }
0047A:  MOVLB  0
0047C:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0039C:  MOVLB  6
0039E:  CLRF   xF3
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003A0:  CLRF   xF3
003A2:  MOVF   xF2,W
003A4:  SUBWF  xF3,W
003A6:  BC    03EA
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003A8:  MOVF   xF3,W
003AA:  ADDWF  xEE,W
003AC:  MOVWF  01
003AE:  MOVLW  00
003B0:  ADDWFC xEF,W
003B2:  MOVWF  03
003B4:  MOVF   01,W
003B6:  MOVWF  FE9
003B8:  MOVFF  03,FEA
003BC:  MOVF   xF3,W
003BE:  ADDWF  xF0,W
003C0:  MOVWF  xF6
003C2:  MOVLW  00
003C4:  ADDWFC xF1,W
003C6:  MOVWF  xF7
003C8:  BSF    F7F.7
003CA:  MOVFF  FF2,6F8
003CE:  BCF    FF2.7
003D0:  MOVFF  6F7,F7A
003D4:  MOVFF  6F6,F79
003D8:  MOVLW  31
003DA:  MOVWF  F7B
003DC:  BSF    F80.0
003DE:  MOVF   F7C,W
003E0:  BTFSC  xF8.7
003E2:  BSF    FF2.7
003E4:  MOVWF  FEF
003E6:  INCF   xF3,F
003E8:  BRA    03A2
....................    }
003EA:  MOVLB  0
003EC:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0047E:  MOVLB  6
00480:  CLRF   xEF
00482:  MOVLW  20
00484:  MOVWF  xEE
00486:  CLRF   xF1
00488:  CLRF   xF0
0048A:  MOVLW  80
0048C:  MOVWF  xF2
0048E:  MOVLB  0
00490:  RCALL  0418
....................    delay_ms(1);
00492:  MOVLW  01
00494:  MOVLB  6
00496:  MOVWF  xF4
00498:  MOVLB  0
0049A:  RCALL  03EE
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0049C:  MOVLB  6
0049E:  CLRF   xEF
004A0:  MOVLW  60
004A2:  MOVWF  xEE
004A4:  CLRF   xF1
004A6:  MOVLW  80
004A8:  MOVWF  xF0
004AA:  MOVLW  02
004AC:  MOVWF  xF2
004AE:  MOVLB  0
004B0:  RCALL  0418
....................    delay_ms(1);
004B2:  MOVLW  01
004B4:  MOVLB  6
004B6:  MOVWF  xF4
004B8:  MOVLB  0
004BA:  RCALL  03EE
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004BC:  MOVLB  6
004BE:  CLRF   xEF
004C0:  MOVLW  61
004C2:  MOVWF  xEE
004C4:  CLRF   xF1
004C6:  MOVLW  90
004C8:  MOVWF  xF0
004CA:  MOVLW  02
004CC:  MOVWF  xF2
004CE:  MOVLB  0
004D0:  RCALL  0418
....................    delay_ms(1);
004D2:  MOVLW  01
004D4:  MOVLB  6
004D6:  MOVWF  xF4
004D8:  MOVLB  0
004DA:  RCALL  03EE
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
004DC:  MOVLB  6
004DE:  CLRF   xEF
004E0:  MOVLW  62
004E2:  MOVWF  xEE
004E4:  CLRF   xF1
004E6:  MOVLW  A0
004E8:  MOVWF  xF0
004EA:  MOVLW  20
004EC:  MOVWF  xF2
004EE:  MOVLB  0
004F0:  RCALL  0418
....................    delay_ms(1);
004F2:  MOVLW  01
004F4:  MOVLB  6
004F6:  MOVWF  xF4
004F8:  MOVLB  0
004FA:  RCALL  03EE
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004FC:  MOVLB  6
004FE:  CLRF   xEF
00500:  MOVLW  82
00502:  MOVWF  xEE
00504:  CLRF   xF1
00506:  MOVLW  C0
00508:  MOVWF  xF0
0050A:  MOVLW  30
0050C:  MOVWF  xF2
0050E:  MOVLB  0
00510:  RCALL  0418
....................    delay_ms(1);
00512:  MOVLW  01
00514:  MOVLB  6
00516:  MOVWF  xF4
00518:  MOVLB  0
0051A:  RCALL  03EE
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0051C:  MOVLB  6
0051E:  CLRF   xEF
00520:  MOVLW  B2
00522:  MOVWF  xEE
00524:  CLRF   xF1
00526:  MOVLW  F0
00528:  MOVWF  xF0
0052A:  MOVLW  38
0052C:  MOVWF  xF2
0052E:  MOVLB  0
00530:  RCALL  0418
....................    delay_ms(1);
00532:  MOVLW  01
00534:  MOVLB  6
00536:  MOVWF  xF4
00538:  MOVLB  0
0053A:  RCALL  03EE
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0053C:  MOVLB  6
0053E:  CLRF   xEF
00540:  MOVLW  EA
00542:  MOVWF  xEE
00544:  MOVLW  01
00546:  MOVWF  xF1
00548:  MOVLW  40
0054A:  MOVWF  xF0
0054C:  MOVLW  01
0054E:  MOVWF  xF2
00550:  MOVLB  0
00552:  RCALL  0418
....................    delay_ms(1);
00554:  MOVLW  01
00556:  MOVLB  6
00558:  MOVWF  xF4
0055A:  MOVLB  0
0055C:  RCALL  03EE
0055E:  GOTO   062E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00562:  MOVLB  6
00564:  CLRF   xEF
00566:  MOVLW  20
00568:  MOVWF  xEE
0056A:  CLRF   xF1
0056C:  CLRF   xF0
0056E:  MOVLW  80
00570:  MOVWF  xF2
00572:  MOVLB  0
00574:  RCALL  039C
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00576:  MOVLB  6
00578:  CLRF   xEF
0057A:  MOVLW  60
0057C:  MOVWF  xEE
0057E:  CLRF   xF1
00580:  MOVLW  80
00582:  MOVWF  xF0
00584:  MOVLW  02
00586:  MOVWF  xF2
00588:  MOVLB  0
0058A:  RCALL  039C
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0058C:  MOVLB  6
0058E:  CLRF   xEF
00590:  MOVLW  61
00592:  MOVWF  xEE
00594:  CLRF   xF1
00596:  MOVLW  90
00598:  MOVWF  xF0
0059A:  MOVLW  02
0059C:  MOVWF  xF2
0059E:  MOVLB  0
005A0:  RCALL  039C
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005A2:  MOVLB  6
005A4:  CLRF   xEF
005A6:  MOVLW  62
005A8:  MOVWF  xEE
005AA:  CLRF   xF1
005AC:  MOVLW  A0
005AE:  MOVWF  xF0
005B0:  MOVLW  20
005B2:  MOVWF  xF2
005B4:  MOVLB  0
005B6:  RCALL  039C
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005B8:  MOVLB  6
005BA:  CLRF   xEF
005BC:  MOVLW  82
005BE:  MOVWF  xEE
005C0:  CLRF   xF1
005C2:  MOVLW  C0
005C4:  MOVWF  xF0
005C6:  MOVLW  30
005C8:  MOVWF  xF2
005CA:  MOVLB  0
005CC:  RCALL  039C
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005CE:  MOVLB  6
005D0:  CLRF   xEF
005D2:  MOVLW  B2
005D4:  MOVWF  xEE
005D6:  CLRF   xF1
005D8:  MOVLW  F0
005DA:  MOVWF  xF0
005DC:  MOVLW  38
005DE:  MOVWF  xF2
005E0:  MOVLB  0
005E2:  RCALL  039C
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005E4:  MOVLB  6
005E6:  CLRF   xEF
005E8:  MOVLW  EA
005EA:  MOVWF  xEE
005EC:  MOVLW  01
005EE:  MOVWF  xF1
005F0:  MOVLW  40
005F2:  MOVWF  xF0
005F4:  MOVLW  01
005F6:  MOVWF  xF2
005F8:  MOVLB  0
005FA:  RCALL  039C
005FC:  GOTO   0632 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00600:  MOVLB  6
00602:  CLRF   xEF
00604:  MOVLW  EA
00606:  MOVWF  xEE
00608:  MOVLW  01
0060A:  MOVWF  xF1
0060C:  MOVLW  40
0060E:  MOVWF  xF0
00610:  MOVLW  01
00612:  MOVWF  xF2
00614:  MOVLB  0
00616:  RCALL  039C
....................    delay_ms(1);
00618:  MOVLW  01
0061A:  MOVLB  6
0061C:  MOVWF  xF4
0061E:  MOVLB  0
00620:  RCALL  03EE
....................    if (paramsValid != isValid)
00622:  MOVF   xEA,W
00624:  SUBLW  AA
00626:  BZ    0630
....................    {
....................       paramsValid = isValid;
00628:  MOVLW  AA
0062A:  MOVWF  xEA
....................       params_save_to_ee(); // saves the base parameters on first boot
0062C:  BRA    047E
....................    }
0062E:  BRA    0632
....................    else
....................    {
....................       params_load_from_ee();
00630:  BRA    0562
....................    }
00632:  GOTO   A5A8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  C4
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00636:  RCALL  0138
....................    switch(ch)
00638:  MOVLB  6
0063A:  MOVF   xFF,W
0063C:  ADDLW  FC
0063E:  BC    0672
00640:  ADDLW  04
00642:  MOVLB  0
00644:  GOTO   067E
....................    {
....................       case 0:
....................          output_low(_CS0);
00648:  MOVLW  1F
0064A:  MOVWF  F8A
0064C:  BCF    F85.5
....................       break; 
0064E:  MOVLB  6
00650:  BRA    0672
....................       case 1:
....................          output_low(_CS1);
00652:  MOVLW  1F
00654:  MOVWF  F8A
00656:  BCF    F85.6
....................       break;   
00658:  MOVLB  6
0065A:  BRA    0672
....................       case 2:
....................          output_low(_CS2);
0065C:  MOVLW  1F
0065E:  MOVWF  F8A
00660:  BCF    F85.7
....................       break;
00662:  MOVLB  6
00664:  BRA    0672
....................       case 3:
....................          output_low(_CS3);
00666:  MOVLW  C4
00668:  MOVWF  F88
0066A:  BCF    F83.0
....................       break;              
0066C:  MOVLB  6
0066E:  BRA    0672
00670:  MOVLB  6
....................    }
....................    delay_us(10);
00672:  MOVLW  35
00674:  MOVWF  00
00676:  DECFSZ 00,F
00678:  BRA    0676
0067A:  MOVLB  0
0067C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  7
0015A:  MOVF   x67,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  C4
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
0076A:  MOVLW  1F
0076C:  MOVWF  F8A
0076E:  BCF    F85.5
....................    output_low(_CS1);
00770:  MOVWF  F8A
00772:  BCF    F85.6
....................    output_low(_CS2);
00774:  MOVWF  F8A
00776:  BCF    F85.7
....................    output_low(_CS3);
00778:  MOVLW  C4
0077A:  MOVWF  F88
0077C:  BCF    F83.0
....................    delay_us(10);
0077E:  MOVLW  35
00780:  MOVWF  00
00782:  DECFSZ 00,F
00784:  BRA    0782
00786:  GOTO   078C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006A0:  MOVFF  6FD,6FF
006A4:  RCALL  0636
....................    spi_write2(command);
006A6:  MOVLB  E
006A8:  MOVF   x8D,W
006AA:  MOVFF  6FE,E8D
006AE:  RRCF   x90,W
006B0:  BNC   06AE
006B2:  MOVLB  0
006B4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  765,767
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  766,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
0078A:  BRA    076A
....................    spi_write2(command);
0078C:  MOVLB  E
0078E:  MOVF   x8D,W
00790:  MOVFF  6F4,E8D
00794:  RRCF   x90,W
00796:  BNC   0794
00798:  MOVLB  0
0079A:  GOTO   07A8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
007B6:  MOVFF  6FC,6FF
007BA:  RCALL  0636
....................    spi_read2(command);
007BC:  MOVLB  E
007BE:  MOVF   x8D,W
007C0:  MOVFF  6FD,E8D
007C4:  RRCF   x90,W
007C6:  BNC   07C4
007C8:  MOVLB  0
007CA:  GOTO   07DC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
006DA:  MOVLB  6
006DC:  MOVF   xFA,W
006DE:  IORLW  40
006E0:  MOVWF  xFC
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
006E2:  MOVFF  6F9,6FD
006E6:  MOVFF  6FC,6FE
006EA:  MOVLB  0
006EC:  RCALL  06A0
....................    spi_write2(data);
006EE:  MOVLB  E
006F0:  MOVF   x8D,W
006F2:  MOVFF  6FB,E8D
006F6:  RRCF   x90,W
006F8:  BNC   06F6
....................    ads_deselect_all();
006FA:  MOVLB  0
006FC:  RCALL  0138
006FE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  764,765
001A8:  MOVLW  08
001AA:  MOVLB  7
001AC:  MOVWF  x66
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
0079E:  MOVLW  08
007A0:  MOVLB  6
007A2:  MOVWF  xF4
007A4:  MOVLB  0
007A6:  BRA    078A
....................    delay_us(10);
007A8:  MOVLW  35
007AA:  MOVWF  00
007AC:  DECFSZ 00,F
007AE:  BRA    07AC
....................    ads_deselect_all();
007B0:  RCALL  0138
007B2:  GOTO   0938 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
007CE:  MOVFF  6F7,6FC
007D2:  MOVLW  10
007D4:  MOVLB  6
007D6:  MOVWF  xFD
007D8:  MOVLB  0
007DA:  BRA    07B6
....................    data.dBytes[3] = 0;
007DC:  MOVLB  6
007DE:  CLRF   xFB
....................    data.dBytes[2] = spi_read2(0);
007E0:  MOVLB  E
007E2:  MOVF   x8D,W
007E4:  CLRF   x8D
007E6:  RRCF   x90,W
007E8:  BNC   07E6
007EA:  MOVFF  E8D,6FA
....................    data.dBytes[1] = spi_read2(0);
007EE:  MOVF   x8D,W
007F0:  CLRF   x8D
007F2:  RRCF   x90,W
007F4:  BNC   07F2
007F6:  MOVFF  E8D,6F9
....................    data.dBytes[0] = spi_read2(0);
007FA:  MOVF   x8D,W
007FC:  CLRF   x8D
007FE:  RRCF   x90,W
00800:  BNC   07FE
00802:  MOVFF  E8D,6F8
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00806:  MOVLB  6
00808:  MOVF   xFA,W
0080A:  ANDLW  80
0080C:  BZ    0812
0080E:  MOVLW  FF
00810:  IORWF  xFB,F
....................    
....................    ads_deselect_all();
00812:  MOVLB  0
00814:  RCALL  0138
....................    return data.dWord;
00816:  MOVFF  6F8,00
0081A:  MOVFF  6F9,01
0081E:  MOVFF  6FA,02
00822:  MOVFF  6FB,03
00826:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00700:  MOVFF  6F4,6FD
00704:  MOVLW  06
00706:  MOVLB  6
00708:  MOVWF  xFE
0070A:  MOVLB  0
0070C:  RCALL  06A0
....................    delay_us(300);                    
0070E:  MOVLW  02
00710:  MOVLB  6
00712:  MOVWF  xF9
00714:  MOVLW  96
00716:  MOVWF  xFA
00718:  MOVLB  0
0071A:  RCALL  06B6
0071C:  MOVLB  6
0071E:  DECFSZ xF9,F
00720:  BRA    0714
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00722:  MOVFF  6F4,6F9
00726:  CLRF   xFA
00728:  MOVFF  6F5,6FB
0072C:  MOVLB  0
0072E:  RCALL  06DA
....................    ads_write_reg(ch, reg1, rc1);
00730:  MOVFF  6F4,6F9
00734:  MOVLW  04
00736:  MOVLB  6
00738:  MOVWF  xFA
0073A:  MOVFF  6F6,6FB
0073E:  MOVLB  0
00740:  RCALL  06DA
....................    ads_write_reg(ch, reg2, rc2);
00742:  MOVFF  6F4,6F9
00746:  MOVLW  08
00748:  MOVLB  6
0074A:  MOVWF  xFA
0074C:  MOVFF  6F7,6FB
00750:  MOVLB  0
00752:  RCALL  06DA
....................    ads_write_reg(ch, reg3, rc3);  
00754:  MOVFF  6F4,6F9
00758:  MOVLW  0C
0075A:  MOVLB  6
0075C:  MOVWF  xFA
0075E:  MOVFF  6F8,6FB
00762:  MOVLB  0
00764:  RCALL  06DA
00766:  GOTO   0912 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02700:  MOVLB  7
02702:  BCF    x42.0
....................    y = x;
02704:  MOVFF  736,73B
02708:  MOVFF  735,73A
0270C:  MOVFF  734,739
02710:  MOVFF  733,738
.................... 
....................    if (x < 0)
02714:  MOVFF  736,746
02718:  MOVFF  735,745
0271C:  MOVFF  734,744
02720:  MOVFF  733,743
02724:  CLRF   x4A
02726:  CLRF   x49
02728:  CLRF   x48
0272A:  CLRF   x47
0272C:  MOVLB  0
0272E:  CALL   1CD0
02732:  BNC   2740
....................    {
....................       s = 1;
02734:  MOVLB  7
02736:  BSF    x42.0
....................       y = -y;
02738:  MOVF   x39,W
0273A:  XORLW  80
0273C:  MOVWF  x39
0273E:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02740:  MOVFF  73B,746
02744:  MOVFF  73A,745
02748:  MOVFF  739,744
0274C:  MOVFF  738,743
02750:  MOVLB  7
02752:  CLRF   x4A
02754:  CLRF   x49
02756:  CLRF   x48
02758:  MOVLW  8E
0275A:  MOVWF  x47
0275C:  MOVLB  0
0275E:  CALL   1CD0
02762:  BC    2766
02764:  BNZ   2796
....................       res = (float32)(unsigned int16)y;
02766:  MOVFF  73B,746
0276A:  MOVFF  73A,745
0276E:  MOVFF  739,744
02772:  MOVFF  738,743
02776:  RCALL  26C4
02778:  MOVFF  02,748
0277C:  MOVFF  01,747
02780:  CALL   0CEA
02784:  MOVFF  03,73F
02788:  MOVFF  02,73E
0278C:  MOVFF  01,73D
02790:  MOVFF  00,73C
02794:  BRA    2938
.................... 
....................  else if (y < 10000000.0)
02796:  MOVFF  73B,746
0279A:  MOVFF  73A,745
0279E:  MOVFF  739,744
027A2:  MOVFF  738,743
027A6:  MOVLW  80
027A8:  MOVLB  7
027AA:  MOVWF  x4A
027AC:  MOVLW  96
027AE:  MOVWF  x49
027B0:  MOVLW  18
027B2:  MOVWF  x48
027B4:  MOVLW  96
027B6:  MOVWF  x47
027B8:  MOVLB  0
027BA:  CALL   1CD0
027BE:  BTFSS  FD8.0
027C0:  BRA    2928
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
027C2:  MOVFF  73B,746
027C6:  MOVFF  73A,745
027CA:  MOVFF  739,744
027CE:  MOVFF  738,743
027D2:  MOVLB  7
027D4:  CLRF   x4A
027D6:  CLRF   x49
027D8:  CLRF   x48
027DA:  MOVLW  70
027DC:  MOVWF  x47
027DE:  MOVLB  0
027E0:  CALL   0D20
027E4:  MOVFF  03,746
027E8:  MOVFF  02,745
027EC:  MOVFF  01,744
027F0:  MOVFF  00,743
027F4:  RCALL  26C4
027F6:  MOVFF  02,741
027FA:  MOVFF  01,740
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
027FE:  MOVFF  73B,746
02802:  MOVFF  73A,745
02806:  MOVFF  739,744
0280A:  MOVFF  738,743
0280E:  MOVLB  7
02810:  CLRF   x4A
02812:  CLRF   x49
02814:  CLRF   x48
02816:  MOVLW  70
02818:  MOVWF  x47
0281A:  MOVLB  0
0281C:  CALL   0D20
02820:  MOVFF  03,746
02824:  MOVFF  02,745
02828:  MOVFF  01,744
0282C:  MOVFF  00,743
02830:  MOVFF  741,748
02834:  MOVFF  740,747
02838:  CALL   0CEA
0283C:  BSF    FD8.1
0283E:  MOVFF  746,74A
02842:  MOVFF  745,749
02846:  MOVFF  744,748
0284A:  MOVFF  743,747
0284E:  MOVFF  03,74E
02852:  MOVFF  02,74D
02856:  MOVFF  01,74C
0285A:  MOVFF  00,74B
0285E:  CALL   0E16
02862:  MOVLB  7
02864:  CLRF   x46
02866:  CLRF   x45
02868:  CLRF   x44
0286A:  MOVLW  8E
0286C:  MOVWF  x43
0286E:  MOVFF  03,74A
02872:  MOVFF  02,749
02876:  MOVFF  01,748
0287A:  MOVFF  00,747
0287E:  MOVLB  0
02880:  CALL   0D20
02884:  MOVFF  03,73B
02888:  MOVFF  02,73A
0288C:  MOVFF  01,739
02890:  MOVFF  00,738
....................       res = 32768.0*(float32)l;
02894:  MOVFF  741,748
02898:  MOVFF  740,747
0289C:  CALL   0CEA
028A0:  MOVLB  7
028A2:  CLRF   x46
028A4:  CLRF   x45
028A6:  CLRF   x44
028A8:  MOVLW  8E
028AA:  MOVWF  x43
028AC:  MOVFF  03,74A
028B0:  MOVFF  02,749
028B4:  MOVFF  01,748
028B8:  MOVFF  00,747
028BC:  MOVLB  0
028BE:  CALL   0D20
028C2:  MOVFF  03,73F
028C6:  MOVFF  02,73E
028CA:  MOVFF  01,73D
028CE:  MOVFF  00,73C
....................       res += (float32)(unsigned int16)y;
028D2:  MOVFF  73B,746
028D6:  MOVFF  73A,745
028DA:  MOVFF  739,744
028DE:  MOVFF  738,743
028E2:  RCALL  26C4
028E4:  MOVFF  02,748
028E8:  MOVFF  01,747
028EC:  CALL   0CEA
028F0:  BCF    FD8.1
028F2:  MOVFF  73F,74A
028F6:  MOVFF  73E,749
028FA:  MOVFF  73D,748
028FE:  MOVFF  73C,747
02902:  MOVFF  03,74E
02906:  MOVFF  02,74D
0290A:  MOVFF  01,74C
0290E:  MOVFF  00,74B
02912:  CALL   0E16
02916:  MOVFF  03,73F
0291A:  MOVFF  02,73E
0291E:  MOVFF  01,73D
02922:  MOVFF  00,73C
....................    }
02926:  BRA    2938
.................... 
....................  else
....................   res = y;
02928:  MOVFF  73B,73F
0292C:  MOVFF  73A,73E
02930:  MOVFF  739,73D
02934:  MOVFF  738,73C
.................... 
....................  y = y - (float32)(unsigned int16)y;
02938:  MOVFF  73B,746
0293C:  MOVFF  73A,745
02940:  MOVFF  739,744
02944:  MOVFF  738,743
02948:  RCALL  26C4
0294A:  MOVFF  02,748
0294E:  MOVFF  01,747
02952:  CALL   0CEA
02956:  BSF    FD8.1
02958:  MOVFF  73B,74A
0295C:  MOVFF  73A,749
02960:  MOVFF  739,748
02964:  MOVFF  738,747
02968:  MOVFF  03,74E
0296C:  MOVFF  02,74D
02970:  MOVFF  01,74C
02974:  MOVFF  00,74B
02978:  CALL   0E16
0297C:  MOVFF  03,73B
02980:  MOVFF  02,73A
02984:  MOVFF  01,739
02988:  MOVFF  00,738
.................... 
....................  if (s)
0298C:  MOVLB  7
0298E:  BTFSS  x42.0
02990:  BRA    2998
....................   res = -res;
02992:  MOVF   x3D,W
02994:  XORLW  80
02996:  MOVWF  x3D
.................... 
....................  if (y != 0)
02998:  MOVFF  73B,746
0299C:  MOVFF  73A,745
029A0:  MOVFF  739,744
029A4:  MOVFF  738,743
029A8:  CLRF   x4A
029AA:  CLRF   x49
029AC:  CLRF   x48
029AE:  CLRF   x47
029B0:  MOVLB  0
029B2:  CALL   1CD0
029B6:  BZ    2A30
....................  {
....................   if (s == 1 && n == 0)
029B8:  MOVLB  7
029BA:  BTFSS  x42.0
029BC:  BRA    29F6
029BE:  MOVF   x37,F
029C0:  BNZ   29F6
....................    res -= 1.0;
029C2:  BSF    FD8.1
029C4:  MOVFF  73F,74A
029C8:  MOVFF  73E,749
029CC:  MOVFF  73D,748
029D0:  MOVFF  73C,747
029D4:  CLRF   x4E
029D6:  CLRF   x4D
029D8:  CLRF   x4C
029DA:  MOVLW  7F
029DC:  MOVWF  x4B
029DE:  MOVLB  0
029E0:  CALL   0E16
029E4:  MOVFF  03,73F
029E8:  MOVFF  02,73E
029EC:  MOVFF  01,73D
029F0:  MOVFF  00,73C
029F4:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
029F6:  BTFSC  x42.0
029F8:  BRA    2A32
029FA:  DECFSZ x37,W
029FC:  BRA    2A32
....................    res += 1.0;
029FE:  BCF    FD8.1
02A00:  MOVFF  73F,74A
02A04:  MOVFF  73E,749
02A08:  MOVFF  73D,748
02A0C:  MOVFF  73C,747
02A10:  CLRF   x4E
02A12:  CLRF   x4D
02A14:  CLRF   x4C
02A16:  MOVLW  7F
02A18:  MOVWF  x4B
02A1A:  MOVLB  0
02A1C:  CALL   0E16
02A20:  MOVFF  03,73F
02A24:  MOVFF  02,73E
02A28:  MOVFF  01,73D
02A2C:  MOVFF  00,73C
02A30:  MOVLB  7
....................  }
....................  if (x == 0)
02A32:  MOVFF  736,746
02A36:  MOVFF  735,745
02A3A:  MOVFF  734,744
02A3E:  MOVFF  733,743
02A42:  CLRF   x4A
02A44:  CLRF   x49
02A46:  CLRF   x48
02A48:  CLRF   x47
02A4A:  MOVLB  0
02A4C:  CALL   1CD0
02A50:  BNZ   2A5E
....................     res = 0;
02A52:  MOVLB  7
02A54:  CLRF   x3F
02A56:  CLRF   x3E
02A58:  CLRF   x3D
02A5A:  CLRF   x3C
02A5C:  MOVLB  0
.................... 
....................  return (res);
02A5E:  MOVFF  73C,00
02A62:  MOVFF  73D,01
02A66:  MOVFF  73E,02
02A6A:  MOVFF  73F,03
02A6E:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02A8E:  MOVFF  732,736
02A92:  MOVFF  731,735
02A96:  MOVFF  730,734
02A9A:  MOVFF  72F,733
02A9E:  MOVLB  7
02AA0:  CLRF   x37
02AA2:  MOVLB  0
02AA4:  RCALL  2700
02AA6:  GOTO   2BB2 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02A70:  MOVFF  732,736
02A74:  MOVFF  731,735
02A78:  MOVFF  730,734
02A7C:  MOVFF  72F,733
02A80:  MOVLW  01
02A82:  MOVLB  7
02A84:  MOVWF  x37
02A86:  MOVLB  0
02A88:  RCALL  2700
02A8A:  GOTO   2B6A (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AAA:  MOVFF  726,746
02AAE:  MOVFF  725,745
02AB2:  MOVFF  724,744
02AB6:  MOVFF  723,743
02ABA:  MOVLB  7
02ABC:  CLRF   x4A
02ABE:  CLRF   x49
02AC0:  CLRF   x48
02AC2:  CLRF   x47
02AC4:  MOVLB  0
02AC6:  CALL   1CD0
02ACA:  BTFSC  FD8.2
02ACC:  BRA    2C0E
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02ACE:  MOVFF  722,73F
02AD2:  MOVFF  721,73E
02AD6:  MOVFF  720,73D
02ADA:  MOVFF  71F,73C
02ADE:  MOVFF  726,743
02AE2:  MOVFF  725,742
02AE6:  MOVFF  724,741
02AEA:  MOVFF  723,740
02AEE:  CALL   1D4A
02AF2:  MOVFF  03,72E
02AF6:  MOVFF  02,72D
02AFA:  MOVFF  01,72C
02AFE:  MOVFF  00,72B
02B02:  MOVFF  03,746
02B06:  MOVFF  02,745
02B0A:  MOVFF  01,744
02B0E:  MOVFF  00,743
02B12:  MOVLB  7
02B14:  CLRF   x4A
02B16:  CLRF   x49
02B18:  CLRF   x48
02B1A:  CLRF   x47
02B1C:  MOVLB  0
02B1E:  CALL   1CD0
02B22:  BNC   2B6C
02B24:  MOVFF  722,73F
02B28:  MOVFF  721,73E
02B2C:  MOVFF  720,73D
02B30:  MOVFF  71F,73C
02B34:  MOVFF  726,743
02B38:  MOVFF  725,742
02B3C:  MOVFF  724,741
02B40:  MOVFF  723,740
02B44:  CALL   1D4A
02B48:  MOVFF  03,72E
02B4C:  MOVFF  02,72D
02B50:  MOVFF  01,72C
02B54:  MOVFF  00,72B
02B58:  MOVFF  03,732
02B5C:  MOVFF  02,731
02B60:  MOVFF  01,730
02B64:  MOVFF  00,72F
02B68:  BRA    2A70
02B6A:  BRA    2BB2
02B6C:  MOVFF  722,73F
02B70:  MOVFF  721,73E
02B74:  MOVFF  720,73D
02B78:  MOVFF  71F,73C
02B7C:  MOVFF  726,743
02B80:  MOVFF  725,742
02B84:  MOVFF  724,741
02B88:  MOVFF  723,740
02B8C:  CALL   1D4A
02B90:  MOVFF  03,72E
02B94:  MOVFF  02,72D
02B98:  MOVFF  01,72C
02B9C:  MOVFF  00,72B
02BA0:  MOVFF  03,732
02BA4:  MOVFF  02,731
02BA8:  MOVFF  01,730
02BAC:  MOVFF  00,72F
02BB0:  BRA    2A8E
02BB2:  MOVFF  03,72A
02BB6:  MOVFF  02,729
02BBA:  MOVFF  01,728
02BBE:  MOVFF  00,727
....................       return(x-(i*y));
02BC2:  MOVFF  72A,746
02BC6:  MOVFF  729,745
02BCA:  MOVFF  728,744
02BCE:  MOVFF  727,743
02BD2:  MOVFF  726,74A
02BD6:  MOVFF  725,749
02BDA:  MOVFF  724,748
02BDE:  MOVFF  723,747
02BE2:  CALL   0D20
02BE6:  BSF    FD8.1
02BE8:  MOVFF  722,74A
02BEC:  MOVFF  721,749
02BF0:  MOVFF  720,748
02BF4:  MOVFF  71F,747
02BF8:  MOVFF  03,74E
02BFC:  MOVFF  02,74D
02C00:  MOVFF  01,74C
02C04:  MOVFF  00,74B
02C08:  CALL   0E16
02C0C:  BRA    2C0E
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C0E:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FA4:  MOVFF  726,746
02FA8:  MOVFF  725,745
02FAC:  MOVFF  724,744
02FB0:  MOVFF  723,743
02FB4:  MOVLW  3B
02FB6:  MOVLB  7
02FB8:  MOVWF  x4A
02FBA:  MOVLW  AA
02FBC:  MOVWF  x49
02FBE:  MOVLW  38
02FC0:  MOVWF  x48
02FC2:  MOVLW  7F
02FC4:  MOVWF  x47
02FC6:  MOVLB  0
02FC8:  CALL   0D20
02FCC:  MOVFF  03,746
02FD0:  MOVFF  02,745
02FD4:  MOVFF  01,744
02FD8:  MOVFF  00,743
02FDC:  CALL   26C4
02FE0:  MOVFF  01,733
....................    s = 0;
02FE4:  MOVLB  7
02FE6:  BCF    x34.0
....................    y = x;
02FE8:  MOVFF  726,72A
02FEC:  MOVFF  725,729
02FF0:  MOVFF  724,728
02FF4:  MOVFF  723,727
.................... 
....................    if (x < 0)
02FF8:  MOVFF  726,746
02FFC:  MOVFF  725,745
03000:  MOVFF  724,744
03004:  MOVFF  723,743
03008:  CLRF   x4A
0300A:  CLRF   x49
0300C:  CLRF   x48
0300E:  CLRF   x47
03010:  MOVLB  0
03012:  CALL   1CD0
03016:  BNC   3026
....................    {
....................       s = 1;
03018:  MOVLB  7
0301A:  BSF    x34.0
....................       n = -n;
0301C:  NEGF   x33
....................       y = -y;
0301E:  MOVF   x28,W
03020:  XORLW  80
03022:  MOVWF  x28
03024:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03026:  MOVLB  7
03028:  CLRF   x2E
0302A:  CLRF   x2D
0302C:  CLRF   x2C
0302E:  CLRF   x2B
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03030:  MOVLW  07
03032:  MOVWF  x36
03034:  MOVLW  2B
03036:  MOVFF  736,FEA
0303A:  MOVWF  FE9
0303C:  MOVLW  7F
0303E:  ADDWF  x33,W
03040:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03042:  MOVFF  72A,746
03046:  MOVFF  729,745
0304A:  MOVFF  728,744
0304E:  MOVFF  727,743
03052:  MOVLW  3B
03054:  MOVWF  x4A
03056:  MOVLW  AA
03058:  MOVWF  x49
0305A:  MOVLW  38
0305C:  MOVWF  x48
0305E:  MOVLW  7F
03060:  MOVWF  x47
03062:  MOVLB  0
03064:  CALL   0D20
03068:  MOVFF  03,738
0306C:  MOVFF  02,737
03070:  MOVFF  01,736
03074:  MOVFF  00,735
03078:  MOVLB  7
0307A:  CLRF   x3A
0307C:  MOVFF  733,739
03080:  BTFSC  x39.7
03082:  DECF   x3A,F
03084:  MOVLB  0
03086:  CALL   2674
0308A:  BSF    FD8.1
0308C:  MOVFF  738,74A
03090:  MOVFF  737,749
03094:  MOVFF  736,748
03098:  MOVFF  735,747
0309C:  MOVFF  03,74E
030A0:  MOVFF  02,74D
030A4:  MOVFF  01,74C
030A8:  MOVFF  00,74B
030AC:  CALL   0E16
030B0:  MOVFF  03,72A
030B4:  MOVFF  02,729
030B8:  MOVFF  01,728
030BC:  MOVFF  00,727
.................... 
....................    r = pe[0]*y + pe[1];
030C0:  MOVLW  7C
030C2:  MOVLB  7
030C4:  MOVWF  x46
030C6:  MOVLW  88
030C8:  MOVWF  x45
030CA:  MOVLW  59
030CC:  MOVWF  x44
030CE:  MOVLW  72
030D0:  MOVWF  x43
030D2:  MOVFF  72A,74A
030D6:  MOVFF  729,749
030DA:  MOVFF  728,748
030DE:  MOVFF  727,747
030E2:  MOVLB  0
030E4:  CALL   0D20
030E8:  MOVFF  03,738
030EC:  MOVFF  02,737
030F0:  MOVFF  01,736
030F4:  MOVFF  00,735
030F8:  BCF    FD8.1
030FA:  MOVFF  03,74A
030FE:  MOVFF  02,749
03102:  MOVFF  01,748
03106:  MOVFF  00,747
0310A:  MOVLW  E0
0310C:  MOVLB  7
0310E:  MOVWF  x4E
03110:  MOVLW  97
03112:  MOVWF  x4D
03114:  MOVLW  26
03116:  MOVWF  x4C
03118:  MOVLW  75
0311A:  MOVWF  x4B
0311C:  MOVLB  0
0311E:  CALL   0E16
03122:  MOVFF  03,732
03126:  MOVFF  02,731
0312A:  MOVFF  01,730
0312E:  MOVFF  00,72F
....................    r = r*y + pe[2];
03132:  MOVFF  732,746
03136:  MOVFF  731,745
0313A:  MOVFF  730,744
0313E:  MOVFF  72F,743
03142:  MOVFF  72A,74A
03146:  MOVFF  729,749
0314A:  MOVFF  728,748
0314E:  MOVFF  727,747
03152:  CALL   0D20
03156:  MOVFF  03,738
0315A:  MOVFF  02,737
0315E:  MOVFF  01,736
03162:  MOVFF  00,735
03166:  BCF    FD8.1
03168:  MOVFF  03,74A
0316C:  MOVFF  02,749
03170:  MOVFF  01,748
03174:  MOVFF  00,747
03178:  MOVLW  C4
0317A:  MOVLB  7
0317C:  MOVWF  x4E
0317E:  MOVLW  1D
03180:  MOVWF  x4D
03182:  MOVLW  1E
03184:  MOVWF  x4C
03186:  MOVLW  78
03188:  MOVWF  x4B
0318A:  MOVLB  0
0318C:  CALL   0E16
03190:  MOVFF  03,732
03194:  MOVFF  02,731
03198:  MOVFF  01,730
0319C:  MOVFF  00,72F
....................    r = r*y + pe[3];
031A0:  MOVFF  732,746
031A4:  MOVFF  731,745
031A8:  MOVFF  730,744
031AC:  MOVFF  72F,743
031B0:  MOVFF  72A,74A
031B4:  MOVFF  729,749
031B8:  MOVFF  728,748
031BC:  MOVFF  727,747
031C0:  CALL   0D20
031C4:  MOVFF  03,738
031C8:  MOVFF  02,737
031CC:  MOVFF  01,736
031D0:  MOVFF  00,735
031D4:  BCF    FD8.1
031D6:  MOVFF  03,74A
031DA:  MOVFF  02,749
031DE:  MOVFF  01,748
031E2:  MOVFF  00,747
031E6:  MOVLW  5E
031E8:  MOVLB  7
031EA:  MOVWF  x4E
031EC:  MOVLW  50
031EE:  MOVWF  x4D
031F0:  MOVLW  63
031F2:  MOVWF  x4C
031F4:  MOVLW  7A
031F6:  MOVWF  x4B
031F8:  MOVLB  0
031FA:  CALL   0E16
031FE:  MOVFF  03,732
03202:  MOVFF  02,731
03206:  MOVFF  01,730
0320A:  MOVFF  00,72F
....................    r = r*y + pe[4];
0320E:  MOVFF  732,746
03212:  MOVFF  731,745
03216:  MOVFF  730,744
0321A:  MOVFF  72F,743
0321E:  MOVFF  72A,74A
03222:  MOVFF  729,749
03226:  MOVFF  728,748
0322A:  MOVFF  727,747
0322E:  CALL   0D20
03232:  MOVFF  03,738
03236:  MOVFF  02,737
0323A:  MOVFF  01,736
0323E:  MOVFF  00,735
03242:  BCF    FD8.1
03244:  MOVFF  03,74A
03248:  MOVFF  02,749
0324C:  MOVFF  01,748
03250:  MOVFF  00,747
03254:  MOVLW  1A
03256:  MOVLB  7
03258:  MOVWF  x4E
0325A:  MOVLW  FE
0325C:  MOVWF  x4D
0325E:  MOVLW  75
03260:  MOVWF  x4C
03262:  MOVLW  7C
03264:  MOVWF  x4B
03266:  MOVLB  0
03268:  CALL   0E16
0326C:  MOVFF  03,732
03270:  MOVFF  02,731
03274:  MOVFF  01,730
03278:  MOVFF  00,72F
....................    r = r*y + pe[5];
0327C:  MOVFF  732,746
03280:  MOVFF  731,745
03284:  MOVFF  730,744
03288:  MOVFF  72F,743
0328C:  MOVFF  72A,74A
03290:  MOVFF  729,749
03294:  MOVFF  728,748
03298:  MOVFF  727,747
0329C:  CALL   0D20
032A0:  MOVFF  03,738
032A4:  MOVFF  02,737
032A8:  MOVFF  01,736
032AC:  MOVFF  00,735
032B0:  BCF    FD8.1
032B2:  MOVFF  03,74A
032B6:  MOVFF  02,749
032BA:  MOVFF  01,748
032BE:  MOVFF  00,747
032C2:  MOVLW  18
032C4:  MOVLB  7
032C6:  MOVWF  x4E
032C8:  MOVLW  72
032CA:  MOVWF  x4D
032CC:  MOVLW  31
032CE:  MOVWF  x4C
032D0:  MOVLW  7E
032D2:  MOVWF  x4B
032D4:  MOVLB  0
032D6:  CALL   0E16
032DA:  MOVFF  03,732
032DE:  MOVFF  02,731
032E2:  MOVFF  01,730
032E6:  MOVFF  00,72F
.................... 
....................    res = res*(1.0 + y*r);
032EA:  MOVFF  72A,746
032EE:  MOVFF  729,745
032F2:  MOVFF  728,744
032F6:  MOVFF  727,743
032FA:  MOVFF  732,74A
032FE:  MOVFF  731,749
03302:  MOVFF  730,748
03306:  MOVFF  72F,747
0330A:  CALL   0D20
0330E:  BCF    FD8.1
03310:  MOVLB  7
03312:  CLRF   x4A
03314:  CLRF   x49
03316:  CLRF   x48
03318:  MOVLW  7F
0331A:  MOVWF  x47
0331C:  MOVFF  03,74E
03320:  MOVFF  02,74D
03324:  MOVFF  01,74C
03328:  MOVFF  00,74B
0332C:  MOVLB  0
0332E:  CALL   0E16
03332:  MOVFF  72E,746
03336:  MOVFF  72D,745
0333A:  MOVFF  72C,744
0333E:  MOVFF  72B,743
03342:  MOVFF  03,74A
03346:  MOVFF  02,749
0334A:  MOVFF  01,748
0334E:  MOVFF  00,747
03352:  CALL   0D20
03356:  MOVFF  03,72E
0335A:  MOVFF  02,72D
0335E:  MOVFF  01,72C
03362:  MOVFF  00,72B
.................... 
....................    if (s)
03366:  MOVLB  7
03368:  BTFSS  x34.0
0336A:  BRA    339E
....................       res = 1.0/res;
0336C:  CLRF   x3F
0336E:  CLRF   x3E
03370:  CLRF   x3D
03372:  MOVLW  7F
03374:  MOVWF  x3C
03376:  MOVFF  72E,743
0337A:  MOVFF  72D,742
0337E:  MOVFF  72C,741
03382:  MOVFF  72B,740
03386:  MOVLB  0
03388:  CALL   1D4A
0338C:  MOVFF  03,72E
03390:  MOVFF  02,72D
03394:  MOVFF  01,72C
03398:  MOVFF  00,72B
0339C:  MOVLB  7
....................    return(res);
0339E:  MOVFF  72B,00
033A2:  MOVFF  72C,01
033A6:  MOVFF  72D,02
033AA:  MOVFF  72E,03
033AE:  MOVLB  0
033B0:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C10:  MOVFF  726,72A
02C14:  MOVFF  725,729
02C18:  MOVFF  724,728
02C1C:  MOVFF  723,727
.................... 
....................    if (y != 1.0)
02C20:  MOVFF  72A,746
02C24:  MOVFF  729,745
02C28:  MOVFF  728,744
02C2C:  MOVFF  727,743
02C30:  MOVLB  7
02C32:  CLRF   x4A
02C34:  CLRF   x49
02C36:  CLRF   x48
02C38:  MOVLW  7F
02C3A:  MOVWF  x47
02C3C:  MOVLB  0
02C3E:  CALL   1CD0
02C42:  BTFSC  FD8.2
02C44:  BRA    2F86
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C46:  MOVLW  07
02C48:  MOVLB  7
02C4A:  MOVWF  x39
02C4C:  MOVLW  27
02C4E:  MOVFF  739,FEA
02C52:  MOVWF  FE9
02C54:  MOVLW  7E
02C56:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02C58:  BSF    FD8.1
02C5A:  MOVFF  72A,74A
02C5E:  MOVFF  729,749
02C62:  MOVFF  728,748
02C66:  MOVFF  727,747
02C6A:  CLRF   x4E
02C6C:  CLRF   x4D
02C6E:  CLRF   x4C
02C70:  MOVLW  7F
02C72:  MOVWF  x4B
02C74:  MOVLB  0
02C76:  CALL   0E16
02C7A:  MOVFF  03,73B
02C7E:  MOVFF  02,73A
02C82:  MOVFF  01,739
02C86:  MOVFF  00,738
02C8A:  BCF    FD8.1
02C8C:  MOVFF  72A,74A
02C90:  MOVFF  729,749
02C94:  MOVFF  728,748
02C98:  MOVFF  727,747
02C9C:  MOVLB  7
02C9E:  CLRF   x4E
02CA0:  CLRF   x4D
02CA2:  CLRF   x4C
02CA4:  MOVLW  7F
02CA6:  MOVWF  x4B
02CA8:  MOVLB  0
02CAA:  CALL   0E16
02CAE:  MOVFF  73B,73F
02CB2:  MOVFF  73A,73E
02CB6:  MOVFF  739,73D
02CBA:  MOVFF  738,73C
02CBE:  MOVFF  03,743
02CC2:  MOVFF  02,742
02CC6:  MOVFF  01,741
02CCA:  MOVFF  00,740
02CCE:  CALL   1D4A
02CD2:  MOVFF  03,72A
02CD6:  MOVFF  02,729
02CDA:  MOVFF  01,728
02CDE:  MOVFF  00,727
.................... 
....................       y2=y*y;
02CE2:  MOVFF  72A,746
02CE6:  MOVFF  729,745
02CEA:  MOVFF  728,744
02CEE:  MOVFF  727,743
02CF2:  MOVFF  72A,74A
02CF6:  MOVFF  729,749
02CFA:  MOVFF  728,748
02CFE:  MOVFF  727,747
02D02:  CALL   0D20
02D06:  MOVFF  03,736
02D0A:  MOVFF  02,735
02D0E:  MOVFF  01,734
02D12:  MOVFF  00,733
.................... 
....................       res = pl[0]*y2 + pl[1];
02D16:  MOVLW  99
02D18:  MOVLB  7
02D1A:  MOVWF  x46
02D1C:  MOVLW  47
02D1E:  MOVWF  x45
02D20:  MOVLW  8A
02D22:  MOVWF  x44
02D24:  MOVLW  7F
02D26:  MOVWF  x43
02D28:  MOVFF  736,74A
02D2C:  MOVFF  735,749
02D30:  MOVFF  734,748
02D34:  MOVFF  733,747
02D38:  MOVLB  0
02D3A:  CALL   0D20
02D3E:  MOVFF  03,73B
02D42:  MOVFF  02,73A
02D46:  MOVFF  01,739
02D4A:  MOVFF  00,738
02D4E:  BCF    FD8.1
02D50:  MOVFF  03,74A
02D54:  MOVFF  02,749
02D58:  MOVFF  01,748
02D5C:  MOVFF  00,747
02D60:  MOVLB  7
02D62:  CLRF   x4E
02D64:  CLRF   x4D
02D66:  CLRF   x4C
02D68:  MOVLW  80
02D6A:  MOVWF  x4B
02D6C:  MOVLB  0
02D6E:  CALL   0E16
02D72:  MOVFF  03,72E
02D76:  MOVFF  02,72D
02D7A:  MOVFF  01,72C
02D7E:  MOVFF  00,72B
.................... 
....................       r = ql[0]*y2 + ql[1];
02D82:  MOVLW  4C
02D84:  MOVLB  7
02D86:  MOVWF  x46
02D88:  MOVLW  F3
02D8A:  MOVWF  x45
02D8C:  MOVLW  3A
02D8E:  MOVWF  x44
02D90:  MOVLW  7B
02D92:  MOVWF  x43
02D94:  MOVFF  736,74A
02D98:  MOVFF  735,749
02D9C:  MOVFF  734,748
02DA0:  MOVFF  733,747
02DA4:  MOVLB  0
02DA6:  CALL   0D20
02DAA:  MOVFF  03,73B
02DAE:  MOVFF  02,73A
02DB2:  MOVFF  01,739
02DB6:  MOVFF  00,738
02DBA:  BCF    FD8.1
02DBC:  MOVFF  03,74A
02DC0:  MOVFF  02,749
02DC4:  MOVFF  01,748
02DC8:  MOVFF  00,747
02DCC:  MOVLW  2B
02DCE:  MOVLB  7
02DD0:  MOVWF  x4E
02DD2:  MOVLW  9D
02DD4:  MOVWF  x4D
02DD6:  MOVLW  DF
02DD8:  MOVWF  x4C
02DDA:  MOVLW  7E
02DDC:  MOVWF  x4B
02DDE:  MOVLB  0
02DE0:  CALL   0E16
02DE4:  MOVFF  03,732
02DE8:  MOVFF  02,731
02DEC:  MOVFF  01,730
02DF0:  MOVFF  00,72F
....................       r = r*y2 + 1.0;
02DF4:  MOVFF  732,746
02DF8:  MOVFF  731,745
02DFC:  MOVFF  730,744
02E00:  MOVFF  72F,743
02E04:  MOVFF  736,74A
02E08:  MOVFF  735,749
02E0C:  MOVFF  734,748
02E10:  MOVFF  733,747
02E14:  CALL   0D20
02E18:  MOVFF  03,73B
02E1C:  MOVFF  02,73A
02E20:  MOVFF  01,739
02E24:  MOVFF  00,738
02E28:  BCF    FD8.1
02E2A:  MOVFF  03,74A
02E2E:  MOVFF  02,749
02E32:  MOVFF  01,748
02E36:  MOVFF  00,747
02E3A:  MOVLB  7
02E3C:  CLRF   x4E
02E3E:  CLRF   x4D
02E40:  CLRF   x4C
02E42:  MOVLW  7F
02E44:  MOVWF  x4B
02E46:  MOVLB  0
02E48:  CALL   0E16
02E4C:  MOVFF  03,732
02E50:  MOVFF  02,731
02E54:  MOVFF  01,730
02E58:  MOVFF  00,72F
.................... 
....................       res = y*res/r;
02E5C:  MOVFF  72A,746
02E60:  MOVFF  729,745
02E64:  MOVFF  728,744
02E68:  MOVFF  727,743
02E6C:  MOVFF  72E,74A
02E70:  MOVFF  72D,749
02E74:  MOVFF  72C,748
02E78:  MOVFF  72B,747
02E7C:  CALL   0D20
02E80:  MOVFF  03,73B
02E84:  MOVFF  02,73A
02E88:  MOVFF  01,739
02E8C:  MOVFF  00,738
02E90:  MOVFF  03,73F
02E94:  MOVFF  02,73E
02E98:  MOVFF  01,73D
02E9C:  MOVFF  00,73C
02EA0:  MOVFF  732,743
02EA4:  MOVFF  731,742
02EA8:  MOVFF  730,741
02EAC:  MOVFF  72F,740
02EB0:  CALL   1D4A
02EB4:  MOVFF  03,72E
02EB8:  MOVFF  02,72D
02EBC:  MOVFF  01,72C
02EC0:  MOVFF  00,72B
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02EC4:  MOVLW  07
02EC6:  MOVLB  7
02EC8:  MOVWF  x39
02ECA:  MOVLW  23
02ECC:  MOVFF  739,FEA
02ED0:  MOVWF  FE9
02ED2:  MOVLW  7E
02ED4:  SUBWF  FEF,W
02ED6:  MOVWF  x37
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02ED8:  BTFSS  x37.7
02EDA:  BRA    2F06
....................          r = -(float32)-n;
02EDC:  MOVLW  00
02EDE:  BSF    FD8.0
02EE0:  SUBFWB x37,W
02EE2:  CLRF   x3A
02EE4:  MOVWF  x39
02EE6:  BTFSC  x39.7
02EE8:  DECF   x3A,F
02EEA:  MOVLB  0
02EEC:  CALL   2674
02EF0:  MOVFF  00,72F
02EF4:  MOVF   01,W
02EF6:  XORLW  80
02EF8:  MOVLB  7
02EFA:  MOVWF  x30
02EFC:  MOVFF  02,731
02F00:  MOVFF  03,732
02F04:  BRA    2F28
....................       else
....................          r = (float32)n;
02F06:  CLRF   x3A
02F08:  MOVFF  737,739
02F0C:  BTFSC  x39.7
02F0E:  DECF   x3A,F
02F10:  MOVLB  0
02F12:  CALL   2674
02F16:  MOVFF  03,732
02F1A:  MOVFF  02,731
02F1E:  MOVFF  01,730
02F22:  MOVFF  00,72F
02F26:  MOVLB  7
.................... 
....................       res += r*LN2;
02F28:  MOVFF  732,746
02F2C:  MOVFF  731,745
02F30:  MOVFF  730,744
02F34:  MOVFF  72F,743
02F38:  MOVLW  18
02F3A:  MOVWF  x4A
02F3C:  MOVLW  72
02F3E:  MOVWF  x49
02F40:  MOVLW  31
02F42:  MOVWF  x48
02F44:  MOVLW  7E
02F46:  MOVWF  x47
02F48:  MOVLB  0
02F4A:  CALL   0D20
02F4E:  BCF    FD8.1
02F50:  MOVFF  72E,74A
02F54:  MOVFF  72D,749
02F58:  MOVFF  72C,748
02F5C:  MOVFF  72B,747
02F60:  MOVFF  03,74E
02F64:  MOVFF  02,74D
02F68:  MOVFF  01,74C
02F6C:  MOVFF  00,74B
02F70:  CALL   0E16
02F74:  MOVFF  03,72E
02F78:  MOVFF  02,72D
02F7C:  MOVFF  01,72C
02F80:  MOVFF  00,72B
....................    }
02F84:  BRA    2F92
.................... 
....................    else
....................       res = 0.0;
02F86:  MOVLB  7
02F88:  CLRF   x2E
02F8A:  CLRF   x2D
02F8C:  CLRF   x2C
02F8E:  CLRF   x2B
02F90:  MOVLB  0
.................... 
....................    return(res);
02F92:  MOVFF  72B,00
02F96:  MOVFF  72C,01
02F9A:  MOVFF  72D,02
02F9E:  MOVFF  72E,03
02FA2:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
033B2:  MOVFF  71A,746
033B6:  MOVFF  719,745
033BA:  MOVFF  718,744
033BE:  MOVFF  717,743
033C2:  MOVLB  7
033C4:  CLRF   x4A
033C6:  CLRF   x49
033C8:  CLRF   x48
033CA:  CLRF   x47
033CC:  MOVLB  0
033CE:  CALL   1CD0
033D2:  BTFSS  FD8.0
033D4:  BRA    3570
033D6:  MOVFF  71E,722
033DA:  MOVFF  71D,721
033DE:  MOVFF  71C,720
033E2:  MOVFF  71B,71F
033E6:  MOVLB  7
033E8:  CLRF   x26
033EA:  CLRF   x25
033EC:  CLRF   x24
033EE:  MOVLW  7F
033F0:  MOVWF  x23
033F2:  MOVLB  0
033F4:  CALL   2AAA
033F8:  MOVFF  03,722
033FC:  MOVFF  02,721
03400:  MOVFF  01,720
03404:  MOVFF  00,71F
03408:  MOVFF  03,746
0340C:  MOVFF  02,745
03410:  MOVFF  01,744
03414:  MOVFF  00,743
03418:  MOVLB  7
0341A:  CLRF   x4A
0341C:  CLRF   x49
0341E:  CLRF   x48
03420:  CLRF   x47
03422:  MOVLB  0
03424:  CALL   1CD0
03428:  BTFSS  FD8.2
0342A:  BRA    3570
....................       if(fmod(y, 2) == 0) {
0342C:  MOVFF  71E,722
03430:  MOVFF  71D,721
03434:  MOVFF  71C,720
03438:  MOVFF  71B,71F
0343C:  MOVLB  7
0343E:  CLRF   x26
03440:  CLRF   x25
03442:  CLRF   x24
03444:  MOVLW  80
03446:  MOVWF  x23
03448:  MOVLB  0
0344A:  CALL   2AAA
0344E:  MOVFF  03,722
03452:  MOVFF  02,721
03456:  MOVFF  01,720
0345A:  MOVFF  00,71F
0345E:  MOVFF  03,746
03462:  MOVFF  02,745
03466:  MOVFF  01,744
0346A:  MOVFF  00,743
0346E:  MOVLB  7
03470:  CLRF   x4A
03472:  CLRF   x49
03474:  CLRF   x48
03476:  CLRF   x47
03478:  MOVLB  0
0347A:  CALL   1CD0
0347E:  BNZ   34F6
....................          return (exp(log(-x) * y));
03480:  MOVLB  7
03482:  MOVF   x18,W
03484:  XORLW  80
03486:  MOVWF  x20
03488:  MOVFF  71A,726
0348C:  MOVFF  719,725
03490:  MOVWF  x24
03492:  MOVFF  717,723
03496:  MOVLB  0
03498:  CALL   2C10
0349C:  MOVFF  03,722
034A0:  MOVFF  02,721
034A4:  MOVFF  01,720
034A8:  MOVFF  00,71F
034AC:  MOVFF  03,746
034B0:  MOVFF  02,745
034B4:  MOVFF  01,744
034B8:  MOVFF  00,743
034BC:  MOVFF  71E,74A
034C0:  MOVFF  71D,749
034C4:  MOVFF  71C,748
034C8:  MOVFF  71B,747
034CC:  CALL   0D20
034D0:  MOVFF  03,722
034D4:  MOVFF  02,721
034D8:  MOVFF  01,720
034DC:  MOVFF  00,71F
034E0:  MOVFF  03,726
034E4:  MOVFF  02,725
034E8:  MOVFF  01,724
034EC:  MOVFF  00,723
034F0:  RCALL  2FA4
034F2:  BRA    36AE
....................       } else {
034F4:  BRA    356E
....................          return (-exp(log(-x) * y));
034F6:  MOVLB  7
034F8:  MOVF   x18,W
034FA:  XORLW  80
034FC:  MOVWF  x20
034FE:  MOVFF  71A,726
03502:  MOVFF  719,725
03506:  MOVWF  x24
03508:  MOVFF  717,723
0350C:  MOVLB  0
0350E:  CALL   2C10
03512:  MOVFF  03,722
03516:  MOVFF  02,721
0351A:  MOVFF  01,720
0351E:  MOVFF  00,71F
03522:  MOVFF  03,746
03526:  MOVFF  02,745
0352A:  MOVFF  01,744
0352E:  MOVFF  00,743
03532:  MOVFF  71E,74A
03536:  MOVFF  71D,749
0353A:  MOVFF  71C,748
0353E:  MOVFF  71B,747
03542:  CALL   0D20
03546:  MOVFF  03,722
0354A:  MOVFF  02,721
0354E:  MOVFF  01,720
03552:  MOVFF  00,71F
03556:  MOVFF  03,726
0355A:  MOVFF  02,725
0355E:  MOVFF  01,724
03562:  MOVFF  00,723
03566:  RCALL  2FA4
03568:  MOVLW  80
0356A:  XORWF  01,F
0356C:  BRA    36AE
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
0356E:  BRA    36AE
03570:  MOVFF  71A,746
03574:  MOVFF  719,745
03578:  MOVFF  718,744
0357C:  MOVFF  717,743
03580:  MOVLB  7
03582:  CLRF   x4A
03584:  CLRF   x49
03586:  CLRF   x48
03588:  CLRF   x47
0358A:  MOVLB  0
0358C:  CALL   1CD0
03590:  BNC   35F2
03592:  MOVFF  71E,722
03596:  MOVFF  71D,721
0359A:  MOVFF  71C,720
0359E:  MOVFF  71B,71F
035A2:  MOVLB  7
035A4:  CLRF   x26
035A6:  CLRF   x25
035A8:  CLRF   x24
035AA:  MOVLW  7F
035AC:  MOVWF  x23
035AE:  MOVLB  0
035B0:  CALL   2AAA
035B4:  MOVFF  03,722
035B8:  MOVFF  02,721
035BC:  MOVFF  01,720
035C0:  MOVFF  00,71F
035C4:  MOVFF  03,746
035C8:  MOVFF  02,745
035CC:  MOVFF  01,744
035D0:  MOVFF  00,743
035D4:  MOVLB  7
035D6:  CLRF   x4A
035D8:  CLRF   x49
035DA:  CLRF   x48
035DC:  CLRF   x47
035DE:  MOVLB  0
035E0:  CALL   1CD0
035E4:  BZ    35F2
....................       return 0;
035E6:  CLRF   00
035E8:  CLRF   01
035EA:  CLRF   02
035EC:  CLRF   03
035EE:  BRA    36AE
....................    } else {
035F0:  BRA    36AE
....................       if(x != 0 || 0 >= y) {
035F2:  MOVFF  71A,746
035F6:  MOVFF  719,745
035FA:  MOVFF  718,744
035FE:  MOVFF  717,743
03602:  MOVLB  7
03604:  CLRF   x4A
03606:  CLRF   x49
03608:  CLRF   x48
0360A:  CLRF   x47
0360C:  MOVLB  0
0360E:  CALL   1CD0
03612:  BNZ   3638
03614:  MOVFF  71E,746
03618:  MOVFF  71D,745
0361C:  MOVFF  71C,744
03620:  MOVFF  71B,743
03624:  MOVLB  7
03626:  CLRF   x4A
03628:  CLRF   x49
0362A:  CLRF   x48
0362C:  CLRF   x47
0362E:  MOVLB  0
03630:  CALL   1CD0
03634:  BC    3638
03636:  BNZ   36A6
....................          return (exp(log(x) * y));
03638:  MOVFF  71A,726
0363C:  MOVFF  719,725
03640:  MOVFF  718,724
03644:  MOVFF  717,723
03648:  CALL   2C10
0364C:  MOVFF  03,722
03650:  MOVFF  02,721
03654:  MOVFF  01,720
03658:  MOVFF  00,71F
0365C:  MOVFF  03,746
03660:  MOVFF  02,745
03664:  MOVFF  01,744
03668:  MOVFF  00,743
0366C:  MOVFF  71E,74A
03670:  MOVFF  71D,749
03674:  MOVFF  71C,748
03678:  MOVFF  71B,747
0367C:  CALL   0D20
03680:  MOVFF  03,722
03684:  MOVFF  02,721
03688:  MOVFF  01,720
0368C:  MOVFF  00,71F
03690:  MOVFF  03,726
03694:  MOVFF  02,725
03698:  MOVFF  01,724
0369C:  MOVFF  00,723
036A0:  RCALL  2FA4
036A2:  BRA    36AE
....................       } else return 0;
036A4:  BRA    36AE
036A6:  CLRF   00
036A8:  CLRF   01
036AA:  CLRF   02
036AC:  CLRF   03
....................    }
036AE:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01EA8:  MOVLB  7
01EAA:  BCF    x35.0
....................    flag = 0;
01EAC:  BCF    x35.1
....................    y = x;
01EAE:  MOVFF  728,72C
01EB2:  MOVFF  727,72B
01EB6:  MOVFF  726,72A
01EBA:  MOVFF  725,729
.................... 
....................    if (x < 0)
01EBE:  MOVFF  728,746
01EC2:  MOVFF  727,745
01EC6:  MOVFF  726,744
01ECA:  MOVFF  725,743
01ECE:  CLRF   x4A
01ED0:  CLRF   x49
01ED2:  CLRF   x48
01ED4:  CLRF   x47
01ED6:  MOVLB  0
01ED8:  RCALL  1CD0
01EDA:  BNC   1EE8
....................    {
....................       s = 1;
01EDC:  MOVLB  7
01EDE:  BSF    x35.0
....................       y = -y;
01EE0:  MOVF   x2A,W
01EE2:  XORLW  80
01EE4:  MOVWF  x2A
01EE6:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01EE8:  MOVLB  7
01EEA:  CLRF   x46
01EEC:  CLRF   x45
01EEE:  CLRF   x44
01EF0:  MOVLW  7F
01EF2:  MOVWF  x43
01EF4:  MOVFF  72C,74A
01EF8:  MOVFF  72B,749
01EFC:  MOVFF  72A,748
01F00:  MOVFF  729,747
01F04:  MOVLB  0
01F06:  RCALL  1CD0
01F08:  BNC   1F40
....................    {
....................       y = 1.0/y;
01F0A:  MOVLB  7
01F0C:  CLRF   x3F
01F0E:  CLRF   x3E
01F10:  CLRF   x3D
01F12:  MOVLW  7F
01F14:  MOVWF  x3C
01F16:  MOVFF  72C,743
01F1A:  MOVFF  72B,742
01F1E:  MOVFF  72A,741
01F22:  MOVFF  729,740
01F26:  MOVLB  0
01F28:  RCALL  1D4A
01F2A:  MOVFF  03,72C
01F2E:  MOVFF  02,72B
01F32:  MOVFF  01,72A
01F36:  MOVFF  00,729
....................       flag = 1;
01F3A:  MOVLB  7
01F3C:  BSF    x35.1
01F3E:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F40:  MOVLW  0A
01F42:  MOVLB  7
01F44:  MOVWF  x46
01F46:  MOVLW  89
01F48:  MOVWF  x45
01F4A:  MOVLW  34
01F4C:  MOVWF  x44
01F4E:  MOVLW  7C
01F50:  MOVWF  x43
01F52:  MOVFF  72C,74A
01F56:  MOVFF  72B,749
01F5A:  MOVFF  72A,748
01F5E:  MOVFF  729,747
01F62:  MOVLB  0
01F64:  CALL   0D20
01F68:  MOVFF  03,739
01F6C:  MOVFF  02,738
01F70:  MOVFF  01,737
01F74:  MOVFF  00,736
01F78:  MOVFF  03,746
01F7C:  MOVFF  02,745
01F80:  MOVFF  01,744
01F84:  MOVFF  00,743
01F88:  MOVFF  72C,74A
01F8C:  MOVFF  72B,749
01F90:  MOVFF  72A,748
01F94:  MOVFF  729,747
01F98:  CALL   0D20
01F9C:  MOVFF  03,739
01FA0:  MOVFF  02,738
01FA4:  MOVFF  01,737
01FA8:  MOVFF  00,736
01FAC:  BCF    FD8.1
01FAE:  MOVFF  03,74A
01FB2:  MOVFF  02,749
01FB6:  MOVFF  01,748
01FBA:  MOVFF  00,747
01FBE:  MOVLW  7C
01FC0:  MOVLB  7
01FC2:  MOVWF  x4E
01FC4:  MOVLW  79
01FC6:  MOVWF  x4D
01FC8:  MOVLW  35
01FCA:  MOVWF  x4C
01FCC:  MOVLW  81
01FCE:  MOVWF  x4B
01FD0:  MOVLB  0
01FD2:  CALL   0E16
01FD6:  MOVFF  03,730
01FDA:  MOVFF  02,72F
01FDE:  MOVFF  01,72E
01FE2:  MOVFF  00,72D
....................    res = res*y*y + pat[2];
01FE6:  MOVFF  730,746
01FEA:  MOVFF  72F,745
01FEE:  MOVFF  72E,744
01FF2:  MOVFF  72D,743
01FF6:  MOVFF  72C,74A
01FFA:  MOVFF  72B,749
01FFE:  MOVFF  72A,748
02002:  MOVFF  729,747
02006:  CALL   0D20
0200A:  MOVFF  03,739
0200E:  MOVFF  02,738
02012:  MOVFF  01,737
02016:  MOVFF  00,736
0201A:  MOVFF  03,746
0201E:  MOVFF  02,745
02022:  MOVFF  01,744
02026:  MOVFF  00,743
0202A:  MOVFF  72C,74A
0202E:  MOVFF  72B,749
02032:  MOVFF  72A,748
02036:  MOVFF  729,747
0203A:  CALL   0D20
0203E:  MOVFF  03,739
02042:  MOVFF  02,738
02046:  MOVFF  01,737
0204A:  MOVFF  00,736
0204E:  BCF    FD8.1
02050:  MOVFF  03,74A
02054:  MOVFF  02,749
02058:  MOVFF  01,748
0205C:  MOVFF  00,747
02060:  MOVLW  3F
02062:  MOVLB  7
02064:  MOVWF  x4E
02066:  MOVLW  02
02068:  MOVWF  x4D
0206A:  MOVLW  33
0206C:  MOVWF  x4C
0206E:  MOVLW  83
02070:  MOVWF  x4B
02072:  MOVLB  0
02074:  CALL   0E16
02078:  MOVFF  03,730
0207C:  MOVFF  02,72F
02080:  MOVFF  01,72E
02084:  MOVFF  00,72D
....................    res = res*y*y + pat[3];
02088:  MOVFF  730,746
0208C:  MOVFF  72F,745
02090:  MOVFF  72E,744
02094:  MOVFF  72D,743
02098:  MOVFF  72C,74A
0209C:  MOVFF  72B,749
020A0:  MOVFF  72A,748
020A4:  MOVFF  729,747
020A8:  CALL   0D20
020AC:  MOVFF  03,739
020B0:  MOVFF  02,738
020B4:  MOVFF  01,737
020B8:  MOVFF  00,736
020BC:  MOVFF  03,746
020C0:  MOVFF  02,745
020C4:  MOVFF  01,744
020C8:  MOVFF  00,743
020CC:  MOVFF  72C,74A
020D0:  MOVFF  72B,749
020D4:  MOVFF  72A,748
020D8:  MOVFF  729,747
020DC:  CALL   0D20
020E0:  MOVFF  03,739
020E4:  MOVFF  02,738
020E8:  MOVFF  01,737
020EC:  MOVFF  00,736
020F0:  BCF    FD8.1
020F2:  MOVFF  03,74A
020F6:  MOVFF  02,749
020FA:  MOVFF  01,748
020FE:  MOVFF  00,747
02102:  MOVLW  33
02104:  MOVLB  7
02106:  MOVWF  x4E
02108:  MOVLW  8C
0210A:  MOVWF  x4D
0210C:  MOVLW  1E
0210E:  MOVWF  x4C
02110:  MOVLW  83
02112:  MOVWF  x4B
02114:  MOVLB  0
02116:  CALL   0E16
0211A:  MOVFF  03,730
0211E:  MOVFF  02,72F
02122:  MOVFF  01,72E
02126:  MOVFF  00,72D
.................... 
....................    r = qat[0]*y*y + qat[1];
0212A:  MOVLB  7
0212C:  CLRF   x46
0212E:  CLRF   x45
02130:  CLRF   x44
02132:  MOVLW  7F
02134:  MOVWF  x43
02136:  MOVFF  72C,74A
0213A:  MOVFF  72B,749
0213E:  MOVFF  72A,748
02142:  MOVFF  729,747
02146:  MOVLB  0
02148:  CALL   0D20
0214C:  MOVFF  03,739
02150:  MOVFF  02,738
02154:  MOVFF  01,737
02158:  MOVFF  00,736
0215C:  MOVFF  03,746
02160:  MOVFF  02,745
02164:  MOVFF  01,744
02168:  MOVFF  00,743
0216C:  MOVFF  72C,74A
02170:  MOVFF  72B,749
02174:  MOVFF  72A,748
02178:  MOVFF  729,747
0217C:  CALL   0D20
02180:  MOVFF  03,739
02184:  MOVFF  02,738
02188:  MOVFF  01,737
0218C:  MOVFF  00,736
02190:  BCF    FD8.1
02192:  MOVFF  03,74A
02196:  MOVFF  02,749
0219A:  MOVFF  01,748
0219E:  MOVFF  00,747
021A2:  MOVLW  1B
021A4:  MOVLB  7
021A6:  MOVWF  x4E
021A8:  MOVLW  E4
021AA:  MOVWF  x4D
021AC:  MOVLW  35
021AE:  MOVWF  x4C
021B0:  MOVLW  82
021B2:  MOVWF  x4B
021B4:  MOVLB  0
021B6:  CALL   0E16
021BA:  MOVFF  03,734
021BE:  MOVFF  02,733
021C2:  MOVFF  01,732
021C6:  MOVFF  00,731
....................    r = r*y*y + qat[2];
021CA:  MOVFF  734,746
021CE:  MOVFF  733,745
021D2:  MOVFF  732,744
021D6:  MOVFF  731,743
021DA:  MOVFF  72C,74A
021DE:  MOVFF  72B,749
021E2:  MOVFF  72A,748
021E6:  MOVFF  729,747
021EA:  CALL   0D20
021EE:  MOVFF  03,739
021F2:  MOVFF  02,738
021F6:  MOVFF  01,737
021FA:  MOVFF  00,736
021FE:  MOVFF  03,746
02202:  MOVFF  02,745
02206:  MOVFF  01,744
0220A:  MOVFF  00,743
0220E:  MOVFF  72C,74A
02212:  MOVFF  72B,749
02216:  MOVFF  72A,748
0221A:  MOVFF  729,747
0221E:  CALL   0D20
02222:  MOVFF  03,739
02226:  MOVFF  02,738
0222A:  MOVFF  01,737
0222E:  MOVFF  00,736
02232:  BCF    FD8.1
02234:  MOVFF  03,74A
02238:  MOVFF  02,749
0223C:  MOVFF  01,748
02240:  MOVFF  00,747
02244:  MOVLW  A4
02246:  MOVLB  7
02248:  MOVWF  x4E
0224A:  MOVLW  DB
0224C:  MOVWF  x4D
0224E:  MOVLW  67
02250:  MOVWF  x4C
02252:  MOVLW  83
02254:  MOVWF  x4B
02256:  MOVLB  0
02258:  CALL   0E16
0225C:  MOVFF  03,734
02260:  MOVFF  02,733
02264:  MOVFF  01,732
02268:  MOVFF  00,731
....................    r = r*y*y + qat[3];
0226C:  MOVFF  734,746
02270:  MOVFF  733,745
02274:  MOVFF  732,744
02278:  MOVFF  731,743
0227C:  MOVFF  72C,74A
02280:  MOVFF  72B,749
02284:  MOVFF  72A,748
02288:  MOVFF  729,747
0228C:  CALL   0D20
02290:  MOVFF  03,739
02294:  MOVFF  02,738
02298:  MOVFF  01,737
0229C:  MOVFF  00,736
022A0:  MOVFF  03,746
022A4:  MOVFF  02,745
022A8:  MOVFF  01,744
022AC:  MOVFF  00,743
022B0:  MOVFF  72C,74A
022B4:  MOVFF  72B,749
022B8:  MOVFF  72A,748
022BC:  MOVFF  729,747
022C0:  CALL   0D20
022C4:  MOVFF  03,739
022C8:  MOVFF  02,738
022CC:  MOVFF  01,737
022D0:  MOVFF  00,736
022D4:  BCF    FD8.1
022D6:  MOVFF  03,74A
022DA:  MOVFF  02,749
022DE:  MOVFF  01,748
022E2:  MOVFF  00,747
022E6:  MOVLW  33
022E8:  MOVLB  7
022EA:  MOVWF  x4E
022EC:  MOVLW  8C
022EE:  MOVWF  x4D
022F0:  MOVLW  1E
022F2:  MOVWF  x4C
022F4:  MOVLW  83
022F6:  MOVWF  x4B
022F8:  MOVLB  0
022FA:  CALL   0E16
022FE:  MOVFF  03,734
02302:  MOVFF  02,733
02306:  MOVFF  01,732
0230A:  MOVFF  00,731
.................... 
....................    res = y*res/r;
0230E:  MOVFF  72C,746
02312:  MOVFF  72B,745
02316:  MOVFF  72A,744
0231A:  MOVFF  729,743
0231E:  MOVFF  730,74A
02322:  MOVFF  72F,749
02326:  MOVFF  72E,748
0232A:  MOVFF  72D,747
0232E:  CALL   0D20
02332:  MOVFF  03,739
02336:  MOVFF  02,738
0233A:  MOVFF  01,737
0233E:  MOVFF  00,736
02342:  MOVFF  03,73F
02346:  MOVFF  02,73E
0234A:  MOVFF  01,73D
0234E:  MOVFF  00,73C
02352:  MOVFF  734,743
02356:  MOVFF  733,742
0235A:  MOVFF  732,741
0235E:  MOVFF  731,740
02362:  RCALL  1D4A
02364:  MOVFF  03,730
02368:  MOVFF  02,72F
0236C:  MOVFF  01,72E
02370:  MOVFF  00,72D
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
02374:  MOVLB  7
02376:  BTFSS  x35.1
02378:  BRA    23B4
....................       res = PI_DIV_BY_TWO - res;
0237A:  BSF    FD8.1
0237C:  MOVLW  DB
0237E:  MOVWF  x4A
02380:  MOVLW  0F
02382:  MOVWF  x49
02384:  MOVLW  49
02386:  MOVWF  x48
02388:  MOVLW  7F
0238A:  MOVWF  x47
0238C:  MOVFF  730,74E
02390:  MOVFF  72F,74D
02394:  MOVFF  72E,74C
02398:  MOVFF  72D,74B
0239C:  MOVLB  0
0239E:  CALL   0E16
023A2:  MOVFF  03,730
023A6:  MOVFF  02,72F
023AA:  MOVFF  01,72E
023AE:  MOVFF  00,72D
023B2:  MOVLB  7
....................    if (s)
023B4:  BTFSS  x35.0
023B6:  BRA    23BE
....................       res = -res;
023B8:  MOVF   x2E,W
023BA:  XORLW  80
023BC:  MOVWF  x2E
.................... 
....................    return(res);
023BE:  MOVFF  72D,00
023C2:  MOVFF  72E,01
023C6:  MOVFF  72F,02
023CA:  MOVFF  730,03
023CE:  MOVLB  0
023D0:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
023D2:  MOVLB  7
023D4:  BCF    x23.0
....................    quad=0; //quadrant
023D6:  CLRF   x24
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
023D8:  MOVFF  71A,746
023DC:  MOVFF  719,745
023E0:  MOVFF  718,744
023E4:  MOVFF  717,743
023E8:  CLRF   x4A
023EA:  CLRF   x49
023EC:  CLRF   x48
023EE:  CLRF   x47
023F0:  MOVLB  0
023F2:  RCALL  1CD0
023F4:  BC    23F8
023F6:  BNZ   2422
023F8:  MOVFF  71E,746
023FC:  MOVFF  71D,745
02400:  MOVFF  71C,744
02404:  MOVFF  71B,743
02408:  MOVLB  7
0240A:  CLRF   x4A
0240C:  CLRF   x49
0240E:  CLRF   x48
02410:  CLRF   x47
02412:  MOVLB  0
02414:  RCALL  1CD0
02416:  BC    241A
02418:  BNZ   241E
0241A:  MOVLW  03
0241C:  BRA    2420
0241E:  MOVLW  04
02420:  BRA    2448
02422:  MOVFF  71E,746
02426:  MOVFF  71D,745
0242A:  MOVFF  71C,744
0242E:  MOVFF  71B,743
02432:  MOVLB  7
02434:  CLRF   x4A
02436:  CLRF   x49
02438:  CLRF   x48
0243A:  CLRF   x47
0243C:  MOVLB  0
0243E:  RCALL  1CD0
02440:  BNC   2446
02442:  MOVLW  02
02444:  BRA    2448
02446:  MOVLW  01
02448:  MOVLB  7
0244A:  MOVWF  x24
....................    if(y<0.0)
0244C:  MOVFF  71A,746
02450:  MOVFF  719,745
02454:  MOVFF  718,744
02458:  MOVFF  717,743
0245C:  CLRF   x4A
0245E:  CLRF   x49
02460:  CLRF   x48
02462:  CLRF   x47
02464:  MOVLB  0
02466:  RCALL  1CD0
02468:  BNC   2476
....................    {
....................       sign=1;
0246A:  MOVLB  7
0246C:  BSF    x23.0
....................       y=-y;
0246E:  MOVF   x18,W
02470:  XORLW  80
02472:  MOVWF  x18
02474:  MOVLB  0
....................    }
....................    if(x<0.0)
02476:  MOVFF  71E,746
0247A:  MOVFF  71D,745
0247E:  MOVFF  71C,744
02482:  MOVFF  71B,743
02486:  MOVLB  7
02488:  CLRF   x4A
0248A:  CLRF   x49
0248C:  CLRF   x48
0248E:  CLRF   x47
02490:  MOVLB  0
02492:  RCALL  1CD0
02494:  BNC   24A0
....................    {
....................       x=-x;
02496:  MOVLB  7
02498:  MOVF   x1C,W
0249A:  XORLW  80
0249C:  MOVWF  x1C
0249E:  MOVLB  0
....................    }
....................    if (x==0.0)
024A0:  MOVFF  71E,746
024A4:  MOVFF  71D,745
024A8:  MOVFF  71C,744
024AC:  MOVFF  71B,743
024B0:  MOVLB  7
024B2:  CLRF   x4A
024B4:  CLRF   x49
024B6:  CLRF   x48
024B8:  CLRF   x47
024BA:  MOVLB  0
024BC:  RCALL  1CD0
024BE:  BNZ   2514
....................    {
....................       if(y==0.0)
024C0:  MOVFF  71A,746
024C4:  MOVFF  719,745
024C8:  MOVFF  718,744
024CC:  MOVFF  717,743
024D0:  MOVLB  7
024D2:  CLRF   x4A
024D4:  CLRF   x49
024D6:  CLRF   x48
024D8:  CLRF   x47
024DA:  MOVLB  0
024DC:  CALL   1CD0
024E0:  BNZ   24E4
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
024E2:  BRA    2512
....................       else
....................       {
....................          if(sign)
024E4:  MOVLB  7
024E6:  BTFSS  x23.0
024E8:  BRA    24FE
....................          {
....................          return (-(PI_DIV_BY_TWO));
024EA:  MOVLW  7F
024EC:  MOVWF  00
024EE:  MOVLW  C9
024F0:  MOVWF  01
024F2:  MOVLW  0F
024F4:  MOVWF  02
024F6:  MOVLW  DB
024F8:  MOVWF  03
024FA:  BRA    264C
....................          }
024FC:  BRA    2510
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
024FE:  MOVLW  7F
02500:  MOVWF  00
02502:  MOVLW  49
02504:  MOVWF  01
02506:  MOVLW  0F
02508:  MOVWF  02
0250A:  MOVLW  DB
0250C:  MOVWF  03
0250E:  BRA    264C
02510:  MOVLB  0
....................          }
....................       }
....................    }
02512:  BRA    264A
....................    else
....................    {
....................       z=y/x;
02514:  MOVFF  71A,73F
02518:  MOVFF  719,73E
0251C:  MOVFF  718,73D
02520:  MOVFF  717,73C
02524:  MOVFF  71E,743
02528:  MOVFF  71D,742
0252C:  MOVFF  71C,741
02530:  MOVFF  71B,740
02534:  RCALL  1D4A
02536:  MOVFF  03,722
0253A:  MOVFF  02,721
0253E:  MOVFF  01,720
02542:  MOVFF  00,71F
....................       switch(quad)
02546:  MOVLW  01
02548:  MOVLB  7
0254A:  SUBWF  x24,W
0254C:  ADDLW  FC
0254E:  BTFSC  FD8.0
02550:  BRA    264C
02552:  ADDLW  04
02554:  MOVLB  0
02556:  GOTO   2652
....................       {
....................          case 1:
....................          {
....................             return atan(z);
0255A:  MOVFF  722,728
0255E:  MOVFF  721,727
02562:  MOVFF  720,726
02566:  MOVFF  71F,725
0256A:  RCALL  1EA8
0256C:  MOVLB  7
0256E:  BRA    264C
....................             break;
02570:  BRA    264C
02572:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
02574:  MOVFF  722,728
02578:  MOVFF  721,727
0257C:  MOVFF  720,726
02580:  MOVFF  71F,725
02584:  RCALL  1EA8
02586:  MOVFF  FEA,726
0258A:  MOVFF  FE9,725
0258E:  BSF    FD8.1
02590:  MOVLW  DB
02592:  MOVLB  7
02594:  MOVWF  x4A
02596:  MOVLW  0F
02598:  MOVWF  x49
0259A:  MOVLW  49
0259C:  MOVWF  x48
0259E:  MOVLW  80
025A0:  MOVWF  x47
025A2:  MOVFF  03,74E
025A6:  MOVFF  02,74D
025AA:  MOVFF  01,74C
025AE:  MOVFF  00,74B
025B2:  MOVLB  0
025B4:  CALL   0E16
025B8:  MOVFF  726,FEA
025BC:  MOVFF  725,FE9
025C0:  MOVLB  7
025C2:  BRA    264C
....................             break;
025C4:  BRA    264C
025C6:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
025C8:  MOVFF  722,728
025CC:  MOVFF  721,727
025D0:  MOVFF  720,726
025D4:  MOVFF  71F,725
025D8:  RCALL  1EA8
025DA:  MOVFF  03,728
025DE:  MOVFF  02,727
025E2:  MOVFF  01,726
025E6:  MOVFF  00,725
025EA:  MOVFF  FEA,72A
025EE:  MOVFF  FE9,729
025F2:  BSF    FD8.1
025F4:  MOVFF  03,74A
025F8:  MOVFF  02,749
025FC:  MOVFF  01,748
02600:  MOVFF  00,747
02604:  MOVLW  DB
02606:  MOVLB  7
02608:  MOVWF  x4E
0260A:  MOVLW  0F
0260C:  MOVWF  x4D
0260E:  MOVLW  49
02610:  MOVWF  x4C
02612:  MOVLW  80
02614:  MOVWF  x4B
02616:  MOVLB  0
02618:  CALL   0E16
0261C:  MOVFF  72A,FEA
02620:  MOVFF  729,FE9
02624:  MOVLB  7
02626:  BRA    264C
....................             break;
02628:  BRA    264C
0262A:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
0262C:  MOVFF  722,728
02630:  MOVFF  721,727
02634:  MOVFF  720,726
02638:  MOVFF  71F,725
0263C:  RCALL  1EA8
0263E:  MOVLW  80
02640:  XORWF  01,F
02642:  MOVLB  7
02644:  BRA    264C
....................             break;
02646:  BRA    264C
02648:  MOVLB  0
0264A:  MOVLB  7
....................          }
....................       }
....................    }
0264C:  MOVLB  0
0264E:  GOTO   3DA2 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
00876:  MOVFF  723,FEA
0087A:  MOVLB  7
0087C:  MOVFF  722,FE9
00880:  CLRF   x30
00882:  MOVFF  FEF,72F
00886:  CLRF   x32
00888:  MOVLW  04
0088A:  MOVWF  x31
0088C:  MOVLB  0
0088E:  RCALL  0828
00890:  MOVF   01,W
00892:  MOVLB  7
00894:  ADDWF  x20,W
00896:  MOVWF  FE9
00898:  MOVF   x21,W
0089A:  ADDWFC 02,W
0089C:  MOVWF  FEA
0089E:  MOVFF  724,FEF
008A2:  MOVFF  725,FEC
008A6:  MOVFF  726,FEC
008AA:  MOVFF  727,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
008AE:  MOVFF  723,729
008B2:  MOVFF  723,FEA
008B6:  MOVFF  722,FE9
008BA:  MOVLW  01
008BC:  ADDWF  FEF,W
008BE:  MOVWF  x2B
008C0:  MOVWF  x2F
008C2:  MOVLW  05
008C4:  MOVWF  x30
008C6:  MOVLB  0
008C8:  RCALL  084A
008CA:  MOVLB  7
008CC:  MOVFF  729,FEA
008D0:  MOVFF  722,FE9
008D4:  MOVFF  00,FEF
008D8:  MOVLB  0
008DA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
0108E:  MOVLB  F
01090:  BTFSC  x5B.0
01092:  BRA    15DE
....................       switch (state)
01094:  MOVLB  1
01096:  MOVF   xE4,W
01098:  ADDLW  F9
0109A:  BTFSC  FD8.0
0109C:  BRA    15DC
0109E:  ADDLW  07
010A0:  MOVLB  0
010A2:  GOTO   15E4
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
010A6:  MOVLB  F
010A8:  BTFSC  x5B.0
010AA:  BRA    10A8
010AC:  MOVFF  F5F,02
010B0:  MOVFF  F5E,01
010B4:  MOVFF  02,6EF
010B8:  MOVFF  01,6EE
010BC:  MOVFF  02,748
010C0:  MOVFF  01,747
010C4:  MOVLB  0
010C6:  RCALL  0CEA
010C8:  MOVFF  03,746
010CC:  MOVFF  02,745
010D0:  MOVFF  01,744
010D4:  MOVFF  00,743
010D8:  MOVFF  B9,74A
010DC:  MOVFF  B8,749
010E0:  MOVFF  B7,748
010E4:  MOVFF  B6,747
010E8:  RCALL  0D20
010EA:  MOVFF  03,6F1
010EE:  MOVFF  02,6F0
010F2:  MOVFF  01,6EF
010F6:  MOVFF  00,6EE
010FA:  BCF    FD8.1
010FC:  MOVFF  03,74A
01100:  MOVFF  02,749
01104:  MOVFF  01,748
01108:  MOVFF  00,747
0110C:  MOVFF  B5,74E
01110:  MOVFF  B4,74D
01114:  MOVFF  B3,74C
01118:  MOVFF  B2,74B
0111C:  RCALL  0E16
0111E:  MOVFF  03,EE
01122:  MOVFF  02,ED
01126:  MOVFF  01,EC
0112A:  MOVFF  00,EB
....................             set_adc_channel(vMon200);
0112E:  MOVLB  F
01130:  MOVF   x5A,W
01132:  ANDLW  3F
01134:  MOVWF  01
01136:  MOVLW  10
01138:  MOVWF  x5A
0113A:  BTFSS  x5B.7
0113C:  BRA    114C
0113E:  MOVF   01,W
01140:  SUBLW  10
01142:  BZ    114C
01144:  BSF    x5B.0
01146:  NOP   
01148:  BTFSC  x5B.0
0114A:  BRA    1148
....................             delay_ms(10);
0114C:  MOVLW  0A
0114E:  MOVLB  6
01150:  MOVWF  xF4
01152:  MOVLB  0
01154:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
01158:  MOVLB  F
0115A:  BSF    x5B.0
0115C:  NOP   
....................             state = 1;
0115E:  MOVLW  01
01160:  MOVLB  1
01162:  MOVWF  xE4
....................          break;
01164:  BRA    15DC
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01166:  MOVLB  F
01168:  BTFSC  x5B.0
0116A:  BRA    1168
0116C:  MOVFF  F5F,02
01170:  MOVFF  F5E,01
01174:  MOVFF  02,6EF
01178:  MOVFF  01,6EE
0117C:  MOVFF  02,748
01180:  MOVFF  01,747
01184:  MOVLB  0
01186:  RCALL  0CEA
01188:  MOVFF  03,746
0118C:  MOVFF  02,745
01190:  MOVFF  01,744
01194:  MOVFF  00,743
01198:  MOVFF  C1,74A
0119C:  MOVFF  C0,749
011A0:  MOVFF  BF,748
011A4:  MOVFF  BE,747
011A8:  RCALL  0D20
011AA:  MOVFF  03,6F1
011AE:  MOVFF  02,6F0
011B2:  MOVFF  01,6EF
011B6:  MOVFF  00,6EE
011BA:  BCF    FD8.1
011BC:  MOVFF  03,74A
011C0:  MOVFF  02,749
011C4:  MOVFF  01,748
011C8:  MOVFF  00,747
011CC:  MOVFF  BD,74E
011D0:  MOVFF  BC,74D
011D4:  MOVFF  BB,74C
011D8:  MOVFF  BA,74B
011DC:  RCALL  0E16
011DE:  MOVFF  03,F2
011E2:  MOVFF  02,F1
011E6:  MOVFF  01,F0
011EA:  MOVFF  00,EF
....................             set_adc_channel(vMon5V6);
011EE:  MOVLB  F
011F0:  MOVF   x5A,W
011F2:  ANDLW  3F
011F4:  MOVWF  01
011F6:  MOVLW  18
011F8:  MOVWF  x5A
011FA:  BTFSS  x5B.7
011FC:  BRA    120C
011FE:  MOVF   01,W
01200:  SUBLW  18
01202:  BZ    120C
01204:  BSF    x5B.0
01206:  NOP   
01208:  BTFSC  x5B.0
0120A:  BRA    1208
....................             delay_ms(10);
0120C:  MOVLW  0A
0120E:  MOVLB  6
01210:  MOVWF  xF4
01212:  MOVLB  0
01214:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
01218:  MOVLB  F
0121A:  BSF    x5B.0
0121C:  NOP   
....................             state = 2;
0121E:  MOVLW  02
01220:  MOVLB  1
01222:  MOVWF  xE4
....................          break;
01224:  BRA    15DC
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01226:  MOVLB  F
01228:  BTFSC  x5B.0
0122A:  BRA    1228
0122C:  MOVFF  F5F,02
01230:  MOVFF  F5E,01
01234:  MOVFF  02,6EF
01238:  MOVFF  01,6EE
0123C:  MOVFF  02,748
01240:  MOVFF  01,747
01244:  MOVLB  0
01246:  RCALL  0CEA
01248:  MOVFF  03,746
0124C:  MOVFF  02,745
01250:  MOVFF  01,744
01254:  MOVFF  00,743
01258:  MOVFF  C9,74A
0125C:  MOVFF  C8,749
01260:  MOVFF  C7,748
01264:  MOVFF  C6,747
01268:  RCALL  0D20
0126A:  MOVFF  03,6F1
0126E:  MOVFF  02,6F0
01272:  MOVFF  01,6EF
01276:  MOVFF  00,6EE
0127A:  BCF    FD8.1
0127C:  MOVFF  03,74A
01280:  MOVFF  02,749
01284:  MOVFF  01,748
01288:  MOVFF  00,747
0128C:  MOVFF  C5,74E
01290:  MOVFF  C4,74D
01294:  MOVFF  C3,74C
01298:  MOVFF  C2,74B
0129C:  RCALL  0E16
0129E:  MOVFF  03,F6
012A2:  MOVFF  02,F5
012A6:  MOVFF  01,F4
012AA:  MOVFF  00,F3
....................             set_adc_channel(vMon5VA);
012AE:  MOVLB  F
012B0:  MOVF   x5A,W
012B2:  ANDLW  3F
012B4:  MOVWF  01
012B6:  MOVLW  19
012B8:  MOVWF  x5A
012BA:  BTFSS  x5B.7
012BC:  BRA    12CC
012BE:  MOVF   01,W
012C0:  SUBLW  19
012C2:  BZ    12CC
012C4:  BSF    x5B.0
012C6:  NOP   
012C8:  BTFSC  x5B.0
012CA:  BRA    12C8
....................             delay_ms(10);
012CC:  MOVLW  0A
012CE:  MOVLB  6
012D0:  MOVWF  xF4
012D2:  MOVLB  0
012D4:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
012D8:  MOVLB  F
012DA:  BSF    x5B.0
012DC:  NOP   
....................             state = 3;
012DE:  MOVLW  03
012E0:  MOVLB  1
012E2:  MOVWF  xE4
....................          break;
012E4:  BRA    15DC
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
012E6:  MOVLB  F
012E8:  BTFSC  x5B.0
012EA:  BRA    12E8
012EC:  MOVFF  F5F,02
012F0:  MOVFF  F5E,01
012F4:  MOVFF  02,6EF
012F8:  MOVFF  01,6EE
012FC:  MOVFF  02,748
01300:  MOVFF  01,747
01304:  MOVLB  0
01306:  RCALL  0CEA
01308:  MOVFF  03,746
0130C:  MOVFF  02,745
01310:  MOVFF  01,744
01314:  MOVFF  00,743
01318:  MOVFF  D1,74A
0131C:  MOVFF  D0,749
01320:  MOVFF  CF,748
01324:  MOVFF  CE,747
01328:  RCALL  0D20
0132A:  MOVFF  03,6F1
0132E:  MOVFF  02,6F0
01332:  MOVFF  01,6EF
01336:  MOVFF  00,6EE
0133A:  BCF    FD8.1
0133C:  MOVFF  03,74A
01340:  MOVFF  02,749
01344:  MOVFF  01,748
01348:  MOVFF  00,747
0134C:  MOVFF  CD,74E
01350:  MOVFF  CC,74D
01354:  MOVFF  CB,74C
01358:  MOVFF  CA,74B
0135C:  RCALL  0E16
0135E:  MOVFF  03,FA
01362:  MOVFF  02,F9
01366:  MOVFF  01,F8
0136A:  MOVFF  00,F7
....................             set_adc_channel(vMon3V6X);
0136E:  MOVLB  F
01370:  MOVF   x5A,W
01372:  ANDLW  3F
01374:  MOVWF  01
01376:  MOVLW  11
01378:  MOVWF  x5A
0137A:  BTFSS  x5B.7
0137C:  BRA    138C
0137E:  MOVF   01,W
01380:  SUBLW  11
01382:  BZ    138C
01384:  BSF    x5B.0
01386:  NOP   
01388:  BTFSC  x5B.0
0138A:  BRA    1388
....................             delay_ms(10);
0138C:  MOVLW  0A
0138E:  MOVLB  6
01390:  MOVWF  xF4
01392:  MOVLB  0
01394:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
01398:  MOVLB  F
0139A:  BSF    x5B.0
0139C:  NOP   
....................             state = 4;
0139E:  MOVLW  04
013A0:  MOVLB  1
013A2:  MOVWF  xE4
....................          break;
013A4:  BRA    15DC
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
013A6:  MOVLB  F
013A8:  BTFSC  x5B.0
013AA:  BRA    13A8
013AC:  MOVFF  F5F,02
013B0:  MOVFF  F5E,01
013B4:  MOVFF  02,6EF
013B8:  MOVFF  01,6EE
013BC:  MOVFF  02,748
013C0:  MOVFF  01,747
013C4:  MOVLB  0
013C6:  RCALL  0CEA
013C8:  MOVFF  03,746
013CC:  MOVFF  02,745
013D0:  MOVFF  01,744
013D4:  MOVFF  00,743
013D8:  MOVFF  D9,74A
013DC:  MOVFF  D8,749
013E0:  MOVFF  D7,748
013E4:  MOVFF  D6,747
013E8:  RCALL  0D20
013EA:  MOVFF  03,6F1
013EE:  MOVFF  02,6F0
013F2:  MOVFF  01,6EF
013F6:  MOVFF  00,6EE
013FA:  BCF    FD8.1
013FC:  MOVFF  03,74A
01400:  MOVFF  02,749
01404:  MOVFF  01,748
01408:  MOVFF  00,747
0140C:  MOVFF  D5,74E
01410:  MOVFF  D4,74D
01414:  MOVFF  D3,74C
01418:  MOVFF  D2,74B
0141C:  RCALL  0E16
0141E:  MOVFF  03,FE
01422:  MOVFF  02,FD
01426:  MOVFF  01,FC
0142A:  MOVFF  00,FB
....................             set_adc_channel(vMon3V3A);
0142E:  MOVLB  F
01430:  MOVF   x5A,W
01432:  ANDLW  3F
01434:  MOVWF  01
01436:  MOVLW  1B
01438:  MOVWF  x5A
0143A:  BTFSS  x5B.7
0143C:  BRA    144C
0143E:  MOVF   01,W
01440:  SUBLW  1B
01442:  BZ    144C
01444:  BSF    x5B.0
01446:  NOP   
01448:  BTFSC  x5B.0
0144A:  BRA    1448
....................             delay_ms(10);
0144C:  MOVLW  0A
0144E:  MOVLB  6
01450:  MOVWF  xF4
01452:  MOVLB  0
01454:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
01458:  MOVLB  F
0145A:  BSF    x5B.0
0145C:  NOP   
....................             state = 5;
0145E:  MOVLW  05
01460:  MOVLB  1
01462:  MOVWF  xE4
....................          break;
01464:  BRA    15DC
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01466:  MOVLB  F
01468:  BTFSC  x5B.0
0146A:  BRA    1468
0146C:  MOVFF  F5F,02
01470:  MOVFF  F5E,01
01474:  MOVFF  02,6EF
01478:  MOVFF  01,6EE
0147C:  MOVFF  02,748
01480:  MOVFF  01,747
01484:  MOVLB  0
01486:  RCALL  0CEA
01488:  MOVFF  03,746
0148C:  MOVFF  02,745
01490:  MOVFF  01,744
01494:  MOVFF  00,743
01498:  MOVFF  E1,74A
0149C:  MOVFF  E0,749
014A0:  MOVFF  DF,748
014A4:  MOVFF  DE,747
014A8:  RCALL  0D20
014AA:  MOVFF  03,6F1
014AE:  MOVFF  02,6F0
014B2:  MOVFF  01,6EF
014B6:  MOVFF  00,6EE
014BA:  BCF    FD8.1
014BC:  MOVFF  03,74A
014C0:  MOVFF  02,749
014C4:  MOVFF  01,748
014C8:  MOVFF  00,747
014CC:  MOVFF  DD,74E
014D0:  MOVFF  DC,74D
014D4:  MOVFF  DB,74C
014D8:  MOVFF  DA,74B
014DC:  RCALL  0E16
014DE:  MOVFF  03,102
014E2:  MOVFF  02,101
014E6:  MOVFF  01,100
014EA:  MOVFF  00,FF
....................             set_adc_channel(vMon3V3D);
014EE:  MOVLB  F
014F0:  MOVF   x5A,W
014F2:  ANDLW  3F
014F4:  MOVWF  01
014F6:  MOVLW  1A
014F8:  MOVWF  x5A
014FA:  BTFSS  x5B.7
014FC:  BRA    150C
014FE:  MOVF   01,W
01500:  SUBLW  1A
01502:  BZ    150C
01504:  BSF    x5B.0
01506:  NOP   
01508:  BTFSC  x5B.0
0150A:  BRA    1508
....................             delay_ms(10);
0150C:  MOVLW  0A
0150E:  MOVLB  6
01510:  MOVWF  xF4
01512:  MOVLB  0
01514:  CALL   03EE
....................             read_adc(ADC_START_ONLY);
01518:  MOVLB  F
0151A:  BSF    x5B.0
0151C:  NOP   
....................             state = 6;
0151E:  MOVLW  06
01520:  MOVLB  1
01522:  MOVWF  xE4
....................          break;
01524:  BRA    15DC
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01526:  MOVLB  F
01528:  BTFSC  x5B.0
0152A:  BRA    1528
0152C:  MOVFF  F5F,02
01530:  MOVFF  F5E,01
01534:  MOVFF  02,6EF
01538:  MOVFF  01,6EE
0153C:  MOVFF  02,748
01540:  MOVFF  01,747
01544:  MOVLB  0
01546:  CALL   0CEA
0154A:  MOVFF  03,746
0154E:  MOVFF  02,745
01552:  MOVFF  01,744
01556:  MOVFF  00,743
0155A:  MOVFF  E9,74A
0155E:  MOVFF  E8,749
01562:  MOVFF  E7,748
01566:  MOVFF  E6,747
0156A:  CALL   0D20
0156E:  MOVFF  03,6F1
01572:  MOVFF  02,6F0
01576:  MOVFF  01,6EF
0157A:  MOVFF  00,6EE
0157E:  BCF    FD8.1
01580:  MOVFF  03,74A
01584:  MOVFF  02,749
01588:  MOVFF  01,748
0158C:  MOVFF  00,747
01590:  MOVFF  E5,74E
01594:  MOVFF  E4,74D
01598:  MOVFF  E3,74C
0159C:  MOVFF  E2,74B
015A0:  RCALL  0E16
015A2:  MOVFF  03,106
015A6:  MOVFF  02,105
015AA:  MOVFF  01,104
015AE:  MOVFF  00,103
....................             set_adc_channel(vMonN15);
015B2:  MOVLB  F
015B4:  MOVF   x5A,W
015B6:  ANDLW  3F
015B8:  MOVWF  01
015BA:  MOVLW  06
015BC:  MOVWF  x5A
015BE:  BTFSS  x5B.7
015C0:  BRA    15D0
015C2:  MOVF   01,W
015C4:  SUBLW  06
015C6:  BZ    15D0
015C8:  BSF    x5B.0
015CA:  NOP   
015CC:  BTFSC  x5B.0
015CE:  BRA    15CC
....................             read_adc(ADC_START_ONLY);
015D0:  BSF    x5B.0
015D2:  NOP   
....................             state = 0;
015D4:  MOVLB  1
015D6:  CLRF   xE4
....................          break;   
015D8:  BRA    15DC
015DA:  MOVLB  1
015DC:  MOVLB  F
....................       }
....................    }
015DE:  MOVLB  0
015E0:  GOTO   A5C6 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
036B0:  MOVLB  6
036B2:  MOVF   xF6,W
036B4:  MULLW  2D
036B6:  MOVF   FF3,W
036B8:  MOVLB  7
036BA:  CLRF   x01
036BC:  MOVWF  x00
036BE:  MOVLW  10
036C0:  ADDWF  x00,W
036C2:  MOVWF  01
036C4:  MOVLW  00
036C6:  ADDWFC x01,W
036C8:  MOVWF  03
036CA:  MOVF   01,W
036CC:  ADDLW  07
036CE:  MOVWF  01
036D0:  MOVLW  01
036D2:  ADDWFC 03,F
036D4:  MOVFF  01,700
036D8:  MOVFF  03,701
036DC:  MOVLB  6
036DE:  MOVF   xF6,W
036E0:  MULLW  2D
036E2:  MOVF   FF3,W
036E4:  MOVLB  7
036E6:  CLRF   x03
036E8:  MOVWF  x02
036EA:  MOVLW  08
036EC:  ADDWF  x02,W
036EE:  MOVWF  01
036F0:  MOVLW  00
036F2:  ADDWFC x03,W
036F4:  MOVWF  03
036F6:  MOVF   01,W
036F8:  ADDLW  07
036FA:  MOVWF  FE9
036FC:  MOVLW  01
036FE:  ADDWFC 03,W
03700:  MOVWF  FEA
03702:  MOVFF  FEF,00
03706:  MOVFF  FEC,01
0370A:  MOVFF  FEC,02
0370E:  MOVFF  FEC,03
03712:  MOVFF  701,FEA
03716:  MOVFF  700,FE9
0371A:  MOVFF  00,FEF
0371E:  MOVFF  01,FEC
03722:  MOVFF  02,FEC
03726:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
0372A:  MOVLB  6
0372C:  MOVF   xF6,W
0372E:  MULLW  2D
03730:  MOVF   FF3,W
03732:  MOVLB  7
03734:  CLRF   x01
03736:  MOVWF  x00
03738:  MOVLW  14
0373A:  ADDWF  x00,W
0373C:  MOVWF  01
0373E:  MOVLW  00
03740:  ADDWFC x01,W
03742:  MOVWF  03
03744:  MOVF   01,W
03746:  ADDLW  07
03748:  MOVWF  01
0374A:  MOVLW  01
0374C:  ADDWFC 03,F
0374E:  MOVFF  01,700
03752:  MOVFF  03,701
03756:  MOVLB  6
03758:  MOVF   xF6,W
0375A:  MULLW  2D
0375C:  MOVF   FF3,W
0375E:  MOVLB  7
03760:  CLRF   x03
03762:  MOVWF  x02
03764:  MOVLW  0C
03766:  ADDWF  x02,W
03768:  MOVWF  01
0376A:  MOVLW  00
0376C:  ADDWFC x03,W
0376E:  MOVWF  03
03770:  MOVF   01,W
03772:  ADDLW  07
03774:  MOVWF  FE9
03776:  MOVLW  01
03778:  ADDWFC 03,W
0377A:  MOVWF  FEA
0377C:  MOVFF  FEF,00
03780:  MOVFF  FEC,01
03784:  MOVFF  FEC,02
03788:  MOVFF  FEC,03
0378C:  MOVFF  701,FEA
03790:  MOVFF  700,FE9
03794:  MOVFF  00,FEF
03798:  MOVFF  01,FEC
0379C:  MOVFF  02,FEC
037A0:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037A4:  MOVLB  6
037A6:  MOVF   xF6,W
037A8:  MULLW  2D
037AA:  MOVF   FF3,W
037AC:  MOVLB  7
037AE:  CLRF   x01
037B0:  MOVWF  x00
037B2:  MOVLW  07
037B4:  ADDWF  x00,W
037B6:  MOVWF  01
037B8:  MOVLW  01
037BA:  ADDWFC x01,W
037BC:  MOVWF  03
037BE:  MOVFF  01,702
037C2:  MOVWF  x03
037C4:  MOVLB  6
037C6:  MOVF   xF6,W
037C8:  MULLW  09
037CA:  MOVF   FF3,W
037CC:  MOVLB  7
037CE:  CLRF   x05
037D0:  MOVWF  x04
037D2:  MOVLW  01
037D4:  ADDWF  x04,W
037D6:  MOVWF  01
037D8:  MOVLW  00
037DA:  ADDWFC x05,W
037DC:  MOVWF  03
037DE:  MOVF   01,W
037E0:  ADDLW  D2
037E2:  MOVWF  FE9
037E4:  MOVLW  01
037E6:  ADDWFC 03,W
037E8:  MOVWF  FEA
037EA:  MOVFF  FEF,70D
037EE:  MOVFF  FEC,01
037F2:  MOVFF  FEC,02
037F6:  MOVFF  FEC,03
037FA:  MOVFF  03,710
037FE:  MOVFF  02,70F
03802:  MOVFF  01,70E
03806:  MOVLB  0
03808:  CALL   1C76
0380C:  MOVFF  703,FEA
03810:  MOVFF  702,FE9
03814:  MOVFF  00,FEF
03818:  MOVFF  01,FEC
0381C:  MOVFF  02,FEC
03820:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03824:  MOVLB  6
03826:  MOVF   xF6,W
03828:  MULLW  2D
0382A:  MOVF   FF3,W
0382C:  MOVLB  7
0382E:  CLRF   x01
03830:  MOVWF  x00
03832:  MOVLW  04
03834:  ADDWF  x00,W
03836:  MOVWF  01
03838:  MOVLW  00
0383A:  ADDWFC x01,W
0383C:  MOVWF  03
0383E:  MOVF   01,W
03840:  ADDLW  07
03842:  MOVWF  01
03844:  MOVLW  01
03846:  ADDWFC 03,F
03848:  MOVFF  01,700
0384C:  MOVFF  03,701
03850:  MOVLB  6
03852:  MOVF   xF6,W
03854:  MULLW  09
03856:  MOVF   FF3,W
03858:  MOVLB  7
0385A:  CLRF   x03
0385C:  MOVWF  x02
0385E:  MOVLW  05
03860:  ADDWF  x02,W
03862:  MOVWF  01
03864:  MOVLW  00
03866:  ADDWFC x03,W
03868:  MOVWF  03
0386A:  MOVF   01,W
0386C:  ADDLW  D2
0386E:  MOVWF  FE9
03870:  MOVLW  01
03872:  ADDWFC 03,W
03874:  MOVWF  FEA
03876:  MOVFF  FEF,70D
0387A:  MOVFF  FEC,01
0387E:  MOVFF  FEC,02
03882:  MOVFF  FEC,03
03886:  MOVFF  03,710
0388A:  MOVFF  02,70F
0388E:  MOVFF  01,70E
03892:  MOVLB  0
03894:  CALL   1C76
03898:  MOVFF  701,FEA
0389C:  MOVFF  700,FE9
038A0:  MOVFF  00,FEF
038A4:  MOVFF  01,FEC
038A8:  MOVFF  02,FEC
038AC:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038B0:  MOVLB  6
038B2:  MOVF   xF6,W
038B4:  MULLW  2D
038B6:  MOVF   FF3,W
038B8:  MOVLB  7
038BA:  CLRF   x01
038BC:  MOVWF  x00
038BE:  MOVLW  08
038C0:  ADDWF  x00,W
038C2:  MOVWF  01
038C4:  MOVLW  00
038C6:  ADDWFC x01,W
038C8:  MOVWF  03
038CA:  MOVF   01,W
038CC:  ADDLW  07
038CE:  MOVWF  01
038D0:  MOVLW  01
038D2:  ADDWFC 03,F
038D4:  MOVFF  01,700
038D8:  MOVFF  03,701
038DC:  MOVLB  6
038DE:  MOVF   xF6,W
038E0:  MULLW  2D
038E2:  MOVF   FF3,W
038E4:  MOVLB  7
038E6:  CLRF   x03
038E8:  MOVWF  x02
038EA:  MOVLW  07
038EC:  ADDWF  x02,W
038EE:  MOVWF  FE9
038F0:  MOVLW  01
038F2:  ADDWFC x03,W
038F4:  MOVWF  FEA
038F6:  MOVFF  FEF,743
038FA:  MOVFF  FEC,744
038FE:  MOVFF  FEC,745
03902:  MOVFF  FEC,746
03906:  MOVLB  6
03908:  MOVF   xF6,W
0390A:  MULLW  10
0390C:  MOVF   FF3,W
0390E:  MOVLB  7
03910:  CLRF   x09
03912:  MOVWF  x08
03914:  MOVLW  08
03916:  ADDWF  x08,W
03918:  MOVWF  01
0391A:  MOVLW  00
0391C:  ADDWFC x09,W
0391E:  MOVWF  03
03920:  MOVF   01,W
03922:  ADDLW  62
03924:  MOVWF  FE9
03926:  MOVLW  00
03928:  ADDWFC 03,W
0392A:  MOVWF  FEA
0392C:  MOVFF  FEF,747
03930:  MOVFF  FEC,01
03934:  MOVFF  FEC,02
03938:  MOVFF  FEC,03
0393C:  MOVFF  03,74A
03940:  MOVFF  02,749
03944:  MOVFF  01,748
03948:  MOVLB  0
0394A:  CALL   0D20
0394E:  MOVFF  03,74A
03952:  MOVFF  02,749
03956:  MOVFF  01,748
0395A:  MOVFF  00,747
0395E:  MOVLB  6
03960:  MOVF   xF6,W
03962:  MULLW  10
03964:  MOVF   FF3,W
03966:  MOVLB  7
03968:  CLRF   x09
0396A:  MOVWF  x08
0396C:  MOVLW  62
0396E:  ADDWF  x08,W
03970:  MOVWF  FE9
03972:  MOVLW  00
03974:  ADDWFC x09,W
03976:  MOVWF  FEA
03978:  MOVFF  FEF,74B
0397C:  MOVFF  FEC,01
03980:  MOVFF  FEC,02
03984:  MOVFF  FEC,03
03988:  BCF    FD8.1
0398A:  MOVFF  03,74E
0398E:  MOVFF  02,74D
03992:  MOVFF  01,74C
03996:  MOVLB  0
03998:  CALL   0E16
0399C:  MOVFF  701,FEA
039A0:  MOVFF  700,FE9
039A4:  MOVFF  00,FEF
039A8:  MOVFF  01,FEC
039AC:  MOVFF  02,FEC
039B0:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039B4:  MOVLB  6
039B6:  MOVF   xF6,W
039B8:  MULLW  2D
039BA:  MOVF   FF3,W
039BC:  MOVLB  7
039BE:  CLRF   x01
039C0:  MOVWF  x00
039C2:  MOVLW  0C
039C4:  ADDWF  x00,W
039C6:  MOVWF  01
039C8:  MOVLW  00
039CA:  ADDWFC x01,W
039CC:  MOVWF  03
039CE:  MOVF   01,W
039D0:  ADDLW  07
039D2:  MOVWF  01
039D4:  MOVLW  01
039D6:  ADDWFC 03,F
039D8:  MOVFF  01,700
039DC:  MOVFF  03,701
039E0:  MOVLB  6
039E2:  MOVF   xF6,W
039E4:  MULLW  2D
039E6:  MOVF   FF3,W
039E8:  MOVLB  7
039EA:  CLRF   x03
039EC:  MOVWF  x02
039EE:  MOVLW  04
039F0:  ADDWF  x02,W
039F2:  MOVWF  01
039F4:  MOVLW  00
039F6:  ADDWFC x03,W
039F8:  MOVWF  03
039FA:  MOVF   01,W
039FC:  ADDLW  07
039FE:  MOVWF  FE9
03A00:  MOVLW  01
03A02:  ADDWFC 03,W
03A04:  MOVWF  FEA
03A06:  MOVFF  FEF,743
03A0A:  MOVFF  FEC,744
03A0E:  MOVFF  FEC,745
03A12:  MOVFF  FEC,746
03A16:  MOVLB  6
03A18:  MOVF   xF6,W
03A1A:  MULLW  10
03A1C:  MOVF   FF3,W
03A1E:  MOVLB  7
03A20:  CLRF   x07
03A22:  MOVWF  x06
03A24:  MOVLW  0C
03A26:  ADDWF  x06,W
03A28:  MOVWF  01
03A2A:  MOVLW  00
03A2C:  ADDWFC x07,W
03A2E:  MOVWF  03
03A30:  MOVF   01,W
03A32:  ADDLW  62
03A34:  MOVWF  FE9
03A36:  MOVLW  00
03A38:  ADDWFC 03,W
03A3A:  MOVWF  FEA
03A3C:  MOVFF  FEF,747
03A40:  MOVFF  FEC,01
03A44:  MOVFF  FEC,02
03A48:  MOVFF  FEC,03
03A4C:  MOVFF  03,74A
03A50:  MOVFF  02,749
03A54:  MOVFF  01,748
03A58:  MOVLB  0
03A5A:  CALL   0D20
03A5E:  MOVFF  03,74A
03A62:  MOVFF  02,749
03A66:  MOVFF  01,748
03A6A:  MOVFF  00,747
03A6E:  MOVLB  6
03A70:  MOVF   xF6,W
03A72:  MULLW  10
03A74:  MOVF   FF3,W
03A76:  MOVLB  7
03A78:  CLRF   x07
03A7A:  MOVWF  x06
03A7C:  MOVLW  04
03A7E:  ADDWF  x06,W
03A80:  MOVWF  01
03A82:  MOVLW  00
03A84:  ADDWFC x07,W
03A86:  MOVWF  03
03A88:  MOVF   01,W
03A8A:  ADDLW  62
03A8C:  MOVWF  FE9
03A8E:  MOVLW  00
03A90:  ADDWFC 03,W
03A92:  MOVWF  FEA
03A94:  MOVFF  FEF,74B
03A98:  MOVFF  FEC,01
03A9C:  MOVFF  FEC,02
03AA0:  MOVFF  FEC,03
03AA4:  BCF    FD8.1
03AA6:  MOVFF  03,74E
03AAA:  MOVFF  02,74D
03AAE:  MOVFF  01,74C
03AB2:  MOVLB  0
03AB4:  CALL   0E16
03AB8:  MOVFF  701,FEA
03ABC:  MOVFF  700,FE9
03AC0:  MOVFF  00,FEF
03AC4:  MOVFF  01,FEC
03AC8:  MOVFF  02,FEC
03ACC:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AD0:  MOVLB  6
03AD2:  CLRF   xFA
03AD4:  CLRF   xF9
03AD6:  CLRF   xF8
03AD8:  CLRF   xF7
03ADA:  CLRF   xFE
03ADC:  CLRF   xFD
03ADE:  CLRF   xFC
03AE0:  MOVLW  7F
03AE2:  MOVWF  xFB
....................    
....................    if (adcVals[ch].cosCounts < 0){
03AE4:  MOVF   xF6,W
03AE6:  MULLW  2D
03AE8:  MOVF   FF3,W
03AEA:  MOVLB  7
03AEC:  CLRF   x01
03AEE:  MOVWF  x00
03AF0:  MOVLW  0C
03AF2:  ADDWF  x00,W
03AF4:  MOVWF  01
03AF6:  MOVLW  00
03AF8:  ADDWFC x01,W
03AFA:  MOVWF  03
03AFC:  MOVF   01,W
03AFE:  ADDLW  07
03B00:  MOVWF  FE9
03B02:  MOVLW  01
03B04:  ADDWFC 03,W
03B06:  MOVWF  FEA
03B08:  MOVFF  FEF,743
03B0C:  MOVFF  FEC,744
03B10:  MOVFF  FEC,745
03B14:  MOVFF  FEC,746
03B18:  CLRF   x4A
03B1A:  CLRF   x49
03B1C:  CLRF   x48
03B1E:  CLRF   x47
03B20:  MOVLB  0
03B22:  CALL   1CD0
03B26:  BTFSS  FD8.0
03B28:  BRA    3C9E
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B2A:  MOVLB  6
03B2C:  MOVF   xF6,W
03B2E:  MULLW  2D
03B30:  MOVF   FF3,W
03B32:  MOVLB  7
03B34:  CLRF   x01
03B36:  MOVWF  x00
03B38:  MOVLW  08
03B3A:  ADDWF  x00,W
03B3C:  MOVWF  01
03B3E:  MOVLW  00
03B40:  ADDWFC x01,W
03B42:  MOVWF  03
03B44:  MOVF   01,W
03B46:  ADDLW  07
03B48:  MOVWF  FE9
03B4A:  MOVLW  01
03B4C:  ADDWFC 03,W
03B4E:  MOVWF  FEA
03B50:  MOVFF  FEF,747
03B54:  MOVFF  FEC,701
03B58:  MOVFF  FEC,749
03B5C:  MOVFF  FEC,74A
03B60:  CLRF   x46
03B62:  CLRF   x45
03B64:  CLRF   x44
03B66:  CLRF   x43
03B68:  MOVFF  701,748
03B6C:  MOVLB  0
03B6E:  CALL   1CD0
03B72:  BNC   3BE4
03B74:  MOVLB  6
03B76:  MOVF   xF6,W
03B78:  MULLW  2D
03B7A:  MOVF   FF3,W
03B7C:  MOVLB  7
03B7E:  CLRF   x01
03B80:  MOVWF  x00
03B82:  MOVLW  10
03B84:  ADDWF  x00,W
03B86:  MOVWF  01
03B88:  MOVLW  00
03B8A:  ADDWFC x01,W
03B8C:  MOVWF  03
03B8E:  MOVF   01,W
03B90:  ADDLW  07
03B92:  MOVWF  FE9
03B94:  MOVLW  01
03B96:  ADDWFC 03,W
03B98:  MOVWF  FEA
03B9A:  MOVFF  FEF,743
03B9E:  MOVFF  FEC,744
03BA2:  MOVFF  FEC,745
03BA6:  MOVFF  FEC,746
03BAA:  CLRF   x4A
03BAC:  CLRF   x49
03BAE:  CLRF   x48
03BB0:  CLRF   x47
03BB2:  MOVLB  0
03BB4:  CALL   1CD0
03BB8:  BNC   3BE4
....................          adcVals[ch].npoles--;
03BBA:  MOVLB  6
03BBC:  MOVF   xF6,W
03BBE:  MULLW  2D
03BC0:  MOVF   FF3,W
03BC2:  MOVLB  7
03BC4:  CLRF   x01
03BC6:  MOVWF  x00
03BC8:  MOVLW  1C
03BCA:  ADDWF  x00,W
03BCC:  MOVWF  01
03BCE:  MOVLW  00
03BD0:  ADDWFC x01,W
03BD2:  MOVWF  03
03BD4:  MOVF   01,W
03BD6:  ADDLW  07
03BD8:  MOVWF  FE9
03BDA:  MOVLW  01
03BDC:  ADDWFC 03,W
03BDE:  MOVWF  FEA
03BE0:  DECF   FEF,F
....................       }
03BE2:  BRA    3C9C
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03BE4:  MOVLB  6
03BE6:  MOVF   xF6,W
03BE8:  MULLW  2D
03BEA:  MOVF   FF3,W
03BEC:  MOVLB  7
03BEE:  CLRF   x01
03BF0:  MOVWF  x00
03BF2:  MOVLW  08
03BF4:  ADDWF  x00,W
03BF6:  MOVWF  01
03BF8:  MOVLW  00
03BFA:  ADDWFC x01,W
03BFC:  MOVWF  03
03BFE:  MOVF   01,W
03C00:  ADDLW  07
03C02:  MOVWF  FE9
03C04:  MOVLW  01
03C06:  ADDWFC 03,W
03C08:  MOVWF  FEA
03C0A:  MOVFF  FEF,743
03C0E:  MOVFF  FEC,701
03C12:  MOVFF  FEC,745
03C16:  MOVFF  FEC,746
03C1A:  MOVFF  701,744
03C1E:  CLRF   x4A
03C20:  CLRF   x49
03C22:  CLRF   x48
03C24:  CLRF   x47
03C26:  MOVLB  0
03C28:  CALL   1CD0
03C2C:  BNC   3C9E
03C2E:  MOVLB  6
03C30:  MOVF   xF6,W
03C32:  MULLW  2D
03C34:  MOVF   FF3,W
03C36:  MOVLB  7
03C38:  CLRF   x01
03C3A:  MOVWF  x00
03C3C:  MOVLW  10
03C3E:  ADDWF  x00,W
03C40:  MOVWF  01
03C42:  MOVLW  00
03C44:  ADDWFC x01,W
03C46:  MOVWF  03
03C48:  MOVF   01,W
03C4A:  ADDLW  07
03C4C:  MOVWF  FE9
03C4E:  MOVLW  01
03C50:  ADDWFC 03,W
03C52:  MOVWF  FEA
03C54:  MOVFF  FEF,747
03C58:  MOVFF  FEC,748
03C5C:  MOVFF  FEC,749
03C60:  MOVFF  FEC,74A
03C64:  CLRF   x46
03C66:  CLRF   x45
03C68:  CLRF   x44
03C6A:  CLRF   x43
03C6C:  MOVLB  0
03C6E:  CALL   1CD0
03C72:  BNC   3C9E
....................          adcVals[ch].npoles++;
03C74:  MOVLB  6
03C76:  MOVF   xF6,W
03C78:  MULLW  2D
03C7A:  MOVF   FF3,W
03C7C:  MOVLB  7
03C7E:  CLRF   x01
03C80:  MOVWF  x00
03C82:  MOVLW  1C
03C84:  ADDWF  x00,W
03C86:  MOVWF  01
03C88:  MOVLW  00
03C8A:  ADDWFC x01,W
03C8C:  MOVWF  03
03C8E:  MOVF   01,W
03C90:  ADDLW  07
03C92:  MOVWF  FE9
03C94:  MOVLW  01
03C96:  ADDWFC 03,W
03C98:  MOVWF  FEA
03C9A:  INCF   FEF,F
03C9C:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03C9E:  MOVLB  6
03CA0:  MOVF   xF6,W
03CA2:  MULLW  2D
03CA4:  MOVF   FF3,W
03CA6:  MOVLB  7
03CA8:  CLRF   x01
03CAA:  MOVWF  x00
03CAC:  MOVLW  18
03CAE:  ADDWF  x00,W
03CB0:  MOVWF  01
03CB2:  MOVLW  00
03CB4:  ADDWFC x01,W
03CB6:  MOVWF  03
03CB8:  MOVF   01,W
03CBA:  ADDLW  07
03CBC:  MOVWF  01
03CBE:  MOVLW  01
03CC0:  ADDWFC 03,F
03CC2:  MOVFF  01,700
03CC6:  MOVFF  03,701
03CCA:  MOVFF  6FE,746
03CCE:  MOVFF  6FD,745
03CD2:  MOVFF  6FC,744
03CD6:  MOVFF  6FB,743
03CDA:  MOVLW  AA
03CDC:  MOVWF  x4A
03CDE:  MOVLW  27
03CE0:  MOVWF  x49
03CE2:  MOVLW  1F
03CE4:  MOVWF  x48
03CE6:  MOVLW  86
03CE8:  MOVWF  x47
03CEA:  MOVLB  0
03CEC:  CALL   0D20
03CF0:  MOVFF  03,705
03CF4:  MOVFF  02,704
03CF8:  MOVFF  01,703
03CFC:  MOVFF  00,702
03D00:  MOVLB  6
03D02:  MOVF   xF6,W
03D04:  MULLW  2D
03D06:  MOVF   FF3,W
03D08:  MOVLB  7
03D0A:  CLRF   x07
03D0C:  MOVWF  x06
03D0E:  MOVLW  08
03D10:  ADDWF  x06,W
03D12:  MOVWF  01
03D14:  MOVLW  00
03D16:  ADDWFC x07,W
03D18:  MOVWF  03
03D1A:  MOVF   01,W
03D1C:  ADDLW  07
03D1E:  MOVWF  FE9
03D20:  MOVLW  01
03D22:  ADDWFC 03,W
03D24:  MOVWF  FEA
03D26:  MOVFF  FEF,706
03D2A:  MOVFF  FEC,707
03D2E:  MOVFF  FEC,708
03D32:  MOVFF  FEC,709
03D36:  MOVLB  6
03D38:  MOVF   xF6,W
03D3A:  MULLW  2D
03D3C:  MOVF   FF3,W
03D3E:  MOVLB  7
03D40:  CLRF   x0B
03D42:  MOVWF  x0A
03D44:  MOVLW  0C
03D46:  ADDWF  x0A,W
03D48:  MOVWF  01
03D4A:  MOVLW  00
03D4C:  ADDWFC x0B,W
03D4E:  MOVWF  03
03D50:  MOVF   01,W
03D52:  ADDLW  07
03D54:  MOVWF  FE9
03D56:  MOVLW  01
03D58:  ADDWFC 03,W
03D5A:  MOVWF  FEA
03D5C:  MOVFF  FEF,00
03D60:  MOVFF  FEC,01
03D64:  MOVFF  FEC,02
03D68:  MOVFF  FEC,03
03D6C:  MOVFF  03,70D
03D70:  MOVFF  02,70C
03D74:  MOVFF  01,70B
03D78:  MOVFF  00,70A
03D7C:  MOVFF  709,71A
03D80:  MOVFF  708,719
03D84:  MOVFF  707,718
03D88:  MOVFF  706,717
03D8C:  MOVFF  03,71E
03D90:  MOVFF  02,71D
03D94:  MOVFF  01,71C
03D98:  MOVFF  00,71B
03D9C:  MOVLB  0
03D9E:  GOTO   23D2
03DA2:  MOVFF  705,746
03DA6:  MOVFF  704,745
03DAA:  MOVFF  703,744
03DAE:  MOVFF  702,743
03DB2:  MOVFF  03,74A
03DB6:  MOVFF  02,749
03DBA:  MOVFF  01,748
03DBE:  MOVFF  00,747
03DC2:  CALL   0D20
03DC6:  MOVFF  701,FEA
03DCA:  MOVFF  700,FE9
03DCE:  MOVFF  00,FEF
03DD2:  MOVFF  01,FEC
03DD6:  MOVFF  02,FEC
03DDA:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DDE:  MOVLB  6
03DE0:  MOVF   xF6,W
03DE2:  MULLW  2D
03DE4:  MOVF   FF3,W
03DE6:  MOVLB  7
03DE8:  CLRF   x01
03DEA:  MOVWF  x00
03DEC:  MOVLW  18
03DEE:  ADDWF  x00,W
03DF0:  MOVWF  01
03DF2:  MOVLW  00
03DF4:  ADDWFC x01,W
03DF6:  MOVWF  03
03DF8:  MOVF   01,W
03DFA:  ADDLW  07
03DFC:  MOVWF  FE9
03DFE:  MOVLW  01
03E00:  ADDWFC 03,W
03E02:  MOVWF  FEA
03E04:  MOVFF  FEF,700
03E08:  MOVFF  FEC,701
03E0C:  MOVFF  FEC,702
03E10:  MOVFF  FEC,703
03E14:  CLRF   x46
03E16:  CLRF   x45
03E18:  MOVLW  7A
03E1A:  MOVWF  x44
03E1C:  MOVLW  88
03E1E:  MOVWF  x43
03E20:  MOVFF  6FE,74A
03E24:  MOVFF  6FD,749
03E28:  MOVFF  6FC,748
03E2C:  MOVFF  6FB,747
03E30:  MOVLB  0
03E32:  CALL   0D20
03E36:  MOVFF  03,707
03E3A:  MOVFF  02,706
03E3E:  MOVFF  01,705
03E42:  MOVFF  00,704
03E46:  MOVLB  6
03E48:  MOVF   xF6,W
03E4A:  MULLW  2D
03E4C:  MOVF   FF3,W
03E4E:  MOVLB  7
03E50:  CLRF   x09
03E52:  MOVWF  x08
03E54:  MOVLW  1C
03E56:  ADDWF  x08,W
03E58:  MOVWF  01
03E5A:  MOVLW  00
03E5C:  ADDWFC x09,W
03E5E:  MOVWF  03
03E60:  MOVF   01,W
03E62:  ADDLW  07
03E64:  MOVWF  FE9
03E66:  MOVLW  01
03E68:  ADDWFC 03,W
03E6A:  MOVWF  FEA
03E6C:  MOVF   FEF,W
03E6E:  CLRF   x3A
03E70:  MOVWF  x39
03E72:  BTFSC  x39.7
03E74:  DECF   x3A,F
03E76:  MOVLB  0
03E78:  CALL   2674
03E7C:  MOVFF  707,746
03E80:  MOVFF  706,745
03E84:  MOVFF  705,744
03E88:  MOVFF  704,743
03E8C:  MOVFF  03,74A
03E90:  MOVFF  02,749
03E94:  MOVFF  01,748
03E98:  MOVFF  00,747
03E9C:  CALL   0D20
03EA0:  MOVFF  FEA,705
03EA4:  MOVFF  FE9,704
03EA8:  BCF    FD8.1
03EAA:  MOVFF  703,74A
03EAE:  MOVFF  702,749
03EB2:  MOVFF  701,748
03EB6:  MOVFF  700,747
03EBA:  MOVFF  03,74E
03EBE:  MOVFF  02,74D
03EC2:  MOVFF  01,74C
03EC6:  MOVFF  00,74B
03ECA:  CALL   0E16
03ECE:  MOVFF  705,FEA
03ED2:  MOVFF  704,FE9
03ED6:  MOVFF  03,6FA
03EDA:  MOVFF  02,6F9
03EDE:  MOVFF  01,6F8
03EE2:  MOVFF  00,6F7
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EE6:  MOVLB  6
03EE8:  MOVF   xF6,W
03EEA:  MULLW  2D
03EEC:  MOVF   FF3,W
03EEE:  MOVLB  7
03EF0:  CLRF   x01
03EF2:  MOVWF  x00
03EF4:  MOVLW  1D
03EF6:  ADDWF  x00,W
03EF8:  MOVWF  01
03EFA:  MOVLW  00
03EFC:  ADDWFC x01,W
03EFE:  MOVWF  03
03F00:  MOVF   01,W
03F02:  ADDLW  07
03F04:  MOVWF  01
03F06:  MOVLW  01
03F08:  ADDWFC 03,F
03F0A:  MOVFF  01,700
03F0E:  MOVFF  03,701
03F12:  MOVLB  6
03F14:  MOVF   xF6,W
03F16:  MULLW  18
03F18:  MOVF   FF3,W
03F1A:  MOVLB  7
03F1C:  CLRF   x03
03F1E:  MOVWF  x02
03F20:  MOVLW  14
03F22:  ADDWF  x02,W
03F24:  MOVWF  01
03F26:  MOVLW  00
03F28:  ADDWFC x03,W
03F2A:  MOVWF  03
03F2C:  MOVF   01,W
03F2E:  ADDLW  82
03F30:  MOVWF  FE9
03F32:  MOVLW  00
03F34:  ADDWFC 03,W
03F36:  MOVWF  FEA
03F38:  MOVFF  FEF,747
03F3C:  MOVFF  FEC,01
03F40:  MOVFF  FEC,02
03F44:  MOVFF  FEC,03
03F48:  MOVFF  6FA,746
03F4C:  MOVFF  6F9,745
03F50:  MOVFF  6F8,744
03F54:  MOVFF  6F7,743
03F58:  MOVFF  03,74A
03F5C:  MOVFF  02,749
03F60:  MOVFF  01,748
03F64:  MOVLB  0
03F66:  CALL   0D20
03F6A:  MOVFF  03,705
03F6E:  MOVFF  02,704
03F72:  MOVFF  01,703
03F76:  MOVFF  00,702
03F7A:  MOVFF  03,71A
03F7E:  MOVFF  02,719
03F82:  MOVFF  01,718
03F86:  MOVFF  00,717
03F8A:  MOVLB  7
03F8C:  CLRF   x1E
03F8E:  CLRF   x1D
03F90:  MOVLW  20
03F92:  MOVWF  x1C
03F94:  MOVLW  81
03F96:  MOVWF  x1B
03F98:  MOVLB  0
03F9A:  CALL   33B2
03F9E:  MOVFF  03,705
03FA2:  MOVFF  02,704
03FA6:  MOVFF  01,703
03FAA:  MOVFF  00,702
03FAE:  MOVLB  6
03FB0:  MOVF   xF6,W
03FB2:  MULLW  18
03FB4:  MOVF   FF3,W
03FB6:  MOVLB  7
03FB8:  CLRF   x07
03FBA:  MOVWF  x06
03FBC:  MOVLW  10
03FBE:  ADDWF  x06,W
03FC0:  MOVWF  01
03FC2:  MOVLW  00
03FC4:  ADDWFC x07,W
03FC6:  MOVWF  03
03FC8:  MOVF   01,W
03FCA:  ADDLW  82
03FCC:  MOVWF  FE9
03FCE:  MOVLW  00
03FD0:  ADDWFC 03,W
03FD2:  MOVWF  FEA
03FD4:  MOVFF  FEF,747
03FD8:  MOVFF  FEC,01
03FDC:  MOVFF  FEC,02
03FE0:  MOVFF  FEC,03
03FE4:  MOVFF  6FA,746
03FE8:  MOVFF  6F9,745
03FEC:  MOVFF  6F8,744
03FF0:  MOVFF  6F7,743
03FF4:  MOVFF  03,74A
03FF8:  MOVFF  02,749
03FFC:  MOVFF  01,748
04000:  MOVLB  0
04002:  CALL   0D20
04006:  MOVFF  03,709
0400A:  MOVFF  02,708
0400E:  MOVFF  01,707
04012:  MOVFF  00,706
04016:  MOVFF  03,71A
0401A:  MOVFF  02,719
0401E:  MOVFF  01,718
04022:  MOVFF  00,717
04026:  MOVLB  7
04028:  CLRF   x1E
0402A:  CLRF   x1D
0402C:  CLRF   x1C
0402E:  MOVLW  81
04030:  MOVWF  x1B
04032:  MOVLB  0
04034:  CALL   33B2
04038:  MOVFF  FEA,707
0403C:  MOVFF  FE9,706
04040:  BCF    FD8.1
04042:  MOVFF  705,74A
04046:  MOVFF  704,749
0404A:  MOVFF  703,748
0404E:  MOVFF  702,747
04052:  MOVFF  03,74E
04056:  MOVFF  02,74D
0405A:  MOVFF  01,74C
0405E:  MOVFF  00,74B
04062:  CALL   0E16
04066:  MOVFF  707,FEA
0406A:  MOVFF  706,FE9
0406E:  MOVFF  03,705
04072:  MOVFF  02,704
04076:  MOVFF  01,703
0407A:  MOVFF  00,702
0407E:  MOVLB  6
04080:  MOVF   xF6,W
04082:  MULLW  18
04084:  MOVF   FF3,W
04086:  MOVLB  7
04088:  CLRF   x09
0408A:  MOVWF  x08
0408C:  MOVLW  0C
0408E:  ADDWF  x08,W
04090:  MOVWF  01
04092:  MOVLW  00
04094:  ADDWFC x09,W
04096:  MOVWF  03
04098:  MOVF   01,W
0409A:  ADDLW  82
0409C:  MOVWF  FE9
0409E:  MOVLW  00
040A0:  ADDWFC 03,W
040A2:  MOVWF  FEA
040A4:  MOVFF  FEF,747
040A8:  MOVFF  FEC,01
040AC:  MOVFF  FEC,02
040B0:  MOVFF  FEC,03
040B4:  MOVFF  6FA,746
040B8:  MOVFF  6F9,745
040BC:  MOVFF  6F8,744
040C0:  MOVFF  6F7,743
040C4:  MOVFF  03,74A
040C8:  MOVFF  02,749
040CC:  MOVFF  01,748
040D0:  MOVLB  0
040D2:  CALL   0D20
040D6:  MOVFF  03,70B
040DA:  MOVFF  02,70A
040DE:  MOVFF  01,709
040E2:  MOVFF  00,708
040E6:  MOVFF  03,71A
040EA:  MOVFF  02,719
040EE:  MOVFF  01,718
040F2:  MOVFF  00,717
040F6:  MOVLB  7
040F8:  CLRF   x1E
040FA:  CLRF   x1D
040FC:  MOVLW  40
040FE:  MOVWF  x1C
04100:  MOVLW  80
04102:  MOVWF  x1B
04104:  MOVLB  0
04106:  CALL   33B2
0410A:  MOVFF  FEA,709
0410E:  MOVFF  FE9,708
04112:  BCF    FD8.1
04114:  MOVFF  705,74A
04118:  MOVFF  704,749
0411C:  MOVFF  703,748
04120:  MOVFF  702,747
04124:  MOVFF  03,74E
04128:  MOVFF  02,74D
0412C:  MOVFF  01,74C
04130:  MOVFF  00,74B
04134:  CALL   0E16
04138:  MOVFF  709,FEA
0413C:  MOVFF  708,FE9
04140:  MOVFF  03,705
04144:  MOVFF  02,704
04148:  MOVFF  01,703
0414C:  MOVFF  00,702
04150:  MOVLB  6
04152:  MOVF   xF6,W
04154:  MULLW  18
04156:  MOVF   FF3,W
04158:  MOVLB  7
0415A:  CLRF   x0B
0415C:  MOVWF  x0A
0415E:  MOVLW  08
04160:  ADDWF  x0A,W
04162:  MOVWF  01
04164:  MOVLW  00
04166:  ADDWFC x0B,W
04168:  MOVWF  03
0416A:  MOVF   01,W
0416C:  ADDLW  82
0416E:  MOVWF  FE9
04170:  MOVLW  00
04172:  ADDWFC 03,W
04174:  MOVWF  FEA
04176:  MOVFF  FEF,747
0417A:  MOVFF  FEC,01
0417E:  MOVFF  FEC,02
04182:  MOVFF  FEC,03
04186:  MOVFF  6FA,746
0418A:  MOVFF  6F9,745
0418E:  MOVFF  6F8,744
04192:  MOVFF  6F7,743
04196:  MOVFF  03,74A
0419A:  MOVFF  02,749
0419E:  MOVFF  01,748
041A2:  MOVLB  0
041A4:  CALL   0D20
041A8:  MOVFF  03,70D
041AC:  MOVFF  02,70C
041B0:  MOVFF  01,70B
041B4:  MOVFF  00,70A
041B8:  MOVFF  03,71A
041BC:  MOVFF  02,719
041C0:  MOVFF  01,718
041C4:  MOVFF  00,717
041C8:  MOVLB  7
041CA:  CLRF   x1E
041CC:  CLRF   x1D
041CE:  CLRF   x1C
041D0:  MOVLW  80
041D2:  MOVWF  x1B
041D4:  MOVLB  0
041D6:  CALL   33B2
041DA:  MOVFF  FEA,70B
041DE:  MOVFF  FE9,70A
041E2:  BCF    FD8.1
041E4:  MOVFF  705,74A
041E8:  MOVFF  704,749
041EC:  MOVFF  703,748
041F0:  MOVFF  702,747
041F4:  MOVFF  03,74E
041F8:  MOVFF  02,74D
041FC:  MOVFF  01,74C
04200:  MOVFF  00,74B
04204:  CALL   0E16
04208:  MOVFF  70B,FEA
0420C:  MOVFF  70A,FE9
04210:  MOVFF  03,705
04214:  MOVFF  02,704
04218:  MOVFF  01,703
0421C:  MOVFF  00,702
04220:  MOVLB  6
04222:  MOVF   xF6,W
04224:  MULLW  18
04226:  MOVF   FF3,W
04228:  MOVLB  7
0422A:  CLRF   x0D
0422C:  MOVWF  x0C
0422E:  MOVLW  04
04230:  ADDWF  x0C,W
04232:  MOVWF  01
04234:  MOVLW  00
04236:  ADDWFC x0D,W
04238:  MOVWF  03
0423A:  MOVF   01,W
0423C:  ADDLW  82
0423E:  MOVWF  FE9
04240:  MOVLW  00
04242:  ADDWFC 03,W
04244:  MOVWF  FEA
04246:  MOVFF  FEF,747
0424A:  MOVFF  FEC,01
0424E:  MOVFF  FEC,02
04252:  MOVFF  FEC,03
04256:  MOVFF  6FA,746
0425A:  MOVFF  6F9,745
0425E:  MOVFF  6F8,744
04262:  MOVFF  6F7,743
04266:  MOVFF  03,74A
0426A:  MOVFF  02,749
0426E:  MOVFF  01,748
04272:  MOVLB  0
04274:  CALL   0D20
04278:  MOVFF  FEA,70D
0427C:  MOVFF  FE9,70C
04280:  BCF    FD8.1
04282:  MOVFF  705,74A
04286:  MOVFF  704,749
0428A:  MOVFF  703,748
0428E:  MOVFF  702,747
04292:  MOVFF  03,74E
04296:  MOVFF  02,74D
0429A:  MOVFF  01,74C
0429E:  MOVFF  00,74B
042A2:  CALL   0E16
042A6:  MOVFF  70D,FEA
042AA:  MOVFF  70C,FE9
042AE:  MOVFF  03,74A
042B2:  MOVFF  02,749
042B6:  MOVFF  01,748
042BA:  MOVFF  00,747
042BE:  MOVLB  6
042C0:  MOVF   xF6,W
042C2:  MULLW  18
042C4:  MOVF   FF3,W
042C6:  MOVLB  7
042C8:  CLRF   x0F
042CA:  MOVWF  x0E
042CC:  MOVLW  82
042CE:  ADDWF  x0E,W
042D0:  MOVWF  FE9
042D2:  MOVLW  00
042D4:  ADDWFC x0F,W
042D6:  MOVWF  FEA
042D8:  MOVFF  FEF,74B
042DC:  MOVFF  FEC,01
042E0:  MOVFF  FEC,02
042E4:  MOVFF  FEC,03
042E8:  BCF    FD8.1
042EA:  MOVFF  03,74E
042EE:  MOVFF  02,74D
042F2:  MOVFF  01,74C
042F6:  MOVLB  0
042F8:  CALL   0E16
042FC:  MOVFF  701,FEA
04300:  MOVFF  700,FE9
04304:  MOVFF  00,FEF
04308:  MOVFF  01,FEC
0430C:  MOVFF  02,FEC
04310:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04314:  MOVLB  6
04316:  MOVF   xF6,F
04318:  BNZ   4378
0431A:  MOVF   xF6,W
0431C:  MULLW  2D
0431E:  MOVF   FF3,W
04320:  MOVLB  7
04322:  CLRF   x01
04324:  MOVWF  x00
04326:  MOVLW  1D
04328:  ADDWF  x00,W
0432A:  MOVWF  01
0432C:  MOVLW  00
0432E:  ADDWFC x01,W
04330:  MOVWF  03
04332:  MOVF   01,W
04334:  ADDLW  07
04336:  MOVWF  FE9
04338:  MOVLW  01
0433A:  ADDWFC 03,W
0433C:  MOVWF  FEA
0433E:  MOVFF  FEF,743
04342:  MOVFF  FEC,744
04346:  MOVFF  FEC,745
0434A:  MOVFF  FEC,746
0434E:  MOVF   FED,F
04350:  MOVF   FED,F
04352:  MOVF   FED,F
04354:  CLRF   x4A
04356:  CLRF   x49
04358:  MOVLW  80
0435A:  MOVWF  x48
0435C:  MOVLW  7F
0435E:  MOVWF  x47
04360:  MOVLB  0
04362:  CALL   0D20
04366:  MOVFF  00,FEF
0436A:  MOVFF  01,FEC
0436E:  MOVFF  02,FEC
04372:  MOVFF  03,FEC
04376:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
04378:  MOVF   xF6,W
0437A:  MULLW  20
0437C:  MOVF   FF3,W
0437E:  MOVLB  7
04380:  CLRF   x01
04382:  MOVWF  x00
04384:  MOVLW  14
04386:  ADDWF  x00,W
04388:  MOVWF  01
0438A:  MOVLW  00
0438C:  ADDWFC x01,W
0438E:  MOVWF  03
04390:  MOVF   01,W
04392:  ADDLW  20
04394:  MOVWF  01
04396:  MOVLW  00
04398:  ADDWFC 03,F
0439A:  MOVFF  01,700
0439E:  MOVFF  03,701
043A2:  MOVLB  6
043A4:  MOVF   xF6,W
043A6:  MULLW  20
043A8:  MOVF   FF3,W
043AA:  MOVLB  7
043AC:  CLRF   x03
043AE:  MOVWF  x02
043B0:  MOVLW  10
043B2:  ADDWF  x02,W
043B4:  MOVWF  01
043B6:  MOVLW  00
043B8:  ADDWFC x03,W
043BA:  MOVWF  03
043BC:  MOVF   01,W
043BE:  ADDLW  20
043C0:  MOVWF  FE9
043C2:  MOVLW  00
043C4:  ADDWFC 03,W
043C6:  MOVWF  FEA
043C8:  MOVFF  FEF,00
043CC:  MOVFF  FEC,01
043D0:  MOVFF  FEC,02
043D4:  MOVFF  FEC,03
043D8:  MOVFF  701,FEA
043DC:  MOVFF  700,FE9
043E0:  MOVFF  00,FEF
043E4:  MOVFF  01,FEC
043E8:  MOVFF  02,FEC
043EC:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043F0:  MOVLB  6
043F2:  MOVF   xF6,W
043F4:  MULLW  20
043F6:  MOVF   FF3,W
043F8:  MOVLB  7
043FA:  CLRF   x01
043FC:  MOVWF  x00
043FE:  MOVLW  10
04400:  ADDWF  x00,W
04402:  MOVWF  01
04404:  MOVLW  00
04406:  ADDWFC x01,W
04408:  MOVWF  03
0440A:  MOVF   01,W
0440C:  ADDLW  20
0440E:  MOVWF  01
04410:  MOVLW  00
04412:  ADDWFC 03,F
04414:  MOVFF  01,700
04418:  MOVFF  03,701
0441C:  MOVLB  6
0441E:  MOVF   xF6,W
04420:  MULLW  2D
04422:  MOVF   FF3,W
04424:  MOVLB  7
04426:  CLRF   x03
04428:  MOVWF  x02
0442A:  MOVLW  1D
0442C:  ADDWF  x02,W
0442E:  MOVWF  01
04430:  MOVLW  00
04432:  ADDWFC x03,W
04434:  MOVWF  03
04436:  MOVF   01,W
04438:  ADDLW  07
0443A:  MOVWF  FE9
0443C:  MOVLW  01
0443E:  ADDWFC 03,W
04440:  MOVWF  FEA
04442:  MOVFF  FEF,00
04446:  MOVFF  FEC,01
0444A:  MOVFF  FEC,02
0444E:  MOVFF  FEC,03
04452:  MOVFF  701,FEA
04456:  MOVFF  700,FE9
0445A:  MOVFF  00,FEF
0445E:  MOVFF  01,FEC
04462:  MOVFF  02,FEC
04466:  MOVFF  03,FEC
0446A:  MOVLB  0
0446C:  GOTO   45C8 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xE5,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  7
001CA:  CLRF   x65
001CC:  MOVWF  x64
001CE:  MOVLW  D2
001D0:  ADDWF  x64,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC x65,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xE5,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  7
001E8:  CLRF   x65
001EA:  MOVWF  x64
001EC:  MOVLW  D2
001EE:  ADDWF  x64,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC x65,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1E5,764
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xE5,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xE5
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xE5,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x65
00222:  MOVWF  x64
00224:  MOVLW  D2
00226:  ADDWF  x64,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x65,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xE5,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  7
00244:  CLRF   x65
00246:  MOVWF  x64
00248:  MOVLW  D2
0024A:  ADDWF  x64,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC x65,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
016F6:  MOVLB  7
016F8:  CLRF   x0A
016FA:  CLRF   x09
016FC:  CLRF   x08
016FE:  CLRF   x07
01700:  CLRF   x0E
01702:  CLRF   x0D
01704:  CLRF   x0C
01706:  CLRF   x0B
01708:  CLRF   x12
0170A:  CLRF   x11
0170C:  CLRF   x10
0170E:  CLRF   x0F
01710:  CLRF   x16
01712:  CLRF   x15
01714:  CLRF   x14
01716:  CLRF   x13
01718:  CLRF   x1A
0171A:  CLRF   x19
0171C:  CLRF   x18
0171E:  CLRF   x17
01720:  CLRF   x1E
01722:  CLRF   x1D
01724:  CLRF   x1C
01726:  CLRF   x1B
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01728:  MOVLB  6
0172A:  MOVF   xF6,F
0172C:  BNZ   1758
....................       sQ_ch = sQ_x;
0172E:  MOVLW  01
01730:  MOVLB  7
01732:  MOVWF  x00
01734:  MOVLW  7E
01736:  MOVLB  6
01738:  MOVWF  xFF
....................       cQ_ch = cQ_x;
0173A:  MOVLW  01
0173C:  MOVLB  7
0173E:  MOVWF  x02
01740:  MOVLW  92
01742:  MOVWF  x01
....................       sIn_ch = &sIn_x;
01744:  MOVLW  01
01746:  MOVWF  x04
01748:  MOVLW  CE
0174A:  MOVWF  x03
....................       cIn_ch = &cIn_x;
0174C:  MOVLW  01
0174E:  MOVWF  x06
01750:  MOVLW  CF
01752:  MOVWF  x05
....................    }
01754:  BRA    1782
01756:  MOVLB  6
....................    else if (ch==1){
01758:  DECFSZ xF6,W
0175A:  BRA    1784
....................       sQ_ch = sQ_y;
0175C:  MOVLW  01
0175E:  MOVLB  7
01760:  MOVWF  x00
01762:  MOVLW  A6
01764:  MOVLB  6
01766:  MOVWF  xFF
....................       cQ_ch = cQ_y;
01768:  MOVLW  01
0176A:  MOVLB  7
0176C:  MOVWF  x02
0176E:  MOVLW  BA
01770:  MOVWF  x01
....................       sIn_ch = &sIn_y;
01772:  MOVLW  01
01774:  MOVWF  x04
01776:  MOVLW  D0
01778:  MOVWF  x03
....................       cIn_ch = &cIn_y;
0177A:  MOVLW  01
0177C:  MOVWF  x06
0177E:  MOVLW  D1
01780:  MOVWF  x05
01782:  MOVLB  6
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
01784:  MOVFF  700,721
01788:  MOVFF  6FF,720
0178C:  MOVFF  704,723
01790:  MOVFF  703,722
01794:  MOVFF  6FA,727
01798:  MOVFF  6F9,726
0179C:  MOVFF  6F8,725
017A0:  MOVFF  6F7,724
017A4:  MOVLB  0
017A6:  CALL   0876
....................    push(cQ_ch, cIn_ch, cosCnts);
017AA:  MOVFF  702,721
017AE:  MOVFF  701,720
017B2:  MOVFF  706,723
017B6:  MOVFF  705,722
017BA:  MOVFF  6FE,727
017BE:  MOVFF  6FD,726
017C2:  MOVFF  6FC,725
017C6:  MOVFF  6FB,724
017CA:  CALL   0876
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
017CE:  MOVFF  6FF,FE9
017D2:  MOVLB  7
017D4:  MOVFF  700,FEA
017D8:  MOVFF  FEF,70F
017DC:  MOVFF  FEC,710
017E0:  MOVFF  FEC,711
017E4:  MOVFF  FEC,712
....................    sinMin=sQ_ch[0];
017E8:  MOVFF  6FF,FE9
017EC:  MOVLB  7
017EE:  MOVFF  700,FEA
017F2:  MOVFF  FEF,713
017F6:  MOVFF  FEC,714
017FA:  MOVFF  FEC,715
017FE:  MOVFF  FEC,716
....................    cosMax=cQ_ch[0];
01802:  MOVFF  701,FE9
01806:  MOVFF  702,FEA
0180A:  MOVFF  FEF,717
0180E:  MOVFF  FEC,718
01812:  MOVFF  FEC,719
01816:  MOVFF  FEC,71A
....................    cosMin=cQ_ch[0];
0181A:  MOVFF  701,FE9
0181E:  MOVFF  702,FEA
01822:  MOVFF  FEF,71B
01826:  MOVFF  FEC,71C
0182A:  MOVFF  FEC,71D
0182E:  MOVFF  FEC,71E
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01832:  MOVLW  01
01834:  MOVWF  x1F
01836:  MOVF   x1F,W
01838:  SUBLW  04
0183A:  BTFSS  FD8.0
0183C:  BRA    1B56
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
0183E:  CLRF   x30
01840:  MOVFF  71F,72F
01844:  CLRF   x32
01846:  MOVLW  04
01848:  MOVWF  x31
0184A:  MOVLB  0
0184C:  CALL   0828
01850:  MOVFF  02,03
01854:  MOVF   01,W
01856:  MOVLB  6
01858:  ADDWF  xFF,W
0185A:  MOVWF  FE9
0185C:  MOVLB  7
0185E:  MOVF   x00,W
01860:  ADDWFC 02,W
01862:  MOVWF  FEA
01864:  MOVFF  FEF,00
01868:  MOVFF  FEC,01
0186C:  MOVFF  FEC,02
01870:  MOVFF  FEC,03
01874:  BTFSS  x12.7
01876:  BRA    187E
01878:  BTFSS  03.7
0187A:  BRA    18A0
0187C:  BRA    1882
0187E:  BTFSC  03.7
01880:  BRA    18D8
01882:  MOVF   x12,W
01884:  SUBWF  03,W
01886:  BNC   18D8
01888:  BNZ   18A0
0188A:  MOVF   x11,W
0188C:  SUBWF  02,W
0188E:  BNC   18D8
01890:  BNZ   18A0
01892:  MOVF   x10,W
01894:  SUBWF  01,W
01896:  BNC   18D8
01898:  BNZ   18A0
0189A:  MOVF   00,W
0189C:  SUBWF  x0F,W
0189E:  BC    18D8
018A0:  CLRF   x30
018A2:  MOVFF  71F,72F
018A6:  CLRF   x32
018A8:  MOVLW  04
018AA:  MOVWF  x31
018AC:  MOVLB  0
018AE:  CALL   0828
018B2:  MOVFF  02,03
018B6:  MOVF   01,W
018B8:  MOVLB  6
018BA:  ADDWF  xFF,W
018BC:  MOVWF  FE9
018BE:  MOVLB  7
018C0:  MOVF   x00,W
018C2:  ADDWFC 02,W
018C4:  MOVWF  FEA
018C6:  MOVFF  FEF,70F
018CA:  MOVFF  FEC,710
018CE:  MOVFF  FEC,711
018D2:  MOVFF  FEC,712
018D6:  MOVF   x0F,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
018D8:  CLRF   x30
018DA:  MOVFF  71F,72F
018DE:  CLRF   x32
018E0:  MOVLW  04
018E2:  MOVWF  x31
018E4:  MOVLB  0
018E6:  CALL   0828
018EA:  MOVFF  02,03
018EE:  MOVF   01,W
018F0:  MOVLB  6
018F2:  ADDWF  xFF,W
018F4:  MOVWF  FE9
018F6:  MOVLB  7
018F8:  MOVF   x00,W
018FA:  ADDWFC 02,W
018FC:  MOVWF  FEA
018FE:  MOVFF  FEF,00
01902:  MOVFF  FEC,01
01906:  MOVFF  FEC,02
0190A:  MOVFF  FEC,03
0190E:  BTFSS  03.7
01910:  BRA    1918
01912:  BTFSS  x16.7
01914:  BRA    193A
01916:  BRA    191C
01918:  BTFSC  x16.7
0191A:  BRA    1980
0191C:  MOVF   03,W
0191E:  SUBWF  x16,W
01920:  BNC   1980
01922:  BNZ   193A
01924:  MOVF   02,W
01926:  SUBWF  x15,W
01928:  BNC   1980
0192A:  BNZ   193A
0192C:  MOVF   01,W
0192E:  SUBWF  x14,W
01930:  BNC   1980
01932:  BNZ   193A
01934:  MOVF   x13,W
01936:  SUBWF  00,W
01938:  BC    1980
0193A:  CLRF   x30
0193C:  MOVFF  71F,72F
01940:  CLRF   x32
01942:  MOVLW  04
01944:  MOVWF  x31
01946:  MOVLB  0
01948:  CALL   0828
0194C:  MOVFF  02,03
01950:  MOVF   01,W
01952:  MOVLB  6
01954:  ADDWF  xFF,W
01956:  MOVWF  FE9
01958:  MOVLB  7
0195A:  MOVF   x00,W
0195C:  ADDWFC 02,W
0195E:  MOVWF  FEA
01960:  MOVFF  FEF,713
01964:  MOVFF  FEC,714
01968:  MOVFF  FEC,715
0196C:  MOVFF  FEC,716
01970:  MOVFF  713,00
01974:  MOVFF  714,01
01978:  MOVFF  715,02
0197C:  MOVFF  716,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
01980:  CLRF   x30
01982:  MOVFF  71F,72F
01986:  CLRF   x32
01988:  MOVLW  04
0198A:  MOVWF  x31
0198C:  MOVLB  0
0198E:  CALL   0828
01992:  MOVFF  02,03
01996:  MOVF   01,W
01998:  MOVLB  7
0199A:  ADDWF  x01,W
0199C:  MOVWF  FE9
0199E:  MOVF   x02,W
019A0:  ADDWFC 02,W
019A2:  MOVWF  FEA
019A4:  MOVFF  FEF,00
019A8:  MOVFF  FEC,01
019AC:  MOVFF  FEC,02
019B0:  MOVFF  FEC,03
019B4:  BTFSS  x1A.7
019B6:  BRA    19BE
019B8:  BTFSS  03.7
019BA:  BRA    19E0
019BC:  BRA    19C2
019BE:  BTFSC  03.7
019C0:  BRA    1A24
019C2:  MOVF   x1A,W
019C4:  SUBWF  03,W
019C6:  BNC   1A24
019C8:  BNZ   19E0
019CA:  MOVF   x19,W
019CC:  SUBWF  02,W
019CE:  BNC   1A24
019D0:  BNZ   19E0
019D2:  MOVF   x18,W
019D4:  SUBWF  01,W
019D6:  BNC   1A24
019D8:  BNZ   19E0
019DA:  MOVF   00,W
019DC:  SUBWF  x17,W
019DE:  BC    1A24
019E0:  CLRF   x30
019E2:  MOVFF  71F,72F
019E6:  CLRF   x32
019E8:  MOVLW  04
019EA:  MOVWF  x31
019EC:  MOVLB  0
019EE:  CALL   0828
019F2:  MOVFF  02,03
019F6:  MOVF   01,W
019F8:  MOVLB  7
019FA:  ADDWF  x01,W
019FC:  MOVWF  FE9
019FE:  MOVF   x02,W
01A00:  ADDWFC 02,W
01A02:  MOVWF  FEA
01A04:  MOVFF  FEF,717
01A08:  MOVFF  FEC,718
01A0C:  MOVFF  FEC,719
01A10:  MOVFF  FEC,71A
01A14:  MOVFF  717,00
01A18:  MOVFF  718,01
01A1C:  MOVFF  719,02
01A20:  MOVFF  71A,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A24:  CLRF   x30
01A26:  MOVFF  71F,72F
01A2A:  CLRF   x32
01A2C:  MOVLW  04
01A2E:  MOVWF  x31
01A30:  MOVLB  0
01A32:  CALL   0828
01A36:  MOVFF  02,03
01A3A:  MOVF   01,W
01A3C:  MOVLB  7
01A3E:  ADDWF  x01,W
01A40:  MOVWF  FE9
01A42:  MOVF   x02,W
01A44:  ADDWFC 02,W
01A46:  MOVWF  FEA
01A48:  MOVFF  FEF,00
01A4C:  MOVFF  FEC,01
01A50:  MOVFF  FEC,02
01A54:  MOVFF  FEC,03
01A58:  BTFSS  03.7
01A5A:  BRA    1A62
01A5C:  BTFSS  x1E.7
01A5E:  BRA    1A84
01A60:  BRA    1A66
01A62:  BTFSC  x1E.7
01A64:  BRA    1AC8
01A66:  MOVF   03,W
01A68:  SUBWF  x1E,W
01A6A:  BNC   1AC8
01A6C:  BNZ   1A84
01A6E:  MOVF   02,W
01A70:  SUBWF  x1D,W
01A72:  BNC   1AC8
01A74:  BNZ   1A84
01A76:  MOVF   01,W
01A78:  SUBWF  x1C,W
01A7A:  BNC   1AC8
01A7C:  BNZ   1A84
01A7E:  MOVF   x1B,W
01A80:  SUBWF  00,W
01A82:  BC    1AC8
01A84:  CLRF   x30
01A86:  MOVFF  71F,72F
01A8A:  CLRF   x32
01A8C:  MOVLW  04
01A8E:  MOVWF  x31
01A90:  MOVLB  0
01A92:  CALL   0828
01A96:  MOVFF  02,03
01A9A:  MOVF   01,W
01A9C:  MOVLB  7
01A9E:  ADDWF  x01,W
01AA0:  MOVWF  FE9
01AA2:  MOVF   x02,W
01AA4:  ADDWFC 02,W
01AA6:  MOVWF  FEA
01AA8:  MOVFF  FEF,71B
01AAC:  MOVFF  FEC,71C
01AB0:  MOVFF  FEC,71D
01AB4:  MOVFF  FEC,71E
01AB8:  MOVFF  71B,00
01ABC:  MOVFF  71C,01
01AC0:  MOVFF  71D,02
01AC4:  MOVFF  71E,03
....................       sumSin+=sQ_ch[i];
01AC8:  CLRF   x30
01ACA:  MOVFF  71F,72F
01ACE:  CLRF   x32
01AD0:  MOVLW  04
01AD2:  MOVWF  x31
01AD4:  MOVLB  0
01AD6:  CALL   0828
01ADA:  MOVFF  02,03
01ADE:  MOVF   01,W
01AE0:  MOVLB  6
01AE2:  ADDWF  xFF,W
01AE4:  MOVWF  FE9
01AE6:  MOVLB  7
01AE8:  MOVF   x00,W
01AEA:  ADDWFC 02,W
01AEC:  MOVWF  FEA
01AEE:  MOVFF  FEF,00
01AF2:  MOVFF  FEC,01
01AF6:  MOVFF  FEC,02
01AFA:  MOVFF  FEC,03
01AFE:  MOVF   00,W
01B00:  ADDWF  x07,F
01B02:  MOVF   01,W
01B04:  ADDWFC x08,F
01B06:  MOVF   02,W
01B08:  ADDWFC x09,F
01B0A:  MOVF   03,W
01B0C:  ADDWFC x0A,F
....................       sumCos+=cQ_ch[i];
01B0E:  CLRF   x30
01B10:  MOVFF  71F,72F
01B14:  CLRF   x32
01B16:  MOVLW  04
01B18:  MOVWF  x31
01B1A:  MOVLB  0
01B1C:  CALL   0828
01B20:  MOVFF  02,03
01B24:  MOVF   01,W
01B26:  MOVLB  7
01B28:  ADDWF  x01,W
01B2A:  MOVWF  FE9
01B2C:  MOVF   x02,W
01B2E:  ADDWFC 02,W
01B30:  MOVWF  FEA
01B32:  MOVFF  FEF,00
01B36:  MOVFF  FEC,01
01B3A:  MOVFF  FEC,02
01B3E:  MOVFF  FEC,03
01B42:  MOVF   00,W
01B44:  ADDWF  x0B,F
01B46:  MOVF   01,W
01B48:  ADDWFC x0C,F
01B4A:  MOVF   02,W
01B4C:  ADDWFC x0D,F
01B4E:  MOVF   03,W
01B50:  ADDWFC x0E,F
01B52:  INCF   x1F,F
01B54:  BRA    1836
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01B56:  MOVF   x13,W
01B58:  ADDWF  x0F,W
01B5A:  MOVWF  00
01B5C:  MOVF   x14,W
01B5E:  ADDWFC x10,W
01B60:  MOVWF  01
01B62:  MOVF   x15,W
01B64:  ADDWFC x11,W
01B66:  MOVWF  02
01B68:  MOVF   x16,W
01B6A:  ADDWFC x12,W
01B6C:  MOVWF  03
01B6E:  MOVF   00,W
01B70:  SUBWF  x07,F
01B72:  MOVF   01,W
01B74:  SUBWFB x08,F
01B76:  MOVF   02,W
01B78:  SUBWFB x09,F
01B7A:  MOVF   03,W
01B7C:  SUBWFB x0A,F
....................    sumCos-=(cosMax+cosMin);
01B7E:  MOVF   x1B,W
01B80:  ADDWF  x17,W
01B82:  MOVWF  00
01B84:  MOVF   x1C,W
01B86:  ADDWFC x18,W
01B88:  MOVWF  01
01B8A:  MOVF   x1D,W
01B8C:  ADDWFC x19,W
01B8E:  MOVWF  02
01B90:  MOVF   x1E,W
01B92:  ADDWFC x1A,W
01B94:  MOVWF  03
01B96:  MOVF   00,W
01B98:  SUBWF  x0B,F
01B9A:  MOVF   01,W
01B9C:  SUBWFB x0C,F
01B9E:  MOVF   02,W
01BA0:  SUBWFB x0D,F
01BA2:  MOVF   03,W
01BA4:  SUBWFB x0E,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BA6:  MOVLB  6
01BA8:  MOVF   xF6,W
01BAA:  MULLW  09
01BAC:  MOVF   FF3,W
01BAE:  MOVLB  7
01BB0:  CLRF   x21
01BB2:  MOVWF  x20
01BB4:  MOVLW  01
01BB6:  ADDWF  x20,W
01BB8:  MOVWF  01
01BBA:  MOVLW  00
01BBC:  ADDWFC x21,W
01BBE:  MOVWF  03
01BC0:  MOVF   01,W
01BC2:  ADDLW  D2
01BC4:  MOVWF  FE9
01BC6:  MOVLW  01
01BC8:  ADDWFC 03,W
01BCA:  MOVWF  FEA
01BCC:  MOVFF  FEA,723
01BD0:  MOVFF  FE9,722
01BD4:  BCF    FD8.1
01BD6:  MOVFF  70A,727
01BDA:  MOVFF  709,726
01BDE:  MOVFF  708,725
01BE2:  MOVFF  707,724
01BE6:  CLRF   x2B
01BE8:  CLRF   x2A
01BEA:  CLRF   x29
01BEC:  MOVLW  03
01BEE:  MOVWF  x28
01BF0:  MOVLB  0
01BF2:  RCALL  160C
01BF4:  MOVFF  723,FEA
01BF8:  MOVFF  722,FE9
01BFC:  MOVFF  00,FEF
01C00:  MOVFF  01,FEC
01C04:  MOVFF  02,FEC
01C08:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C0C:  MOVLB  6
01C0E:  MOVF   xF6,W
01C10:  MULLW  09
01C12:  MOVF   FF3,W
01C14:  MOVLB  7
01C16:  CLRF   x21
01C18:  MOVWF  x20
01C1A:  MOVLW  05
01C1C:  ADDWF  x20,W
01C1E:  MOVWF  01
01C20:  MOVLW  00
01C22:  ADDWFC x21,W
01C24:  MOVWF  03
01C26:  MOVF   01,W
01C28:  ADDLW  D2
01C2A:  MOVWF  FE9
01C2C:  MOVLW  01
01C2E:  ADDWFC 03,W
01C30:  MOVWF  FEA
01C32:  MOVFF  FEA,723
01C36:  MOVFF  FE9,722
01C3A:  BCF    FD8.1
01C3C:  MOVFF  70E,727
01C40:  MOVFF  70D,726
01C44:  MOVFF  70C,725
01C48:  MOVFF  70B,724
01C4C:  CLRF   x2B
01C4E:  CLRF   x2A
01C50:  CLRF   x29
01C52:  MOVLW  03
01C54:  MOVWF  x28
01C56:  MOVLB  0
01C58:  RCALL  160C
01C5A:  MOVFF  723,FEA
01C5E:  MOVFF  722,FE9
01C62:  MOVFF  00,FEF
01C66:  MOVFF  01,FEC
01C6A:  MOVFF  02,FEC
01C6E:  MOVFF  03,FEC
01C72:  GOTO   4550 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04470:  MOVLB  6
04472:  CLRF   xF1
04474:  CLRF   xF0
04476:  CLRF   xEF
04478:  CLRF   xEE
0447A:  CLRF   xF5
0447C:  CLRF   xF4
0447E:  CLRF   xF3
04480:  CLRF   xF2
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04482:  MOVLB  1
04484:  MOVF   xE6,W
04486:  MULLW  09
04488:  MOVF   FF3,W
0448A:  MOVLB  6
0448C:  CLRF   xF7
0448E:  MOVWF  xF6
04490:  MOVLW  D2
04492:  ADDWF  xF6,W
04494:  MOVWF  FE9
04496:  MOVLW  01
04498:  ADDWFC xF7,W
0449A:  MOVWF  FEA
0449C:  BTFSC  FEF.1
0449E:  BRA    461C
044A0:  MOVLB  1
044A2:  MOVF   xE6,W
044A4:  MULLW  09
044A6:  MOVF   FF3,W
044A8:  MOVLB  6
044AA:  CLRF   xF9
044AC:  MOVWF  xF8
044AE:  MOVLW  D2
044B0:  ADDWF  xF8,W
044B2:  MOVWF  FE9
044B4:  MOVLW  01
044B6:  ADDWFC xF9,W
044B8:  MOVWF  FEA
044BA:  BTFSS  FEF.0
044BC:  BRA    461C
....................       smData[ch].adcBusy = true;
044BE:  MOVLB  1
044C0:  MOVF   xE6,W
044C2:  MULLW  09
044C4:  MOVF   FF3,W
044C6:  MOVLB  6
044C8:  CLRF   xF7
044CA:  MOVWF  xF6
044CC:  MOVLW  D2
044CE:  ADDWF  xF6,W
044D0:  MOVWF  FE9
044D2:  MOVLW  01
044D4:  ADDWFC xF7,W
044D6:  MOVWF  FEA
044D8:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
044DA:  BCF    FD8.0
044DC:  MOVLB  1
044DE:  RLCF   xE6,W
044E0:  MOVLB  6
044E2:  MOVWF  xF6
044E4:  MOVWF  xF7
044E6:  MOVLB  0
044E8:  CALL   07CE
044EC:  MOVFF  03,6F1
044F0:  MOVFF  02,6F0
044F4:  MOVFF  01,6EF
044F8:  MOVFF  00,6EE
....................       cosNew = ads_read_data(ch*2+1);      
044FC:  BCF    FD8.0
044FE:  MOVLB  1
04500:  RLCF   xE6,W
04502:  ADDLW  01
04504:  MOVLB  6
04506:  MOVWF  xF6
04508:  MOVWF  xF7
0450A:  MOVLB  0
0450C:  CALL   07CE
04510:  MOVFF  03,6F5
04514:  MOVFF  02,6F4
04518:  MOVFF  01,6F3
0451C:  MOVFF  00,6F2
....................       
....................       if (adcFilter){
04520:  MOVLB  1
04522:  BTFSS  x61.0
04524:  BRA    4554
....................          iqm_ring_buffer(ch, sinNew, cosNew);
04526:  MOVFF  1E6,6F6
0452A:  MOVFF  6F1,6FA
0452E:  MOVFF  6F0,6F9
04532:  MOVFF  6EF,6F8
04536:  MOVFF  6EE,6F7
0453A:  MOVFF  6F5,6FE
0453E:  MOVFF  6F4,6FD
04542:  MOVFF  6F3,6FC
04546:  MOVFF  6F2,6FB
0454A:  MOVLB  0
0454C:  GOTO   16F6
....................       }
04550:  BRA    45C0
04552:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04554:  MOVF   xE6,W
04556:  MULLW  09
04558:  MOVF   FF3,W
0455A:  MOVLB  6
0455C:  CLRF   xF7
0455E:  MOVWF  xF6
04560:  MOVLW  01
04562:  ADDWF  xF6,W
04564:  MOVWF  01
04566:  MOVLW  00
04568:  ADDWFC xF7,W
0456A:  MOVWF  03
0456C:  MOVF   01,W
0456E:  ADDLW  D2
04570:  MOVWF  FE9
04572:  MOVLW  01
04574:  ADDWFC 03,W
04576:  MOVWF  FEA
04578:  MOVFF  6EE,FEF
0457C:  MOVFF  6EF,FEC
04580:  MOVFF  6F0,FEC
04584:  MOVFF  6F1,FEC
....................          smData[ch].avgCos = cosNew;
04588:  MOVLB  1
0458A:  MOVF   xE6,W
0458C:  MULLW  09
0458E:  MOVF   FF3,W
04590:  MOVLB  6
04592:  CLRF   xF7
04594:  MOVWF  xF6
04596:  MOVLW  05
04598:  ADDWF  xF6,W
0459A:  MOVWF  01
0459C:  MOVLW  00
0459E:  ADDWFC xF7,W
045A0:  MOVWF  03
045A2:  MOVF   01,W
045A4:  ADDLW  D2
045A6:  MOVWF  FE9
045A8:  MOVLW  01
045AA:  ADDWFC 03,W
045AC:  MOVWF  FEA
045AE:  MOVFF  6F2,FEF
045B2:  MOVFF  6F3,FEC
045B6:  MOVFF  6F4,FEC
045BA:  MOVFF  6F5,FEC
045BE:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045C0:  MOVFF  1E6,6F6
045C4:  GOTO   36B0
....................       ch = !ch;
045C8:  MOVLB  1
045CA:  MOVF   xE6,F
045CC:  BZ    45D2
045CE:  MOVLW  00
045D0:  BRA    45D4
045D2:  MOVLW  01
045D4:  MOVWF  xE6
....................       
....................       smData[!ch].dataReady = false;
045D6:  MOVF   xE6,F
045D8:  BZ    45DE
045DA:  MOVLW  00
045DC:  BRA    45E0
045DE:  MOVLW  01
045E0:  MULLW  09
045E2:  MOVF   FF3,W
045E4:  MOVLB  6
045E6:  CLRF   xF7
045E8:  MOVWF  xF6
045EA:  MOVLW  D2
045EC:  ADDWF  xF6,W
045EE:  MOVWF  FE9
045F0:  MOVLW  01
045F2:  ADDWFC xF7,W
045F4:  MOVWF  FEA
045F6:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045F8:  MOVLB  1
045FA:  MOVF   xE6,F
045FC:  BZ    4602
045FE:  MOVLW  00
04600:  BRA    4604
04602:  MOVLW  01
04604:  MULLW  09
04606:  MOVF   FF3,W
04608:  MOVLB  6
0460A:  CLRF   xF7
0460C:  MOVWF  xF6
0460E:  MOVLW  D2
04610:  ADDWF  xF6,W
04612:  MOVWF  FE9
04614:  MOVLW  01
04616:  ADDWFC xF7,W
04618:  MOVWF  FEA
0461A:  BCF    FEF.1
....................    }
0461C:  MOVLB  0
0461E:  GOTO   A5CA (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
008DC:  MOVLB  6
008DE:  CLRF   xEE
008E0:  CLRF   xEF
008E2:  CLRF   xF0
008E4:  CLRF   xF1
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
008E6:  CLRF   xF2
008E8:  MOVF   xF2,W
008EA:  SUBLW  03
008EC:  BNC   0922
....................       rc0=reg0config;
008EE:  MOVLW  30
008F0:  MOVWF  xEE
....................       rc1=reg1config;
008F2:  MOVLW  10
008F4:  MOVWF  xEF
....................       rc2=reg2config;
008F6:  CLRF   xF0
....................       rc3=reg3config;
008F8:  CLRF   xF1
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
008FA:  MOVFF  6F2,6F4
008FE:  MOVFF  6EE,6F5
00902:  MOVFF  6EF,6F6
00906:  MOVFF  6F0,6F7
0090A:  MOVFF  6F1,6F8
0090E:  MOVLB  0
00910:  BRA    0700
....................       delay_ms(100);
00912:  MOVLW  64
00914:  MOVLB  6
00916:  MOVWF  xF4
00918:  MOVLB  0
0091A:  RCALL  03EE
0091C:  MOVLB  6
0091E:  INCF   xF2,F
00920:  BRA    08E8
....................    }
....................    
....................    if (adcFilter){
00922:  MOVLB  1
00924:  BTFSS  x61.0
00926:  BRA    0A48
....................       for (int i = 0; i < BUFFER_SIZE; i++){
00928:  MOVLB  6
0092A:  CLRF   xF3
0092C:  MOVF   xF3,W
0092E:  SUBLW  04
00930:  BTFSS  FD8.0
00932:  BRA    0A46
....................          ads_start_conv_all();
00934:  MOVLB  0
00936:  BRA    079E
....................          delay_ms(50);
00938:  MOVLW  32
0093A:  MOVLB  6
0093C:  MOVWF  xF4
0093E:  MOVLB  0
00940:  RCALL  03EE
....................          push(sQ_x, &sIn_x, ads_read_data(0));
00942:  MOVLB  6
00944:  CLRF   xF7
00946:  MOVLB  0
00948:  RCALL  07CE
0094A:  MOVFF  03,6F7
0094E:  MOVFF  02,6F6
00952:  MOVFF  01,6F5
00956:  MOVFF  00,6F4
0095A:  MOVLW  01
0095C:  MOVLB  7
0095E:  MOVWF  x21
00960:  MOVLW  7E
00962:  MOVWF  x20
00964:  MOVLW  01
00966:  MOVWF  x23
00968:  MOVLW  CE
0096A:  MOVWF  x22
0096C:  MOVFF  03,727
00970:  MOVFF  02,726
00974:  MOVFF  01,725
00978:  MOVFF  00,724
0097C:  MOVLB  0
0097E:  RCALL  0876
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
00980:  MOVLW  01
00982:  MOVLB  6
00984:  MOVWF  xF7
00986:  MOVLB  0
00988:  RCALL  07CE
0098A:  MOVFF  03,6F7
0098E:  MOVFF  02,6F6
00992:  MOVFF  01,6F5
00996:  MOVFF  00,6F4
0099A:  MOVLW  01
0099C:  MOVLB  7
0099E:  MOVWF  x21
009A0:  MOVLW  92
009A2:  MOVWF  x20
009A4:  MOVLW  01
009A6:  MOVWF  x23
009A8:  MOVLW  CF
009AA:  MOVWF  x22
009AC:  MOVFF  03,727
009B0:  MOVFF  02,726
009B4:  MOVFF  01,725
009B8:  MOVFF  00,724
009BC:  MOVLB  0
009BE:  RCALL  0876
....................          push(sQ_y, &sIn_y, ads_read_data(2));
009C0:  MOVLW  02
009C2:  MOVLB  6
009C4:  MOVWF  xF7
009C6:  MOVLB  0
009C8:  RCALL  07CE
009CA:  MOVFF  03,6F7
009CE:  MOVFF  02,6F6
009D2:  MOVFF  01,6F5
009D6:  MOVFF  00,6F4
009DA:  MOVLW  01
009DC:  MOVLB  7
009DE:  MOVWF  x21
009E0:  MOVLW  A6
009E2:  MOVWF  x20
009E4:  MOVLW  01
009E6:  MOVWF  x23
009E8:  MOVLW  D0
009EA:  MOVWF  x22
009EC:  MOVFF  03,727
009F0:  MOVFF  02,726
009F4:  MOVFF  01,725
009F8:  MOVFF  00,724
009FC:  MOVLB  0
009FE:  RCALL  0876
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A00:  MOVLW  03
00A02:  MOVLB  6
00A04:  MOVWF  xF7
00A06:  MOVLB  0
00A08:  RCALL  07CE
00A0A:  MOVFF  03,6F7
00A0E:  MOVFF  02,6F6
00A12:  MOVFF  01,6F5
00A16:  MOVFF  00,6F4
00A1A:  MOVLW  01
00A1C:  MOVLB  7
00A1E:  MOVWF  x21
00A20:  MOVLW  BA
00A22:  MOVWF  x20
00A24:  MOVLW  01
00A26:  MOVWF  x23
00A28:  MOVLW  D1
00A2A:  MOVWF  x22
00A2C:  MOVFF  03,727
00A30:  MOVFF  02,726
00A34:  MOVFF  01,725
00A38:  MOVFF  00,724
00A3C:  MOVLB  0
00A3E:  RCALL  0876
00A40:  MOVLB  6
00A42:  INCF   xF3,F
00A44:  BRA    092C
00A46:  MOVLB  1
....................       }
....................    }
00A48:  MOVLB  0
00A4A:  GOTO   0AAE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00A4E:  MOVLW  00
00A50:  MOVLB  F
00A52:  MOVWF  x53
00A54:  MOVLW  40
00A56:  MOVWF  x0C
00A58:  MOVLW  00
00A5A:  MOVWF  x14
00A5C:  MOVLW  03
00A5E:  MOVWF  x1C
00A60:  MOVLW  0F
00A62:  MOVWF  x21
00A64:  MOVLW  00
00A66:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00A68:  MOVLW  08
00A6A:  MOVWF  x55
00A6C:  CLRF   x56
00A6E:  CLRF   x52
00A70:  SETF   x57
00A72:  CLRF   F61
00A74:  MOVLW  94
00A76:  MOVWF  x5B
....................    output_high(EN_EXC);
00A78:  MOVLW  E8
00A7A:  MOVWF  F8B
00A7C:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00A7E:  MOVF   x5A,W
00A80:  ANDLW  3F
00A82:  MOVWF  01
00A84:  MOVLW  06
00A86:  MOVWF  x5A
00A88:  BTFSS  x5B.7
00A8A:  BRA    0A9A
00A8C:  MOVF   01,W
00A8E:  SUBLW  06
00A90:  BZ    0A9A
00A92:  BSF    x5B.0
00A94:  NOP   
00A96:  BTFSC  x5B.0
00A98:  BRA    0A96
....................    delay_ms(10);
00A9A:  MOVLW  0A
00A9C:  MOVLB  6
00A9E:  MOVWF  xF4
00AA0:  MOVLB  0
00AA2:  RCALL  03EE
....................    read_adc(ADC_START_ONLY);
00AA4:  MOVLB  F
00AA6:  BSF    x5B.0
00AA8:  NOP   
....................    setup_external_ADCs();
00AAA:  MOVLB  0
00AAC:  BRA    08DC
....................    intTimeoutReg = sensorSampleRate;
00AAE:  MOVLB  1
00AB0:  CLRF   x7D
00AB2:  MOVLW  32
00AB4:  MOVWF  x7C
00AB6:  MOVLB  0
00AB8:  GOTO   A5AC (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046FC:  MOVLB  6
046FE:  MOVF   xF2,W
04700:  MULLW  20
04702:  MOVF   FF3,W
04704:  MOVLB  7
04706:  CLRF   x00
04708:  MOVLB  6
0470A:  MOVWF  xFF
0470C:  MOVLW  0C
0470E:  ADDWF  xFF,W
04710:  MOVWF  01
04712:  MOVLW  00
04714:  MOVLB  7
04716:  ADDWFC x00,W
04718:  MOVWF  03
0471A:  MOVF   01,W
0471C:  ADDLW  20
0471E:  MOVWF  FE9
04720:  MOVLW  00
04722:  ADDWFC 03,W
04724:  MOVWF  FEA
04726:  MOVFF  FEF,747
0472A:  MOVFF  FEC,748
0472E:  MOVFF  FEC,749
04732:  MOVFF  FEC,74A
04736:  MOVLB  6
04738:  MOVF   xF2,W
0473A:  MULLW  20
0473C:  MOVF   FF3,W
0473E:  MOVLB  7
04740:  CLRF   x04
04742:  MOVWF  x03
04744:  MOVLW  10
04746:  ADDWF  x03,W
04748:  MOVWF  01
0474A:  MOVLW  00
0474C:  ADDWFC x04,W
0474E:  MOVWF  03
04750:  MOVF   01,W
04752:  ADDLW  20
04754:  MOVWF  FE9
04756:  MOVLW  00
04758:  ADDWFC 03,W
0475A:  MOVWF  FEA
0475C:  MOVFF  FEF,74B
04760:  MOVFF  FEC,01
04764:  MOVFF  FEC,02
04768:  MOVFF  FEC,03
0476C:  MOVFF  FEA,704
04770:  MOVFF  FE9,703
04774:  BSF    FD8.1
04776:  MOVFF  03,74E
0477A:  MOVFF  02,74D
0477E:  MOVFF  01,74C
04782:  MOVLB  0
04784:  CALL   0E16
04788:  MOVFF  704,FEA
0478C:  MOVFF  703,FE9
04790:  MOVFF  03,6F6
04794:  MOVFF  02,6F5
04798:  MOVFF  01,6F4
0479C:  MOVFF  00,6F3
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
047A0:  MOVLB  6
047A2:  MOVF   xF2,W
047A4:  MULLW  20
047A6:  MOVF   FF3,W
047A8:  MOVLB  7
047AA:  CLRF   x00
047AC:  MOVLB  6
047AE:  MOVWF  xFF
047B0:  MOVLW  1C
047B2:  ADDWF  xFF,W
047B4:  MOVWF  01
047B6:  MOVLW  00
047B8:  MOVLB  7
047BA:  ADDWFC x00,W
047BC:  MOVWF  03
047BE:  MOVF   01,W
047C0:  ADDLW  20
047C2:  MOVWF  01
047C4:  MOVLW  00
047C6:  ADDWFC 03,F
047C8:  MOVFF  01,6FF
047CC:  MOVLB  6
047CE:  MOVFF  03,700
047D2:  MOVFF  03,FEA
047D6:  MOVFF  01,FE9
047DA:  MOVFF  FEF,701
047DE:  MOVFF  FEC,702
047E2:  MOVFF  FEC,703
047E6:  MOVFF  FEC,704
047EA:  MOVF   xF2,W
047EC:  MULLW  20
047EE:  MOVF   FF3,W
047F0:  MOVLB  7
047F2:  CLRF   x06
047F4:  MOVWF  x05
047F6:  MOVLW  04
047F8:  ADDWF  x05,W
047FA:  MOVWF  01
047FC:  MOVLW  00
047FE:  ADDWFC x06,W
04800:  MOVWF  03
04802:  MOVF   01,W
04804:  ADDLW  20
04806:  MOVWF  FE9
04808:  MOVLW  00
0480A:  ADDWFC 03,W
0480C:  MOVWF  FEA
0480E:  MOVFF  FEF,747
04812:  MOVFF  FEC,01
04816:  MOVFF  FEC,02
0481A:  MOVFF  FEC,03
0481E:  MOVFF  6F6,746
04822:  MOVFF  6F5,745
04826:  MOVFF  6F4,744
0482A:  MOVFF  6F3,743
0482E:  MOVFF  03,74A
04832:  MOVFF  02,749
04836:  MOVFF  01,748
0483A:  MOVLB  0
0483C:  CALL   0D20
04840:  BCF    FD8.1
04842:  MOVFF  704,74A
04846:  MOVFF  703,749
0484A:  MOVFF  702,748
0484E:  MOVFF  701,747
04852:  MOVFF  03,74E
04856:  MOVFF  02,74D
0485A:  MOVFF  01,74C
0485E:  MOVFF  00,74B
04862:  CALL   0E16
04866:  MOVFF  700,FEA
0486A:  MOVFF  6FF,FE9
0486E:  MOVFF  00,FEF
04872:  MOVFF  01,FEC
04876:  MOVFF  02,FEC
0487A:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
0487E:  MOVLB  6
04880:  MOVF   xF2,W
04882:  MULLW  20
04884:  MOVF   FF3,W
04886:  MOVLB  7
04888:  CLRF   x00
0488A:  MOVLB  6
0488C:  MOVWF  xFF
0488E:  MOVLW  1C
04890:  ADDWF  xFF,W
04892:  MOVWF  01
04894:  MOVLW  00
04896:  MOVLB  7
04898:  ADDWFC x00,W
0489A:  MOVWF  03
0489C:  MOVF   01,W
0489E:  ADDLW  20
048A0:  MOVWF  FE9
048A2:  MOVLW  00
048A4:  ADDWFC 03,W
048A6:  MOVWF  FEA
048A8:  MOVFF  FEF,747
048AC:  MOVFF  FEC,700
048B0:  MOVFF  FEC,749
048B4:  MOVFF  FEC,74A
048B8:  CLRF   x46
048BA:  CLRF   x45
048BC:  MOVLW  7C
048BE:  MOVWF  x44
048C0:  MOVLW  84
048C2:  MOVWF  x43
048C4:  MOVFF  700,748
048C8:  MOVLB  0
048CA:  CALL   1CD0
048CE:  BNC   4908
048D0:  MOVLB  6
048D2:  MOVF   xF2,W
048D4:  MULLW  20
048D6:  MOVF   FF3,W
048D8:  MOVLB  7
048DA:  CLRF   x00
048DC:  MOVLB  6
048DE:  MOVWF  xFF
048E0:  MOVLW  1C
048E2:  ADDWF  xFF,W
048E4:  MOVWF  01
048E6:  MOVLW  00
048E8:  MOVLB  7
048EA:  ADDWFC x00,W
048EC:  MOVWF  03
048EE:  MOVF   01,W
048F0:  ADDLW  20
048F2:  MOVWF  FE9
048F4:  MOVLW  00
048F6:  ADDWFC 03,W
048F8:  MOVWF  FEA
048FA:  MOVLW  84
048FC:  MOVWF  FEF
048FE:  MOVLW  7C
04900:  MOVWF  FEC
04902:  CLRF   FEC
04904:  CLRF   FEC
04906:  BRA    4990
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
04908:  MOVLB  6
0490A:  MOVF   xF2,W
0490C:  MULLW  20
0490E:  MOVF   FF3,W
04910:  MOVLB  7
04912:  CLRF   x00
04914:  MOVLB  6
04916:  MOVWF  xFF
04918:  MOVLW  1C
0491A:  ADDWF  xFF,W
0491C:  MOVWF  01
0491E:  MOVLW  00
04920:  MOVLB  7
04922:  ADDWFC x00,W
04924:  MOVWF  03
04926:  MOVF   01,W
04928:  ADDLW  20
0492A:  MOVWF  FE9
0492C:  MOVLW  00
0492E:  ADDWFC 03,W
04930:  MOVWF  FEA
04932:  MOVFF  FEF,743
04936:  MOVFF  FEC,700
0493A:  MOVFF  FEC,745
0493E:  MOVFF  FEC,746
04942:  MOVFF  700,744
04946:  CLRF   x4A
04948:  CLRF   x49
0494A:  MOVLW  C0
0494C:  MOVWF  x48
0494E:  MOVLW  82
04950:  MOVWF  x47
04952:  MOVLB  0
04954:  CALL   1CD0
04958:  BNC   4992
0495A:  MOVLB  6
0495C:  MOVF   xF2,W
0495E:  MULLW  20
04960:  MOVF   FF3,W
04962:  MOVLB  7
04964:  CLRF   x00
04966:  MOVLB  6
04968:  MOVWF  xFF
0496A:  MOVLW  1C
0496C:  ADDWF  xFF,W
0496E:  MOVWF  01
04970:  MOVLW  00
04972:  MOVLB  7
04974:  ADDWFC x00,W
04976:  MOVWF  03
04978:  MOVF   01,W
0497A:  ADDLW  20
0497C:  MOVWF  FE9
0497E:  MOVLW  00
04980:  ADDWFC 03,W
04982:  MOVWF  FEA
04984:  MOVLW  82
04986:  MOVWF  FEF
04988:  MOVLW  C0
0498A:  MOVWF  FEC
0498C:  CLRF   FEC
0498E:  CLRF   FEC
04990:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04992:  MOVLB  6
04994:  MOVF   xF2,W
04996:  MULLW  20
04998:  MOVF   FF3,W
0499A:  MOVLB  7
0499C:  CLRF   x00
0499E:  MOVLB  6
049A0:  MOVWF  xFF
049A2:  MOVLW  20
049A4:  ADDWF  xFF,W
049A6:  MOVWF  FE9
049A8:  MOVLW  00
049AA:  MOVLB  7
049AC:  ADDWFC x00,W
049AE:  MOVWF  FEA
049B0:  MOVFF  FEF,747
049B4:  MOVFF  FEC,01
049B8:  MOVFF  FEC,02
049BC:  MOVFF  FEC,03
049C0:  MOVFF  6F6,746
049C4:  MOVFF  6F5,745
049C8:  MOVFF  6F4,744
049CC:  MOVFF  6F3,743
049D0:  MOVFF  03,74A
049D4:  MOVFF  02,749
049D8:  MOVFF  01,748
049DC:  MOVLB  0
049DE:  CALL   0D20
049E2:  MOVFF  03,6FA
049E6:  MOVFF  02,6F9
049EA:  MOVFF  01,6F8
049EE:  MOVFF  00,6F7
049F2:  MOVLB  6
049F4:  MOVF   xF2,W
049F6:  MULLW  20
049F8:  MOVF   FF3,W
049FA:  MOVLB  7
049FC:  CLRF   x02
049FE:  MOVWF  x01
04A00:  MOVLW  08
04A02:  ADDWF  x01,W
04A04:  MOVWF  01
04A06:  MOVLW  00
04A08:  ADDWFC x02,W
04A0A:  MOVWF  03
04A0C:  MOVF   01,W
04A0E:  ADDLW  20
04A10:  MOVWF  FE9
04A12:  MOVLW  00
04A14:  ADDWFC 03,W
04A16:  MOVWF  FEA
04A18:  MOVFF  FEF,701
04A1C:  MOVFF  FEC,702
04A20:  MOVFF  FEC,703
04A24:  MOVFF  FEC,704
04A28:  MOVLB  6
04A2A:  MOVF   xF2,W
04A2C:  MULLW  20
04A2E:  MOVF   FF3,W
04A30:  MOVLB  7
04A32:  CLRF   x06
04A34:  MOVWF  x05
04A36:  MOVLW  10
04A38:  ADDWF  x05,W
04A3A:  MOVWF  01
04A3C:  MOVLW  00
04A3E:  ADDWFC x06,W
04A40:  MOVWF  03
04A42:  MOVF   01,W
04A44:  ADDLW  20
04A46:  MOVWF  FE9
04A48:  MOVLW  00
04A4A:  ADDWFC 03,W
04A4C:  MOVWF  FEA
04A4E:  MOVFF  FEF,747
04A52:  MOVFF  FEC,748
04A56:  MOVFF  FEC,749
04A5A:  MOVFF  FEC,74A
04A5E:  MOVLB  6
04A60:  MOVF   xF2,W
04A62:  MULLW  20
04A64:  MOVF   FF3,W
04A66:  MOVLB  7
04A68:  CLRF   x0A
04A6A:  MOVWF  x09
04A6C:  MOVLW  14
04A6E:  ADDWF  x09,W
04A70:  MOVWF  01
04A72:  MOVLW  00
04A74:  ADDWFC x0A,W
04A76:  MOVWF  03
04A78:  MOVF   01,W
04A7A:  ADDLW  20
04A7C:  MOVWF  FE9
04A7E:  MOVLW  00
04A80:  ADDWFC 03,W
04A82:  MOVWF  FEA
04A84:  MOVFF  FEF,74B
04A88:  MOVFF  FEC,01
04A8C:  MOVFF  FEC,02
04A90:  MOVFF  FEC,03
04A94:  MOVFF  FEA,70A
04A98:  MOVFF  FE9,709
04A9C:  BSF    FD8.1
04A9E:  MOVFF  03,74E
04AA2:  MOVFF  02,74D
04AA6:  MOVFF  01,74C
04AAA:  MOVLB  0
04AAC:  CALL   0E16
04AB0:  MOVFF  70A,FEA
04AB4:  MOVFF  709,FE9
04AB8:  MOVFF  704,746
04ABC:  MOVFF  703,745
04AC0:  MOVFF  702,744
04AC4:  MOVFF  701,743
04AC8:  MOVFF  03,74A
04ACC:  MOVFF  02,749
04AD0:  MOVFF  01,748
04AD4:  MOVFF  00,747
04AD8:  CALL   0D20
04ADC:  MOVFF  03,6FE
04AE0:  MOVFF  02,6FD
04AE4:  MOVFF  01,6FC
04AE8:  MOVFF  00,6FB
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04AEC:  MOVLB  6
04AEE:  MOVF   xF2,W
04AF0:  MULLW  20
04AF2:  MOVF   FF3,W
04AF4:  MOVLB  7
04AF6:  CLRF   x00
04AF8:  MOVLB  6
04AFA:  MOVWF  xFF
04AFC:  MOVLW  18
04AFE:  ADDWF  xFF,W
04B00:  MOVWF  01
04B02:  MOVLW  00
04B04:  MOVLB  7
04B06:  ADDWFC x00,W
04B08:  MOVWF  03
04B0A:  MOVF   01,W
04B0C:  ADDLW  20
04B0E:  MOVWF  01
04B10:  MOVLW  00
04B12:  ADDWFC 03,F
04B14:  MOVFF  01,6FF
04B18:  MOVLB  6
04B1A:  MOVFF  03,700
04B1E:  MOVF   xF2,W
04B20:  MULLW  20
04B22:  MOVF   FF3,W
04B24:  MOVLB  7
04B26:  CLRF   x02
04B28:  MOVWF  x01
04B2A:  MOVLW  1C
04B2C:  ADDWF  x01,W
04B2E:  MOVWF  01
04B30:  MOVLW  00
04B32:  ADDWFC x02,W
04B34:  MOVWF  03
04B36:  MOVF   01,W
04B38:  ADDLW  20
04B3A:  MOVWF  FE9
04B3C:  MOVLW  00
04B3E:  ADDWFC 03,W
04B40:  MOVWF  FEA
04B42:  MOVFF  FEF,74B
04B46:  MOVFF  FEC,01
04B4A:  MOVFF  FEC,02
04B4E:  MOVFF  FEC,03
04B52:  MOVFF  FEA,702
04B56:  MOVFF  FE9,701
04B5A:  BCF    FD8.1
04B5C:  MOVFF  6FA,74A
04B60:  MOVFF  6F9,749
04B64:  MOVFF  6F8,748
04B68:  MOVFF  6F7,747
04B6C:  MOVFF  03,74E
04B70:  MOVFF  02,74D
04B74:  MOVFF  01,74C
04B78:  MOVLB  0
04B7A:  CALL   0E16
04B7E:  MOVFF  702,FEA
04B82:  MOVFF  701,FE9
04B86:  MOVFF  03,706
04B8A:  MOVFF  02,705
04B8E:  MOVFF  01,704
04B92:  MOVFF  00,703
04B96:  BCF    FD8.1
04B98:  MOVFF  03,74A
04B9C:  MOVFF  02,749
04BA0:  MOVFF  01,748
04BA4:  MOVFF  00,747
04BA8:  MOVFF  6FE,74E
04BAC:  MOVFF  6FD,74D
04BB0:  MOVFF  6FC,74C
04BB4:  MOVFF  6FB,74B
04BB8:  CALL   0E16
04BBC:  MOVFF  700,FEA
04BC0:  MOVFF  6FF,FE9
04BC4:  MOVFF  00,FEF
04BC8:  MOVFF  01,FEC
04BCC:  MOVFF  02,FEC
04BD0:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04BD4:  MOVLB  6
04BD6:  MOVF   xF2,W
04BD8:  MULLW  20
04BDA:  MOVF   FF3,W
04BDC:  MOVLB  7
04BDE:  CLRF   x00
04BE0:  MOVLB  6
04BE2:  MOVWF  xFF
04BE4:  MOVLW  18
04BE6:  ADDWF  xFF,W
04BE8:  MOVWF  01
04BEA:  MOVLW  00
04BEC:  MOVLB  7
04BEE:  ADDWFC x00,W
04BF0:  MOVWF  03
04BF2:  MOVF   01,W
04BF4:  ADDLW  20
04BF6:  MOVWF  FE9
04BF8:  MOVLW  00
04BFA:  ADDWFC 03,W
04BFC:  MOVWF  FEA
04BFE:  MOVFF  FEF,747
04C02:  MOVFF  FEC,700
04C06:  MOVFF  FEC,749
04C0A:  MOVFF  FEC,74A
04C0E:  CLRF   x46
04C10:  CLRF   x45
04C12:  MOVLW  7C
04C14:  MOVWF  x44
04C16:  MOVLW  84
04C18:  MOVWF  x43
04C1A:  MOVFF  700,748
04C1E:  MOVLB  0
04C20:  CALL   1CD0
04C24:  BNC   4C5E
04C26:  MOVLB  6
04C28:  MOVF   xF2,W
04C2A:  MULLW  20
04C2C:  MOVF   FF3,W
04C2E:  MOVLB  7
04C30:  CLRF   x00
04C32:  MOVLB  6
04C34:  MOVWF  xFF
04C36:  MOVLW  18
04C38:  ADDWF  xFF,W
04C3A:  MOVWF  01
04C3C:  MOVLW  00
04C3E:  MOVLB  7
04C40:  ADDWFC x00,W
04C42:  MOVWF  03
04C44:  MOVF   01,W
04C46:  ADDLW  20
04C48:  MOVWF  FE9
04C4A:  MOVLW  00
04C4C:  ADDWFC 03,W
04C4E:  MOVWF  FEA
04C50:  MOVLW  84
04C52:  MOVWF  FEF
04C54:  MOVLW  7C
04C56:  MOVWF  FEC
04C58:  CLRF   FEC
04C5A:  CLRF   FEC
04C5C:  BRA    4CE6
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04C5E:  MOVLB  6
04C60:  MOVF   xF2,W
04C62:  MULLW  20
04C64:  MOVF   FF3,W
04C66:  MOVLB  7
04C68:  CLRF   x00
04C6A:  MOVLB  6
04C6C:  MOVWF  xFF
04C6E:  MOVLW  18
04C70:  ADDWF  xFF,W
04C72:  MOVWF  01
04C74:  MOVLW  00
04C76:  MOVLB  7
04C78:  ADDWFC x00,W
04C7A:  MOVWF  03
04C7C:  MOVF   01,W
04C7E:  ADDLW  20
04C80:  MOVWF  FE9
04C82:  MOVLW  00
04C84:  ADDWFC 03,W
04C86:  MOVWF  FEA
04C88:  MOVFF  FEF,743
04C8C:  MOVFF  FEC,700
04C90:  MOVFF  FEC,745
04C94:  MOVFF  FEC,746
04C98:  MOVFF  700,744
04C9C:  CLRF   x4A
04C9E:  CLRF   x49
04CA0:  MOVLW  C0
04CA2:  MOVWF  x48
04CA4:  MOVLW  82
04CA6:  MOVWF  x47
04CA8:  MOVLB  0
04CAA:  CALL   1CD0
04CAE:  BNC   4CE6
04CB0:  MOVLB  6
04CB2:  MOVF   xF2,W
04CB4:  MULLW  20
04CB6:  MOVF   FF3,W
04CB8:  MOVLB  7
04CBA:  CLRF   x00
04CBC:  MOVLB  6
04CBE:  MOVWF  xFF
04CC0:  MOVLW  18
04CC2:  ADDWF  xFF,W
04CC4:  MOVWF  01
04CC6:  MOVLW  00
04CC8:  MOVLB  7
04CCA:  ADDWFC x00,W
04CCC:  MOVWF  03
04CCE:  MOVF   01,W
04CD0:  ADDLW  20
04CD2:  MOVWF  FE9
04CD4:  MOVLW  00
04CD6:  ADDWFC 03,W
04CD8:  MOVWF  FEA
04CDA:  MOVLW  82
04CDC:  MOVWF  FEF
04CDE:  MOVLW  C0
04CE0:  MOVWF  FEC
04CE2:  CLRF   FEC
04CE4:  CLRF   FEC
04CE6:  MOVLB  0
04CE8:  GOTO   4D60 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04CEC:  MOVLB  6
04CEE:  MOVF   xF1,W
04CF0:  MULLW  20
04CF2:  MOVF   FF3,W
04CF4:  CLRF   xF3
04CF6:  MOVWF  xF2
04CF8:  MOVLW  0C
04CFA:  ADDWF  xF2,W
04CFC:  MOVWF  01
04CFE:  MOVLW  00
04D00:  ADDWFC xF3,W
04D02:  MOVWF  03
04D04:  MOVF   01,W
04D06:  ADDLW  20
04D08:  MOVWF  FE9
04D0A:  MOVLW  00
04D0C:  ADDWFC 03,W
04D0E:  MOVWF  FEA
04D10:  MOVFF  FEF,743
04D14:  MOVFF  FEC,744
04D18:  MOVFF  FEC,745
04D1C:  MOVFF  FEC,746
04D20:  MOVF   xF1,W
04D22:  MULLW  20
04D24:  MOVF   FF3,W
04D26:  CLRF   xF7
04D28:  MOVWF  xF6
04D2A:  MOVLW  10
04D2C:  ADDWF  xF6,W
04D2E:  MOVWF  01
04D30:  MOVLW  00
04D32:  ADDWFC xF7,W
04D34:  MOVWF  03
04D36:  MOVF   01,W
04D38:  ADDLW  20
04D3A:  MOVWF  FE9
04D3C:  MOVLW  00
04D3E:  ADDWFC 03,W
04D40:  MOVWF  FEA
04D42:  MOVFF  FEF,747
04D46:  MOVFF  FEC,748
04D4A:  MOVFF  FEC,749
04D4E:  MOVFF  FEC,74A
04D52:  MOVLB  0
04D54:  CALL   1CD0
04D58:  BZ    4D60
04D5A:  MOVFF  6F1,6F2
04D5E:  BRA    46FC
....................    if ((index++) >= numChannels) index = 0;
04D60:  MOVLB  1
04D62:  MOVF   xE7,W
04D64:  INCF   xE7,F
04D66:  SUBLW  01
04D68:  BC    4D6C
04D6A:  CLRF   xE7
04D6C:  MOVLB  0
04D6E:  GOTO   4E5E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00ABC:  CLRF   03
00ABE:  MOVF   F91,W
00AC0:  MOVFF  6F3,F91
00AC4:  RRCF   F94,W
00AC6:  BNC   0AC4
00AC8:  MOVF   F91,W
00ACA:  MOVWF  02
00ACC:  MOVFF  6F2,F91
00AD0:  RRCF   F94,W
00AD2:  BNC   0AD0
00AD4:  MOVF   F91,W
00AD6:  MOVWF  01
00AD8:  MOVFF  6F1,F91
00ADC:  RRCF   F94,W
00ADE:  BNC   0ADC
00AE0:  MOVFF  F91,00
00AE4:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04658:  MOVLB  6
0465A:  MOVF   xF2,F
0465C:  BZ    46AC
....................       if (chMap[0] == ch) output_low(INV_HVX);
0465E:  MOVLW  00
04660:  MOVLB  0
04662:  BTFSC  x60.0
04664:  MOVLW  01
04666:  MOVLB  6
04668:  SUBWF  xF1,W
0466A:  BNZ   4672
0466C:  MOVLW  C4
0466E:  MOVWF  F88
04670:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
04672:  MOVLW  00
04674:  MOVLB  0
04676:  BTFSC  x60.1
04678:  MOVLW  01
0467A:  MOVLB  6
0467C:  SUBWF  xF1,W
0467E:  BNZ   4686
04680:  MOVLW  C4
04682:  MOVWF  F88
04684:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04686:  MOVF   xF1,W
04688:  MULLW  03
0468A:  MOVF   FF3,W
0468C:  CLRF   xF4
0468E:  MOVWF  xF3
04690:  MOVLW  02
04692:  ADDWF  xF3,W
04694:  MOVWF  01
04696:  MOVLW  00
04698:  ADDWFC xF4,W
0469A:  MOVWF  03
0469C:  MOVF   01,W
0469E:  ADDLW  62
046A0:  MOVWF  FE9
046A2:  MOVLW  01
046A4:  ADDWFC 03,W
046A6:  MOVWF  FEA
046A8:  BSF    FEF.0
....................    }
046AA:  BRA    46F8
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
046AC:  MOVLW  00
046AE:  MOVLB  0
046B0:  BTFSC  x60.0
046B2:  MOVLW  01
046B4:  MOVLB  6
046B6:  SUBWF  xF1,W
046B8:  BNZ   46C0
046BA:  MOVLW  C4
046BC:  MOVWF  F88
046BE:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
046C0:  MOVLW  00
046C2:  MOVLB  0
046C4:  BTFSC  x60.1
046C6:  MOVLW  01
046C8:  MOVLB  6
046CA:  SUBWF  xF1,W
046CC:  BNZ   46D4
046CE:  MOVLW  C4
046D0:  MOVWF  F88
046D2:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
046D4:  MOVF   xF1,W
046D6:  MULLW  03
046D8:  MOVF   FF3,W
046DA:  CLRF   xF4
046DC:  MOVWF  xF3
046DE:  MOVLW  02
046E0:  ADDWF  xF3,W
046E2:  MOVWF  01
046E4:  MOVLW  00
046E6:  ADDWFC xF4,W
046E8:  MOVWF  03
046EA:  MOVF   01,W
046EC:  ADDLW  62
046EE:  MOVWF  FE9
046F0:  MOVLW  01
046F2:  ADDWFC 03,W
046F4:  MOVWF  FEA
046F6:  BCF    FEF.0
....................    }
046F8:  MOVLB  0
046FA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04D72:  MOVLB  6
04D74:  CLRF   xF0
04D76:  CLRF   xEF
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04D78:  MOVFF  6EE,6FB
04D7C:  CLRF   xFD
04D7E:  MOVLW  61
04D80:  MOVWF  xFC
04D82:  MOVLB  0
04D84:  RCALL  4622
04D86:  MOVF   01,F
04D88:  BNZ   4E58
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04D8A:  MOVLB  6
04D8C:  MOVF   xEE,W
04D8E:  MULLW  04
04D90:  MOVF   FF3,W
04D92:  CLRF   03
04D94:  ADDLW  68
04D96:  MOVWF  FE9
04D98:  MOVLW  01
04D9A:  ADDWFC 03,W
04D9C:  MOVWF  FEA
04D9E:  MOVFF  FEF,743
04DA2:  MOVFF  FEC,744
04DA6:  MOVFF  FEC,745
04DAA:  MOVFF  FEC,746
04DAE:  MOVLB  7
04DB0:  CLRF   x4A
04DB2:  CLRF   x49
04DB4:  CLRF   x48
04DB6:  CLRF   x47
04DB8:  MOVLB  0
04DBA:  CALL   1CD0
04DBE:  BNC   4DD0
04DC0:  MOVFF  6EE,6F1
04DC4:  MOVLW  01
04DC6:  MOVLB  6
04DC8:  MOVWF  xF2
04DCA:  MOVLB  0
04DCC:  RCALL  4658
04DCE:  BRA    4DDC
....................       else                             invert_voltage(ch, FALSE);
04DD0:  MOVFF  6EE,6F1
04DD4:  MOVLB  6
04DD6:  CLRF   xF2
04DD8:  MOVLB  0
04DDA:  RCALL  4658
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04DDC:  MOVLB  6
04DDE:  MOVF   xEE,W
04DE0:  MULLW  04
04DE2:  MOVF   FF3,W
04DE4:  CLRF   03
04DE6:  ADDLW  68
04DE8:  MOVWF  FE9
04DEA:  MOVLW  01
04DEC:  ADDWFC 03,W
04DEE:  MOVWF  FEA
04DF0:  MOVFF  FEF,00
04DF4:  MOVFF  FEC,01
04DF8:  MOVFF  FEC,02
04DFC:  MOVFF  FEC,03
04E00:  BCF    01.7
04E02:  MOVFF  03,6F4
04E06:  MOVFF  02,6F3
04E0A:  MOVFF  01,6F2
04E0E:  MOVFF  00,6F1
04E12:  MOVFF  03,746
04E16:  MOVFF  02,745
04E1A:  MOVFF  01,744
04E1E:  MOVFF  00,743
04E22:  MOVLW  66
04E24:  MOVLB  7
04E26:  MOVWF  x4A
04E28:  MOVLW  D6
04E2A:  MOVWF  x49
04E2C:  MOVLW  23
04E2E:  MOVWF  x48
04E30:  MOVLW  88
04E32:  MOVWF  x47
04E34:  MOVLB  0
04E36:  CALL   0D20
04E3A:  MOVFF  03,746
04E3E:  MOVFF  02,745
04E42:  MOVFF  01,744
04E46:  MOVFF  00,743
04E4A:  CALL   26C4
04E4E:  MOVFF  02,6F0
04E52:  MOVFF  01,6EF
....................    }
04E56:  BRA    4F4E
....................    else {
....................       pid_task(ch);
04E58:  MOVFF  6EE,6F1
04E5C:  BRA    4CEC
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04E5E:  MOVLB  6
04E60:  MOVF   xEE,W
04E62:  MULLW  20
04E64:  MOVF   FF3,W
04E66:  CLRF   xF2
04E68:  MOVWF  xF1
04E6A:  MOVLW  18
04E6C:  ADDWF  xF1,W
04E6E:  MOVWF  01
04E70:  MOVLW  00
04E72:  ADDWFC xF2,W
04E74:  MOVWF  03
04E76:  MOVF   01,W
04E78:  ADDLW  20
04E7A:  MOVWF  FE9
04E7C:  MOVLW  00
04E7E:  ADDWFC 03,W
04E80:  MOVWF  FEA
04E82:  MOVFF  FEF,743
04E86:  MOVFF  FEC,744
04E8A:  MOVFF  FEC,745
04E8E:  MOVFF  FEC,746
04E92:  MOVLB  7
04E94:  CLRF   x4A
04E96:  CLRF   x49
04E98:  CLRF   x48
04E9A:  CLRF   x47
04E9C:  MOVLB  0
04E9E:  CALL   1CD0
04EA2:  BNC   4EB6
04EA4:  MOVFF  6EE,6F1
04EA8:  MOVLW  01
04EAA:  MOVLB  6
04EAC:  MOVWF  xF2
04EAE:  MOVLB  0
04EB0:  CALL   4658
04EB4:  BRA    4EC4
....................       else                       invert_voltage(ch, FALSE);
04EB6:  MOVFF  6EE,6F1
04EBA:  MOVLB  6
04EBC:  CLRF   xF2
04EBE:  MOVLB  0
04EC0:  CALL   4658
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04EC4:  MOVLB  6
04EC6:  MOVF   xEE,W
04EC8:  MULLW  20
04ECA:  MOVF   FF3,W
04ECC:  CLRF   xF2
04ECE:  MOVWF  xF1
04ED0:  MOVLW  18
04ED2:  ADDWF  xF1,W
04ED4:  MOVWF  01
04ED6:  MOVLW  00
04ED8:  ADDWFC xF2,W
04EDA:  MOVWF  03
04EDC:  MOVF   01,W
04EDE:  ADDLW  20
04EE0:  MOVWF  FE9
04EE2:  MOVLW  00
04EE4:  ADDWFC 03,W
04EE6:  MOVWF  FEA
04EE8:  MOVFF  FEF,00
04EEC:  MOVFF  FEC,01
04EF0:  MOVFF  FEC,02
04EF4:  MOVFF  FEC,03
04EF8:  BCF    01.7
04EFA:  MOVFF  03,6F4
04EFE:  MOVFF  02,6F3
04F02:  MOVFF  01,6F2
04F06:  MOVFF  00,6F1
04F0A:  MOVFF  03,746
04F0E:  MOVFF  02,745
04F12:  MOVFF  01,744
04F16:  MOVFF  00,743
04F1A:  MOVLW  66
04F1C:  MOVLB  7
04F1E:  MOVWF  x4A
04F20:  MOVLW  D6
04F22:  MOVWF  x49
04F24:  MOVLW  23
04F26:  MOVWF  x48
04F28:  MOVLW  88
04F2A:  MOVWF  x47
04F2C:  MOVLB  0
04F2E:  CALL   0D20
04F32:  MOVFF  03,746
04F36:  MOVFF  02,745
04F3A:  MOVFF  01,744
04F3E:  MOVFF  00,743
04F42:  CALL   26C4
04F46:  MOVFF  02,6F0
04F4A:  MOVFF  01,6EF
....................    }
....................    
....................    dacVals[ch].val = txData;
04F4E:  MOVLB  6
04F50:  MOVF   xEE,W
04F52:  MULLW  03
04F54:  MOVF   FF3,W
04F56:  CLRF   xF2
04F58:  MOVWF  xF1
04F5A:  MOVLW  62
04F5C:  ADDWF  xF1,W
04F5E:  MOVWF  FE9
04F60:  MOVLW  01
04F62:  ADDWFC xF2,W
04F64:  MOVWF  FEA
04F66:  MOVFF  6F0,FEC
04F6A:  MOVF   FED,F
04F6C:  MOVFF  6EF,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04F70:  MOVLW  00
04F72:  MOVLB  0
04F74:  BTFSC  x60.0
04F76:  MOVLW  01
04F78:  MOVLB  6
04F7A:  SUBWF  xEE,W
04F7C:  BNZ   4F84
04F7E:  MOVLW  E8
04F80:  MOVWF  F8B
04F82:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04F84:  MOVLW  00
04F86:  MOVLB  0
04F88:  BTFSC  x60.1
04F8A:  MOVLW  01
04F8C:  MOVLB  6
04F8E:  SUBWF  xEE,W
04F90:  BNZ   4F98
04F92:  MOVLW  E8
04F94:  MOVWF  F8B
04F96:  BSF    F86.1
....................    
....................    delay_ms(1);
04F98:  MOVLW  01
04F9A:  MOVWF  xF4
04F9C:  MOVLB  0
04F9E:  CALL   03EE
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04FA2:  MOVLW  00
04FA4:  BTFSC  x60.0
04FA6:  MOVLW  01
04FA8:  MOVLB  6
04FAA:  SUBWF  xEE,W
04FAC:  BNZ   4FB4
04FAE:  MOVLW  E8
04FB0:  MOVWF  F8B
04FB2:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04FB4:  MOVLW  00
04FB6:  MOVLB  0
04FB8:  BTFSC  x60.1
04FBA:  MOVLW  01
04FBC:  MOVLB  6
04FBE:  SUBWF  xEE,W
04FC0:  BNZ   4FC8
04FC2:  MOVLW  E8
04FC4:  MOVWF  F8B
04FC6:  BCF    F86.1
....................    delay_ms(1);
04FC8:  MOVLW  01
04FCA:  MOVWF  xF4
04FCC:  MOVLB  0
04FCE:  CALL   03EE
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04FD2:  MOVLB  6
04FD4:  CLRF   xF4
04FD6:  CLRF   xF3
04FD8:  MOVFF  6F0,6F2
04FDC:  MOVFF  6EF,6F1
04FE0:  MOVLB  0
04FE2:  CALL   0ABC
....................    delay_ms(1);
04FE6:  MOVLW  01
04FE8:  MOVLB  6
04FEA:  MOVWF  xF4
04FEC:  MOVLB  0
04FEE:  CALL   03EE
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04FF2:  MOVLW  00
04FF4:  BTFSC  x60.0
04FF6:  MOVLW  01
04FF8:  MOVLB  6
04FFA:  SUBWF  xEE,W
04FFC:  BNZ   5004
04FFE:  MOVLW  E8
05000:  MOVWF  F8B
05002:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
05004:  MOVLW  00
05006:  MOVLB  0
05008:  BTFSC  x60.1
0500A:  MOVLW  01
0500C:  MOVLB  6
0500E:  SUBWF  xEE,W
05010:  BNZ   5018
05012:  MOVLW  E8
05014:  MOVWF  F8B
05016:  BSF    F86.1
05018:  MOVLB  0
0501A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  zero a stage axis by finding the midpoint                                */ 
.................... /*****************************************************************************/
.................... void zero_stage(channelMap ch){
....................    float maxSP = 0;
....................    float minSP = 0;
....................    
....................    chMode[ch] = MANUAL;          // set channel to manual
....................    manualOutputValues[ch] = 0;   // set channel output to 0%
....................    set_nanoDAC_outputs(ch);
....................    
....................    for (int i=0; i<3; i++){
....................       manualOutputValues[ch] = op_upper_bound;
....................       set_nanoDAC_outputs(ch);
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
0501C:  MOVLB  1
0501E:  MOVF   xE8,W
05020:  XORLW  00
05022:  MOVLB  0
05024:  BZ    502C
05026:  XORLW  01
05028:  BZ    503E
0502A:  BRA    504E
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
0502C:  MOVLB  6
0502E:  CLRF   xEE
05030:  MOVLB  0
05032:  RCALL  4D72
....................          state = 1;
05034:  MOVLW  01
05036:  MOVLB  1
05038:  MOVWF  xE8
....................       break;
0503A:  MOVLB  0
0503C:  BRA    504E
....................       case 1:
....................          set_nanoDAC_outputs(chY);
0503E:  MOVLW  01
05040:  MOVLB  6
05042:  MOVWF  xEE
05044:  MOVLB  0
05046:  RCALL  4D72
....................          state = 0;
05048:  MOVLB  1
0504A:  CLRF   xE8
....................       break;
0504C:  MOVLB  0
....................    }
0504E:  GOTO   A5DC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00AE6:  MOVLB  6
00AE8:  CLRF   xF4
00AEA:  CLRF   xF3
00AEC:  CLRF   xF2
00AEE:  CLRF   xF1
00AF0:  MOVLB  0
00AF2:  RCALL  0ABC
....................    output_low(_SYNC_X);
00AF4:  MOVLW  E8
00AF6:  MOVWF  F8B
00AF8:  BCF    F86.2
....................    output_low(_SYNC_Y);
00AFA:  MOVWF  F8B
00AFC:  BCF    F86.1
....................    output_high(_SYNC_X);
00AFE:  MOVWF  F8B
00B00:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B02:  MOVWF  F8B
00B04:  BSF    F86.1
00B06:  GOTO   A5B0 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B0A:  MOVLB  6
00B0C:  MOVF   xEF,W
00B0E:  SUBLW  03
00B10:  BTFSS  FD8.0
00B12:  BRA    0C90
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B14:  CLRF   xF0
00B16:  MOVF   xF0,W
00B18:  SUBLW  06
00B1A:  BNC   0B6E
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B1C:  MOVLB  7
00B1E:  CLRF   x30
00B20:  MOVFF  6EF,72F
00B24:  CLRF   x32
00B26:  MOVLW  B5
00B28:  MOVWF  x31
00B2A:  MOVLB  0
00B2C:  RCALL  0828
00B2E:  MOVFF  02,6F2
00B32:  MOVFF  01,6F1
00B36:  MOVLW  06
00B38:  MOVLB  6
00B3A:  ADDWF  xF1,F
00B3C:  MOVLW  00
00B3E:  ADDWFC xF2,F
00B40:  MOVLB  7
00B42:  CLRF   x30
00B44:  MOVFF  6F0,72F
00B48:  CLRF   x32
00B4A:  MOVLW  19
00B4C:  MOVWF  x31
00B4E:  MOVLB  0
00B50:  RCALL  0828
00B52:  MOVF   01,W
00B54:  MOVLB  6
00B56:  ADDWF  xF1,F
00B58:  MOVF   02,W
00B5A:  ADDWFC xF2,F
00B5C:  MOVLW  E9
00B5E:  ADDWF  xF1,W
00B60:  MOVWF  FE9
00B62:  MOVLW  01
00B64:  ADDWFC xF2,W
00B66:  MOVWF  FEA
00B68:  CLRF   FEF
00B6A:  INCF   xF0,F
00B6C:  BRA    0B16
....................       }
....................       SERcmd[recNum].t = 0;
00B6E:  MOVLB  7
00B70:  CLRF   x30
00B72:  MOVFF  6EF,72F
00B76:  CLRF   x32
00B78:  MOVLW  B5
00B7A:  MOVWF  x31
00B7C:  MOVLB  0
00B7E:  RCALL  0828
00B80:  MOVFF  01,6F1
00B84:  MOVLW  05
00B86:  MOVLB  6
00B88:  ADDWF  01,W
00B8A:  MOVWF  01
00B8C:  MOVLW  00
00B8E:  ADDWFC 02,W
00B90:  MOVWF  03
00B92:  MOVF   01,W
00B94:  ADDLW  E9
00B96:  MOVWF  FE9
00B98:  MOVLW  01
00B9A:  ADDWFC 03,W
00B9C:  MOVWF  FEA
00B9E:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00BA0:  MOVLB  7
00BA2:  CLRF   x30
00BA4:  MOVFF  6EF,72F
00BA8:  CLRF   x32
00BAA:  MOVLW  B5
00BAC:  MOVWF  x31
00BAE:  MOVLB  0
00BB0:  RCALL  0828
00BB2:  MOVFF  01,6F1
00BB6:  MOVLW  01
00BB8:  MOVLB  6
00BBA:  ADDWF  01,W
00BBC:  MOVWF  01
00BBE:  MOVLW  00
00BC0:  ADDWFC 02,W
00BC2:  MOVWF  03
00BC4:  MOVF   01,W
00BC6:  ADDLW  E9
00BC8:  MOVWF  FE9
00BCA:  MOVLW  01
00BCC:  ADDWFC 03,W
00BCE:  MOVWF  FEA
00BD0:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00BD2:  MOVLB  7
00BD4:  CLRF   x30
00BD6:  MOVFF  6EF,72F
00BDA:  CLRF   x32
00BDC:  MOVLW  B5
00BDE:  MOVWF  x31
00BE0:  MOVLB  0
00BE2:  RCALL  0828
00BE4:  MOVFF  01,6F1
00BE8:  MOVLW  02
00BEA:  MOVLB  6
00BEC:  ADDWF  01,W
00BEE:  MOVWF  01
00BF0:  MOVLW  00
00BF2:  ADDWFC 02,W
00BF4:  MOVWF  03
00BF6:  MOVF   01,W
00BF8:  ADDLW  E9
00BFA:  MOVWF  FE9
00BFC:  MOVLW  01
00BFE:  ADDWFC 03,W
00C00:  MOVWF  FEA
00C02:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C04:  MOVLB  7
00C06:  CLRF   x30
00C08:  MOVFF  6EF,72F
00C0C:  CLRF   x32
00C0E:  MOVLW  B5
00C10:  MOVWF  x31
00C12:  MOVLB  0
00C14:  RCALL  0828
00C16:  MOVFF  01,6F1
00C1A:  MOVLW  03
00C1C:  MOVLB  6
00C1E:  ADDWF  01,W
00C20:  MOVWF  01
00C22:  MOVLW  00
00C24:  ADDWFC 02,W
00C26:  MOVWF  03
00C28:  MOVF   01,W
00C2A:  ADDLW  E9
00C2C:  MOVWF  FE9
00C2E:  MOVLW  01
00C30:  ADDWFC 03,W
00C32:  MOVWF  FEA
00C34:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C36:  MOVLB  7
00C38:  CLRF   x30
00C3A:  MOVFF  6EF,72F
00C3E:  CLRF   x32
00C40:  MOVLW  B5
00C42:  MOVWF  x31
00C44:  MOVLB  0
00C46:  RCALL  0828
00C48:  MOVFF  01,6F1
00C4C:  MOVLW  04
00C4E:  MOVLB  6
00C50:  ADDWF  01,W
00C52:  MOVWF  01
00C54:  MOVLW  00
00C56:  ADDWFC 02,W
00C58:  MOVWF  03
00C5A:  MOVF   01,W
00C5C:  ADDLW  E9
00C5E:  MOVWF  FE9
00C60:  MOVLW  01
00C62:  ADDWFC 03,W
00C64:  MOVWF  FEA
00C66:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00C68:  MOVLB  7
00C6A:  CLRF   x30
00C6C:  MOVFF  6EF,72F
00C70:  CLRF   x32
00C72:  MOVLW  B5
00C74:  MOVWF  x31
00C76:  MOVLB  0
00C78:  RCALL  0828
00C7A:  MOVLW  E9
00C7C:  MOVLB  6
00C7E:  ADDWF  01,W
00C80:  MOVWF  FE9
00C82:  MOVLW  01
00C84:  ADDWFC 02,W
00C86:  MOVWF  FEA
00C88:  BCF    FEF.0
....................       retData[0] = '\0';
00C8A:  MOVLB  4
00C8C:  CLRF   xBF
00C8E:  MOVLB  6
....................    }
00C90:  MOVLB  0
00C92:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
055DE:  MOVLB  7
055E0:  CLRF   x30
055E2:  MOVFF  4BD,72F
055E6:  CLRF   x32
055E8:  MOVLW  B5
055EA:  MOVWF  x31
055EC:  MOVLB  0
055EE:  CALL   0828
055F2:  MOVFF  02,6F0
055F6:  MOVFF  01,6EF
055FA:  MOVLW  E9
055FC:  MOVLB  6
055FE:  ADDWF  01,W
05600:  MOVWF  FE9
05602:  MOVLW  01
05604:  ADDWFC 02,W
05606:  MOVWF  FEA
05608:  BTFSC  FEF.0
0560A:  BRA    562C
....................    {
....................       if (SRI == SWI) return FALSE;
0560C:  MOVLB  4
0560E:  MOVF   xBE,W
05610:  SUBWF  xBD,W
05612:  BNZ   561A
05614:  MOVLW  00
05616:  MOVWF  01
05618:  BRA    5632
....................       SRI +=1;
0561A:  MOVLW  01
0561C:  ADDWF  xBD,F
....................       if (SRI >= numRecords) SRI=0;
0561E:  MOVF   xBD,W
05620:  SUBLW  03
05622:  BC    5626
05624:  CLRF   xBD
05626:  MOVLB  0
05628:  BRA    55DE
0562A:  MOVLB  6
....................    }
....................    return TRUE;
0562C:  MOVLW  01
0562E:  MOVWF  01
05630:  MOVLB  4
05632:  MOVLB  0
05634:  GOTO   A0A4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
0508A:  MOVLW  01
0508C:  MOVLB  4
0508E:  ADDWF  xBE,F
....................    if (SWI >= numRecords) SWI=0;
05090:  MOVF   xBE,W
05092:  SUBLW  03
05094:  BC    5098
05096:  CLRF   xBE
05098:  MOVLB  0
0509A:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,561
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x61.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* pBuff){
....................     output_high(TX_ENABLE);
*
0A054:  MOVLW  93
0A056:  MOVWF  F89
0A058:  BSF    F84.5
....................     delay_us(500);
0A05A:  MOVLW  02
0A05C:  MOVLB  6
0A05E:  MOVWF  xF1
0A060:  MOVLW  FA
0A062:  MOVWF  xFA
0A064:  MOVLB  0
0A066:  CALL   06B6
0A06A:  MOVLB  6
0A06C:  DECFSZ xF1,F
0A06E:  BRA    A060
....................     
....................     fprintf(SERIAL, "%s", pBuff);
0A070:  MOVFF  6F0,FEA
0A074:  MOVFF  6EF,FE9
0A078:  MOVLB  0
0A07A:  CALL   509C
....................     delay_us(500);
0A07E:  MOVLW  02
0A080:  MOVLB  6
0A082:  MOVWF  xF1
0A084:  MOVLW  FA
0A086:  MOVWF  xFA
0A088:  MOVLB  0
0A08A:  CALL   06B6
0A08E:  MOVLB  6
0A090:  DECFSZ xF1,F
0A092:  BRA    A084
....................     
....................     output_low(TX_ENABLE);
0A094:  MOVLW  93
0A096:  MOVWF  F89
0A098:  BCF    F84.5
0A09A:  MOVLB  0
0A09C:  GOTO   A1BC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x5F,W
000F6:  ADDLW  23
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,767
00104:  MOVFF  FE9,766
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  767,FEA
00110:  MOVFF  766,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x5F,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x5F,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x5F
....................       BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x61.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................    }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05052:  CLRF   03
05054:  MOVLB  5
05056:  MOVF   x60,W
05058:  ADDLW  23
0505A:  MOVWF  FE9
0505C:  MOVLW  05
0505E:  ADDWFC 03,W
05060:  MOVWF  FEA
05062:  MOVFF  FEF,6EF
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05066:  MOVLW  01
05068:  ADDWF  x60,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
0506A:  MOVF   x60,W
0506C:  SUBLW  3B
0506E:  BC    5072
05070:  CLRF   x60
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05072:  MOVF   x5F,W
05074:  SUBWF  x60,W
05076:  BNZ   507E
05078:  MOVLB  1
0507A:  BCF    x61.1
0507C:  MOVLB  5
....................    return data;
0507E:  MOVLB  6
05080:  MOVFF  6EF,01
05084:  MOVLB  0
05086:  GOTO   5108 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
050C6:  MOVLB  1
050C8:  BTFSS  x61.1
050CA:  BRA    55D8
050CC:  MOVLB  7
050CE:  CLRF   x30
050D0:  MOVFF  4BE,72F
050D4:  CLRF   x32
050D6:  MOVLW  B5
050D8:  MOVWF  x31
050DA:  MOVLB  0
050DC:  CALL   0828
050E0:  MOVFF  02,6F0
050E4:  MOVFF  01,6EF
050E8:  MOVLW  E9
050EA:  MOVLB  6
050EC:  ADDWF  01,W
050EE:  MOVWF  01
050F0:  MOVLW  01
050F2:  ADDWFC 02,W
050F4:  MOVWF  03
050F6:  MOVFF  01,FE9
050FA:  MOVWF  FEA
050FC:  BTFSS  FEF.0
050FE:  BRA    5104
05100:  MOVLB  1
05102:  BRA    55D8
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
05104:  MOVLB  0
05106:  BRA    5052
05108:  MOVFF  01,6EE
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
0510C:  MOVLB  6
0510E:  MOVF   xEE,W
05110:  SUBLW  0D
05112:  BZ    511A
05114:  MOVF   xEE,W
05116:  SUBLW  20
05118:  BNZ   511C
....................       {
....................       }
0511A:  BRA    55D2
....................       else if (rxChar == UART_SOT_CHAR)
0511C:  MOVF   xEE,W
0511E:  SUBLW  7E
05120:  BNZ   5164
....................       {
....................          resetSERcmd(SWI);
05122:  MOVFF  4BE,6EF
05126:  MOVLB  0
05128:  CALL   0B0A
....................          SERcmd[SWI].t = rxChar;
0512C:  MOVLB  7
0512E:  CLRF   x30
05130:  MOVFF  4BE,72F
05134:  CLRF   x32
05136:  MOVLW  B5
05138:  MOVWF  x31
0513A:  MOVLB  0
0513C:  CALL   0828
05140:  MOVFF  01,6EF
05144:  MOVLW  05
05146:  MOVLB  6
05148:  ADDWF  01,W
0514A:  MOVWF  01
0514C:  MOVLW  00
0514E:  ADDWFC 02,W
05150:  MOVWF  03
05152:  MOVF   01,W
05154:  ADDLW  E9
05156:  MOVWF  FE9
05158:  MOVLW  01
0515A:  ADDWFC 03,W
0515C:  MOVWF  FEA
0515E:  MOVFF  6EE,FEF
....................       }
05162:  BRA    55D2
....................       else if (rxChar >= oneByteCmdTestValue)
05164:  MOVF   xEE,W
05166:  SUBLW  7F
05168:  BC    51D6
....................       {
....................          resetSERcmd(SWI);
0516A:  MOVFF  4BE,6EF
0516E:  MOVLB  0
05170:  CALL   0B0A
....................          SERcmd[SWI].t = rxChar;
05174:  MOVLB  7
05176:  CLRF   x30
05178:  MOVFF  4BE,72F
0517C:  CLRF   x32
0517E:  MOVLW  B5
05180:  MOVWF  x31
05182:  MOVLB  0
05184:  CALL   0828
05188:  MOVFF  01,6EF
0518C:  MOVLW  05
0518E:  MOVLB  6
05190:  ADDWF  01,W
05192:  MOVWF  01
05194:  MOVLW  00
05196:  ADDWFC 02,W
05198:  MOVWF  03
0519A:  MOVF   01,W
0519C:  ADDLW  E9
0519E:  MOVWF  FE9
051A0:  MOVLW  01
051A2:  ADDWFC 03,W
051A4:  MOVWF  FEA
051A6:  MOVFF  6EE,FEF
....................          SERcmd[SWI].full = TRUE;
051AA:  MOVLB  7
051AC:  CLRF   x30
051AE:  MOVFF  4BE,72F
051B2:  CLRF   x32
051B4:  MOVLW  B5
051B6:  MOVWF  x31
051B8:  MOVLB  0
051BA:  CALL   0828
051BE:  MOVLW  E9
051C0:  MOVLB  6
051C2:  ADDWF  01,W
051C4:  MOVWF  FE9
051C6:  MOVLW  01
051C8:  ADDWFC 02,W
051CA:  MOVWF  FEA
051CC:  BSF    FEF.0
....................          setNextSERWriteIndex();
051CE:  MOVLB  0
051D0:  RCALL  508A
....................       }
051D2:  BRA    55D0
051D4:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
051D6:  MOVF   xEE,W
051D8:  SUBLW  0A
051DA:  BTFSS  FD8.2
051DC:  BRA    52EA
....................       {
....................          SERcmd[SWI].full = TRUE;
051DE:  MOVLB  7
051E0:  CLRF   x30
051E2:  MOVFF  4BE,72F
051E6:  CLRF   x32
051E8:  MOVLW  B5
051EA:  MOVWF  x31
051EC:  MOVLB  0
051EE:  CALL   0828
051F2:  MOVLW  E9
051F4:  MOVLB  6
051F6:  ADDWF  01,W
051F8:  MOVWF  FE9
051FA:  MOVLW  01
051FC:  ADDWFC 02,W
051FE:  MOVWF  FEA
05200:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05202:  MOVLB  7
05204:  CLRF   x30
05206:  MOVFF  4BE,72F
0520A:  CLRF   x32
0520C:  MOVLW  B5
0520E:  MOVWF  x31
05210:  MOVLB  0
05212:  CALL   0828
05216:  MOVFF  01,6EF
0521A:  MOVLW  04
0521C:  ADDWF  01,W
0521E:  MOVWF  01
05220:  MOVLW  00
05222:  ADDWFC 02,W
05224:  MOVWF  03
05226:  MOVF   01,W
05228:  ADDLW  E9
0522A:  MOVWF  01
0522C:  MOVLW  01
0522E:  ADDWFC 03,F
05230:  MOVFF  01,6EF
05234:  MOVFF  03,6F0
05238:  MOVLB  7
0523A:  CLRF   x30
0523C:  MOVFF  4BE,72F
05240:  CLRF   x32
05242:  MOVLW  B5
05244:  MOVWF  x31
05246:  MOVLB  0
05248:  CALL   0828
0524C:  MOVFF  01,6F1
05250:  MOVLW  02
05252:  MOVLB  6
05254:  ADDWF  01,W
05256:  MOVWF  01
05258:  MOVLW  00
0525A:  ADDWFC 02,W
0525C:  MOVWF  03
0525E:  MOVF   01,W
05260:  ADDLW  E9
05262:  MOVWF  FE9
05264:  MOVLW  01
05266:  ADDWFC 03,W
05268:  MOVWF  FEA
0526A:  MOVFF  FEF,6F1
0526E:  MOVFF  6F0,FEA
05272:  MOVFF  6EF,FE9
05276:  MOVFF  6F1,FEF
....................          SERcmd[SWI].chrIndex = 0;
0527A:  MOVLB  7
0527C:  CLRF   x30
0527E:  MOVFF  4BE,72F
05282:  CLRF   x32
05284:  MOVLW  B5
05286:  MOVWF  x31
05288:  MOVLB  0
0528A:  CALL   0828
0528E:  MOVFF  01,6EF
05292:  MOVLW  01
05294:  MOVLB  6
05296:  ADDWF  01,W
05298:  MOVWF  01
0529A:  MOVLW  00
0529C:  ADDWFC 02,W
0529E:  MOVWF  03
052A0:  MOVF   01,W
052A2:  ADDLW  E9
052A4:  MOVWF  FE9
052A6:  MOVLW  01
052A8:  ADDWFC 03,W
052AA:  MOVWF  FEA
052AC:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
052AE:  MOVLB  7
052B0:  CLRF   x30
052B2:  MOVFF  4BE,72F
052B6:  CLRF   x32
052B8:  MOVLW  B5
052BA:  MOVWF  x31
052BC:  MOVLB  0
052BE:  CALL   0828
052C2:  MOVFF  01,6EF
052C6:  MOVLW  02
052C8:  MOVLB  6
052CA:  ADDWF  01,W
052CC:  MOVWF  01
052CE:  MOVLW  00
052D0:  ADDWFC 02,W
052D2:  MOVWF  03
052D4:  MOVF   01,W
052D6:  ADDLW  E9
052D8:  MOVWF  FE9
052DA:  MOVLW  01
052DC:  ADDWFC 03,W
052DE:  MOVWF  FEA
052E0:  CLRF   FEF
....................          setNextSERWriteIndex();
052E2:  MOVLB  0
052E4:  RCALL  508A
....................       }
052E6:  BRA    55D0
052E8:  MOVLB  6
....................       else if (rxChar == delimiter)
052EA:  MOVF   xEE,W
052EC:  SUBLW  2C
052EE:  BNZ   53B2
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052F0:  MOVLB  7
052F2:  CLRF   x30
052F4:  MOVFF  4BE,72F
052F8:  CLRF   x32
052FA:  MOVLW  B5
052FC:  MOVWF  x31
052FE:  MOVLB  0
05300:  CALL   0828
05304:  MOVFF  02,6F0
05308:  MOVFF  01,6EF
0530C:  MOVLW  02
0530E:  MOVLB  6
05310:  ADDWF  01,W
05312:  MOVWF  01
05314:  MOVLW  00
05316:  ADDWFC 02,W
05318:  MOVWF  03
0531A:  MOVF   01,W
0531C:  ADDLW  E9
0531E:  MOVWF  FE9
05320:  MOVLW  01
05322:  ADDWFC 03,W
05324:  MOVWF  FEA
05326:  MOVF   FEF,W
05328:  SUBLW  05
0532A:  BNC   539A
....................          {
....................             SERcmd[SWI].paramIndex +=1;
0532C:  MOVLB  7
0532E:  CLRF   x30
05330:  MOVFF  4BE,72F
05334:  CLRF   x32
05336:  MOVLW  B5
05338:  MOVWF  x31
0533A:  MOVLB  0
0533C:  CALL   0828
05340:  MOVFF  01,6EF
05344:  MOVLW  02
05346:  MOVLB  6
05348:  ADDWF  01,W
0534A:  MOVWF  01
0534C:  MOVLW  00
0534E:  ADDWFC 02,W
05350:  MOVWF  03
05352:  MOVF   01,W
05354:  ADDLW  E9
05356:  MOVWF  FE9
05358:  MOVLW  01
0535A:  ADDWFC 03,W
0535C:  MOVWF  FEA
0535E:  MOVLW  01
05360:  ADDWF  FEF,W
05362:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05364:  MOVLB  7
05366:  CLRF   x30
05368:  MOVFF  4BE,72F
0536C:  CLRF   x32
0536E:  MOVLW  B5
05370:  MOVWF  x31
05372:  MOVLB  0
05374:  CALL   0828
05378:  MOVFF  01,6EF
0537C:  MOVLW  01
0537E:  MOVLB  6
05380:  ADDWF  01,W
05382:  MOVWF  01
05384:  MOVLW  00
05386:  ADDWFC 02,W
05388:  MOVWF  03
0538A:  MOVF   01,W
0538C:  ADDLW  E9
0538E:  MOVWF  FE9
05390:  MOVLW  01
05392:  ADDWFC 03,W
05394:  MOVWF  FEA
05396:  CLRF   FEF
....................          }
05398:  BRA    53B0
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
0539A:  MOVFF  4BE,6EF
0539E:  MOVLB  0
053A0:  CALL   0B0A
....................             fprintf(SERIAL, retData);
053A4:  MOVLW  04
053A6:  MOVWF  FEA
053A8:  MOVLW  BF
053AA:  MOVWF  FE9
053AC:  RCALL  509C
053AE:  MOVLB  6
....................          }
....................       }
053B0:  BRA    55D2
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
053B2:  MOVLB  7
053B4:  CLRF   x30
053B6:  MOVFF  4BE,72F
053BA:  CLRF   x32
053BC:  MOVLW  B5
053BE:  MOVWF  x31
053C0:  MOVLB  0
053C2:  CALL   0828
053C6:  MOVFF  02,6F0
053CA:  MOVFF  01,6EF
053CE:  MOVLW  01
053D0:  MOVLB  6
053D2:  ADDWF  01,W
053D4:  MOVWF  01
053D6:  MOVLW  00
053D8:  ADDWFC 02,W
053DA:  MOVWF  03
053DC:  MOVF   01,W
053DE:  ADDLW  E9
053E0:  MOVWF  FE9
053E2:  MOVLW  01
053E4:  ADDWFC 03,W
053E6:  MOVWF  FEA
053E8:  MOVF   FEF,W
053EA:  SUBLW  18
053EC:  BTFSS  FD8.0
053EE:  BRA    55BC
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053F0:  MOVLB  7
053F2:  CLRF   x30
053F4:  MOVFF  4BE,72F
053F8:  CLRF   x32
053FA:  MOVLW  B5
053FC:  MOVWF  x31
053FE:  MOVLB  0
05400:  CALL   0828
05404:  MOVFF  02,6F0
05408:  MOVFF  01,6EF
0540C:  MOVLW  06
0540E:  MOVLB  6
05410:  ADDWF  xEF,F
05412:  MOVLW  00
05414:  ADDWFC xF0,F
05416:  MOVLB  7
05418:  CLRF   x30
0541A:  MOVFF  4BE,72F
0541E:  CLRF   x32
05420:  MOVLW  B5
05422:  MOVWF  x31
05424:  MOVLB  0
05426:  CALL   0828
0542A:  MOVFF  02,6F2
0542E:  MOVFF  01,6F1
05432:  MOVLW  02
05434:  ADDWF  01,W
05436:  MOVWF  01
05438:  MOVLW  00
0543A:  ADDWFC 02,W
0543C:  MOVWF  03
0543E:  MOVF   01,W
05440:  ADDLW  E9
05442:  MOVWF  FE9
05444:  MOVLW  01
05446:  ADDWFC 03,W
05448:  MOVWF  FEA
0544A:  MOVLB  7
0544C:  CLRF   x30
0544E:  MOVFF  FEF,72F
05452:  CLRF   x32
05454:  MOVLW  19
05456:  MOVWF  x31
05458:  MOVLB  0
0545A:  CALL   0828
0545E:  MOVFF  02,03
05462:  MOVF   01,W
05464:  MOVLB  6
05466:  ADDWF  xEF,F
05468:  MOVF   02,W
0546A:  ADDWFC xF0,F
0546C:  MOVLB  7
0546E:  CLRF   x30
05470:  MOVFF  4BE,72F
05474:  CLRF   x32
05476:  MOVLW  B5
05478:  MOVWF  x31
0547A:  MOVLB  0
0547C:  CALL   0828
05480:  MOVFF  01,6F1
05484:  MOVLW  01
05486:  MOVLB  6
05488:  ADDWF  01,W
0548A:  MOVWF  01
0548C:  MOVLW  00
0548E:  ADDWFC 02,W
05490:  MOVWF  03
05492:  MOVF   01,W
05494:  ADDLW  E9
05496:  MOVWF  FE9
05498:  MOVLW  01
0549A:  ADDWFC 03,W
0549C:  MOVWF  FEA
0549E:  MOVF   FEF,W
054A0:  ADDWF  xEF,W
054A2:  MOVWF  01
054A4:  MOVLW  00
054A6:  ADDWFC xF0,W
054A8:  MOVWF  03
054AA:  MOVF   01,W
054AC:  ADDLW  E9
054AE:  MOVWF  FE9
054B0:  MOVLW  01
054B2:  ADDWFC 03,W
054B4:  MOVWF  FEA
054B6:  MOVFF  6EE,FEF
....................             SERcmd[SWI].chrIndex += 1;
054BA:  MOVLB  7
054BC:  CLRF   x30
054BE:  MOVFF  4BE,72F
054C2:  CLRF   x32
054C4:  MOVLW  B5
054C6:  MOVWF  x31
054C8:  MOVLB  0
054CA:  CALL   0828
054CE:  MOVFF  01,6EF
054D2:  MOVLW  01
054D4:  MOVLB  6
054D6:  ADDWF  01,W
054D8:  MOVWF  01
054DA:  MOVLW  00
054DC:  ADDWFC 02,W
054DE:  MOVWF  03
054E0:  MOVF   01,W
054E2:  ADDLW  E9
054E4:  MOVWF  FE9
054E6:  MOVLW  01
054E8:  ADDWFC 03,W
054EA:  MOVWF  FEA
054EC:  MOVLW  01
054EE:  ADDWF  FEF,W
054F0:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054F2:  MOVLB  7
054F4:  CLRF   x30
054F6:  MOVFF  4BE,72F
054FA:  CLRF   x32
054FC:  MOVLW  B5
054FE:  MOVWF  x31
05500:  MOVLB  0
05502:  CALL   0828
05506:  MOVFF  02,6F0
0550A:  MOVFF  01,6EF
0550E:  MOVLW  06
05510:  MOVLB  6
05512:  ADDWF  xEF,F
05514:  MOVLW  00
05516:  ADDWFC xF0,F
05518:  MOVLB  7
0551A:  CLRF   x30
0551C:  MOVFF  4BE,72F
05520:  CLRF   x32
05522:  MOVLW  B5
05524:  MOVWF  x31
05526:  MOVLB  0
05528:  CALL   0828
0552C:  MOVFF  02,6F2
05530:  MOVFF  01,6F1
05534:  MOVLW  02
05536:  ADDWF  01,W
05538:  MOVWF  01
0553A:  MOVLW  00
0553C:  ADDWFC 02,W
0553E:  MOVWF  03
05540:  MOVF   01,W
05542:  ADDLW  E9
05544:  MOVWF  FE9
05546:  MOVLW  01
05548:  ADDWFC 03,W
0554A:  MOVWF  FEA
0554C:  MOVLB  7
0554E:  CLRF   x30
05550:  MOVFF  FEF,72F
05554:  CLRF   x32
05556:  MOVLW  19
05558:  MOVWF  x31
0555A:  MOVLB  0
0555C:  CALL   0828
05560:  MOVFF  02,03
05564:  MOVF   01,W
05566:  MOVLB  6
05568:  ADDWF  xEF,F
0556A:  MOVF   02,W
0556C:  ADDWFC xF0,F
0556E:  MOVLB  7
05570:  CLRF   x30
05572:  MOVFF  4BE,72F
05576:  CLRF   x32
05578:  MOVLW  B5
0557A:  MOVWF  x31
0557C:  MOVLB  0
0557E:  CALL   0828
05582:  MOVFF  01,6F1
05586:  MOVLW  01
05588:  MOVLB  6
0558A:  ADDWF  01,W
0558C:  MOVWF  01
0558E:  MOVLW  00
05590:  ADDWFC 02,W
05592:  MOVWF  03
05594:  MOVF   01,W
05596:  ADDLW  E9
05598:  MOVWF  FE9
0559A:  MOVLW  01
0559C:  ADDWFC 03,W
0559E:  MOVWF  FEA
055A0:  MOVF   FEF,W
055A2:  ADDWF  xEF,W
055A4:  MOVWF  01
055A6:  MOVLW  00
055A8:  ADDWFC xF0,W
055AA:  MOVWF  03
055AC:  MOVF   01,W
055AE:  ADDLW  E9
055B0:  MOVWF  FE9
055B2:  MOVLW  01
055B4:  ADDWFC 03,W
055B6:  MOVWF  FEA
055B8:  CLRF   FEF
....................          }
055BA:  BRA    55D2
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
055BC:  MOVFF  4BE,6EF
055C0:  MOVLB  0
055C2:  CALL   0B0A
....................             fprintf(SERIAL, retData);
055C6:  MOVLW  04
055C8:  MOVWF  FEA
055CA:  MOVLW  BF
055CC:  MOVWF  FE9
055CE:  RCALL  509C
055D0:  MOVLB  6
....................          }
....................       }
055D2:  MOVLB  0
055D4:  BRA    50C6
055D6:  MOVLB  1
....................    }          
055D8:  MOVLB  0
055DA:  GOTO   A5F0 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00C94:  MOVLB  6
00C96:  CLRF   xEE
00C98:  MOVF   xEE,W
00C9A:  SUBLW  03
00C9C:  BNC   0CAC
....................    {
....................       resetSERcmd(i);
00C9E:  MOVFF  6EE,6EF
00CA2:  MOVLB  0
00CA4:  RCALL  0B0A
00CA6:  MOVLB  6
00CA8:  INCF   xEE,F
00CAA:  BRA    0C98
....................    }
....................    enable_interrupts(INT_RDA);
00CAC:  MOVLB  E
00CAE:  BSF    xC0.5
00CB0:  MOVLB  0
00CB2:  GOTO   A5B4 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00CB6:  MOVLB  E
00CB8:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00CBA:  MOVLW  01
00CBC:  MOVWF  FD1
00CBE:  MOVLW  07
00CC0:  MOVWF  FCE
00CC2:  CLRF   FCF
00CC4:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00CC6:  MOVLB  1
00CC8:  CLRF   x73
00CCA:  CLRF   x72
00CCC:  CLRF   x71
00CCE:  CLRF   x70
....................    timeoutReg1 = 0;
00CD0:  CLRF   x77
00CD2:  CLRF   x76
00CD4:  CLRF   x75
00CD6:  CLRF   x74
....................    timeoutReg2 = 0;
00CD8:  CLRF   x7B
00CDA:  CLRF   x7A
00CDC:  CLRF   x79
00CDE:  CLRF   x78
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00CE0:  MOVLB  E
00CE2:  BSF    xC1.0
00CE4:  MOVLB  0
00CE6:  GOTO   A5B8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x73,F
0026C:  BNZ   027C
0026E:  MOVF   x72,F
00270:  BNZ   027C
00272:  MOVF   x71,F
00274:  BNZ   027C
00276:  MOVF   x70,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x70,F
00280:  MOVLW  00
00282:  SUBWFB x71,F
00284:  SUBWFB x72,F
00286:  SUBWFB x73,F
00288:  BRA    0292
0028A:  CLRF   x73
0028C:  CLRF   x72
0028E:  CLRF   x71
00290:  CLRF   x70
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x77,F
00294:  BNZ   02A4
00296:  MOVF   x76,F
00298:  BNZ   02A4
0029A:  MOVF   x75,F
0029C:  BNZ   02A4
0029E:  MOVF   x74,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x74,F
002A8:  MOVLW  00
002AA:  SUBWFB x75,F
002AC:  SUBWFB x76,F
002AE:  SUBWFB x77,F
002B0:  BRA    02BA
002B2:  CLRF   x77
002B4:  CLRF   x76
002B6:  CLRF   x75
002B8:  CLRF   x74
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x7B,F
002BC:  BNZ   02CC
002BE:  MOVF   x7A,F
002C0:  BNZ   02CC
002C2:  MOVF   x79,F
002C4:  BNZ   02CC
002C6:  MOVF   x78,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x78,F
002D0:  MOVLW  00
002D2:  SUBWFB x79,F
002D4:  SUBWFB x7A,F
002D6:  SUBWFB x7B,F
002D8:  BRA    02E2
002DA:  CLRF   x7B
002DC:  CLRF   x7A
002DE:  CLRF   x79
002E0:  CLRF   x78
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x7C,F
002E4:  BNZ   02EA
002E6:  MOVF   x7D,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x64,F
002F0:  MOVLW  00
002F2:  ADDWFC x65,F
002F4:  ADDWFC x66,F
002F6:  ADDWFC x67,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x67,F
002FA:  BNZ   0316
002FC:  MOVF   x66,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x7D,W
00304:  MOVLB  5
00306:  SUBWF  x65,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x7C,W
00310:  MOVLB  5
00312:  SUBWF  x64,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x67
0031E:  CLRF   x66
00320:  CLRF   x65
00322:  CLRF   x64
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);           // sFiltOn
.................... int8 setFilterOff(unsigned int8);          // sFiltOff
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"sFiltOn",  &setFilterOn},
....................    {"sFiltOff", &setFilterOff},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05786:  MOVLW  04
05788:  MOVLB  7
0578A:  MOVWF  x30
0578C:  MOVLW  BF
0578E:  MOVWF  x2F
05790:  MOVLB  0
05792:  RCALL  5638
05794:  MOVFF  02,03
05798:  MOVF   01,W
0579A:  ADDLW  BF
0579C:  MOVLB  6
0579E:  MOVWF  xF9
057A0:  MOVLW  04
057A2:  ADDWFC 02,W
057A4:  MOVWF  xFA
057A6:  MOVFF  FE8,563
057AA:  MOVFF  6F9,562
057AE:  MOVLW  30
057B0:  MOVWF  FF6
057B2:  MOVLW  03
057B4:  MOVWF  FF7
057B6:  MOVLB  0
057B8:  RCALL  5766
057BA:  MOVLW  2C
057BC:  MOVLB  7
057BE:  MOVWF  x3E
057C0:  MOVLB  0
057C2:  RCALL  5670
....................    return SUCCESS;
057C4:  MOVLW  00
057C6:  MOVWF  01
057C8:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
057CA:  MOVLW  04
057CC:  MOVLB  7
057CE:  MOVWF  x30
057D0:  MOVLW  BF
057D2:  MOVWF  x2F
057D4:  MOVLB  0
057D6:  RCALL  5638
057D8:  MOVFF  02,03
057DC:  MOVF   01,W
057DE:  ADDLW  BF
057E0:  MOVLB  6
057E2:  MOVWF  xF9
057E4:  MOVLW  04
057E6:  ADDWFC 02,W
057E8:  MOVWF  xFA
057EA:  MOVFF  FE8,563
057EE:  MOVFF  6F9,562
057F2:  MOVLW  3A
057F4:  MOVWF  FF6
057F6:  MOVLW  03
057F8:  MOVWF  FF7
057FA:  MOVLB  0
057FC:  RCALL  5766
057FE:  MOVLW  2C
05800:  MOVLB  7
05802:  MOVWF  x3E
05804:  MOVLB  0
05806:  RCALL  5670
....................    return SUCCESS;
05808:  MOVLW  00
0580A:  MOVWF  01
0580C:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05D12:  MOVLB  7
05D14:  CLRF   x30
05D16:  MOVFF  683,72F
05D1A:  CLRF   x32
05D1C:  MOVLW  B5
05D1E:  MOVWF  x31
05D20:  MOVLB  0
05D22:  CALL   0828
05D26:  MOVFF  02,6FB
05D2A:  MOVFF  01,6FA
05D2E:  MOVLW  06
05D30:  MOVLB  6
05D32:  ADDWF  xFA,F
05D34:  MOVLW  00
05D36:  ADDWFC xFB,F
05D38:  MOVLW  32
05D3A:  ADDWF  xFA,W
05D3C:  MOVWF  01
05D3E:  MOVLW  00
05D40:  ADDWFC xFB,W
05D42:  MOVWF  03
05D44:  MOVF   01,W
05D46:  ADDLW  E9
05D48:  MOVWF  01
05D4A:  MOVLW  01
05D4C:  ADDWFC 03,F
05D4E:  MOVFF  01,6FA
05D52:  MOVFF  03,6FB
05D56:  MOVFF  03,729
05D5A:  MOVFF  01,728
05D5E:  MOVLB  0
05D60:  RCALL  580E
05D62:  MOVF   01,F
05D64:  BNZ   5D6E
05D66:  MOVLW  02
05D68:  MOVWF  01
05D6A:  BRA    5EBA
05D6C:  BRA    5DCC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05D6E:  MOVLB  7
05D70:  CLRF   x30
05D72:  MOVFF  683,72F
05D76:  CLRF   x32
05D78:  MOVLW  B5
05D7A:  MOVWF  x31
05D7C:  MOVLB  0
05D7E:  CALL   0828
05D82:  MOVFF  02,6FB
05D86:  MOVFF  01,6FA
05D8A:  MOVLW  06
05D8C:  MOVLB  6
05D8E:  ADDWF  xFA,F
05D90:  MOVLW  00
05D92:  ADDWFC xFB,F
05D94:  MOVLW  32
05D96:  ADDWF  xFA,W
05D98:  MOVWF  01
05D9A:  MOVLW  00
05D9C:  ADDWFC xFB,W
05D9E:  MOVWF  03
05DA0:  MOVF   01,W
05DA2:  ADDLW  E9
05DA4:  MOVWF  01
05DA6:  MOVLW  01
05DA8:  ADDWFC 03,F
05DAA:  MOVFF  01,6FA
05DAE:  MOVFF  03,6FB
05DB2:  MOVFF  03,729
05DB6:  MOVFF  01,728
05DBA:  MOVLB  7
05DBC:  CLRF   x2B
05DBE:  CLRF   x2A
05DC0:  MOVLW  0A
05DC2:  MOVWF  x2C
05DC4:  MOVLB  0
05DC6:  RCALL  58FE
05DC8:  MOVFF  01,6F9
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05DCC:  MOVLW  01
05DCE:  MOVLB  6
05DD0:  SUBWF  xF9,W
05DD2:  MOVWF  xFB
05DD4:  CLRF   xFD
05DD6:  MOVLW  60
05DD8:  MOVWF  xFC
05DDA:  MOVLB  0
05DDC:  CALL   4622
05DE0:  BTFSC  01.0
05DE2:  BRA    5E3A
05DE4:  MOVLW  04
05DE6:  MOVLB  7
05DE8:  MOVWF  x30
05DEA:  MOVLW  BF
05DEC:  MOVWF  x2F
05DEE:  MOVLB  0
05DF0:  RCALL  5638
05DF2:  MOVFF  02,03
05DF6:  MOVF   01,W
05DF8:  ADDLW  BF
05DFA:  MOVLB  6
05DFC:  MOVWF  xFA
05DFE:  MOVLW  04
05E00:  ADDWFC 02,W
05E02:  MOVWF  xFB
05E04:  MOVFF  FE8,563
05E08:  MOVFF  6FA,562
05E0C:  MOVFF  6F9,729
05E10:  MOVLW  18
05E12:  MOVLB  7
05E14:  MOVWF  x2A
05E16:  MOVLB  0
05E18:  RCALL  5C52
05E1A:  MOVLW  2C
05E1C:  MOVLB  7
05E1E:  MOVWF  x3E
05E20:  MOVLB  0
05E22:  RCALL  5670
05E24:  MOVLW  58
05E26:  MOVLB  7
05E28:  MOVWF  x3E
05E2A:  MOVLB  0
05E2C:  RCALL  5670
05E2E:  MOVLW  2C
05E30:  MOVLB  7
05E32:  MOVWF  x3E
05E34:  MOVLB  0
05E36:  RCALL  5670
05E38:  BRA    5EB6
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05E3A:  MOVLW  01
05E3C:  MOVLB  6
05E3E:  SUBWF  xF9,W
05E40:  MOVWF  xFB
05E42:  CLRF   xFD
05E44:  MOVLW  60
05E46:  MOVWF  xFC
05E48:  MOVLB  0
05E4A:  CALL   4622
05E4E:  BTFSS  01.0
05E50:  BRA    5EB0
05E52:  MOVLW  04
05E54:  MOVLB  7
05E56:  MOVWF  x30
05E58:  MOVLW  BF
05E5A:  MOVWF  x2F
05E5C:  MOVLB  0
05E5E:  CALL   5638
05E62:  MOVFF  02,03
05E66:  MOVF   01,W
05E68:  ADDLW  BF
05E6A:  MOVLB  6
05E6C:  MOVWF  xFA
05E6E:  MOVLW  04
05E70:  ADDWFC 02,W
05E72:  MOVWF  xFB
05E74:  MOVFF  FE8,563
05E78:  MOVFF  6FA,562
05E7C:  MOVFF  6F9,729
05E80:  MOVLW  18
05E82:  MOVLB  7
05E84:  MOVWF  x2A
05E86:  MOVLB  0
05E88:  RCALL  5C52
05E8A:  MOVLW  2C
05E8C:  MOVLB  7
05E8E:  MOVWF  x3E
05E90:  MOVLB  0
05E92:  CALL   5670
05E96:  MOVLW  59
05E98:  MOVLB  7
05E9A:  MOVWF  x3E
05E9C:  MOVLB  0
05E9E:  CALL   5670
05EA2:  MOVLW  2C
05EA4:  MOVLB  7
05EA6:  MOVWF  x3E
05EA8:  MOVLB  0
05EAA:  CALL   5670
05EAE:  BRA    5EB6
....................    else return INV_PARAM;
05EB0:  MOVLW  02
05EB2:  MOVWF  01
05EB4:  BRA    5EBA
....................    
....................    return SUCCESS;
05EB6:  MOVLW  00
05EB8:  MOVWF  01
05EBA:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05EFE:  MOVLB  7
05F00:  CLRF   x30
05F02:  MOVFF  683,72F
05F06:  CLRF   x32
05F08:  MOVLW  B5
05F0A:  MOVWF  x31
05F0C:  MOVLB  0
05F0E:  CALL   0828
05F12:  MOVFF  02,6FC
05F16:  MOVFF  01,6FB
05F1A:  MOVLW  06
05F1C:  MOVLB  6
05F1E:  ADDWF  xFB,F
05F20:  MOVLW  00
05F22:  ADDWFC xFC,F
05F24:  MOVLW  32
05F26:  ADDWF  xFB,W
05F28:  MOVWF  01
05F2A:  MOVLW  00
05F2C:  ADDWFC xFC,W
05F2E:  MOVWF  03
05F30:  MOVF   01,W
05F32:  ADDLW  E9
05F34:  MOVWF  01
05F36:  MOVLW  01
05F38:  ADDWFC 03,F
05F3A:  MOVFF  01,6FB
05F3E:  MOVFF  03,6FC
05F42:  MOVFF  03,729
05F46:  MOVFF  01,728
05F4A:  MOVLB  0
05F4C:  RCALL  580E
05F4E:  MOVF   01,F
05F50:  BNZ   5F5A
05F52:  MOVLW  02
05F54:  MOVWF  01
05F56:  BRA    60B4
05F58:  BRA    5FB8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05F5A:  MOVLB  7
05F5C:  CLRF   x30
05F5E:  MOVFF  683,72F
05F62:  CLRF   x32
05F64:  MOVLW  B5
05F66:  MOVWF  x31
05F68:  MOVLB  0
05F6A:  CALL   0828
05F6E:  MOVFF  02,6FC
05F72:  MOVFF  01,6FB
05F76:  MOVLW  06
05F78:  MOVLB  6
05F7A:  ADDWF  xFB,F
05F7C:  MOVLW  00
05F7E:  ADDWFC xFC,F
05F80:  MOVLW  32
05F82:  ADDWF  xFB,W
05F84:  MOVWF  01
05F86:  MOVLW  00
05F88:  ADDWFC xFC,W
05F8A:  MOVWF  03
05F8C:  MOVF   01,W
05F8E:  ADDLW  E9
05F90:  MOVWF  01
05F92:  MOVLW  01
05F94:  ADDWFC 03,F
05F96:  MOVFF  01,6FB
05F9A:  MOVFF  03,6FC
05F9E:  MOVFF  03,729
05FA2:  MOVFF  01,728
05FA6:  MOVLB  7
05FA8:  CLRF   x2B
05FAA:  CLRF   x2A
05FAC:  MOVLW  0A
05FAE:  MOVWF  x2C
05FB0:  MOVLB  0
05FB2:  RCALL  58FE
05FB4:  MOVFF  01,6F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05FB8:  MOVLB  7
05FBA:  CLRF   x30
05FBC:  MOVFF  683,72F
05FC0:  CLRF   x32
05FC2:  MOVLW  B5
05FC4:  MOVWF  x31
05FC6:  MOVLB  0
05FC8:  CALL   0828
05FCC:  MOVFF  02,6FC
05FD0:  MOVFF  01,6FB
05FD4:  MOVLW  06
05FD6:  MOVLB  6
05FD8:  ADDWF  xFB,F
05FDA:  MOVLW  00
05FDC:  ADDWFC xFC,F
05FDE:  MOVLW  4B
05FE0:  ADDWF  xFB,W
05FE2:  MOVWF  01
05FE4:  MOVLW  00
05FE6:  ADDWFC xFC,W
05FE8:  MOVWF  03
05FEA:  MOVF   01,W
05FEC:  ADDLW  E9
05FEE:  MOVWF  01
05FF0:  MOVLW  01
05FF2:  ADDWFC 03,F
05FF4:  MOVFF  01,6FB
05FF8:  MOVFF  03,6FC
05FFC:  MOVFF  03,730
06000:  MOVFF  01,72F
06004:  MOVLB  0
06006:  CALL   5638
0600A:  MOVFF  02,03
0600E:  MOVF   01,W
06010:  SUBLW  01
06012:  BNZ   6018
06014:  MOVF   03,F
06016:  BZ    6020
06018:  MOVLW  02
0601A:  MOVWF  01
0601C:  BRA    60B4
0601E:  BRA    6060
....................    else arg2 = SERcmd[rec].p[3][0];
06020:  MOVLB  7
06022:  CLRF   x30
06024:  MOVFF  683,72F
06028:  CLRF   x32
0602A:  MOVLW  B5
0602C:  MOVWF  x31
0602E:  MOVLB  0
06030:  CALL   0828
06034:  MOVFF  02,6FC
06038:  MOVFF  01,6FB
0603C:  MOVLW  06
0603E:  MOVLB  6
06040:  ADDWF  xFB,F
06042:  MOVLW  00
06044:  ADDWFC xFC,F
06046:  MOVLW  4B
06048:  ADDWF  xFB,F
0604A:  MOVLW  00
0604C:  ADDWFC xFC,F
0604E:  MOVLW  E9
06050:  ADDWF  xFB,W
06052:  MOVWF  FE9
06054:  MOVLW  01
06056:  ADDWFC xFC,W
06058:  MOVWF  FEA
0605A:  MOVFF  FEF,6FA
0605E:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06060:  MOVLB  6
06062:  MOVF   xFA,W
06064:  SUBLW  58
06066:  BNZ   6084
06068:  MOVLW  01
0606A:  SUBWF  xF9,W
0606C:  MOVWF  xFB
0606E:  MOVFF  FE8,710
06072:  MOVLB  7
06074:  CLRF   x11
06076:  CLRF   x13
06078:  MOVLW  60
0607A:  MOVWF  x12
0607C:  MOVLB  0
0607E:  RCALL  5EBC
06080:  BRA    60B0
06082:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06084:  MOVF   xFA,W
06086:  SUBLW  59
06088:  BNZ   60A8
0608A:  MOVLW  01
0608C:  SUBWF  xF9,W
0608E:  MOVWF  xFB
06090:  MOVFF  FE8,710
06094:  MOVLW  01
06096:  MOVLB  7
06098:  MOVWF  x11
0609A:  CLRF   x13
0609C:  MOVLW  60
0609E:  MOVWF  x12
060A0:  MOVLB  0
060A2:  RCALL  5EBC
060A4:  BRA    60B0
060A6:  MOVLB  6
....................    else return INV_PARAM;
060A8:  MOVLW  02
060AA:  MOVWF  01
060AC:  MOVLB  0
060AE:  BRA    60B4
....................    
....................    return SUCCESS;
060B0:  MOVLW  00
060B2:  MOVWF  01
060B4:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
060E0:  MOVLB  7
060E2:  CLRF   x30
060E4:  MOVFF  683,72F
060E8:  CLRF   x32
060EA:  MOVLW  B5
060EC:  MOVWF  x31
060EE:  MOVLB  0
060F0:  CALL   0828
060F4:  MOVFF  02,6FB
060F8:  MOVFF  01,6FA
060FC:  MOVLW  06
060FE:  MOVLB  6
06100:  ADDWF  xFA,F
06102:  MOVLW  00
06104:  ADDWFC xFB,F
06106:  MOVLW  32
06108:  ADDWF  xFA,W
0610A:  MOVWF  01
0610C:  MOVLW  00
0610E:  ADDWFC xFB,W
06110:  MOVWF  03
06112:  MOVF   01,W
06114:  ADDLW  E9
06116:  MOVWF  01
06118:  MOVLW  01
0611A:  ADDWFC 03,F
0611C:  MOVFF  01,6FA
06120:  MOVFF  03,6FB
06124:  MOVFF  03,729
06128:  MOVFF  01,728
0612C:  MOVLB  0
0612E:  CALL   580E
06132:  MOVF   01,F
06134:  BNZ   613E
06136:  MOVLW  02
06138:  MOVWF  01
0613A:  BRA    6270
0613C:  BRA    619E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0613E:  MOVLB  7
06140:  CLRF   x30
06142:  MOVFF  683,72F
06146:  CLRF   x32
06148:  MOVLW  B5
0614A:  MOVWF  x31
0614C:  MOVLB  0
0614E:  CALL   0828
06152:  MOVFF  02,6FB
06156:  MOVFF  01,6FA
0615A:  MOVLW  06
0615C:  MOVLB  6
0615E:  ADDWF  xFA,F
06160:  MOVLW  00
06162:  ADDWFC xFB,F
06164:  MOVLW  32
06166:  ADDWF  xFA,W
06168:  MOVWF  01
0616A:  MOVLW  00
0616C:  ADDWFC xFB,W
0616E:  MOVWF  03
06170:  MOVF   01,W
06172:  ADDLW  E9
06174:  MOVWF  01
06176:  MOVLW  01
06178:  ADDWFC 03,F
0617A:  MOVFF  01,6FA
0617E:  MOVFF  03,6FB
06182:  MOVFF  03,729
06186:  MOVFF  01,728
0618A:  MOVLB  7
0618C:  CLRF   x2B
0618E:  CLRF   x2A
06190:  MOVLW  0A
06192:  MOVWF  x2C
06194:  MOVLB  0
06196:  CALL   58FE
0619A:  MOVFF  01,6F9
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
0619E:  MOVLW  01
061A0:  MOVLB  6
061A2:  SUBWF  xF9,W
061A4:  MOVWF  xFB
061A6:  CLRF   xFD
061A8:  MOVLW  61
061AA:  MOVWF  xFC
061AC:  MOVLB  0
061AE:  CALL   4622
061B2:  BTFSC  01.0
061B4:  BRA    6202
061B6:  MOVLW  04
061B8:  MOVLB  7
061BA:  MOVWF  x30
061BC:  MOVLW  BF
061BE:  MOVWF  x2F
061C0:  MOVLB  0
061C2:  CALL   5638
061C6:  MOVFF  02,03
061CA:  MOVF   01,W
061CC:  ADDLW  BF
061CE:  MOVLB  6
061D0:  MOVWF  xFA
061D2:  MOVLW  04
061D4:  ADDWFC 02,W
061D6:  MOVWF  xFB
061D8:  MOVFF  FE8,563
061DC:  MOVFF  6FA,562
061E0:  MOVFF  6F9,729
061E4:  MOVLW  18
061E6:  MOVLB  7
061E8:  MOVWF  x2A
061EA:  MOVLB  0
061EC:  RCALL  5C52
061EE:  MOVLW  42
061F0:  MOVWF  FF6
061F2:  MOVLW  03
061F4:  MOVWF  FF7
061F6:  MOVLW  08
061F8:  MOVLB  6
061FA:  MOVWF  xFD
061FC:  MOVLB  0
061FE:  RCALL  60B6
06200:  BRA    626C
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06202:  MOVLW  01
06204:  MOVLB  6
06206:  SUBWF  xF9,W
06208:  MOVWF  xFB
0620A:  CLRF   xFD
0620C:  MOVLW  61
0620E:  MOVWF  xFC
06210:  MOVLB  0
06212:  CALL   4622
06216:  BTFSS  01.0
06218:  BRA    6266
0621A:  MOVLW  04
0621C:  MOVLB  7
0621E:  MOVWF  x30
06220:  MOVLW  BF
06222:  MOVWF  x2F
06224:  MOVLB  0
06226:  CALL   5638
0622A:  MOVFF  02,03
0622E:  MOVF   01,W
06230:  ADDLW  BF
06232:  MOVLB  6
06234:  MOVWF  xFA
06236:  MOVLW  04
06238:  ADDWFC 02,W
0623A:  MOVWF  xFB
0623C:  MOVFF  FE8,563
06240:  MOVFF  6FA,562
06244:  MOVFF  6F9,729
06248:  MOVLW  18
0624A:  MOVLB  7
0624C:  MOVWF  x2A
0624E:  MOVLB  0
06250:  RCALL  5C52
06252:  MOVLW  4E
06254:  MOVWF  FF6
06256:  MOVLW  03
06258:  MOVWF  FF7
0625A:  MOVLW  08
0625C:  MOVLB  6
0625E:  MOVWF  xFD
06260:  MOVLB  0
06262:  RCALL  60B6
06264:  BRA    626C
....................    else return INV_PARAM;
06266:  MOVLW  02
06268:  MOVWF  01
0626A:  BRA    6270
....................    
....................    return SUCCESS;
0626C:  MOVLW  00
0626E:  MOVWF  01
06270:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06272:  MOVLW  4D
06274:  MOVLB  6
06276:  MOVWF  xFE
06278:  MOVLW  41
0627A:  MOVWF  xFF
0627C:  MOVLW  4E
0627E:  MOVLB  7
06280:  MOVWF  x00
06282:  MOVLW  55
06284:  MOVWF  x01
06286:  MOVLW  41
06288:  MOVWF  x02
0628A:  MOVLW  4C
0628C:  MOVWF  x03
0628E:  CLRF   x04
06290:  MOVLW  06
06292:  MOVLB  6
06294:  MOVWF  xFD
06296:  MOVLW  FE
06298:  MOVWF  xFC
....................    char *s_magsns = "MAGSNS";
0629A:  MOVLW  4D
0629C:  MOVLB  7
0629E:  MOVWF  x07
062A0:  MOVLW  41
062A2:  MOVWF  x08
062A4:  MOVLW  47
062A6:  MOVWF  x09
062A8:  MOVLW  53
062AA:  MOVWF  x0A
062AC:  MOVLW  4E
062AE:  MOVWF  x0B
062B0:  MOVLW  53
062B2:  MOVWF  x0C
062B4:  CLRF   x0D
062B6:  MOVLW  07
062B8:  MOVWF  x06
062BA:  MOVWF  x05
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
062BC:  CLRF   x30
062BE:  MOVFF  683,72F
062C2:  CLRF   x32
062C4:  MOVLW  B5
062C6:  MOVWF  x31
062C8:  MOVLB  0
062CA:  CALL   0828
062CE:  MOVFF  02,70F
062D2:  MOVFF  01,70E
062D6:  MOVLW  06
062D8:  MOVLB  7
062DA:  ADDWF  x0E,F
062DC:  MOVLW  00
062DE:  ADDWFC x0F,F
062E0:  MOVLW  32
062E2:  ADDWF  x0E,W
062E4:  MOVWF  01
062E6:  MOVLW  00
062E8:  ADDWFC x0F,W
062EA:  MOVWF  03
062EC:  MOVF   01,W
062EE:  ADDLW  E9
062F0:  MOVWF  01
062F2:  MOVLW  01
062F4:  ADDWFC 03,F
062F6:  MOVFF  01,70E
062FA:  MOVFF  03,70F
062FE:  MOVFF  03,729
06302:  MOVFF  01,728
06306:  MOVLB  0
06308:  CALL   580E
0630C:  MOVF   01,F
0630E:  BNZ   6318
06310:  MOVLW  02
06312:  MOVWF  01
06314:  BRA    6492
06316:  BRA    6376
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06318:  MOVLB  7
0631A:  CLRF   x30
0631C:  MOVFF  683,72F
06320:  CLRF   x32
06322:  MOVLW  B5
06324:  MOVWF  x31
06326:  MOVLB  0
06328:  CALL   0828
0632C:  MOVFF  02,70F
06330:  MOVFF  01,70E
06334:  MOVLW  06
06336:  MOVLB  7
06338:  ADDWF  x0E,F
0633A:  MOVLW  00
0633C:  ADDWFC x0F,F
0633E:  MOVLW  32
06340:  ADDWF  x0E,W
06342:  MOVWF  01
06344:  MOVLW  00
06346:  ADDWFC x0F,W
06348:  MOVWF  03
0634A:  MOVF   01,W
0634C:  ADDLW  E9
0634E:  MOVWF  01
06350:  MOVLW  01
06352:  ADDWFC 03,F
06354:  MOVFF  01,70E
06358:  MOVFF  03,70F
0635C:  MOVFF  03,729
06360:  MOVFF  01,728
06364:  CLRF   x2B
06366:  CLRF   x2A
06368:  MOVLW  0A
0636A:  MOVWF  x2C
0636C:  MOVLB  0
0636E:  CALL   58FE
06372:  MOVFF  01,6F9
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06376:  MOVLB  7
06378:  CLRF   x30
0637A:  MOVFF  683,72F
0637E:  CLRF   x32
06380:  MOVLW  B5
06382:  MOVWF  x31
06384:  MOVLB  0
06386:  CALL   0828
0638A:  MOVFF  02,70F
0638E:  MOVFF  01,70E
06392:  MOVLW  06
06394:  MOVLB  7
06396:  ADDWF  x0E,F
06398:  MOVLW  00
0639A:  ADDWFC x0F,F
0639C:  MOVLW  4B
0639E:  ADDWF  x0E,W
063A0:  MOVWF  01
063A2:  MOVLW  00
063A4:  ADDWFC x0F,W
063A6:  MOVWF  03
063A8:  MOVF   01,W
063AA:  ADDLW  E9
063AC:  MOVWF  01
063AE:  MOVLW  01
063B0:  ADDWFC 03,F
063B2:  MOVFF  01,70E
063B6:  MOVFF  03,70F
063BA:  MOVFF  03,730
063BE:  MOVFF  01,72F
063C2:  MOVLB  0
063C4:  CALL   5638
063C8:  MOVFF  02,03
063CC:  MOVF   01,W
063CE:  BNZ   63DC
063D0:  MOVF   03,F
063D2:  BNZ   63DC
063D4:  MOVLW  02
063D6:  MOVWF  01
063D8:  BRA    6492
063DA:  BRA    6422
....................    else arg2 = SERcmd[rec].p[3];
063DC:  MOVLB  7
063DE:  CLRF   x30
063E0:  MOVFF  683,72F
063E4:  CLRF   x32
063E6:  MOVLW  B5
063E8:  MOVWF  x31
063EA:  MOVLB  0
063EC:  CALL   0828
063F0:  MOVFF  02,70F
063F4:  MOVFF  01,70E
063F8:  MOVLW  06
063FA:  MOVLB  7
063FC:  ADDWF  x0E,F
063FE:  MOVLW  00
06400:  ADDWFC x0F,F
06402:  MOVLW  4B
06404:  ADDWF  x0E,W
06406:  MOVWF  01
06408:  MOVLW  00
0640A:  ADDWFC x0F,W
0640C:  MOVWF  03
0640E:  MOVF   01,W
06410:  ADDLW  E9
06412:  MOVWF  01
06414:  MOVLW  01
06416:  ADDWFC 03,F
06418:  MOVFF  01,6FA
0641C:  MOVFF  03,6FB
06420:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06422:  MOVFF  6FD,730
06426:  MOVFF  6FC,72F
0642A:  MOVFF  6FB,732
0642E:  MOVFF  6FA,731
06432:  CALL   56EE
06436:  MOVF   01,F
06438:  BNZ   6454
0643A:  MOVLW  01
0643C:  MOVLB  6
0643E:  SUBWF  xF9,W
06440:  MOVLB  7
06442:  MOVWF  x0E
06444:  MOVWF  x10
06446:  CLRF   x11
06448:  CLRF   x13
0644A:  MOVLW  61
0644C:  MOVWF  x12
0644E:  MOVLB  0
06450:  RCALL  5EBC
06452:  BRA    648E
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06454:  MOVFF  706,730
06458:  MOVFF  705,72F
0645C:  MOVFF  6FB,732
06460:  MOVFF  6FA,731
06464:  CALL   56EE
06468:  MOVF   01,F
0646A:  BNZ   6488
0646C:  MOVLW  01
0646E:  MOVLB  6
06470:  SUBWF  xF9,W
06472:  MOVLB  7
06474:  MOVWF  x0E
06476:  MOVWF  x10
06478:  MOVLW  01
0647A:  MOVWF  x11
0647C:  CLRF   x13
0647E:  MOVLW  61
06480:  MOVWF  x12
06482:  MOVLB  0
06484:  RCALL  5EBC
06486:  BRA    648E
....................    else return INV_PARAM;
06488:  MOVLW  02
0648A:  MOVWF  01
0648C:  BRA    6492
....................    
....................    return SUCCESS;
0648E:  MOVLW  00
06490:  MOVWF  01
06492:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0671A:  MOVLB  7
0671C:  CLRF   x30
0671E:  MOVFF  683,72F
06722:  CLRF   x32
06724:  MOVLW  B5
06726:  MOVWF  x31
06728:  MOVLB  0
0672A:  CALL   0828
0672E:  MOVFF  02,701
06732:  MOVFF  01,700
06736:  MOVLW  06
06738:  MOVLB  7
0673A:  ADDWF  x00,F
0673C:  MOVLW  00
0673E:  ADDWFC x01,F
06740:  MOVLW  32
06742:  ADDWF  x00,W
06744:  MOVWF  01
06746:  MOVLW  00
06748:  ADDWFC x01,W
0674A:  MOVWF  03
0674C:  MOVF   01,W
0674E:  ADDLW  E9
06750:  MOVWF  01
06752:  MOVLW  01
06754:  ADDWFC 03,F
06756:  MOVFF  01,700
0675A:  MOVFF  03,701
0675E:  MOVFF  03,729
06762:  MOVFF  01,728
06766:  MOVLB  0
06768:  CALL   580E
0676C:  MOVF   01,F
0676E:  BNZ   6778
06770:  MOVLW  02
06772:  MOVWF  01
06774:  BRA    6BEE
06776:  BRA    67D6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06778:  MOVLB  7
0677A:  CLRF   x30
0677C:  MOVFF  683,72F
06780:  CLRF   x32
06782:  MOVLW  B5
06784:  MOVWF  x31
06786:  MOVLB  0
06788:  CALL   0828
0678C:  MOVFF  02,701
06790:  MOVFF  01,700
06794:  MOVLW  06
06796:  MOVLB  7
06798:  ADDWF  x00,F
0679A:  MOVLW  00
0679C:  ADDWFC x01,F
0679E:  MOVLW  32
067A0:  ADDWF  x00,W
067A2:  MOVWF  01
067A4:  MOVLW  00
067A6:  ADDWFC x01,W
067A8:  MOVWF  03
067AA:  MOVF   01,W
067AC:  ADDLW  E9
067AE:  MOVWF  01
067B0:  MOVLW  01
067B2:  ADDWFC 03,F
067B4:  MOVFF  01,700
067B8:  MOVFF  03,701
067BC:  MOVFF  03,729
067C0:  MOVFF  01,728
067C4:  CLRF   x2B
067C6:  CLRF   x2A
067C8:  MOVLW  0A
067CA:  MOVWF  x2C
067CC:  MOVLB  0
067CE:  CALL   58FE
067D2:  MOVFF  01,6F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
067D6:  MOVLB  7
067D8:  CLRF   x30
067DA:  MOVFF  683,72F
067DE:  CLRF   x32
067E0:  MOVLW  B5
067E2:  MOVWF  x31
067E4:  MOVLB  0
067E6:  CALL   0828
067EA:  MOVFF  02,701
067EE:  MOVFF  01,700
067F2:  MOVLW  06
067F4:  MOVLB  7
067F6:  ADDWF  x00,F
067F8:  MOVLW  00
067FA:  ADDWFC x01,F
067FC:  MOVLW  4B
067FE:  ADDWF  x00,W
06800:  MOVWF  01
06802:  MOVLW  00
06804:  ADDWFC x01,W
06806:  MOVWF  03
06808:  MOVF   01,W
0680A:  ADDLW  E9
0680C:  MOVWF  01
0680E:  MOVLW  01
06810:  ADDWFC 03,F
06812:  MOVFF  01,700
06816:  MOVFF  03,701
0681A:  MOVFF  03,730
0681E:  MOVFF  01,72F
06822:  MOVLB  0
06824:  CALL   5638
06828:  MOVFF  02,03
0682C:  MOVF   01,W
0682E:  SUBLW  01
06830:  BNZ   6836
06832:  MOVF   03,F
06834:  BZ    683E
06836:  MOVLW  02
06838:  MOVWF  01
0683A:  BRA    6BEE
0683C:  BRA    687E
....................    else arg2 = SERcmd[rec].p[3][0];
0683E:  MOVLB  7
06840:  CLRF   x30
06842:  MOVFF  683,72F
06846:  CLRF   x32
06848:  MOVLW  B5
0684A:  MOVWF  x31
0684C:  MOVLB  0
0684E:  CALL   0828
06852:  MOVFF  02,701
06856:  MOVFF  01,700
0685A:  MOVLW  06
0685C:  MOVLB  7
0685E:  ADDWF  x00,F
06860:  MOVLW  00
06862:  ADDWFC x01,F
06864:  MOVLW  4B
06866:  ADDWF  x00,F
06868:  MOVLW  00
0686A:  ADDWFC x01,F
0686C:  MOVLW  E9
0686E:  ADDWF  x00,W
06870:  MOVWF  FE9
06872:  MOVLW  01
06874:  ADDWFC x01,W
06876:  MOVWF  FEA
06878:  MOVFF  FEF,6FA
0687C:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
0687E:  MOVLB  6
06880:  MOVF   xFA,W
06882:  SUBLW  50
06884:  BNZ   6924
06886:  MOVLW  04
06888:  MOVLB  7
0688A:  MOVWF  x30
0688C:  MOVLW  BF
0688E:  MOVWF  x2F
06890:  MOVLB  0
06892:  CALL   5638
06896:  MOVFF  02,03
0689A:  MOVF   01,W
0689C:  ADDLW  BF
0689E:  MOVLB  7
068A0:  MOVWF  x00
068A2:  MOVLW  04
068A4:  ADDWFC 02,W
068A6:  MOVWF  x01
068A8:  MOVLW  01
068AA:  MOVLB  6
068AC:  SUBWF  xF9,W
068AE:  MULLW  20
068B0:  MOVF   FF3,W
068B2:  MOVLB  7
068B4:  CLRF   x03
068B6:  MOVWF  x02
068B8:  MOVLW  20
068BA:  ADDWF  x02,W
068BC:  MOVWF  FE9
068BE:  MOVLW  00
068C0:  ADDWFC x03,W
068C2:  MOVWF  FEA
068C4:  MOVFF  FEF,704
068C8:  MOVFF  FEC,705
068CC:  MOVFF  FEC,706
068D0:  MOVFF  FEC,707
068D4:  MOVFF  701,563
068D8:  MOVFF  700,562
068DC:  MOVFF  6F9,729
068E0:  MOVLW  18
068E2:  MOVWF  x2A
068E4:  MOVLB  0
068E6:  CALL   5C52
068EA:  MOVLW  2C
068EC:  MOVLB  7
068EE:  MOVWF  x3E
068F0:  MOVLB  0
068F2:  CALL   5670
068F6:  MOVLW  89
068F8:  MOVWF  FE9
068FA:  MOVFF  707,734
068FE:  MOVFF  706,733
06902:  MOVFF  705,732
06906:  MOVFF  704,731
0690A:  MOVLW  02
0690C:  MOVLB  7
0690E:  MOVWF  x35
06910:  MOVLB  0
06912:  RCALL  656A
06914:  MOVLW  2C
06916:  MOVLB  7
06918:  MOVWF  x3E
0691A:  MOVLB  0
0691C:  CALL   5670
06920:  BRA    6BEA
06922:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06924:  MOVF   xFA,W
06926:  SUBLW  49
06928:  BNZ   69D0
0692A:  MOVLW  04
0692C:  MOVLB  7
0692E:  MOVWF  x30
06930:  MOVLW  BF
06932:  MOVWF  x2F
06934:  MOVLB  0
06936:  CALL   5638
0693A:  MOVF   01,W
0693C:  ADDLW  BF
0693E:  MOVLB  7
06940:  MOVWF  x00
06942:  MOVLW  04
06944:  ADDWFC 02,W
06946:  MOVWF  x01
06948:  MOVLW  01
0694A:  MOVLB  6
0694C:  SUBWF  xF9,W
0694E:  MULLW  20
06950:  MOVF   FF3,W
06952:  MOVLB  7
06954:  CLRF   x03
06956:  MOVWF  x02
06958:  MOVLW  04
0695A:  ADDWF  x02,W
0695C:  MOVWF  01
0695E:  MOVLW  00
06960:  ADDWFC x03,W
06962:  MOVWF  03
06964:  MOVF   01,W
06966:  ADDLW  20
06968:  MOVWF  FE9
0696A:  MOVLW  00
0696C:  ADDWFC 03,W
0696E:  MOVWF  FEA
06970:  MOVFF  FEF,702
06974:  MOVFF  FEC,703
06978:  MOVFF  FEC,704
0697C:  MOVFF  FEC,705
06980:  MOVFF  701,563
06984:  MOVFF  700,562
06988:  MOVFF  6F9,729
0698C:  MOVLW  18
0698E:  MOVWF  x2A
06990:  MOVLB  0
06992:  CALL   5C52
06996:  MOVLW  2C
06998:  MOVLB  7
0699A:  MOVWF  x3E
0699C:  MOVLB  0
0699E:  CALL   5670
069A2:  MOVLW  89
069A4:  MOVWF  FE9
069A6:  MOVFF  705,734
069AA:  MOVFF  704,733
069AE:  MOVFF  703,732
069B2:  MOVFF  702,731
069B6:  MOVLW  02
069B8:  MOVLB  7
069BA:  MOVWF  x35
069BC:  MOVLB  0
069BE:  RCALL  656A
069C0:  MOVLW  2C
069C2:  MOVLB  7
069C4:  MOVWF  x3E
069C6:  MOVLB  0
069C8:  CALL   5670
069CC:  BRA    6BEA
069CE:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
069D0:  MOVF   xFA,W
069D2:  SUBLW  44
069D4:  BNZ   6A7C
069D6:  MOVLW  04
069D8:  MOVLB  7
069DA:  MOVWF  x30
069DC:  MOVLW  BF
069DE:  MOVWF  x2F
069E0:  MOVLB  0
069E2:  CALL   5638
069E6:  MOVF   01,W
069E8:  ADDLW  BF
069EA:  MOVLB  7
069EC:  MOVWF  x00
069EE:  MOVLW  04
069F0:  ADDWFC 02,W
069F2:  MOVWF  x01
069F4:  MOVLW  01
069F6:  MOVLB  6
069F8:  SUBWF  xF9,W
069FA:  MULLW  20
069FC:  MOVF   FF3,W
069FE:  MOVLB  7
06A00:  CLRF   x03
06A02:  MOVWF  x02
06A04:  MOVLW  08
06A06:  ADDWF  x02,W
06A08:  MOVWF  01
06A0A:  MOVLW  00
06A0C:  ADDWFC x03,W
06A0E:  MOVWF  03
06A10:  MOVF   01,W
06A12:  ADDLW  20
06A14:  MOVWF  FE9
06A16:  MOVLW  00
06A18:  ADDWFC 03,W
06A1A:  MOVWF  FEA
06A1C:  MOVFF  FEF,702
06A20:  MOVFF  FEC,703
06A24:  MOVFF  FEC,704
06A28:  MOVFF  FEC,705
06A2C:  MOVFF  701,563
06A30:  MOVFF  700,562
06A34:  MOVFF  6F9,729
06A38:  MOVLW  18
06A3A:  MOVWF  x2A
06A3C:  MOVLB  0
06A3E:  CALL   5C52
06A42:  MOVLW  2C
06A44:  MOVLB  7
06A46:  MOVWF  x3E
06A48:  MOVLB  0
06A4A:  CALL   5670
06A4E:  MOVLW  89
06A50:  MOVWF  FE9
06A52:  MOVFF  705,734
06A56:  MOVFF  704,733
06A5A:  MOVFF  703,732
06A5E:  MOVFF  702,731
06A62:  MOVLW  02
06A64:  MOVLB  7
06A66:  MOVWF  x35
06A68:  MOVLB  0
06A6A:  RCALL  656A
06A6C:  MOVLW  2C
06A6E:  MOVLB  7
06A70:  MOVWF  x3E
06A72:  MOVLB  0
06A74:  CALL   5670
06A78:  BRA    6BEA
06A7A:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06A7C:  MOVF   xFA,W
06A7E:  SUBLW  41
06A80:  BTFSS  FD8.2
06A82:  BRA    6BE2
06A84:  MOVLW  04
06A86:  MOVLB  7
06A88:  MOVWF  x30
06A8A:  MOVLW  BF
06A8C:  MOVWF  x2F
06A8E:  MOVLB  0
06A90:  CALL   5638
06A94:  MOVF   01,W
06A96:  ADDLW  BF
06A98:  MOVLB  7
06A9A:  MOVWF  x00
06A9C:  MOVLW  04
06A9E:  ADDWFC 02,W
06AA0:  MOVWF  x01
06AA2:  MOVLW  01
06AA4:  MOVLB  6
06AA6:  SUBWF  xF9,W
06AA8:  MULLW  20
06AAA:  MOVF   FF3,W
06AAC:  MOVLB  7
06AAE:  CLRF   x03
06AB0:  MOVWF  x02
06AB2:  MOVLW  20
06AB4:  ADDWF  x02,W
06AB6:  MOVWF  FE9
06AB8:  MOVLW  00
06ABA:  ADDWFC x03,W
06ABC:  MOVWF  FEA
06ABE:  MOVFF  FEF,704
06AC2:  MOVFF  FEC,705
06AC6:  MOVFF  FEC,706
06ACA:  MOVFF  FEC,707
06ACE:  MOVLW  01
06AD0:  MOVLB  6
06AD2:  SUBWF  xF9,W
06AD4:  MULLW  20
06AD6:  MOVF   FF3,W
06AD8:  MOVLB  7
06ADA:  CLRF   x09
06ADC:  MOVWF  x08
06ADE:  MOVLW  04
06AE0:  ADDWF  x08,W
06AE2:  MOVWF  01
06AE4:  MOVLW  00
06AE6:  ADDWFC x09,W
06AE8:  MOVWF  03
06AEA:  MOVF   01,W
06AEC:  ADDLW  20
06AEE:  MOVWF  FE9
06AF0:  MOVLW  00
06AF2:  ADDWFC 03,W
06AF4:  MOVWF  FEA
06AF6:  MOVFF  FEF,708
06AFA:  MOVFF  FEC,709
06AFE:  MOVFF  FEC,70A
06B02:  MOVFF  FEC,70B
06B06:  MOVLW  01
06B08:  MOVLB  6
06B0A:  SUBWF  xF9,W
06B0C:  MULLW  20
06B0E:  MOVF   FF3,W
06B10:  MOVLB  7
06B12:  CLRF   x0D
06B14:  MOVWF  x0C
06B16:  MOVLW  08
06B18:  ADDWF  x0C,W
06B1A:  MOVWF  01
06B1C:  MOVLW  00
06B1E:  ADDWFC x0D,W
06B20:  MOVWF  03
06B22:  MOVF   01,W
06B24:  ADDLW  20
06B26:  MOVWF  FE9
06B28:  MOVLW  00
06B2A:  ADDWFC 03,W
06B2C:  MOVWF  FEA
06B2E:  MOVFF  FEF,70C
06B32:  MOVFF  FEC,70D
06B36:  MOVFF  FEC,70E
06B3A:  MOVFF  FEC,70F
06B3E:  MOVFF  701,563
06B42:  MOVFF  700,562
06B46:  MOVFF  6F9,729
06B4A:  MOVLW  18
06B4C:  MOVWF  x2A
06B4E:  MOVLB  0
06B50:  CALL   5C52
06B54:  MOVLW  2C
06B56:  MOVLB  7
06B58:  MOVWF  x3E
06B5A:  MOVLB  0
06B5C:  CALL   5670
06B60:  MOVLW  89
06B62:  MOVWF  FE9
06B64:  MOVFF  707,734
06B68:  MOVFF  706,733
06B6C:  MOVFF  705,732
06B70:  MOVFF  704,731
06B74:  MOVLW  02
06B76:  MOVLB  7
06B78:  MOVWF  x35
06B7A:  MOVLB  0
06B7C:  RCALL  656A
06B7E:  MOVLW  2C
06B80:  MOVLB  7
06B82:  MOVWF  x3E
06B84:  MOVLB  0
06B86:  CALL   5670
06B8A:  MOVLW  89
06B8C:  MOVWF  FE9
06B8E:  MOVFF  70B,734
06B92:  MOVFF  70A,733
06B96:  MOVFF  709,732
06B9A:  MOVFF  708,731
06B9E:  MOVLW  02
06BA0:  MOVLB  7
06BA2:  MOVWF  x35
06BA4:  MOVLB  0
06BA6:  RCALL  656A
06BA8:  MOVLW  2C
06BAA:  MOVLB  7
06BAC:  MOVWF  x3E
06BAE:  MOVLB  0
06BB0:  CALL   5670
06BB4:  MOVLW  89
06BB6:  MOVWF  FE9
06BB8:  MOVFF  70F,734
06BBC:  MOVFF  70E,733
06BC0:  MOVFF  70D,732
06BC4:  MOVFF  70C,731
06BC8:  MOVLW  02
06BCA:  MOVLB  7
06BCC:  MOVWF  x35
06BCE:  MOVLB  0
06BD0:  RCALL  656A
06BD2:  MOVLW  2C
06BD4:  MOVLB  7
06BD6:  MOVWF  x3E
06BD8:  MOVLB  0
06BDA:  CALL   5670
06BDE:  BRA    6BEA
06BE0:  MOVLB  6
....................    else return INV_PARAM;
06BE2:  MOVLW  02
06BE4:  MOVWF  01
06BE6:  MOVLB  0
06BE8:  BRA    6BEE
....................    
....................    return SUCCESS;
06BEA:  MOVLW  00
06BEC:  MOVWF  01
06BEE:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06F0C:  MOVLB  7
06F0E:  CLRF   x30
06F10:  MOVFF  683,72F
06F14:  CLRF   x32
06F16:  MOVLW  B5
06F18:  MOVWF  x31
06F1A:  MOVLB  0
06F1C:  CALL   0828
06F20:  MOVFF  02,700
06F24:  MOVFF  01,6FF
06F28:  MOVLW  06
06F2A:  MOVLB  6
06F2C:  ADDWF  xFF,F
06F2E:  MOVLW  00
06F30:  MOVLB  7
06F32:  ADDWFC x00,F
06F34:  MOVLW  32
06F36:  MOVLB  6
06F38:  ADDWF  xFF,W
06F3A:  MOVWF  01
06F3C:  MOVLW  00
06F3E:  MOVLB  7
06F40:  ADDWFC x00,W
06F42:  MOVWF  03
06F44:  MOVF   01,W
06F46:  ADDLW  E9
06F48:  MOVWF  01
06F4A:  MOVLW  01
06F4C:  ADDWFC 03,F
06F4E:  MOVFF  01,6FF
06F52:  MOVFF  03,700
06F56:  MOVFF  03,729
06F5A:  MOVFF  01,728
06F5E:  MOVLB  0
06F60:  CALL   580E
06F64:  MOVF   01,F
06F66:  BNZ   6F70
06F68:  MOVLW  02
06F6A:  MOVWF  01
06F6C:  BRA    722E
06F6E:  BRA    6FD6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06F70:  MOVLB  7
06F72:  CLRF   x30
06F74:  MOVFF  683,72F
06F78:  CLRF   x32
06F7A:  MOVLW  B5
06F7C:  MOVWF  x31
06F7E:  MOVLB  0
06F80:  CALL   0828
06F84:  MOVFF  02,700
06F88:  MOVFF  01,6FF
06F8C:  MOVLW  06
06F8E:  MOVLB  6
06F90:  ADDWF  xFF,F
06F92:  MOVLW  00
06F94:  MOVLB  7
06F96:  ADDWFC x00,F
06F98:  MOVLW  32
06F9A:  MOVLB  6
06F9C:  ADDWF  xFF,W
06F9E:  MOVWF  01
06FA0:  MOVLW  00
06FA2:  MOVLB  7
06FA4:  ADDWFC x00,W
06FA6:  MOVWF  03
06FA8:  MOVF   01,W
06FAA:  ADDLW  E9
06FAC:  MOVWF  01
06FAE:  MOVLW  01
06FB0:  ADDWFC 03,F
06FB2:  MOVFF  01,6FF
06FB6:  MOVFF  03,700
06FBA:  MOVFF  03,729
06FBE:  MOVFF  01,728
06FC2:  MOVLB  7
06FC4:  CLRF   x2B
06FC6:  CLRF   x2A
06FC8:  MOVLW  0A
06FCA:  MOVWF  x2C
06FCC:  MOVLB  0
06FCE:  CALL   58FE
06FD2:  MOVFF  01,6F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06FD6:  MOVLB  7
06FD8:  CLRF   x30
06FDA:  MOVFF  683,72F
06FDE:  CLRF   x32
06FE0:  MOVLW  B5
06FE2:  MOVWF  x31
06FE4:  MOVLB  0
06FE6:  CALL   0828
06FEA:  MOVFF  02,700
06FEE:  MOVFF  01,6FF
06FF2:  MOVLW  06
06FF4:  MOVLB  6
06FF6:  ADDWF  xFF,F
06FF8:  MOVLW  00
06FFA:  MOVLB  7
06FFC:  ADDWFC x00,F
06FFE:  MOVLW  4B
07000:  MOVLB  6
07002:  ADDWF  xFF,W
07004:  MOVWF  01
07006:  MOVLW  00
07008:  MOVLB  7
0700A:  ADDWFC x00,W
0700C:  MOVWF  03
0700E:  MOVF   01,W
07010:  ADDLW  E9
07012:  MOVWF  01
07014:  MOVLW  01
07016:  ADDWFC 03,F
07018:  MOVFF  01,6FF
0701C:  MOVFF  03,700
07020:  MOVFF  03,730
07024:  MOVFF  01,72F
07028:  MOVLB  0
0702A:  CALL   5638
0702E:  MOVFF  02,03
07032:  MOVF   01,W
07034:  SUBLW  01
07036:  BNZ   703C
07038:  MOVF   03,F
0703A:  BZ    7044
0703C:  MOVLW  02
0703E:  MOVWF  01
07040:  BRA    722E
07042:  BRA    708E
....................    else arg2 = SERcmd[rec].p[3][0];
07044:  MOVLB  7
07046:  CLRF   x30
07048:  MOVFF  683,72F
0704C:  CLRF   x32
0704E:  MOVLW  B5
07050:  MOVWF  x31
07052:  MOVLB  0
07054:  CALL   0828
07058:  MOVFF  02,700
0705C:  MOVFF  01,6FF
07060:  MOVLW  06
07062:  MOVLB  6
07064:  ADDWF  xFF,F
07066:  MOVLW  00
07068:  MOVLB  7
0706A:  ADDWFC x00,F
0706C:  MOVLW  4B
0706E:  MOVLB  6
07070:  ADDWF  xFF,F
07072:  MOVLW  00
07074:  MOVLB  7
07076:  ADDWFC x00,F
07078:  MOVLW  E9
0707A:  MOVLB  6
0707C:  ADDWF  xFF,W
0707E:  MOVWF  FE9
07080:  MOVLW  01
07082:  MOVLB  7
07084:  ADDWFC x00,W
07086:  MOVWF  FEA
07088:  MOVFF  FEF,6FA
0708C:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0708E:  MOVLB  7
07090:  CLRF   x30
07092:  MOVFF  683,72F
07096:  CLRF   x32
07098:  MOVLW  B5
0709A:  MOVWF  x31
0709C:  MOVLB  0
0709E:  CALL   0828
070A2:  MOVFF  02,700
070A6:  MOVFF  01,6FF
070AA:  MOVLW  06
070AC:  MOVLB  6
070AE:  ADDWF  xFF,F
070B0:  MOVLW  00
070B2:  MOVLB  7
070B4:  ADDWFC x00,F
070B6:  MOVLW  64
070B8:  MOVLB  6
070BA:  ADDWF  xFF,W
070BC:  MOVWF  01
070BE:  MOVLW  00
070C0:  MOVLB  7
070C2:  ADDWFC x00,W
070C4:  MOVWF  03
070C6:  MOVF   01,W
070C8:  ADDLW  E9
070CA:  MOVWF  01
070CC:  MOVLW  01
070CE:  ADDWFC 03,F
070D0:  MOVFF  01,6FF
070D4:  MOVFF  03,700
070D8:  MOVFF  03,703
070DC:  MOVFF  01,702
070E0:  MOVLB  0
070E2:  RCALL  6BF0
070E4:  MOVF   01,F
070E6:  BNZ   70F0
070E8:  MOVLW  02
070EA:  MOVWF  01
070EC:  BRA    722E
070EE:  BRA    715C
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
070F0:  MOVLB  7
070F2:  CLRF   x30
070F4:  MOVFF  683,72F
070F8:  CLRF   x32
070FA:  MOVLW  B5
070FC:  MOVWF  x31
070FE:  MOVLB  0
07100:  CALL   0828
07104:  MOVFF  02,700
07108:  MOVFF  01,6FF
0710C:  MOVLW  06
0710E:  MOVLB  6
07110:  ADDWF  xFF,F
07112:  MOVLW  00
07114:  MOVLB  7
07116:  ADDWFC x00,F
07118:  MOVLW  64
0711A:  MOVLB  6
0711C:  ADDWF  xFF,W
0711E:  MOVWF  01
07120:  MOVLW  00
07122:  MOVLB  7
07124:  ADDWFC x00,W
07126:  MOVWF  03
07128:  MOVF   01,W
0712A:  ADDLW  E9
0712C:  MOVWF  01
0712E:  MOVLW  01
07130:  ADDWFC 03,F
07132:  MOVFF  01,6FF
07136:  MOVFF  03,700
0713A:  MOVFF  03,703
0713E:  MOVFF  01,702
07142:  MOVLB  7
07144:  CLRF   x05
07146:  CLRF   x04
07148:  MOVLB  0
0714A:  RCALL  6CB2
0714C:  MOVFF  03,6FE
07150:  MOVFF  02,6FD
07154:  MOVFF  01,6FC
07158:  MOVFF  00,6FB
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
0715C:  MOVLB  6
0715E:  MOVF   xFA,W
07160:  SUBLW  50
07162:  BNZ   7196
07164:  MOVLW  01
07166:  SUBWF  xF9,W
07168:  MULLW  20
0716A:  MOVF   FF3,W
0716C:  MOVLB  7
0716E:  CLRF   x00
07170:  MOVLB  6
07172:  MOVWF  xFF
07174:  MOVLW  20
07176:  ADDWF  xFF,W
07178:  MOVWF  FE9
0717A:  MOVLW  00
0717C:  MOVLB  7
0717E:  ADDWFC x00,W
07180:  MOVWF  FEA
07182:  MOVFF  6FB,FEF
07186:  MOVFF  6FC,FEC
0718A:  MOVFF  6FD,FEC
0718E:  MOVFF  6FE,FEC
07192:  BRA    7228
07194:  MOVLB  6
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07196:  MOVF   xFA,W
07198:  SUBLW  49
0719A:  BNZ   71DA
0719C:  MOVLW  01
0719E:  SUBWF  xF9,W
071A0:  MULLW  20
071A2:  MOVF   FF3,W
071A4:  MOVLB  7
071A6:  CLRF   x00
071A8:  MOVLB  6
071AA:  MOVWF  xFF
071AC:  MOVLW  04
071AE:  ADDWF  xFF,W
071B0:  MOVWF  01
071B2:  MOVLW  00
071B4:  MOVLB  7
071B6:  ADDWFC x00,W
071B8:  MOVWF  03
071BA:  MOVF   01,W
071BC:  ADDLW  20
071BE:  MOVWF  FE9
071C0:  MOVLW  00
071C2:  ADDWFC 03,W
071C4:  MOVWF  FEA
071C6:  MOVFF  6FB,FEF
071CA:  MOVFF  6FC,FEC
071CE:  MOVFF  6FD,FEC
071D2:  MOVFF  6FE,FEC
071D6:  BRA    7228
071D8:  MOVLB  6
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
071DA:  MOVF   xFA,W
071DC:  SUBLW  44
071DE:  BNZ   721E
071E0:  MOVLW  01
071E2:  SUBWF  xF9,W
071E4:  MULLW  20
071E6:  MOVF   FF3,W
071E8:  MOVLB  7
071EA:  CLRF   x00
071EC:  MOVLB  6
071EE:  MOVWF  xFF
071F0:  MOVLW  08
071F2:  ADDWF  xFF,W
071F4:  MOVWF  01
071F6:  MOVLW  00
071F8:  MOVLB  7
071FA:  ADDWFC x00,W
071FC:  MOVWF  03
071FE:  MOVF   01,W
07200:  ADDLW  20
07202:  MOVWF  FE9
07204:  MOVLW  00
07206:  ADDWFC 03,W
07208:  MOVWF  FEA
0720A:  MOVFF  6FB,FEF
0720E:  MOVFF  6FC,FEC
07212:  MOVFF  6FD,FEC
07216:  MOVFF  6FE,FEC
0721A:  BRA    7228
0721C:  MOVLB  6
....................    else return INV_PARAM;
0721E:  MOVLW  02
07220:  MOVWF  01
07222:  MOVLB  0
07224:  BRA    722E
07226:  MOVLB  7
....................    
....................    return SUCCESS;
07228:  MOVLW  00
0722A:  MOVWF  01
0722C:  MOVLB  0
0722E:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07230:  MOVLB  7
07232:  CLRF   x30
07234:  MOVFF  683,72F
07238:  CLRF   x32
0723A:  MOVLW  B5
0723C:  MOVWF  x31
0723E:  MOVLB  0
07240:  CALL   0828
07244:  MOVFF  02,6FB
07248:  MOVFF  01,6FA
0724C:  MOVLW  06
0724E:  MOVLB  6
07250:  ADDWF  xFA,F
07252:  MOVLW  00
07254:  ADDWFC xFB,F
07256:  MOVLW  32
07258:  ADDWF  xFA,W
0725A:  MOVWF  01
0725C:  MOVLW  00
0725E:  ADDWFC xFB,W
07260:  MOVWF  03
07262:  MOVF   01,W
07264:  ADDLW  E9
07266:  MOVWF  01
07268:  MOVLW  01
0726A:  ADDWFC 03,F
0726C:  MOVFF  01,6FA
07270:  MOVFF  03,6FB
07274:  MOVFF  03,729
07278:  MOVFF  01,728
0727C:  MOVLB  0
0727E:  CALL   580E
07282:  MOVF   01,F
07284:  BNZ   728E
07286:  MOVLW  02
07288:  MOVWF  01
0728A:  BRA    7394
0728C:  BRA    72EE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0728E:  MOVLB  7
07290:  CLRF   x30
07292:  MOVFF  683,72F
07296:  CLRF   x32
07298:  MOVLW  B5
0729A:  MOVWF  x31
0729C:  MOVLB  0
0729E:  CALL   0828
072A2:  MOVFF  02,6FB
072A6:  MOVFF  01,6FA
072AA:  MOVLW  06
072AC:  MOVLB  6
072AE:  ADDWF  xFA,F
072B0:  MOVLW  00
072B2:  ADDWFC xFB,F
072B4:  MOVLW  32
072B6:  ADDWF  xFA,W
072B8:  MOVWF  01
072BA:  MOVLW  00
072BC:  ADDWFC xFB,W
072BE:  MOVWF  03
072C0:  MOVF   01,W
072C2:  ADDLW  E9
072C4:  MOVWF  01
072C6:  MOVLW  01
072C8:  ADDWFC 03,F
072CA:  MOVFF  01,6FA
072CE:  MOVFF  03,6FB
072D2:  MOVFF  03,729
072D6:  MOVFF  01,728
072DA:  MOVLB  7
072DC:  CLRF   x2B
072DE:  CLRF   x2A
072E0:  MOVLW  0A
072E2:  MOVWF  x2C
072E4:  MOVLB  0
072E6:  CALL   58FE
072EA:  MOVFF  01,6F9
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
072EE:  MOVLW  04
072F0:  MOVLB  7
072F2:  MOVWF  x30
072F4:  MOVLW  BF
072F6:  MOVWF  x2F
072F8:  MOVLB  0
072FA:  CALL   5638
072FE:  MOVF   01,W
07300:  ADDLW  BF
07302:  MOVLB  6
07304:  MOVWF  xFA
07306:  MOVLW  04
07308:  ADDWFC 02,W
0730A:  MOVWF  xFB
0730C:  MOVLW  01
0730E:  SUBWF  xF9,W
07310:  MULLW  20
07312:  MOVF   FF3,W
07314:  CLRF   xFD
07316:  MOVWF  xFC
07318:  MOVLW  0C
0731A:  ADDWF  xFC,W
0731C:  MOVWF  01
0731E:  MOVLW  00
07320:  ADDWFC xFD,W
07322:  MOVWF  03
07324:  MOVF   01,W
07326:  ADDLW  20
07328:  MOVWF  FE9
0732A:  MOVLW  00
0732C:  ADDWFC 03,W
0732E:  MOVWF  FEA
07330:  MOVFF  FEF,6FC
07334:  MOVFF  FEC,6FD
07338:  MOVFF  FEC,6FE
0733C:  MOVFF  FEC,6FF
07340:  MOVFF  6FB,563
07344:  MOVFF  6FA,562
07348:  MOVFF  6F9,729
0734C:  MOVLW  18
0734E:  MOVLB  7
07350:  MOVWF  x2A
07352:  MOVLB  0
07354:  CALL   5C52
07358:  MOVLW  2C
0735A:  MOVLB  7
0735C:  MOVWF  x3E
0735E:  MOVLB  0
07360:  CALL   5670
07364:  MOVLW  89
07366:  MOVWF  FE9
07368:  MOVFF  6FF,734
0736C:  MOVFF  6FE,733
07370:  MOVFF  6FD,732
07374:  MOVFF  6FC,731
07378:  MOVLW  02
0737A:  MOVLB  7
0737C:  MOVWF  x35
0737E:  MOVLB  0
07380:  CALL   656A
07384:  MOVLW  2C
07386:  MOVLB  7
07388:  MOVWF  x3E
0738A:  MOVLB  0
0738C:  CALL   5670
....................    return SUCCESS;
07390:  MOVLW  00
07392:  MOVWF  01
07394:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07396:  MOVLB  7
07398:  CLRF   x30
0739A:  MOVFF  683,72F
0739E:  CLRF   x32
073A0:  MOVLW  B5
073A2:  MOVWF  x31
073A4:  MOVLB  0
073A6:  CALL   0828
073AA:  MOVFF  02,6FF
073AE:  MOVFF  01,6FE
073B2:  MOVLW  06
073B4:  MOVLB  6
073B6:  ADDWF  xFE,F
073B8:  MOVLW  00
073BA:  ADDWFC xFF,F
073BC:  MOVLW  32
073BE:  ADDWF  xFE,W
073C0:  MOVWF  01
073C2:  MOVLW  00
073C4:  ADDWFC xFF,W
073C6:  MOVWF  03
073C8:  MOVF   01,W
073CA:  ADDLW  E9
073CC:  MOVWF  01
073CE:  MOVLW  01
073D0:  ADDWFC 03,F
073D2:  MOVFF  01,6FE
073D6:  MOVFF  03,6FF
073DA:  MOVFF  03,729
073DE:  MOVFF  01,728
073E2:  MOVLB  0
073E4:  CALL   580E
073E8:  MOVF   01,F
073EA:  BNZ   73F4
073EC:  MOVLW  02
073EE:  MOVWF  01
073F0:  BRA    7556
073F2:  BRA    7454
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
073F4:  MOVLB  7
073F6:  CLRF   x30
073F8:  MOVFF  683,72F
073FC:  CLRF   x32
073FE:  MOVLW  B5
07400:  MOVWF  x31
07402:  MOVLB  0
07404:  CALL   0828
07408:  MOVFF  02,6FF
0740C:  MOVFF  01,6FE
07410:  MOVLW  06
07412:  MOVLB  6
07414:  ADDWF  xFE,F
07416:  MOVLW  00
07418:  ADDWFC xFF,F
0741A:  MOVLW  32
0741C:  ADDWF  xFE,W
0741E:  MOVWF  01
07420:  MOVLW  00
07422:  ADDWFC xFF,W
07424:  MOVWF  03
07426:  MOVF   01,W
07428:  ADDLW  E9
0742A:  MOVWF  01
0742C:  MOVLW  01
0742E:  ADDWFC 03,F
07430:  MOVFF  01,6FE
07434:  MOVFF  03,6FF
07438:  MOVFF  03,729
0743C:  MOVFF  01,728
07440:  MOVLB  7
07442:  CLRF   x2B
07444:  CLRF   x2A
07446:  MOVLW  0A
07448:  MOVWF  x2C
0744A:  MOVLB  0
0744C:  CALL   58FE
07450:  MOVFF  01,6F9
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07454:  MOVLB  7
07456:  CLRF   x30
07458:  MOVFF  683,72F
0745C:  CLRF   x32
0745E:  MOVLW  B5
07460:  MOVWF  x31
07462:  MOVLB  0
07464:  CALL   0828
07468:  MOVFF  02,6FF
0746C:  MOVFF  01,6FE
07470:  MOVLW  06
07472:  MOVLB  6
07474:  ADDWF  xFE,F
07476:  MOVLW  00
07478:  ADDWFC xFF,F
0747A:  MOVLW  4B
0747C:  ADDWF  xFE,W
0747E:  MOVWF  01
07480:  MOVLW  00
07482:  ADDWFC xFF,W
07484:  MOVWF  03
07486:  MOVF   01,W
07488:  ADDLW  E9
0748A:  MOVWF  01
0748C:  MOVLW  01
0748E:  ADDWFC 03,F
07490:  MOVFF  01,6FE
07494:  MOVFF  03,6FF
07498:  MOVFF  03,703
0749C:  MOVFF  01,702
074A0:  MOVLB  0
074A2:  CALL   6BF0
074A6:  MOVF   01,F
074A8:  BNZ   74B2
074AA:  MOVLW  02
074AC:  MOVWF  01
074AE:  BRA    7556
074B0:  BRA    751A
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
074B2:  MOVLB  7
074B4:  CLRF   x30
074B6:  MOVFF  683,72F
074BA:  CLRF   x32
074BC:  MOVLW  B5
074BE:  MOVWF  x31
074C0:  MOVLB  0
074C2:  CALL   0828
074C6:  MOVFF  02,6FF
074CA:  MOVFF  01,6FE
074CE:  MOVLW  06
074D0:  MOVLB  6
074D2:  ADDWF  xFE,F
074D4:  MOVLW  00
074D6:  ADDWFC xFF,F
074D8:  MOVLW  4B
074DA:  ADDWF  xFE,W
074DC:  MOVWF  01
074DE:  MOVLW  00
074E0:  ADDWFC xFF,W
074E2:  MOVWF  03
074E4:  MOVF   01,W
074E6:  ADDLW  E9
074E8:  MOVWF  01
074EA:  MOVLW  01
074EC:  ADDWFC 03,F
074EE:  MOVFF  01,6FE
074F2:  MOVFF  03,6FF
074F6:  MOVFF  03,703
074FA:  MOVFF  01,702
074FE:  MOVLB  7
07500:  CLRF   x05
07502:  CLRF   x04
07504:  MOVLB  0
07506:  CALL   6CB2
0750A:  MOVFF  03,6FD
0750E:  MOVFF  02,6FC
07512:  MOVFF  01,6FB
07516:  MOVFF  00,6FA
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0751A:  MOVLW  01
0751C:  MOVLB  6
0751E:  SUBWF  xF9,W
07520:  MULLW  20
07522:  MOVF   FF3,W
07524:  CLRF   xFF
07526:  MOVWF  xFE
07528:  MOVLW  0C
0752A:  ADDWF  xFE,W
0752C:  MOVWF  01
0752E:  MOVLW  00
07530:  ADDWFC xFF,W
07532:  MOVWF  03
07534:  MOVF   01,W
07536:  ADDLW  20
07538:  MOVWF  FE9
0753A:  MOVLW  00
0753C:  ADDWFC 03,W
0753E:  MOVWF  FEA
07540:  MOVFF  6FA,FEF
07544:  MOVFF  6FB,FEC
07548:  MOVFF  6FC,FEC
0754C:  MOVFF  6FD,FEC
....................    
....................    return SUCCESS;
07550:  MOVLW  00
07552:  MOVWF  01
07554:  MOVLB  0
07556:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07558:  MOVLB  7
0755A:  CLRF   x30
0755C:  MOVFF  683,72F
07560:  CLRF   x32
07562:  MOVLW  B5
07564:  MOVWF  x31
07566:  MOVLB  0
07568:  CALL   0828
0756C:  MOVFF  02,701
07570:  MOVFF  01,700
07574:  MOVLW  06
07576:  MOVLB  7
07578:  ADDWF  x00,F
0757A:  MOVLW  00
0757C:  ADDWFC x01,F
0757E:  MOVLW  32
07580:  ADDWF  x00,W
07582:  MOVWF  01
07584:  MOVLW  00
07586:  ADDWFC x01,W
07588:  MOVWF  03
0758A:  MOVF   01,W
0758C:  ADDLW  E9
0758E:  MOVWF  01
07590:  MOVLW  01
07592:  ADDWFC 03,F
07594:  MOVFF  01,700
07598:  MOVFF  03,701
0759C:  MOVFF  03,729
075A0:  MOVFF  01,728
075A4:  MOVLB  0
075A6:  CALL   580E
075AA:  MOVF   01,F
075AC:  BNZ   75B6
075AE:  MOVLW  02
075B0:  MOVWF  01
075B2:  BRA    7924
075B4:  BRA    7614
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
075B6:  MOVLB  7
075B8:  CLRF   x30
075BA:  MOVFF  683,72F
075BE:  CLRF   x32
075C0:  MOVLW  B5
075C2:  MOVWF  x31
075C4:  MOVLB  0
075C6:  CALL   0828
075CA:  MOVFF  02,701
075CE:  MOVFF  01,700
075D2:  MOVLW  06
075D4:  MOVLB  7
075D6:  ADDWF  x00,F
075D8:  MOVLW  00
075DA:  ADDWFC x01,F
075DC:  MOVLW  32
075DE:  ADDWF  x00,W
075E0:  MOVWF  01
075E2:  MOVLW  00
075E4:  ADDWFC x01,W
075E6:  MOVWF  03
075E8:  MOVF   01,W
075EA:  ADDLW  E9
075EC:  MOVWF  01
075EE:  MOVLW  01
075F0:  ADDWFC 03,F
075F2:  MOVFF  01,700
075F6:  MOVFF  03,701
075FA:  MOVFF  03,729
075FE:  MOVFF  01,728
07602:  CLRF   x2B
07604:  CLRF   x2A
07606:  MOVLW  0A
07608:  MOVWF  x2C
0760A:  MOVLB  0
0760C:  CALL   58FE
07610:  MOVFF  01,6F9
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07614:  MOVLW  04
07616:  MOVLB  7
07618:  MOVWF  x30
0761A:  MOVLW  BF
0761C:  MOVWF  x2F
0761E:  MOVLB  0
07620:  CALL   5638
07624:  MOVFF  02,03
07628:  MOVF   01,W
0762A:  ADDLW  BF
0762C:  MOVLB  7
0762E:  MOVWF  x00
07630:  MOVLW  04
07632:  ADDWFC 02,W
07634:  MOVWF  x01
07636:  MOVFF  FE8,563
0763A:  MOVFF  700,562
0763E:  MOVFF  6F9,729
07642:  MOVLW  18
07644:  MOVWF  x2A
07646:  MOVLB  0
07648:  CALL   5C52
0764C:  MOVLW  2C
0764E:  MOVLB  7
07650:  MOVWF  x3E
07652:  MOVLB  0
07654:  CALL   5670
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07658:  MOVLW  04
0765A:  MOVLB  7
0765C:  MOVWF  x30
0765E:  MOVLW  BF
07660:  MOVWF  x2F
07662:  MOVLB  0
07664:  CALL   5638
07668:  MOVFF  02,03
0766C:  MOVF   01,W
0766E:  ADDLW  BF
07670:  MOVLB  7
07672:  MOVWF  x00
07674:  MOVLW  04
07676:  ADDWFC 02,W
07678:  MOVWF  x01
0767A:  MOVLW  01
0767C:  MOVLB  6
0767E:  SUBWF  xF9,W
07680:  MULLW  18
07682:  MOVF   FF3,W
07684:  MOVLB  7
07686:  CLRF   x03
07688:  MOVWF  x02
0768A:  MOVLW  82
0768C:  ADDWF  x02,W
0768E:  MOVWF  FE9
07690:  MOVLW  00
07692:  ADDWFC x03,W
07694:  MOVWF  FEA
07696:  MOVFF  FEF,731
0769A:  MOVFF  FEC,732
0769E:  MOVFF  FEC,733
076A2:  MOVFF  FEC,734
076A6:  MOVFF  701,563
076AA:  MOVFF  700,562
076AE:  MOVLW  89
076B0:  MOVWF  FE9
076B2:  MOVLW  02
076B4:  MOVWF  x35
076B6:  MOVLB  0
076B8:  CALL   656A
076BC:  MOVLW  2C
076BE:  MOVLB  7
076C0:  MOVWF  x3E
076C2:  MOVLB  0
076C4:  CALL   5670
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
076C8:  MOVLW  04
076CA:  MOVLB  7
076CC:  MOVWF  x30
076CE:  MOVLW  BF
076D0:  MOVWF  x2F
076D2:  MOVLB  0
076D4:  CALL   5638
076D8:  MOVF   01,W
076DA:  ADDLW  BF
076DC:  MOVLB  7
076DE:  MOVWF  x00
076E0:  MOVLW  04
076E2:  ADDWFC 02,W
076E4:  MOVWF  x01
076E6:  MOVLW  01
076E8:  MOVLB  6
076EA:  SUBWF  xF9,W
076EC:  MULLW  18
076EE:  MOVF   FF3,W
076F0:  MOVLB  7
076F2:  CLRF   x03
076F4:  MOVWF  x02
076F6:  MOVLW  04
076F8:  ADDWF  x02,W
076FA:  MOVWF  01
076FC:  MOVLW  00
076FE:  ADDWFC x03,W
07700:  MOVWF  03
07702:  MOVF   01,W
07704:  ADDLW  82
07706:  MOVWF  FE9
07708:  MOVLW  00
0770A:  ADDWFC 03,W
0770C:  MOVWF  FEA
0770E:  MOVFF  FEF,731
07712:  MOVFF  FEC,732
07716:  MOVFF  FEC,733
0771A:  MOVFF  FEC,734
0771E:  MOVFF  701,563
07722:  MOVFF  700,562
07726:  MOVLW  89
07728:  MOVWF  FE9
0772A:  MOVLW  02
0772C:  MOVWF  x35
0772E:  MOVLB  0
07730:  CALL   656A
07734:  MOVLW  2C
07736:  MOVLB  7
07738:  MOVWF  x3E
0773A:  MOVLB  0
0773C:  CALL   5670
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07740:  MOVLW  04
07742:  MOVLB  7
07744:  MOVWF  x30
07746:  MOVLW  BF
07748:  MOVWF  x2F
0774A:  MOVLB  0
0774C:  CALL   5638
07750:  MOVF   01,W
07752:  ADDLW  BF
07754:  MOVLB  7
07756:  MOVWF  x00
07758:  MOVLW  04
0775A:  ADDWFC 02,W
0775C:  MOVWF  x01
0775E:  MOVLW  01
07760:  MOVLB  6
07762:  SUBWF  xF9,W
07764:  MULLW  18
07766:  MOVF   FF3,W
07768:  MOVLB  7
0776A:  CLRF   x03
0776C:  MOVWF  x02
0776E:  MOVLW  08
07770:  ADDWF  x02,W
07772:  MOVWF  01
07774:  MOVLW  00
07776:  ADDWFC x03,W
07778:  MOVWF  03
0777A:  MOVF   01,W
0777C:  ADDLW  82
0777E:  MOVWF  FE9
07780:  MOVLW  00
07782:  ADDWFC 03,W
07784:  MOVWF  FEA
07786:  MOVFF  FEF,731
0778A:  MOVFF  FEC,732
0778E:  MOVFF  FEC,733
07792:  MOVFF  FEC,734
07796:  MOVFF  701,563
0779A:  MOVFF  700,562
0779E:  MOVLW  89
077A0:  MOVWF  FE9
077A2:  MOVLW  02
077A4:  MOVWF  x35
077A6:  MOVLB  0
077A8:  CALL   656A
077AC:  MOVLW  2C
077AE:  MOVLB  7
077B0:  MOVWF  x3E
077B2:  MOVLB  0
077B4:  CALL   5670
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
077B8:  MOVLW  04
077BA:  MOVLB  7
077BC:  MOVWF  x30
077BE:  MOVLW  BF
077C0:  MOVWF  x2F
077C2:  MOVLB  0
077C4:  CALL   5638
077C8:  MOVF   01,W
077CA:  ADDLW  BF
077CC:  MOVLB  7
077CE:  MOVWF  x00
077D0:  MOVLW  04
077D2:  ADDWFC 02,W
077D4:  MOVWF  x01
077D6:  MOVLW  01
077D8:  MOVLB  6
077DA:  SUBWF  xF9,W
077DC:  MULLW  18
077DE:  MOVF   FF3,W
077E0:  MOVLB  7
077E2:  CLRF   x03
077E4:  MOVWF  x02
077E6:  MOVLW  0C
077E8:  ADDWF  x02,W
077EA:  MOVWF  01
077EC:  MOVLW  00
077EE:  ADDWFC x03,W
077F0:  MOVWF  03
077F2:  MOVF   01,W
077F4:  ADDLW  82
077F6:  MOVWF  FE9
077F8:  MOVLW  00
077FA:  ADDWFC 03,W
077FC:  MOVWF  FEA
077FE:  MOVFF  FEF,731
07802:  MOVFF  FEC,732
07806:  MOVFF  FEC,733
0780A:  MOVFF  FEC,734
0780E:  MOVFF  701,563
07812:  MOVFF  700,562
07816:  MOVLW  89
07818:  MOVWF  FE9
0781A:  MOVLW  02
0781C:  MOVWF  x35
0781E:  MOVLB  0
07820:  CALL   656A
07824:  MOVLW  2C
07826:  MOVLB  7
07828:  MOVWF  x3E
0782A:  MOVLB  0
0782C:  CALL   5670
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07830:  MOVLW  04
07832:  MOVLB  7
07834:  MOVWF  x30
07836:  MOVLW  BF
07838:  MOVWF  x2F
0783A:  MOVLB  0
0783C:  CALL   5638
07840:  MOVF   01,W
07842:  ADDLW  BF
07844:  MOVLB  7
07846:  MOVWF  x00
07848:  MOVLW  04
0784A:  ADDWFC 02,W
0784C:  MOVWF  x01
0784E:  MOVLW  01
07850:  MOVLB  6
07852:  SUBWF  xF9,W
07854:  MULLW  18
07856:  MOVF   FF3,W
07858:  MOVLB  7
0785A:  CLRF   x03
0785C:  MOVWF  x02
0785E:  MOVLW  10
07860:  ADDWF  x02,W
07862:  MOVWF  01
07864:  MOVLW  00
07866:  ADDWFC x03,W
07868:  MOVWF  03
0786A:  MOVF   01,W
0786C:  ADDLW  82
0786E:  MOVWF  FE9
07870:  MOVLW  00
07872:  ADDWFC 03,W
07874:  MOVWF  FEA
07876:  MOVFF  FEF,731
0787A:  MOVFF  FEC,732
0787E:  MOVFF  FEC,733
07882:  MOVFF  FEC,734
07886:  MOVFF  701,563
0788A:  MOVFF  700,562
0788E:  MOVLW  89
07890:  MOVWF  FE9
07892:  MOVLW  02
07894:  MOVWF  x35
07896:  MOVLB  0
07898:  CALL   656A
0789C:  MOVLW  2C
0789E:  MOVLB  7
078A0:  MOVWF  x3E
078A2:  MOVLB  0
078A4:  CALL   5670
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
078A8:  MOVLW  04
078AA:  MOVLB  7
078AC:  MOVWF  x30
078AE:  MOVLW  BF
078B0:  MOVWF  x2F
078B2:  MOVLB  0
078B4:  CALL   5638
078B8:  MOVF   01,W
078BA:  ADDLW  BF
078BC:  MOVLB  7
078BE:  MOVWF  x00
078C0:  MOVLW  04
078C2:  ADDWFC 02,W
078C4:  MOVWF  x01
078C6:  MOVLW  01
078C8:  MOVLB  6
078CA:  SUBWF  xF9,W
078CC:  MULLW  18
078CE:  MOVF   FF3,W
078D0:  MOVLB  7
078D2:  CLRF   x03
078D4:  MOVWF  x02
078D6:  MOVLW  14
078D8:  ADDWF  x02,W
078DA:  MOVWF  01
078DC:  MOVLW  00
078DE:  ADDWFC x03,W
078E0:  MOVWF  03
078E2:  MOVF   01,W
078E4:  ADDLW  82
078E6:  MOVWF  FE9
078E8:  MOVLW  00
078EA:  ADDWFC 03,W
078EC:  MOVWF  FEA
078EE:  MOVFF  FEF,731
078F2:  MOVFF  FEC,732
078F6:  MOVFF  FEC,733
078FA:  MOVFF  FEC,734
078FE:  MOVFF  701,563
07902:  MOVFF  700,562
07906:  MOVLW  89
07908:  MOVWF  FE9
0790A:  MOVLW  02
0790C:  MOVWF  x35
0790E:  MOVLB  0
07910:  CALL   656A
07914:  MOVLW  2C
07916:  MOVLB  7
07918:  MOVWF  x3E
0791A:  MOVLB  0
0791C:  CALL   5670
....................    
....................    return SUCCESS;
07920:  MOVLW  00
07922:  MOVWF  01
07924:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07926:  MOVLB  7
07928:  CLRF   x30
0792A:  MOVFF  683,72F
0792E:  CLRF   x32
07930:  MOVLW  B5
07932:  MOVWF  x31
07934:  MOVLB  0
07936:  CALL   0828
0793A:  MOVFF  02,701
0793E:  MOVFF  01,700
07942:  MOVLW  06
07944:  MOVLB  7
07946:  ADDWF  x00,F
07948:  MOVLW  00
0794A:  ADDWFC x01,F
0794C:  MOVLW  32
0794E:  ADDWF  x00,W
07950:  MOVWF  01
07952:  MOVLW  00
07954:  ADDWFC x01,W
07956:  MOVWF  03
07958:  MOVF   01,W
0795A:  ADDLW  E9
0795C:  MOVWF  01
0795E:  MOVLW  01
07960:  ADDWFC 03,F
07962:  MOVFF  01,700
07966:  MOVFF  03,701
0796A:  MOVFF  03,729
0796E:  MOVFF  01,728
07972:  MOVLB  0
07974:  CALL   580E
07978:  MOVF   01,F
0797A:  BNZ   7984
0797C:  MOVLW  02
0797E:  MOVWF  01
07980:  BRA    7EA4
07982:  BRA    79E2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07984:  MOVLB  7
07986:  CLRF   x30
07988:  MOVFF  683,72F
0798C:  CLRF   x32
0798E:  MOVLW  B5
07990:  MOVWF  x31
07992:  MOVLB  0
07994:  CALL   0828
07998:  MOVFF  02,701
0799C:  MOVFF  01,700
079A0:  MOVLW  06
079A2:  MOVLB  7
079A4:  ADDWF  x00,F
079A6:  MOVLW  00
079A8:  ADDWFC x01,F
079AA:  MOVLW  32
079AC:  ADDWF  x00,W
079AE:  MOVWF  01
079B0:  MOVLW  00
079B2:  ADDWFC x01,W
079B4:  MOVWF  03
079B6:  MOVF   01,W
079B8:  ADDLW  E9
079BA:  MOVWF  01
079BC:  MOVLW  01
079BE:  ADDWFC 03,F
079C0:  MOVFF  01,700
079C4:  MOVFF  03,701
079C8:  MOVFF  03,729
079CC:  MOVFF  01,728
079D0:  CLRF   x2B
079D2:  CLRF   x2A
079D4:  MOVLW  0A
079D6:  MOVWF  x2C
079D8:  MOVLB  0
079DA:  CALL   58FE
079DE:  MOVFF  01,6F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
079E2:  MOVLB  7
079E4:  CLRF   x30
079E6:  MOVFF  683,72F
079EA:  CLRF   x32
079EC:  MOVLW  B5
079EE:  MOVWF  x31
079F0:  MOVLB  0
079F2:  CALL   0828
079F6:  MOVFF  02,701
079FA:  MOVFF  01,700
079FE:  MOVLW  06
07A00:  MOVLB  7
07A02:  ADDWF  x00,F
07A04:  MOVLW  00
07A06:  ADDWFC x01,F
07A08:  MOVLW  4B
07A0A:  ADDWF  x00,W
07A0C:  MOVWF  01
07A0E:  MOVLW  00
07A10:  ADDWFC x01,W
07A12:  MOVWF  03
07A14:  MOVF   01,W
07A16:  ADDLW  E9
07A18:  MOVWF  01
07A1A:  MOVLW  01
07A1C:  ADDWFC 03,F
07A1E:  MOVFF  01,700
07A22:  MOVFF  03,701
07A26:  MOVFF  03,730
07A2A:  MOVFF  01,72F
07A2E:  MOVLB  0
07A30:  CALL   5638
07A34:  MOVFF  02,03
07A38:  MOVF   01,W
07A3A:  SUBLW  01
07A3C:  BNZ   7A42
07A3E:  MOVF   03,F
07A40:  BZ    7A4A
07A42:  MOVLW  02
07A44:  MOVWF  01
07A46:  BRA    7EA4
07A48:  BRA    7A8A
....................    else arg2 = SERcmd[rec].p[3][0];
07A4A:  MOVLB  7
07A4C:  CLRF   x30
07A4E:  MOVFF  683,72F
07A52:  CLRF   x32
07A54:  MOVLW  B5
07A56:  MOVWF  x31
07A58:  MOVLB  0
07A5A:  CALL   0828
07A5E:  MOVFF  02,701
07A62:  MOVFF  01,700
07A66:  MOVLW  06
07A68:  MOVLB  7
07A6A:  ADDWF  x00,F
07A6C:  MOVLW  00
07A6E:  ADDWFC x01,F
07A70:  MOVLW  4B
07A72:  ADDWF  x00,F
07A74:  MOVLW  00
07A76:  ADDWFC x01,F
07A78:  MOVLW  E9
07A7A:  ADDWF  x00,W
07A7C:  MOVWF  FE9
07A7E:  MOVLW  01
07A80:  ADDWFC x01,W
07A82:  MOVWF  FEA
07A84:  MOVFF  FEF,6FA
07A88:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07A8A:  MOVLB  6
07A8C:  MOVF   xFA,W
07A8E:  SUBLW  30
07A90:  BNZ   7B32
07A92:  MOVLW  04
07A94:  MOVLB  7
07A96:  MOVWF  x30
07A98:  MOVLW  BF
07A9A:  MOVWF  x2F
07A9C:  MOVLB  0
07A9E:  CALL   5638
07AA2:  MOVFF  02,03
07AA6:  MOVF   01,W
07AA8:  ADDLW  BF
07AAA:  MOVLB  7
07AAC:  MOVWF  x00
07AAE:  MOVLW  04
07AB0:  ADDWFC 02,W
07AB2:  MOVWF  x01
07AB4:  MOVLW  01
07AB6:  MOVLB  6
07AB8:  SUBWF  xF9,W
07ABA:  MULLW  18
07ABC:  MOVF   FF3,W
07ABE:  MOVLB  7
07AC0:  CLRF   x03
07AC2:  MOVWF  x02
07AC4:  MOVLW  82
07AC6:  ADDWF  x02,W
07AC8:  MOVWF  FE9
07ACA:  MOVLW  00
07ACC:  ADDWFC x03,W
07ACE:  MOVWF  FEA
07AD0:  MOVFF  FEF,704
07AD4:  MOVFF  FEC,705
07AD8:  MOVFF  FEC,706
07ADC:  MOVFF  FEC,707
07AE0:  MOVFF  701,563
07AE4:  MOVFF  700,562
07AE8:  MOVFF  6F9,729
07AEC:  MOVLW  18
07AEE:  MOVWF  x2A
07AF0:  MOVLB  0
07AF2:  CALL   5C52
07AF6:  MOVLW  2C
07AF8:  MOVLB  7
07AFA:  MOVWF  x3E
07AFC:  MOVLB  0
07AFE:  CALL   5670
07B02:  MOVLW  89
07B04:  MOVWF  FE9
07B06:  MOVFF  707,734
07B0A:  MOVFF  706,733
07B0E:  MOVFF  705,732
07B12:  MOVFF  704,731
07B16:  MOVLW  02
07B18:  MOVLB  7
07B1A:  MOVWF  x35
07B1C:  MOVLB  0
07B1E:  CALL   656A
07B22:  MOVLW  2C
07B24:  MOVLB  7
07B26:  MOVWF  x3E
07B28:  MOVLB  0
07B2A:  CALL   5670
07B2E:  BRA    7EA0
07B30:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07B32:  MOVF   xFA,W
07B34:  SUBLW  31
07B36:  BNZ   7BE0
07B38:  MOVLW  04
07B3A:  MOVLB  7
07B3C:  MOVWF  x30
07B3E:  MOVLW  BF
07B40:  MOVWF  x2F
07B42:  MOVLB  0
07B44:  CALL   5638
07B48:  MOVF   01,W
07B4A:  ADDLW  BF
07B4C:  MOVLB  7
07B4E:  MOVWF  x00
07B50:  MOVLW  04
07B52:  ADDWFC 02,W
07B54:  MOVWF  x01
07B56:  MOVLW  01
07B58:  MOVLB  6
07B5A:  SUBWF  xF9,W
07B5C:  MULLW  18
07B5E:  MOVF   FF3,W
07B60:  MOVLB  7
07B62:  CLRF   x03
07B64:  MOVWF  x02
07B66:  MOVLW  04
07B68:  ADDWF  x02,W
07B6A:  MOVWF  01
07B6C:  MOVLW  00
07B6E:  ADDWFC x03,W
07B70:  MOVWF  03
07B72:  MOVF   01,W
07B74:  ADDLW  82
07B76:  MOVWF  FE9
07B78:  MOVLW  00
07B7A:  ADDWFC 03,W
07B7C:  MOVWF  FEA
07B7E:  MOVFF  FEF,702
07B82:  MOVFF  FEC,703
07B86:  MOVFF  FEC,704
07B8A:  MOVFF  FEC,705
07B8E:  MOVFF  701,563
07B92:  MOVFF  700,562
07B96:  MOVFF  6F9,729
07B9A:  MOVLW  18
07B9C:  MOVWF  x2A
07B9E:  MOVLB  0
07BA0:  CALL   5C52
07BA4:  MOVLW  2C
07BA6:  MOVLB  7
07BA8:  MOVWF  x3E
07BAA:  MOVLB  0
07BAC:  CALL   5670
07BB0:  MOVLW  89
07BB2:  MOVWF  FE9
07BB4:  MOVFF  705,734
07BB8:  MOVFF  704,733
07BBC:  MOVFF  703,732
07BC0:  MOVFF  702,731
07BC4:  MOVLW  02
07BC6:  MOVLB  7
07BC8:  MOVWF  x35
07BCA:  MOVLB  0
07BCC:  CALL   656A
07BD0:  MOVLW  2C
07BD2:  MOVLB  7
07BD4:  MOVWF  x3E
07BD6:  MOVLB  0
07BD8:  CALL   5670
07BDC:  BRA    7EA0
07BDE:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07BE0:  MOVF   xFA,W
07BE2:  SUBLW  32
07BE4:  BNZ   7C8E
07BE6:  MOVLW  04
07BE8:  MOVLB  7
07BEA:  MOVWF  x30
07BEC:  MOVLW  BF
07BEE:  MOVWF  x2F
07BF0:  MOVLB  0
07BF2:  CALL   5638
07BF6:  MOVF   01,W
07BF8:  ADDLW  BF
07BFA:  MOVLB  7
07BFC:  MOVWF  x00
07BFE:  MOVLW  04
07C00:  ADDWFC 02,W
07C02:  MOVWF  x01
07C04:  MOVLW  01
07C06:  MOVLB  6
07C08:  SUBWF  xF9,W
07C0A:  MULLW  18
07C0C:  MOVF   FF3,W
07C0E:  MOVLB  7
07C10:  CLRF   x03
07C12:  MOVWF  x02
07C14:  MOVLW  08
07C16:  ADDWF  x02,W
07C18:  MOVWF  01
07C1A:  MOVLW  00
07C1C:  ADDWFC x03,W
07C1E:  MOVWF  03
07C20:  MOVF   01,W
07C22:  ADDLW  82
07C24:  MOVWF  FE9
07C26:  MOVLW  00
07C28:  ADDWFC 03,W
07C2A:  MOVWF  FEA
07C2C:  MOVFF  FEF,702
07C30:  MOVFF  FEC,703
07C34:  MOVFF  FEC,704
07C38:  MOVFF  FEC,705
07C3C:  MOVFF  701,563
07C40:  MOVFF  700,562
07C44:  MOVFF  6F9,729
07C48:  MOVLW  18
07C4A:  MOVWF  x2A
07C4C:  MOVLB  0
07C4E:  CALL   5C52
07C52:  MOVLW  2C
07C54:  MOVLB  7
07C56:  MOVWF  x3E
07C58:  MOVLB  0
07C5A:  CALL   5670
07C5E:  MOVLW  89
07C60:  MOVWF  FE9
07C62:  MOVFF  705,734
07C66:  MOVFF  704,733
07C6A:  MOVFF  703,732
07C6E:  MOVFF  702,731
07C72:  MOVLW  02
07C74:  MOVLB  7
07C76:  MOVWF  x35
07C78:  MOVLB  0
07C7A:  CALL   656A
07C7E:  MOVLW  2C
07C80:  MOVLB  7
07C82:  MOVWF  x3E
07C84:  MOVLB  0
07C86:  CALL   5670
07C8A:  BRA    7EA0
07C8C:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07C8E:  MOVF   xFA,W
07C90:  SUBLW  33
07C92:  BNZ   7D3C
07C94:  MOVLW  04
07C96:  MOVLB  7
07C98:  MOVWF  x30
07C9A:  MOVLW  BF
07C9C:  MOVWF  x2F
07C9E:  MOVLB  0
07CA0:  CALL   5638
07CA4:  MOVF   01,W
07CA6:  ADDLW  BF
07CA8:  MOVLB  7
07CAA:  MOVWF  x00
07CAC:  MOVLW  04
07CAE:  ADDWFC 02,W
07CB0:  MOVWF  x01
07CB2:  MOVLW  01
07CB4:  MOVLB  6
07CB6:  SUBWF  xF9,W
07CB8:  MULLW  18
07CBA:  MOVF   FF3,W
07CBC:  MOVLB  7
07CBE:  CLRF   x03
07CC0:  MOVWF  x02
07CC2:  MOVLW  0C
07CC4:  ADDWF  x02,W
07CC6:  MOVWF  01
07CC8:  MOVLW  00
07CCA:  ADDWFC x03,W
07CCC:  MOVWF  03
07CCE:  MOVF   01,W
07CD0:  ADDLW  82
07CD2:  MOVWF  FE9
07CD4:  MOVLW  00
07CD6:  ADDWFC 03,W
07CD8:  MOVWF  FEA
07CDA:  MOVFF  FEF,702
07CDE:  MOVFF  FEC,703
07CE2:  MOVFF  FEC,704
07CE6:  MOVFF  FEC,705
07CEA:  MOVFF  701,563
07CEE:  MOVFF  700,562
07CF2:  MOVFF  6F9,729
07CF6:  MOVLW  18
07CF8:  MOVWF  x2A
07CFA:  MOVLB  0
07CFC:  CALL   5C52
07D00:  MOVLW  2C
07D02:  MOVLB  7
07D04:  MOVWF  x3E
07D06:  MOVLB  0
07D08:  CALL   5670
07D0C:  MOVLW  89
07D0E:  MOVWF  FE9
07D10:  MOVFF  705,734
07D14:  MOVFF  704,733
07D18:  MOVFF  703,732
07D1C:  MOVFF  702,731
07D20:  MOVLW  02
07D22:  MOVLB  7
07D24:  MOVWF  x35
07D26:  MOVLB  0
07D28:  CALL   656A
07D2C:  MOVLW  2C
07D2E:  MOVLB  7
07D30:  MOVWF  x3E
07D32:  MOVLB  0
07D34:  CALL   5670
07D38:  BRA    7EA0
07D3A:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07D3C:  MOVF   xFA,W
07D3E:  SUBLW  34
07D40:  BNZ   7DEA
07D42:  MOVLW  04
07D44:  MOVLB  7
07D46:  MOVWF  x30
07D48:  MOVLW  BF
07D4A:  MOVWF  x2F
07D4C:  MOVLB  0
07D4E:  CALL   5638
07D52:  MOVF   01,W
07D54:  ADDLW  BF
07D56:  MOVLB  7
07D58:  MOVWF  x00
07D5A:  MOVLW  04
07D5C:  ADDWFC 02,W
07D5E:  MOVWF  x01
07D60:  MOVLW  01
07D62:  MOVLB  6
07D64:  SUBWF  xF9,W
07D66:  MULLW  18
07D68:  MOVF   FF3,W
07D6A:  MOVLB  7
07D6C:  CLRF   x03
07D6E:  MOVWF  x02
07D70:  MOVLW  10
07D72:  ADDWF  x02,W
07D74:  MOVWF  01
07D76:  MOVLW  00
07D78:  ADDWFC x03,W
07D7A:  MOVWF  03
07D7C:  MOVF   01,W
07D7E:  ADDLW  82
07D80:  MOVWF  FE9
07D82:  MOVLW  00
07D84:  ADDWFC 03,W
07D86:  MOVWF  FEA
07D88:  MOVFF  FEF,702
07D8C:  MOVFF  FEC,703
07D90:  MOVFF  FEC,704
07D94:  MOVFF  FEC,705
07D98:  MOVFF  701,563
07D9C:  MOVFF  700,562
07DA0:  MOVFF  6F9,729
07DA4:  MOVLW  18
07DA6:  MOVWF  x2A
07DA8:  MOVLB  0
07DAA:  CALL   5C52
07DAE:  MOVLW  2C
07DB0:  MOVLB  7
07DB2:  MOVWF  x3E
07DB4:  MOVLB  0
07DB6:  CALL   5670
07DBA:  MOVLW  89
07DBC:  MOVWF  FE9
07DBE:  MOVFF  705,734
07DC2:  MOVFF  704,733
07DC6:  MOVFF  703,732
07DCA:  MOVFF  702,731
07DCE:  MOVLW  02
07DD0:  MOVLB  7
07DD2:  MOVWF  x35
07DD4:  MOVLB  0
07DD6:  CALL   656A
07DDA:  MOVLW  2C
07DDC:  MOVLB  7
07DDE:  MOVWF  x3E
07DE0:  MOVLB  0
07DE2:  CALL   5670
07DE6:  BRA    7EA0
07DE8:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07DEA:  MOVF   xFA,W
07DEC:  SUBLW  35
07DEE:  BNZ   7E98
07DF0:  MOVLW  04
07DF2:  MOVLB  7
07DF4:  MOVWF  x30
07DF6:  MOVLW  BF
07DF8:  MOVWF  x2F
07DFA:  MOVLB  0
07DFC:  CALL   5638
07E00:  MOVF   01,W
07E02:  ADDLW  BF
07E04:  MOVLB  7
07E06:  MOVWF  x00
07E08:  MOVLW  04
07E0A:  ADDWFC 02,W
07E0C:  MOVWF  x01
07E0E:  MOVLW  01
07E10:  MOVLB  6
07E12:  SUBWF  xF9,W
07E14:  MULLW  18
07E16:  MOVF   FF3,W
07E18:  MOVLB  7
07E1A:  CLRF   x03
07E1C:  MOVWF  x02
07E1E:  MOVLW  14
07E20:  ADDWF  x02,W
07E22:  MOVWF  01
07E24:  MOVLW  00
07E26:  ADDWFC x03,W
07E28:  MOVWF  03
07E2A:  MOVF   01,W
07E2C:  ADDLW  82
07E2E:  MOVWF  FE9
07E30:  MOVLW  00
07E32:  ADDWFC 03,W
07E34:  MOVWF  FEA
07E36:  MOVFF  FEF,702
07E3A:  MOVFF  FEC,703
07E3E:  MOVFF  FEC,704
07E42:  MOVFF  FEC,705
07E46:  MOVFF  701,563
07E4A:  MOVFF  700,562
07E4E:  MOVFF  6F9,729
07E52:  MOVLW  18
07E54:  MOVWF  x2A
07E56:  MOVLB  0
07E58:  CALL   5C52
07E5C:  MOVLW  2C
07E5E:  MOVLB  7
07E60:  MOVWF  x3E
07E62:  MOVLB  0
07E64:  CALL   5670
07E68:  MOVLW  89
07E6A:  MOVWF  FE9
07E6C:  MOVFF  705,734
07E70:  MOVFF  704,733
07E74:  MOVFF  703,732
07E78:  MOVFF  702,731
07E7C:  MOVLW  02
07E7E:  MOVLB  7
07E80:  MOVWF  x35
07E82:  MOVLB  0
07E84:  CALL   656A
07E88:  MOVLW  2C
07E8A:  MOVLB  7
07E8C:  MOVWF  x3E
07E8E:  MOVLB  0
07E90:  CALL   5670
07E94:  BRA    7EA0
07E96:  MOVLB  6
....................    else return INV_PARAM;
07E98:  MOVLW  02
07E9A:  MOVWF  01
07E9C:  MOVLB  0
07E9E:  BRA    7EA4
....................    
....................    return SUCCESS;
07EA0:  MOVLW  00
07EA2:  MOVWF  01
07EA4:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07EA6:  MOVLB  7
07EA8:  CLRF   x30
07EAA:  MOVFF  683,72F
07EAE:  CLRF   x32
07EB0:  MOVLW  B5
07EB2:  MOVWF  x31
07EB4:  MOVLB  0
07EB6:  CALL   0828
07EBA:  MOVFF  02,700
07EBE:  MOVFF  01,6FF
07EC2:  MOVLW  06
07EC4:  MOVLB  6
07EC6:  ADDWF  xFF,F
07EC8:  MOVLW  00
07ECA:  MOVLB  7
07ECC:  ADDWFC x00,F
07ECE:  MOVLW  32
07ED0:  MOVLB  6
07ED2:  ADDWF  xFF,W
07ED4:  MOVWF  01
07ED6:  MOVLW  00
07ED8:  MOVLB  7
07EDA:  ADDWFC x00,W
07EDC:  MOVWF  03
07EDE:  MOVF   01,W
07EE0:  ADDLW  E9
07EE2:  MOVWF  01
07EE4:  MOVLW  01
07EE6:  ADDWFC 03,F
07EE8:  MOVFF  01,6FF
07EEC:  MOVFF  03,700
07EF0:  MOVFF  03,729
07EF4:  MOVFF  01,728
07EF8:  MOVLB  0
07EFA:  CALL   580E
07EFE:  MOVF   01,F
07F00:  BNZ   7F0A
07F02:  MOVLW  02
07F04:  MOVWF  01
07F06:  BRA    8298
07F08:  BRA    7F70
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07F0A:  MOVLB  7
07F0C:  CLRF   x30
07F0E:  MOVFF  683,72F
07F12:  CLRF   x32
07F14:  MOVLW  B5
07F16:  MOVWF  x31
07F18:  MOVLB  0
07F1A:  CALL   0828
07F1E:  MOVFF  02,700
07F22:  MOVFF  01,6FF
07F26:  MOVLW  06
07F28:  MOVLB  6
07F2A:  ADDWF  xFF,F
07F2C:  MOVLW  00
07F2E:  MOVLB  7
07F30:  ADDWFC x00,F
07F32:  MOVLW  32
07F34:  MOVLB  6
07F36:  ADDWF  xFF,W
07F38:  MOVWF  01
07F3A:  MOVLW  00
07F3C:  MOVLB  7
07F3E:  ADDWFC x00,W
07F40:  MOVWF  03
07F42:  MOVF   01,W
07F44:  ADDLW  E9
07F46:  MOVWF  01
07F48:  MOVLW  01
07F4A:  ADDWFC 03,F
07F4C:  MOVFF  01,6FF
07F50:  MOVFF  03,700
07F54:  MOVFF  03,729
07F58:  MOVFF  01,728
07F5C:  MOVLB  7
07F5E:  CLRF   x2B
07F60:  CLRF   x2A
07F62:  MOVLW  0A
07F64:  MOVWF  x2C
07F66:  MOVLB  0
07F68:  CALL   58FE
07F6C:  MOVFF  01,6F9
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07F70:  MOVLB  7
07F72:  CLRF   x30
07F74:  MOVFF  683,72F
07F78:  CLRF   x32
07F7A:  MOVLW  B5
07F7C:  MOVWF  x31
07F7E:  MOVLB  0
07F80:  CALL   0828
07F84:  MOVFF  02,700
07F88:  MOVFF  01,6FF
07F8C:  MOVLW  06
07F8E:  MOVLB  6
07F90:  ADDWF  xFF,F
07F92:  MOVLW  00
07F94:  MOVLB  7
07F96:  ADDWFC x00,F
07F98:  MOVLW  4B
07F9A:  MOVLB  6
07F9C:  ADDWF  xFF,W
07F9E:  MOVWF  01
07FA0:  MOVLW  00
07FA2:  MOVLB  7
07FA4:  ADDWFC x00,W
07FA6:  MOVWF  03
07FA8:  MOVF   01,W
07FAA:  ADDLW  E9
07FAC:  MOVWF  01
07FAE:  MOVLW  01
07FB0:  ADDWFC 03,F
07FB2:  MOVFF  01,6FF
07FB6:  MOVFF  03,700
07FBA:  MOVFF  03,730
07FBE:  MOVFF  01,72F
07FC2:  MOVLB  0
07FC4:  CALL   5638
07FC8:  MOVFF  02,03
07FCC:  MOVF   01,W
07FCE:  SUBLW  01
07FD0:  BNZ   7FD6
07FD2:  MOVF   03,F
07FD4:  BZ    7FDE
07FD6:  MOVLW  02
07FD8:  MOVWF  01
07FDA:  BRA    8298
07FDC:  BRA    8028
....................    else arg2 = SERcmd[rec].p[3][0];
07FDE:  MOVLB  7
07FE0:  CLRF   x30
07FE2:  MOVFF  683,72F
07FE6:  CLRF   x32
07FE8:  MOVLW  B5
07FEA:  MOVWF  x31
07FEC:  MOVLB  0
07FEE:  CALL   0828
07FF2:  MOVFF  02,700
07FF6:  MOVFF  01,6FF
07FFA:  MOVLW  06
07FFC:  MOVLB  6
07FFE:  ADDWF  xFF,F
08000:  MOVLW  00
08002:  MOVLB  7
08004:  ADDWFC x00,F
08006:  MOVLW  4B
08008:  MOVLB  6
0800A:  ADDWF  xFF,F
0800C:  MOVLW  00
0800E:  MOVLB  7
08010:  ADDWFC x00,F
08012:  MOVLW  E9
08014:  MOVLB  6
08016:  ADDWF  xFF,W
08018:  MOVWF  FE9
0801A:  MOVLW  01
0801C:  MOVLB  7
0801E:  ADDWFC x00,W
08020:  MOVWF  FEA
08022:  MOVFF  FEF,6FA
08026:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
08028:  MOVLB  7
0802A:  CLRF   x30
0802C:  MOVFF  683,72F
08030:  CLRF   x32
08032:  MOVLW  B5
08034:  MOVWF  x31
08036:  MOVLB  0
08038:  CALL   0828
0803C:  MOVFF  02,700
08040:  MOVFF  01,6FF
08044:  MOVLW  06
08046:  MOVLB  6
08048:  ADDWF  xFF,F
0804A:  MOVLW  00
0804C:  MOVLB  7
0804E:  ADDWFC x00,F
08050:  MOVLW  64
08052:  MOVLB  6
08054:  ADDWF  xFF,W
08056:  MOVWF  01
08058:  MOVLW  00
0805A:  MOVLB  7
0805C:  ADDWFC x00,W
0805E:  MOVWF  03
08060:  MOVF   01,W
08062:  ADDLW  E9
08064:  MOVWF  01
08066:  MOVLW  01
08068:  ADDWFC 03,F
0806A:  MOVFF  01,6FF
0806E:  MOVFF  03,700
08072:  MOVFF  03,703
08076:  MOVFF  01,702
0807A:  MOVLB  0
0807C:  CALL   6BF0
08080:  MOVF   01,F
08082:  BNZ   808C
08084:  MOVLW  02
08086:  MOVWF  01
08088:  BRA    8298
0808A:  BRA    80FA
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0808C:  MOVLB  7
0808E:  CLRF   x30
08090:  MOVFF  683,72F
08094:  CLRF   x32
08096:  MOVLW  B5
08098:  MOVWF  x31
0809A:  MOVLB  0
0809C:  CALL   0828
080A0:  MOVFF  02,700
080A4:  MOVFF  01,6FF
080A8:  MOVLW  06
080AA:  MOVLB  6
080AC:  ADDWF  xFF,F
080AE:  MOVLW  00
080B0:  MOVLB  7
080B2:  ADDWFC x00,F
080B4:  MOVLW  64
080B6:  MOVLB  6
080B8:  ADDWF  xFF,W
080BA:  MOVWF  01
080BC:  MOVLW  00
080BE:  MOVLB  7
080C0:  ADDWFC x00,W
080C2:  MOVWF  03
080C4:  MOVF   01,W
080C6:  ADDLW  E9
080C8:  MOVWF  01
080CA:  MOVLW  01
080CC:  ADDWFC 03,F
080CE:  MOVFF  01,6FF
080D2:  MOVFF  03,700
080D6:  MOVFF  03,703
080DA:  MOVFF  01,702
080DE:  MOVLB  7
080E0:  CLRF   x05
080E2:  CLRF   x04
080E4:  MOVLB  0
080E6:  CALL   6CB2
080EA:  MOVFF  03,6FE
080EE:  MOVFF  02,6FD
080F2:  MOVFF  01,6FC
080F6:  MOVFF  00,6FB
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
080FA:  MOVLB  6
080FC:  MOVF   xFA,W
080FE:  SUBLW  30
08100:  BNZ   8134
08102:  MOVLW  01
08104:  SUBWF  xF9,W
08106:  MULLW  18
08108:  MOVF   FF3,W
0810A:  MOVLB  7
0810C:  CLRF   x00
0810E:  MOVLB  6
08110:  MOVWF  xFF
08112:  MOVLW  82
08114:  ADDWF  xFF,W
08116:  MOVWF  FE9
08118:  MOVLW  00
0811A:  MOVLB  7
0811C:  ADDWFC x00,W
0811E:  MOVWF  FEA
08120:  MOVFF  6FB,FEF
08124:  MOVFF  6FC,FEC
08128:  MOVFF  6FD,FEC
0812C:  MOVFF  6FE,FEC
08130:  BRA    8292
08132:  MOVLB  6
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08134:  MOVF   xFA,W
08136:  SUBLW  31
08138:  BNZ   8178
0813A:  MOVLW  01
0813C:  SUBWF  xF9,W
0813E:  MULLW  18
08140:  MOVF   FF3,W
08142:  MOVLB  7
08144:  CLRF   x00
08146:  MOVLB  6
08148:  MOVWF  xFF
0814A:  MOVLW  04
0814C:  ADDWF  xFF,W
0814E:  MOVWF  01
08150:  MOVLW  00
08152:  MOVLB  7
08154:  ADDWFC x00,W
08156:  MOVWF  03
08158:  MOVF   01,W
0815A:  ADDLW  82
0815C:  MOVWF  FE9
0815E:  MOVLW  00
08160:  ADDWFC 03,W
08162:  MOVWF  FEA
08164:  MOVFF  6FB,FEF
08168:  MOVFF  6FC,FEC
0816C:  MOVFF  6FD,FEC
08170:  MOVFF  6FE,FEC
08174:  BRA    8292
08176:  MOVLB  6
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08178:  MOVF   xFA,W
0817A:  SUBLW  32
0817C:  BNZ   81BC
0817E:  MOVLW  01
08180:  SUBWF  xF9,W
08182:  MULLW  18
08184:  MOVF   FF3,W
08186:  MOVLB  7
08188:  CLRF   x00
0818A:  MOVLB  6
0818C:  MOVWF  xFF
0818E:  MOVLW  08
08190:  ADDWF  xFF,W
08192:  MOVWF  01
08194:  MOVLW  00
08196:  MOVLB  7
08198:  ADDWFC x00,W
0819A:  MOVWF  03
0819C:  MOVF   01,W
0819E:  ADDLW  82
081A0:  MOVWF  FE9
081A2:  MOVLW  00
081A4:  ADDWFC 03,W
081A6:  MOVWF  FEA
081A8:  MOVFF  6FB,FEF
081AC:  MOVFF  6FC,FEC
081B0:  MOVFF  6FD,FEC
081B4:  MOVFF  6FE,FEC
081B8:  BRA    8292
081BA:  MOVLB  6
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
081BC:  MOVF   xFA,W
081BE:  SUBLW  33
081C0:  BNZ   8200
081C2:  MOVLW  01
081C4:  SUBWF  xF9,W
081C6:  MULLW  18
081C8:  MOVF   FF3,W
081CA:  MOVLB  7
081CC:  CLRF   x00
081CE:  MOVLB  6
081D0:  MOVWF  xFF
081D2:  MOVLW  0C
081D4:  ADDWF  xFF,W
081D6:  MOVWF  01
081D8:  MOVLW  00
081DA:  MOVLB  7
081DC:  ADDWFC x00,W
081DE:  MOVWF  03
081E0:  MOVF   01,W
081E2:  ADDLW  82
081E4:  MOVWF  FE9
081E6:  MOVLW  00
081E8:  ADDWFC 03,W
081EA:  MOVWF  FEA
081EC:  MOVFF  6FB,FEF
081F0:  MOVFF  6FC,FEC
081F4:  MOVFF  6FD,FEC
081F8:  MOVFF  6FE,FEC
081FC:  BRA    8292
081FE:  MOVLB  6
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08200:  MOVF   xFA,W
08202:  SUBLW  34
08204:  BNZ   8244
08206:  MOVLW  01
08208:  SUBWF  xF9,W
0820A:  MULLW  18
0820C:  MOVF   FF3,W
0820E:  MOVLB  7
08210:  CLRF   x00
08212:  MOVLB  6
08214:  MOVWF  xFF
08216:  MOVLW  10
08218:  ADDWF  xFF,W
0821A:  MOVWF  01
0821C:  MOVLW  00
0821E:  MOVLB  7
08220:  ADDWFC x00,W
08222:  MOVWF  03
08224:  MOVF   01,W
08226:  ADDLW  82
08228:  MOVWF  FE9
0822A:  MOVLW  00
0822C:  ADDWFC 03,W
0822E:  MOVWF  FEA
08230:  MOVFF  6FB,FEF
08234:  MOVFF  6FC,FEC
08238:  MOVFF  6FD,FEC
0823C:  MOVFF  6FE,FEC
08240:  BRA    8292
08242:  MOVLB  6
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08244:  MOVF   xFA,W
08246:  SUBLW  35
08248:  BNZ   8288
0824A:  MOVLW  01
0824C:  SUBWF  xF9,W
0824E:  MULLW  18
08250:  MOVF   FF3,W
08252:  MOVLB  7
08254:  CLRF   x00
08256:  MOVLB  6
08258:  MOVWF  xFF
0825A:  MOVLW  14
0825C:  ADDWF  xFF,W
0825E:  MOVWF  01
08260:  MOVLW  00
08262:  MOVLB  7
08264:  ADDWFC x00,W
08266:  MOVWF  03
08268:  MOVF   01,W
0826A:  ADDLW  82
0826C:  MOVWF  FE9
0826E:  MOVLW  00
08270:  ADDWFC 03,W
08272:  MOVWF  FEA
08274:  MOVFF  6FB,FEF
08278:  MOVFF  6FC,FEC
0827C:  MOVFF  6FD,FEC
08280:  MOVFF  6FE,FEC
08284:  BRA    8292
08286:  MOVLB  6
....................    else return INV_PARAM;
08288:  MOVLW  02
0828A:  MOVWF  01
0828C:  MOVLB  0
0828E:  BRA    8298
08290:  MOVLB  7
....................    
....................    return SUCCESS;
08292:  MOVLW  00
08294:  MOVWF  01
08296:  MOVLB  0
08298:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0829A:  MOVLW  4E
0829C:  MOVLB  6
0829E:  MOVWF  xFD
082A0:  MOVLW  31
082A2:  MOVWF  xFE
082A4:  MOVLW  35
082A6:  MOVWF  xFF
082A8:  MOVLB  7
082AA:  CLRF   x00
082AC:  MOVLW  06
082AE:  MOVLB  6
082B0:  MOVWF  xFC
082B2:  MOVLW  FD
082B4:  MOVWF  xFB
....................    char *s_200 = "200";
082B6:  MOVLW  32
082B8:  MOVLB  7
082BA:  MOVWF  x03
082BC:  MOVLW  30
082BE:  MOVWF  x04
082C0:  MOVWF  x05
082C2:  CLRF   x06
082C4:  MOVLW  07
082C6:  MOVWF  x02
082C8:  MOVLW  03
082CA:  MOVWF  x01
....................    char *s_5V6 = "5V6";
082CC:  MOVLW  35
082CE:  MOVWF  x09
082D0:  MOVLW  56
082D2:  MOVWF  x0A
082D4:  MOVLW  36
082D6:  MOVWF  x0B
082D8:  CLRF   x0C
082DA:  MOVLW  07
082DC:  MOVWF  x08
082DE:  MOVLW  09
082E0:  MOVWF  x07
....................    char *s_5VA = "5VA";
082E2:  MOVLW  35
082E4:  MOVWF  x0F
082E6:  MOVLW  56
082E8:  MOVWF  x10
082EA:  MOVLW  41
082EC:  MOVWF  x11
082EE:  CLRF   x12
082F0:  MOVLW  07
082F2:  MOVWF  x0E
082F4:  MOVLW  0F
082F6:  MOVWF  x0D
....................    char *s_3V6X = "3V6X";
082F8:  MOVLW  33
082FA:  MOVWF  x15
082FC:  MOVLW  56
082FE:  MOVWF  x16
08300:  MOVLW  36
08302:  MOVWF  x17
08304:  MOVLW  58
08306:  MOVWF  x18
08308:  CLRF   x19
0830A:  MOVLW  07
0830C:  MOVWF  x14
0830E:  MOVLW  15
08310:  MOVWF  x13
....................    char *s_3V3A = "3V3A";
08312:  MOVLW  33
08314:  MOVWF  x1C
08316:  MOVLW  56
08318:  MOVWF  x1D
0831A:  MOVLW  33
0831C:  MOVWF  x1E
0831E:  MOVLW  41
08320:  MOVWF  x1F
08322:  CLRF   x20
08324:  MOVLW  07
08326:  MOVWF  x1B
08328:  MOVLW  1C
0832A:  MOVWF  x1A
....................    char *s_3V3D = "3V3D";
0832C:  MOVLW  33
0832E:  MOVWF  x23
08330:  MOVLW  56
08332:  MOVWF  x24
08334:  MOVLW  33
08336:  MOVWF  x25
08338:  MOVLW  44
0833A:  MOVWF  x26
0833C:  CLRF   x27
0833E:  MOVLW  07
08340:  MOVWF  x22
08342:  MOVLW  23
08344:  MOVWF  x21
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08346:  CLRF   x30
08348:  MOVFF  683,72F
0834C:  CLRF   x32
0834E:  MOVLW  B5
08350:  MOVWF  x31
08352:  MOVLB  0
08354:  CALL   0828
08358:  MOVFF  02,729
0835C:  MOVFF  01,728
08360:  MOVLW  06
08362:  MOVLB  7
08364:  ADDWF  x28,F
08366:  MOVLW  00
08368:  ADDWFC x29,F
0836A:  MOVLW  32
0836C:  ADDWF  x28,W
0836E:  MOVWF  01
08370:  MOVLW  00
08372:  ADDWFC x29,W
08374:  MOVWF  03
08376:  MOVF   01,W
08378:  ADDLW  E9
0837A:  MOVWF  01
0837C:  MOVLW  01
0837E:  ADDWFC 03,F
08380:  MOVFF  01,6F9
08384:  MOVLB  6
08386:  MOVFF  03,6FA
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0838A:  MOVFF  6FC,730
0838E:  MOVFF  6FB,72F
08392:  MOVFF  6FA,732
08396:  MOVFF  6F9,731
0839A:  MOVLB  0
0839C:  CALL   56EE
083A0:  MOVF   01,F
083A2:  BNZ   8426
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
083A4:  MOVLW  04
083A6:  MOVLB  7
083A8:  MOVWF  x30
083AA:  MOVLW  BF
083AC:  MOVWF  x2F
083AE:  MOVLB  0
083B0:  CALL   5638
083B4:  MOVFF  02,03
083B8:  MOVF   01,W
083BA:  ADDLW  BF
083BC:  MOVLB  7
083BE:  MOVWF  x28
083C0:  MOVLW  04
083C2:  ADDWFC 02,W
083C4:  MOVWF  x29
083C6:  MOVFF  FE8,563
083CA:  MOVFF  728,562
083CE:  MOVLW  89
083D0:  MOVWF  FE9
083D2:  MOVFF  B5,734
083D6:  MOVFF  B4,733
083DA:  MOVFF  B3,732
083DE:  MOVFF  B2,731
083E2:  MOVLW  02
083E4:  MOVWF  x35
083E6:  MOVLB  0
083E8:  CALL   656A
083EC:  MOVLW  2C
083EE:  MOVLB  7
083F0:  MOVWF  x3E
083F2:  MOVLB  0
083F4:  CALL   5670
083F8:  MOVLW  89
083FA:  MOVWF  FE9
083FC:  MOVFF  B9,734
08400:  MOVFF  B8,733
08404:  MOVFF  B7,732
08408:  MOVFF  B6,731
0840C:  MOVLW  02
0840E:  MOVLB  7
08410:  MOVWF  x35
08412:  MOVLB  0
08414:  CALL   656A
08418:  MOVLW  2C
0841A:  MOVLB  7
0841C:  MOVWF  x3E
0841E:  MOVLB  0
08420:  CALL   5670
....................    }
08424:  BRA    87C8
....................    else if (0 == strcmp(s_200, arg1)) {
08426:  MOVFF  702,730
0842A:  MOVFF  701,72F
0842E:  MOVFF  6FA,732
08432:  MOVFF  6F9,731
08436:  CALL   56EE
0843A:  MOVF   01,F
0843C:  BNZ   84C0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
0843E:  MOVLW  04
08440:  MOVLB  7
08442:  MOVWF  x30
08444:  MOVLW  BF
08446:  MOVWF  x2F
08448:  MOVLB  0
0844A:  CALL   5638
0844E:  MOVFF  02,03
08452:  MOVF   01,W
08454:  ADDLW  BF
08456:  MOVLB  7
08458:  MOVWF  x28
0845A:  MOVLW  04
0845C:  ADDWFC 02,W
0845E:  MOVWF  x29
08460:  MOVFF  FE8,563
08464:  MOVFF  728,562
08468:  MOVLW  89
0846A:  MOVWF  FE9
0846C:  MOVFF  BD,734
08470:  MOVFF  BC,733
08474:  MOVFF  BB,732
08478:  MOVFF  BA,731
0847C:  MOVLW  02
0847E:  MOVWF  x35
08480:  MOVLB  0
08482:  CALL   656A
08486:  MOVLW  2C
08488:  MOVLB  7
0848A:  MOVWF  x3E
0848C:  MOVLB  0
0848E:  CALL   5670
08492:  MOVLW  89
08494:  MOVWF  FE9
08496:  MOVFF  C1,734
0849A:  MOVFF  C0,733
0849E:  MOVFF  BF,732
084A2:  MOVFF  BE,731
084A6:  MOVLW  02
084A8:  MOVLB  7
084AA:  MOVWF  x35
084AC:  MOVLB  0
084AE:  CALL   656A
084B2:  MOVLW  2C
084B4:  MOVLB  7
084B6:  MOVWF  x3E
084B8:  MOVLB  0
084BA:  CALL   5670
....................    }
084BE:  BRA    87C8
....................    else if (0 == strcmp(s_5V6, arg1)) {
084C0:  MOVFF  708,730
084C4:  MOVFF  707,72F
084C8:  MOVFF  6FA,732
084CC:  MOVFF  6F9,731
084D0:  CALL   56EE
084D4:  MOVF   01,F
084D6:  BNZ   855A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
084D8:  MOVLW  04
084DA:  MOVLB  7
084DC:  MOVWF  x30
084DE:  MOVLW  BF
084E0:  MOVWF  x2F
084E2:  MOVLB  0
084E4:  CALL   5638
084E8:  MOVFF  02,03
084EC:  MOVF   01,W
084EE:  ADDLW  BF
084F0:  MOVLB  7
084F2:  MOVWF  x28
084F4:  MOVLW  04
084F6:  ADDWFC 02,W
084F8:  MOVWF  x29
084FA:  MOVFF  FE8,563
084FE:  MOVFF  728,562
08502:  MOVLW  89
08504:  MOVWF  FE9
08506:  MOVFF  C5,734
0850A:  MOVFF  C4,733
0850E:  MOVFF  C3,732
08512:  MOVFF  C2,731
08516:  MOVLW  02
08518:  MOVWF  x35
0851A:  MOVLB  0
0851C:  CALL   656A
08520:  MOVLW  2C
08522:  MOVLB  7
08524:  MOVWF  x3E
08526:  MOVLB  0
08528:  CALL   5670
0852C:  MOVLW  89
0852E:  MOVWF  FE9
08530:  MOVFF  C9,734
08534:  MOVFF  C8,733
08538:  MOVFF  C7,732
0853C:  MOVFF  C6,731
08540:  MOVLW  02
08542:  MOVLB  7
08544:  MOVWF  x35
08546:  MOVLB  0
08548:  CALL   656A
0854C:  MOVLW  2C
0854E:  MOVLB  7
08550:  MOVWF  x3E
08552:  MOVLB  0
08554:  CALL   5670
....................    }
08558:  BRA    87C8
....................    else if (0 == strcmp(s_5VA, arg1)) {
0855A:  MOVFF  70E,730
0855E:  MOVFF  70D,72F
08562:  MOVFF  6FA,732
08566:  MOVFF  6F9,731
0856A:  CALL   56EE
0856E:  MOVF   01,F
08570:  BNZ   85F4
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08572:  MOVLW  04
08574:  MOVLB  7
08576:  MOVWF  x30
08578:  MOVLW  BF
0857A:  MOVWF  x2F
0857C:  MOVLB  0
0857E:  CALL   5638
08582:  MOVFF  02,03
08586:  MOVF   01,W
08588:  ADDLW  BF
0858A:  MOVLB  7
0858C:  MOVWF  x28
0858E:  MOVLW  04
08590:  ADDWFC 02,W
08592:  MOVWF  x29
08594:  MOVFF  FE8,563
08598:  MOVFF  728,562
0859C:  MOVLW  89
0859E:  MOVWF  FE9
085A0:  MOVFF  CD,734
085A4:  MOVFF  CC,733
085A8:  MOVFF  CB,732
085AC:  MOVFF  CA,731
085B0:  MOVLW  02
085B2:  MOVWF  x35
085B4:  MOVLB  0
085B6:  CALL   656A
085BA:  MOVLW  2C
085BC:  MOVLB  7
085BE:  MOVWF  x3E
085C0:  MOVLB  0
085C2:  CALL   5670
085C6:  MOVLW  89
085C8:  MOVWF  FE9
085CA:  MOVFF  D1,734
085CE:  MOVFF  D0,733
085D2:  MOVFF  CF,732
085D6:  MOVFF  CE,731
085DA:  MOVLW  02
085DC:  MOVLB  7
085DE:  MOVWF  x35
085E0:  MOVLB  0
085E2:  CALL   656A
085E6:  MOVLW  2C
085E8:  MOVLB  7
085EA:  MOVWF  x3E
085EC:  MOVLB  0
085EE:  CALL   5670
....................    }
085F2:  BRA    87C8
....................    else if (0 == strcmp(s_3V6X, arg1)) {
085F4:  MOVFF  714,730
085F8:  MOVFF  713,72F
085FC:  MOVFF  6FA,732
08600:  MOVFF  6F9,731
08604:  CALL   56EE
08608:  MOVF   01,F
0860A:  BNZ   868E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
0860C:  MOVLW  04
0860E:  MOVLB  7
08610:  MOVWF  x30
08612:  MOVLW  BF
08614:  MOVWF  x2F
08616:  MOVLB  0
08618:  CALL   5638
0861C:  MOVFF  02,03
08620:  MOVF   01,W
08622:  ADDLW  BF
08624:  MOVLB  7
08626:  MOVWF  x28
08628:  MOVLW  04
0862A:  ADDWFC 02,W
0862C:  MOVWF  x29
0862E:  MOVFF  FE8,563
08632:  MOVFF  728,562
08636:  MOVLW  89
08638:  MOVWF  FE9
0863A:  MOVFF  D5,734
0863E:  MOVFF  D4,733
08642:  MOVFF  D3,732
08646:  MOVFF  D2,731
0864A:  MOVLW  02
0864C:  MOVWF  x35
0864E:  MOVLB  0
08650:  CALL   656A
08654:  MOVLW  2C
08656:  MOVLB  7
08658:  MOVWF  x3E
0865A:  MOVLB  0
0865C:  CALL   5670
08660:  MOVLW  89
08662:  MOVWF  FE9
08664:  MOVFF  D9,734
08668:  MOVFF  D8,733
0866C:  MOVFF  D7,732
08670:  MOVFF  D6,731
08674:  MOVLW  02
08676:  MOVLB  7
08678:  MOVWF  x35
0867A:  MOVLB  0
0867C:  CALL   656A
08680:  MOVLW  2C
08682:  MOVLB  7
08684:  MOVWF  x3E
08686:  MOVLB  0
08688:  CALL   5670
....................    }
0868C:  BRA    87C8
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0868E:  MOVFF  71B,730
08692:  MOVFF  71A,72F
08696:  MOVFF  6FA,732
0869A:  MOVFF  6F9,731
0869E:  CALL   56EE
086A2:  MOVF   01,F
086A4:  BNZ   8728
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
086A6:  MOVLW  04
086A8:  MOVLB  7
086AA:  MOVWF  x30
086AC:  MOVLW  BF
086AE:  MOVWF  x2F
086B0:  MOVLB  0
086B2:  CALL   5638
086B6:  MOVFF  02,03
086BA:  MOVF   01,W
086BC:  ADDLW  BF
086BE:  MOVLB  7
086C0:  MOVWF  x28
086C2:  MOVLW  04
086C4:  ADDWFC 02,W
086C6:  MOVWF  x29
086C8:  MOVFF  FE8,563
086CC:  MOVFF  728,562
086D0:  MOVLW  89
086D2:  MOVWF  FE9
086D4:  MOVFF  DD,734
086D8:  MOVFF  DC,733
086DC:  MOVFF  DB,732
086E0:  MOVFF  DA,731
086E4:  MOVLW  02
086E6:  MOVWF  x35
086E8:  MOVLB  0
086EA:  CALL   656A
086EE:  MOVLW  2C
086F0:  MOVLB  7
086F2:  MOVWF  x3E
086F4:  MOVLB  0
086F6:  CALL   5670
086FA:  MOVLW  89
086FC:  MOVWF  FE9
086FE:  MOVFF  E1,734
08702:  MOVFF  E0,733
08706:  MOVFF  DF,732
0870A:  MOVFF  DE,731
0870E:  MOVLW  02
08710:  MOVLB  7
08712:  MOVWF  x35
08714:  MOVLB  0
08716:  CALL   656A
0871A:  MOVLW  2C
0871C:  MOVLB  7
0871E:  MOVWF  x3E
08720:  MOVLB  0
08722:  CALL   5670
....................    }
08726:  BRA    87C8
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08728:  MOVFF  722,730
0872C:  MOVFF  721,72F
08730:  MOVFF  6FA,732
08734:  MOVFF  6F9,731
08738:  CALL   56EE
0873C:  MOVF   01,F
0873E:  BNZ   87C2
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08740:  MOVLW  04
08742:  MOVLB  7
08744:  MOVWF  x30
08746:  MOVLW  BF
08748:  MOVWF  x2F
0874A:  MOVLB  0
0874C:  CALL   5638
08750:  MOVFF  02,03
08754:  MOVF   01,W
08756:  ADDLW  BF
08758:  MOVLB  7
0875A:  MOVWF  x28
0875C:  MOVLW  04
0875E:  ADDWFC 02,W
08760:  MOVWF  x29
08762:  MOVFF  FE8,563
08766:  MOVFF  728,562
0876A:  MOVLW  89
0876C:  MOVWF  FE9
0876E:  MOVFF  E5,734
08772:  MOVFF  E4,733
08776:  MOVFF  E3,732
0877A:  MOVFF  E2,731
0877E:  MOVLW  02
08780:  MOVWF  x35
08782:  MOVLB  0
08784:  CALL   656A
08788:  MOVLW  2C
0878A:  MOVLB  7
0878C:  MOVWF  x3E
0878E:  MOVLB  0
08790:  CALL   5670
08794:  MOVLW  89
08796:  MOVWF  FE9
08798:  MOVFF  E9,734
0879C:  MOVFF  E8,733
087A0:  MOVFF  E7,732
087A4:  MOVFF  E6,731
087A8:  MOVLW  02
087AA:  MOVLB  7
087AC:  MOVWF  x35
087AE:  MOVLB  0
087B0:  CALL   656A
087B4:  MOVLW  2C
087B6:  MOVLB  7
087B8:  MOVWF  x3E
087BA:  MOVLB  0
087BC:  CALL   5670
....................    }
087C0:  BRA    87C8
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
087C2:  MOVLW  02
087C4:  MOVWF  01
087C6:  BRA    87CC
....................    
....................    return SUCCESS;
087C8:  MOVLW  00
087CA:  MOVWF  01
087CC:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
087CE:  MOVLW  00
087D0:  MOVWF  01
087D2:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
087D4:  MOVLW  4E
087D6:  MOVLB  6
087D8:  MOVWF  xFD
087DA:  MOVLW  31
087DC:  MOVWF  xFE
087DE:  MOVLW  35
087E0:  MOVWF  xFF
087E2:  MOVLB  7
087E4:  CLRF   x00
087E6:  MOVLW  06
087E8:  MOVLB  6
087EA:  MOVWF  xFC
087EC:  MOVLW  FD
087EE:  MOVWF  xFB
....................    char *s_200 = "200";
087F0:  MOVLW  32
087F2:  MOVLB  7
087F4:  MOVWF  x03
087F6:  MOVLW  30
087F8:  MOVWF  x04
087FA:  MOVWF  x05
087FC:  CLRF   x06
087FE:  MOVLW  07
08800:  MOVWF  x02
08802:  MOVLW  03
08804:  MOVWF  x01
....................    char *s_5V6 = "5V6";
08806:  MOVLW  35
08808:  MOVWF  x09
0880A:  MOVLW  56
0880C:  MOVWF  x0A
0880E:  MOVLW  36
08810:  MOVWF  x0B
08812:  CLRF   x0C
08814:  MOVLW  07
08816:  MOVWF  x08
08818:  MOVLW  09
0881A:  MOVWF  x07
....................    char *s_5VA = "5VA";
0881C:  MOVLW  35
0881E:  MOVWF  x0F
08820:  MOVLW  56
08822:  MOVWF  x10
08824:  MOVLW  41
08826:  MOVWF  x11
08828:  CLRF   x12
0882A:  MOVLW  07
0882C:  MOVWF  x0E
0882E:  MOVLW  0F
08830:  MOVWF  x0D
....................    char *s_3V6X = "3V6X";
08832:  MOVLW  33
08834:  MOVWF  x15
08836:  MOVLW  56
08838:  MOVWF  x16
0883A:  MOVLW  36
0883C:  MOVWF  x17
0883E:  MOVLW  58
08840:  MOVWF  x18
08842:  CLRF   x19
08844:  MOVLW  07
08846:  MOVWF  x14
08848:  MOVLW  15
0884A:  MOVWF  x13
....................    char *s_3V3A = "3V3A";
0884C:  MOVLW  33
0884E:  MOVWF  x1C
08850:  MOVLW  56
08852:  MOVWF  x1D
08854:  MOVLW  33
08856:  MOVWF  x1E
08858:  MOVLW  41
0885A:  MOVWF  x1F
0885C:  CLRF   x20
0885E:  MOVLW  07
08860:  MOVWF  x1B
08862:  MOVLW  1C
08864:  MOVWF  x1A
....................    char *s_3V3D = "3V3D";
08866:  MOVLW  33
08868:  MOVWF  x23
0886A:  MOVLW  56
0886C:  MOVWF  x24
0886E:  MOVLW  33
08870:  MOVWF  x25
08872:  MOVLW  44
08874:  MOVWF  x26
08876:  CLRF   x27
08878:  MOVLW  07
0887A:  MOVWF  x22
0887C:  MOVLW  23
0887E:  MOVWF  x21
....................    char *s_all = "all";
08880:  MOVLW  61
08882:  MOVWF  x2A
08884:  MOVLW  6C
08886:  MOVWF  x2B
08888:  MOVWF  x2C
0888A:  CLRF   x2D
0888C:  MOVLW  07
0888E:  MOVWF  x29
08890:  MOVLW  2A
08892:  MOVWF  x28
....................    
....................    arg1 = SERcmd[rec].p[2];
08894:  CLRF   x30
08896:  MOVFF  683,72F
0889A:  CLRF   x32
0889C:  MOVLW  B5
0889E:  MOVWF  x31
088A0:  MOVLB  0
088A2:  CALL   0828
088A6:  MOVFF  02,72F
088AA:  MOVFF  01,72E
088AE:  MOVLW  06
088B0:  MOVLB  7
088B2:  ADDWF  x2E,F
088B4:  MOVLW  00
088B6:  ADDWFC x2F,F
088B8:  MOVLW  32
088BA:  ADDWF  x2E,W
088BC:  MOVWF  01
088BE:  MOVLW  00
088C0:  ADDWFC x2F,W
088C2:  MOVWF  03
088C4:  MOVF   01,W
088C6:  ADDLW  E9
088C8:  MOVWF  01
088CA:  MOVLW  01
088CC:  ADDWFC 03,F
088CE:  MOVFF  01,6F9
088D2:  MOVLB  6
088D4:  MOVFF  03,6FA
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
088D8:  MOVFF  6FC,730
088DC:  MOVFF  6FB,72F
088E0:  MOVFF  6FA,732
088E4:  MOVFF  6F9,731
088E8:  MOVLB  0
088EA:  CALL   56EE
088EE:  MOVF   01,F
088F0:  BNZ   8948
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
088F2:  MOVLW  04
088F4:  MOVLB  7
088F6:  MOVWF  x30
088F8:  MOVLW  BF
088FA:  MOVWF  x2F
088FC:  MOVLB  0
088FE:  CALL   5638
08902:  MOVFF  02,03
08906:  MOVF   01,W
08908:  ADDLW  BF
0890A:  MOVLB  7
0890C:  MOVWF  x2E
0890E:  MOVLW  04
08910:  ADDWFC 02,W
08912:  MOVWF  x2F
08914:  MOVFF  FE8,563
08918:  MOVFF  72E,562
0891C:  MOVLW  89
0891E:  MOVWF  FE9
08920:  MOVFF  EE,734
08924:  MOVFF  ED,733
08928:  MOVFF  EC,732
0892C:  MOVFF  EB,731
08930:  MOVLW  02
08932:  MOVWF  x35
08934:  MOVLB  0
08936:  CALL   656A
0893A:  MOVLW  2C
0893C:  MOVLB  7
0893E:  MOVWF  x3E
08940:  MOVLB  0
08942:  CALL   5670
....................    }
08946:  BRA    8E4A
....................    else if (0 == strcmp(s_200, arg1)) {
08948:  MOVFF  702,730
0894C:  MOVFF  701,72F
08950:  MOVFF  6FA,732
08954:  MOVFF  6F9,731
08958:  CALL   56EE
0895C:  MOVF   01,F
0895E:  BNZ   89B6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08960:  MOVLW  04
08962:  MOVLB  7
08964:  MOVWF  x30
08966:  MOVLW  BF
08968:  MOVWF  x2F
0896A:  MOVLB  0
0896C:  CALL   5638
08970:  MOVFF  02,03
08974:  MOVF   01,W
08976:  ADDLW  BF
08978:  MOVLB  7
0897A:  MOVWF  x2E
0897C:  MOVLW  04
0897E:  ADDWFC 02,W
08980:  MOVWF  x2F
08982:  MOVFF  FE8,563
08986:  MOVFF  72E,562
0898A:  MOVLW  89
0898C:  MOVWF  FE9
0898E:  MOVFF  F2,734
08992:  MOVFF  F1,733
08996:  MOVFF  F0,732
0899A:  MOVFF  EF,731
0899E:  MOVLW  01
089A0:  MOVWF  x35
089A2:  MOVLB  0
089A4:  CALL   656A
089A8:  MOVLW  2C
089AA:  MOVLB  7
089AC:  MOVWF  x3E
089AE:  MOVLB  0
089B0:  CALL   5670
....................    }
089B4:  BRA    8E4A
....................    else if (0 == strcmp(s_5V6, arg1)) {
089B6:  MOVFF  708,730
089BA:  MOVFF  707,72F
089BE:  MOVFF  6FA,732
089C2:  MOVFF  6F9,731
089C6:  CALL   56EE
089CA:  MOVF   01,F
089CC:  BNZ   8A24
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
089CE:  MOVLW  04
089D0:  MOVLB  7
089D2:  MOVWF  x30
089D4:  MOVLW  BF
089D6:  MOVWF  x2F
089D8:  MOVLB  0
089DA:  CALL   5638
089DE:  MOVFF  02,03
089E2:  MOVF   01,W
089E4:  ADDLW  BF
089E6:  MOVLB  7
089E8:  MOVWF  x2E
089EA:  MOVLW  04
089EC:  ADDWFC 02,W
089EE:  MOVWF  x2F
089F0:  MOVFF  FE8,563
089F4:  MOVFF  72E,562
089F8:  MOVLW  89
089FA:  MOVWF  FE9
089FC:  MOVFF  F6,734
08A00:  MOVFF  F5,733
08A04:  MOVFF  F4,732
08A08:  MOVFF  F3,731
08A0C:  MOVLW  03
08A0E:  MOVWF  x35
08A10:  MOVLB  0
08A12:  CALL   656A
08A16:  MOVLW  2C
08A18:  MOVLB  7
08A1A:  MOVWF  x3E
08A1C:  MOVLB  0
08A1E:  CALL   5670
....................    }
08A22:  BRA    8E4A
....................    else if (0 == strcmp(s_5VA, arg1)) {
08A24:  MOVFF  70E,730
08A28:  MOVFF  70D,72F
08A2C:  MOVFF  6FA,732
08A30:  MOVFF  6F9,731
08A34:  CALL   56EE
08A38:  MOVF   01,F
08A3A:  BNZ   8A92
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08A3C:  MOVLW  04
08A3E:  MOVLB  7
08A40:  MOVWF  x30
08A42:  MOVLW  BF
08A44:  MOVWF  x2F
08A46:  MOVLB  0
08A48:  CALL   5638
08A4C:  MOVFF  02,03
08A50:  MOVF   01,W
08A52:  ADDLW  BF
08A54:  MOVLB  7
08A56:  MOVWF  x2E
08A58:  MOVLW  04
08A5A:  ADDWFC 02,W
08A5C:  MOVWF  x2F
08A5E:  MOVFF  FE8,563
08A62:  MOVFF  72E,562
08A66:  MOVLW  89
08A68:  MOVWF  FE9
08A6A:  MOVFF  FA,734
08A6E:  MOVFF  F9,733
08A72:  MOVFF  F8,732
08A76:  MOVFF  F7,731
08A7A:  MOVLW  03
08A7C:  MOVWF  x35
08A7E:  MOVLB  0
08A80:  CALL   656A
08A84:  MOVLW  2C
08A86:  MOVLB  7
08A88:  MOVWF  x3E
08A8A:  MOVLB  0
08A8C:  CALL   5670
....................    }
08A90:  BRA    8E4A
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08A92:  MOVFF  714,730
08A96:  MOVFF  713,72F
08A9A:  MOVFF  6FA,732
08A9E:  MOVFF  6F9,731
08AA2:  CALL   56EE
08AA6:  MOVF   01,F
08AA8:  BNZ   8B00
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08AAA:  MOVLW  04
08AAC:  MOVLB  7
08AAE:  MOVWF  x30
08AB0:  MOVLW  BF
08AB2:  MOVWF  x2F
08AB4:  MOVLB  0
08AB6:  CALL   5638
08ABA:  MOVFF  02,03
08ABE:  MOVF   01,W
08AC0:  ADDLW  BF
08AC2:  MOVLB  7
08AC4:  MOVWF  x2E
08AC6:  MOVLW  04
08AC8:  ADDWFC 02,W
08ACA:  MOVWF  x2F
08ACC:  MOVFF  FE8,563
08AD0:  MOVFF  72E,562
08AD4:  MOVLW  89
08AD6:  MOVWF  FE9
08AD8:  MOVFF  FE,734
08ADC:  MOVFF  FD,733
08AE0:  MOVFF  FC,732
08AE4:  MOVFF  FB,731
08AE8:  MOVLW  03
08AEA:  MOVWF  x35
08AEC:  MOVLB  0
08AEE:  CALL   656A
08AF2:  MOVLW  2C
08AF4:  MOVLB  7
08AF6:  MOVWF  x3E
08AF8:  MOVLB  0
08AFA:  CALL   5670
....................    }
08AFE:  BRA    8E4A
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08B00:  MOVFF  71B,730
08B04:  MOVFF  71A,72F
08B08:  MOVFF  6FA,732
08B0C:  MOVFF  6F9,731
08B10:  CALL   56EE
08B14:  MOVF   01,F
08B16:  BNZ   8B6E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08B18:  MOVLW  04
08B1A:  MOVLB  7
08B1C:  MOVWF  x30
08B1E:  MOVLW  BF
08B20:  MOVWF  x2F
08B22:  MOVLB  0
08B24:  CALL   5638
08B28:  MOVFF  02,03
08B2C:  MOVF   01,W
08B2E:  ADDLW  BF
08B30:  MOVLB  7
08B32:  MOVWF  x2E
08B34:  MOVLW  04
08B36:  ADDWFC 02,W
08B38:  MOVWF  x2F
08B3A:  MOVFF  FE8,563
08B3E:  MOVFF  72E,562
08B42:  MOVLW  89
08B44:  MOVWF  FE9
08B46:  MOVFF  102,734
08B4A:  MOVFF  101,733
08B4E:  MOVFF  100,732
08B52:  MOVFF  FF,731
08B56:  MOVLW  03
08B58:  MOVWF  x35
08B5A:  MOVLB  0
08B5C:  CALL   656A
08B60:  MOVLW  2C
08B62:  MOVLB  7
08B64:  MOVWF  x3E
08B66:  MOVLB  0
08B68:  CALL   5670
....................    }
08B6C:  BRA    8E4A
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08B6E:  MOVFF  722,730
08B72:  MOVFF  721,72F
08B76:  MOVFF  6FA,732
08B7A:  MOVFF  6F9,731
08B7E:  CALL   56EE
08B82:  MOVF   01,F
08B84:  BNZ   8BDC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08B86:  MOVLW  04
08B88:  MOVLB  7
08B8A:  MOVWF  x30
08B8C:  MOVLW  BF
08B8E:  MOVWF  x2F
08B90:  MOVLB  0
08B92:  CALL   5638
08B96:  MOVFF  02,03
08B9A:  MOVF   01,W
08B9C:  ADDLW  BF
08B9E:  MOVLB  7
08BA0:  MOVWF  x2E
08BA2:  MOVLW  04
08BA4:  ADDWFC 02,W
08BA6:  MOVWF  x2F
08BA8:  MOVFF  FE8,563
08BAC:  MOVFF  72E,562
08BB0:  MOVLW  89
08BB2:  MOVWF  FE9
08BB4:  MOVFF  106,734
08BB8:  MOVFF  105,733
08BBC:  MOVFF  104,732
08BC0:  MOVFF  103,731
08BC4:  MOVLW  03
08BC6:  MOVWF  x35
08BC8:  MOVLB  0
08BCA:  CALL   656A
08BCE:  MOVLW  2C
08BD0:  MOVLB  7
08BD2:  MOVWF  x3E
08BD4:  MOVLB  0
08BD6:  CALL   5670
....................    }
08BDA:  BRA    8E4A
....................    else if (0 == strcmp(s_all, arg1)) {
08BDC:  MOVFF  729,730
08BE0:  MOVFF  728,72F
08BE4:  MOVFF  6FA,732
08BE8:  MOVFF  6F9,731
08BEC:  CALL   56EE
08BF0:  MOVF   01,F
08BF2:  BTFSS  FD8.2
08BF4:  BRA    8E44
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08BF6:  MOVLW  04
08BF8:  MOVLB  7
08BFA:  MOVWF  x30
08BFC:  MOVLW  BF
08BFE:  MOVWF  x2F
08C00:  MOVLB  0
08C02:  CALL   5638
08C06:  MOVFF  02,03
08C0A:  MOVF   01,W
08C0C:  ADDLW  BF
08C0E:  MOVLB  7
08C10:  MOVWF  x2E
08C12:  MOVLW  04
08C14:  ADDWFC 02,W
08C16:  MOVWF  x2F
08C18:  MOVFF  FE8,563
08C1C:  MOVFF  72E,562
08C20:  MOVLW  89
08C22:  MOVWF  FE9
08C24:  MOVFF  EE,734
08C28:  MOVFF  ED,733
08C2C:  MOVFF  EC,732
08C30:  MOVFF  EB,731
08C34:  MOVLW  02
08C36:  MOVWF  x35
08C38:  MOVLB  0
08C3A:  CALL   656A
08C3E:  MOVLW  2C
08C40:  MOVLB  7
08C42:  MOVWF  x3E
08C44:  MOVLB  0
08C46:  CALL   5670
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08C4A:  MOVLW  04
08C4C:  MOVLB  7
08C4E:  MOVWF  x30
08C50:  MOVLW  BF
08C52:  MOVWF  x2F
08C54:  MOVLB  0
08C56:  CALL   5638
08C5A:  MOVFF  02,03
08C5E:  MOVF   01,W
08C60:  ADDLW  BF
08C62:  MOVLB  7
08C64:  MOVWF  x2E
08C66:  MOVLW  04
08C68:  ADDWFC 02,W
08C6A:  MOVWF  x2F
08C6C:  MOVFF  FE8,563
08C70:  MOVFF  72E,562
08C74:  MOVLW  89
08C76:  MOVWF  FE9
08C78:  MOVFF  F2,734
08C7C:  MOVFF  F1,733
08C80:  MOVFF  F0,732
08C84:  MOVFF  EF,731
08C88:  MOVLW  01
08C8A:  MOVWF  x35
08C8C:  MOVLB  0
08C8E:  CALL   656A
08C92:  MOVLW  2C
08C94:  MOVLB  7
08C96:  MOVWF  x3E
08C98:  MOVLB  0
08C9A:  CALL   5670
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08C9E:  MOVLW  04
08CA0:  MOVLB  7
08CA2:  MOVWF  x30
08CA4:  MOVLW  BF
08CA6:  MOVWF  x2F
08CA8:  MOVLB  0
08CAA:  CALL   5638
08CAE:  MOVFF  02,03
08CB2:  MOVF   01,W
08CB4:  ADDLW  BF
08CB6:  MOVLB  7
08CB8:  MOVWF  x2E
08CBA:  MOVLW  04
08CBC:  ADDWFC 02,W
08CBE:  MOVWF  x2F
08CC0:  MOVFF  FE8,563
08CC4:  MOVFF  72E,562
08CC8:  MOVLW  89
08CCA:  MOVWF  FE9
08CCC:  MOVFF  F6,734
08CD0:  MOVFF  F5,733
08CD4:  MOVFF  F4,732
08CD8:  MOVFF  F3,731
08CDC:  MOVLW  03
08CDE:  MOVWF  x35
08CE0:  MOVLB  0
08CE2:  CALL   656A
08CE6:  MOVLW  2C
08CE8:  MOVLB  7
08CEA:  MOVWF  x3E
08CEC:  MOVLB  0
08CEE:  CALL   5670
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08CF2:  MOVLW  04
08CF4:  MOVLB  7
08CF6:  MOVWF  x30
08CF8:  MOVLW  BF
08CFA:  MOVWF  x2F
08CFC:  MOVLB  0
08CFE:  CALL   5638
08D02:  MOVFF  02,03
08D06:  MOVF   01,W
08D08:  ADDLW  BF
08D0A:  MOVLB  7
08D0C:  MOVWF  x2E
08D0E:  MOVLW  04
08D10:  ADDWFC 02,W
08D12:  MOVWF  x2F
08D14:  MOVFF  FE8,563
08D18:  MOVFF  72E,562
08D1C:  MOVLW  89
08D1E:  MOVWF  FE9
08D20:  MOVFF  FA,734
08D24:  MOVFF  F9,733
08D28:  MOVFF  F8,732
08D2C:  MOVFF  F7,731
08D30:  MOVLW  03
08D32:  MOVWF  x35
08D34:  MOVLB  0
08D36:  CALL   656A
08D3A:  MOVLW  2C
08D3C:  MOVLB  7
08D3E:  MOVWF  x3E
08D40:  MOVLB  0
08D42:  CALL   5670
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08D46:  MOVLW  04
08D48:  MOVLB  7
08D4A:  MOVWF  x30
08D4C:  MOVLW  BF
08D4E:  MOVWF  x2F
08D50:  MOVLB  0
08D52:  CALL   5638
08D56:  MOVFF  02,03
08D5A:  MOVF   01,W
08D5C:  ADDLW  BF
08D5E:  MOVLB  7
08D60:  MOVWF  x2E
08D62:  MOVLW  04
08D64:  ADDWFC 02,W
08D66:  MOVWF  x2F
08D68:  MOVFF  FE8,563
08D6C:  MOVFF  72E,562
08D70:  MOVLW  89
08D72:  MOVWF  FE9
08D74:  MOVFF  FE,734
08D78:  MOVFF  FD,733
08D7C:  MOVFF  FC,732
08D80:  MOVFF  FB,731
08D84:  MOVLW  03
08D86:  MOVWF  x35
08D88:  MOVLB  0
08D8A:  CALL   656A
08D8E:  MOVLW  2C
08D90:  MOVLB  7
08D92:  MOVWF  x3E
08D94:  MOVLB  0
08D96:  CALL   5670
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08D9A:  MOVLW  04
08D9C:  MOVLB  7
08D9E:  MOVWF  x30
08DA0:  MOVLW  BF
08DA2:  MOVWF  x2F
08DA4:  MOVLB  0
08DA6:  CALL   5638
08DAA:  MOVFF  02,03
08DAE:  MOVF   01,W
08DB0:  ADDLW  BF
08DB2:  MOVLB  7
08DB4:  MOVWF  x2E
08DB6:  MOVLW  04
08DB8:  ADDWFC 02,W
08DBA:  MOVWF  x2F
08DBC:  MOVFF  FE8,563
08DC0:  MOVFF  72E,562
08DC4:  MOVLW  89
08DC6:  MOVWF  FE9
08DC8:  MOVFF  102,734
08DCC:  MOVFF  101,733
08DD0:  MOVFF  100,732
08DD4:  MOVFF  FF,731
08DD8:  MOVLW  03
08DDA:  MOVWF  x35
08DDC:  MOVLB  0
08DDE:  CALL   656A
08DE2:  MOVLW  2C
08DE4:  MOVLB  7
08DE6:  MOVWF  x3E
08DE8:  MOVLB  0
08DEA:  CALL   5670
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08DEE:  MOVLW  04
08DF0:  MOVLB  7
08DF2:  MOVWF  x30
08DF4:  MOVLW  BF
08DF6:  MOVWF  x2F
08DF8:  MOVLB  0
08DFA:  CALL   5638
08DFE:  MOVFF  02,03
08E02:  MOVF   01,W
08E04:  ADDLW  BF
08E06:  MOVLB  7
08E08:  MOVWF  x2E
08E0A:  MOVLW  04
08E0C:  ADDWFC 02,W
08E0E:  MOVWF  x2F
08E10:  MOVFF  FE8,563
08E14:  MOVFF  72E,562
08E18:  MOVLW  89
08E1A:  MOVWF  FE9
08E1C:  MOVFF  106,734
08E20:  MOVFF  105,733
08E24:  MOVFF  104,732
08E28:  MOVFF  103,731
08E2C:  MOVLW  03
08E2E:  MOVWF  x35
08E30:  MOVLB  0
08E32:  CALL   656A
08E36:  MOVLW  2C
08E38:  MOVLB  7
08E3A:  MOVWF  x3E
08E3C:  MOVLB  0
08E3E:  CALL   5670
....................    }
08E42:  BRA    8E4A
....................    else return INV_PARAM;
08E44:  MOVLW  02
08E46:  MOVWF  01
08E48:  BRA    8E4E
....................    
....................    return SUCCESS;
08E4A:  MOVLW  00
08E4C:  MOVWF  01
08E4E:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08E50:  MOVLW  50
08E52:  MOVLB  6
08E54:  MOVWF  xFE
08E56:  MOVLW  56
08E58:  MOVWF  xFF
08E5A:  MOVLB  7
08E5C:  CLRF   x00
08E5E:  MOVLW  06
08E60:  MOVLB  6
08E62:  MOVWF  xFD
08E64:  MOVLW  FE
08E66:  MOVWF  xFC
....................    char *s_CV = "CV";
08E68:  MOVLW  43
08E6A:  MOVLB  7
08E6C:  MOVWF  x03
08E6E:  MOVLW  56
08E70:  MOVWF  x04
08E72:  CLRF   x05
08E74:  MOVLW  07
08E76:  MOVWF  x02
08E78:  MOVLW  03
08E7A:  MOVWF  x01
....................    char *s_PVold = "PVold";
08E7C:  MOVLW  50
08E7E:  MOVWF  x08
08E80:  MOVLW  56
08E82:  MOVWF  x09
08E84:  MOVLW  6F
08E86:  MOVWF  x0A
08E88:  MOVLW  6C
08E8A:  MOVWF  x0B
08E8C:  MOVLW  64
08E8E:  MOVWF  x0C
08E90:  CLRF   x0D
08E92:  MOVLW  07
08E94:  MOVWF  x07
08E96:  MOVLW  08
08E98:  MOVWF  x06
....................    char *s_I = "I";
08E9A:  MOVLW  49
08E9C:  MOVWF  x10
08E9E:  CLRF   x11
08EA0:  MOVLW  07
08EA2:  MOVWF  x0F
08EA4:  MOVLW  10
08EA6:  MOVWF  x0E
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08EA8:  CLRF   x30
08EAA:  MOVFF  683,72F
08EAE:  CLRF   x32
08EB0:  MOVLW  B5
08EB2:  MOVWF  x31
08EB4:  MOVLB  0
08EB6:  CALL   0828
08EBA:  MOVFF  02,713
08EBE:  MOVFF  01,712
08EC2:  MOVLW  06
08EC4:  MOVLB  7
08EC6:  ADDWF  x12,F
08EC8:  MOVLW  00
08ECA:  ADDWFC x13,F
08ECC:  MOVLW  32
08ECE:  ADDWF  x12,W
08ED0:  MOVWF  01
08ED2:  MOVLW  00
08ED4:  ADDWFC x13,W
08ED6:  MOVWF  03
08ED8:  MOVF   01,W
08EDA:  ADDLW  E9
08EDC:  MOVWF  01
08EDE:  MOVLW  01
08EE0:  ADDWFC 03,F
08EE2:  MOVFF  01,712
08EE6:  MOVFF  03,713
08EEA:  MOVFF  03,729
08EEE:  MOVFF  01,728
08EF2:  MOVLB  0
08EF4:  CALL   580E
08EF8:  MOVF   01,F
08EFA:  BNZ   8F04
08EFC:  MOVLW  02
08EFE:  MOVWF  01
08F00:  BRA    92AC
08F02:  BRA    8F62
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08F04:  MOVLB  7
08F06:  CLRF   x30
08F08:  MOVFF  683,72F
08F0C:  CLRF   x32
08F0E:  MOVLW  B5
08F10:  MOVWF  x31
08F12:  MOVLB  0
08F14:  CALL   0828
08F18:  MOVFF  02,713
08F1C:  MOVFF  01,712
08F20:  MOVLW  06
08F22:  MOVLB  7
08F24:  ADDWF  x12,F
08F26:  MOVLW  00
08F28:  ADDWFC x13,F
08F2A:  MOVLW  32
08F2C:  ADDWF  x12,W
08F2E:  MOVWF  01
08F30:  MOVLW  00
08F32:  ADDWFC x13,W
08F34:  MOVWF  03
08F36:  MOVF   01,W
08F38:  ADDLW  E9
08F3A:  MOVWF  01
08F3C:  MOVLW  01
08F3E:  ADDWFC 03,F
08F40:  MOVFF  01,712
08F44:  MOVFF  03,713
08F48:  MOVFF  03,729
08F4C:  MOVFF  01,728
08F50:  CLRF   x2B
08F52:  CLRF   x2A
08F54:  MOVLW  0A
08F56:  MOVWF  x2C
08F58:  MOVLB  0
08F5A:  CALL   58FE
08F5E:  MOVFF  01,6F9
....................    
....................    arg2 = SERcmd[rec].p[3];
08F62:  MOVLB  7
08F64:  CLRF   x30
08F66:  MOVFF  683,72F
08F6A:  CLRF   x32
08F6C:  MOVLW  B5
08F6E:  MOVWF  x31
08F70:  MOVLB  0
08F72:  CALL   0828
08F76:  MOVFF  02,713
08F7A:  MOVFF  01,712
08F7E:  MOVLW  06
08F80:  MOVLB  7
08F82:  ADDWF  x12,F
08F84:  MOVLW  00
08F86:  ADDWFC x13,F
08F88:  MOVLW  4B
08F8A:  ADDWF  x12,W
08F8C:  MOVWF  01
08F8E:  MOVLW  00
08F90:  ADDWFC x13,W
08F92:  MOVWF  03
08F94:  MOVF   01,W
08F96:  ADDLW  E9
08F98:  MOVWF  01
08F9A:  MOVLW  01
08F9C:  ADDWFC 03,F
08F9E:  MOVFF  01,6FA
08FA2:  MOVLB  6
08FA4:  MOVFF  03,6FB
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08FA8:  MOVFF  6FD,730
08FAC:  MOVFF  6FC,72F
08FB0:  MOVFF  6FB,732
08FB4:  MOVFF  6FA,731
08FB8:  MOVLB  0
08FBA:  CALL   56EE
08FBE:  MOVF   01,F
08FC0:  BNZ   9068
08FC2:  MOVLW  04
08FC4:  MOVLB  7
08FC6:  MOVWF  x30
08FC8:  MOVLW  BF
08FCA:  MOVWF  x2F
08FCC:  MOVLB  0
08FCE:  CALL   5638
08FD2:  MOVF   01,W
08FD4:  ADDLW  BF
08FD6:  MOVLB  7
08FD8:  MOVWF  x12
08FDA:  MOVLW  04
08FDC:  ADDWFC 02,W
08FDE:  MOVWF  x13
08FE0:  MOVLW  01
08FE2:  MOVLB  6
08FE4:  SUBWF  xF9,W
08FE6:  MULLW  20
08FE8:  MOVF   FF3,W
08FEA:  MOVLB  7
08FEC:  CLRF   x15
08FEE:  MOVWF  x14
08FF0:  MOVLW  10
08FF2:  ADDWF  x14,W
08FF4:  MOVWF  01
08FF6:  MOVLW  00
08FF8:  ADDWFC x15,W
08FFA:  MOVWF  03
08FFC:  MOVF   01,W
08FFE:  ADDLW  20
09000:  MOVWF  FE9
09002:  MOVLW  00
09004:  ADDWFC 03,W
09006:  MOVWF  FEA
09008:  MOVFF  FEF,714
0900C:  MOVFF  FEC,715
09010:  MOVFF  FEC,716
09014:  MOVFF  FEC,717
09018:  MOVFF  713,563
0901C:  MOVFF  712,562
09020:  MOVFF  6F9,729
09024:  MOVLW  18
09026:  MOVWF  x2A
09028:  MOVLB  0
0902A:  CALL   5C52
0902E:  MOVLW  2C
09030:  MOVLB  7
09032:  MOVWF  x3E
09034:  MOVLB  0
09036:  CALL   5670
0903A:  MOVLW  89
0903C:  MOVWF  FE9
0903E:  MOVFF  717,734
09042:  MOVFF  716,733
09046:  MOVFF  715,732
0904A:  MOVFF  714,731
0904E:  MOVLW  02
09050:  MOVLB  7
09052:  MOVWF  x35
09054:  MOVLB  0
09056:  CALL   656A
0905A:  MOVLW  2C
0905C:  MOVLB  7
0905E:  MOVWF  x3E
09060:  MOVLB  0
09062:  CALL   5670
09066:  BRA    92A8
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
09068:  MOVFF  702,730
0906C:  MOVFF  701,72F
09070:  MOVFF  6FB,732
09074:  MOVFF  6FA,731
09078:  CALL   56EE
0907C:  MOVF   01,F
0907E:  BNZ   9126
09080:  MOVLW  04
09082:  MOVLB  7
09084:  MOVWF  x30
09086:  MOVLW  BF
09088:  MOVWF  x2F
0908A:  MOVLB  0
0908C:  CALL   5638
09090:  MOVF   01,W
09092:  ADDLW  BF
09094:  MOVLB  7
09096:  MOVWF  x12
09098:  MOVLW  04
0909A:  ADDWFC 02,W
0909C:  MOVWF  x13
0909E:  MOVLW  01
090A0:  MOVLB  6
090A2:  SUBWF  xF9,W
090A4:  MULLW  20
090A6:  MOVF   FF3,W
090A8:  MOVLB  7
090AA:  CLRF   x15
090AC:  MOVWF  x14
090AE:  MOVLW  18
090B0:  ADDWF  x14,W
090B2:  MOVWF  01
090B4:  MOVLW  00
090B6:  ADDWFC x15,W
090B8:  MOVWF  03
090BA:  MOVF   01,W
090BC:  ADDLW  20
090BE:  MOVWF  FE9
090C0:  MOVLW  00
090C2:  ADDWFC 03,W
090C4:  MOVWF  FEA
090C6:  MOVFF  FEF,714
090CA:  MOVFF  FEC,715
090CE:  MOVFF  FEC,716
090D2:  MOVFF  FEC,717
090D6:  MOVFF  713,563
090DA:  MOVFF  712,562
090DE:  MOVFF  6F9,729
090E2:  MOVLW  18
090E4:  MOVWF  x2A
090E6:  MOVLB  0
090E8:  CALL   5C52
090EC:  MOVLW  2C
090EE:  MOVLB  7
090F0:  MOVWF  x3E
090F2:  MOVLB  0
090F4:  CALL   5670
090F8:  MOVLW  89
090FA:  MOVWF  FE9
090FC:  MOVFF  717,734
09100:  MOVFF  716,733
09104:  MOVFF  715,732
09108:  MOVFF  714,731
0910C:  MOVLW  02
0910E:  MOVLB  7
09110:  MOVWF  x35
09112:  MOVLB  0
09114:  CALL   656A
09118:  MOVLW  2C
0911A:  MOVLB  7
0911C:  MOVWF  x3E
0911E:  MOVLB  0
09120:  CALL   5670
09124:  BRA    92A8
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09126:  MOVFF  707,730
0912A:  MOVFF  706,72F
0912E:  MOVFF  6FB,732
09132:  MOVFF  6FA,731
09136:  CALL   56EE
0913A:  MOVF   01,F
0913C:  BNZ   91E4
0913E:  MOVLW  04
09140:  MOVLB  7
09142:  MOVWF  x30
09144:  MOVLW  BF
09146:  MOVWF  x2F
09148:  MOVLB  0
0914A:  CALL   5638
0914E:  MOVF   01,W
09150:  ADDLW  BF
09152:  MOVLB  7
09154:  MOVWF  x12
09156:  MOVLW  04
09158:  ADDWFC 02,W
0915A:  MOVWF  x13
0915C:  MOVLW  01
0915E:  MOVLB  6
09160:  SUBWF  xF9,W
09162:  MULLW  20
09164:  MOVF   FF3,W
09166:  MOVLB  7
09168:  CLRF   x15
0916A:  MOVWF  x14
0916C:  MOVLW  14
0916E:  ADDWF  x14,W
09170:  MOVWF  01
09172:  MOVLW  00
09174:  ADDWFC x15,W
09176:  MOVWF  03
09178:  MOVF   01,W
0917A:  ADDLW  20
0917C:  MOVWF  FE9
0917E:  MOVLW  00
09180:  ADDWFC 03,W
09182:  MOVWF  FEA
09184:  MOVFF  FEF,714
09188:  MOVFF  FEC,715
0918C:  MOVFF  FEC,716
09190:  MOVFF  FEC,717
09194:  MOVFF  713,563
09198:  MOVFF  712,562
0919C:  MOVFF  6F9,729
091A0:  MOVLW  18
091A2:  MOVWF  x2A
091A4:  MOVLB  0
091A6:  CALL   5C52
091AA:  MOVLW  2C
091AC:  MOVLB  7
091AE:  MOVWF  x3E
091B0:  MOVLB  0
091B2:  CALL   5670
091B6:  MOVLW  89
091B8:  MOVWF  FE9
091BA:  MOVFF  717,734
091BE:  MOVFF  716,733
091C2:  MOVFF  715,732
091C6:  MOVFF  714,731
091CA:  MOVLW  02
091CC:  MOVLB  7
091CE:  MOVWF  x35
091D0:  MOVLB  0
091D2:  CALL   656A
091D6:  MOVLW  2C
091D8:  MOVLB  7
091DA:  MOVWF  x3E
091DC:  MOVLB  0
091DE:  CALL   5670
091E2:  BRA    92A8
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
091E4:  MOVFF  70F,730
091E8:  MOVFF  70E,72F
091EC:  MOVFF  6FB,732
091F0:  MOVFF  6FA,731
091F4:  CALL   56EE
091F8:  MOVF   01,F
091FA:  BNZ   92A2
091FC:  MOVLW  04
091FE:  MOVLB  7
09200:  MOVWF  x30
09202:  MOVLW  BF
09204:  MOVWF  x2F
09206:  MOVLB  0
09208:  CALL   5638
0920C:  MOVF   01,W
0920E:  ADDLW  BF
09210:  MOVLB  7
09212:  MOVWF  x12
09214:  MOVLW  04
09216:  ADDWFC 02,W
09218:  MOVWF  x13
0921A:  MOVLW  01
0921C:  MOVLB  6
0921E:  SUBWF  xF9,W
09220:  MULLW  20
09222:  MOVF   FF3,W
09224:  MOVLB  7
09226:  CLRF   x15
09228:  MOVWF  x14
0922A:  MOVLW  1C
0922C:  ADDWF  x14,W
0922E:  MOVWF  01
09230:  MOVLW  00
09232:  ADDWFC x15,W
09234:  MOVWF  03
09236:  MOVF   01,W
09238:  ADDLW  20
0923A:  MOVWF  FE9
0923C:  MOVLW  00
0923E:  ADDWFC 03,W
09240:  MOVWF  FEA
09242:  MOVFF  FEF,714
09246:  MOVFF  FEC,715
0924A:  MOVFF  FEC,716
0924E:  MOVFF  FEC,717
09252:  MOVFF  713,563
09256:  MOVFF  712,562
0925A:  MOVFF  6F9,729
0925E:  MOVLW  18
09260:  MOVWF  x2A
09262:  MOVLB  0
09264:  CALL   5C52
09268:  MOVLW  2C
0926A:  MOVLB  7
0926C:  MOVWF  x3E
0926E:  MOVLB  0
09270:  CALL   5670
09274:  MOVLW  89
09276:  MOVWF  FE9
09278:  MOVFF  717,734
0927C:  MOVFF  716,733
09280:  MOVFF  715,732
09284:  MOVFF  714,731
09288:  MOVLW  02
0928A:  MOVLB  7
0928C:  MOVWF  x35
0928E:  MOVLB  0
09290:  CALL   656A
09294:  MOVLW  2C
09296:  MOVLB  7
09298:  MOVWF  x3E
0929A:  MOVLB  0
0929C:  CALL   5670
092A0:  BRA    92A8
....................    else return INV_PARAM;
092A2:  MOVLW  02
092A4:  MOVWF  01
092A6:  BRA    92AC
....................    
....................    return SUCCESS;
092A8:  MOVLW  00
092AA:  MOVWF  01
092AC:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
093CC:  MOVLW  72
093CE:  MOVLB  6
093D0:  MOVWF  xFE
093D2:  MOVLW  61
093D4:  MOVWF  xFF
093D6:  MOVLW  77
093D8:  MOVLB  7
093DA:  MOVWF  x00
093DC:  CLRF   x01
093DE:  MOVLW  06
093E0:  MOVLB  6
093E2:  MOVWF  xFD
093E4:  MOVLW  FE
093E6:  MOVWF  xFC
....................    char *s_calibrated = "calib";
093E8:  MOVLW  63
093EA:  MOVLB  7
093EC:  MOVWF  x04
093EE:  MOVLW  61
093F0:  MOVWF  x05
093F2:  MOVLW  6C
093F4:  MOVWF  x06
093F6:  MOVLW  69
093F8:  MOVWF  x07
093FA:  MOVLW  62
093FC:  MOVWF  x08
093FE:  CLRF   x09
09400:  MOVLW  07
09402:  MOVWF  x03
09404:  MOVLW  04
09406:  MOVWF  x02
....................    char *s_p0 = "p0";
09408:  MOVLW  70
0940A:  MOVWF  x0C
0940C:  MOVLW  30
0940E:  MOVWF  x0D
09410:  CLRF   x0E
09412:  MOVLW  07
09414:  MOVWF  x0B
09416:  MOVLW  0C
09418:  MOVWF  x0A
....................    char *s_poles = "poles";
0941A:  MOVLW  70
0941C:  MOVWF  x11
0941E:  MOVLW  6F
09420:  MOVWF  x12
09422:  MOVLW  6C
09424:  MOVWF  x13
09426:  MOVLW  65
09428:  MOVWF  x14
0942A:  MOVLW  73
0942C:  MOVWF  x15
0942E:  CLRF   x16
09430:  MOVLW  07
09432:  MOVWF  x10
09434:  MOVLW  11
09436:  MOVWF  x0F
....................    char *s_real = "real";
09438:  MOVLW  72
0943A:  MOVWF  x19
0943C:  MOVLW  65
0943E:  MOVWF  x1A
09440:  MOVLW  61
09442:  MOVWF  x1B
09444:  MOVLW  6C
09446:  MOVWF  x1C
09448:  CLRF   x1D
0944A:  MOVLW  07
0944C:  MOVWF  x18
0944E:  MOVLW  19
09450:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09452:  CLRF   x30
09454:  MOVFF  683,72F
09458:  CLRF   x32
0945A:  MOVLW  B5
0945C:  MOVWF  x31
0945E:  MOVLB  0
09460:  CALL   0828
09464:  MOVFF  02,71F
09468:  MOVFF  01,71E
0946C:  MOVLW  06
0946E:  MOVLB  7
09470:  ADDWF  x1E,F
09472:  MOVLW  00
09474:  ADDWFC x1F,F
09476:  MOVLW  32
09478:  ADDWF  x1E,W
0947A:  MOVWF  01
0947C:  MOVLW  00
0947E:  ADDWFC x1F,W
09480:  MOVWF  03
09482:  MOVF   01,W
09484:  ADDLW  E9
09486:  MOVWF  01
09488:  MOVLW  01
0948A:  ADDWFC 03,F
0948C:  MOVFF  01,71E
09490:  MOVFF  03,71F
09494:  MOVFF  03,729
09498:  MOVFF  01,728
0949C:  MOVLB  0
0949E:  CALL   580E
094A2:  MOVF   01,F
094A4:  BNZ   94AE
094A6:  MOVLW  02
094A8:  MOVWF  01
094AA:  BRA    9B10
094AC:  BRA    950C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094AE:  MOVLB  7
094B0:  CLRF   x30
094B2:  MOVFF  683,72F
094B6:  CLRF   x32
094B8:  MOVLW  B5
094BA:  MOVWF  x31
094BC:  MOVLB  0
094BE:  CALL   0828
094C2:  MOVFF  02,71F
094C6:  MOVFF  01,71E
094CA:  MOVLW  06
094CC:  MOVLB  7
094CE:  ADDWF  x1E,F
094D0:  MOVLW  00
094D2:  ADDWFC x1F,F
094D4:  MOVLW  32
094D6:  ADDWF  x1E,W
094D8:  MOVWF  01
094DA:  MOVLW  00
094DC:  ADDWFC x1F,W
094DE:  MOVWF  03
094E0:  MOVF   01,W
094E2:  ADDLW  E9
094E4:  MOVWF  01
094E6:  MOVLW  01
094E8:  ADDWFC 03,F
094EA:  MOVFF  01,71E
094EE:  MOVFF  03,71F
094F2:  MOVFF  03,729
094F6:  MOVFF  01,728
094FA:  CLRF   x2B
094FC:  CLRF   x2A
094FE:  MOVLW  0A
09500:  MOVWF  x2C
09502:  MOVLB  0
09504:  CALL   58FE
09508:  MOVFF  01,6F9
....................    
....................    arg2 = SERcmd[rec].p[3];
0950C:  MOVLB  7
0950E:  CLRF   x30
09510:  MOVFF  683,72F
09514:  CLRF   x32
09516:  MOVLW  B5
09518:  MOVWF  x31
0951A:  MOVLB  0
0951C:  CALL   0828
09520:  MOVFF  02,71F
09524:  MOVFF  01,71E
09528:  MOVLW  06
0952A:  MOVLB  7
0952C:  ADDWF  x1E,F
0952E:  MOVLW  00
09530:  ADDWFC x1F,F
09532:  MOVLW  4B
09534:  ADDWF  x1E,W
09536:  MOVWF  01
09538:  MOVLW  00
0953A:  ADDWFC x1F,W
0953C:  MOVWF  03
0953E:  MOVF   01,W
09540:  ADDLW  E9
09542:  MOVWF  01
09544:  MOVLW  01
09546:  ADDWFC 03,F
09548:  MOVFF  01,6FA
0954C:  MOVLB  6
0954E:  MOVFF  03,6FB
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09552:  MOVFF  6FD,730
09556:  MOVFF  6FC,72F
0955A:  MOVFF  6FB,732
0955E:  MOVFF  6FA,731
09562:  MOVLB  0
09564:  CALL   56EE
09568:  MOVF   01,F
0956A:  BTFSS  FD8.2
0956C:  BRA    96F0
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0956E:  MOVLW  04
09570:  MOVLB  7
09572:  MOVWF  x30
09574:  MOVLW  BF
09576:  MOVWF  x2F
09578:  MOVLB  0
0957A:  CALL   5638
0957E:  MOVFF  02,03
09582:  MOVF   01,W
09584:  ADDLW  BF
09586:  MOVLB  7
09588:  MOVWF  x1E
0958A:  MOVLW  04
0958C:  ADDWFC 02,W
0958E:  MOVWF  x1F
09590:  MOVFF  FE8,563
09594:  MOVFF  71E,562
09598:  MOVFF  6F9,729
0959C:  MOVLW  18
0959E:  MOVWF  x2A
095A0:  MOVLB  0
095A2:  CALL   5C52
095A6:  MOVLW  2C
095A8:  MOVLB  7
095AA:  MOVWF  x3E
095AC:  MOVLB  0
095AE:  CALL   5670
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
095B2:  MOVLW  04
095B4:  MOVLB  7
095B6:  MOVWF  x30
095B8:  MOVLW  BF
095BA:  MOVWF  x2F
095BC:  MOVLB  0
095BE:  CALL   5638
095C2:  MOVFF  02,03
095C6:  MOVF   01,W
095C8:  ADDLW  BF
095CA:  MOVLB  7
095CC:  MOVWF  x1E
095CE:  MOVLW  04
095D0:  ADDWFC 02,W
095D2:  MOVWF  x1F
095D4:  MOVLW  01
095D6:  MOVLB  6
095D8:  SUBWF  xF9,W
095DA:  MULLW  2D
095DC:  MOVF   FF3,W
095DE:  MOVLB  7
095E0:  CLRF   x21
095E2:  MOVWF  x20
095E4:  MOVLW  07
095E6:  ADDWF  x20,W
095E8:  MOVWF  FE9
095EA:  MOVLW  01
095EC:  ADDWFC x21,W
095EE:  MOVWF  FEA
095F0:  MOVFF  FEF,73E
095F4:  MOVFF  FEC,01
095F8:  MOVFF  FEC,02
095FC:  MOVFF  FEC,03
09600:  MOVFF  03,741
09604:  MOVFF  02,740
09608:  MOVFF  01,73F
0960C:  MOVLB  0
0960E:  CALL   6494
09612:  MOVFF  03,725
09616:  MOVFF  02,724
0961A:  MOVFF  01,723
0961E:  MOVFF  00,722
09622:  MOVFF  71F,563
09626:  MOVFF  71E,562
0962A:  MOVLW  41
0962C:  MOVWF  FE9
0962E:  MOVFF  03,731
09632:  MOVFF  02,730
09636:  MOVFF  01,72F
0963A:  MOVFF  00,72E
0963E:  RCALL  92AE
09640:  MOVLW  2C
09642:  MOVLB  7
09644:  MOVWF  x3E
09646:  MOVLB  0
09648:  CALL   5670
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0964C:  MOVLW  04
0964E:  MOVLB  7
09650:  MOVWF  x30
09652:  MOVLW  BF
09654:  MOVWF  x2F
09656:  MOVLB  0
09658:  CALL   5638
0965C:  MOVF   01,W
0965E:  ADDLW  BF
09660:  MOVLB  7
09662:  MOVWF  x1E
09664:  MOVLW  04
09666:  ADDWFC 02,W
09668:  MOVWF  x1F
0966A:  MOVLW  01
0966C:  MOVLB  6
0966E:  SUBWF  xF9,W
09670:  MULLW  2D
09672:  MOVF   FF3,W
09674:  MOVLB  7
09676:  CLRF   x21
09678:  MOVWF  x20
0967A:  MOVLW  04
0967C:  ADDWF  x20,W
0967E:  MOVWF  01
09680:  MOVLW  00
09682:  ADDWFC x21,W
09684:  MOVWF  03
09686:  MOVF   01,W
09688:  ADDLW  07
0968A:  MOVWF  FE9
0968C:  MOVLW  01
0968E:  ADDWFC 03,W
09690:  MOVWF  FEA
09692:  MOVFF  FEF,73E
09696:  MOVFF  FEC,01
0969A:  MOVFF  FEC,02
0969E:  MOVFF  FEC,03
096A2:  MOVFF  03,741
096A6:  MOVFF  02,740
096AA:  MOVFF  01,73F
096AE:  MOVLB  0
096B0:  CALL   6494
096B4:  MOVFF  03,723
096B8:  MOVFF  02,722
096BC:  MOVFF  01,721
096C0:  MOVFF  00,720
096C4:  MOVFF  71F,563
096C8:  MOVFF  71E,562
096CC:  MOVLW  41
096CE:  MOVWF  FE9
096D0:  MOVFF  03,731
096D4:  MOVFF  02,730
096D8:  MOVFF  01,72F
096DC:  MOVFF  00,72E
096E0:  RCALL  92AE
096E2:  MOVLW  2C
096E4:  MOVLB  7
096E6:  MOVWF  x3E
096E8:  MOVLB  0
096EA:  CALL   5670
....................    }
096EE:  BRA    9B0C
....................    else if (0 == strcmp(s_calibrated, arg2)) {
096F0:  MOVFF  703,730
096F4:  MOVFF  702,72F
096F8:  MOVFF  6FB,732
096FC:  MOVFF  6FA,731
09700:  CALL   56EE
09704:  MOVF   01,F
09706:  BTFSS  FD8.2
09708:  BRA    9894
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0970A:  MOVLW  04
0970C:  MOVLB  7
0970E:  MOVWF  x30
09710:  MOVLW  BF
09712:  MOVWF  x2F
09714:  MOVLB  0
09716:  CALL   5638
0971A:  MOVFF  02,03
0971E:  MOVF   01,W
09720:  ADDLW  BF
09722:  MOVLB  7
09724:  MOVWF  x1E
09726:  MOVLW  04
09728:  ADDWFC 02,W
0972A:  MOVWF  x1F
0972C:  MOVFF  FE8,563
09730:  MOVFF  71E,562
09734:  MOVFF  6F9,729
09738:  MOVLW  18
0973A:  MOVWF  x2A
0973C:  MOVLB  0
0973E:  CALL   5C52
09742:  MOVLW  2C
09744:  MOVLB  7
09746:  MOVWF  x3E
09748:  MOVLB  0
0974A:  CALL   5670
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0974E:  MOVLW  04
09750:  MOVLB  7
09752:  MOVWF  x30
09754:  MOVLW  BF
09756:  MOVWF  x2F
09758:  MOVLB  0
0975A:  CALL   5638
0975E:  MOVF   01,W
09760:  ADDLW  BF
09762:  MOVLB  7
09764:  MOVWF  x1E
09766:  MOVLW  04
09768:  ADDWFC 02,W
0976A:  MOVWF  x1F
0976C:  MOVLW  01
0976E:  MOVLB  6
09770:  SUBWF  xF9,W
09772:  MULLW  2D
09774:  MOVF   FF3,W
09776:  MOVLB  7
09778:  CLRF   x21
0977A:  MOVWF  x20
0977C:  MOVLW  08
0977E:  ADDWF  x20,W
09780:  MOVWF  01
09782:  MOVLW  00
09784:  ADDWFC x21,W
09786:  MOVWF  03
09788:  MOVF   01,W
0978A:  ADDLW  07
0978C:  MOVWF  FE9
0978E:  MOVLW  01
09790:  ADDWFC 03,W
09792:  MOVWF  FEA
09794:  MOVFF  FEF,73E
09798:  MOVFF  FEC,01
0979C:  MOVFF  FEC,02
097A0:  MOVFF  FEC,03
097A4:  MOVFF  03,741
097A8:  MOVFF  02,740
097AC:  MOVFF  01,73F
097B0:  MOVLB  0
097B2:  CALL   6494
097B6:  MOVFF  03,723
097BA:  MOVFF  02,722
097BE:  MOVFF  01,721
097C2:  MOVFF  00,720
097C6:  MOVFF  71F,563
097CA:  MOVFF  71E,562
097CE:  MOVLW  41
097D0:  MOVWF  FE9
097D2:  MOVFF  03,731
097D6:  MOVFF  02,730
097DA:  MOVFF  01,72F
097DE:  MOVFF  00,72E
097E2:  RCALL  92AE
097E4:  MOVLW  2C
097E6:  MOVLB  7
097E8:  MOVWF  x3E
097EA:  MOVLB  0
097EC:  CALL   5670
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
097F0:  MOVLW  04
097F2:  MOVLB  7
097F4:  MOVWF  x30
097F6:  MOVLW  BF
097F8:  MOVWF  x2F
097FA:  MOVLB  0
097FC:  CALL   5638
09800:  MOVF   01,W
09802:  ADDLW  BF
09804:  MOVLB  7
09806:  MOVWF  x1E
09808:  MOVLW  04
0980A:  ADDWFC 02,W
0980C:  MOVWF  x1F
0980E:  MOVLW  01
09810:  MOVLB  6
09812:  SUBWF  xF9,W
09814:  MULLW  2D
09816:  MOVF   FF3,W
09818:  MOVLB  7
0981A:  CLRF   x21
0981C:  MOVWF  x20
0981E:  MOVLW  0C
09820:  ADDWF  x20,W
09822:  MOVWF  01
09824:  MOVLW  00
09826:  ADDWFC x21,W
09828:  MOVWF  03
0982A:  MOVF   01,W
0982C:  ADDLW  07
0982E:  MOVWF  FE9
09830:  MOVLW  01
09832:  ADDWFC 03,W
09834:  MOVWF  FEA
09836:  MOVFF  FEF,73E
0983A:  MOVFF  FEC,01
0983E:  MOVFF  FEC,02
09842:  MOVFF  FEC,03
09846:  MOVFF  03,741
0984A:  MOVFF  02,740
0984E:  MOVFF  01,73F
09852:  MOVLB  0
09854:  CALL   6494
09858:  MOVFF  03,723
0985C:  MOVFF  02,722
09860:  MOVFF  01,721
09864:  MOVFF  00,720
09868:  MOVFF  71F,563
0986C:  MOVFF  71E,562
09870:  MOVLW  41
09872:  MOVWF  FE9
09874:  MOVFF  03,731
09878:  MOVFF  02,730
0987C:  MOVFF  01,72F
09880:  MOVFF  00,72E
09884:  RCALL  92AE
09886:  MOVLW  2C
09888:  MOVLB  7
0988A:  MOVWF  x3E
0988C:  MOVLB  0
0988E:  CALL   5670
....................    }
09892:  BRA    9B0C
....................    else if (0 == strcmp(s_p0, arg2)) {
09894:  MOVFF  70B,730
09898:  MOVFF  70A,72F
0989C:  MOVFF  6FB,732
098A0:  MOVFF  6FA,731
098A4:  CALL   56EE
098A8:  MOVF   01,F
098AA:  BNZ   996A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098AC:  MOVLW  04
098AE:  MOVLB  7
098B0:  MOVWF  x30
098B2:  MOVLW  BF
098B4:  MOVWF  x2F
098B6:  MOVLB  0
098B8:  CALL   5638
098BC:  MOVFF  02,03
098C0:  MOVF   01,W
098C2:  ADDLW  BF
098C4:  MOVLB  7
098C6:  MOVWF  x1E
098C8:  MOVLW  04
098CA:  ADDWFC 02,W
098CC:  MOVWF  x1F
098CE:  MOVFF  FE8,563
098D2:  MOVFF  71E,562
098D6:  MOVFF  6F9,729
098DA:  MOVLW  18
098DC:  MOVWF  x2A
098DE:  MOVLB  0
098E0:  CALL   5C52
098E4:  MOVLW  2C
098E6:  MOVLB  7
098E8:  MOVWF  x3E
098EA:  MOVLB  0
098EC:  CALL   5670
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
098F0:  MOVLW  04
098F2:  MOVLB  7
098F4:  MOVWF  x30
098F6:  MOVLW  BF
098F8:  MOVWF  x2F
098FA:  MOVLB  0
098FC:  CALL   5638
09900:  MOVF   01,W
09902:  ADDLW  BF
09904:  MOVLB  7
09906:  MOVWF  x1E
09908:  MOVLW  04
0990A:  ADDWFC 02,W
0990C:  MOVWF  x1F
0990E:  MOVLW  01
09910:  MOVLB  6
09912:  SUBWF  xF9,W
09914:  MULLW  2D
09916:  MOVF   FF3,W
09918:  MOVLB  7
0991A:  CLRF   x21
0991C:  MOVWF  x20
0991E:  MOVLW  18
09920:  ADDWF  x20,W
09922:  MOVWF  01
09924:  MOVLW  00
09926:  ADDWFC x21,W
09928:  MOVWF  03
0992A:  MOVF   01,W
0992C:  ADDLW  07
0992E:  MOVWF  FE9
09930:  MOVLW  01
09932:  ADDWFC 03,W
09934:  MOVWF  FEA
09936:  MOVFF  FEF,731
0993A:  MOVFF  FEC,732
0993E:  MOVFF  FEC,733
09942:  MOVFF  FEC,734
09946:  MOVFF  71F,563
0994A:  MOVFF  71E,562
0994E:  MOVLW  89
09950:  MOVWF  FE9
09952:  MOVLW  02
09954:  MOVWF  x35
09956:  MOVLB  0
09958:  CALL   656A
0995C:  MOVLW  2C
0995E:  MOVLB  7
09960:  MOVWF  x3E
09962:  MOVLB  0
09964:  CALL   5670
....................    }
09968:  BRA    9B0C
....................    else if (0 == strcmp(s_poles, arg2)) {
0996A:  MOVFF  710,730
0996E:  MOVFF  70F,72F
09972:  MOVFF  6FB,732
09976:  MOVFF  6FA,731
0997A:  CALL   56EE
0997E:  MOVF   01,F
09980:  BNZ   9A30
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09982:  MOVLW  04
09984:  MOVLB  7
09986:  MOVWF  x30
09988:  MOVLW  BF
0998A:  MOVWF  x2F
0998C:  MOVLB  0
0998E:  CALL   5638
09992:  MOVFF  02,03
09996:  MOVF   01,W
09998:  ADDLW  BF
0999A:  MOVLB  7
0999C:  MOVWF  x1E
0999E:  MOVLW  04
099A0:  ADDWFC 02,W
099A2:  MOVWF  x1F
099A4:  MOVFF  FE8,563
099A8:  MOVFF  71E,562
099AC:  MOVFF  6F9,729
099B0:  MOVLW  18
099B2:  MOVWF  x2A
099B4:  MOVLB  0
099B6:  CALL   5C52
099BA:  MOVLW  2C
099BC:  MOVLB  7
099BE:  MOVWF  x3E
099C0:  MOVLB  0
099C2:  CALL   5670
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
099C6:  MOVLW  04
099C8:  MOVLB  7
099CA:  MOVWF  x30
099CC:  MOVLW  BF
099CE:  MOVWF  x2F
099D0:  MOVLB  0
099D2:  CALL   5638
099D6:  MOVF   01,W
099D8:  ADDLW  BF
099DA:  MOVLB  7
099DC:  MOVWF  x1E
099DE:  MOVLW  04
099E0:  ADDWFC 02,W
099E2:  MOVWF  x1F
099E4:  MOVLW  01
099E6:  MOVLB  6
099E8:  SUBWF  xF9,W
099EA:  MULLW  2D
099EC:  MOVF   FF3,W
099EE:  MOVLB  7
099F0:  CLRF   x21
099F2:  MOVWF  x20
099F4:  MOVLW  1C
099F6:  ADDWF  x20,W
099F8:  MOVWF  01
099FA:  MOVLW  00
099FC:  ADDWFC x21,W
099FE:  MOVWF  03
09A00:  MOVF   01,W
09A02:  ADDLW  07
09A04:  MOVWF  FE9
09A06:  MOVLW  01
09A08:  ADDWFC 03,W
09A0A:  MOVWF  FEA
09A0C:  MOVFF  FEF,729
09A10:  MOVFF  71F,563
09A14:  MOVFF  71E,562
09A18:  MOVLW  18
09A1A:  MOVWF  x2A
09A1C:  MOVLB  0
09A1E:  CALL   5C52
09A22:  MOVLW  2C
09A24:  MOVLB  7
09A26:  MOVWF  x3E
09A28:  MOVLB  0
09A2A:  CALL   5670
....................    }
09A2E:  BRA    9B0C
....................    else if (0 == strcmp(s_real, arg2)) {
09A30:  MOVFF  718,730
09A34:  MOVFF  717,72F
09A38:  MOVFF  6FB,732
09A3C:  MOVFF  6FA,731
09A40:  CALL   56EE
09A44:  MOVF   01,F
09A46:  BNZ   9B06
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A48:  MOVLW  04
09A4A:  MOVLB  7
09A4C:  MOVWF  x30
09A4E:  MOVLW  BF
09A50:  MOVWF  x2F
09A52:  MOVLB  0
09A54:  CALL   5638
09A58:  MOVFF  02,03
09A5C:  MOVF   01,W
09A5E:  ADDLW  BF
09A60:  MOVLB  7
09A62:  MOVWF  x1E
09A64:  MOVLW  04
09A66:  ADDWFC 02,W
09A68:  MOVWF  x1F
09A6A:  MOVFF  FE8,563
09A6E:  MOVFF  71E,562
09A72:  MOVFF  6F9,729
09A76:  MOVLW  18
09A78:  MOVWF  x2A
09A7A:  MOVLB  0
09A7C:  CALL   5C52
09A80:  MOVLW  2C
09A82:  MOVLB  7
09A84:  MOVWF  x3E
09A86:  MOVLB  0
09A88:  CALL   5670
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09A8C:  MOVLW  04
09A8E:  MOVLB  7
09A90:  MOVWF  x30
09A92:  MOVLW  BF
09A94:  MOVWF  x2F
09A96:  MOVLB  0
09A98:  CALL   5638
09A9C:  MOVF   01,W
09A9E:  ADDLW  BF
09AA0:  MOVLB  7
09AA2:  MOVWF  x1E
09AA4:  MOVLW  04
09AA6:  ADDWFC 02,W
09AA8:  MOVWF  x1F
09AAA:  MOVLW  01
09AAC:  MOVLB  6
09AAE:  SUBWF  xF9,W
09AB0:  MULLW  2D
09AB2:  MOVF   FF3,W
09AB4:  MOVLB  7
09AB6:  CLRF   x21
09AB8:  MOVWF  x20
09ABA:  MOVLW  1D
09ABC:  ADDWF  x20,W
09ABE:  MOVWF  01
09AC0:  MOVLW  00
09AC2:  ADDWFC x21,W
09AC4:  MOVWF  03
09AC6:  MOVF   01,W
09AC8:  ADDLW  07
09ACA:  MOVWF  FE9
09ACC:  MOVLW  01
09ACE:  ADDWFC 03,W
09AD0:  MOVWF  FEA
09AD2:  MOVFF  FEF,731
09AD6:  MOVFF  FEC,732
09ADA:  MOVFF  FEC,733
09ADE:  MOVFF  FEC,734
09AE2:  MOVFF  71F,563
09AE6:  MOVFF  71E,562
09AEA:  MOVLW  89
09AEC:  MOVWF  FE9
09AEE:  MOVLW  02
09AF0:  MOVWF  x35
09AF2:  MOVLB  0
09AF4:  CALL   656A
09AF8:  MOVLW  2C
09AFA:  MOVLB  7
09AFC:  MOVWF  x3E
09AFE:  MOVLB  0
09B00:  CALL   5670
....................    }
09B04:  BRA    9B0C
....................    else return INV_PARAM;
09B06:  MOVLW  02
09B08:  MOVWF  01
09B0A:  BRA    9B10
....................    
....................    return SUCCESS;
09B0C:  MOVLW  00
09B0E:  MOVWF  01
09B10:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09B12:  MOVLB  7
09B14:  CLRF   x30
09B16:  MOVFF  683,72F
09B1A:  CLRF   x32
09B1C:  MOVLW  B5
09B1E:  MOVWF  x31
09B20:  MOVLB  0
09B22:  CALL   0828
09B26:  MOVFF  02,6FB
09B2A:  MOVFF  01,6FA
09B2E:  MOVLW  06
09B30:  MOVLB  6
09B32:  ADDWF  xFA,F
09B34:  MOVLW  00
09B36:  ADDWFC xFB,F
09B38:  MOVLW  32
09B3A:  ADDWF  xFA,W
09B3C:  MOVWF  01
09B3E:  MOVLW  00
09B40:  ADDWFC xFB,W
09B42:  MOVWF  03
09B44:  MOVF   01,W
09B46:  ADDLW  E9
09B48:  MOVWF  01
09B4A:  MOVLW  01
09B4C:  ADDWFC 03,F
09B4E:  MOVFF  01,6FA
09B52:  MOVFF  03,6FB
09B56:  MOVFF  03,729
09B5A:  MOVFF  01,728
09B5E:  MOVLB  0
09B60:  CALL   580E
09B64:  MOVF   01,F
09B66:  BNZ   9B70
09B68:  MOVLW  02
09B6A:  MOVWF  01
09B6C:  BRA    9C66
09B6E:  BRA    9BD0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B70:  MOVLB  7
09B72:  CLRF   x30
09B74:  MOVFF  683,72F
09B78:  CLRF   x32
09B7A:  MOVLW  B5
09B7C:  MOVWF  x31
09B7E:  MOVLB  0
09B80:  CALL   0828
09B84:  MOVFF  02,6FB
09B88:  MOVFF  01,6FA
09B8C:  MOVLW  06
09B8E:  MOVLB  6
09B90:  ADDWF  xFA,F
09B92:  MOVLW  00
09B94:  ADDWFC xFB,F
09B96:  MOVLW  32
09B98:  ADDWF  xFA,W
09B9A:  MOVWF  01
09B9C:  MOVLW  00
09B9E:  ADDWFC xFB,W
09BA0:  MOVWF  03
09BA2:  MOVF   01,W
09BA4:  ADDLW  E9
09BA6:  MOVWF  01
09BA8:  MOVLW  01
09BAA:  ADDWFC 03,F
09BAC:  MOVFF  01,6FA
09BB0:  MOVFF  03,6FB
09BB4:  MOVFF  03,729
09BB8:  MOVFF  01,728
09BBC:  MOVLB  7
09BBE:  CLRF   x2B
09BC0:  CLRF   x2A
09BC2:  MOVLW  0A
09BC4:  MOVWF  x2C
09BC6:  MOVLB  0
09BC8:  CALL   58FE
09BCC:  MOVFF  01,6F9
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
09BD0:  MOVLW  04
09BD2:  MOVLB  7
09BD4:  MOVWF  x30
09BD6:  MOVLW  BF
09BD8:  MOVWF  x2F
09BDA:  MOVLB  0
09BDC:  CALL   5638
09BE0:  MOVF   01,W
09BE2:  ADDLW  BF
09BE4:  MOVLB  6
09BE6:  MOVWF  xFA
09BE8:  MOVLW  04
09BEA:  ADDWFC 02,W
09BEC:  MOVWF  xFB
09BEE:  MOVLW  01
09BF0:  SUBWF  xF9,W
09BF2:  MULLW  04
09BF4:  MOVF   FF3,W
09BF6:  CLRF   03
09BF8:  ADDLW  68
09BFA:  MOVWF  FE9
09BFC:  MOVLW  01
09BFE:  ADDWFC 03,W
09C00:  MOVWF  FEA
09C02:  MOVFF  FEF,6FC
09C06:  MOVFF  FEC,6FD
09C0A:  MOVFF  FEC,6FE
09C0E:  MOVFF  FEC,6FF
09C12:  MOVFF  6FB,563
09C16:  MOVFF  6FA,562
09C1A:  MOVFF  6F9,729
09C1E:  MOVLW  18
09C20:  MOVLB  7
09C22:  MOVWF  x2A
09C24:  MOVLB  0
09C26:  CALL   5C52
09C2A:  MOVLW  2C
09C2C:  MOVLB  7
09C2E:  MOVWF  x3E
09C30:  MOVLB  0
09C32:  CALL   5670
09C36:  MOVLW  89
09C38:  MOVWF  FE9
09C3A:  MOVFF  6FF,734
09C3E:  MOVFF  6FE,733
09C42:  MOVFF  6FD,732
09C46:  MOVFF  6FC,731
09C4A:  MOVLW  02
09C4C:  MOVLB  7
09C4E:  MOVWF  x35
09C50:  MOVLB  0
09C52:  CALL   656A
09C56:  MOVLW  2C
09C58:  MOVLB  7
09C5A:  MOVWF  x3E
09C5C:  MOVLB  0
09C5E:  CALL   5670
....................    
....................    return SUCCESS;
09C62:  MOVLW  00
09C64:  MOVWF  01
09C66:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C68:  MOVLB  7
09C6A:  CLRF   x30
09C6C:  MOVFF  683,72F
09C70:  CLRF   x32
09C72:  MOVLW  B5
09C74:  MOVWF  x31
09C76:  MOVLB  0
09C78:  CALL   0828
09C7C:  MOVFF  02,6FF
09C80:  MOVFF  01,6FE
09C84:  MOVLW  06
09C86:  MOVLB  6
09C88:  ADDWF  xFE,F
09C8A:  MOVLW  00
09C8C:  ADDWFC xFF,F
09C8E:  MOVLW  32
09C90:  ADDWF  xFE,W
09C92:  MOVWF  01
09C94:  MOVLW  00
09C96:  ADDWFC xFF,W
09C98:  MOVWF  03
09C9A:  MOVF   01,W
09C9C:  ADDLW  E9
09C9E:  MOVWF  01
09CA0:  MOVLW  01
09CA2:  ADDWFC 03,F
09CA4:  MOVFF  01,6FE
09CA8:  MOVFF  03,6FF
09CAC:  MOVFF  03,729
09CB0:  MOVFF  01,728
09CB4:  MOVLB  0
09CB6:  CALL   580E
09CBA:  MOVF   01,F
09CBC:  BNZ   9CC6
09CBE:  MOVLW  02
09CC0:  MOVWF  01
09CC2:  BRA    9EAC
09CC4:  BRA    9D26
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CC6:  MOVLB  7
09CC8:  CLRF   x30
09CCA:  MOVFF  683,72F
09CCE:  CLRF   x32
09CD0:  MOVLW  B5
09CD2:  MOVWF  x31
09CD4:  MOVLB  0
09CD6:  CALL   0828
09CDA:  MOVFF  02,6FF
09CDE:  MOVFF  01,6FE
09CE2:  MOVLW  06
09CE4:  MOVLB  6
09CE6:  ADDWF  xFE,F
09CE8:  MOVLW  00
09CEA:  ADDWFC xFF,F
09CEC:  MOVLW  32
09CEE:  ADDWF  xFE,W
09CF0:  MOVWF  01
09CF2:  MOVLW  00
09CF4:  ADDWFC xFF,W
09CF6:  MOVWF  03
09CF8:  MOVF   01,W
09CFA:  ADDLW  E9
09CFC:  MOVWF  01
09CFE:  MOVLW  01
09D00:  ADDWFC 03,F
09D02:  MOVFF  01,6FE
09D06:  MOVFF  03,6FF
09D0A:  MOVFF  03,729
09D0E:  MOVFF  01,728
09D12:  MOVLB  7
09D14:  CLRF   x2B
09D16:  CLRF   x2A
09D18:  MOVLW  0A
09D1A:  MOVWF  x2C
09D1C:  MOVLB  0
09D1E:  CALL   58FE
09D22:  MOVFF  01,6F9
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09D26:  MOVLB  7
09D28:  CLRF   x30
09D2A:  MOVFF  683,72F
09D2E:  CLRF   x32
09D30:  MOVLW  B5
09D32:  MOVWF  x31
09D34:  MOVLB  0
09D36:  CALL   0828
09D3A:  MOVFF  02,6FF
09D3E:  MOVFF  01,6FE
09D42:  MOVLW  06
09D44:  MOVLB  6
09D46:  ADDWF  xFE,F
09D48:  MOVLW  00
09D4A:  ADDWFC xFF,F
09D4C:  MOVLW  4B
09D4E:  ADDWF  xFE,W
09D50:  MOVWF  01
09D52:  MOVLW  00
09D54:  ADDWFC xFF,W
09D56:  MOVWF  03
09D58:  MOVF   01,W
09D5A:  ADDLW  E9
09D5C:  MOVWF  01
09D5E:  MOVLW  01
09D60:  ADDWFC 03,F
09D62:  MOVFF  01,6FE
09D66:  MOVFF  03,6FF
09D6A:  MOVFF  03,703
09D6E:  MOVFF  01,702
09D72:  MOVLB  0
09D74:  CALL   6BF0
09D78:  MOVF   01,F
09D7A:  BNZ   9D84
09D7C:  MOVLW  02
09D7E:  MOVWF  01
09D80:  BRA    9EAC
09D82:  BRA    9DEC
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09D84:  MOVLB  7
09D86:  CLRF   x30
09D88:  MOVFF  683,72F
09D8C:  CLRF   x32
09D8E:  MOVLW  B5
09D90:  MOVWF  x31
09D92:  MOVLB  0
09D94:  CALL   0828
09D98:  MOVFF  02,6FF
09D9C:  MOVFF  01,6FE
09DA0:  MOVLW  06
09DA2:  MOVLB  6
09DA4:  ADDWF  xFE,F
09DA6:  MOVLW  00
09DA8:  ADDWFC xFF,F
09DAA:  MOVLW  4B
09DAC:  ADDWF  xFE,W
09DAE:  MOVWF  01
09DB0:  MOVLW  00
09DB2:  ADDWFC xFF,W
09DB4:  MOVWF  03
09DB6:  MOVF   01,W
09DB8:  ADDLW  E9
09DBA:  MOVWF  01
09DBC:  MOVLW  01
09DBE:  ADDWFC 03,F
09DC0:  MOVFF  01,6FE
09DC4:  MOVFF  03,6FF
09DC8:  MOVFF  03,703
09DCC:  MOVFF  01,702
09DD0:  MOVLB  7
09DD2:  CLRF   x05
09DD4:  CLRF   x04
09DD6:  MOVLB  0
09DD8:  CALL   6CB2
09DDC:  MOVFF  03,6FD
09DE0:  MOVFF  02,6FC
09DE4:  MOVFF  01,6FB
09DE8:  MOVFF  00,6FA
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09DEC:  MOVLB  7
09DEE:  CLRF   x46
09DF0:  CLRF   x45
09DF2:  MOVLW  7C
09DF4:  MOVWF  x44
09DF6:  MOVLW  84
09DF8:  MOVWF  x43
09DFA:  MOVFF  6FD,74A
09DFE:  MOVFF  6FC,749
09E02:  MOVFF  6FB,748
09E06:  MOVFF  6FA,747
09E0A:  MOVLB  0
09E0C:  CALL   1CD0
09E10:  BNC   9E36
09E12:  MOVLW  01
09E14:  MOVLB  6
09E16:  SUBWF  xF9,W
09E18:  MULLW  04
09E1A:  MOVF   FF3,W
09E1C:  CLRF   03
09E1E:  ADDLW  68
09E20:  MOVWF  FE9
09E22:  MOVLW  01
09E24:  ADDWFC 03,W
09E26:  MOVWF  FEA
09E28:  MOVLW  84
09E2A:  MOVWF  FEF
09E2C:  MOVLW  7C
09E2E:  MOVWF  FEC
09E30:  CLRF   FEC
09E32:  CLRF   FEC
09E34:  BRA    9EA6
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
09E36:  MOVFF  6FD,746
09E3A:  MOVFF  6FC,745
09E3E:  MOVFF  6FB,744
09E42:  MOVFF  6FA,743
09E46:  MOVLB  7
09E48:  CLRF   x4A
09E4A:  CLRF   x49
09E4C:  MOVLW  C0
09E4E:  MOVWF  x48
09E50:  MOVLW  82
09E52:  MOVWF  x47
09E54:  MOVLB  0
09E56:  CALL   1CD0
09E5A:  BNC   9E80
09E5C:  MOVLW  01
09E5E:  MOVLB  6
09E60:  SUBWF  xF9,W
09E62:  MULLW  04
09E64:  MOVF   FF3,W
09E66:  CLRF   03
09E68:  ADDLW  68
09E6A:  MOVWF  FE9
09E6C:  MOVLW  01
09E6E:  ADDWFC 03,W
09E70:  MOVWF  FEA
09E72:  MOVLW  82
09E74:  MOVWF  FEF
09E76:  MOVLW  C0
09E78:  MOVWF  FEC
09E7A:  CLRF   FEC
09E7C:  CLRF   FEC
09E7E:  BRA    9EA6
....................    else manualOutputValues[arg1-1] = arg2;
09E80:  MOVLW  01
09E82:  MOVLB  6
09E84:  SUBWF  xF9,W
09E86:  MULLW  04
09E88:  MOVF   FF3,W
09E8A:  CLRF   03
09E8C:  ADDLW  68
09E8E:  MOVWF  FE9
09E90:  MOVLW  01
09E92:  ADDWFC 03,W
09E94:  MOVWF  FEA
09E96:  MOVFF  6FA,FEF
09E9A:  MOVFF  6FB,FEC
09E9E:  MOVFF  6FC,FEC
09EA2:  MOVFF  6FD,FEC
....................    
....................    return SUCCESS;
09EA6:  MOVLW  00
09EA8:  MOVWF  01
09EAA:  MOVLB  0
09EAC:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09EAE:  MOVLB  1
09EB0:  BSF    x61.0
....................    return SUCCESS;
09EB2:  MOVLW  00
09EB4:  MOVWF  01
09EB6:  MOVLB  0
09EB8:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09EBA:  MOVLB  1
09EBC:  BCF    x61.0
....................    return SUCCESS;
09EBE:  MOVLW  00
09EC0:  MOVWF  01
09EC2:  MOVLB  0
09EC4:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09EC6:  MOVLW  01
09EC8:  MOVWF  01
09ECA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06BF0:  MOVLB  7
06BF2:  BCF    x04.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06BF4:  CLRF   x05
06BF6:  MOVFF  703,730
06BFA:  MOVFF  702,72F
06BFE:  MOVLB  0
06C00:  CALL   5638
06C04:  MOVFF  02,03
06C08:  MOVF   01,W
06C0A:  MOVF   03,F
06C0C:  BNZ   6C18
06C0E:  MOVF   01,W
06C10:  MOVLB  7
06C12:  SUBWF  x05,W
06C14:  BC    6CAA
06C16:  MOVLB  0
....................       if (!isdigit(arg[i])){
06C18:  MOVLB  7
06C1A:  MOVF   x05,W
06C1C:  ADDWF  x02,W
06C1E:  MOVWF  FE9
06C20:  MOVLW  00
06C22:  ADDWFC x03,W
06C24:  MOVWF  FEA
06C26:  MOVFF  FEF,706
06C2A:  MOVF   x06,W
06C2C:  SUBLW  2F
06C2E:  BC    6C36
06C30:  MOVF   x06,W
06C32:  SUBLW  39
06C34:  BC    6CA2
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06C36:  MOVF   x05,W
06C38:  ADDWF  x02,W
06C3A:  MOVWF  FE9
06C3C:  MOVLW  00
06C3E:  ADDWFC x03,W
06C40:  MOVWF  FEA
06C42:  MOVF   FEF,W
06C44:  SUBLW  2D
06C46:  BZ    6C72
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06C48:  MOVF   x05,W
06C4A:  ADDWF  x02,W
06C4C:  MOVWF  FE9
06C4E:  MOVLW  00
06C50:  ADDWFC x03,W
06C52:  MOVWF  FEA
06C54:  MOVF   FEF,W
06C56:  SUBLW  2E
06C58:  BZ    6C62
06C5A:  MOVLW  00
06C5C:  MOVWF  01
06C5E:  BRA    6CAE
06C60:  BRA    6C70
....................             else if  (decimal) return FALSE;
06C62:  BTFSS  x04.0
06C64:  BRA    6C6E
06C66:  MOVLW  00
06C68:  MOVWF  01
06C6A:  BRA    6CAE
06C6C:  BRA    6C70
....................             else decimal = TRUE;
06C6E:  BSF    x04.0
....................          }
06C70:  BRA    6CA2
....................          else if (0 != i) return FALSE;
06C72:  MOVF   x05,F
06C74:  BZ    6C7E
06C76:  MOVLW  00
06C78:  MOVWF  01
06C7A:  BRA    6CAE
06C7C:  BRA    6CA2
....................          else if (1 == strlen(arg)) return FALSE;
06C7E:  MOVFF  703,730
06C82:  MOVFF  702,72F
06C86:  MOVLB  0
06C88:  CALL   5638
06C8C:  MOVFF  02,03
06C90:  MOVF   01,W
06C92:  SUBLW  01
06C94:  BNZ   6CA4
06C96:  MOVF   03,F
06C98:  BNZ   6CA4
06C9A:  MOVLW  00
06C9C:  MOVWF  01
06C9E:  MOVLB  7
06CA0:  BRA    6CAE
06CA2:  MOVLB  0
....................       }
06CA4:  MOVLB  7
06CA6:  INCF   x05,F
06CA8:  BRA    6BF6
....................    }
....................    return TRUE;
06CAA:  MOVLW  01
06CAC:  MOVWF  01
06CAE:  MOVLB  0
06CB0:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
0580E:  MOVFF  729,730
05812:  MOVFF  728,72F
05816:  RCALL  5638
05818:  MOVFF  02,03
0581C:  MOVF   01,W
0581E:  SUBLW  01
05820:  BNZ   5826
05822:  MOVF   03,F
05824:  BZ    582E
05826:  MOVLW  00
05828:  MOVWF  01
0582A:  BRA    585C
0582C:  BRA    5854
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
0582E:  MOVLB  7
05830:  MOVFF  728,FE9
05834:  MOVFF  729,FEA
05838:  MOVF   FEF,W
0583A:  SUBLW  31
0583C:  BZ    5856
0583E:  MOVFF  728,FE9
05842:  MOVFF  729,FEA
05846:  MOVF   FEF,W
05848:  SUBLW  32
0584A:  BZ    5856
0584C:  MOVLW  00
0584E:  MOVWF  01
05850:  MOVLB  0
05852:  BRA    585C
05854:  MOVLB  7
....................     return TRUE;
05856:  MOVLW  01
05858:  MOVWF  01
0585A:  MOVLB  0
0585C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
056B4:  MOVLB  6
056B6:  MOVF   xF8,W
056B8:  SUBLW  2F
056BA:  BC    56CC
056BC:  MOVF   xF8,W
056BE:  SUBLW  39
056C0:  BNC   56CC
056C2:  MOVLW  30
056C4:  SUBWF  xF8,W
056C6:  MOVWF  01
056C8:  BRA    56E8
056CA:  BRA    56E8
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
056CC:  MOVF   xF8,W
056CE:  SUBLW  40
056D0:  BC    56E4
056D2:  MOVF   xF8,W
056D4:  SUBLW  46
056D6:  BNC   56E4
056D8:  MOVLW  41
056DA:  SUBWF  xF8,W
056DC:  ADDLW  0A
056DE:  MOVWF  01
056E0:  BRA    56E8
056E2:  BRA    56E8
....................    else return 0xFF;
056E4:  MOVLW  FF
056E6:  MOVWF  01
056E8:  MOVLB  0
056EA:  GOTO   9F72 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09ECC:  MOVLB  7
09ECE:  CLRF   x30
09ED0:  MOVFF  6EF,72F
09ED4:  CLRF   x32
09ED6:  MOVLW  B5
09ED8:  MOVWF  x31
09EDA:  MOVLB  0
09EDC:  CALL   0828
09EE0:  MOVFF  02,6F8
09EE4:  MOVFF  01,6F7
09EE8:  MOVLW  06
09EEA:  MOVLB  6
09EEC:  ADDWF  xF7,F
09EEE:  MOVLW  00
09EF0:  ADDWFC xF8,F
09EF2:  MOVLW  E9
09EF4:  ADDWF  xF7,W
09EF6:  MOVWF  01
09EF8:  MOVLW  01
09EFA:  ADDWFC xF8,W
09EFC:  MOVWF  03
09EFE:  MOVFF  01,6F0
09F02:  MOVWF  xF1
09F04:  MOVLB  7
09F06:  CLRF   x30
09F08:  MOVFF  6EF,72F
09F0C:  CLRF   x32
09F0E:  MOVLW  B5
09F10:  MOVWF  x31
09F12:  MOVLB  0
09F14:  CALL   0828
09F18:  MOVFF  02,6FA
09F1C:  MOVFF  01,6F9
09F20:  MOVLW  06
09F22:  MOVLB  6
09F24:  ADDWF  xF9,F
09F26:  MOVLW  00
09F28:  ADDWFC xFA,F
09F2A:  MOVLW  19
09F2C:  ADDWF  xF9,W
09F2E:  MOVWF  01
09F30:  MOVLW  00
09F32:  ADDWFC xFA,W
09F34:  MOVWF  03
09F36:  MOVF   01,W
09F38:  ADDLW  E9
09F3A:  MOVWF  01
09F3C:  MOVLW  01
09F3E:  ADDWFC 03,F
09F40:  MOVFF  01,6F2
09F44:  MOVFF  03,6F3
09F48:  CLRF   xF4
09F4A:  CLRF   xF5
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
09F4C:  MOVFF  6F0,FE9
09F50:  MOVFF  6F1,FEA
09F54:  MOVF   FEF,W
09F56:  SUBLW  44
09F58:  BTFSS  FD8.2
09F5A:  BRA    A04A
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
09F5C:  MOVLW  01
09F5E:  ADDWF  xF0,W
09F60:  MOVWF  FE9
09F62:  MOVLW  00
09F64:  ADDWFC xF1,W
09F66:  MOVWF  FEA
09F68:  MOVFF  FEF,6F8
09F6C:  MOVLB  0
09F6E:  GOTO   56B4
09F72:  MOVFF  01,6F7
09F76:  MOVLB  6
09F78:  MOVF   xF4,W
09F7A:  ANDLW  0F
09F7C:  SUBWF  01,W
09F7E:  BNZ   A042
....................          while (0 != strlen(cmd_list[i].cmd_name)){
09F80:  MOVF   xF5,W
09F82:  MULLW  04
09F84:  MOVF   FF3,W
09F86:  CLRF   xF8
09F88:  MOVWF  xF7
09F8A:  MOVLW  68
09F8C:  ADDWF  xF7,W
09F8E:  MOVWF  FE9
09F90:  MOVLW  05
09F92:  ADDWFC xF8,W
09F94:  MOVWF  FEA
09F96:  MOVFF  FEC,730
09F9A:  MOVF   FED,F
09F9C:  MOVFF  FEF,72F
09FA0:  MOVLB  0
09FA2:  CALL   5638
09FA6:  MOVFF  02,03
09FAA:  MOVF   01,W
09FAC:  BNZ   9FB2
09FAE:  MOVF   03,F
09FB0:  BZ    A038
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
09FB2:  MOVLB  6
09FB4:  MOVF   xF5,W
09FB6:  MULLW  04
09FB8:  MOVF   FF3,W
09FBA:  CLRF   xF8
09FBC:  MOVWF  xF7
09FBE:  MOVLW  68
09FC0:  ADDWF  xF7,W
09FC2:  MOVWF  FE9
09FC4:  MOVLW  05
09FC6:  ADDWFC xF8,W
09FC8:  MOVWF  FEA
09FCA:  MOVFF  FEC,732
09FCE:  MOVF   FED,F
09FD0:  MOVFF  FEF,731
09FD4:  MOVFF  6F3,730
09FD8:  MOVFF  6F2,72F
09FDC:  MOVLB  0
09FDE:  CALL   56EE
09FE2:  MOVF   01,F
09FE4:  BNZ   A030
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
09FE6:  MOVLB  6
09FE8:  MOVF   xF5,W
09FEA:  MULLW  04
09FEC:  MOVF   FF3,W
09FEE:  CLRF   xF8
09FF0:  MOVWF  xF7
09FF2:  MOVLW  02
09FF4:  ADDWF  xF7,W
09FF6:  MOVWF  01
09FF8:  MOVLW  00
09FFA:  ADDWFC xF8,W
09FFC:  MOVWF  03
09FFE:  MOVF   01,W
0A000:  ADDLW  68
0A002:  MOVWF  01
0A004:  MOVLW  05
0A006:  ADDWFC 03,F
0A008:  MOVFF  01,6F7
0A00C:  MOVFF  03,6F8
0A010:  MOVFF  03,FEA
0A014:  MOVFF  01,FE9
0A018:  MOVFF  6EF,683
0A01C:  MOVLB  0
0A01E:  CALL   00BC
0A022:  MOVFF  01,6F6
....................                return return_code;
0A026:  MOVLB  6
0A028:  MOVFF  6F6,01
0A02C:  BRA    A04E
0A02E:  MOVLB  0
....................             }
....................             i++;
0A030:  MOVLB  6
0A032:  INCF   xF5,F
0A034:  BRA    9F80
0A036:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A038:  MOVLW  01
0A03A:  MOVWF  01
0A03C:  MOVLB  6
0A03E:  BRA    A04E
....................       } else return 254; // NOT THIS ADDRESS
0A040:  BRA    A048
0A042:  MOVLW  FE
0A044:  MOVWF  01
0A046:  BRA    A04E
....................    } else return 255; // NOT THIS DEVICE TYPE
0A048:  BRA    A04E
0A04A:  MOVLW  FF
0A04C:  MOVWF  01
0A04E:  MOVLB  0
0A050:  GOTO   A140 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A0A0:  GOTO   55DE
0A0A4:  MOVF   01,F
0A0A6:  BTFSC  FD8.2
0A0A8:  BRA    A1C6
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A0AA:  MOVLW  04
0A0AC:  MOVLB  7
0A0AE:  MOVWF  x30
0A0B0:  MOVLW  BF
0A0B2:  MOVWF  x2F
0A0B4:  MOVLB  0
0A0B6:  CALL   5638
0A0BA:  MOVFF  02,03
0A0BE:  MOVF   01,W
0A0C0:  ADDLW  BF
0A0C2:  MOVLB  6
0A0C4:  MOVWF  xEF
0A0C6:  MOVLW  04
0A0C8:  ADDWFC 02,W
0A0CA:  MOVWF  xF0
0A0CC:  MOVLB  7
0A0CE:  CLRF   x30
0A0D0:  MOVFF  4BD,72F
0A0D4:  CLRF   x32
0A0D6:  MOVLW  B5
0A0D8:  MOVWF  x31
0A0DA:  MOVLB  0
0A0DC:  CALL   0828
0A0E0:  MOVFF  02,6F2
0A0E4:  MOVFF  01,6F1
0A0E8:  MOVLW  06
0A0EA:  MOVLB  6
0A0EC:  ADDWF  xF1,F
0A0EE:  MOVLW  00
0A0F0:  ADDWFC xF2,F
0A0F2:  MOVLW  E9
0A0F4:  ADDWF  xF1,W
0A0F6:  MOVWF  01
0A0F8:  MOVLW  01
0A0FA:  ADDWFC xF2,W
0A0FC:  MOVWF  03
0A0FE:  MOVFF  01,6F3
0A102:  MOVWF  xF4
0A104:  MOVFF  6F0,563
0A108:  MOVFF  6EF,562
0A10C:  MOVLW  24
0A10E:  MOVLB  7
0A110:  MOVWF  x3E
0A112:  MOVLB  0
0A114:  CALL   5670
0A118:  MOVFF  563,FEA
0A11C:  MOVFF  562,FE9
0A120:  CLRF   FEF
0A122:  MOVFF  6F4,FEA
0A126:  MOVFF  6F3,FE9
0A12A:  CALL   5690
0A12E:  MOVLW  2C
0A130:  MOVLB  7
0A132:  MOVWF  x3E
0A134:  MOVLB  0
0A136:  CALL   5670
....................       
....................       return_code = command_parser(SRI);
0A13A:  MOVFF  4BD,6EF
0A13E:  BRA    9ECC
0A140:  MOVFF  01,6EE
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A144:  MOVLW  04
0A146:  MOVLB  7
0A148:  MOVWF  x30
0A14A:  MOVLW  BF
0A14C:  MOVWF  x2F
0A14E:  MOVLB  0
0A150:  CALL   5638
0A154:  MOVF   01,W
0A156:  ADDLW  BF
0A158:  MOVLB  6
0A15A:  MOVWF  xEF
0A15C:  MOVLW  04
0A15E:  ADDWFC 02,W
0A160:  MOVWF  xF0
0A162:  MOVF   xEE,W
0A164:  MULLW  03
0A166:  MOVF   FF3,W
0A168:  CLRF   xF2
0A16A:  MOVWF  xF1
0A16C:  MOVLW  01
0A16E:  ADDWF  xF1,W
0A170:  MOVWF  01
0A172:  MOVLW  00
0A174:  ADDWFC xF2,W
0A176:  MOVWF  03
0A178:  MOVF   01,W
0A17A:  ADDLW  50
0A17C:  MOVWF  FE9
0A17E:  MOVLW  06
0A180:  ADDWFC 03,W
0A182:  MOVWF  FEA
0A184:  MOVFF  FEC,6F2
0A188:  MOVF   FED,F
0A18A:  MOVFF  FEF,6F1
0A18E:  MOVFF  6F0,563
0A192:  MOVFF  6EF,562
0A196:  MOVFF  563,FEA
0A19A:  MOVFF  562,FE9
0A19E:  CLRF   FEF
0A1A0:  MOVFF  6F2,FEA
0A1A4:  MOVFF  6F1,FE9
0A1A8:  MOVLB  0
0A1AA:  CALL   5690
....................       serial_out(retData);
0A1AE:  MOVLW  04
0A1B0:  MOVLB  6
0A1B2:  MOVWF  xF0
0A1B4:  MOVLW  BF
0A1B6:  MOVWF  xEF
0A1B8:  MOVLB  0
0A1BA:  BRA    A054
....................       resetSERcmd(SRI);
0A1BC:  MOVFF  4BD,6EF
0A1C0:  CALL   0B0A
0A1C4:  BRA    A0A0
....................    }
0A1C6:  GOTO   A5F2 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... //!#define DEBUG_1
.................... 
.................... void main()
0A1CA:  CLRF   FF8
0A1CC:  BCF    FF2.5
0A1CE:  BSF    07.7
0A1D0:  MOVLB  E
0A1D2:  MOVLW  55
0A1D4:  MOVWF  x9B
0A1D6:  MOVLW  AA
0A1D8:  MOVWF  x9B
0A1DA:  BCF    x9B.0
0A1DC:  MOVLW  17
0A1DE:  MOVWF  xB0
0A1E0:  MOVLW  13
0A1E2:  MOVWF  xB2
0A1E4:  MOVLW  09
0A1E6:  MOVWF  x8A
0A1E8:  MOVLW  0A
0A1EA:  MOVWF  x8B
0A1EC:  MOVLW  11
0A1EE:  MOVWF  xEB
0A1F0:  MOVLW  12
0A1F2:  MOVWF  xED
0A1F4:  MOVLW  10
0A1F6:  MOVWF  xF4
0A1F8:  MOVLW  0F
0A1FA:  MOVWF  xF5
0A1FC:  MOVLW  09
0A1FE:  MOVWF  xF8
0A200:  MOVLW  55
0A202:  MOVWF  x9B
0A204:  MOVLW  AA
0A206:  MOVWF  x9B
0A208:  BSF    x9B.0
0A20A:  CLRF   xD8
0A20C:  CLRF   xD5
0A20E:  CLRF   xD7
0A210:  MOVLW  08
0A212:  MOVWF  xD9
0A214:  MOVLW  60
0A216:  MOVWF  xD3
0A218:  MOVLW  AA
0A21A:  MOVLB  0
0A21C:  MOVWF  xEA
0A21E:  MOVLB  1
0A220:  BCF    x61.0
0A222:  CLRF   x73
0A224:  CLRF   x72
0A226:  CLRF   x71
0A228:  CLRF   x70
0A22A:  CLRF   x77
0A22C:  CLRF   x76
0A22E:  CLRF   x75
0A230:  CLRF   x74
0A232:  CLRF   x7B
0A234:  CLRF   x7A
0A236:  CLRF   x79
0A238:  CLRF   x78
0A23A:  CLRF   x7D
0A23C:  CLRF   x7C
0A23E:  MOVLB  E
0A240:  BCF    x91.5
0A242:  MOVLW  00
0A244:  MOVWF  x90
0A246:  MOVLW  03
0A248:  MOVWF  x8E
0A24A:  MOVLW  2A
0A24C:  MOVWF  x91
0A24E:  MOVLW  C4
0A250:  MOVWF  F88
0A252:  MOVWF  F88
0A254:  MOVWF  F88
0A256:  MOVLB  1
0A258:  CLRF   xCE
0A25A:  CLRF   xCF
0A25C:  CLRF   xD0
0A25E:  CLRF   xD1
0A260:  BCF    F95.5
0A262:  MOVLW  40
0A264:  MOVWF  F94
0A266:  MOVLW  9F
0A268:  MOVWF  F92
0A26A:  MOVLW  3A
0A26C:  MOVWF  F95
0A26E:  MOVLW  93
0A270:  MOVWF  F89
0A272:  MOVWF  F89
0A274:  MOVLB  4
0A276:  CLRF   xBD
0A278:  CLRF   xBE
0A27A:  MOVLB  5
0A27C:  CLRF   x5F
0A27E:  CLRF   x60
0A280:  MOVLB  1
0A282:  BCF    x61.1
0A284:  MOVLB  5
0A286:  CLRF   x61
0A288:  BSF    F9E.3
0A28A:  MOVLW  7C
0A28C:  MOVWF  F9A
0A28E:  MOVLW  00
0A290:  MOVWF  F9B
0A292:  MOVLW  A6
0A294:  MOVWF  F9D
0A296:  MOVLW  90
0A298:  MOVWF  F9C
0A29A:  CLRF   x63
0A29C:  CLRF   x62
0A29E:  CLRF   x67
0A2A0:  CLRF   x66
0A2A2:  CLRF   x65
0A2A4:  CLRF   x64
0A2A6:  MOVLB  F
0A2A8:  CLRF   x0C
0A2AA:  CLRF   x14
0A2AC:  CLRF   x1C
0A2AE:  CLRF   x21
0A2B0:  CLRF   x29
0A2B2:  CLRF   x35
0A2B4:  CLRF   x36
0A2B6:  CLRF   x37
0A2B8:  CLRF   x34
0A2BA:  CLRF   x31
0A2BC:  CLRF   x32
0A2BE:  CLRF   x33
0A2C0:  CLRF   x30
0A2C2:  MOVLW  57
0A2C4:  MOVLB  5
0A2C6:  MOVWF  x6B
0A2C8:  MOVLW  86
0A2CA:  MOVWF  x6A
0A2CC:  MOVLW  57
0A2CE:  MOVWF  x6F
0A2D0:  MOVLW  CA
0A2D2:  MOVWF  x6E
0A2D4:  MOVLW  5D
0A2D6:  MOVWF  x73
0A2D8:  MOVLW  12
0A2DA:  MOVWF  x72
0A2DC:  MOVLW  5E
0A2DE:  MOVWF  x77
0A2E0:  MOVLW  FE
0A2E2:  MOVWF  x76
0A2E4:  MOVLW  60
0A2E6:  MOVWF  x7B
0A2E8:  MOVLW  E0
0A2EA:  MOVWF  x7A
0A2EC:  MOVLW  62
0A2EE:  MOVWF  x7F
0A2F0:  MOVLW  72
0A2F2:  MOVWF  x7E
0A2F4:  MOVLW  67
0A2F6:  MOVWF  x83
0A2F8:  MOVLW  1A
0A2FA:  MOVWF  x82
0A2FC:  MOVLW  6F
0A2FE:  MOVWF  x87
0A300:  MOVLW  0C
0A302:  MOVWF  x86
0A304:  MOVLW  72
0A306:  MOVWF  x8B
0A308:  MOVLW  30
0A30A:  MOVWF  x8A
0A30C:  MOVLW  73
0A30E:  MOVWF  x8F
0A310:  MOVLW  96
0A312:  MOVWF  x8E
0A314:  MOVLW  75
0A316:  MOVWF  x93
0A318:  MOVLW  58
0A31A:  MOVWF  x92
0A31C:  MOVLW  79
0A31E:  MOVWF  x97
0A320:  MOVLW  26
0A322:  MOVWF  x96
0A324:  MOVLW  7E
0A326:  MOVWF  x9B
0A328:  MOVLW  A6
0A32A:  MOVWF  x9A
0A32C:  MOVLW  82
0A32E:  MOVWF  x9F
0A330:  MOVLW  9A
0A332:  MOVWF  x9E
0A334:  MOVLW  87
0A336:  MOVWF  xA3
0A338:  MOVLW  CE
0A33A:  MOVWF  xA2
0A33C:  MOVLW  87
0A33E:  MOVWF  xA7
0A340:  MOVLW  D4
0A342:  MOVWF  xA6
0A344:  MOVLW  8E
0A346:  MOVWF  xAB
0A348:  MOVLW  50
0A34A:  MOVWF  xAA
0A34C:  MOVLW  93
0A34E:  MOVWF  xAF
0A350:  MOVLW  CC
0A352:  MOVWF  xAE
0A354:  MOVLW  9B
0A356:  MOVWF  xB3
0A358:  MOVLW  12
0A35A:  MOVWF  xB2
0A35C:  MOVLW  9C
0A35E:  MOVWF  xB7
0A360:  MOVLW  68
0A362:  MOVWF  xB6
0A364:  MOVLW  9E
0A366:  MOVWF  xBB
0A368:  MOVLW  AE
0A36A:  MOVWF  xBA
0A36C:  MOVLW  9E
0A36E:  MOVWF  xBF
0A370:  MOVLW  BA
0A372:  MOVWF  xBE
0A374:  MOVLW  9E
0A376:  MOVWF  xC3
0A378:  MOVLW  C6
0A37A:  MOVWF  xC2
0A37C:  BRA    A550
0A37E:  DATA 02,00
0A380:  DATA 1A,00
0A382:  DATA 00,0C
0A384:  DATA 00,20
0A386:  DATA 78,23
0A388:  DATA D7,0A
0A38A:  DATA 7D,19
0A38C:  DATA 99,9A
0A38E:  DATA 7B,4C
0A390:  DATA CC,CD
0A392:  DATA 14,C0
0A394:  DATA 00,0C
0A396:  DATA 80,78
0A398:  DATA 23,D7
0A39A:  DATA 0A,7D
0A39C:  DATA 19,99
0A39E:  DATA 9A,7B
0A3A0:  DATA 4C,CC
0A3A2:  DATA CD,14
0A3A4:  DATA C0,00
0A3A6:  DATA 01,80
0A3A8:  DATA 02,09
0A3AA:  DATA C0,00
0A3AC:  DATA 05,80
0A3AE:  DATA 7F,00
0A3B0:  DATA 00,00
0A3B2:  DATA 7F,0B
0A3B4:  DATA C0,00
0A3B6:  DATA 05,80
0A3B8:  DATA 7F,00
0A3BA:  DATA 00,00
0A3BC:  DATA 7F,07
0A3BE:  DATA C0,00
0A3C0:  DATA 01,80
0A3C2:  DATA 7F,17
0A3C4:  DATA C0,00
0A3C6:  DATA 01,80
0A3C8:  DATA 7F,17
0A3CA:  DATA C0,00
0A3CC:  DATA 04,80
0A3CE:  DATA 79,B7
0A3D0:  DATA F3,BD
0A3D2:  DATA 04,C0
0A3D4:  DATA 00,04
0A3D6:  DATA 80,7C
0A3D8:  DATA 59,DF
0A3DA:  DATA 4E,04
0A3DC:  DATA C0,00
0A3DE:  DATA 04,80
0A3E0:  DATA 78,0A
0A3E2:  DATA 28,88
0A3E4:  DATA 04,C0
0A3E6:  DATA 00,04
0A3E8:  DATA 80,78
0A3EA:  DATA 05,EA
0A3EC:  DATA 16,04
0A3EE:  DATA C0,00
0A3F0:  DATA 04,80
0A3F2:  DATA 78,1E
0A3F4:  DATA 33,D7
0A3F6:  DATA 04,C0
0A3F8:  DATA 00,04
0A3FA:  DATA 80,77
0A3FC:  DATA 68,7B
0A3FE:  DATA BB,04
0A400:  DATA C0,00
0A402:  DATA 04,80
0A404:  DATA 77,68
0A406:  DATA 0D,C6
0A408:  DATA 76,40
0A40A:  DATA EB,00
0A40C:  DATA 0E,41
0A40E:  DATA 62,00
0A410:  DATA 17,41
0A412:  DATA D2,00
0A414:  DATA 3C,45
0A416:  DATA 23,00
0A418:  DATA 02,05
0A41A:  DATA 68,C4
0A41C:  DATA 05,02
0A41E:  DATA 05,6C
0A420:  DATA C7,05
0A422:  DATA 02,05
0A424:  DATA 70,CA
0A426:  DATA 05,02
0A428:  DATA 05,74
0A42A:  DATA D1,05
0A42C:  DATA 02,05
0A42E:  DATA 78,D8
0A430:  DATA 05,02
0A432:  DATA 05,7C
0A434:  DATA E0,05
0A436:  DATA 02,05
0A438:  DATA 80,E8
0A43A:  DATA 05,02
0A43C:  DATA 05,84
0A43E:  DATA ED,05
0A440:  DATA 02,05
0A442:  DATA 88,F2
0A444:  DATA 05,02
0A446:  DATA 05,8C
0A448:  DATA F6,05
0A44A:  DATA 02,05
0A44C:  DATA 90,FA
0A44E:  DATA 05,02
0A450:  DATA 05,94
0A452:  DATA 01,06
0A454:  DATA 02,05
0A456:  DATA 98,07
0A458:  DATA 06,02
0A45A:  DATA 05,9C
0A45C:  DATA 0D,06
0A45E:  DATA 02,05
0A460:  DATA A0,13
0A462:  DATA 06,02
0A464:  DATA 05,A4
0A466:  DATA 19,06
0A468:  DATA 02,05
0A46A:  DATA A8,1E
0A46C:  DATA 06,02
0A46E:  DATA 05,AC
0A470:  DATA 27,06
0A472:  DATA 02,05
0A474:  DATA B0,2F
0A476:  DATA 06,02
0A478:  DATA 05,B4
0A47A:  DATA 36,06
0A47C:  DATA 02,05
0A47E:  DATA B8,3D
0A480:  DATA 06,02
0A482:  DATA 05,BC
0A484:  DATA 45,06
0A486:  DATA 02,05
0A488:  DATA C0,4E
0A48A:  DATA 06,89
0A48C:  DATA 05,C4
0A48E:  DATA 67,72
0A490:  DATA 00,67
0A492:  DATA 73,00
0A494:  DATA 67,43
0A496:  DATA 68,4D
0A498:  DATA 61,70
0A49A:  DATA 00,73
0A49C:  DATA 43,68
0A49E:  DATA 4D,61
0A4A0:  DATA 70,00
0A4A2:  DATA 67,43
0A4A4:  DATA 68,4D
0A4A6:  DATA 6F,64
0A4A8:  DATA 65,00
0A4AA:  DATA 73,43
0A4AC:  DATA 68,4D
0A4AE:  DATA 6F,64
0A4B0:  DATA 65,00
0A4B2:  DATA 67,50
0A4B4:  DATA 49,44
0A4B6:  DATA 00,73
0A4B8:  DATA 50,49
0A4BA:  DATA 44,00
0A4BC:  DATA 67,53
0A4BE:  DATA 50,00
0A4C0:  DATA 73,53
0A4C2:  DATA 50,00
0A4C4:  DATA 67,53
0A4C6:  DATA 43,61
0A4C8:  DATA 6C,73
0A4CA:  DATA 00,67
0A4CC:  DATA 53,43
0A4CE:  DATA 61,6C
0A4D0:  DATA 00,73
0A4D2:  DATA 53,43
0A4D4:  DATA 61,6C
0A4D6:  DATA 00,67
0A4D8:  DATA 4D,43
0A4DA:  DATA 61,6C
0A4DC:  DATA 00,73
0A4DE:  DATA 4D,43
0A4E0:  DATA 61,6C
0A4E2:  DATA 00,67
0A4E4:  DATA 4D,6F
0A4E6:  DATA 6E,00
0A4E8:  DATA 67,50
0A4EA:  DATA 49,44
0A4EC:  DATA 64,61
0A4EE:  DATA 74,61
0A4F0:  DATA 00,67
0A4F2:  DATA 49,50
0A4F4:  DATA 64,61
0A4F6:  DATA 74,61
0A4F8:  DATA 00,67
0A4FA:  DATA 4D,61
0A4FC:  DATA 6E,4F
0A4FE:  DATA 50,00
0A500:  DATA 73,4D
0A502:  DATA 61,6E
0A504:  DATA 4F,50
0A506:  DATA 00,73
0A508:  DATA 46,69
0A50A:  DATA 6C,74
0A50C:  DATA 4F,6E
0A50E:  DATA 00,73
0A510:  DATA 46,69
0A512:  DATA 6C,74
0A514:  DATA 4F,66
0A516:  DATA 66,04
0A518:  DATA C0,00
0A51A:  DATA 32,80
0A51C:  DATA 59,06
0A51E:  DATA 01,61
0A520:  DATA 06,02
0A522:  DATA 71,06
0A524:  DATA 53,55
0A526:  DATA 43,43
0A528:  DATA 45,53
0A52A:  DATA 53,00
0A52C:  DATA 49,4E
0A52E:  DATA 56,41
0A530:  DATA 4C,49
0A532:  DATA 44,20
0A534:  DATA 43,4F
0A536:  DATA 4D,4D
0A538:  DATA 41,4E
0A53A:  DATA 44,00
0A53C:  DATA 49,4E
0A53E:  DATA 56,41
0A540:  DATA 4C,49
0A542:  DATA 44,20
0A544:  DATA 50,41
0A546:  DATA 52,41
0A548:  DATA 4D,45
0A54A:  DATA 54,45
0A54C:  DATA 52,00
0A54E:  DATA 00,00
0A550:  MOVLW  00
0A552:  MOVWF  FF8
0A554:  MOVLW  A3
0A556:  MOVWF  FF7
0A558:  MOVLW  7E
0A55A:  MOVWF  FF6
0A55C:  TBLRD*+
0A55E:  MOVF   FF5,W
0A560:  MOVWF  00
0A562:  XORLW  00
0A564:  BZ    A58C
0A566:  TBLRD*+
0A568:  MOVF   FF5,W
0A56A:  MOVWF  01
0A56C:  BTFSC  FE8.7
0A56E:  BRA    A57A
0A570:  ANDLW  3F
0A572:  MOVWF  FEA
0A574:  TBLRD*+
0A576:  MOVFF  FF5,FE9
0A57A:  BTFSC  01.6
0A57C:  TBLRD*+
0A57E:  BTFSS  01.6
0A580:  TBLRD*+
0A582:  MOVFF  FF5,FEE
0A586:  DCFSNZ 00,F
0A588:  BRA    A55C
0A58A:  BRA    A57E
0A58C:  CLRF   FF8
0A58E:  MOVLB  6
0A590:  CLRF   x85
0A592:  MOVLW  64
0A594:  MOVWF  x84
0A596:  CLRF   x87
0A598:  CLRF   x86
0A59A:  CLRF   x89
0A59C:  CLRF   x88
.................... {
....................    int16 loopDelay = 100;
....................    int16 controlCounter = 0;
....................    int16 debugCounter = 0;
....................    
....................    char pBuff[100];
....................    
....................    IO_init();                    // set up IO 
0A59E:  MOVLB  0
0A5A0:  GOTO   0358
....................    params_init();                // load parameters
0A5A4:  GOTO   0600
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0A5A8:  GOTO   0A4E
....................    control_init();               // initialize the output control DACs
0A5AC:  GOTO   0AE6
....................    serial_init();                // setup the serial port
0A5B0:  GOTO   0C94
....................    event_timer_init();
0A5B4:  GOTO   0CB6
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0A5B8:  MOVLW  C0
0A5BA:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
....................       pBuff[0] = '\0';
0A5BC:  MOVLB  6
0A5BE:  CLRF   x8A
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A5C0:  MOVLB  0
0A5C2:  GOTO   108E
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A5C6:  GOTO   4470
....................       
....................       if (controlCounter >= 2){
0A5CA:  MOVLB  6
0A5CC:  MOVF   x87,F
0A5CE:  BNZ   A5D6
0A5D0:  MOVF   x86,W
0A5D2:  SUBLW  01
0A5D4:  BC    A5E4
....................          control_task();
0A5D6:  MOVLB  0
0A5D8:  GOTO   501C
....................          controlCounter = 0;
0A5DC:  MOVLB  6
0A5DE:  CLRF   x87
0A5E0:  CLRF   x86
....................       }else controlCounter++;
0A5E2:  BRA    A5EA
0A5E4:  INCF   x86,F
0A5E6:  BTFSC  FD8.2
0A5E8:  INCF   x87,F
....................       
....................       serial_task();             //serial port
0A5EA:  MOVLB  0
0A5EC:  GOTO   50C6
.................... 
....................       #ifdef DEBUG_1
....................       if (debugCounter >= 0){
....................          static int8 ch = 0;
....................          sprintf(pBuff+strlen(pBuff), "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
....................          sprintf(pBuff+strlen(pBuff), "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
....................          if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
....................          else                    sprintf(pBuff+strlen(pBuff), "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
....................          ch = !ch;
....................          debugCounter = 0;
....................       } else debugCounter++;
....................       serial_out(pBuff);
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0A5F0:  BRA    A0A0
....................       
....................       delay_ms(loopDelay);
0A5F2:  MOVFF  685,6EE
0A5F6:  MOVLB  6
0A5F8:  INCF   xEE,F
0A5FA:  DECF   xEE,F
0A5FC:  BTFSC  FD8.2
0A5FE:  BRA    A60C
0A600:  SETF   xF4
0A602:  MOVLB  0
0A604:  CALL   03EE
0A608:  MOVLB  6
0A60A:  BRA    A5FA
0A60C:  MOVFF  684,6F4
0A610:  MOVLB  0
0A612:  CALL   03EE
0A616:  BRA    A5BC
....................    }
.................... }
0A618:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
