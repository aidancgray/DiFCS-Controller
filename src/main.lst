CCS PCH C Compiler, Version 5.117, 2138               19-Dec-25 17:16

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43436 bytes (66%)
                           Largest free fragment is 22098
               RAM used:   1796 (50%) at main() level
                           1910 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A53A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,32
00336:  DATA 30,38
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
00358:  DATA 43,4E
0035A:  DATA 54,2C
0035C:  DATA 25,75
0035E:  DATA 2C,25
00360:  DATA 2E,30
00362:  DATA 66,2C
00364:  DATA 25,2E
00366:  DATA 30,66
00368:  DATA 3B,00
0036A:  DATA 50,4F
0036C:  DATA 53,2C
0036E:  DATA 25,75
00370:  DATA 2C,25
00372:  DATA 33,2E
00374:  DATA 33,66
00376:  DATA 3B,00
00378:  DATA 4F,55
0037A:  DATA 54,2C
0037C:  DATA 25,75
0037E:  DATA 2C,2D
00380:  DATA 2C,25
00382:  DATA 4C,75
00384:  DATA 3B,00
00386:  DATA 4F,55
00388:  DATA 54,2C
0038A:  DATA 25,75
0038C:  DATA 2C,2B
0038E:  DATA 2C,25
00390:  DATA 4C,75
00392:  DATA 3B,00
*
006BA:  ADDWF  FE8,W
006BC:  CLRF   FF7
006BE:  RLCF   FF7,F
006C0:  ADDLW  D5
006C2:  MOVWF  FF6
006C4:  MOVLW  06
006C6:  ADDWFC FF7,F
006C8:  TBLRD*-
006CA:  MOVF   FF5,W
006CC:  MOVWF  FFA
006CE:  TBLRD*
006D0:  MOVF   FF5,W
006D2:  MOVWF  FF9
006D4:  DATA 84,06
006D6:  DATA 8E,06
006D8:  DATA 98,06
006DA:  DATA A2,06
*
00864:  MOVLB  7
00866:  MOVF   x44,W
00868:  MULWF  x46
0086A:  MOVFF  FF3,01
0086E:  MOVFF  FF4,00
00872:  MULWF  x47
00874:  MOVF   FF3,W
00876:  ADDWF  00,F
00878:  MOVF   x45,W
0087A:  MULWF  x46
0087C:  MOVF   FF3,W
0087E:  ADDWFC 00,W
00880:  MOVWF  02
00882:  MOVLB  0
00884:  RETURN 0
00886:  MOVLB  7
00888:  MOVF   x42,W
0088A:  CLRF   01
0088C:  SUBWF  x41,W
0088E:  BC    0896
00890:  MOVFF  741,00
00894:  BRA    08AE
00896:  CLRF   00
00898:  MOVLW  08
0089A:  MOVWF  x43
0089C:  RLCF   x41,F
0089E:  RLCF   00,F
008A0:  MOVF   x42,W
008A2:  SUBWF  00,W
008A4:  BTFSC  FD8.0
008A6:  MOVWF  00
008A8:  RLCF   01,F
008AA:  DECFSZ x43,F
008AC:  BRA    089C
008AE:  MOVLB  0
008B0:  RETURN 0
*
00D16:  MOVLW  8E
00D18:  MOVWF  00
00D1A:  MOVFF  753,01
00D1E:  MOVFF  752,02
00D22:  CLRF   03
00D24:  MOVF   01,F
00D26:  BNZ   0D3A
00D28:  MOVFF  02,01
00D2C:  CLRF   02
00D2E:  MOVLW  08
00D30:  SUBWF  00,F
00D32:  MOVF   01,F
00D34:  BNZ   0D3A
00D36:  CLRF   00
00D38:  BRA    0D4A
00D3A:  BCF    FD8.0
00D3C:  BTFSC  01.7
00D3E:  BRA    0D48
00D40:  RLCF   02,F
00D42:  RLCF   01,F
00D44:  DECF   00,F
00D46:  BRA    0D3A
00D48:  BCF    01.7
00D4A:  RETURN 0
00D4C:  MOVLB  7
00D4E:  MOVF   x53,W
00D50:  BTFSC  FD8.2
00D52:  BRA    0E36
00D54:  MOVWF  00
00D56:  MOVF   x57,W
00D58:  BTFSC  FD8.2
00D5A:  BRA    0E36
00D5C:  ADDWF  00,F
00D5E:  BNC   0D68
00D60:  MOVLW  81
00D62:  ADDWF  00,F
00D64:  BC    0E36
00D66:  BRA    0D70
00D68:  MOVLW  7F
00D6A:  SUBWF  00,F
00D6C:  BNC   0E36
00D6E:  BZ    0E36
00D70:  MOVFF  754,75B
00D74:  MOVF   x58,W
00D76:  XORWF  x5B,F
00D78:  BSF    x54.7
00D7A:  BSF    x58.7
00D7C:  MOVF   x56,W
00D7E:  MULWF  x5A
00D80:  MOVFF  FF4,75D
00D84:  MOVF   x55,W
00D86:  MULWF  x59
00D88:  MOVFF  FF4,03
00D8C:  MOVFF  FF3,75C
00D90:  MULWF  x5A
00D92:  MOVF   FF3,W
00D94:  ADDWF  x5D,F
00D96:  MOVF   FF4,W
00D98:  ADDWFC x5C,F
00D9A:  MOVLW  00
00D9C:  ADDWFC 03,F
00D9E:  MOVF   x56,W
00DA0:  MULWF  x59
00DA2:  MOVF   FF3,W
00DA4:  ADDWF  x5D,F
00DA6:  MOVF   FF4,W
00DA8:  ADDWFC x5C,F
00DAA:  MOVLW  00
00DAC:  CLRF   02
00DAE:  ADDWFC 03,F
00DB0:  ADDWFC 02,F
00DB2:  MOVF   x54,W
00DB4:  MULWF  x5A
00DB6:  MOVF   FF3,W
00DB8:  ADDWF  x5C,F
00DBA:  MOVF   FF4,W
00DBC:  ADDWFC 03,F
00DBE:  MOVLW  00
00DC0:  ADDWFC 02,F
00DC2:  MOVF   x54,W
00DC4:  MULWF  x59
00DC6:  MOVF   FF3,W
00DC8:  ADDWF  03,F
00DCA:  MOVF   FF4,W
00DCC:  ADDWFC 02,F
00DCE:  MOVLW  00
00DD0:  CLRF   01
00DD2:  ADDWFC 01,F
00DD4:  MOVF   x56,W
00DD6:  MULWF  x58
00DD8:  MOVF   FF3,W
00DDA:  ADDWF  x5C,F
00DDC:  MOVF   FF4,W
00DDE:  ADDWFC 03,F
00DE0:  MOVLW  00
00DE2:  ADDWFC 02,F
00DE4:  ADDWFC 01,F
00DE6:  MOVF   x55,W
00DE8:  MULWF  x58
00DEA:  MOVF   FF3,W
00DEC:  ADDWF  03,F
00DEE:  MOVF   FF4,W
00DF0:  ADDWFC 02,F
00DF2:  MOVLW  00
00DF4:  ADDWFC 01,F
00DF6:  MOVF   x54,W
00DF8:  MULWF  x58
00DFA:  MOVF   FF3,W
00DFC:  ADDWF  02,F
00DFE:  MOVF   FF4,W
00E00:  ADDWFC 01,F
00E02:  INCF   00,F
00E04:  BTFSC  01.7
00E06:  BRA    0E12
00E08:  RLCF   x5C,F
00E0A:  RLCF   03,F
00E0C:  RLCF   02,F
00E0E:  RLCF   01,F
00E10:  DECF   00,F
00E12:  MOVLW  00
00E14:  BTFSS  x5C.7
00E16:  BRA    0E2C
00E18:  INCF   03,F
00E1A:  ADDWFC 02,F
00E1C:  ADDWFC 01,F
00E1E:  MOVF   01,W
00E20:  BNZ   0E2C
00E22:  MOVF   02,W
00E24:  BNZ   0E2C
00E26:  MOVF   03,W
00E28:  BNZ   0E2C
00E2A:  INCF   00,F
00E2C:  BTFSC  x5B.7
00E2E:  BSF    01.7
00E30:  BTFSS  x5B.7
00E32:  BCF    01.7
00E34:  BRA    0E3E
00E36:  CLRF   00
00E38:  CLRF   01
00E3A:  CLRF   02
00E3C:  CLRF   03
00E3E:  MOVLB  0
00E40:  RETURN 0
00E42:  MOVLW  80
00E44:  BTFSS  FD8.1
00E46:  BRA    0E4C
00E48:  MOVLB  7
00E4A:  XORWF  x57,F
00E4C:  MOVLB  7
00E4E:  CLRF   x5C
00E50:  CLRF   x5D
00E52:  MOVFF  753,75B
00E56:  MOVF   x57,W
00E58:  XORWF  x5B,F
00E5A:  MOVF   x52,W
00E5C:  BTFSC  FD8.2
00E5E:  BRA    101E
00E60:  MOVWF  x5A
00E62:  MOVWF  00
00E64:  MOVF   x56,W
00E66:  BTFSC  FD8.2
00E68:  BRA    1030
00E6A:  SUBWF  x5A,F
00E6C:  BTFSC  FD8.2
00E6E:  BRA    0F76
00E70:  BNC   0EEE
00E72:  MOVFF  757,760
00E76:  BSF    x60.7
00E78:  MOVFF  758,75F
00E7C:  MOVFF  759,75E
00E80:  CLRF   x5D
00E82:  BCF    FD8.0
00E84:  RRCF   x60,F
00E86:  RRCF   x5F,F
00E88:  RRCF   x5E,F
00E8A:  RRCF   x5D,F
00E8C:  DECFSZ x5A,F
00E8E:  BRA    0E80
00E90:  BTFSS  x5B.7
00E92:  BRA    0E9A
00E94:  BSF    x5C.0
00E96:  BRA    1058
00E98:  BCF    x5C.0
00E9A:  BCF    x5A.0
00E9C:  BSF    x5C.4
00E9E:  MOVLW  07
00EA0:  MOVWF  FEA
00EA2:  MOVLW  55
00EA4:  MOVWF  FE9
00EA6:  BRA    107E
00EA8:  BCF    x5C.4
00EAA:  BTFSC  x5B.7
00EAC:  BRA    0EC2
00EAE:  BTFSS  x5A.0
00EB0:  BRA    0ED8
00EB2:  RRCF   x60,F
00EB4:  RRCF   x5F,F
00EB6:  RRCF   x5E,F
00EB8:  RRCF   x5D,F
00EBA:  INCF   00,F
00EBC:  BTFSC  FD8.2
00EBE:  BRA    104E
00EC0:  BRA    0ED8
00EC2:  BTFSC  x60.7
00EC4:  BRA    0EDE
00EC6:  BCF    FD8.0
00EC8:  RLCF   x5D,F
00ECA:  RLCF   x5E,F
00ECC:  RLCF   x5F,F
00ECE:  RLCF   x60,F
00ED0:  DECF   00,F
00ED2:  BTFSC  FD8.2
00ED4:  BRA    104E
00ED6:  BRA    0EC2
00ED8:  BSF    x5C.6
00EDA:  BRA    0FB6
00EDC:  BCF    x5C.6
00EDE:  MOVFF  753,75B
00EE2:  BTFSS  x53.7
00EE4:  BRA    0EEA
00EE6:  BSF    x60.7
00EE8:  BRA    1040
00EEA:  BCF    x60.7
00EEC:  BRA    1040
00EEE:  MOVFF  756,75A
00EF2:  MOVFF  756,00
00EF6:  MOVF   x52,W
00EF8:  SUBWF  x5A,F
00EFA:  MOVFF  753,760
00EFE:  BSF    x60.7
00F00:  MOVFF  754,75F
00F04:  MOVFF  755,75E
00F08:  CLRF   x5D
00F0A:  BCF    FD8.0
00F0C:  RRCF   x60,F
00F0E:  RRCF   x5F,F
00F10:  RRCF   x5E,F
00F12:  RRCF   x5D,F
00F14:  DECFSZ x5A,F
00F16:  BRA    0F08
00F18:  BTFSS  x5B.7
00F1A:  BRA    0F22
00F1C:  BSF    x5C.1
00F1E:  BRA    1058
00F20:  BCF    x5C.1
00F22:  BCF    x5A.0
00F24:  BSF    x5C.5
00F26:  MOVLW  07
00F28:  MOVWF  FEA
00F2A:  MOVLW  59
00F2C:  MOVWF  FE9
00F2E:  BRA    107E
00F30:  BCF    x5C.5
00F32:  BTFSC  x5B.7
00F34:  BRA    0F4A
00F36:  BTFSS  x5A.0
00F38:  BRA    0F60
00F3A:  RRCF   x60,F
00F3C:  RRCF   x5F,F
00F3E:  RRCF   x5E,F
00F40:  RRCF   x5D,F
00F42:  INCF   00,F
00F44:  BTFSC  FD8.2
00F46:  BRA    104E
00F48:  BRA    0F60
00F4A:  BTFSC  x60.7
00F4C:  BRA    0F66
00F4E:  BCF    FD8.0
00F50:  RLCF   x5D,F
00F52:  RLCF   x5E,F
00F54:  RLCF   x5F,F
00F56:  RLCF   x60,F
00F58:  DECF   00,F
00F5A:  BTFSC  FD8.2
00F5C:  BRA    104E
00F5E:  BRA    0F4A
00F60:  BSF    x5C.7
00F62:  BRA    0FB6
00F64:  BCF    x5C.7
00F66:  MOVFF  757,75B
00F6A:  BTFSS  x57.7
00F6C:  BRA    0F72
00F6E:  BSF    x60.7
00F70:  BRA    1040
00F72:  BCF    x60.7
00F74:  BRA    1040
00F76:  MOVFF  757,760
00F7A:  BSF    x60.7
00F7C:  MOVFF  758,75F
00F80:  MOVFF  759,75E
00F84:  BTFSS  x5B.7
00F86:  BRA    0F90
00F88:  BCF    x60.7
00F8A:  BSF    x5C.2
00F8C:  BRA    1058
00F8E:  BCF    x5C.2
00F90:  CLRF   x5D
00F92:  BCF    x5A.0
00F94:  MOVLW  07
00F96:  MOVWF  FEA
00F98:  MOVLW  55
00F9A:  MOVWF  FE9
00F9C:  BRA    107E
00F9E:  BTFSC  x5B.7
00FA0:  BRA    0FDA
00FA2:  MOVFF  753,75B
00FA6:  BTFSS  x5A.0
00FA8:  BRA    0FB6
00FAA:  RRCF   x60,F
00FAC:  RRCF   x5F,F
00FAE:  RRCF   x5E,F
00FB0:  RRCF   x5D,F
00FB2:  INCF   00,F
00FB4:  BZ    104E
00FB6:  BTFSS  x5D.7
00FB8:  BRA    0FD0
00FBA:  INCF   x5E,F
00FBC:  BNZ   0FD0
00FBE:  INCF   x5F,F
00FC0:  BNZ   0FD0
00FC2:  INCF   x60,F
00FC4:  BNZ   0FD0
00FC6:  RRCF   x60,F
00FC8:  RRCF   x5F,F
00FCA:  RRCF   x5E,F
00FCC:  INCF   00,F
00FCE:  BZ    104E
00FD0:  BTFSC  x5C.6
00FD2:  BRA    0EDC
00FD4:  BTFSC  x5C.7
00FD6:  BRA    0F64
00FD8:  BRA    1012
00FDA:  MOVLW  80
00FDC:  XORWF  x60,F
00FDE:  BTFSS  x60.7
00FE0:  BRA    0FEA
00FE2:  BRA    1058
00FE4:  MOVFF  757,75B
00FE8:  BRA    0FFE
00FEA:  MOVFF  753,75B
00FEE:  MOVF   x60,F
00FF0:  BNZ   0FFE
00FF2:  MOVF   x5F,F
00FF4:  BNZ   0FFE
00FF6:  MOVF   x5E,F
00FF8:  BNZ   0FFE
00FFA:  CLRF   00
00FFC:  BRA    1040
00FFE:  BTFSC  x60.7
01000:  BRA    1012
01002:  BCF    FD8.0
01004:  RLCF   x5D,F
01006:  RLCF   x5E,F
01008:  RLCF   x5F,F
0100A:  RLCF   x60,F
0100C:  DECFSZ 00,F
0100E:  BRA    0FFE
01010:  BRA    104E
01012:  BTFSS  x5B.7
01014:  BRA    101A
01016:  BSF    x60.7
01018:  BRA    1040
0101A:  BCF    x60.7
0101C:  BRA    1040
0101E:  MOVFF  756,00
01022:  MOVFF  757,760
01026:  MOVFF  758,75F
0102A:  MOVFF  759,75E
0102E:  BRA    1040
01030:  MOVFF  752,00
01034:  MOVFF  753,760
01038:  MOVFF  754,75F
0103C:  MOVFF  755,75E
01040:  MOVFF  760,01
01044:  MOVFF  75F,02
01048:  MOVFF  75E,03
0104C:  BRA    10B6
0104E:  CLRF   00
01050:  CLRF   01
01052:  CLRF   02
01054:  CLRF   03
01056:  BRA    10B6
01058:  CLRF   x5D
0105A:  COMF   x5E,F
0105C:  COMF   x5F,F
0105E:  COMF   x60,F
01060:  COMF   x5D,F
01062:  INCF   x5D,F
01064:  BNZ   1070
01066:  INCF   x5E,F
01068:  BNZ   1070
0106A:  INCF   x5F,F
0106C:  BNZ   1070
0106E:  INCF   x60,F
01070:  BTFSC  x5C.0
01072:  BRA    0E98
01074:  BTFSC  x5C.1
01076:  BRA    0F20
01078:  BTFSC  x5C.2
0107A:  BRA    0F8E
0107C:  BRA    0FE4
0107E:  MOVF   FEF,W
01080:  ADDWF  x5E,F
01082:  BNC   108E
01084:  INCF   x5F,F
01086:  BNZ   108E
01088:  INCF   x60,F
0108A:  BTFSC  FD8.2
0108C:  BSF    x5A.0
0108E:  MOVF   FED,F
01090:  MOVF   FEF,W
01092:  ADDWF  x5F,F
01094:  BNC   109C
01096:  INCF   x60,F
01098:  BTFSC  FD8.2
0109A:  BSF    x5A.0
0109C:  MOVF   FED,F
0109E:  MOVF   FEF,W
010A0:  BTFSC  FEF.7
010A2:  BRA    10A6
010A4:  XORLW  80
010A6:  ADDWF  x60,F
010A8:  BTFSC  FD8.0
010AA:  BSF    x5A.0
010AC:  BTFSC  x5C.4
010AE:  BRA    0EA8
010B0:  BTFSC  x5C.5
010B2:  BRA    0F30
010B4:  BRA    0F9E
010B6:  MOVLB  0
010B8:  RETURN 0
*
01610:  ADDWF  FE8,W
01612:  CLRF   FF7
01614:  RLCF   FF7,F
01616:  ADDLW  2B
01618:  MOVWF  FF6
0161A:  MOVLW  16
0161C:  ADDWFC FF7,F
0161E:  TBLRD*-
01620:  MOVF   FF5,W
01622:  MOVWF  FFA
01624:  TBLRD*
01626:  MOVF   FF5,W
01628:  MOVWF  FF9
0162A:  DATA D2,10
0162C:  DATA 92,11
0162E:  DATA 52,12
01630:  DATA 12,13
01632:  DATA D2,13
01634:  DATA 92,14
01636:  DATA 52,15
01638:  BTFSC  FD8.1
0163A:  BRA    1644
0163C:  MOVLW  07
0163E:  MOVWF  FEA
01640:  MOVLW  41
01642:  MOVWF  FE9
01644:  MOVLB  7
01646:  MOVF   x3C,W
01648:  XORWF  x40,W
0164A:  ANDLW  80
0164C:  MOVWF  x46
0164E:  BTFSS  x3C.7
01650:  BRA    1668
01652:  COMF   x39,F
01654:  COMF   x3A,F
01656:  COMF   x3B,F
01658:  COMF   x3C,F
0165A:  INCF   x39,F
0165C:  BTFSC  FD8.2
0165E:  INCF   x3A,F
01660:  BTFSC  FD8.2
01662:  INCF   x3B,F
01664:  BTFSC  FD8.2
01666:  INCF   x3C,F
01668:  BTFSS  x40.7
0166A:  BRA    1682
0166C:  COMF   x3D,F
0166E:  COMF   x3E,F
01670:  COMF   x3F,F
01672:  COMF   x40,F
01674:  INCF   x3D,F
01676:  BTFSC  FD8.2
01678:  INCF   x3E,F
0167A:  BTFSC  FD8.2
0167C:  INCF   x3F,F
0167E:  BTFSC  FD8.2
01680:  INCF   x40,F
01682:  CLRF   00
01684:  CLRF   01
01686:  CLRF   02
01688:  CLRF   03
0168A:  CLRF   x41
0168C:  CLRF   x42
0168E:  CLRF   x43
01690:  CLRF   x44
01692:  MOVF   x40,W
01694:  IORWF  x3F,W
01696:  IORWF  x3E,W
01698:  IORWF  x3D,W
0169A:  BZ    16F4
0169C:  MOVLW  20
0169E:  MOVWF  x45
016A0:  BCF    FD8.0
016A2:  RLCF   x39,F
016A4:  RLCF   x3A,F
016A6:  RLCF   x3B,F
016A8:  RLCF   x3C,F
016AA:  RLCF   x41,F
016AC:  RLCF   x42,F
016AE:  RLCF   x43,F
016B0:  RLCF   x44,F
016B2:  MOVF   x40,W
016B4:  SUBWF  x44,W
016B6:  BNZ   16C8
016B8:  MOVF   x3F,W
016BA:  SUBWF  x43,W
016BC:  BNZ   16C8
016BE:  MOVF   x3E,W
016C0:  SUBWF  x42,W
016C2:  BNZ   16C8
016C4:  MOVF   x3D,W
016C6:  SUBWF  x41,W
016C8:  BNC   16E8
016CA:  MOVF   x3D,W
016CC:  SUBWF  x41,F
016CE:  MOVF   x3E,W
016D0:  BTFSS  FD8.0
016D2:  INCFSZ x3E,W
016D4:  SUBWF  x42,F
016D6:  MOVF   x3F,W
016D8:  BTFSS  FD8.0
016DA:  INCFSZ x3F,W
016DC:  SUBWF  x43,F
016DE:  MOVF   x40,W
016E0:  BTFSS  FD8.0
016E2:  INCFSZ x40,W
016E4:  SUBWF  x44,F
016E6:  BSF    FD8.0
016E8:  RLCF   00,F
016EA:  RLCF   01,F
016EC:  RLCF   02,F
016EE:  RLCF   03,F
016F0:  DECFSZ x45,F
016F2:  BRA    16A0
016F4:  BTFSS  x46.7
016F6:  BRA    170E
016F8:  COMF   00,F
016FA:  COMF   01,F
016FC:  COMF   02,F
016FE:  COMF   03,F
01700:  INCF   00,F
01702:  BTFSC  FD8.2
01704:  INCF   01,F
01706:  BTFSC  FD8.2
01708:  INCF   02,F
0170A:  BTFSC  FD8.2
0170C:  INCF   03,F
0170E:  MOVFF  741,FEF
01712:  MOVFF  742,FEC
01716:  MOVFF  743,FEC
0171A:  MOVFF  744,FEC
0171E:  MOVLB  0
01720:  RETURN 0
*
01C7E:  MOVLW  B6
01C80:  MOVWF  00
01C82:  CLRF   03
01C84:  CLRF   02
01C86:  CLRF   01
01C88:  MOVLB  7
01C8A:  BCF    x1C.0
01C8C:  BTFSS  x1B.7
01C8E:  BRA    1CA8
01C90:  BSF    x1C.0
01C92:  COMF   x18,F
01C94:  COMF   x19,F
01C96:  COMF   x1A,F
01C98:  COMF   x1B,F
01C9A:  INCF   x18,F
01C9C:  BNZ   1CA8
01C9E:  INCF   x19,F
01CA0:  BNZ   1CA8
01CA2:  INCF   x1A,F
01CA4:  BTFSC  FD8.2
01CA6:  INCF   x1B,F
01CA8:  MOVF   x18,W
01CAA:  IORWF  x19,W
01CAC:  IORWF  x1A,W
01CAE:  IORWF  x1B,W
01CB0:  BNZ   1CB6
01CB2:  CLRF   00
01CB4:  BRA    1CD4
01CB6:  BCF    FD8.0
01CB8:  BTFSC  01.7
01CBA:  BRA    1CCE
01CBC:  RLCF   x18,F
01CBE:  RLCF   x19,F
01CC0:  RLCF   x1A,F
01CC2:  RLCF   x1B,F
01CC4:  RLCF   03,F
01CC6:  RLCF   02,F
01CC8:  RLCF   01,F
01CCA:  DECFSZ 00,F
01CCC:  BRA    1CB6
01CCE:  BCF    01.7
01CD0:  BTFSC  x1C.0
01CD2:  BSF    01.7
01CD4:  MOVLB  0
01CD6:  RETURN 0
01CD8:  MOVFF  74F,756
01CDC:  MOVLB  7
01CDE:  MOVF   x53,W
01CE0:  XORWF  x56,F
01CE2:  BTFSS  x56.7
01CE4:  BRA    1CF0
01CE6:  BCF    FD8.2
01CE8:  BCF    FD8.0
01CEA:  BTFSC  x4F.7
01CEC:  BSF    FD8.0
01CEE:  BRA    1D4E
01CF0:  MOVFF  74F,756
01CF4:  MOVFF  752,757
01CF8:  MOVF   x4E,W
01CFA:  SUBWF  x57,F
01CFC:  BZ    1D0A
01CFE:  BTFSS  x56.7
01D00:  BRA    1D4E
01D02:  MOVF   FD8,W
01D04:  XORLW  01
01D06:  MOVWF  FD8
01D08:  BRA    1D4E
01D0A:  MOVFF  753,757
01D0E:  MOVF   x4F,W
01D10:  SUBWF  x57,F
01D12:  BZ    1D20
01D14:  BTFSS  x56.7
01D16:  BRA    1D4E
01D18:  MOVF   FD8,W
01D1A:  XORLW  01
01D1C:  MOVWF  FD8
01D1E:  BRA    1D4E
01D20:  MOVFF  754,757
01D24:  MOVF   x50,W
01D26:  SUBWF  x57,F
01D28:  BZ    1D36
01D2A:  BTFSS  x56.7
01D2C:  BRA    1D4E
01D2E:  MOVF   FD8,W
01D30:  XORLW  01
01D32:  MOVWF  FD8
01D34:  BRA    1D4E
01D36:  MOVFF  755,757
01D3A:  MOVF   x51,W
01D3C:  SUBWF  x57,F
01D3E:  BZ    1D4C
01D40:  BTFSS  x56.7
01D42:  BRA    1D4E
01D44:  MOVF   FD8,W
01D46:  XORLW  01
01D48:  MOVWF  FD8
01D4A:  BRA    1D4E
01D4C:  BCF    FD8.0
01D4E:  MOVLB  0
01D50:  RETURN 0
01D52:  MOVLB  7
01D54:  MOVF   x47,W
01D56:  BTFSC  FD8.2
01D58:  BRA    1EA4
01D5A:  MOVWF  x53
01D5C:  MOVF   x4B,W
01D5E:  BTFSC  FD8.2
01D60:  BRA    1EA4
01D62:  SUBWF  x53,F
01D64:  BNC   1D70
01D66:  MOVLW  7F
01D68:  ADDWF  x53,F
01D6A:  BTFSC  FD8.0
01D6C:  BRA    1EA4
01D6E:  BRA    1D7C
01D70:  MOVLW  81
01D72:  SUBWF  x53,F
01D74:  BTFSS  FD8.0
01D76:  BRA    1EA4
01D78:  BTFSC  FD8.2
01D7A:  BRA    1EA4
01D7C:  MOVFF  753,00
01D80:  CLRF   01
01D82:  CLRF   02
01D84:  CLRF   03
01D86:  CLRF   x52
01D88:  MOVFF  748,751
01D8C:  BSF    x51.7
01D8E:  MOVFF  749,750
01D92:  MOVFF  74A,74F
01D96:  MOVLW  19
01D98:  MOVWF  x53
01D9A:  MOVF   x4E,W
01D9C:  SUBWF  x4F,F
01D9E:  BC    1DBA
01DA0:  MOVLW  01
01DA2:  SUBWF  x50,F
01DA4:  BC    1DBA
01DA6:  SUBWF  x51,F
01DA8:  BC    1DBA
01DAA:  SUBWF  x52,F
01DAC:  BC    1DBA
01DAE:  INCF   x52,F
01DB0:  INCF   x51,F
01DB2:  INCF   x50,F
01DB4:  MOVF   x4E,W
01DB6:  ADDWF  x4F,F
01DB8:  BRA    1E0A
01DBA:  MOVF   x4D,W
01DBC:  SUBWF  x50,F
01DBE:  BC    1DE4
01DC0:  MOVLW  01
01DC2:  SUBWF  x51,F
01DC4:  BC    1DE4
01DC6:  SUBWF  x52,F
01DC8:  BC    1DE4
01DCA:  INCF   x52,F
01DCC:  INCF   x51,F
01DCE:  MOVF   x4D,W
01DD0:  ADDWF  x50,F
01DD2:  MOVF   x4E,W
01DD4:  ADDWF  x4F,F
01DD6:  BNC   1E0A
01DD8:  INCF   x50,F
01DDA:  BNZ   1E0A
01DDC:  INCF   x51,F
01DDE:  BNZ   1E0A
01DE0:  INCF   x52,F
01DE2:  BRA    1E0A
01DE4:  MOVF   x4C,W
01DE6:  IORLW  80
01DE8:  SUBWF  x51,F
01DEA:  BC    1E08
01DEC:  MOVLW  01
01DEE:  SUBWF  x52,F
01DF0:  BC    1E08
01DF2:  INCF   x52,F
01DF4:  MOVF   x4C,W
01DF6:  IORLW  80
01DF8:  ADDWF  x51,F
01DFA:  MOVF   x4D,W
01DFC:  ADDWF  x50,F
01DFE:  BNC   1DD2
01E00:  INCF   x51,F
01E02:  BNZ   1DD2
01E04:  INCF   x52,F
01E06:  BRA    1DD2
01E08:  BSF    03.0
01E0A:  DECFSZ x53,F
01E0C:  BRA    1E10
01E0E:  BRA    1E26
01E10:  BCF    FD8.0
01E12:  RLCF   x4F,F
01E14:  RLCF   x50,F
01E16:  RLCF   x51,F
01E18:  RLCF   x52,F
01E1A:  BCF    FD8.0
01E1C:  RLCF   03,F
01E1E:  RLCF   02,F
01E20:  RLCF   01,F
01E22:  RLCF   x54,F
01E24:  BRA    1D9A
01E26:  BTFSS  x54.0
01E28:  BRA    1E36
01E2A:  BCF    FD8.0
01E2C:  RRCF   01,F
01E2E:  RRCF   02,F
01E30:  RRCF   03,F
01E32:  RRCF   x54,F
01E34:  BRA    1E3A
01E36:  DECF   00,F
01E38:  BZ    1EA4
01E3A:  BTFSC  x54.7
01E3C:  BRA    1E7A
01E3E:  BCF    FD8.0
01E40:  RLCF   x4F,F
01E42:  RLCF   x50,F
01E44:  RLCF   x51,F
01E46:  RLCF   x52,F
01E48:  MOVF   x4E,W
01E4A:  SUBWF  x4F,F
01E4C:  BC    1E5C
01E4E:  MOVLW  01
01E50:  SUBWF  x50,F
01E52:  BC    1E5C
01E54:  SUBWF  x51,F
01E56:  BC    1E5C
01E58:  SUBWF  x52,F
01E5A:  BNC   1E90
01E5C:  MOVF   x4D,W
01E5E:  SUBWF  x50,F
01E60:  BC    1E6C
01E62:  MOVLW  01
01E64:  SUBWF  x51,F
01E66:  BC    1E6C
01E68:  SUBWF  x52,F
01E6A:  BNC   1E90
01E6C:  MOVF   x4C,W
01E6E:  IORLW  80
01E70:  SUBWF  x51,F
01E72:  BC    1E7A
01E74:  MOVLW  01
01E76:  SUBWF  x52,F
01E78:  BNC   1E90
01E7A:  INCF   03,F
01E7C:  BNZ   1E90
01E7E:  INCF   02,F
01E80:  BNZ   1E90
01E82:  INCF   01,F
01E84:  BNZ   1E90
01E86:  INCF   00,F
01E88:  BZ    1EA4
01E8A:  RRCF   01,F
01E8C:  RRCF   02,F
01E8E:  RRCF   03,F
01E90:  MOVFF  748,753
01E94:  MOVF   x4C,W
01E96:  XORWF  x53,F
01E98:  BTFSS  x53.7
01E9A:  BRA    1EA0
01E9C:  BSF    01.7
01E9E:  BRA    1EAC
01EA0:  BCF    01.7
01EA2:  BRA    1EAC
01EA4:  CLRF   00
01EA6:  CLRF   01
01EA8:  CLRF   02
01EAA:  CLRF   03
01EAC:  MOVLB  0
01EAE:  RETURN 0
*
0265A:  ADDWF  FE8,W
0265C:  CLRF   FF7
0265E:  RLCF   FF7,F
02660:  ADDLW  75
02662:  MOVWF  FF6
02664:  MOVLW  26
02666:  ADDWFC FF7,F
02668:  TBLRD*-
0266A:  MOVF   FF5,W
0266C:  MOVWF  FFA
0266E:  TBLRD*
02670:  MOVF   FF5,W
02672:  MOVWF  FF9
02674:  DATA 62,25
02676:  DATA 7C,25
02678:  DATA D0,25
0267A:  DATA 34,26
0267C:  MOVLW  8E
0267E:  MOVWF  00
02680:  MOVFF  745,01
02684:  MOVFF  744,02
02688:  CLRF   03
0268A:  BTFSS  01.7
0268C:  BRA    2698
0268E:  COMF   01,F
02690:  COMF   02,F
02692:  INCF   02,F
02694:  BNZ   2698
02696:  INCF   01,F
02698:  MOVF   01,F
0269A:  BNZ   26AE
0269C:  MOVFF  02,01
026A0:  CLRF   02
026A2:  MOVLW  08
026A4:  SUBWF  00,F
026A6:  MOVF   01,F
026A8:  BNZ   26AE
026AA:  CLRF   00
026AC:  BRA    26CA
026AE:  BCF    FD8.0
026B0:  BTFSC  01.7
026B2:  BRA    26BC
026B4:  RLCF   02,F
026B6:  RLCF   01,F
026B8:  DECF   00,F
026BA:  BRA    26AE
026BC:  MOVLB  7
026BE:  BTFSS  x45.7
026C0:  BRA    26C6
026C2:  MOVLB  0
026C4:  BRA    26CA
026C6:  BCF    01.7
026C8:  MOVLB  0
026CA:  RETURN 0
026CC:  MOVLW  8E
026CE:  MOVWF  00
026D0:  MOVLB  7
026D2:  MOVF   x4E,W
026D4:  SUBWF  00,F
026D6:  MOVFF  74F,02
026DA:  MOVFF  750,01
026DE:  BSF    02.7
026E0:  MOVF   00,F
026E2:  BZ    26F6
026E4:  BCF    FD8.0
026E6:  MOVF   02,F
026E8:  BNZ   26EE
026EA:  MOVF   01,F
026EC:  BZ    26F6
026EE:  RRCF   02,F
026F0:  RRCF   01,F
026F2:  DECFSZ 00,F
026F4:  BRA    26E4
026F6:  BTFSS  x4F.7
026F8:  BRA    2704
026FA:  COMF   01,F
026FC:  COMF   02,F
026FE:  INCF   01,F
02700:  BTFSC  FD8.2
02702:  INCF   02,F
02704:  MOVLB  0
02706:  RETURN 0
*
045BC:  MOVLB  7
045BE:  MOVF   x10,W
045C0:  ANDLW  07
045C2:  MOVWF  00
045C4:  RRCF   x10,W
045C6:  MOVWF  01
045C8:  RRCF   01,F
045CA:  RRCF   01,F
045CC:  MOVLW  1F
045CE:  ANDWF  01,F
045D0:  MOVF   01,W
045D2:  ADDWF  x11,W
045D4:  MOVWF  FE9
045D6:  MOVLW  00
045D8:  ADDWFC x12,W
045DA:  MOVWF  FEA
045DC:  MOVFF  FEF,01
045E0:  INCF   00,F
045E2:  BRA    45E6
045E4:  RRCF   01,F
045E6:  DECFSZ 00,F
045E8:  BRA    45E4
045EA:  MOVLW  01
045EC:  ANDWF  01,F
045EE:  MOVLB  0
045F0:  RETURN 0
*
04FE2:  MOVF   FEF,F
04FE4:  BZ    500A
04FE6:  MOVFF  FEA,707
04FEA:  MOVFF  FE9,706
04FEE:  MOVF   FEF,W
04FF0:  MOVLB  E
04FF2:  BTFSS  xC8.4
04FF4:  BRA    4FF2
04FF6:  MOVWF  F99
04FF8:  MOVFF  707,FEA
04FFC:  MOVFF  706,FE9
05000:  INCF   FE9,F
05002:  BTFSC  FD8.2
05004:  INCF   FEA,F
05006:  MOVLB  0
05008:  BRA    4FE2
0500A:  GOTO   502A (RETURN)
*
055E6:  MOVFF  565,FEA
055EA:  MOVFF  564,FE9
055EE:  MOVFF  753,FEF
055F2:  INCF   FE9,F
055F4:  BTFSC  FD8.2
055F6:  INCF   FEA,F
055F8:  CLRF   FEF
055FA:  MOVLB  5
055FC:  INCF   x64,F
055FE:  BTFSC  FD8.2
05600:  INCF   x65,F
05602:  MOVLB  0
05604:  RETURN 0
05606:  MOVF   FEF,F
05608:  BZ    5628
0560A:  MOVFF  FEA,70B
0560E:  MOVFF  FE9,70A
05612:  MOVFF  FEF,753
05616:  RCALL  55E6
05618:  MOVFF  70B,FEA
0561C:  MOVFF  70A,FE9
05620:  INCF   FE9,F
05622:  BTFSC  FD8.2
05624:  INCF   FEA,F
05626:  BRA    5606
05628:  RETURN 0
*
056DC:  TBLRD*+
056DE:  MOVF   FF5,F
056E0:  BZ    56FA
056E2:  MOVFF  FF6,711
056E6:  MOVFF  FF7,712
056EA:  MOVFF  FF5,753
056EE:  RCALL  55E6
056F0:  MOVFF  711,FF6
056F4:  MOVFF  712,FF7
056F8:  BRA    56DC
056FA:  RETURN 0
*
0581E:  MOVLB  7
05820:  MOVF   x6B,W
05822:  XORWF  x6D,W
05824:  ANDLW  80
05826:  MOVWF  x6F
05828:  BTFSS  x6B.7
0582A:  BRA    5836
0582C:  COMF   x6A,F
0582E:  COMF   x6B,F
05830:  INCF   x6A,F
05832:  BTFSC  FD8.2
05834:  INCF   x6B,F
05836:  BTFSS  x6D.7
05838:  BRA    5844
0583A:  COMF   x6C,F
0583C:  COMF   x6D,F
0583E:  INCF   x6C,F
05840:  BTFSC  FD8.2
05842:  INCF   x6D,F
05844:  MOVF   x6A,W
05846:  MULWF  x6C
05848:  MOVFF  FF3,01
0584C:  MOVFF  FF4,00
05850:  MULWF  x6D
05852:  MOVF   FF3,W
05854:  ADDWF  00,F
05856:  MOVF   x6B,W
05858:  MULWF  x6C
0585A:  MOVF   FF3,W
0585C:  ADDWFC 00,W
0585E:  MOVWF  02
05860:  BTFSS  x6F.7
05862:  BRA    586E
05864:  COMF   01,F
05866:  COMF   02,F
05868:  INCF   01,F
0586A:  BTFSC  FD8.2
0586C:  INCF   02,F
0586E:  MOVLB  0
05870:  GOTO   5B04 (RETURN)
*
05BC8:  MOVLW  20
05BCA:  MOVLB  7
05BCC:  BTFSS  x38.4
05BCE:  MOVLW  30
05BD0:  MOVWF  x39
05BD2:  MOVFF  737,00
05BD6:  BTFSS  00.7
05BD8:  BRA    5BEA
05BDA:  COMF   00,F
05BDC:  INCF   00,F
05BDE:  MOVFF  00,737
05BE2:  MOVLW  2D
05BE4:  MOVWF  x39
05BE6:  BSF    x38.7
05BE8:  BSF    x38.0
05BEA:  MOVF   01,W
05BEC:  MOVFF  737,741
05BF0:  MOVLW  64
05BF2:  MOVWF  x42
05BF4:  MOVLB  0
05BF6:  CALL   0886
05BFA:  MOVFF  00,737
05BFE:  MOVLW  30
05C00:  ADDWF  01,W
05C02:  MOVLB  7
05C04:  MOVWF  x3A
05C06:  MOVFF  737,741
05C0A:  MOVLW  0A
05C0C:  MOVWF  x42
05C0E:  MOVLB  0
05C10:  CALL   0886
05C14:  MOVLW  30
05C16:  ADDWF  00,W
05C18:  MOVLB  7
05C1A:  MOVWF  x3C
05C1C:  MOVLW  30
05C1E:  ADDWF  01,W
05C20:  MOVWF  x3B
05C22:  MOVFF  739,00
05C26:  MOVLW  30
05C28:  SUBWF  x3A,W
05C2A:  BZ    5C34
05C2C:  BSF    x38.1
05C2E:  BTFSC  x38.7
05C30:  BSF    x38.2
05C32:  BRA    5C58
05C34:  MOVFF  739,73A
05C38:  MOVLW  20
05C3A:  MOVWF  x39
05C3C:  MOVLW  30
05C3E:  SUBWF  x3B,W
05C40:  BZ    5C4A
05C42:  BSF    x38.0
05C44:  BTFSC  x38.7
05C46:  BSF    x38.1
05C48:  BRA    5C58
05C4A:  BTFSS  FD8.2
05C4C:  BSF    x38.0
05C4E:  BNZ   5C58
05C50:  MOVFF  73A,73B
05C54:  MOVLW  20
05C56:  MOVWF  x3A
05C58:  BTFSC  x38.2
05C5A:  BRA    5C66
05C5C:  BTFSC  x38.1
05C5E:  BRA    5C6E
05C60:  BTFSC  x38.0
05C62:  BRA    5C76
05C64:  BRA    5C7E
05C66:  MOVFF  739,753
05C6A:  MOVLB  0
05C6C:  RCALL  55E6
05C6E:  MOVFF  73A,753
05C72:  MOVLB  0
05C74:  RCALL  55E6
05C76:  MOVFF  73B,753
05C7A:  MOVLB  0
05C7C:  RCALL  55E6
05C7E:  MOVFF  73C,753
05C82:  MOVLB  0
05C84:  RCALL  55E6
05C86:  RETURN 0
*
05E2C:  MOVLB  7
05E2E:  MOVF   x25,W
05E30:  ANDLW  07
05E32:  MOVWF  00
05E34:  RRCF   x25,W
05E36:  MOVWF  01
05E38:  RRCF   01,F
05E3A:  RRCF   01,F
05E3C:  MOVLW  1F
05E3E:  ANDWF  01,F
05E40:  MOVF   01,W
05E42:  ADDWF  x27,W
05E44:  MOVWF  FE9
05E46:  MOVLW  00
05E48:  ADDWFC x28,W
05E4A:  MOVWF  FEA
05E4C:  CLRF   01
05E4E:  INCF   01,F
05E50:  INCF   00,F
05E52:  BRA    5E56
05E54:  RLCF   01,F
05E56:  DECFSZ 00,F
05E58:  BRA    5E54
05E5A:  MOVF   x26,F
05E5C:  BZ    5E64
05E5E:  MOVF   01,W
05E60:  IORWF  FEF,F
05E62:  BRA    5E6A
05E64:  COMF   01,F
05E66:  MOVF   01,W
05E68:  ANDWF  FEF,F
05E6A:  MOVLB  0
05E6C:  RETURN 0
*
0601C:  TBLRD*+
0601E:  MOVFF  FF6,71C
06022:  MOVFF  FF7,71D
06026:  MOVFF  FF5,753
0602A:  CALL   55E6
0602E:  MOVFF  71C,FF6
06032:  MOVFF  71D,FF7
06036:  MOVLB  7
06038:  DECFSZ x1B,F
0603A:  BRA    603E
0603C:  BRA    6042
0603E:  MOVLB  0
06040:  BRA    601C
06042:  MOVLB  0
06044:  RETURN 0
*
063EC:  MOVLB  7
063EE:  MOVF   x53,W
063F0:  SUBLW  B6
063F2:  MOVWF  x53
063F4:  CLRF   03
063F6:  MOVFF  754,757
063FA:  BSF    x54.7
063FC:  BCF    FD8.0
063FE:  RRCF   x54,F
06400:  RRCF   x55,F
06402:  RRCF   x56,F
06404:  RRCF   03,F
06406:  RRCF   02,F
06408:  RRCF   01,F
0640A:  RRCF   00,F
0640C:  DECFSZ x53,F
0640E:  BRA    63FC
06410:  BTFSS  x57.7
06412:  BRA    642A
06414:  COMF   00,F
06416:  COMF   01,F
06418:  COMF   02,F
0641A:  COMF   03,F
0641C:  INCF   00,F
0641E:  BTFSC  FD8.2
06420:  INCF   01,F
06422:  BTFSC  FD8.2
06424:  INCF   02,F
06426:  BTFSC  FD8.2
06428:  INCF   03,F
0642A:  MOVLB  0
0642C:  RETURN 0
0642E:  BTFSC  FD8.1
06430:  BRA    643A
06432:  MOVLW  07
06434:  MOVWF  FEA
06436:  MOVLW  5B
06438:  MOVWF  FE9
0643A:  CLRF   00
0643C:  CLRF   01
0643E:  CLRF   02
06440:  CLRF   03
06442:  MOVLB  7
06444:  CLRF   x5B
06446:  CLRF   x5C
06448:  CLRF   x5D
0644A:  CLRF   x5E
0644C:  MOVF   x5A,W
0644E:  IORWF  x59,W
06450:  IORWF  x58,W
06452:  IORWF  x57,W
06454:  BZ    64AE
06456:  MOVLW  20
06458:  MOVWF  x5F
0645A:  BCF    FD8.0
0645C:  RLCF   x53,F
0645E:  RLCF   x54,F
06460:  RLCF   x55,F
06462:  RLCF   x56,F
06464:  RLCF   x5B,F
06466:  RLCF   x5C,F
06468:  RLCF   x5D,F
0646A:  RLCF   x5E,F
0646C:  MOVF   x5A,W
0646E:  SUBWF  x5E,W
06470:  BNZ   6482
06472:  MOVF   x59,W
06474:  SUBWF  x5D,W
06476:  BNZ   6482
06478:  MOVF   x58,W
0647A:  SUBWF  x5C,W
0647C:  BNZ   6482
0647E:  MOVF   x57,W
06480:  SUBWF  x5B,W
06482:  BNC   64A2
06484:  MOVF   x57,W
06486:  SUBWF  x5B,F
06488:  MOVF   x58,W
0648A:  BTFSS  FD8.0
0648C:  INCFSZ x58,W
0648E:  SUBWF  x5C,F
06490:  MOVF   x59,W
06492:  BTFSS  FD8.0
06494:  INCFSZ x59,W
06496:  SUBWF  x5D,F
06498:  MOVF   x5A,W
0649A:  BTFSS  FD8.0
0649C:  INCFSZ x5A,W
0649E:  SUBWF  x5E,F
064A0:  BSF    FD8.0
064A2:  RLCF   00,F
064A4:  RLCF   01,F
064A6:  RLCF   02,F
064A8:  RLCF   03,F
064AA:  DECFSZ x5F,F
064AC:  BRA    645A
064AE:  MOVFF  75B,FEF
064B2:  MOVFF  75C,FEC
064B6:  MOVFF  75D,FEC
064BA:  MOVFF  75E,FEC
064BE:  MOVLB  0
064C0:  RETURN 0
064C2:  MOVF   FE9,W
064C4:  MOVLB  7
064C6:  MOVWF  x4B
064C8:  MOVF   x4A,W
064CA:  MOVWF  x4D
064CC:  BZ    6506
064CE:  MOVFF  749,756
064D2:  MOVFF  748,755
064D6:  MOVFF  747,754
064DA:  MOVFF  746,753
064DE:  CLRF   x5A
064E0:  CLRF   x59
064E2:  MOVLW  20
064E4:  MOVWF  x58
064E6:  MOVLW  82
064E8:  MOVWF  x57
064EA:  MOVLB  0
064EC:  CALL   0D4C
064F0:  MOVFF  03,749
064F4:  MOVFF  02,748
064F8:  MOVFF  01,747
064FC:  MOVFF  00,746
06500:  MOVLB  7
06502:  DECFSZ x4D,F
06504:  BRA    64CE
06506:  MOVFF  749,756
0650A:  MOVFF  748,755
0650E:  MOVFF  747,754
06512:  MOVFF  746,753
06516:  MOVLB  0
06518:  RCALL  63EC
0651A:  MOVFF  03,749
0651E:  MOVFF  02,748
06522:  MOVFF  01,747
06526:  MOVFF  00,746
0652A:  MOVLB  7
0652C:  BTFSS  x49.7
0652E:  BRA    654A
06530:  DECF   x4B,F
06532:  BSF    x4B.5
06534:  COMF   x46,F
06536:  COMF   x47,F
06538:  COMF   x48,F
0653A:  COMF   x49,F
0653C:  INCF   x46,F
0653E:  BTFSC  FD8.2
06540:  INCF   x47,F
06542:  BTFSC  FD8.2
06544:  INCF   x48,F
06546:  BTFSC  FD8.2
06548:  INCF   x49,F
0654A:  MOVLW  3B
0654C:  MOVWF  x52
0654E:  MOVLW  9A
06550:  MOVWF  x51
06552:  MOVLW  CA
06554:  MOVWF  x50
06556:  CLRF   x4F
06558:  MOVLW  0A
0655A:  MOVWF  x4D
0655C:  MOVF   x4A,W
0655E:  BTFSC  FD8.2
06560:  INCF   x4B,F
06562:  BSF    FD8.1
06564:  MOVLW  07
06566:  MOVWF  FEA
06568:  MOVLW  46
0656A:  MOVWF  FE9
0656C:  MOVFF  749,756
06570:  MOVFF  748,755
06574:  MOVFF  747,754
06578:  MOVFF  746,753
0657C:  MOVFF  752,75A
06580:  MOVFF  751,759
06584:  MOVFF  750,758
06588:  MOVFF  74F,757
0658C:  MOVLB  0
0658E:  RCALL  642E
06590:  MOVF   01,W
06592:  MOVF   00,F
06594:  BNZ   65BC
06596:  MOVLB  7
06598:  INCF   x4A,W
0659A:  SUBWF  x4D,W
0659C:  BTFSS  FD8.2
0659E:  BRA    65A4
065A0:  MOVLB  0
065A2:  BRA    65BC
065A4:  MOVF   x4B,W
065A6:  BZ    65C2
065A8:  ANDLW  0F
065AA:  SUBWF  x4D,W
065AC:  BZ    65B0
065AE:  BC    6638
065B0:  BTFSC  x4B.7
065B2:  BRA    6638
065B4:  BTFSC  x4B.6
065B6:  BRA    65C2
065B8:  MOVLW  20
065BA:  BRA    662A
065BC:  MOVLW  20
065BE:  MOVLB  7
065C0:  ANDWF  x4B,F
065C2:  BTFSS  x4B.5
065C4:  BRA    65E4
065C6:  BCF    x4B.5
065C8:  MOVF   x4A,W
065CA:  BTFSS  FD8.2
065CC:  DECF   x4B,F
065CE:  MOVF   00,W
065D0:  MOVWF  x4B
065D2:  MOVLW  2D
065D4:  MOVWF  x53
065D6:  MOVLB  0
065D8:  CALL   55E6
065DC:  MOVLB  7
065DE:  MOVF   x4B,W
065E0:  MOVWF  00
065E2:  CLRF   x4B
065E4:  MOVF   x4A,W
065E6:  SUBWF  x4D,W
065E8:  BNZ   6604
065EA:  MOVF   00,W
065EC:  MOVWF  x4B
065EE:  MOVLW  2E
065F0:  MOVWF  x53
065F2:  MOVLB  0
065F4:  CALL   55E6
065F8:  MOVLB  7
065FA:  MOVF   x4B,W
065FC:  MOVWF  00
065FE:  MOVLW  20
06600:  ANDWF  x4B,F
06602:  MOVLW  00
06604:  MOVLW  30
06606:  BTFSS  x4B.5
06608:  BRA    662A
0660A:  BCF    x4B.5
0660C:  MOVF   x4A,W
0660E:  BTFSS  FD8.2
06610:  DECF   x4B,F
06612:  MOVF   00,W
06614:  MOVWF  x4B
06616:  MOVLW  2D
06618:  MOVWF  x53
0661A:  MOVLB  0
0661C:  CALL   55E6
06620:  MOVLB  7
06622:  MOVF   x4B,W
06624:  MOVWF  00
06626:  CLRF   x4B
06628:  MOVLW  30
0662A:  ADDWF  00,F
0662C:  MOVFF  00,753
06630:  MOVLB  0
06632:  CALL   55E6
06636:  MOVLB  7
06638:  BCF    FD8.1
0663A:  MOVFF  752,756
0663E:  MOVFF  751,755
06642:  MOVFF  750,754
06646:  MOVFF  74F,753
0664A:  CLRF   x5A
0664C:  CLRF   x59
0664E:  CLRF   x58
06650:  MOVLW  0A
06652:  MOVWF  x57
06654:  MOVLB  0
06656:  RCALL  642E
06658:  MOVFF  03,752
0665C:  MOVFF  02,751
06660:  MOVFF  01,750
06664:  MOVFF  00,74F
06668:  MOVLB  7
0666A:  DECFSZ x4D,F
0666C:  BRA    6562
0666E:  MOVLB  0
06670:  RETURN 0
*
090DA:  MOVF   FE9,W
090DC:  MOVLB  7
090DE:  MOVWF  x40
090E0:  BTFSS  x3F.7
090E2:  BRA    90FE
090E4:  DECF   x40,F
090E6:  BSF    x40.5
090E8:  COMF   x3C,F
090EA:  COMF   x3D,F
090EC:  COMF   x3E,F
090EE:  COMF   x3F,F
090F0:  INCF   x3C,F
090F2:  BTFSC  FD8.2
090F4:  INCF   x3D,F
090F6:  BTFSC  FD8.2
090F8:  INCF   x3E,F
090FA:  BTFSC  FD8.2
090FC:  INCF   x3F,F
090FE:  MOVLW  3B
09100:  MOVWF  x47
09102:  MOVLW  9A
09104:  MOVWF  x46
09106:  MOVLW  CA
09108:  MOVWF  x45
0910A:  CLRF   x44
0910C:  MOVLW  0A
0910E:  MOVWF  x42
09110:  BSF    FD8.1
09112:  MOVLW  07
09114:  MOVWF  FEA
09116:  MOVLW  3C
09118:  MOVWF  FE9
0911A:  MOVFF  73F,756
0911E:  MOVFF  73E,755
09122:  MOVFF  73D,754
09126:  MOVFF  73C,753
0912A:  MOVFF  747,75A
0912E:  MOVFF  746,759
09132:  MOVFF  745,758
09136:  MOVFF  744,757
0913A:  MOVLB  0
0913C:  CALL   642E
09140:  MOVF   01,W
09142:  MOVF   00,F
09144:  BNZ   916C
09146:  MOVLB  7
09148:  MOVF   x42,W
0914A:  XORLW  01
0914C:  BTFSS  FD8.2
0914E:  BRA    9154
09150:  MOVLB  0
09152:  BRA    916C
09154:  MOVF   x40,W
09156:  BZ    9172
09158:  ANDLW  0F
0915A:  SUBWF  x42,W
0915C:  BZ    9160
0915E:  BC    91BC
09160:  BTFSC  x40.7
09162:  BRA    91BC
09164:  BTFSC  x40.6
09166:  BRA    9172
09168:  MOVLW  20
0916A:  BRA    91AE
0916C:  MOVLW  20
0916E:  MOVLB  7
09170:  ANDWF  x40,F
09172:  BTFSS  x40.5
09174:  BRA    918E
09176:  BCF    x40.5
09178:  MOVFF  00,740
0917C:  MOVLW  2D
0917E:  MOVWF  x53
09180:  MOVLB  0
09182:  CALL   55E6
09186:  MOVLB  7
09188:  MOVFF  740,00
0918C:  CLRF   x40
0918E:  MOVLW  30
09190:  BTFSS  x40.5
09192:  BRA    91AE
09194:  BCF    x40.5
09196:  MOVFF  00,740
0919A:  MOVLW  2D
0919C:  MOVWF  x53
0919E:  MOVLB  0
091A0:  CALL   55E6
091A4:  MOVLB  7
091A6:  MOVFF  740,00
091AA:  CLRF   x40
091AC:  MOVLW  30
091AE:  ADDWF  00,F
091B0:  MOVFF  00,753
091B4:  MOVLB  0
091B6:  CALL   55E6
091BA:  MOVLB  7
091BC:  BCF    FD8.1
091BE:  MOVFF  747,756
091C2:  MOVFF  746,755
091C6:  MOVFF  745,754
091CA:  MOVFF  744,753
091CE:  CLRF   x5A
091D0:  CLRF   x59
091D2:  CLRF   x58
091D4:  MOVLW  0A
091D6:  MOVWF  x57
091D8:  MOVLB  0
091DA:  CALL   642E
091DE:  MOVFF  03,747
091E2:  MOVFF  02,746
091E6:  MOVFF  01,745
091EA:  MOVFF  00,744
091EE:  MOVLB  7
091F0:  DECFSZ x42,F
091F2:  BRA    9110
091F4:  MOVLB  0
091F6:  RETURN 0
*
09DF2:  MOVF   01,W
09DF4:  MOVFF  71B,741
09DF8:  MOVLW  64
09DFA:  MOVLB  7
09DFC:  MOVWF  x42
09DFE:  MOVLB  0
09E00:  CALL   0886
09E04:  MOVFF  00,71B
09E08:  MOVF   01,W
09E0A:  MOVLW  30
09E0C:  BNZ   9E1E
09E0E:  MOVLB  7
09E10:  BTFSS  x1C.1
09E12:  BRA    9E34
09E14:  BTFSC  x1C.3
09E16:  BRA    9E34
09E18:  BTFSC  x1C.4
09E1A:  MOVLW  20
09E1C:  BRA    9E26
09E1E:  MOVLB  7
09E20:  BCF    x1C.3
09E22:  BCF    x1C.4
09E24:  BSF    x1C.0
09E26:  ADDWF  01,F
09E28:  MOVFF  01,753
09E2C:  MOVLB  0
09E2E:  CALL   55E6
09E32:  MOVLB  7
09E34:  MOVFF  71B,741
09E38:  MOVLW  0A
09E3A:  MOVWF  x42
09E3C:  MOVLB  0
09E3E:  CALL   0886
09E42:  MOVFF  00,71B
09E46:  MOVF   01,W
09E48:  MOVLW  30
09E4A:  BNZ   9E5C
09E4C:  MOVLB  7
09E4E:  BTFSC  x1C.3
09E50:  BRA    9E68
09E52:  BTFSS  x1C.0
09E54:  BRA    9E68
09E56:  BTFSC  x1C.4
09E58:  MOVLW  20
09E5A:  MOVLB  0
09E5C:  ADDWF  01,F
09E5E:  MOVFF  01,753
09E62:  CALL   55E6
09E66:  MOVLB  7
09E68:  MOVLW  30
09E6A:  ADDWF  x1B,F
09E6C:  MOVFF  71B,753
09E70:  MOVLB  0
09E72:  CALL   55E6
09E76:  RETURN 0
09E78:  MOVFF  FEA,71D
09E7C:  MOVFF  FE9,71C
09E80:  MOVLB  7
09E82:  SWAPF  x16,W
09E84:  IORLW  F0
09E86:  MOVWF  x18
09E88:  ADDWF  x18,F
09E8A:  ADDLW  E2
09E8C:  MOVWF  x19
09E8E:  ADDLW  32
09E90:  MOVWF  x1B
09E92:  MOVF   x16,W
09E94:  ANDLW  0F
09E96:  ADDWF  x19,F
09E98:  ADDWF  x19,F
09E9A:  ADDWF  x1B,F
09E9C:  ADDLW  E9
09E9E:  MOVWF  x1A
09EA0:  ADDWF  x1A,F
09EA2:  ADDWF  x1A,F
09EA4:  SWAPF  x15,W
09EA6:  ANDLW  0F
09EA8:  ADDWF  x1A,F
09EAA:  ADDWF  x1B,F
09EAC:  RLCF   x1A,F
09EAE:  RLCF   x1B,F
09EB0:  COMF   x1B,F
09EB2:  RLCF   x1B,F
09EB4:  MOVF   x15,W
09EB6:  ANDLW  0F
09EB8:  ADDWF  x1B,F
09EBA:  RLCF   x18,F
09EBC:  MOVLW  07
09EBE:  MOVWF  x17
09EC0:  MOVLW  0A
09EC2:  DECF   x1A,F
09EC4:  ADDWF  x1B,F
09EC6:  BNC   9EC2
09EC8:  DECF   x19,F
09ECA:  ADDWF  x1A,F
09ECC:  BNC   9EC8
09ECE:  DECF   x18,F
09ED0:  ADDWF  x19,F
09ED2:  BNC   9ECE
09ED4:  DECF   x17,F
09ED6:  ADDWF  x18,F
09ED8:  BNC   9ED4
09EDA:  MOVLW  07
09EDC:  MOVWF  FEA
09EDE:  MOVLW  17
09EE0:  MOVWF  FE9
09EE2:  MOVLW  07
09EE4:  ANDWF  x1C,W
09EE6:  BCF    x1C.6
09EE8:  ADDWF  FE9,F
09EEA:  MOVLW  00
09EEC:  ADDWFC FEA,F
09EEE:  MOVF   FE9,W
09EF0:  SUBLW  1B
09EF2:  BNZ   9EFC
09EF4:  MOVF   FEA,W
09EF6:  SUBLW  07
09EF8:  BNZ   9EFC
09EFA:  BSF    x1C.6
09EFC:  MOVF   FEF,W
09EFE:  MOVWF  00
09F00:  BNZ   9F12
09F02:  BTFSC  x1C.6
09F04:  BRA    9F12
09F06:  BTFSC  x1C.4
09F08:  BRA    9F36
09F0A:  BTFSC  x1C.3
09F0C:  BRA    9F12
09F0E:  MOVLW  20
09F10:  BRA    9F18
09F12:  BSF    x1C.3
09F14:  BCF    x1C.4
09F16:  MOVLW  30
09F18:  ADDWF  00,F
09F1A:  MOVFF  FEA,716
09F1E:  MOVFF  FE9,715
09F22:  MOVFF  00,753
09F26:  MOVLB  0
09F28:  CALL   55E6
09F2C:  MOVFF  716,FEA
09F30:  MOVFF  715,FE9
09F34:  MOVLB  7
09F36:  MOVF   FEE,W
09F38:  BTFSS  x1C.6
09F3A:  BRA    9EEE
09F3C:  MOVLB  0
09F3E:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
0042A:  MOVLW  07
0042C:  MOVWF  FEA
0042E:  MOVLW  09
00430:  MOVWF  FE9
00432:  MOVF   FEF,W
00434:  BZ    0452
00436:  MOVLW  14
00438:  MOVWF  01
0043A:  CLRF   00
0043C:  DECFSZ 00,F
0043E:  BRA    043C
00440:  DECFSZ 01,F
00442:  BRA    043A
00444:  MOVLW  BF
00446:  MOVWF  00
00448:  DECFSZ 00,F
0044A:  BRA    0448
0044C:  BRA    044E
0044E:  DECFSZ FEF,F
00450:  BRA    0436
00452:  RETURN 0
*
006F2:  MOVLW  01
006F4:  MOVLB  7
006F6:  SUBWF  x0F,F
006F8:  BNC   0712
006FA:  MOVLW  07
006FC:  MOVWF  FEA
006FE:  MOVLW  0F
00700:  MOVWF  FE9
00702:  MOVF   FEF,W
00704:  BZ    0712
00706:  MOVLW  04
00708:  MOVWF  00
0070A:  DECFSZ 00,F
0070C:  BRA    070A
0070E:  DECFSZ FEF,F
00710:  BRA    0706
00712:  MOVLB  0
00714:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00394:  MOVLW  CF
00396:  MOVWF  F87
00398:  CLRF   F82
....................    output_b(portB_reset);
0039A:  MOVLW  04
0039C:  MOVWF  F88
0039E:  CLRF   F83
....................    output_c(portC_reset);
003A0:  MOVLW  93
003A2:  MOVWF  F89
003A4:  CLRF   F84
....................    output_d(portD_reset);
003A6:  MOVLW  1F
003A8:  MOVWF  F8A
003AA:  CLRF   F85
....................    output_e(portE_reset);
003AC:  BCF    F8B.0
003AE:  BCF    F8B.1
003B0:  BCF    F8B.2
003B2:  BCF    F8B.3
003B4:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003B6:  MOVLB  F
003B8:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003BA:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003BC:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003BE:  SETF   x20
....................    port_e_pullups(portE_pullups);
003C0:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003C2:  MOVLW  40
003C4:  MOVWF  x0C
003C6:  CLRF   x14
003C8:  MOVLW  03
003CA:  MOVWF  x1C
003CC:  MOVLW  0F
003CE:  MOVWF  x21
003D0:  CLRF   x29
003D2:  MOVLB  0
003D4:  GOTO   A938 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05664:  MOVFF  745,FEA
05668:  MOVLB  7
0566A:  MOVFF  744,FE9
0566E:  MOVFF  FEF,748
05672:  MOVFF  747,FEA
05676:  MOVFF  746,FE9
0567A:  MOVF   FEF,W
0567C:  SUBWF  x48,W
0567E:  BNZ   56AE
....................       if (*s1 == '\0')
05680:  MOVFF  745,03
05684:  MOVFF  744,FE9
05688:  MOVFF  03,FEA
0568C:  MOVF   FEF,F
0568E:  BNZ   5696
....................          return(0);
05690:  MOVLW  00
05692:  MOVWF  01
05694:  BRA    56D8
05696:  MOVFF  745,03
0569A:  MOVF   x44,W
0569C:  INCF   x44,F
0569E:  BTFSC  FD8.2
056A0:  INCF   x45,F
056A2:  INCF   x46,F
056A4:  BTFSC  FD8.2
056A6:  INCF   x47,F
056A8:  MOVLB  0
056AA:  BRA    5664
056AC:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
056AE:  MOVFF  745,03
056B2:  MOVFF  744,FE9
056B6:  MOVFF  03,FEA
056BA:  MOVFF  FEF,748
056BE:  MOVFF  747,03
056C2:  MOVFF  746,FE9
056C6:  MOVFF  03,FEA
056CA:  MOVF   FEF,W
056CC:  SUBWF  x48,W
056CE:  BC    56D4
056D0:  MOVLW  FF
056D2:  BRA    56D6
056D4:  MOVLW  01
056D6:  MOVWF  01
056D8:  MOVLB  0
056DA:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
057D4:  MOVFF  76B,76E
....................    for(su=s;0<n;++su,--n)
057D8:  MOVFF  76A,770
057DC:  MOVFF  769,76F
057E0:  MOVLB  7
057E2:  MOVF   x6D,F
057E4:  BNZ   57EC
057E6:  MOVF   x6C,W
057E8:  SUBLW  00
057EA:  BC    5814
....................       if(*su==uc)
057EC:  MOVFF  770,FEA
057F0:  MOVFF  76F,FE9
057F4:  MOVF   x6E,W
057F6:  SUBWF  FEF,W
057F8:  BNZ   5804
....................       return su;
057FA:  MOVFF  76F,01
057FE:  MOVFF  770,02
05802:  BRA    581A
05804:  INCF   x6F,F
05806:  BTFSC  FD8.2
05808:  INCF   x70,F
0580A:  MOVF   x6C,W
0580C:  BTFSC  FD8.2
0580E:  DECF   x6D,F
05810:  DECF   x6C,F
05812:  BRA    57E2
....................    return NULL;
05814:  MOVLW  00
05816:  MOVWF  01
05818:  MOVWF  02
0581A:  MOVLB  0
0581C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
055AE:  MOVFF  745,747
055B2:  MOVFF  744,746
055B6:  MOVFF  747,FEA
055BA:  MOVLB  7
055BC:  MOVFF  746,FE9
055C0:  MOVF   FEF,F
055C2:  BZ    55D0
055C4:  INCF   x46,F
055C6:  BTFSC  FD8.2
055C8:  INCF   x47,F
055CA:  MOVLB  0
055CC:  BRA    55B6
055CE:  MOVLB  7
....................    return(sc - s);
055D0:  MOVF   x44,W
055D2:  SUBWF  x46,W
055D4:  MOVWF  00
055D6:  MOVF   x45,W
055D8:  SUBWFB x47,W
055DA:  MOVWF  03
055DC:  MOVFF  00,01
055E0:  MOVWF  02
055E2:  MOVLB  0
055E4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06BEA:  MOVLB  7
06BEC:  CLRF   x1E
06BEE:  CLRF   x1D
06BF0:  CLRF   x1C
06BF2:  MOVLW  7F
06BF4:  MOVWF  x1B
06BF6:  CLRF   x22
06BF8:  CLRF   x21
06BFA:  CLRF   x20
06BFC:  CLRF   x1F
06BFE:  BSF    x23.0
06C00:  BCF    x23.1
06C02:  BCF    x23.2
06C04:  CLRF   x25
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06C06:  MOVF   x17,W
06C08:  IORWF  x18,W
06C0A:  BNZ   6C16
....................       return 0;
06C0C:  CLRF   00
06C0E:  CLRF   01
06C10:  CLRF   02
06C12:  CLRF   03
06C14:  BRA    6E40
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06C16:  MOVF   x25,W
06C18:  INCF   x25,F
06C1A:  ADDWF  x17,W
06C1C:  MOVWF  FE9
06C1E:  MOVLW  00
06C20:  ADDWFC x18,W
06C22:  MOVWF  FEA
06C24:  MOVFF  FEF,724
06C28:  MOVF   x24,F
06C2A:  BTFSC  FD8.2
06C2C:  BRA    6DC4
....................    {
....................       if (skip && !isspace(c))
06C2E:  BTFSS  x23.0
06C30:  BRA    6C50
06C32:  MOVF   x24,W
06C34:  SUBLW  20
06C36:  BZ    6C50
....................       {
....................          skip = 0;
06C38:  BCF    x23.0
....................          if (c == '+')
06C3A:  MOVF   x24,W
06C3C:  SUBLW  2B
06C3E:  BNZ   6C46
....................          {
....................             sign = 0;
06C40:  BCF    x23.1
....................             continue;
06C42:  BRA    6DAC
....................          }            
06C44:  BRA    6C50
....................          else if (c == '-')
06C46:  MOVF   x24,W
06C48:  SUBLW  2D
06C4A:  BNZ   6C50
....................          {
....................             sign = 1;
06C4C:  BSF    x23.1
....................             continue;
06C4E:  BRA    6DAC
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06C50:  BTFSC  x23.0
06C52:  BRA    6C62
06C54:  MOVF   x24,W
06C56:  SUBLW  2E
06C58:  BNZ   6C62
06C5A:  BTFSC  x23.2
06C5C:  BRA    6C62
....................          point = 1;
06C5E:  BSF    x23.2
06C60:  BRA    6DAC
....................       else if (!skip && isdigit(c))
06C62:  BTFSC  x23.0
06C64:  BRA    6DA6
06C66:  MOVF   x24,W
06C68:  SUBLW  2F
06C6A:  BTFSC  FD8.0
06C6C:  BRA    6DA6
06C6E:  MOVF   x24,W
06C70:  SUBLW  39
06C72:  BTFSS  FD8.0
06C74:  BRA    6DA6
....................       {
....................          c -= '0';
06C76:  MOVLW  30
06C78:  SUBWF  x24,F
....................          if (point)
06C7A:  BTFSS  x23.2
06C7C:  BRA    6D2C
....................          {
....................             pow10 = pow10 * 10.0;
06C7E:  MOVFF  71E,756
06C82:  MOVFF  71D,755
06C86:  MOVFF  71C,754
06C8A:  MOVFF  71B,753
06C8E:  CLRF   x5A
06C90:  CLRF   x59
06C92:  MOVLW  20
06C94:  MOVWF  x58
06C96:  MOVLW  82
06C98:  MOVWF  x57
06C9A:  MOVLB  0
06C9C:  CALL   0D4C
06CA0:  MOVFF  03,71E
06CA4:  MOVFF  02,71D
06CA8:  MOVFF  01,71C
06CAC:  MOVFF  00,71B
....................             result += (float)c / pow10;   
06CB0:  MOVLB  7
06CB2:  CLRF   x53
06CB4:  MOVFF  724,752
06CB8:  MOVLB  0
06CBA:  CALL   0D16
06CBE:  MOVFF  03,729
06CC2:  MOVFF  02,728
06CC6:  MOVFF  01,727
06CCA:  MOVFF  00,726
06CCE:  MOVFF  03,74A
06CD2:  MOVFF  02,749
06CD6:  MOVFF  01,748
06CDA:  MOVFF  00,747
06CDE:  MOVFF  71E,74E
06CE2:  MOVFF  71D,74D
06CE6:  MOVFF  71C,74C
06CEA:  MOVFF  71B,74B
06CEE:  CALL   1D52
06CF2:  BCF    FD8.1
06CF4:  MOVFF  722,755
06CF8:  MOVFF  721,754
06CFC:  MOVFF  720,753
06D00:  MOVFF  71F,752
06D04:  MOVFF  03,759
06D08:  MOVFF  02,758
06D0C:  MOVFF  01,757
06D10:  MOVFF  00,756
06D14:  CALL   0E42
06D18:  MOVFF  03,722
06D1C:  MOVFF  02,721
06D20:  MOVFF  01,720
06D24:  MOVFF  00,71F
....................          }
06D28:  BRA    6DA2
06D2A:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06D2C:  CLRF   x56
06D2E:  CLRF   x55
06D30:  MOVLW  20
06D32:  MOVWF  x54
06D34:  MOVLW  82
06D36:  MOVWF  x53
06D38:  MOVFF  722,75A
06D3C:  MOVFF  721,759
06D40:  MOVFF  720,758
06D44:  MOVFF  71F,757
06D48:  MOVLB  0
06D4A:  CALL   0D4C
06D4E:  MOVFF  03,729
06D52:  MOVFF  02,728
06D56:  MOVFF  01,727
06D5A:  MOVFF  00,726
06D5E:  MOVLB  7
06D60:  CLRF   x53
06D62:  MOVFF  724,752
06D66:  MOVLB  0
06D68:  CALL   0D16
06D6C:  BCF    FD8.1
06D6E:  MOVFF  729,755
06D72:  MOVFF  728,754
06D76:  MOVFF  727,753
06D7A:  MOVFF  726,752
06D7E:  MOVFF  03,759
06D82:  MOVFF  02,758
06D86:  MOVFF  01,757
06D8A:  MOVFF  00,756
06D8E:  CALL   0E42
06D92:  MOVFF  03,722
06D96:  MOVFF  02,721
06D9A:  MOVFF  01,720
06D9E:  MOVFF  00,71F
....................          }
....................       }
06DA2:  BRA    6DAE
06DA4:  MOVLB  7
....................       else if (!skip)
06DA6:  BTFSC  x23.0
06DA8:  BRA    6DAC
....................          break;
06DAA:  BRA    6DC4
06DAC:  MOVLB  0
06DAE:  MOVLB  7
06DB0:  MOVF   x25,W
06DB2:  INCF   x25,F
06DB4:  ADDWF  x17,W
06DB6:  MOVWF  FE9
06DB8:  MOVLW  00
06DBA:  ADDWFC x18,W
06DBC:  MOVWF  FEA
06DBE:  MOVFF  FEF,724
06DC2:  BRA    6C28
....................    }
.................... 
....................    if (sign)
06DC4:  BTFSS  x23.1
06DC6:  BRA    6DFC
....................       result = -1*result;
06DC8:  CLRF   x56
06DCA:  CLRF   x55
06DCC:  MOVLW  80
06DCE:  MOVWF  x54
06DD0:  MOVLW  7F
06DD2:  MOVWF  x53
06DD4:  MOVFF  722,75A
06DD8:  MOVFF  721,759
06DDC:  MOVFF  720,758
06DE0:  MOVFF  71F,757
06DE4:  MOVLB  0
06DE6:  CALL   0D4C
06DEA:  MOVFF  03,722
06DEE:  MOVFF  02,721
06DF2:  MOVFF  01,720
06DF6:  MOVFF  00,71F
06DFA:  MOVLB  7
....................       
....................    if(endptr)
06DFC:  MOVF   x19,W
06DFE:  IORWF  x1A,W
06E00:  BZ    6E30
....................    {
....................       if (ptr) {
06E02:  MOVF   x25,F
06E04:  BZ    6E1E
....................          ptr--;
06E06:  DECF   x25,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06E08:  MOVFF  71A,FEA
06E0C:  MOVFF  719,FE9
06E10:  MOVF   x25,W
06E12:  ADDWF  x17,W
06E14:  MOVWF  FEF
06E16:  MOVLW  00
06E18:  ADDWFC x18,W
06E1A:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06E1C:  BRA    6E30
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
06E1E:  MOVFF  71A,FEA
06E22:  MOVFF  719,FE9
06E26:  MOVFF  718,FEC
06E2A:  MOVF   FED,F
06E2C:  MOVFF  717,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
06E30:  MOVFF  71F,00
06E34:  MOVFF  720,01
06E38:  MOVFF  721,02
06E3C:  MOVFF  722,03
06E40:  MOVLB  0
06E42:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05874:  MOVLB  7
05876:  CLRF   x42
05878:  CLRF   x41
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
0587A:  MOVLW  30
0587C:  MOVWF  x44
0587E:  MOVLW  31
05880:  MOVWF  x45
05882:  MOVLW  32
05884:  MOVWF  x46
05886:  MOVLW  33
05888:  MOVWF  x47
0588A:  MOVLW  34
0588C:  MOVWF  x48
0588E:  MOVLW  35
05890:  MOVWF  x49
05892:  MOVLW  36
05894:  MOVWF  x4A
05896:  MOVLW  37
05898:  MOVWF  x4B
0589A:  MOVLW  38
0589C:  MOVWF  x4C
0589E:  MOVLW  39
058A0:  MOVWF  x4D
058A2:  MOVLW  61
058A4:  MOVWF  x4E
058A6:  MOVLW  62
058A8:  MOVWF  x4F
058AA:  MOVLW  63
058AC:  MOVWF  x50
058AE:  MOVLW  64
058B0:  MOVWF  x51
058B2:  MOVLW  65
058B4:  MOVWF  x52
058B6:  MOVLW  66
058B8:  MOVWF  x53
058BA:  MOVLW  67
058BC:  MOVWF  x54
058BE:  MOVLW  68
058C0:  MOVWF  x55
058C2:  MOVLW  69
058C4:  MOVWF  x56
058C6:  MOVLW  6A
058C8:  MOVWF  x57
058CA:  MOVLW  6B
058CC:  MOVWF  x58
058CE:  MOVLW  6C
058D0:  MOVWF  x59
058D2:  MOVLW  6D
058D4:  MOVWF  x5A
058D6:  MOVLW  6E
058D8:  MOVWF  x5B
058DA:  MOVLW  6F
058DC:  MOVWF  x5C
058DE:  MOVLW  70
058E0:  MOVWF  x5D
058E2:  MOVLW  71
058E4:  MOVWF  x5E
058E6:  MOVLW  73
058E8:  MOVWF  x5F
058EA:  MOVLW  74
058EC:  MOVWF  x60
058EE:  MOVLW  75
058F0:  MOVWF  x61
058F2:  MOVLW  76
058F4:  MOVWF  x62
058F6:  MOVLW  77
058F8:  MOVWF  x63
058FA:  MOVLW  78
058FC:  MOVWF  x64
058FE:  MOVLW  79
05900:  MOVWF  x65
05902:  MOVLW  7A
05904:  MOVWF  x66
05906:  CLRF   x67
....................    for(sc=s;isspace(*sc);++sc);
05908:  MOVFF  737,73C
0590C:  MOVFF  736,73B
05910:  MOVFF  73C,FEA
05914:  MOVFF  73B,FE9
05918:  MOVF   FEF,W
0591A:  SUBLW  20
0591C:  BNZ   5926
0591E:  INCF   x3B,F
05920:  BTFSC  FD8.2
05922:  INCF   x3C,F
05924:  BRA    5910
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05926:  MOVFF  73C,03
0592A:  MOVFF  73B,FE9
0592E:  MOVFF  03,FEA
05932:  MOVF   FEF,W
05934:  SUBLW  2D
05936:  BZ    5946
05938:  MOVFF  73C,FEA
0593C:  MOVFF  73B,FE9
05940:  MOVF   FEF,W
05942:  SUBLW  2B
05944:  BNZ   5958
05946:  MOVFF  73C,FEA
0594A:  MOVF   x3B,W
0594C:  INCF   x3B,F
0594E:  BTFSC  FD8.2
05950:  INCF   x3C,F
05952:  MOVWF  FE9
05954:  MOVF   FEF,W
05956:  BRA    595A
05958:  MOVLW  2B
0595A:  MOVWF  x43
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
0595C:  MOVF   x43,W
0595E:  SUBLW  2D
05960:  BZ    5976
05962:  BTFSC  x3A.7
05964:  BRA    5976
05966:  DECFSZ x3A,W
05968:  BRA    596C
0596A:  BRA    5976
0596C:  BTFSC  x3A.7
0596E:  BRA    597A
05970:  MOVF   x3A,W
05972:  SUBLW  24
05974:  BC    597A
....................    goto StrtoulGO;
05976:  BRA    5B82
05978:  BRA    5A72
.................... 
....................    else if (base)
0597A:  MOVF   x3A,F
0597C:  BZ    5A0A
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
0597E:  MOVF   x3A,W
05980:  SUBLW  10
05982:  BNZ   59BE
05984:  MOVFF  73C,FEA
05988:  MOVFF  73B,FE9
0598C:  MOVF   FEF,W
0598E:  SUBLW  30
05990:  BNZ   59BE
05992:  MOVLW  01
05994:  ADDWF  x3B,W
05996:  MOVWF  FE9
05998:  MOVLW  00
0599A:  ADDWFC x3C,W
0599C:  MOVWF  FEA
0599E:  MOVF   FEF,W
059A0:  SUBLW  78
059A2:  BZ    59B6
059A4:  MOVLW  01
059A6:  ADDWF  x3B,W
059A8:  MOVWF  FE9
059AA:  MOVLW  00
059AC:  ADDWFC x3C,W
059AE:  MOVWF  FEA
059B0:  MOVF   FEF,W
059B2:  SUBLW  58
059B4:  BNZ   59BE
....................          sc+=2;
059B6:  MOVLW  02
059B8:  ADDWF  x3B,F
059BA:  MOVLW  00
059BC:  ADDWFC x3C,F
....................       if(base==8 && *sc =='0')
059BE:  MOVF   x3A,W
059C0:  SUBLW  08
059C2:  BNZ   59DA
059C4:  MOVFF  73C,FEA
059C8:  MOVFF  73B,FE9
059CC:  MOVF   FEF,W
059CE:  SUBLW  30
059D0:  BNZ   59DA
....................          sc+=1;
059D2:  MOVLW  01
059D4:  ADDWF  x3B,F
059D6:  MOVLW  00
059D8:  ADDWFC x3C,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
059DA:  MOVF   x3A,W
059DC:  SUBLW  02
059DE:  BNZ   5A08
059E0:  MOVFF  73C,FEA
059E4:  MOVFF  73B,FE9
059E8:  MOVF   FEF,W
059EA:  SUBLW  30
059EC:  BNZ   5A08
059EE:  MOVLW  01
059F0:  ADDWF  x3B,W
059F2:  MOVWF  FE9
059F4:  MOVLW  00
059F6:  ADDWFC x3C,W
059F8:  MOVWF  FEA
059FA:  MOVF   FEF,W
059FC:  SUBLW  62
059FE:  BNZ   5A08
....................          sc+=2;
05A00:  MOVLW  02
05A02:  ADDWF  x3B,F
05A04:  MOVLW  00
05A06:  ADDWFC x3C,F
.................... 
....................    }
05A08:  BRA    5A72
....................    else if(*sc!='0') // base is 0, find base
05A0A:  MOVFF  73C,FEA
05A0E:  MOVFF  73B,FE9
05A12:  MOVF   FEF,W
05A14:  SUBLW  30
05A16:  BZ    5A1E
....................       base=10;
05A18:  MOVLW  0A
05A1A:  MOVWF  x3A
05A1C:  BRA    5A72
....................    else if (sc[1]=='x' || sc[1]=='X')
05A1E:  MOVLW  01
05A20:  ADDWF  x3B,W
05A22:  MOVWF  FE9
05A24:  MOVLW  00
05A26:  ADDWFC x3C,W
05A28:  MOVWF  FEA
05A2A:  MOVF   FEF,W
05A2C:  SUBLW  78
05A2E:  BZ    5A42
05A30:  MOVLW  01
05A32:  ADDWF  x3B,W
05A34:  MOVWF  FE9
05A36:  MOVLW  00
05A38:  ADDWFC x3C,W
05A3A:  MOVWF  FEA
05A3C:  MOVF   FEF,W
05A3E:  SUBLW  58
05A40:  BNZ   5A50
....................       base =16,sc+=2;
05A42:  MOVLW  10
05A44:  MOVWF  x3A
05A46:  MOVLW  02
05A48:  ADDWF  x3B,F
05A4A:  MOVLW  00
05A4C:  ADDWFC x3C,F
05A4E:  BRA    5A72
....................    else if(sc[1]=='b')
05A50:  MOVLW  01
05A52:  ADDWF  x3B,W
05A54:  MOVWF  FE9
05A56:  MOVLW  00
05A58:  ADDWFC x3C,W
05A5A:  MOVWF  FEA
05A5C:  MOVF   FEF,W
05A5E:  SUBLW  62
05A60:  BNZ   5A6E
....................       base=2,sc+=2;
05A62:  MOVLW  02
05A64:  MOVWF  x3A
05A66:  ADDWF  x3B,F
05A68:  MOVLW  00
05A6A:  ADDWFC x3C,F
05A6C:  BRA    5A72
....................    else
....................       base=8;
05A6E:  MOVLW  08
05A70:  MOVWF  x3A
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05A72:  MOVFF  73C,73E
05A76:  MOVFF  73B,73D
05A7A:  MOVFF  73C,FEA
05A7E:  MOVFF  73B,FE9
05A82:  MOVF   FEF,W
05A84:  SUBLW  30
05A86:  BNZ   5A90
05A88:  INCF   x3B,F
05A8A:  BTFSC  FD8.2
05A8C:  INCF   x3C,F
05A8E:  BRA    5A7A
....................    sd=memchr(digits,tolower(*sc),base);
05A90:  MOVFF  73C,03
05A94:  MOVFF  73B,FE9
05A98:  MOVFF  03,FEA
05A9C:  MOVFF  FEF,768
05AA0:  MOVF   x68,W
05AA2:  SUBLW  40
05AA4:  BC    5AB2
05AA6:  MOVF   x68,W
05AA8:  SUBLW  5A
05AAA:  BNC   5AB2
05AAC:  MOVF   x68,W
05AAE:  IORLW  20
05AB0:  BRA    5AB4
05AB2:  MOVF   x68,W
05AB4:  MOVWF  x68
05AB6:  MOVLW  07
05AB8:  MOVWF  x6A
05ABA:  MOVLW  44
05ABC:  MOVWF  x69
05ABE:  MOVFF  768,76B
05AC2:  CLRF   x6D
05AC4:  MOVFF  73A,76C
05AC8:  BTFSC  x6C.7
05ACA:  DECF   x6D,F
05ACC:  MOVLB  0
05ACE:  RCALL  57D4
05AD0:  MOVFF  02,740
05AD4:  MOVFF  01,73F
....................    for(; sd!=0; )
05AD8:  MOVLB  7
05ADA:  MOVF   x3F,F
05ADC:  BNZ   5AE2
05ADE:  MOVF   x40,F
05AE0:  BZ    5B76
....................    {
....................       x=x*base+(int16)(sd-digits);
05AE2:  CLRF   03
05AE4:  MOVF   x3A,W
05AE6:  MOVWF  00
05AE8:  BTFSC  FE8.7
05AEA:  DECF   03,F
05AEC:  MOVWF  x68
05AEE:  MOVFF  03,769
05AF2:  MOVFF  742,76B
05AF6:  MOVFF  741,76A
05AFA:  MOVFF  03,76D
05AFE:  MOVWF  x6C
05B00:  MOVLB  0
05B02:  BRA    581E
05B04:  MOVFF  01,768
05B08:  MOVLW  44
05B0A:  MOVLB  7
05B0C:  SUBWF  x3F,W
05B0E:  MOVWF  00
05B10:  MOVLW  07
05B12:  SUBWFB x40,W
05B14:  MOVWF  03
05B16:  MOVF   00,W
05B18:  ADDWF  01,W
05B1A:  MOVWF  01
05B1C:  MOVF   02,W
05B1E:  ADDWFC 03,F
05B20:  MOVFF  01,741
05B24:  MOVFF  03,742
....................       ++sc;
05B28:  INCF   x3B,F
05B2A:  BTFSC  FD8.2
05B2C:  INCF   x3C,F
....................       sd=memchr(digits,tolower(*sc),base);
05B2E:  MOVFF  73C,FEA
05B32:  MOVFF  73B,FE9
05B36:  MOVFF  FEF,768
05B3A:  MOVF   x68,W
05B3C:  SUBLW  40
05B3E:  BC    5B4C
05B40:  MOVF   x68,W
05B42:  SUBLW  5A
05B44:  BNC   5B4C
05B46:  MOVF   x68,W
05B48:  IORLW  20
05B4A:  BRA    5B4E
05B4C:  MOVF   x68,W
05B4E:  MOVWF  x68
05B50:  MOVLW  07
05B52:  MOVWF  x6A
05B54:  MOVLW  44
05B56:  MOVWF  x69
05B58:  MOVFF  768,76B
05B5C:  CLRF   x6D
05B5E:  MOVFF  73A,76C
05B62:  BTFSC  x6C.7
05B64:  DECF   x6D,F
05B66:  MOVLB  0
05B68:  RCALL  57D4
05B6A:  MOVFF  02,740
05B6E:  MOVFF  01,73F
05B72:  BRA    5AD8
05B74:  MOVLB  7
....................    }
....................    if(s1==sc)
05B76:  MOVF   x3B,W
05B78:  SUBWF  x3D,W
05B7A:  BNZ   5BA4
05B7C:  MOVF   x3C,W
05B7E:  SUBWF  x3E,W
05B80:  BNZ   5BA4
....................    {
....................    StrtoulGO:
....................       if (endptr)
05B82:  MOVLB  7
05B84:  MOVF   x38,W
05B86:  IORWF  x39,W
05B88:  BZ    5B9C
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05B8A:  MOVFF  739,FEA
05B8E:  MOVFF  738,FE9
05B92:  MOVFF  737,FEC
05B96:  MOVF   FED,F
05B98:  MOVFF  736,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05B9C:  MOVLW  00
05B9E:  MOVWF  01
05BA0:  MOVWF  02
05BA2:  BRA    5BC4
....................    }
....................    if (endptr)
05BA4:  MOVF   x38,W
05BA6:  IORWF  x39,W
05BA8:  BZ    5BBC
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05BAA:  MOVFF  739,FEA
05BAE:  MOVFF  738,FE9
05BB2:  MOVFF  73C,FEC
05BB6:  MOVF   FED,F
05BB8:  MOVFF  73B,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05BBC:  MOVFF  741,01
05BC0:  MOVFF  742,02
05BC4:  MOVLB  0
05BC6:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00454:  MOVLB  7
00456:  CLRF   x08
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00458:  CLRF   x08
0045A:  MOVF   x07,W
0045C:  SUBWF  x08,W
0045E:  BC    04B6
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00460:  MOVF   x08,W
00462:  ADDWF  x05,W
00464:  MOVWF  x09
00466:  MOVLW  00
00468:  ADDWFC x06,W
0046A:  MOVWF  x0A
0046C:  MOVF   x08,W
0046E:  ADDWF  x03,W
00470:  MOVWF  01
00472:  MOVLW  00
00474:  ADDWFC x04,W
00476:  MOVWF  03
00478:  MOVF   01,W
0047A:  MOVWF  FE9
0047C:  MOVFF  03,FEA
00480:  MOVFF  FEF,70B
00484:  BSF    F7F.7
00486:  MOVF   FF2,W
00488:  MOVWF  00
0048A:  BCF    FF2.7
0048C:  MOVFF  70A,F7A
00490:  MOVFF  709,F79
00494:  MOVLW  31
00496:  MOVWF  F7B
00498:  MOVFF  70B,F7C
0049C:  MOVLB  F
0049E:  MOVLW  55
004A0:  MOVWF  F81
004A2:  MOVLW  AA
004A4:  MOVWF  F81
004A6:  BSF    F80.4
004A8:  BTFSC  F80.4
004AA:  BRA    04A8
004AC:  MOVF   00,W
004AE:  IORWF  FF2,F
004B0:  MOVLB  7
004B2:  INCF   x08,F
004B4:  BRA    045A
....................    }
004B6:  MOVLB  0
004B8:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D8:  MOVLB  7
003DA:  CLRF   x08
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003DC:  CLRF   x08
003DE:  MOVF   x07,W
003E0:  SUBWF  x08,W
003E2:  BC    0426
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003E4:  MOVF   x08,W
003E6:  ADDWF  x03,W
003E8:  MOVWF  01
003EA:  MOVLW  00
003EC:  ADDWFC x04,W
003EE:  MOVWF  03
003F0:  MOVF   01,W
003F2:  MOVWF  FE9
003F4:  MOVFF  03,FEA
003F8:  MOVF   x08,W
003FA:  ADDWF  x05,W
003FC:  MOVWF  x0B
003FE:  MOVLW  00
00400:  ADDWFC x06,W
00402:  MOVWF  x0C
00404:  BSF    F7F.7
00406:  MOVFF  FF2,70D
0040A:  BCF    FF2.7
0040C:  MOVFF  70C,F7A
00410:  MOVFF  70B,F79
00414:  MOVLW  31
00416:  MOVWF  F7B
00418:  BSF    F80.0
0041A:  MOVF   F7C,W
0041C:  BTFSC  x0D.7
0041E:  BSF    FF2.7
00420:  MOVWF  FEF
00422:  INCF   x08,F
00424:  BRA    03DE
....................    }
00426:  MOVLB  0
00428:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004BA:  MOVLB  7
004BC:  CLRF   x04
004BE:  MOVLW  20
004C0:  MOVWF  x03
004C2:  CLRF   x06
004C4:  CLRF   x05
004C6:  MOVLW  80
004C8:  MOVWF  x07
004CA:  MOVLB  0
004CC:  RCALL  0454
....................    delay_ms(1);
004CE:  MOVLW  01
004D0:  MOVLB  7
004D2:  MOVWF  x09
004D4:  MOVLB  0
004D6:  RCALL  042A
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004D8:  MOVLB  7
004DA:  CLRF   x04
004DC:  MOVLW  70
004DE:  MOVWF  x03
004E0:  CLRF   x06
004E2:  MOVLW  80
004E4:  MOVWF  x05
004E6:  MOVLW  02
004E8:  MOVWF  x07
004EA:  MOVLB  0
004EC:  RCALL  0454
....................    delay_ms(1);
004EE:  MOVLW  01
004F0:  MOVLB  7
004F2:  MOVWF  x09
004F4:  MOVLB  0
004F6:  RCALL  042A
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004F8:  MOVLB  7
004FA:  CLRF   x04
004FC:  MOVLW  71
004FE:  MOVWF  x03
00500:  CLRF   x06
00502:  MOVLW  90
00504:  MOVWF  x05
00506:  MOVLW  02
00508:  MOVWF  x07
0050A:  MOVLB  0
0050C:  RCALL  0454
....................    delay_ms(1);
0050E:  MOVLW  01
00510:  MOVLB  7
00512:  MOVWF  x09
00514:  MOVLB  0
00516:  RCALL  042A
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00518:  MOVLB  7
0051A:  CLRF   x04
0051C:  MOVLW  72
0051E:  MOVWF  x03
00520:  CLRF   x06
00522:  MOVLW  A0
00524:  MOVWF  x05
00526:  MOVLW  20
00528:  MOVWF  x07
0052A:  MOVLB  0
0052C:  RCALL  0454
....................    delay_ms(1);
0052E:  MOVLW  01
00530:  MOVLB  7
00532:  MOVWF  x09
00534:  MOVLB  0
00536:  RCALL  042A
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00538:  MOVLB  7
0053A:  CLRF   x04
0053C:  MOVLW  92
0053E:  MOVWF  x03
00540:  CLRF   x06
00542:  MOVLW  C0
00544:  MOVWF  x05
00546:  MOVLW  30
00548:  MOVWF  x07
0054A:  MOVLB  0
0054C:  RCALL  0454
....................    delay_ms(1);
0054E:  MOVLW  01
00550:  MOVLB  7
00552:  MOVWF  x09
00554:  MOVLB  0
00556:  RCALL  042A
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00558:  MOVLB  7
0055A:  CLRF   x04
0055C:  MOVLW  C2
0055E:  MOVWF  x03
00560:  CLRF   x06
00562:  MOVLW  F0
00564:  MOVWF  x05
00566:  MOVLW  38
00568:  MOVWF  x07
0056A:  MOVLB  0
0056C:  RCALL  0454
....................    delay_ms(1);
0056E:  MOVLW  01
00570:  MOVLB  7
00572:  MOVWF  x09
00574:  MOVLB  0
00576:  RCALL  042A
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00578:  MOVLB  7
0057A:  CLRF   x04
0057C:  MOVLW  FA
0057E:  MOVWF  x03
00580:  MOVLW  01
00582:  MOVWF  x06
00584:  MOVLW  40
00586:  MOVWF  x05
00588:  MOVLW  01
0058A:  MOVWF  x07
0058C:  MOVLB  0
0058E:  RCALL  0454
....................    delay_ms(1);
00590:  MOVLW  01
00592:  MOVLB  7
00594:  MOVWF  x09
00596:  MOVLB  0
00598:  RCALL  042A
0059A:  GOTO   066A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
0059E:  MOVLB  7
005A0:  CLRF   x04
005A2:  MOVLW  20
005A4:  MOVWF  x03
005A6:  CLRF   x06
005A8:  CLRF   x05
005AA:  MOVLW  80
005AC:  MOVWF  x07
005AE:  MOVLB  0
005B0:  RCALL  03D8
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005B2:  MOVLB  7
005B4:  CLRF   x04
005B6:  MOVLW  70
005B8:  MOVWF  x03
005BA:  CLRF   x06
005BC:  MOVLW  80
005BE:  MOVWF  x05
005C0:  MOVLW  02
005C2:  MOVWF  x07
005C4:  MOVLB  0
005C6:  RCALL  03D8
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005C8:  MOVLB  7
005CA:  CLRF   x04
005CC:  MOVLW  71
005CE:  MOVWF  x03
005D0:  CLRF   x06
005D2:  MOVLW  90
005D4:  MOVWF  x05
005D6:  MOVLW  02
005D8:  MOVWF  x07
005DA:  MOVLB  0
005DC:  RCALL  03D8
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005DE:  MOVLB  7
005E0:  CLRF   x04
005E2:  MOVLW  72
005E4:  MOVWF  x03
005E6:  CLRF   x06
005E8:  MOVLW  A0
005EA:  MOVWF  x05
005EC:  MOVLW  20
005EE:  MOVWF  x07
005F0:  MOVLB  0
005F2:  RCALL  03D8
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005F4:  MOVLB  7
005F6:  CLRF   x04
005F8:  MOVLW  92
005FA:  MOVWF  x03
005FC:  CLRF   x06
005FE:  MOVLW  C0
00600:  MOVWF  x05
00602:  MOVLW  30
00604:  MOVWF  x07
00606:  MOVLB  0
00608:  RCALL  03D8
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0060A:  MOVLB  7
0060C:  CLRF   x04
0060E:  MOVLW  C2
00610:  MOVWF  x03
00612:  CLRF   x06
00614:  MOVLW  F0
00616:  MOVWF  x05
00618:  MOVLW  38
0061A:  MOVWF  x07
0061C:  MOVLB  0
0061E:  RCALL  03D8
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00620:  MOVLB  7
00622:  CLRF   x04
00624:  MOVLW  FA
00626:  MOVWF  x03
00628:  MOVLW  01
0062A:  MOVWF  x06
0062C:  MOVLW  40
0062E:  MOVWF  x05
00630:  MOVLW  01
00632:  MOVWF  x07
00634:  MOVLB  0
00636:  RCALL  03D8
00638:  GOTO   066E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0063C:  MOVLB  7
0063E:  CLRF   x04
00640:  MOVLW  FA
00642:  MOVWF  x03
00644:  MOVLW  01
00646:  MOVWF  x06
00648:  MOVLW  40
0064A:  MOVWF  x05
0064C:  MOVLW  01
0064E:  MOVWF  x07
00650:  MOVLB  0
00652:  RCALL  03D8
....................    delay_ms(1);
00654:  MOVLW  01
00656:  MOVLB  7
00658:  MOVWF  x09
0065A:  MOVLB  0
0065C:  RCALL  042A
....................    if (paramsValid != isValid)
0065E:  MOVF   xFA,W
00660:  SUBLW  AA
00662:  BZ    066C
....................    {
....................       paramsValid = isValid;
00664:  MOVLW  AA
00666:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
00668:  BRA    04BA
....................    }
0066A:  BRA    066E
....................    else
....................    {
....................       params_load_from_ee();
0066C:  BRA    059E
....................    }
0066E:  GOTO   A93C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  04
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00672:  RCALL  0138
....................    switch(ch)
00674:  MOVLB  7
00676:  MOVF   x14,W
00678:  ADDLW  FC
0067A:  BC    06AE
0067C:  ADDLW  04
0067E:  MOVLB  0
00680:  GOTO   06BA
....................    {
....................       case 0:
....................          output_low(_CS0);
00684:  MOVLW  1F
00686:  MOVWF  F8A
00688:  BCF    F85.5
....................       break; 
0068A:  MOVLB  7
0068C:  BRA    06AE
....................       case 1:
....................          output_low(_CS1);
0068E:  MOVLW  1F
00690:  MOVWF  F8A
00692:  BCF    F85.6
....................       break;   
00694:  MOVLB  7
00696:  BRA    06AE
....................       case 2:
....................          output_low(_CS2);
00698:  MOVLW  1F
0069A:  MOVWF  F8A
0069C:  BCF    F85.7
....................       break;
0069E:  MOVLB  7
006A0:  BRA    06AE
....................       case 3:
....................          output_low(_CS3);
006A2:  MOVLW  04
006A4:  MOVWF  F88
006A6:  BCF    F83.0
....................       break;              
006A8:  MOVLB  7
006AA:  BRA    06AE
006AC:  MOVLB  7
....................    }
....................    delay_us(10);
006AE:  MOVLW  35
006B0:  MOVWF  00
006B2:  DECFSZ 00,F
006B4:  BRA    06B2
006B6:  MOVLB  0
006B8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  7
0015A:  MOVF   x75,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  04
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007A6:  MOVLW  1F
007A8:  MOVWF  F8A
007AA:  BCF    F85.5
....................    output_low(_CS1);
007AC:  MOVWF  F8A
007AE:  BCF    F85.6
....................    output_low(_CS2);
007B0:  MOVWF  F8A
007B2:  BCF    F85.7
....................    output_low(_CS3);
007B4:  MOVLW  04
007B6:  MOVWF  F88
007B8:  BCF    F83.0
....................    delay_us(10);
007BA:  MOVLW  35
007BC:  MOVWF  00
007BE:  DECFSZ 00,F
007C0:  BRA    07BE
007C2:  GOTO   07C8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006DC:  MOVFF  712,714
006E0:  RCALL  0672
....................    spi_write2(command);
006E2:  MOVLB  E
006E4:  MOVF   x8D,W
006E6:  MOVFF  713,E8D
006EA:  RRCF   x90,W
006EC:  BNC   06EA
006EE:  MOVLB  0
006F0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  773,775
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  774,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007C6:  BRA    07A6
....................    spi_write2(command);
007C8:  MOVLB  E
007CA:  MOVF   x8D,W
007CC:  MOVFF  709,E8D
007D0:  RRCF   x90,W
007D2:  BNC   07D0
007D4:  MOVLB  0
007D6:  GOTO   07E4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
007F2:  MOVFF  711,714
007F6:  RCALL  0672
....................    spi_read2(command);
007F8:  MOVLB  E
007FA:  MOVF   x8D,W
007FC:  MOVFF  712,E8D
00800:  RRCF   x90,W
00802:  BNC   0800
00804:  MOVLB  0
00806:  GOTO   0818 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00716:  MOVLB  7
00718:  MOVF   x0F,W
0071A:  IORLW  40
0071C:  MOVWF  x11
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0071E:  MOVFF  70E,712
00722:  MOVFF  711,713
00726:  MOVLB  0
00728:  RCALL  06DC
....................    spi_write2(data);
0072A:  MOVLB  E
0072C:  MOVF   x8D,W
0072E:  MOVFF  710,E8D
00732:  RRCF   x90,W
00734:  BNC   0732
....................    ads_deselect_all();
00736:  MOVLB  0
00738:  RCALL  0138
0073A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  772,773
001A8:  MOVLW  08
001AA:  MOVLB  7
001AC:  MOVWF  x74
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007DA:  MOVLW  08
007DC:  MOVLB  7
007DE:  MOVWF  x09
007E0:  MOVLB  0
007E2:  BRA    07C6
....................    delay_us(10);
007E4:  MOVLW  35
007E6:  MOVWF  00
007E8:  DECFSZ 00,F
007EA:  BRA    07E8
....................    ads_deselect_all();
007EC:  RCALL  0138
007EE:  GOTO   0974 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0080A:  MOVFF  70C,711
0080E:  MOVLW  10
00810:  MOVLB  7
00812:  MOVWF  x12
00814:  MOVLB  0
00816:  BRA    07F2
....................    data.dBytes[3] = 0;
00818:  MOVLB  7
0081A:  CLRF   x10
....................    data.dBytes[2] = spi_read2(0);
0081C:  MOVLB  E
0081E:  MOVF   x8D,W
00820:  CLRF   x8D
00822:  RRCF   x90,W
00824:  BNC   0822
00826:  MOVFF  E8D,70F
....................    data.dBytes[1] = spi_read2(0);
0082A:  MOVF   x8D,W
0082C:  CLRF   x8D
0082E:  RRCF   x90,W
00830:  BNC   082E
00832:  MOVFF  E8D,70E
....................    data.dBytes[0] = spi_read2(0);
00836:  MOVF   x8D,W
00838:  CLRF   x8D
0083A:  RRCF   x90,W
0083C:  BNC   083A
0083E:  MOVFF  E8D,70D
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00842:  MOVLB  7
00844:  MOVF   x0F,W
00846:  ANDLW  80
00848:  BZ    084E
0084A:  MOVLW  FF
0084C:  IORWF  x10,F
....................    
....................    ads_deselect_all();
0084E:  MOVLB  0
00850:  RCALL  0138
....................    return data.dWord;
00852:  MOVFF  70D,00
00856:  MOVFF  70E,01
0085A:  MOVFF  70F,02
0085E:  MOVFF  710,03
00862:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0073C:  MOVFF  709,712
00740:  MOVLW  06
00742:  MOVLB  7
00744:  MOVWF  x13
00746:  MOVLB  0
00748:  RCALL  06DC
....................    delay_us(300);                    
0074A:  MOVLW  02
0074C:  MOVLB  7
0074E:  MOVWF  x0E
00750:  MOVLW  96
00752:  MOVWF  x0F
00754:  MOVLB  0
00756:  RCALL  06F2
00758:  MOVLB  7
0075A:  DECFSZ x0E,F
0075C:  BRA    0750
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0075E:  MOVFF  709,70E
00762:  CLRF   x0F
00764:  MOVFF  70A,710
00768:  MOVLB  0
0076A:  RCALL  0716
....................    ads_write_reg(ch, reg1, rc1);
0076C:  MOVFF  709,70E
00770:  MOVLW  04
00772:  MOVLB  7
00774:  MOVWF  x0F
00776:  MOVFF  70B,710
0077A:  MOVLB  0
0077C:  RCALL  0716
....................    ads_write_reg(ch, reg2, rc2);
0077E:  MOVFF  709,70E
00782:  MOVLW  08
00784:  MOVLB  7
00786:  MOVWF  x0F
00788:  MOVFF  70C,710
0078C:  MOVLB  0
0078E:  RCALL  0716
....................    ads_write_reg(ch, reg3, rc3);  
00790:  MOVFF  709,70E
00794:  MOVLW  0C
00796:  MOVLB  7
00798:  MOVWF  x0F
0079A:  MOVFF  70D,710
0079E:  MOVLB  0
007A0:  RCALL  0716
007A2:  GOTO   094E (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02708:  MOVLB  7
0270A:  BCF    x4D.0
....................    y = x;
0270C:  MOVFF  741,746
02710:  MOVFF  740,745
02714:  MOVFF  73F,744
02718:  MOVFF  73E,743
.................... 
....................    if (x < 0)
0271C:  MOVFF  741,751
02720:  MOVFF  740,750
02724:  MOVFF  73F,74F
02728:  MOVFF  73E,74E
0272C:  CLRF   x55
0272E:  CLRF   x54
02730:  CLRF   x53
02732:  CLRF   x52
02734:  MOVLB  0
02736:  CALL   1CD8
0273A:  BNC   2748
....................    {
....................       s = 1;
0273C:  MOVLB  7
0273E:  BSF    x4D.0
....................       y = -y;
02740:  MOVF   x44,W
02742:  XORLW  80
02744:  MOVWF  x44
02746:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02748:  MOVFF  746,751
0274C:  MOVFF  745,750
02750:  MOVFF  744,74F
02754:  MOVFF  743,74E
02758:  MOVLB  7
0275A:  CLRF   x55
0275C:  CLRF   x54
0275E:  CLRF   x53
02760:  MOVLW  8E
02762:  MOVWF  x52
02764:  MOVLB  0
02766:  CALL   1CD8
0276A:  BC    276E
0276C:  BNZ   279E
....................       res = (float32)(unsigned int16)y;
0276E:  MOVFF  746,751
02772:  MOVFF  745,750
02776:  MOVFF  744,74F
0277A:  MOVFF  743,74E
0277E:  RCALL  26CC
02780:  MOVFF  02,753
02784:  MOVFF  01,752
02788:  CALL   0D16
0278C:  MOVFF  03,74A
02790:  MOVFF  02,749
02794:  MOVFF  01,748
02798:  MOVFF  00,747
0279C:  BRA    2940
.................... 
....................  else if (y < 10000000.0)
0279E:  MOVFF  746,751
027A2:  MOVFF  745,750
027A6:  MOVFF  744,74F
027AA:  MOVFF  743,74E
027AE:  MOVLW  80
027B0:  MOVLB  7
027B2:  MOVWF  x55
027B4:  MOVLW  96
027B6:  MOVWF  x54
027B8:  MOVLW  18
027BA:  MOVWF  x53
027BC:  MOVLW  96
027BE:  MOVWF  x52
027C0:  MOVLB  0
027C2:  CALL   1CD8
027C6:  BTFSS  FD8.0
027C8:  BRA    2930
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
027CA:  MOVFF  746,756
027CE:  MOVFF  745,755
027D2:  MOVFF  744,754
027D6:  MOVFF  743,753
027DA:  MOVLB  7
027DC:  CLRF   x5A
027DE:  CLRF   x59
027E0:  CLRF   x58
027E2:  MOVLW  70
027E4:  MOVWF  x57
027E6:  MOVLB  0
027E8:  CALL   0D4C
027EC:  MOVFF  03,751
027F0:  MOVFF  02,750
027F4:  MOVFF  01,74F
027F8:  MOVFF  00,74E
027FC:  RCALL  26CC
027FE:  MOVFF  02,74C
02802:  MOVFF  01,74B
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02806:  MOVFF  746,756
0280A:  MOVFF  745,755
0280E:  MOVFF  744,754
02812:  MOVFF  743,753
02816:  MOVLB  7
02818:  CLRF   x5A
0281A:  CLRF   x59
0281C:  CLRF   x58
0281E:  MOVLW  70
02820:  MOVWF  x57
02822:  MOVLB  0
02824:  CALL   0D4C
02828:  MOVFF  03,751
0282C:  MOVFF  02,750
02830:  MOVFF  01,74F
02834:  MOVFF  00,74E
02838:  MOVFF  74C,753
0283C:  MOVFF  74B,752
02840:  CALL   0D16
02844:  BSF    FD8.1
02846:  MOVFF  751,755
0284A:  MOVFF  750,754
0284E:  MOVFF  74F,753
02852:  MOVFF  74E,752
02856:  MOVFF  03,759
0285A:  MOVFF  02,758
0285E:  MOVFF  01,757
02862:  MOVFF  00,756
02866:  CALL   0E42
0286A:  MOVLB  7
0286C:  CLRF   x56
0286E:  CLRF   x55
02870:  CLRF   x54
02872:  MOVLW  8E
02874:  MOVWF  x53
02876:  MOVFF  03,75A
0287A:  MOVFF  02,759
0287E:  MOVFF  01,758
02882:  MOVFF  00,757
02886:  MOVLB  0
02888:  CALL   0D4C
0288C:  MOVFF  03,746
02890:  MOVFF  02,745
02894:  MOVFF  01,744
02898:  MOVFF  00,743
....................       res = 32768.0*(float32)l;
0289C:  MOVFF  74C,753
028A0:  MOVFF  74B,752
028A4:  CALL   0D16
028A8:  MOVLB  7
028AA:  CLRF   x56
028AC:  CLRF   x55
028AE:  CLRF   x54
028B0:  MOVLW  8E
028B2:  MOVWF  x53
028B4:  MOVFF  03,75A
028B8:  MOVFF  02,759
028BC:  MOVFF  01,758
028C0:  MOVFF  00,757
028C4:  MOVLB  0
028C6:  CALL   0D4C
028CA:  MOVFF  03,74A
028CE:  MOVFF  02,749
028D2:  MOVFF  01,748
028D6:  MOVFF  00,747
....................       res += (float32)(unsigned int16)y;
028DA:  MOVFF  746,751
028DE:  MOVFF  745,750
028E2:  MOVFF  744,74F
028E6:  MOVFF  743,74E
028EA:  RCALL  26CC
028EC:  MOVFF  02,753
028F0:  MOVFF  01,752
028F4:  CALL   0D16
028F8:  BCF    FD8.1
028FA:  MOVFF  74A,755
028FE:  MOVFF  749,754
02902:  MOVFF  748,753
02906:  MOVFF  747,752
0290A:  MOVFF  03,759
0290E:  MOVFF  02,758
02912:  MOVFF  01,757
02916:  MOVFF  00,756
0291A:  CALL   0E42
0291E:  MOVFF  03,74A
02922:  MOVFF  02,749
02926:  MOVFF  01,748
0292A:  MOVFF  00,747
....................    }
0292E:  BRA    2940
.................... 
....................  else
....................   res = y;
02930:  MOVFF  746,74A
02934:  MOVFF  745,749
02938:  MOVFF  744,748
0293C:  MOVFF  743,747
.................... 
....................  y = y - (float32)(unsigned int16)y;
02940:  MOVFF  746,751
02944:  MOVFF  745,750
02948:  MOVFF  744,74F
0294C:  MOVFF  743,74E
02950:  RCALL  26CC
02952:  MOVFF  02,753
02956:  MOVFF  01,752
0295A:  CALL   0D16
0295E:  BSF    FD8.1
02960:  MOVFF  746,755
02964:  MOVFF  745,754
02968:  MOVFF  744,753
0296C:  MOVFF  743,752
02970:  MOVFF  03,759
02974:  MOVFF  02,758
02978:  MOVFF  01,757
0297C:  MOVFF  00,756
02980:  CALL   0E42
02984:  MOVFF  03,746
02988:  MOVFF  02,745
0298C:  MOVFF  01,744
02990:  MOVFF  00,743
.................... 
....................  if (s)
02994:  MOVLB  7
02996:  BTFSS  x4D.0
02998:  BRA    29A0
....................   res = -res;
0299A:  MOVF   x48,W
0299C:  XORLW  80
0299E:  MOVWF  x48
.................... 
....................  if (y != 0)
029A0:  MOVFF  746,751
029A4:  MOVFF  745,750
029A8:  MOVFF  744,74F
029AC:  MOVFF  743,74E
029B0:  CLRF   x55
029B2:  CLRF   x54
029B4:  CLRF   x53
029B6:  CLRF   x52
029B8:  MOVLB  0
029BA:  CALL   1CD8
029BE:  BZ    2A38
....................  {
....................   if (s == 1 && n == 0)
029C0:  MOVLB  7
029C2:  BTFSS  x4D.0
029C4:  BRA    29FE
029C6:  MOVF   x42,F
029C8:  BNZ   29FE
....................    res -= 1.0;
029CA:  BSF    FD8.1
029CC:  MOVFF  74A,755
029D0:  MOVFF  749,754
029D4:  MOVFF  748,753
029D8:  MOVFF  747,752
029DC:  CLRF   x59
029DE:  CLRF   x58
029E0:  CLRF   x57
029E2:  MOVLW  7F
029E4:  MOVWF  x56
029E6:  MOVLB  0
029E8:  CALL   0E42
029EC:  MOVFF  03,74A
029F0:  MOVFF  02,749
029F4:  MOVFF  01,748
029F8:  MOVFF  00,747
029FC:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
029FE:  BTFSC  x4D.0
02A00:  BRA    2A3A
02A02:  DECFSZ x42,W
02A04:  BRA    2A3A
....................    res += 1.0;
02A06:  BCF    FD8.1
02A08:  MOVFF  74A,755
02A0C:  MOVFF  749,754
02A10:  MOVFF  748,753
02A14:  MOVFF  747,752
02A18:  CLRF   x59
02A1A:  CLRF   x58
02A1C:  CLRF   x57
02A1E:  MOVLW  7F
02A20:  MOVWF  x56
02A22:  MOVLB  0
02A24:  CALL   0E42
02A28:  MOVFF  03,74A
02A2C:  MOVFF  02,749
02A30:  MOVFF  01,748
02A34:  MOVFF  00,747
02A38:  MOVLB  7
....................  }
....................  if (x == 0)
02A3A:  MOVFF  741,751
02A3E:  MOVFF  740,750
02A42:  MOVFF  73F,74F
02A46:  MOVFF  73E,74E
02A4A:  CLRF   x55
02A4C:  CLRF   x54
02A4E:  CLRF   x53
02A50:  CLRF   x52
02A52:  MOVLB  0
02A54:  CALL   1CD8
02A58:  BNZ   2A66
....................     res = 0;
02A5A:  MOVLB  7
02A5C:  CLRF   x4A
02A5E:  CLRF   x49
02A60:  CLRF   x48
02A62:  CLRF   x47
02A64:  MOVLB  0
.................... 
....................  return (res);
02A66:  MOVFF  747,00
02A6A:  MOVFF  748,01
02A6E:  MOVFF  749,02
02A72:  MOVFF  74A,03
02A76:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02A96:  MOVFF  73D,741
02A9A:  MOVFF  73C,740
02A9E:  MOVFF  73B,73F
02AA2:  MOVFF  73A,73E
02AA6:  MOVLB  7
02AA8:  CLRF   x42
02AAA:  MOVLB  0
02AAC:  RCALL  2708
02AAE:  GOTO   2BBA (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02A78:  MOVFF  73D,741
02A7C:  MOVFF  73C,740
02A80:  MOVFF  73B,73F
02A84:  MOVFF  73A,73E
02A88:  MOVLW  01
02A8A:  MOVLB  7
02A8C:  MOVWF  x42
02A8E:  MOVLB  0
02A90:  RCALL  2708
02A92:  GOTO   2B72 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AB2:  MOVFF  731,751
02AB6:  MOVFF  730,750
02ABA:  MOVFF  72F,74F
02ABE:  MOVFF  72E,74E
02AC2:  MOVLB  7
02AC4:  CLRF   x55
02AC6:  CLRF   x54
02AC8:  CLRF   x53
02ACA:  CLRF   x52
02ACC:  MOVLB  0
02ACE:  CALL   1CD8
02AD2:  BTFSC  FD8.2
02AD4:  BRA    2C16
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02AD6:  MOVFF  72D,74A
02ADA:  MOVFF  72C,749
02ADE:  MOVFF  72B,748
02AE2:  MOVFF  72A,747
02AE6:  MOVFF  731,74E
02AEA:  MOVFF  730,74D
02AEE:  MOVFF  72F,74C
02AF2:  MOVFF  72E,74B
02AF6:  CALL   1D52
02AFA:  MOVFF  03,739
02AFE:  MOVFF  02,738
02B02:  MOVFF  01,737
02B06:  MOVFF  00,736
02B0A:  MOVFF  03,751
02B0E:  MOVFF  02,750
02B12:  MOVFF  01,74F
02B16:  MOVFF  00,74E
02B1A:  MOVLB  7
02B1C:  CLRF   x55
02B1E:  CLRF   x54
02B20:  CLRF   x53
02B22:  CLRF   x52
02B24:  MOVLB  0
02B26:  CALL   1CD8
02B2A:  BNC   2B74
02B2C:  MOVFF  72D,74A
02B30:  MOVFF  72C,749
02B34:  MOVFF  72B,748
02B38:  MOVFF  72A,747
02B3C:  MOVFF  731,74E
02B40:  MOVFF  730,74D
02B44:  MOVFF  72F,74C
02B48:  MOVFF  72E,74B
02B4C:  CALL   1D52
02B50:  MOVFF  03,739
02B54:  MOVFF  02,738
02B58:  MOVFF  01,737
02B5C:  MOVFF  00,736
02B60:  MOVFF  03,73D
02B64:  MOVFF  02,73C
02B68:  MOVFF  01,73B
02B6C:  MOVFF  00,73A
02B70:  BRA    2A78
02B72:  BRA    2BBA
02B74:  MOVFF  72D,74A
02B78:  MOVFF  72C,749
02B7C:  MOVFF  72B,748
02B80:  MOVFF  72A,747
02B84:  MOVFF  731,74E
02B88:  MOVFF  730,74D
02B8C:  MOVFF  72F,74C
02B90:  MOVFF  72E,74B
02B94:  CALL   1D52
02B98:  MOVFF  03,739
02B9C:  MOVFF  02,738
02BA0:  MOVFF  01,737
02BA4:  MOVFF  00,736
02BA8:  MOVFF  03,73D
02BAC:  MOVFF  02,73C
02BB0:  MOVFF  01,73B
02BB4:  MOVFF  00,73A
02BB8:  BRA    2A96
02BBA:  MOVFF  03,735
02BBE:  MOVFF  02,734
02BC2:  MOVFF  01,733
02BC6:  MOVFF  00,732
....................       return(x-(i*y));
02BCA:  MOVFF  735,756
02BCE:  MOVFF  734,755
02BD2:  MOVFF  733,754
02BD6:  MOVFF  732,753
02BDA:  MOVFF  731,75A
02BDE:  MOVFF  730,759
02BE2:  MOVFF  72F,758
02BE6:  MOVFF  72E,757
02BEA:  CALL   0D4C
02BEE:  BSF    FD8.1
02BF0:  MOVFF  72D,755
02BF4:  MOVFF  72C,754
02BF8:  MOVFF  72B,753
02BFC:  MOVFF  72A,752
02C00:  MOVFF  03,759
02C04:  MOVFF  02,758
02C08:  MOVFF  01,757
02C0C:  MOVFF  00,756
02C10:  CALL   0E42
02C14:  BRA    2C16
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C16:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FAC:  MOVFF  731,756
02FB0:  MOVFF  730,755
02FB4:  MOVFF  72F,754
02FB8:  MOVFF  72E,753
02FBC:  MOVLW  3B
02FBE:  MOVLB  7
02FC0:  MOVWF  x5A
02FC2:  MOVLW  AA
02FC4:  MOVWF  x59
02FC6:  MOVLW  38
02FC8:  MOVWF  x58
02FCA:  MOVLW  7F
02FCC:  MOVWF  x57
02FCE:  MOVLB  0
02FD0:  CALL   0D4C
02FD4:  MOVFF  03,751
02FD8:  MOVFF  02,750
02FDC:  MOVFF  01,74F
02FE0:  MOVFF  00,74E
02FE4:  CALL   26CC
02FE8:  MOVFF  01,73E
....................    s = 0;
02FEC:  MOVLB  7
02FEE:  BCF    x3F.0
....................    y = x;
02FF0:  MOVFF  731,735
02FF4:  MOVFF  730,734
02FF8:  MOVFF  72F,733
02FFC:  MOVFF  72E,732
.................... 
....................    if (x < 0)
03000:  MOVFF  731,751
03004:  MOVFF  730,750
03008:  MOVFF  72F,74F
0300C:  MOVFF  72E,74E
03010:  CLRF   x55
03012:  CLRF   x54
03014:  CLRF   x53
03016:  CLRF   x52
03018:  MOVLB  0
0301A:  CALL   1CD8
0301E:  BNC   302E
....................    {
....................       s = 1;
03020:  MOVLB  7
03022:  BSF    x3F.0
....................       n = -n;
03024:  NEGF   x3E
....................       y = -y;
03026:  MOVF   x33,W
03028:  XORLW  80
0302A:  MOVWF  x33
0302C:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0302E:  MOVLB  7
03030:  CLRF   x39
03032:  CLRF   x38
03034:  CLRF   x37
03036:  CLRF   x36
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03038:  MOVLW  07
0303A:  MOVWF  x41
0303C:  MOVLW  36
0303E:  MOVFF  741,FEA
03042:  MOVWF  FE9
03044:  MOVLW  7F
03046:  ADDWF  x3E,W
03048:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0304A:  MOVFF  735,756
0304E:  MOVFF  734,755
03052:  MOVFF  733,754
03056:  MOVFF  732,753
0305A:  MOVLW  3B
0305C:  MOVWF  x5A
0305E:  MOVLW  AA
03060:  MOVWF  x59
03062:  MOVLW  38
03064:  MOVWF  x58
03066:  MOVLW  7F
03068:  MOVWF  x57
0306A:  MOVLB  0
0306C:  CALL   0D4C
03070:  MOVFF  03,743
03074:  MOVFF  02,742
03078:  MOVFF  01,741
0307C:  MOVFF  00,740
03080:  MOVLB  7
03082:  CLRF   x45
03084:  MOVFF  73E,744
03088:  BTFSC  x44.7
0308A:  DECF   x45,F
0308C:  MOVLB  0
0308E:  CALL   267C
03092:  BSF    FD8.1
03094:  MOVFF  743,755
03098:  MOVFF  742,754
0309C:  MOVFF  741,753
030A0:  MOVFF  740,752
030A4:  MOVFF  03,759
030A8:  MOVFF  02,758
030AC:  MOVFF  01,757
030B0:  MOVFF  00,756
030B4:  CALL   0E42
030B8:  MOVFF  03,735
030BC:  MOVFF  02,734
030C0:  MOVFF  01,733
030C4:  MOVFF  00,732
.................... 
....................    r = pe[0]*y + pe[1];
030C8:  MOVLW  7C
030CA:  MOVLB  7
030CC:  MOVWF  x56
030CE:  MOVLW  88
030D0:  MOVWF  x55
030D2:  MOVLW  59
030D4:  MOVWF  x54
030D6:  MOVLW  72
030D8:  MOVWF  x53
030DA:  MOVFF  735,75A
030DE:  MOVFF  734,759
030E2:  MOVFF  733,758
030E6:  MOVFF  732,757
030EA:  MOVLB  0
030EC:  CALL   0D4C
030F0:  MOVFF  03,743
030F4:  MOVFF  02,742
030F8:  MOVFF  01,741
030FC:  MOVFF  00,740
03100:  BCF    FD8.1
03102:  MOVFF  03,755
03106:  MOVFF  02,754
0310A:  MOVFF  01,753
0310E:  MOVFF  00,752
03112:  MOVLW  E0
03114:  MOVLB  7
03116:  MOVWF  x59
03118:  MOVLW  97
0311A:  MOVWF  x58
0311C:  MOVLW  26
0311E:  MOVWF  x57
03120:  MOVLW  75
03122:  MOVWF  x56
03124:  MOVLB  0
03126:  CALL   0E42
0312A:  MOVFF  03,73D
0312E:  MOVFF  02,73C
03132:  MOVFF  01,73B
03136:  MOVFF  00,73A
....................    r = r*y + pe[2];
0313A:  MOVFF  73D,756
0313E:  MOVFF  73C,755
03142:  MOVFF  73B,754
03146:  MOVFF  73A,753
0314A:  MOVFF  735,75A
0314E:  MOVFF  734,759
03152:  MOVFF  733,758
03156:  MOVFF  732,757
0315A:  CALL   0D4C
0315E:  MOVFF  03,743
03162:  MOVFF  02,742
03166:  MOVFF  01,741
0316A:  MOVFF  00,740
0316E:  BCF    FD8.1
03170:  MOVFF  03,755
03174:  MOVFF  02,754
03178:  MOVFF  01,753
0317C:  MOVFF  00,752
03180:  MOVLW  C4
03182:  MOVLB  7
03184:  MOVWF  x59
03186:  MOVLW  1D
03188:  MOVWF  x58
0318A:  MOVLW  1E
0318C:  MOVWF  x57
0318E:  MOVLW  78
03190:  MOVWF  x56
03192:  MOVLB  0
03194:  CALL   0E42
03198:  MOVFF  03,73D
0319C:  MOVFF  02,73C
031A0:  MOVFF  01,73B
031A4:  MOVFF  00,73A
....................    r = r*y + pe[3];
031A8:  MOVFF  73D,756
031AC:  MOVFF  73C,755
031B0:  MOVFF  73B,754
031B4:  MOVFF  73A,753
031B8:  MOVFF  735,75A
031BC:  MOVFF  734,759
031C0:  MOVFF  733,758
031C4:  MOVFF  732,757
031C8:  CALL   0D4C
031CC:  MOVFF  03,743
031D0:  MOVFF  02,742
031D4:  MOVFF  01,741
031D8:  MOVFF  00,740
031DC:  BCF    FD8.1
031DE:  MOVFF  03,755
031E2:  MOVFF  02,754
031E6:  MOVFF  01,753
031EA:  MOVFF  00,752
031EE:  MOVLW  5E
031F0:  MOVLB  7
031F2:  MOVWF  x59
031F4:  MOVLW  50
031F6:  MOVWF  x58
031F8:  MOVLW  63
031FA:  MOVWF  x57
031FC:  MOVLW  7A
031FE:  MOVWF  x56
03200:  MOVLB  0
03202:  CALL   0E42
03206:  MOVFF  03,73D
0320A:  MOVFF  02,73C
0320E:  MOVFF  01,73B
03212:  MOVFF  00,73A
....................    r = r*y + pe[4];
03216:  MOVFF  73D,756
0321A:  MOVFF  73C,755
0321E:  MOVFF  73B,754
03222:  MOVFF  73A,753
03226:  MOVFF  735,75A
0322A:  MOVFF  734,759
0322E:  MOVFF  733,758
03232:  MOVFF  732,757
03236:  CALL   0D4C
0323A:  MOVFF  03,743
0323E:  MOVFF  02,742
03242:  MOVFF  01,741
03246:  MOVFF  00,740
0324A:  BCF    FD8.1
0324C:  MOVFF  03,755
03250:  MOVFF  02,754
03254:  MOVFF  01,753
03258:  MOVFF  00,752
0325C:  MOVLW  1A
0325E:  MOVLB  7
03260:  MOVWF  x59
03262:  MOVLW  FE
03264:  MOVWF  x58
03266:  MOVLW  75
03268:  MOVWF  x57
0326A:  MOVLW  7C
0326C:  MOVWF  x56
0326E:  MOVLB  0
03270:  CALL   0E42
03274:  MOVFF  03,73D
03278:  MOVFF  02,73C
0327C:  MOVFF  01,73B
03280:  MOVFF  00,73A
....................    r = r*y + pe[5];
03284:  MOVFF  73D,756
03288:  MOVFF  73C,755
0328C:  MOVFF  73B,754
03290:  MOVFF  73A,753
03294:  MOVFF  735,75A
03298:  MOVFF  734,759
0329C:  MOVFF  733,758
032A0:  MOVFF  732,757
032A4:  CALL   0D4C
032A8:  MOVFF  03,743
032AC:  MOVFF  02,742
032B0:  MOVFF  01,741
032B4:  MOVFF  00,740
032B8:  BCF    FD8.1
032BA:  MOVFF  03,755
032BE:  MOVFF  02,754
032C2:  MOVFF  01,753
032C6:  MOVFF  00,752
032CA:  MOVLW  18
032CC:  MOVLB  7
032CE:  MOVWF  x59
032D0:  MOVLW  72
032D2:  MOVWF  x58
032D4:  MOVLW  31
032D6:  MOVWF  x57
032D8:  MOVLW  7E
032DA:  MOVWF  x56
032DC:  MOVLB  0
032DE:  CALL   0E42
032E2:  MOVFF  03,73D
032E6:  MOVFF  02,73C
032EA:  MOVFF  01,73B
032EE:  MOVFF  00,73A
.................... 
....................    res = res*(1.0 + y*r);
032F2:  MOVFF  735,756
032F6:  MOVFF  734,755
032FA:  MOVFF  733,754
032FE:  MOVFF  732,753
03302:  MOVFF  73D,75A
03306:  MOVFF  73C,759
0330A:  MOVFF  73B,758
0330E:  MOVFF  73A,757
03312:  CALL   0D4C
03316:  BCF    FD8.1
03318:  MOVLB  7
0331A:  CLRF   x55
0331C:  CLRF   x54
0331E:  CLRF   x53
03320:  MOVLW  7F
03322:  MOVWF  x52
03324:  MOVFF  03,759
03328:  MOVFF  02,758
0332C:  MOVFF  01,757
03330:  MOVFF  00,756
03334:  MOVLB  0
03336:  CALL   0E42
0333A:  MOVFF  739,756
0333E:  MOVFF  738,755
03342:  MOVFF  737,754
03346:  MOVFF  736,753
0334A:  MOVFF  03,75A
0334E:  MOVFF  02,759
03352:  MOVFF  01,758
03356:  MOVFF  00,757
0335A:  CALL   0D4C
0335E:  MOVFF  03,739
03362:  MOVFF  02,738
03366:  MOVFF  01,737
0336A:  MOVFF  00,736
.................... 
....................    if (s)
0336E:  MOVLB  7
03370:  BTFSS  x3F.0
03372:  BRA    33A6
....................       res = 1.0/res;
03374:  CLRF   x4A
03376:  CLRF   x49
03378:  CLRF   x48
0337A:  MOVLW  7F
0337C:  MOVWF  x47
0337E:  MOVFF  739,74E
03382:  MOVFF  738,74D
03386:  MOVFF  737,74C
0338A:  MOVFF  736,74B
0338E:  MOVLB  0
03390:  CALL   1D52
03394:  MOVFF  03,739
03398:  MOVFF  02,738
0339C:  MOVFF  01,737
033A0:  MOVFF  00,736
033A4:  MOVLB  7
....................    return(res);
033A6:  MOVFF  736,00
033AA:  MOVFF  737,01
033AE:  MOVFF  738,02
033B2:  MOVFF  739,03
033B6:  MOVLB  0
033B8:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C18:  MOVFF  731,735
02C1C:  MOVFF  730,734
02C20:  MOVFF  72F,733
02C24:  MOVFF  72E,732
.................... 
....................    if (y != 1.0)
02C28:  MOVFF  735,751
02C2C:  MOVFF  734,750
02C30:  MOVFF  733,74F
02C34:  MOVFF  732,74E
02C38:  MOVLB  7
02C3A:  CLRF   x55
02C3C:  CLRF   x54
02C3E:  CLRF   x53
02C40:  MOVLW  7F
02C42:  MOVWF  x52
02C44:  MOVLB  0
02C46:  CALL   1CD8
02C4A:  BTFSC  FD8.2
02C4C:  BRA    2F8E
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C4E:  MOVLW  07
02C50:  MOVLB  7
02C52:  MOVWF  x44
02C54:  MOVLW  32
02C56:  MOVFF  744,FEA
02C5A:  MOVWF  FE9
02C5C:  MOVLW  7E
02C5E:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02C60:  BSF    FD8.1
02C62:  MOVFF  735,755
02C66:  MOVFF  734,754
02C6A:  MOVFF  733,753
02C6E:  MOVFF  732,752
02C72:  CLRF   x59
02C74:  CLRF   x58
02C76:  CLRF   x57
02C78:  MOVLW  7F
02C7A:  MOVWF  x56
02C7C:  MOVLB  0
02C7E:  CALL   0E42
02C82:  MOVFF  03,746
02C86:  MOVFF  02,745
02C8A:  MOVFF  01,744
02C8E:  MOVFF  00,743
02C92:  BCF    FD8.1
02C94:  MOVFF  735,755
02C98:  MOVFF  734,754
02C9C:  MOVFF  733,753
02CA0:  MOVFF  732,752
02CA4:  MOVLB  7
02CA6:  CLRF   x59
02CA8:  CLRF   x58
02CAA:  CLRF   x57
02CAC:  MOVLW  7F
02CAE:  MOVWF  x56
02CB0:  MOVLB  0
02CB2:  CALL   0E42
02CB6:  MOVFF  746,74A
02CBA:  MOVFF  745,749
02CBE:  MOVFF  744,748
02CC2:  MOVFF  743,747
02CC6:  MOVFF  03,74E
02CCA:  MOVFF  02,74D
02CCE:  MOVFF  01,74C
02CD2:  MOVFF  00,74B
02CD6:  CALL   1D52
02CDA:  MOVFF  03,735
02CDE:  MOVFF  02,734
02CE2:  MOVFF  01,733
02CE6:  MOVFF  00,732
.................... 
....................       y2=y*y;
02CEA:  MOVFF  735,756
02CEE:  MOVFF  734,755
02CF2:  MOVFF  733,754
02CF6:  MOVFF  732,753
02CFA:  MOVFF  735,75A
02CFE:  MOVFF  734,759
02D02:  MOVFF  733,758
02D06:  MOVFF  732,757
02D0A:  CALL   0D4C
02D0E:  MOVFF  03,741
02D12:  MOVFF  02,740
02D16:  MOVFF  01,73F
02D1A:  MOVFF  00,73E
.................... 
....................       res = pl[0]*y2 + pl[1];
02D1E:  MOVLW  99
02D20:  MOVLB  7
02D22:  MOVWF  x56
02D24:  MOVLW  47
02D26:  MOVWF  x55
02D28:  MOVLW  8A
02D2A:  MOVWF  x54
02D2C:  MOVLW  7F
02D2E:  MOVWF  x53
02D30:  MOVFF  741,75A
02D34:  MOVFF  740,759
02D38:  MOVFF  73F,758
02D3C:  MOVFF  73E,757
02D40:  MOVLB  0
02D42:  CALL   0D4C
02D46:  MOVFF  03,746
02D4A:  MOVFF  02,745
02D4E:  MOVFF  01,744
02D52:  MOVFF  00,743
02D56:  BCF    FD8.1
02D58:  MOVFF  03,755
02D5C:  MOVFF  02,754
02D60:  MOVFF  01,753
02D64:  MOVFF  00,752
02D68:  MOVLB  7
02D6A:  CLRF   x59
02D6C:  CLRF   x58
02D6E:  CLRF   x57
02D70:  MOVLW  80
02D72:  MOVWF  x56
02D74:  MOVLB  0
02D76:  CALL   0E42
02D7A:  MOVFF  03,739
02D7E:  MOVFF  02,738
02D82:  MOVFF  01,737
02D86:  MOVFF  00,736
.................... 
....................       r = ql[0]*y2 + ql[1];
02D8A:  MOVLW  4C
02D8C:  MOVLB  7
02D8E:  MOVWF  x56
02D90:  MOVLW  F3
02D92:  MOVWF  x55
02D94:  MOVLW  3A
02D96:  MOVWF  x54
02D98:  MOVLW  7B
02D9A:  MOVWF  x53
02D9C:  MOVFF  741,75A
02DA0:  MOVFF  740,759
02DA4:  MOVFF  73F,758
02DA8:  MOVFF  73E,757
02DAC:  MOVLB  0
02DAE:  CALL   0D4C
02DB2:  MOVFF  03,746
02DB6:  MOVFF  02,745
02DBA:  MOVFF  01,744
02DBE:  MOVFF  00,743
02DC2:  BCF    FD8.1
02DC4:  MOVFF  03,755
02DC8:  MOVFF  02,754
02DCC:  MOVFF  01,753
02DD0:  MOVFF  00,752
02DD4:  MOVLW  2B
02DD6:  MOVLB  7
02DD8:  MOVWF  x59
02DDA:  MOVLW  9D
02DDC:  MOVWF  x58
02DDE:  MOVLW  DF
02DE0:  MOVWF  x57
02DE2:  MOVLW  7E
02DE4:  MOVWF  x56
02DE6:  MOVLB  0
02DE8:  CALL   0E42
02DEC:  MOVFF  03,73D
02DF0:  MOVFF  02,73C
02DF4:  MOVFF  01,73B
02DF8:  MOVFF  00,73A
....................       r = r*y2 + 1.0;
02DFC:  MOVFF  73D,756
02E00:  MOVFF  73C,755
02E04:  MOVFF  73B,754
02E08:  MOVFF  73A,753
02E0C:  MOVFF  741,75A
02E10:  MOVFF  740,759
02E14:  MOVFF  73F,758
02E18:  MOVFF  73E,757
02E1C:  CALL   0D4C
02E20:  MOVFF  03,746
02E24:  MOVFF  02,745
02E28:  MOVFF  01,744
02E2C:  MOVFF  00,743
02E30:  BCF    FD8.1
02E32:  MOVFF  03,755
02E36:  MOVFF  02,754
02E3A:  MOVFF  01,753
02E3E:  MOVFF  00,752
02E42:  MOVLB  7
02E44:  CLRF   x59
02E46:  CLRF   x58
02E48:  CLRF   x57
02E4A:  MOVLW  7F
02E4C:  MOVWF  x56
02E4E:  MOVLB  0
02E50:  CALL   0E42
02E54:  MOVFF  03,73D
02E58:  MOVFF  02,73C
02E5C:  MOVFF  01,73B
02E60:  MOVFF  00,73A
.................... 
....................       res = y*res/r;
02E64:  MOVFF  735,756
02E68:  MOVFF  734,755
02E6C:  MOVFF  733,754
02E70:  MOVFF  732,753
02E74:  MOVFF  739,75A
02E78:  MOVFF  738,759
02E7C:  MOVFF  737,758
02E80:  MOVFF  736,757
02E84:  CALL   0D4C
02E88:  MOVFF  03,746
02E8C:  MOVFF  02,745
02E90:  MOVFF  01,744
02E94:  MOVFF  00,743
02E98:  MOVFF  03,74A
02E9C:  MOVFF  02,749
02EA0:  MOVFF  01,748
02EA4:  MOVFF  00,747
02EA8:  MOVFF  73D,74E
02EAC:  MOVFF  73C,74D
02EB0:  MOVFF  73B,74C
02EB4:  MOVFF  73A,74B
02EB8:  CALL   1D52
02EBC:  MOVFF  03,739
02EC0:  MOVFF  02,738
02EC4:  MOVFF  01,737
02EC8:  MOVFF  00,736
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02ECC:  MOVLW  07
02ECE:  MOVLB  7
02ED0:  MOVWF  x44
02ED2:  MOVLW  2E
02ED4:  MOVFF  744,FEA
02ED8:  MOVWF  FE9
02EDA:  MOVLW  7E
02EDC:  SUBWF  FEF,W
02EDE:  MOVWF  x42
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02EE0:  BTFSS  x42.7
02EE2:  BRA    2F0E
....................          r = -(float32)-n;
02EE4:  MOVLW  00
02EE6:  BSF    FD8.0
02EE8:  SUBFWB x42,W
02EEA:  CLRF   x45
02EEC:  MOVWF  x44
02EEE:  BTFSC  x44.7
02EF0:  DECF   x45,F
02EF2:  MOVLB  0
02EF4:  CALL   267C
02EF8:  MOVFF  00,73A
02EFC:  MOVF   01,W
02EFE:  XORLW  80
02F00:  MOVLB  7
02F02:  MOVWF  x3B
02F04:  MOVFF  02,73C
02F08:  MOVFF  03,73D
02F0C:  BRA    2F30
....................       else
....................          r = (float32)n;
02F0E:  CLRF   x45
02F10:  MOVFF  742,744
02F14:  BTFSC  x44.7
02F16:  DECF   x45,F
02F18:  MOVLB  0
02F1A:  CALL   267C
02F1E:  MOVFF  03,73D
02F22:  MOVFF  02,73C
02F26:  MOVFF  01,73B
02F2A:  MOVFF  00,73A
02F2E:  MOVLB  7
.................... 
....................       res += r*LN2;
02F30:  MOVFF  73D,756
02F34:  MOVFF  73C,755
02F38:  MOVFF  73B,754
02F3C:  MOVFF  73A,753
02F40:  MOVLW  18
02F42:  MOVWF  x5A
02F44:  MOVLW  72
02F46:  MOVWF  x59
02F48:  MOVLW  31
02F4A:  MOVWF  x58
02F4C:  MOVLW  7E
02F4E:  MOVWF  x57
02F50:  MOVLB  0
02F52:  CALL   0D4C
02F56:  BCF    FD8.1
02F58:  MOVFF  739,755
02F5C:  MOVFF  738,754
02F60:  MOVFF  737,753
02F64:  MOVFF  736,752
02F68:  MOVFF  03,759
02F6C:  MOVFF  02,758
02F70:  MOVFF  01,757
02F74:  MOVFF  00,756
02F78:  CALL   0E42
02F7C:  MOVFF  03,739
02F80:  MOVFF  02,738
02F84:  MOVFF  01,737
02F88:  MOVFF  00,736
....................    }
02F8C:  BRA    2F9A
.................... 
....................    else
....................       res = 0.0;
02F8E:  MOVLB  7
02F90:  CLRF   x39
02F92:  CLRF   x38
02F94:  CLRF   x37
02F96:  CLRF   x36
02F98:  MOVLB  0
.................... 
....................    return(res);
02F9A:  MOVFF  736,00
02F9E:  MOVFF  737,01
02FA2:  MOVFF  738,02
02FA6:  MOVFF  739,03
02FAA:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
033BA:  MOVFF  725,751
033BE:  MOVFF  724,750
033C2:  MOVFF  723,74F
033C6:  MOVFF  722,74E
033CA:  MOVLB  7
033CC:  CLRF   x55
033CE:  CLRF   x54
033D0:  CLRF   x53
033D2:  CLRF   x52
033D4:  MOVLB  0
033D6:  CALL   1CD8
033DA:  BTFSS  FD8.0
033DC:  BRA    3578
033DE:  MOVFF  729,72D
033E2:  MOVFF  728,72C
033E6:  MOVFF  727,72B
033EA:  MOVFF  726,72A
033EE:  MOVLB  7
033F0:  CLRF   x31
033F2:  CLRF   x30
033F4:  CLRF   x2F
033F6:  MOVLW  7F
033F8:  MOVWF  x2E
033FA:  MOVLB  0
033FC:  CALL   2AB2
03400:  MOVFF  03,72D
03404:  MOVFF  02,72C
03408:  MOVFF  01,72B
0340C:  MOVFF  00,72A
03410:  MOVFF  03,751
03414:  MOVFF  02,750
03418:  MOVFF  01,74F
0341C:  MOVFF  00,74E
03420:  MOVLB  7
03422:  CLRF   x55
03424:  CLRF   x54
03426:  CLRF   x53
03428:  CLRF   x52
0342A:  MOVLB  0
0342C:  CALL   1CD8
03430:  BTFSS  FD8.2
03432:  BRA    3578
....................       if(fmod(y, 2) == 0) {
03434:  MOVFF  729,72D
03438:  MOVFF  728,72C
0343C:  MOVFF  727,72B
03440:  MOVFF  726,72A
03444:  MOVLB  7
03446:  CLRF   x31
03448:  CLRF   x30
0344A:  CLRF   x2F
0344C:  MOVLW  80
0344E:  MOVWF  x2E
03450:  MOVLB  0
03452:  CALL   2AB2
03456:  MOVFF  03,72D
0345A:  MOVFF  02,72C
0345E:  MOVFF  01,72B
03462:  MOVFF  00,72A
03466:  MOVFF  03,751
0346A:  MOVFF  02,750
0346E:  MOVFF  01,74F
03472:  MOVFF  00,74E
03476:  MOVLB  7
03478:  CLRF   x55
0347A:  CLRF   x54
0347C:  CLRF   x53
0347E:  CLRF   x52
03480:  MOVLB  0
03482:  CALL   1CD8
03486:  BNZ   34FE
....................          return (exp(log(-x) * y));
03488:  MOVLB  7
0348A:  MOVF   x23,W
0348C:  XORLW  80
0348E:  MOVWF  x2B
03490:  MOVFF  725,731
03494:  MOVFF  724,730
03498:  MOVWF  x2F
0349A:  MOVFF  722,72E
0349E:  MOVLB  0
034A0:  CALL   2C18
034A4:  MOVFF  03,72D
034A8:  MOVFF  02,72C
034AC:  MOVFF  01,72B
034B0:  MOVFF  00,72A
034B4:  MOVFF  03,756
034B8:  MOVFF  02,755
034BC:  MOVFF  01,754
034C0:  MOVFF  00,753
034C4:  MOVFF  729,75A
034C8:  MOVFF  728,759
034CC:  MOVFF  727,758
034D0:  MOVFF  726,757
034D4:  CALL   0D4C
034D8:  MOVFF  03,72D
034DC:  MOVFF  02,72C
034E0:  MOVFF  01,72B
034E4:  MOVFF  00,72A
034E8:  MOVFF  03,731
034EC:  MOVFF  02,730
034F0:  MOVFF  01,72F
034F4:  MOVFF  00,72E
034F8:  RCALL  2FAC
034FA:  BRA    36B6
....................       } else {
034FC:  BRA    3576
....................          return (-exp(log(-x) * y));
034FE:  MOVLB  7
03500:  MOVF   x23,W
03502:  XORLW  80
03504:  MOVWF  x2B
03506:  MOVFF  725,731
0350A:  MOVFF  724,730
0350E:  MOVWF  x2F
03510:  MOVFF  722,72E
03514:  MOVLB  0
03516:  CALL   2C18
0351A:  MOVFF  03,72D
0351E:  MOVFF  02,72C
03522:  MOVFF  01,72B
03526:  MOVFF  00,72A
0352A:  MOVFF  03,756
0352E:  MOVFF  02,755
03532:  MOVFF  01,754
03536:  MOVFF  00,753
0353A:  MOVFF  729,75A
0353E:  MOVFF  728,759
03542:  MOVFF  727,758
03546:  MOVFF  726,757
0354A:  CALL   0D4C
0354E:  MOVFF  03,72D
03552:  MOVFF  02,72C
03556:  MOVFF  01,72B
0355A:  MOVFF  00,72A
0355E:  MOVFF  03,731
03562:  MOVFF  02,730
03566:  MOVFF  01,72F
0356A:  MOVFF  00,72E
0356E:  RCALL  2FAC
03570:  MOVLW  80
03572:  XORWF  01,F
03574:  BRA    36B6
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03576:  BRA    36B6
03578:  MOVFF  725,751
0357C:  MOVFF  724,750
03580:  MOVFF  723,74F
03584:  MOVFF  722,74E
03588:  MOVLB  7
0358A:  CLRF   x55
0358C:  CLRF   x54
0358E:  CLRF   x53
03590:  CLRF   x52
03592:  MOVLB  0
03594:  CALL   1CD8
03598:  BNC   35FA
0359A:  MOVFF  729,72D
0359E:  MOVFF  728,72C
035A2:  MOVFF  727,72B
035A6:  MOVFF  726,72A
035AA:  MOVLB  7
035AC:  CLRF   x31
035AE:  CLRF   x30
035B0:  CLRF   x2F
035B2:  MOVLW  7F
035B4:  MOVWF  x2E
035B6:  MOVLB  0
035B8:  CALL   2AB2
035BC:  MOVFF  03,72D
035C0:  MOVFF  02,72C
035C4:  MOVFF  01,72B
035C8:  MOVFF  00,72A
035CC:  MOVFF  03,751
035D0:  MOVFF  02,750
035D4:  MOVFF  01,74F
035D8:  MOVFF  00,74E
035DC:  MOVLB  7
035DE:  CLRF   x55
035E0:  CLRF   x54
035E2:  CLRF   x53
035E4:  CLRF   x52
035E6:  MOVLB  0
035E8:  CALL   1CD8
035EC:  BZ    35FA
....................       return 0;
035EE:  CLRF   00
035F0:  CLRF   01
035F2:  CLRF   02
035F4:  CLRF   03
035F6:  BRA    36B6
....................    } else {
035F8:  BRA    36B6
....................       if(x != 0 || 0 >= y) {
035FA:  MOVFF  725,751
035FE:  MOVFF  724,750
03602:  MOVFF  723,74F
03606:  MOVFF  722,74E
0360A:  MOVLB  7
0360C:  CLRF   x55
0360E:  CLRF   x54
03610:  CLRF   x53
03612:  CLRF   x52
03614:  MOVLB  0
03616:  CALL   1CD8
0361A:  BNZ   3640
0361C:  MOVFF  729,751
03620:  MOVFF  728,750
03624:  MOVFF  727,74F
03628:  MOVFF  726,74E
0362C:  MOVLB  7
0362E:  CLRF   x55
03630:  CLRF   x54
03632:  CLRF   x53
03634:  CLRF   x52
03636:  MOVLB  0
03638:  CALL   1CD8
0363C:  BC    3640
0363E:  BNZ   36AE
....................          return (exp(log(x) * y));
03640:  MOVFF  725,731
03644:  MOVFF  724,730
03648:  MOVFF  723,72F
0364C:  MOVFF  722,72E
03650:  CALL   2C18
03654:  MOVFF  03,72D
03658:  MOVFF  02,72C
0365C:  MOVFF  01,72B
03660:  MOVFF  00,72A
03664:  MOVFF  03,756
03668:  MOVFF  02,755
0366C:  MOVFF  01,754
03670:  MOVFF  00,753
03674:  MOVFF  729,75A
03678:  MOVFF  728,759
0367C:  MOVFF  727,758
03680:  MOVFF  726,757
03684:  CALL   0D4C
03688:  MOVFF  03,72D
0368C:  MOVFF  02,72C
03690:  MOVFF  01,72B
03694:  MOVFF  00,72A
03698:  MOVFF  03,731
0369C:  MOVFF  02,730
036A0:  MOVFF  01,72F
036A4:  MOVFF  00,72E
036A8:  RCALL  2FAC
036AA:  BRA    36B6
....................       } else return 0;
036AC:  BRA    36B6
036AE:  CLRF   00
036B0:  CLRF   01
036B2:  CLRF   02
036B4:  CLRF   03
....................    }
036B6:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01EB0:  MOVLB  7
01EB2:  BCF    x40.0
....................    flag = 0;
01EB4:  BCF    x40.1
....................    y = x;
01EB6:  MOVFF  733,737
01EBA:  MOVFF  732,736
01EBE:  MOVFF  731,735
01EC2:  MOVFF  730,734
.................... 
....................    if (x < 0)
01EC6:  MOVFF  733,751
01ECA:  MOVFF  732,750
01ECE:  MOVFF  731,74F
01ED2:  MOVFF  730,74E
01ED6:  CLRF   x55
01ED8:  CLRF   x54
01EDA:  CLRF   x53
01EDC:  CLRF   x52
01EDE:  MOVLB  0
01EE0:  RCALL  1CD8
01EE2:  BNC   1EF0
....................    {
....................       s = 1;
01EE4:  MOVLB  7
01EE6:  BSF    x40.0
....................       y = -y;
01EE8:  MOVF   x35,W
01EEA:  XORLW  80
01EEC:  MOVWF  x35
01EEE:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01EF0:  MOVLB  7
01EF2:  CLRF   x51
01EF4:  CLRF   x50
01EF6:  CLRF   x4F
01EF8:  MOVLW  7F
01EFA:  MOVWF  x4E
01EFC:  MOVFF  737,755
01F00:  MOVFF  736,754
01F04:  MOVFF  735,753
01F08:  MOVFF  734,752
01F0C:  MOVLB  0
01F0E:  RCALL  1CD8
01F10:  BNC   1F48
....................    {
....................       y = 1.0/y;
01F12:  MOVLB  7
01F14:  CLRF   x4A
01F16:  CLRF   x49
01F18:  CLRF   x48
01F1A:  MOVLW  7F
01F1C:  MOVWF  x47
01F1E:  MOVFF  737,74E
01F22:  MOVFF  736,74D
01F26:  MOVFF  735,74C
01F2A:  MOVFF  734,74B
01F2E:  MOVLB  0
01F30:  RCALL  1D52
01F32:  MOVFF  03,737
01F36:  MOVFF  02,736
01F3A:  MOVFF  01,735
01F3E:  MOVFF  00,734
....................       flag = 1;
01F42:  MOVLB  7
01F44:  BSF    x40.1
01F46:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F48:  MOVLW  0A
01F4A:  MOVLB  7
01F4C:  MOVWF  x56
01F4E:  MOVLW  89
01F50:  MOVWF  x55
01F52:  MOVLW  34
01F54:  MOVWF  x54
01F56:  MOVLW  7C
01F58:  MOVWF  x53
01F5A:  MOVFF  737,75A
01F5E:  MOVFF  736,759
01F62:  MOVFF  735,758
01F66:  MOVFF  734,757
01F6A:  MOVLB  0
01F6C:  CALL   0D4C
01F70:  MOVFF  03,744
01F74:  MOVFF  02,743
01F78:  MOVFF  01,742
01F7C:  MOVFF  00,741
01F80:  MOVFF  03,756
01F84:  MOVFF  02,755
01F88:  MOVFF  01,754
01F8C:  MOVFF  00,753
01F90:  MOVFF  737,75A
01F94:  MOVFF  736,759
01F98:  MOVFF  735,758
01F9C:  MOVFF  734,757
01FA0:  CALL   0D4C
01FA4:  MOVFF  03,744
01FA8:  MOVFF  02,743
01FAC:  MOVFF  01,742
01FB0:  MOVFF  00,741
01FB4:  BCF    FD8.1
01FB6:  MOVFF  03,755
01FBA:  MOVFF  02,754
01FBE:  MOVFF  01,753
01FC2:  MOVFF  00,752
01FC6:  MOVLW  7C
01FC8:  MOVLB  7
01FCA:  MOVWF  x59
01FCC:  MOVLW  79
01FCE:  MOVWF  x58
01FD0:  MOVLW  35
01FD2:  MOVWF  x57
01FD4:  MOVLW  81
01FD6:  MOVWF  x56
01FD8:  MOVLB  0
01FDA:  CALL   0E42
01FDE:  MOVFF  03,73B
01FE2:  MOVFF  02,73A
01FE6:  MOVFF  01,739
01FEA:  MOVFF  00,738
....................    res = res*y*y + pat[2];
01FEE:  MOVFF  73B,756
01FF2:  MOVFF  73A,755
01FF6:  MOVFF  739,754
01FFA:  MOVFF  738,753
01FFE:  MOVFF  737,75A
02002:  MOVFF  736,759
02006:  MOVFF  735,758
0200A:  MOVFF  734,757
0200E:  CALL   0D4C
02012:  MOVFF  03,744
02016:  MOVFF  02,743
0201A:  MOVFF  01,742
0201E:  MOVFF  00,741
02022:  MOVFF  03,756
02026:  MOVFF  02,755
0202A:  MOVFF  01,754
0202E:  MOVFF  00,753
02032:  MOVFF  737,75A
02036:  MOVFF  736,759
0203A:  MOVFF  735,758
0203E:  MOVFF  734,757
02042:  CALL   0D4C
02046:  MOVFF  03,744
0204A:  MOVFF  02,743
0204E:  MOVFF  01,742
02052:  MOVFF  00,741
02056:  BCF    FD8.1
02058:  MOVFF  03,755
0205C:  MOVFF  02,754
02060:  MOVFF  01,753
02064:  MOVFF  00,752
02068:  MOVLW  3F
0206A:  MOVLB  7
0206C:  MOVWF  x59
0206E:  MOVLW  02
02070:  MOVWF  x58
02072:  MOVLW  33
02074:  MOVWF  x57
02076:  MOVLW  83
02078:  MOVWF  x56
0207A:  MOVLB  0
0207C:  CALL   0E42
02080:  MOVFF  03,73B
02084:  MOVFF  02,73A
02088:  MOVFF  01,739
0208C:  MOVFF  00,738
....................    res = res*y*y + pat[3];
02090:  MOVFF  73B,756
02094:  MOVFF  73A,755
02098:  MOVFF  739,754
0209C:  MOVFF  738,753
020A0:  MOVFF  737,75A
020A4:  MOVFF  736,759
020A8:  MOVFF  735,758
020AC:  MOVFF  734,757
020B0:  CALL   0D4C
020B4:  MOVFF  03,744
020B8:  MOVFF  02,743
020BC:  MOVFF  01,742
020C0:  MOVFF  00,741
020C4:  MOVFF  03,756
020C8:  MOVFF  02,755
020CC:  MOVFF  01,754
020D0:  MOVFF  00,753
020D4:  MOVFF  737,75A
020D8:  MOVFF  736,759
020DC:  MOVFF  735,758
020E0:  MOVFF  734,757
020E4:  CALL   0D4C
020E8:  MOVFF  03,744
020EC:  MOVFF  02,743
020F0:  MOVFF  01,742
020F4:  MOVFF  00,741
020F8:  BCF    FD8.1
020FA:  MOVFF  03,755
020FE:  MOVFF  02,754
02102:  MOVFF  01,753
02106:  MOVFF  00,752
0210A:  MOVLW  33
0210C:  MOVLB  7
0210E:  MOVWF  x59
02110:  MOVLW  8C
02112:  MOVWF  x58
02114:  MOVLW  1E
02116:  MOVWF  x57
02118:  MOVLW  83
0211A:  MOVWF  x56
0211C:  MOVLB  0
0211E:  CALL   0E42
02122:  MOVFF  03,73B
02126:  MOVFF  02,73A
0212A:  MOVFF  01,739
0212E:  MOVFF  00,738
.................... 
....................    r = qat[0]*y*y + qat[1];
02132:  MOVLB  7
02134:  CLRF   x56
02136:  CLRF   x55
02138:  CLRF   x54
0213A:  MOVLW  7F
0213C:  MOVWF  x53
0213E:  MOVFF  737,75A
02142:  MOVFF  736,759
02146:  MOVFF  735,758
0214A:  MOVFF  734,757
0214E:  MOVLB  0
02150:  CALL   0D4C
02154:  MOVFF  03,744
02158:  MOVFF  02,743
0215C:  MOVFF  01,742
02160:  MOVFF  00,741
02164:  MOVFF  03,756
02168:  MOVFF  02,755
0216C:  MOVFF  01,754
02170:  MOVFF  00,753
02174:  MOVFF  737,75A
02178:  MOVFF  736,759
0217C:  MOVFF  735,758
02180:  MOVFF  734,757
02184:  CALL   0D4C
02188:  MOVFF  03,744
0218C:  MOVFF  02,743
02190:  MOVFF  01,742
02194:  MOVFF  00,741
02198:  BCF    FD8.1
0219A:  MOVFF  03,755
0219E:  MOVFF  02,754
021A2:  MOVFF  01,753
021A6:  MOVFF  00,752
021AA:  MOVLW  1B
021AC:  MOVLB  7
021AE:  MOVWF  x59
021B0:  MOVLW  E4
021B2:  MOVWF  x58
021B4:  MOVLW  35
021B6:  MOVWF  x57
021B8:  MOVLW  82
021BA:  MOVWF  x56
021BC:  MOVLB  0
021BE:  CALL   0E42
021C2:  MOVFF  03,73F
021C6:  MOVFF  02,73E
021CA:  MOVFF  01,73D
021CE:  MOVFF  00,73C
....................    r = r*y*y + qat[2];
021D2:  MOVFF  73F,756
021D6:  MOVFF  73E,755
021DA:  MOVFF  73D,754
021DE:  MOVFF  73C,753
021E2:  MOVFF  737,75A
021E6:  MOVFF  736,759
021EA:  MOVFF  735,758
021EE:  MOVFF  734,757
021F2:  CALL   0D4C
021F6:  MOVFF  03,744
021FA:  MOVFF  02,743
021FE:  MOVFF  01,742
02202:  MOVFF  00,741
02206:  MOVFF  03,756
0220A:  MOVFF  02,755
0220E:  MOVFF  01,754
02212:  MOVFF  00,753
02216:  MOVFF  737,75A
0221A:  MOVFF  736,759
0221E:  MOVFF  735,758
02222:  MOVFF  734,757
02226:  CALL   0D4C
0222A:  MOVFF  03,744
0222E:  MOVFF  02,743
02232:  MOVFF  01,742
02236:  MOVFF  00,741
0223A:  BCF    FD8.1
0223C:  MOVFF  03,755
02240:  MOVFF  02,754
02244:  MOVFF  01,753
02248:  MOVFF  00,752
0224C:  MOVLW  A4
0224E:  MOVLB  7
02250:  MOVWF  x59
02252:  MOVLW  DB
02254:  MOVWF  x58
02256:  MOVLW  67
02258:  MOVWF  x57
0225A:  MOVLW  83
0225C:  MOVWF  x56
0225E:  MOVLB  0
02260:  CALL   0E42
02264:  MOVFF  03,73F
02268:  MOVFF  02,73E
0226C:  MOVFF  01,73D
02270:  MOVFF  00,73C
....................    r = r*y*y + qat[3];
02274:  MOVFF  73F,756
02278:  MOVFF  73E,755
0227C:  MOVFF  73D,754
02280:  MOVFF  73C,753
02284:  MOVFF  737,75A
02288:  MOVFF  736,759
0228C:  MOVFF  735,758
02290:  MOVFF  734,757
02294:  CALL   0D4C
02298:  MOVFF  03,744
0229C:  MOVFF  02,743
022A0:  MOVFF  01,742
022A4:  MOVFF  00,741
022A8:  MOVFF  03,756
022AC:  MOVFF  02,755
022B0:  MOVFF  01,754
022B4:  MOVFF  00,753
022B8:  MOVFF  737,75A
022BC:  MOVFF  736,759
022C0:  MOVFF  735,758
022C4:  MOVFF  734,757
022C8:  CALL   0D4C
022CC:  MOVFF  03,744
022D0:  MOVFF  02,743
022D4:  MOVFF  01,742
022D8:  MOVFF  00,741
022DC:  BCF    FD8.1
022DE:  MOVFF  03,755
022E2:  MOVFF  02,754
022E6:  MOVFF  01,753
022EA:  MOVFF  00,752
022EE:  MOVLW  33
022F0:  MOVLB  7
022F2:  MOVWF  x59
022F4:  MOVLW  8C
022F6:  MOVWF  x58
022F8:  MOVLW  1E
022FA:  MOVWF  x57
022FC:  MOVLW  83
022FE:  MOVWF  x56
02300:  MOVLB  0
02302:  CALL   0E42
02306:  MOVFF  03,73F
0230A:  MOVFF  02,73E
0230E:  MOVFF  01,73D
02312:  MOVFF  00,73C
.................... 
....................    res = y*res/r;
02316:  MOVFF  737,756
0231A:  MOVFF  736,755
0231E:  MOVFF  735,754
02322:  MOVFF  734,753
02326:  MOVFF  73B,75A
0232A:  MOVFF  73A,759
0232E:  MOVFF  739,758
02332:  MOVFF  738,757
02336:  CALL   0D4C
0233A:  MOVFF  03,744
0233E:  MOVFF  02,743
02342:  MOVFF  01,742
02346:  MOVFF  00,741
0234A:  MOVFF  03,74A
0234E:  MOVFF  02,749
02352:  MOVFF  01,748
02356:  MOVFF  00,747
0235A:  MOVFF  73F,74E
0235E:  MOVFF  73E,74D
02362:  MOVFF  73D,74C
02366:  MOVFF  73C,74B
0236A:  RCALL  1D52
0236C:  MOVFF  03,73B
02370:  MOVFF  02,73A
02374:  MOVFF  01,739
02378:  MOVFF  00,738
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
0237C:  MOVLB  7
0237E:  BTFSS  x40.1
02380:  BRA    23BC
....................       res = PI_DIV_BY_TWO - res;
02382:  BSF    FD8.1
02384:  MOVLW  DB
02386:  MOVWF  x55
02388:  MOVLW  0F
0238A:  MOVWF  x54
0238C:  MOVLW  49
0238E:  MOVWF  x53
02390:  MOVLW  7F
02392:  MOVWF  x52
02394:  MOVFF  73B,759
02398:  MOVFF  73A,758
0239C:  MOVFF  739,757
023A0:  MOVFF  738,756
023A4:  MOVLB  0
023A6:  CALL   0E42
023AA:  MOVFF  03,73B
023AE:  MOVFF  02,73A
023B2:  MOVFF  01,739
023B6:  MOVFF  00,738
023BA:  MOVLB  7
....................    if (s)
023BC:  BTFSS  x40.0
023BE:  BRA    23C6
....................       res = -res;
023C0:  MOVF   x39,W
023C2:  XORLW  80
023C4:  MOVWF  x39
.................... 
....................    return(res);
023C6:  MOVFF  738,00
023CA:  MOVFF  739,01
023CE:  MOVFF  73A,02
023D2:  MOVFF  73B,03
023D6:  MOVLB  0
023D8:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
023DA:  MOVLB  7
023DC:  BCF    x2E.0
....................    quad=0; //quadrant
023DE:  CLRF   x2F
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
023E0:  MOVFF  725,751
023E4:  MOVFF  724,750
023E8:  MOVFF  723,74F
023EC:  MOVFF  722,74E
023F0:  CLRF   x55
023F2:  CLRF   x54
023F4:  CLRF   x53
023F6:  CLRF   x52
023F8:  MOVLB  0
023FA:  RCALL  1CD8
023FC:  BC    2400
023FE:  BNZ   242A
02400:  MOVFF  729,751
02404:  MOVFF  728,750
02408:  MOVFF  727,74F
0240C:  MOVFF  726,74E
02410:  MOVLB  7
02412:  CLRF   x55
02414:  CLRF   x54
02416:  CLRF   x53
02418:  CLRF   x52
0241A:  MOVLB  0
0241C:  RCALL  1CD8
0241E:  BC    2422
02420:  BNZ   2426
02422:  MOVLW  03
02424:  BRA    2428
02426:  MOVLW  04
02428:  BRA    2450
0242A:  MOVFF  729,751
0242E:  MOVFF  728,750
02432:  MOVFF  727,74F
02436:  MOVFF  726,74E
0243A:  MOVLB  7
0243C:  CLRF   x55
0243E:  CLRF   x54
02440:  CLRF   x53
02442:  CLRF   x52
02444:  MOVLB  0
02446:  RCALL  1CD8
02448:  BNC   244E
0244A:  MOVLW  02
0244C:  BRA    2450
0244E:  MOVLW  01
02450:  MOVLB  7
02452:  MOVWF  x2F
....................    if(y<0.0)
02454:  MOVFF  725,751
02458:  MOVFF  724,750
0245C:  MOVFF  723,74F
02460:  MOVFF  722,74E
02464:  CLRF   x55
02466:  CLRF   x54
02468:  CLRF   x53
0246A:  CLRF   x52
0246C:  MOVLB  0
0246E:  RCALL  1CD8
02470:  BNC   247E
....................    {
....................       sign=1;
02472:  MOVLB  7
02474:  BSF    x2E.0
....................       y=-y;
02476:  MOVF   x23,W
02478:  XORLW  80
0247A:  MOVWF  x23
0247C:  MOVLB  0
....................    }
....................    if(x<0.0)
0247E:  MOVFF  729,751
02482:  MOVFF  728,750
02486:  MOVFF  727,74F
0248A:  MOVFF  726,74E
0248E:  MOVLB  7
02490:  CLRF   x55
02492:  CLRF   x54
02494:  CLRF   x53
02496:  CLRF   x52
02498:  MOVLB  0
0249A:  RCALL  1CD8
0249C:  BNC   24A8
....................    {
....................       x=-x;
0249E:  MOVLB  7
024A0:  MOVF   x27,W
024A2:  XORLW  80
024A4:  MOVWF  x27
024A6:  MOVLB  0
....................    }
....................    if (x==0.0)
024A8:  MOVFF  729,751
024AC:  MOVFF  728,750
024B0:  MOVFF  727,74F
024B4:  MOVFF  726,74E
024B8:  MOVLB  7
024BA:  CLRF   x55
024BC:  CLRF   x54
024BE:  CLRF   x53
024C0:  CLRF   x52
024C2:  MOVLB  0
024C4:  RCALL  1CD8
024C6:  BNZ   251C
....................    {
....................       if(y==0.0)
024C8:  MOVFF  725,751
024CC:  MOVFF  724,750
024D0:  MOVFF  723,74F
024D4:  MOVFF  722,74E
024D8:  MOVLB  7
024DA:  CLRF   x55
024DC:  CLRF   x54
024DE:  CLRF   x53
024E0:  CLRF   x52
024E2:  MOVLB  0
024E4:  CALL   1CD8
024E8:  BNZ   24EC
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
024EA:  BRA    251A
....................       else
....................       {
....................          if(sign)
024EC:  MOVLB  7
024EE:  BTFSS  x2E.0
024F0:  BRA    2506
....................          {
....................          return (-(PI_DIV_BY_TWO));
024F2:  MOVLW  7F
024F4:  MOVWF  00
024F6:  MOVLW  C9
024F8:  MOVWF  01
024FA:  MOVLW  0F
024FC:  MOVWF  02
024FE:  MOVLW  DB
02500:  MOVWF  03
02502:  BRA    2654
....................          }
02504:  BRA    2518
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02506:  MOVLW  7F
02508:  MOVWF  00
0250A:  MOVLW  49
0250C:  MOVWF  01
0250E:  MOVLW  0F
02510:  MOVWF  02
02512:  MOVLW  DB
02514:  MOVWF  03
02516:  BRA    2654
02518:  MOVLB  0
....................          }
....................       }
....................    }
0251A:  BRA    2652
....................    else
....................    {
....................       z=y/x;
0251C:  MOVFF  725,74A
02520:  MOVFF  724,749
02524:  MOVFF  723,748
02528:  MOVFF  722,747
0252C:  MOVFF  729,74E
02530:  MOVFF  728,74D
02534:  MOVFF  727,74C
02538:  MOVFF  726,74B
0253C:  RCALL  1D52
0253E:  MOVFF  03,72D
02542:  MOVFF  02,72C
02546:  MOVFF  01,72B
0254A:  MOVFF  00,72A
....................       switch(quad)
0254E:  MOVLW  01
02550:  MOVLB  7
02552:  SUBWF  x2F,W
02554:  ADDLW  FC
02556:  BTFSC  FD8.0
02558:  BRA    2654
0255A:  ADDLW  04
0255C:  MOVLB  0
0255E:  GOTO   265A
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02562:  MOVFF  72D,733
02566:  MOVFF  72C,732
0256A:  MOVFF  72B,731
0256E:  MOVFF  72A,730
02572:  RCALL  1EB0
02574:  MOVLB  7
02576:  BRA    2654
....................             break;
02578:  BRA    2654
0257A:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
0257C:  MOVFF  72D,733
02580:  MOVFF  72C,732
02584:  MOVFF  72B,731
02588:  MOVFF  72A,730
0258C:  RCALL  1EB0
0258E:  MOVFF  FEA,731
02592:  MOVFF  FE9,730
02596:  BSF    FD8.1
02598:  MOVLW  DB
0259A:  MOVLB  7
0259C:  MOVWF  x55
0259E:  MOVLW  0F
025A0:  MOVWF  x54
025A2:  MOVLW  49
025A4:  MOVWF  x53
025A6:  MOVLW  80
025A8:  MOVWF  x52
025AA:  MOVFF  03,759
025AE:  MOVFF  02,758
025B2:  MOVFF  01,757
025B6:  MOVFF  00,756
025BA:  MOVLB  0
025BC:  CALL   0E42
025C0:  MOVFF  731,FEA
025C4:  MOVFF  730,FE9
025C8:  MOVLB  7
025CA:  BRA    2654
....................             break;
025CC:  BRA    2654
025CE:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
025D0:  MOVFF  72D,733
025D4:  MOVFF  72C,732
025D8:  MOVFF  72B,731
025DC:  MOVFF  72A,730
025E0:  RCALL  1EB0
025E2:  MOVFF  03,733
025E6:  MOVFF  02,732
025EA:  MOVFF  01,731
025EE:  MOVFF  00,730
025F2:  MOVFF  FEA,735
025F6:  MOVFF  FE9,734
025FA:  BSF    FD8.1
025FC:  MOVFF  03,755
02600:  MOVFF  02,754
02604:  MOVFF  01,753
02608:  MOVFF  00,752
0260C:  MOVLW  DB
0260E:  MOVLB  7
02610:  MOVWF  x59
02612:  MOVLW  0F
02614:  MOVWF  x58
02616:  MOVLW  49
02618:  MOVWF  x57
0261A:  MOVLW  80
0261C:  MOVWF  x56
0261E:  MOVLB  0
02620:  CALL   0E42
02624:  MOVFF  735,FEA
02628:  MOVFF  734,FE9
0262C:  MOVLB  7
0262E:  BRA    2654
....................             break;
02630:  BRA    2654
02632:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02634:  MOVFF  72D,733
02638:  MOVFF  72C,732
0263C:  MOVFF  72B,731
02640:  MOVFF  72A,730
02644:  RCALL  1EB0
02646:  MOVLW  80
02648:  XORWF  01,F
0264A:  MOVLB  7
0264C:  BRA    2654
....................             break;
0264E:  BRA    2654
02650:  MOVLB  0
02652:  MOVLB  7
....................          }
....................       }
....................    }
02654:  MOVLB  0
02656:  GOTO   3D60 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008B2:  MOVFF  738,FEA
008B6:  MOVLB  7
008B8:  MOVFF  737,FE9
008BC:  CLRF   x45
008BE:  MOVFF  FEF,744
008C2:  CLRF   x47
008C4:  MOVLW  04
008C6:  MOVWF  x46
008C8:  MOVLB  0
008CA:  RCALL  0864
008CC:  MOVF   01,W
008CE:  MOVLB  7
008D0:  ADDWF  x35,W
008D2:  MOVWF  FE9
008D4:  MOVF   x36,W
008D6:  ADDWFC 02,W
008D8:  MOVWF  FEA
008DA:  MOVFF  739,FEF
008DE:  MOVFF  73A,FEC
008E2:  MOVFF  73B,FEC
008E6:  MOVFF  73C,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
008EA:  MOVFF  738,73E
008EE:  MOVFF  738,FEA
008F2:  MOVFF  737,FE9
008F6:  MOVLW  01
008F8:  ADDWF  FEF,W
008FA:  MOVWF  x40
008FC:  MOVWF  x41
008FE:  MOVLW  05
00900:  MOVWF  x42
00902:  MOVLB  0
00904:  RCALL  0886
00906:  MOVLB  7
00908:  MOVFF  73E,FEA
0090C:  MOVFF  737,FE9
00910:  MOVFF  00,FEF
00914:  MOVLB  0
00916:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
010BA:  MOVLB  F
010BC:  BTFSC  x5B.0
010BE:  BRA    160A
....................       switch (state)
010C0:  MOVLB  1
010C2:  MOVF   xE6,W
010C4:  ADDLW  F9
010C6:  BTFSC  FD8.0
010C8:  BRA    1608
010CA:  ADDLW  07
010CC:  MOVLB  0
010CE:  GOTO   1610
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
010D2:  MOVLB  F
010D4:  BTFSC  x5B.0
010D6:  BRA    10D4
010D8:  MOVFF  F5F,02
010DC:  MOVFF  F5E,01
010E0:  MOVFF  02,704
010E4:  MOVFF  01,703
010E8:  MOVFF  02,753
010EC:  MOVFF  01,752
010F0:  MOVLB  0
010F2:  RCALL  0D16
010F4:  MOVFF  03,756
010F8:  MOVFF  02,755
010FC:  MOVFF  01,754
01100:  MOVFF  00,753
01104:  MOVFF  C9,75A
01108:  MOVFF  C8,759
0110C:  MOVFF  C7,758
01110:  MOVFF  C6,757
01114:  RCALL  0D4C
01116:  MOVFF  03,706
0111A:  MOVFF  02,705
0111E:  MOVFF  01,704
01122:  MOVFF  00,703
01126:  BCF    FD8.1
01128:  MOVFF  03,755
0112C:  MOVFF  02,754
01130:  MOVFF  01,753
01134:  MOVFF  00,752
01138:  MOVFF  C5,759
0113C:  MOVFF  C4,758
01140:  MOVFF  C3,757
01144:  MOVFF  C2,756
01148:  RCALL  0E42
0114A:  MOVFF  03,FE
0114E:  MOVFF  02,FD
01152:  MOVFF  01,FC
01156:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
0115A:  MOVLB  F
0115C:  MOVF   x5A,W
0115E:  ANDLW  3F
01160:  MOVWF  01
01162:  MOVLW  10
01164:  MOVWF  x5A
01166:  BTFSS  x5B.7
01168:  BRA    1178
0116A:  MOVF   01,W
0116C:  SUBLW  10
0116E:  BZ    1178
01170:  BSF    x5B.0
01172:  NOP   
01174:  BTFSC  x5B.0
01176:  BRA    1174
....................             delay_ms(10);
01178:  MOVLW  0A
0117A:  MOVLB  7
0117C:  MOVWF  x09
0117E:  MOVLB  0
01180:  CALL   042A
....................             read_adc(ADC_START_ONLY);
01184:  MOVLB  F
01186:  BSF    x5B.0
01188:  NOP   
....................             state = 1;
0118A:  MOVLW  01
0118C:  MOVLB  1
0118E:  MOVWF  xE6
....................          break;
01190:  BRA    1608
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
01192:  MOVLB  F
01194:  BTFSC  x5B.0
01196:  BRA    1194
01198:  MOVFF  F5F,02
0119C:  MOVFF  F5E,01
011A0:  MOVFF  02,704
011A4:  MOVFF  01,703
011A8:  MOVFF  02,753
011AC:  MOVFF  01,752
011B0:  MOVLB  0
011B2:  RCALL  0D16
011B4:  MOVFF  03,756
011B8:  MOVFF  02,755
011BC:  MOVFF  01,754
011C0:  MOVFF  00,753
011C4:  MOVFF  D1,75A
011C8:  MOVFF  D0,759
011CC:  MOVFF  CF,758
011D0:  MOVFF  CE,757
011D4:  RCALL  0D4C
011D6:  MOVFF  03,706
011DA:  MOVFF  02,705
011DE:  MOVFF  01,704
011E2:  MOVFF  00,703
011E6:  BCF    FD8.1
011E8:  MOVFF  03,755
011EC:  MOVFF  02,754
011F0:  MOVFF  01,753
011F4:  MOVFF  00,752
011F8:  MOVFF  CD,759
011FC:  MOVFF  CC,758
01200:  MOVFF  CB,757
01204:  MOVFF  CA,756
01208:  RCALL  0E42
0120A:  MOVFF  03,102
0120E:  MOVFF  02,101
01212:  MOVFF  01,100
01216:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
0121A:  MOVLB  F
0121C:  MOVF   x5A,W
0121E:  ANDLW  3F
01220:  MOVWF  01
01222:  MOVLW  18
01224:  MOVWF  x5A
01226:  BTFSS  x5B.7
01228:  BRA    1238
0122A:  MOVF   01,W
0122C:  SUBLW  18
0122E:  BZ    1238
01230:  BSF    x5B.0
01232:  NOP   
01234:  BTFSC  x5B.0
01236:  BRA    1234
....................             delay_ms(10);
01238:  MOVLW  0A
0123A:  MOVLB  7
0123C:  MOVWF  x09
0123E:  MOVLB  0
01240:  CALL   042A
....................             read_adc(ADC_START_ONLY);
01244:  MOVLB  F
01246:  BSF    x5B.0
01248:  NOP   
....................             state = 2;
0124A:  MOVLW  02
0124C:  MOVLB  1
0124E:  MOVWF  xE6
....................          break;
01250:  BRA    1608
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01252:  MOVLB  F
01254:  BTFSC  x5B.0
01256:  BRA    1254
01258:  MOVFF  F5F,02
0125C:  MOVFF  F5E,01
01260:  MOVFF  02,704
01264:  MOVFF  01,703
01268:  MOVFF  02,753
0126C:  MOVFF  01,752
01270:  MOVLB  0
01272:  RCALL  0D16
01274:  MOVFF  03,756
01278:  MOVFF  02,755
0127C:  MOVFF  01,754
01280:  MOVFF  00,753
01284:  MOVFF  D9,75A
01288:  MOVFF  D8,759
0128C:  MOVFF  D7,758
01290:  MOVFF  D6,757
01294:  RCALL  0D4C
01296:  MOVFF  03,706
0129A:  MOVFF  02,705
0129E:  MOVFF  01,704
012A2:  MOVFF  00,703
012A6:  BCF    FD8.1
012A8:  MOVFF  03,755
012AC:  MOVFF  02,754
012B0:  MOVFF  01,753
012B4:  MOVFF  00,752
012B8:  MOVFF  D5,759
012BC:  MOVFF  D4,758
012C0:  MOVFF  D3,757
012C4:  MOVFF  D2,756
012C8:  RCALL  0E42
012CA:  MOVFF  03,106
012CE:  MOVFF  02,105
012D2:  MOVFF  01,104
012D6:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
012DA:  MOVLB  F
012DC:  MOVF   x5A,W
012DE:  ANDLW  3F
012E0:  MOVWF  01
012E2:  MOVLW  19
012E4:  MOVWF  x5A
012E6:  BTFSS  x5B.7
012E8:  BRA    12F8
012EA:  MOVF   01,W
012EC:  SUBLW  19
012EE:  BZ    12F8
012F0:  BSF    x5B.0
012F2:  NOP   
012F4:  BTFSC  x5B.0
012F6:  BRA    12F4
....................             delay_ms(10);
012F8:  MOVLW  0A
012FA:  MOVLB  7
012FC:  MOVWF  x09
012FE:  MOVLB  0
01300:  CALL   042A
....................             read_adc(ADC_START_ONLY);
01304:  MOVLB  F
01306:  BSF    x5B.0
01308:  NOP   
....................             state = 3;
0130A:  MOVLW  03
0130C:  MOVLB  1
0130E:  MOVWF  xE6
....................          break;
01310:  BRA    1608
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01312:  MOVLB  F
01314:  BTFSC  x5B.0
01316:  BRA    1314
01318:  MOVFF  F5F,02
0131C:  MOVFF  F5E,01
01320:  MOVFF  02,704
01324:  MOVFF  01,703
01328:  MOVFF  02,753
0132C:  MOVFF  01,752
01330:  MOVLB  0
01332:  RCALL  0D16
01334:  MOVFF  03,756
01338:  MOVFF  02,755
0133C:  MOVFF  01,754
01340:  MOVFF  00,753
01344:  MOVFF  E1,75A
01348:  MOVFF  E0,759
0134C:  MOVFF  DF,758
01350:  MOVFF  DE,757
01354:  RCALL  0D4C
01356:  MOVFF  03,706
0135A:  MOVFF  02,705
0135E:  MOVFF  01,704
01362:  MOVFF  00,703
01366:  BCF    FD8.1
01368:  MOVFF  03,755
0136C:  MOVFF  02,754
01370:  MOVFF  01,753
01374:  MOVFF  00,752
01378:  MOVFF  DD,759
0137C:  MOVFF  DC,758
01380:  MOVFF  DB,757
01384:  MOVFF  DA,756
01388:  RCALL  0E42
0138A:  MOVFF  03,10A
0138E:  MOVFF  02,109
01392:  MOVFF  01,108
01396:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
0139A:  MOVLB  F
0139C:  MOVF   x5A,W
0139E:  ANDLW  3F
013A0:  MOVWF  01
013A2:  MOVLW  11
013A4:  MOVWF  x5A
013A6:  BTFSS  x5B.7
013A8:  BRA    13B8
013AA:  MOVF   01,W
013AC:  SUBLW  11
013AE:  BZ    13B8
013B0:  BSF    x5B.0
013B2:  NOP   
013B4:  BTFSC  x5B.0
013B6:  BRA    13B4
....................             delay_ms(10);
013B8:  MOVLW  0A
013BA:  MOVLB  7
013BC:  MOVWF  x09
013BE:  MOVLB  0
013C0:  CALL   042A
....................             read_adc(ADC_START_ONLY);
013C4:  MOVLB  F
013C6:  BSF    x5B.0
013C8:  NOP   
....................             state = 4;
013CA:  MOVLW  04
013CC:  MOVLB  1
013CE:  MOVWF  xE6
....................          break;
013D0:  BRA    1608
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
013D2:  MOVLB  F
013D4:  BTFSC  x5B.0
013D6:  BRA    13D4
013D8:  MOVFF  F5F,02
013DC:  MOVFF  F5E,01
013E0:  MOVFF  02,704
013E4:  MOVFF  01,703
013E8:  MOVFF  02,753
013EC:  MOVFF  01,752
013F0:  MOVLB  0
013F2:  RCALL  0D16
013F4:  MOVFF  03,756
013F8:  MOVFF  02,755
013FC:  MOVFF  01,754
01400:  MOVFF  00,753
01404:  MOVFF  E9,75A
01408:  MOVFF  E8,759
0140C:  MOVFF  E7,758
01410:  MOVFF  E6,757
01414:  RCALL  0D4C
01416:  MOVFF  03,706
0141A:  MOVFF  02,705
0141E:  MOVFF  01,704
01422:  MOVFF  00,703
01426:  BCF    FD8.1
01428:  MOVFF  03,755
0142C:  MOVFF  02,754
01430:  MOVFF  01,753
01434:  MOVFF  00,752
01438:  MOVFF  E5,759
0143C:  MOVFF  E4,758
01440:  MOVFF  E3,757
01444:  MOVFF  E2,756
01448:  RCALL  0E42
0144A:  MOVFF  03,10E
0144E:  MOVFF  02,10D
01452:  MOVFF  01,10C
01456:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
0145A:  MOVLB  F
0145C:  MOVF   x5A,W
0145E:  ANDLW  3F
01460:  MOVWF  01
01462:  MOVLW  1B
01464:  MOVWF  x5A
01466:  BTFSS  x5B.7
01468:  BRA    1478
0146A:  MOVF   01,W
0146C:  SUBLW  1B
0146E:  BZ    1478
01470:  BSF    x5B.0
01472:  NOP   
01474:  BTFSC  x5B.0
01476:  BRA    1474
....................             delay_ms(10);
01478:  MOVLW  0A
0147A:  MOVLB  7
0147C:  MOVWF  x09
0147E:  MOVLB  0
01480:  CALL   042A
....................             read_adc(ADC_START_ONLY);
01484:  MOVLB  F
01486:  BSF    x5B.0
01488:  NOP   
....................             state = 5;
0148A:  MOVLW  05
0148C:  MOVLB  1
0148E:  MOVWF  xE6
....................          break;
01490:  BRA    1608
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01492:  MOVLB  F
01494:  BTFSC  x5B.0
01496:  BRA    1494
01498:  MOVFF  F5F,02
0149C:  MOVFF  F5E,01
014A0:  MOVFF  02,704
014A4:  MOVFF  01,703
014A8:  MOVFF  02,753
014AC:  MOVFF  01,752
014B0:  MOVLB  0
014B2:  RCALL  0D16
014B4:  MOVFF  03,756
014B8:  MOVFF  02,755
014BC:  MOVFF  01,754
014C0:  MOVFF  00,753
014C4:  MOVFF  F1,75A
014C8:  MOVFF  F0,759
014CC:  MOVFF  EF,758
014D0:  MOVFF  EE,757
014D4:  RCALL  0D4C
014D6:  MOVFF  03,706
014DA:  MOVFF  02,705
014DE:  MOVFF  01,704
014E2:  MOVFF  00,703
014E6:  BCF    FD8.1
014E8:  MOVFF  03,755
014EC:  MOVFF  02,754
014F0:  MOVFF  01,753
014F4:  MOVFF  00,752
014F8:  MOVFF  ED,759
014FC:  MOVFF  EC,758
01500:  MOVFF  EB,757
01504:  MOVFF  EA,756
01508:  RCALL  0E42
0150A:  MOVFF  03,112
0150E:  MOVFF  02,111
01512:  MOVFF  01,110
01516:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
0151A:  MOVLB  F
0151C:  MOVF   x5A,W
0151E:  ANDLW  3F
01520:  MOVWF  01
01522:  MOVLW  1A
01524:  MOVWF  x5A
01526:  BTFSS  x5B.7
01528:  BRA    1538
0152A:  MOVF   01,W
0152C:  SUBLW  1A
0152E:  BZ    1538
01530:  BSF    x5B.0
01532:  NOP   
01534:  BTFSC  x5B.0
01536:  BRA    1534
....................             delay_ms(10);
01538:  MOVLW  0A
0153A:  MOVLB  7
0153C:  MOVWF  x09
0153E:  MOVLB  0
01540:  CALL   042A
....................             read_adc(ADC_START_ONLY);
01544:  MOVLB  F
01546:  BSF    x5B.0
01548:  NOP   
....................             state = 6;
0154A:  MOVLW  06
0154C:  MOVLB  1
0154E:  MOVWF  xE6
....................          break;
01550:  BRA    1608
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01552:  MOVLB  F
01554:  BTFSC  x5B.0
01556:  BRA    1554
01558:  MOVFF  F5F,02
0155C:  MOVFF  F5E,01
01560:  MOVFF  02,704
01564:  MOVFF  01,703
01568:  MOVFF  02,753
0156C:  MOVFF  01,752
01570:  MOVLB  0
01572:  CALL   0D16
01576:  MOVFF  03,756
0157A:  MOVFF  02,755
0157E:  MOVFF  01,754
01582:  MOVFF  00,753
01586:  MOVFF  F9,75A
0158A:  MOVFF  F8,759
0158E:  MOVFF  F7,758
01592:  MOVFF  F6,757
01596:  CALL   0D4C
0159A:  MOVFF  03,706
0159E:  MOVFF  02,705
015A2:  MOVFF  01,704
015A6:  MOVFF  00,703
015AA:  BCF    FD8.1
015AC:  MOVFF  03,755
015B0:  MOVFF  02,754
015B4:  MOVFF  01,753
015B8:  MOVFF  00,752
015BC:  MOVFF  F5,759
015C0:  MOVFF  F4,758
015C4:  MOVFF  F3,757
015C8:  MOVFF  F2,756
015CC:  RCALL  0E42
015CE:  MOVFF  03,116
015D2:  MOVFF  02,115
015D6:  MOVFF  01,114
015DA:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
015DE:  MOVLB  F
015E0:  MOVF   x5A,W
015E2:  ANDLW  3F
015E4:  MOVWF  01
015E6:  MOVLW  06
015E8:  MOVWF  x5A
015EA:  BTFSS  x5B.7
015EC:  BRA    15FC
015EE:  MOVF   01,W
015F0:  SUBLW  06
015F2:  BZ    15FC
015F4:  BSF    x5B.0
015F6:  NOP   
015F8:  BTFSC  x5B.0
015FA:  BRA    15F8
....................             read_adc(ADC_START_ONLY);
015FC:  BSF    x5B.0
015FE:  NOP   
....................             state = 0;
01600:  MOVLB  1
01602:  CLRF   xE6
....................          break;   
01604:  BRA    1608
01606:  MOVLB  1
01608:  MOVLB  F
....................       }
....................    }
0160A:  MOVLB  0
0160C:  GOTO   A95A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
036B8:  MOVLB  7
036BA:  MOVF   x0B,W
036BC:  MULLW  26
036BE:  MOVF   FF3,W
036C0:  CLRF   x15
036C2:  MOVWF  x14
036C4:  MOVLW  10
036C6:  ADDWF  x14,W
036C8:  MOVWF  01
036CA:  MOVLW  00
036CC:  ADDWFC x15,W
036CE:  MOVWF  03
036D0:  MOVF   01,W
036D2:  ADDLW  17
036D4:  MOVWF  01
036D6:  MOVLW  01
036D8:  ADDWFC 03,F
036DA:  MOVFF  01,714
036DE:  MOVFF  03,715
036E2:  MOVF   x0B,W
036E4:  MULLW  26
036E6:  MOVF   FF3,W
036E8:  CLRF   x17
036EA:  MOVWF  x16
036EC:  MOVLW  08
036EE:  ADDWF  x16,W
036F0:  MOVWF  01
036F2:  MOVLW  00
036F4:  ADDWFC x17,W
036F6:  MOVWF  03
036F8:  MOVF   01,W
036FA:  ADDLW  17
036FC:  MOVWF  FE9
036FE:  MOVLW  01
03700:  ADDWFC 03,W
03702:  MOVWF  FEA
03704:  MOVFF  FEF,00
03708:  MOVFF  FEC,01
0370C:  MOVFF  FEC,02
03710:  MOVFF  FEC,03
03714:  MOVFF  715,FEA
03718:  MOVFF  714,FE9
0371C:  MOVFF  00,FEF
03720:  MOVFF  01,FEC
03724:  MOVFF  02,FEC
03728:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
0372C:  MOVF   x0B,W
0372E:  MULLW  26
03730:  MOVF   FF3,W
03732:  CLRF   x15
03734:  MOVWF  x14
03736:  MOVLW  14
03738:  ADDWF  x14,W
0373A:  MOVWF  01
0373C:  MOVLW  00
0373E:  ADDWFC x15,W
03740:  MOVWF  03
03742:  MOVF   01,W
03744:  ADDLW  17
03746:  MOVWF  01
03748:  MOVLW  01
0374A:  ADDWFC 03,F
0374C:  MOVFF  01,714
03750:  MOVFF  03,715
03754:  MOVF   x0B,W
03756:  MULLW  26
03758:  MOVF   FF3,W
0375A:  CLRF   x17
0375C:  MOVWF  x16
0375E:  MOVLW  0C
03760:  ADDWF  x16,W
03762:  MOVWF  01
03764:  MOVLW  00
03766:  ADDWFC x17,W
03768:  MOVWF  03
0376A:  MOVF   01,W
0376C:  ADDLW  17
0376E:  MOVWF  FE9
03770:  MOVLW  01
03772:  ADDWFC 03,W
03774:  MOVWF  FEA
03776:  MOVFF  FEF,00
0377A:  MOVFF  FEC,01
0377E:  MOVFF  FEC,02
03782:  MOVFF  FEC,03
03786:  MOVFF  715,FEA
0378A:  MOVFF  714,FE9
0378E:  MOVFF  00,FEF
03792:  MOVFF  01,FEC
03796:  MOVFF  02,FEC
0379A:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
0379E:  MOVF   x0B,W
037A0:  MULLW  26
037A2:  MOVF   FF3,W
037A4:  CLRF   x15
037A6:  MOVWF  x14
037A8:  MOVLW  17
037AA:  ADDWF  x14,W
037AC:  MOVWF  01
037AE:  MOVLW  01
037B0:  ADDWFC x15,W
037B2:  MOVWF  03
037B4:  MOVFF  01,716
037B8:  MOVWF  x17
037BA:  MOVF   x0B,W
037BC:  MULLW  09
037BE:  MOVF   FF3,W
037C0:  CLRF   x19
037C2:  MOVWF  x18
037C4:  MOVLW  01
037C6:  ADDWF  x18,W
037C8:  MOVWF  01
037CA:  MOVLW  00
037CC:  ADDWFC x19,W
037CE:  MOVWF  03
037D0:  MOVF   01,W
037D2:  ADDLW  D4
037D4:  MOVWF  FE9
037D6:  MOVLW  01
037D8:  ADDWFC 03,W
037DA:  MOVWF  FEA
037DC:  MOVFF  FEF,718
037E0:  MOVFF  FEC,01
037E4:  MOVFF  FEC,02
037E8:  MOVFF  FEC,03
037EC:  MOVFF  03,71B
037F0:  MOVFF  02,71A
037F4:  MOVFF  01,719
037F8:  MOVLB  0
037FA:  CALL   1C7E
037FE:  MOVFF  717,FEA
03802:  MOVFF  716,FE9
03806:  MOVFF  00,FEF
0380A:  MOVFF  01,FEC
0380E:  MOVFF  02,FEC
03812:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03816:  MOVLB  7
03818:  MOVF   x0B,W
0381A:  MULLW  26
0381C:  MOVF   FF3,W
0381E:  CLRF   x15
03820:  MOVWF  x14
03822:  MOVLW  04
03824:  ADDWF  x14,W
03826:  MOVWF  01
03828:  MOVLW  00
0382A:  ADDWFC x15,W
0382C:  MOVWF  03
0382E:  MOVF   01,W
03830:  ADDLW  17
03832:  MOVWF  01
03834:  MOVLW  01
03836:  ADDWFC 03,F
03838:  MOVFF  01,714
0383C:  MOVFF  03,715
03840:  MOVF   x0B,W
03842:  MULLW  09
03844:  MOVF   FF3,W
03846:  CLRF   x17
03848:  MOVWF  x16
0384A:  MOVLW  05
0384C:  ADDWF  x16,W
0384E:  MOVWF  01
03850:  MOVLW  00
03852:  ADDWFC x17,W
03854:  MOVWF  03
03856:  MOVF   01,W
03858:  ADDLW  D4
0385A:  MOVWF  FE9
0385C:  MOVLW  01
0385E:  ADDWFC 03,W
03860:  MOVWF  FEA
03862:  MOVFF  FEF,718
03866:  MOVFF  FEC,01
0386A:  MOVFF  FEC,02
0386E:  MOVFF  FEC,03
03872:  MOVFF  03,71B
03876:  MOVFF  02,71A
0387A:  MOVFF  01,719
0387E:  MOVLB  0
03880:  CALL   1C7E
03884:  MOVFF  715,FEA
03888:  MOVFF  714,FE9
0388C:  MOVFF  00,FEF
03890:  MOVFF  01,FEC
03894:  MOVFF  02,FEC
03898:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
0389C:  MOVLB  7
0389E:  MOVF   x0B,W
038A0:  MULLW  26
038A2:  MOVF   FF3,W
038A4:  CLRF   x15
038A6:  MOVWF  x14
038A8:  MOVLW  08
038AA:  ADDWF  x14,W
038AC:  MOVWF  01
038AE:  MOVLW  00
038B0:  ADDWFC x15,W
038B2:  MOVWF  03
038B4:  MOVF   01,W
038B6:  ADDLW  17
038B8:  MOVWF  01
038BA:  MOVLW  01
038BC:  ADDWFC 03,F
038BE:  MOVFF  01,714
038C2:  MOVFF  03,715
038C6:  MOVF   x0B,W
038C8:  MULLW  26
038CA:  MOVF   FF3,W
038CC:  CLRF   x17
038CE:  MOVWF  x16
038D0:  MOVLW  17
038D2:  ADDWF  x16,W
038D4:  MOVWF  FE9
038D6:  MOVLW  01
038D8:  ADDWFC x17,W
038DA:  MOVWF  FEA
038DC:  MOVFF  FEF,753
038E0:  MOVFF  FEC,754
038E4:  MOVFF  FEC,755
038E8:  MOVFF  FEC,756
038EC:  MOVF   x0B,W
038EE:  MULLW  10
038F0:  MOVF   FF3,W
038F2:  CLRF   x1D
038F4:  MOVWF  x1C
038F6:  MOVLW  08
038F8:  ADDWF  x1C,W
038FA:  MOVWF  01
038FC:  MOVLW  00
038FE:  ADDWFC x1D,W
03900:  MOVWF  03
03902:  MOVF   01,W
03904:  ADDLW  72
03906:  MOVWF  FE9
03908:  MOVLW  00
0390A:  ADDWFC 03,W
0390C:  MOVWF  FEA
0390E:  MOVFF  FEF,757
03912:  MOVFF  FEC,01
03916:  MOVFF  FEC,02
0391A:  MOVFF  FEC,03
0391E:  MOVFF  03,75A
03922:  MOVFF  02,759
03926:  MOVFF  01,758
0392A:  MOVLB  0
0392C:  CALL   0D4C
03930:  MOVFF  03,755
03934:  MOVFF  02,754
03938:  MOVFF  01,753
0393C:  MOVFF  00,752
03940:  MOVLB  7
03942:  MOVF   x0B,W
03944:  MULLW  10
03946:  MOVF   FF3,W
03948:  CLRF   x1D
0394A:  MOVWF  x1C
0394C:  MOVLW  72
0394E:  ADDWF  x1C,W
03950:  MOVWF  FE9
03952:  MOVLW  00
03954:  ADDWFC x1D,W
03956:  MOVWF  FEA
03958:  MOVFF  FEF,756
0395C:  MOVFF  FEC,01
03960:  MOVFF  FEC,02
03964:  MOVFF  FEC,03
03968:  BCF    FD8.1
0396A:  MOVFF  03,759
0396E:  MOVFF  02,758
03972:  MOVFF  01,757
03976:  MOVLB  0
03978:  CALL   0E42
0397C:  MOVFF  715,FEA
03980:  MOVFF  714,FE9
03984:  MOVFF  00,FEF
03988:  MOVFF  01,FEC
0398C:  MOVFF  02,FEC
03990:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
03994:  MOVLB  7
03996:  MOVF   x0B,W
03998:  MULLW  26
0399A:  MOVF   FF3,W
0399C:  CLRF   x15
0399E:  MOVWF  x14
039A0:  MOVLW  0C
039A2:  ADDWF  x14,W
039A4:  MOVWF  01
039A6:  MOVLW  00
039A8:  ADDWFC x15,W
039AA:  MOVWF  03
039AC:  MOVF   01,W
039AE:  ADDLW  17
039B0:  MOVWF  01
039B2:  MOVLW  01
039B4:  ADDWFC 03,F
039B6:  MOVFF  01,714
039BA:  MOVFF  03,715
039BE:  MOVF   x0B,W
039C0:  MULLW  26
039C2:  MOVF   FF3,W
039C4:  CLRF   x17
039C6:  MOVWF  x16
039C8:  MOVLW  04
039CA:  ADDWF  x16,W
039CC:  MOVWF  01
039CE:  MOVLW  00
039D0:  ADDWFC x17,W
039D2:  MOVWF  03
039D4:  MOVF   01,W
039D6:  ADDLW  17
039D8:  MOVWF  FE9
039DA:  MOVLW  01
039DC:  ADDWFC 03,W
039DE:  MOVWF  FEA
039E0:  MOVFF  FEF,753
039E4:  MOVFF  FEC,754
039E8:  MOVFF  FEC,755
039EC:  MOVFF  FEC,756
039F0:  MOVF   x0B,W
039F2:  MULLW  10
039F4:  MOVF   FF3,W
039F6:  CLRF   x1B
039F8:  MOVWF  x1A
039FA:  MOVLW  0C
039FC:  ADDWF  x1A,W
039FE:  MOVWF  01
03A00:  MOVLW  00
03A02:  ADDWFC x1B,W
03A04:  MOVWF  03
03A06:  MOVF   01,W
03A08:  ADDLW  72
03A0A:  MOVWF  FE9
03A0C:  MOVLW  00
03A0E:  ADDWFC 03,W
03A10:  MOVWF  FEA
03A12:  MOVFF  FEF,757
03A16:  MOVFF  FEC,01
03A1A:  MOVFF  FEC,02
03A1E:  MOVFF  FEC,03
03A22:  MOVFF  03,75A
03A26:  MOVFF  02,759
03A2A:  MOVFF  01,758
03A2E:  MOVLB  0
03A30:  CALL   0D4C
03A34:  MOVFF  03,755
03A38:  MOVFF  02,754
03A3C:  MOVFF  01,753
03A40:  MOVFF  00,752
03A44:  MOVLB  7
03A46:  MOVF   x0B,W
03A48:  MULLW  10
03A4A:  MOVF   FF3,W
03A4C:  CLRF   x1B
03A4E:  MOVWF  x1A
03A50:  MOVLW  04
03A52:  ADDWF  x1A,W
03A54:  MOVWF  01
03A56:  MOVLW  00
03A58:  ADDWFC x1B,W
03A5A:  MOVWF  03
03A5C:  MOVF   01,W
03A5E:  ADDLW  72
03A60:  MOVWF  FE9
03A62:  MOVLW  00
03A64:  ADDWFC 03,W
03A66:  MOVWF  FEA
03A68:  MOVFF  FEF,756
03A6C:  MOVFF  FEC,01
03A70:  MOVFF  FEC,02
03A74:  MOVFF  FEC,03
03A78:  BCF    FD8.1
03A7A:  MOVFF  03,759
03A7E:  MOVFF  02,758
03A82:  MOVFF  01,757
03A86:  MOVLB  0
03A88:  CALL   0E42
03A8C:  MOVFF  715,FEA
03A90:  MOVFF  714,FE9
03A94:  MOVFF  00,FEF
03A98:  MOVFF  01,FEC
03A9C:  MOVFF  02,FEC
03AA0:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AA4:  MOVLB  7
03AA6:  CLRF   x0F
03AA8:  CLRF   x0E
03AAA:  CLRF   x0D
03AAC:  CLRF   x0C
03AAE:  CLRF   x13
03AB0:  CLRF   x12
03AB2:  CLRF   x11
03AB4:  MOVLW  7F
03AB6:  MOVWF  x10
....................    
....................    if (adcVals[ch].cosCounts < 0){
03AB8:  MOVF   x0B,W
03ABA:  MULLW  26
03ABC:  MOVF   FF3,W
03ABE:  CLRF   x15
03AC0:  MOVWF  x14
03AC2:  MOVLW  0C
03AC4:  ADDWF  x14,W
03AC6:  MOVWF  01
03AC8:  MOVLW  00
03ACA:  ADDWFC x15,W
03ACC:  MOVWF  03
03ACE:  MOVF   01,W
03AD0:  ADDLW  17
03AD2:  MOVWF  FE9
03AD4:  MOVLW  01
03AD6:  ADDWFC 03,W
03AD8:  MOVWF  FEA
03ADA:  MOVFF  FEF,74E
03ADE:  MOVFF  FEC,74F
03AE2:  MOVFF  FEC,750
03AE6:  MOVFF  FEC,751
03AEA:  CLRF   x55
03AEC:  CLRF   x54
03AEE:  CLRF   x53
03AF0:  CLRF   x52
03AF2:  MOVLB  0
03AF4:  CALL   1CD8
03AF8:  BTFSS  FD8.0
03AFA:  BRA    3C64
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03AFC:  MOVLB  7
03AFE:  MOVF   x0B,W
03B00:  MULLW  26
03B02:  MOVF   FF3,W
03B04:  CLRF   x15
03B06:  MOVWF  x14
03B08:  MOVLW  08
03B0A:  ADDWF  x14,W
03B0C:  MOVWF  01
03B0E:  MOVLW  00
03B10:  ADDWFC x15,W
03B12:  MOVWF  03
03B14:  MOVF   01,W
03B16:  ADDLW  17
03B18:  MOVWF  FE9
03B1A:  MOVLW  01
03B1C:  ADDWFC 03,W
03B1E:  MOVWF  FEA
03B20:  MOVFF  FEF,752
03B24:  MOVFF  FEC,715
03B28:  MOVFF  FEC,754
03B2C:  MOVFF  FEC,755
03B30:  CLRF   x51
03B32:  CLRF   x50
03B34:  CLRF   x4F
03B36:  CLRF   x4E
03B38:  MOVFF  715,753
03B3C:  MOVLB  0
03B3E:  CALL   1CD8
03B42:  BNC   3BB0
03B44:  MOVLB  7
03B46:  MOVF   x0B,W
03B48:  MULLW  26
03B4A:  MOVF   FF3,W
03B4C:  CLRF   x15
03B4E:  MOVWF  x14
03B50:  MOVLW  10
03B52:  ADDWF  x14,W
03B54:  MOVWF  01
03B56:  MOVLW  00
03B58:  ADDWFC x15,W
03B5A:  MOVWF  03
03B5C:  MOVF   01,W
03B5E:  ADDLW  17
03B60:  MOVWF  FE9
03B62:  MOVLW  01
03B64:  ADDWFC 03,W
03B66:  MOVWF  FEA
03B68:  MOVFF  FEF,74E
03B6C:  MOVFF  FEC,74F
03B70:  MOVFF  FEC,750
03B74:  MOVFF  FEC,751
03B78:  CLRF   x55
03B7A:  CLRF   x54
03B7C:  CLRF   x53
03B7E:  CLRF   x52
03B80:  MOVLB  0
03B82:  CALL   1CD8
03B86:  BNC   3BB0
....................          adcVals[ch].npoles--;
03B88:  MOVLB  7
03B8A:  MOVF   x0B,W
03B8C:  MULLW  26
03B8E:  MOVF   FF3,W
03B90:  CLRF   x15
03B92:  MOVWF  x14
03B94:  MOVLW  1C
03B96:  ADDWF  x14,W
03B98:  MOVWF  01
03B9A:  MOVLW  00
03B9C:  ADDWFC x15,W
03B9E:  MOVWF  03
03BA0:  MOVF   01,W
03BA2:  ADDLW  17
03BA4:  MOVWF  FE9
03BA6:  MOVLW  01
03BA8:  ADDWFC 03,W
03BAA:  MOVWF  FEA
03BAC:  DECF   FEF,F
....................       }
03BAE:  BRA    3C62
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03BB0:  MOVLB  7
03BB2:  MOVF   x0B,W
03BB4:  MULLW  26
03BB6:  MOVF   FF3,W
03BB8:  CLRF   x15
03BBA:  MOVWF  x14
03BBC:  MOVLW  08
03BBE:  ADDWF  x14,W
03BC0:  MOVWF  01
03BC2:  MOVLW  00
03BC4:  ADDWFC x15,W
03BC6:  MOVWF  03
03BC8:  MOVF   01,W
03BCA:  ADDLW  17
03BCC:  MOVWF  FE9
03BCE:  MOVLW  01
03BD0:  ADDWFC 03,W
03BD2:  MOVWF  FEA
03BD4:  MOVFF  FEF,74E
03BD8:  MOVFF  FEC,715
03BDC:  MOVFF  FEC,750
03BE0:  MOVFF  FEC,751
03BE4:  MOVFF  715,74F
03BE8:  CLRF   x55
03BEA:  CLRF   x54
03BEC:  CLRF   x53
03BEE:  CLRF   x52
03BF0:  MOVLB  0
03BF2:  CALL   1CD8
03BF6:  BNC   3C64
03BF8:  MOVLB  7
03BFA:  MOVF   x0B,W
03BFC:  MULLW  26
03BFE:  MOVF   FF3,W
03C00:  CLRF   x15
03C02:  MOVWF  x14
03C04:  MOVLW  10
03C06:  ADDWF  x14,W
03C08:  MOVWF  01
03C0A:  MOVLW  00
03C0C:  ADDWFC x15,W
03C0E:  MOVWF  03
03C10:  MOVF   01,W
03C12:  ADDLW  17
03C14:  MOVWF  FE9
03C16:  MOVLW  01
03C18:  ADDWFC 03,W
03C1A:  MOVWF  FEA
03C1C:  MOVFF  FEF,752
03C20:  MOVFF  FEC,753
03C24:  MOVFF  FEC,754
03C28:  MOVFF  FEC,755
03C2C:  CLRF   x51
03C2E:  CLRF   x50
03C30:  CLRF   x4F
03C32:  CLRF   x4E
03C34:  MOVLB  0
03C36:  CALL   1CD8
03C3A:  BNC   3C64
....................          adcVals[ch].npoles++;
03C3C:  MOVLB  7
03C3E:  MOVF   x0B,W
03C40:  MULLW  26
03C42:  MOVF   FF3,W
03C44:  CLRF   x15
03C46:  MOVWF  x14
03C48:  MOVLW  1C
03C4A:  ADDWF  x14,W
03C4C:  MOVWF  01
03C4E:  MOVLW  00
03C50:  ADDWFC x15,W
03C52:  MOVWF  03
03C54:  MOVF   01,W
03C56:  ADDLW  17
03C58:  MOVWF  FE9
03C5A:  MOVLW  01
03C5C:  ADDWFC 03,W
03C5E:  MOVWF  FEA
03C60:  INCF   FEF,F
03C62:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03C64:  MOVLB  7
03C66:  MOVF   x0B,W
03C68:  MULLW  26
03C6A:  MOVF   FF3,W
03C6C:  CLRF   x15
03C6E:  MOVWF  x14
03C70:  MOVLW  18
03C72:  ADDWF  x14,W
03C74:  MOVWF  01
03C76:  MOVLW  00
03C78:  ADDWFC x15,W
03C7A:  MOVWF  03
03C7C:  MOVF   01,W
03C7E:  ADDLW  17
03C80:  MOVWF  01
03C82:  MOVLW  01
03C84:  ADDWFC 03,F
03C86:  MOVFF  01,714
03C8A:  MOVFF  03,715
03C8E:  MOVFF  713,756
03C92:  MOVFF  712,755
03C96:  MOVFF  711,754
03C9A:  MOVFF  710,753
03C9E:  MOVLW  AA
03CA0:  MOVWF  x5A
03CA2:  MOVLW  27
03CA4:  MOVWF  x59
03CA6:  MOVLW  1F
03CA8:  MOVWF  x58
03CAA:  MOVLW  86
03CAC:  MOVWF  x57
03CAE:  MOVLB  0
03CB0:  CALL   0D4C
03CB4:  MOVFF  03,719
03CB8:  MOVFF  02,718
03CBC:  MOVFF  01,717
03CC0:  MOVFF  00,716
03CC4:  MOVLB  7
03CC6:  MOVF   x0B,W
03CC8:  MULLW  26
03CCA:  MOVF   FF3,W
03CCC:  CLRF   x1B
03CCE:  MOVWF  x1A
03CD0:  MOVLW  08
03CD2:  ADDWF  x1A,W
03CD4:  MOVWF  01
03CD6:  MOVLW  00
03CD8:  ADDWFC x1B,W
03CDA:  MOVWF  03
03CDC:  MOVF   01,W
03CDE:  ADDLW  17
03CE0:  MOVWF  FE9
03CE2:  MOVLW  01
03CE4:  ADDWFC 03,W
03CE6:  MOVWF  FEA
03CE8:  MOVFF  FEF,71A
03CEC:  MOVFF  FEC,71B
03CF0:  MOVFF  FEC,71C
03CF4:  MOVFF  FEC,71D
03CF8:  MOVF   x0B,W
03CFA:  MULLW  26
03CFC:  MOVF   FF3,W
03CFE:  CLRF   x1F
03D00:  MOVWF  x1E
03D02:  MOVLW  0C
03D04:  ADDWF  x1E,W
03D06:  MOVWF  01
03D08:  MOVLW  00
03D0A:  ADDWFC x1F,W
03D0C:  MOVWF  03
03D0E:  MOVF   01,W
03D10:  ADDLW  17
03D12:  MOVWF  FE9
03D14:  MOVLW  01
03D16:  ADDWFC 03,W
03D18:  MOVWF  FEA
03D1A:  MOVFF  FEF,00
03D1E:  MOVFF  FEC,01
03D22:  MOVFF  FEC,02
03D26:  MOVFF  FEC,03
03D2A:  MOVFF  03,721
03D2E:  MOVFF  02,720
03D32:  MOVFF  01,71F
03D36:  MOVFF  00,71E
03D3A:  MOVFF  71D,725
03D3E:  MOVFF  71C,724
03D42:  MOVFF  71B,723
03D46:  MOVFF  71A,722
03D4A:  MOVFF  03,729
03D4E:  MOVFF  02,728
03D52:  MOVFF  01,727
03D56:  MOVFF  00,726
03D5A:  MOVLB  0
03D5C:  GOTO   23DA
03D60:  MOVFF  719,756
03D64:  MOVFF  718,755
03D68:  MOVFF  717,754
03D6C:  MOVFF  716,753
03D70:  MOVFF  03,75A
03D74:  MOVFF  02,759
03D78:  MOVFF  01,758
03D7C:  MOVFF  00,757
03D80:  CALL   0D4C
03D84:  MOVFF  715,FEA
03D88:  MOVFF  714,FE9
03D8C:  MOVFF  00,FEF
03D90:  MOVFF  01,FEC
03D94:  MOVFF  02,FEC
03D98:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03D9C:  MOVLB  7
03D9E:  MOVF   x0B,W
03DA0:  MULLW  26
03DA2:  MOVF   FF3,W
03DA4:  CLRF   x15
03DA6:  MOVWF  x14
03DA8:  MOVLW  18
03DAA:  ADDWF  x14,W
03DAC:  MOVWF  01
03DAE:  MOVLW  00
03DB0:  ADDWFC x15,W
03DB2:  MOVWF  03
03DB4:  MOVF   01,W
03DB6:  ADDLW  17
03DB8:  MOVWF  FE9
03DBA:  MOVLW  01
03DBC:  ADDWFC 03,W
03DBE:  MOVWF  FEA
03DC0:  MOVFF  FEF,714
03DC4:  MOVFF  FEC,715
03DC8:  MOVFF  FEC,716
03DCC:  MOVFF  FEC,717
03DD0:  CLRF   x56
03DD2:  CLRF   x55
03DD4:  MOVLW  7A
03DD6:  MOVWF  x54
03DD8:  MOVLW  88
03DDA:  MOVWF  x53
03DDC:  MOVFF  713,75A
03DE0:  MOVFF  712,759
03DE4:  MOVFF  711,758
03DE8:  MOVFF  710,757
03DEC:  MOVLB  0
03DEE:  CALL   0D4C
03DF2:  MOVFF  03,71B
03DF6:  MOVFF  02,71A
03DFA:  MOVFF  01,719
03DFE:  MOVFF  00,718
03E02:  MOVLB  7
03E04:  MOVF   x0B,W
03E06:  MULLW  26
03E08:  MOVF   FF3,W
03E0A:  CLRF   x1D
03E0C:  MOVWF  x1C
03E0E:  MOVLW  1C
03E10:  ADDWF  x1C,W
03E12:  MOVWF  01
03E14:  MOVLW  00
03E16:  ADDWFC x1D,W
03E18:  MOVWF  03
03E1A:  MOVF   01,W
03E1C:  ADDLW  17
03E1E:  MOVWF  FE9
03E20:  MOVLW  01
03E22:  ADDWFC 03,W
03E24:  MOVWF  FEA
03E26:  MOVF   FEF,W
03E28:  CLRF   x45
03E2A:  MOVWF  x44
03E2C:  BTFSC  x44.7
03E2E:  DECF   x45,F
03E30:  MOVLB  0
03E32:  CALL   267C
03E36:  MOVFF  71B,756
03E3A:  MOVFF  71A,755
03E3E:  MOVFF  719,754
03E42:  MOVFF  718,753
03E46:  MOVFF  03,75A
03E4A:  MOVFF  02,759
03E4E:  MOVFF  01,758
03E52:  MOVFF  00,757
03E56:  CALL   0D4C
03E5A:  MOVFF  FEA,719
03E5E:  MOVFF  FE9,718
03E62:  BCF    FD8.1
03E64:  MOVFF  717,755
03E68:  MOVFF  716,754
03E6C:  MOVFF  715,753
03E70:  MOVFF  714,752
03E74:  MOVFF  03,759
03E78:  MOVFF  02,758
03E7C:  MOVFF  01,757
03E80:  MOVFF  00,756
03E84:  CALL   0E42
03E88:  MOVFF  719,FEA
03E8C:  MOVFF  718,FE9
03E90:  MOVFF  03,70F
03E94:  MOVFF  02,70E
03E98:  MOVFF  01,70D
03E9C:  MOVFF  00,70C
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EA0:  MOVLB  7
03EA2:  MOVF   x0B,W
03EA4:  MULLW  26
03EA6:  MOVF   FF3,W
03EA8:  CLRF   x15
03EAA:  MOVWF  x14
03EAC:  MOVLW  1D
03EAE:  ADDWF  x14,W
03EB0:  MOVWF  01
03EB2:  MOVLW  00
03EB4:  ADDWFC x15,W
03EB6:  MOVWF  03
03EB8:  MOVF   01,W
03EBA:  ADDLW  17
03EBC:  MOVWF  01
03EBE:  MOVLW  01
03EC0:  ADDWFC 03,F
03EC2:  MOVFF  01,714
03EC6:  MOVFF  03,715
03ECA:  MOVF   x0B,W
03ECC:  MULLW  18
03ECE:  MOVF   FF3,W
03ED0:  CLRF   x17
03ED2:  MOVWF  x16
03ED4:  MOVLW  14
03ED6:  ADDWF  x16,W
03ED8:  MOVWF  01
03EDA:  MOVLW  00
03EDC:  ADDWFC x17,W
03EDE:  MOVWF  03
03EE0:  MOVF   01,W
03EE2:  ADDLW  92
03EE4:  MOVWF  FE9
03EE6:  MOVLW  00
03EE8:  ADDWFC 03,W
03EEA:  MOVWF  FEA
03EEC:  MOVFF  FEF,757
03EF0:  MOVFF  FEC,01
03EF4:  MOVFF  FEC,02
03EF8:  MOVFF  FEC,03
03EFC:  MOVFF  70F,756
03F00:  MOVFF  70E,755
03F04:  MOVFF  70D,754
03F08:  MOVFF  70C,753
03F0C:  MOVFF  03,75A
03F10:  MOVFF  02,759
03F14:  MOVFF  01,758
03F18:  MOVLB  0
03F1A:  CALL   0D4C
03F1E:  MOVFF  03,719
03F22:  MOVFF  02,718
03F26:  MOVFF  01,717
03F2A:  MOVFF  00,716
03F2E:  MOVFF  03,725
03F32:  MOVFF  02,724
03F36:  MOVFF  01,723
03F3A:  MOVFF  00,722
03F3E:  MOVLB  7
03F40:  CLRF   x29
03F42:  CLRF   x28
03F44:  MOVLW  20
03F46:  MOVWF  x27
03F48:  MOVLW  81
03F4A:  MOVWF  x26
03F4C:  MOVLB  0
03F4E:  CALL   33BA
03F52:  MOVFF  03,719
03F56:  MOVFF  02,718
03F5A:  MOVFF  01,717
03F5E:  MOVFF  00,716
03F62:  MOVLB  7
03F64:  MOVF   x0B,W
03F66:  MULLW  18
03F68:  MOVF   FF3,W
03F6A:  CLRF   x1B
03F6C:  MOVWF  x1A
03F6E:  MOVLW  10
03F70:  ADDWF  x1A,W
03F72:  MOVWF  01
03F74:  MOVLW  00
03F76:  ADDWFC x1B,W
03F78:  MOVWF  03
03F7A:  MOVF   01,W
03F7C:  ADDLW  92
03F7E:  MOVWF  FE9
03F80:  MOVLW  00
03F82:  ADDWFC 03,W
03F84:  MOVWF  FEA
03F86:  MOVFF  FEF,757
03F8A:  MOVFF  FEC,01
03F8E:  MOVFF  FEC,02
03F92:  MOVFF  FEC,03
03F96:  MOVFF  70F,756
03F9A:  MOVFF  70E,755
03F9E:  MOVFF  70D,754
03FA2:  MOVFF  70C,753
03FA6:  MOVFF  03,75A
03FAA:  MOVFF  02,759
03FAE:  MOVFF  01,758
03FB2:  MOVLB  0
03FB4:  CALL   0D4C
03FB8:  MOVFF  03,71D
03FBC:  MOVFF  02,71C
03FC0:  MOVFF  01,71B
03FC4:  MOVFF  00,71A
03FC8:  MOVFF  03,725
03FCC:  MOVFF  02,724
03FD0:  MOVFF  01,723
03FD4:  MOVFF  00,722
03FD8:  MOVLB  7
03FDA:  CLRF   x29
03FDC:  CLRF   x28
03FDE:  CLRF   x27
03FE0:  MOVLW  81
03FE2:  MOVWF  x26
03FE4:  MOVLB  0
03FE6:  CALL   33BA
03FEA:  MOVFF  FEA,71B
03FEE:  MOVFF  FE9,71A
03FF2:  BCF    FD8.1
03FF4:  MOVFF  719,755
03FF8:  MOVFF  718,754
03FFC:  MOVFF  717,753
04000:  MOVFF  716,752
04004:  MOVFF  03,759
04008:  MOVFF  02,758
0400C:  MOVFF  01,757
04010:  MOVFF  00,756
04014:  CALL   0E42
04018:  MOVFF  71B,FEA
0401C:  MOVFF  71A,FE9
04020:  MOVFF  03,719
04024:  MOVFF  02,718
04028:  MOVFF  01,717
0402C:  MOVFF  00,716
04030:  MOVLB  7
04032:  MOVF   x0B,W
04034:  MULLW  18
04036:  MOVF   FF3,W
04038:  CLRF   x1D
0403A:  MOVWF  x1C
0403C:  MOVLW  0C
0403E:  ADDWF  x1C,W
04040:  MOVWF  01
04042:  MOVLW  00
04044:  ADDWFC x1D,W
04046:  MOVWF  03
04048:  MOVF   01,W
0404A:  ADDLW  92
0404C:  MOVWF  FE9
0404E:  MOVLW  00
04050:  ADDWFC 03,W
04052:  MOVWF  FEA
04054:  MOVFF  FEF,757
04058:  MOVFF  FEC,01
0405C:  MOVFF  FEC,02
04060:  MOVFF  FEC,03
04064:  MOVFF  70F,756
04068:  MOVFF  70E,755
0406C:  MOVFF  70D,754
04070:  MOVFF  70C,753
04074:  MOVFF  03,75A
04078:  MOVFF  02,759
0407C:  MOVFF  01,758
04080:  MOVLB  0
04082:  CALL   0D4C
04086:  MOVFF  03,71F
0408A:  MOVFF  02,71E
0408E:  MOVFF  01,71D
04092:  MOVFF  00,71C
04096:  MOVFF  03,725
0409A:  MOVFF  02,724
0409E:  MOVFF  01,723
040A2:  MOVFF  00,722
040A6:  MOVLB  7
040A8:  CLRF   x29
040AA:  CLRF   x28
040AC:  MOVLW  40
040AE:  MOVWF  x27
040B0:  MOVLW  80
040B2:  MOVWF  x26
040B4:  MOVLB  0
040B6:  CALL   33BA
040BA:  MOVFF  FEA,71D
040BE:  MOVFF  FE9,71C
040C2:  BCF    FD8.1
040C4:  MOVFF  719,755
040C8:  MOVFF  718,754
040CC:  MOVFF  717,753
040D0:  MOVFF  716,752
040D4:  MOVFF  03,759
040D8:  MOVFF  02,758
040DC:  MOVFF  01,757
040E0:  MOVFF  00,756
040E4:  CALL   0E42
040E8:  MOVFF  71D,FEA
040EC:  MOVFF  71C,FE9
040F0:  MOVFF  03,719
040F4:  MOVFF  02,718
040F8:  MOVFF  01,717
040FC:  MOVFF  00,716
04100:  MOVLB  7
04102:  MOVF   x0B,W
04104:  MULLW  18
04106:  MOVF   FF3,W
04108:  CLRF   x1F
0410A:  MOVWF  x1E
0410C:  MOVLW  08
0410E:  ADDWF  x1E,W
04110:  MOVWF  01
04112:  MOVLW  00
04114:  ADDWFC x1F,W
04116:  MOVWF  03
04118:  MOVF   01,W
0411A:  ADDLW  92
0411C:  MOVWF  FE9
0411E:  MOVLW  00
04120:  ADDWFC 03,W
04122:  MOVWF  FEA
04124:  MOVFF  FEF,757
04128:  MOVFF  FEC,01
0412C:  MOVFF  FEC,02
04130:  MOVFF  FEC,03
04134:  MOVFF  70F,756
04138:  MOVFF  70E,755
0413C:  MOVFF  70D,754
04140:  MOVFF  70C,753
04144:  MOVFF  03,75A
04148:  MOVFF  02,759
0414C:  MOVFF  01,758
04150:  MOVLB  0
04152:  CALL   0D4C
04156:  MOVFF  03,721
0415A:  MOVFF  02,720
0415E:  MOVFF  01,71F
04162:  MOVFF  00,71E
04166:  MOVFF  03,725
0416A:  MOVFF  02,724
0416E:  MOVFF  01,723
04172:  MOVFF  00,722
04176:  MOVLB  7
04178:  CLRF   x29
0417A:  CLRF   x28
0417C:  CLRF   x27
0417E:  MOVLW  80
04180:  MOVWF  x26
04182:  MOVLB  0
04184:  CALL   33BA
04188:  MOVFF  FEA,71F
0418C:  MOVFF  FE9,71E
04190:  BCF    FD8.1
04192:  MOVFF  719,755
04196:  MOVFF  718,754
0419A:  MOVFF  717,753
0419E:  MOVFF  716,752
041A2:  MOVFF  03,759
041A6:  MOVFF  02,758
041AA:  MOVFF  01,757
041AE:  MOVFF  00,756
041B2:  CALL   0E42
041B6:  MOVFF  71F,FEA
041BA:  MOVFF  71E,FE9
041BE:  MOVFF  03,719
041C2:  MOVFF  02,718
041C6:  MOVFF  01,717
041CA:  MOVFF  00,716
041CE:  MOVLB  7
041D0:  MOVF   x0B,W
041D2:  MULLW  18
041D4:  MOVF   FF3,W
041D6:  CLRF   x21
041D8:  MOVWF  x20
041DA:  MOVLW  04
041DC:  ADDWF  x20,W
041DE:  MOVWF  01
041E0:  MOVLW  00
041E2:  ADDWFC x21,W
041E4:  MOVWF  03
041E6:  MOVF   01,W
041E8:  ADDLW  92
041EA:  MOVWF  FE9
041EC:  MOVLW  00
041EE:  ADDWFC 03,W
041F0:  MOVWF  FEA
041F2:  MOVFF  FEF,757
041F6:  MOVFF  FEC,01
041FA:  MOVFF  FEC,02
041FE:  MOVFF  FEC,03
04202:  MOVFF  70F,756
04206:  MOVFF  70E,755
0420A:  MOVFF  70D,754
0420E:  MOVFF  70C,753
04212:  MOVFF  03,75A
04216:  MOVFF  02,759
0421A:  MOVFF  01,758
0421E:  MOVLB  0
04220:  CALL   0D4C
04224:  MOVFF  FEA,721
04228:  MOVFF  FE9,720
0422C:  BCF    FD8.1
0422E:  MOVFF  719,755
04232:  MOVFF  718,754
04236:  MOVFF  717,753
0423A:  MOVFF  716,752
0423E:  MOVFF  03,759
04242:  MOVFF  02,758
04246:  MOVFF  01,757
0424A:  MOVFF  00,756
0424E:  CALL   0E42
04252:  MOVFF  721,FEA
04256:  MOVFF  720,FE9
0425A:  MOVFF  03,755
0425E:  MOVFF  02,754
04262:  MOVFF  01,753
04266:  MOVFF  00,752
0426A:  MOVLB  7
0426C:  MOVF   x0B,W
0426E:  MULLW  18
04270:  MOVF   FF3,W
04272:  CLRF   x23
04274:  MOVWF  x22
04276:  MOVLW  92
04278:  ADDWF  x22,W
0427A:  MOVWF  FE9
0427C:  MOVLW  00
0427E:  ADDWFC x23,W
04280:  MOVWF  FEA
04282:  MOVFF  FEF,756
04286:  MOVFF  FEC,01
0428A:  MOVFF  FEC,02
0428E:  MOVFF  FEC,03
04292:  BCF    FD8.1
04294:  MOVFF  03,759
04298:  MOVFF  02,758
0429C:  MOVFF  01,757
042A0:  MOVLB  0
042A2:  CALL   0E42
042A6:  MOVFF  715,FEA
042AA:  MOVFF  714,FE9
042AE:  MOVFF  00,FEF
042B2:  MOVFF  01,FEC
042B6:  MOVFF  02,FEC
042BA:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
042BE:  MOVLB  7
042C0:  MOVF   x0B,F
042C2:  BNZ   4320
042C4:  MOVF   x0B,W
042C6:  MULLW  26
042C8:  MOVF   FF3,W
042CA:  CLRF   x15
042CC:  MOVWF  x14
042CE:  MOVLW  1D
042D0:  ADDWF  x14,W
042D2:  MOVWF  01
042D4:  MOVLW  00
042D6:  ADDWFC x15,W
042D8:  MOVWF  03
042DA:  MOVF   01,W
042DC:  ADDLW  17
042DE:  MOVWF  FE9
042E0:  MOVLW  01
042E2:  ADDWFC 03,W
042E4:  MOVWF  FEA
042E6:  MOVFF  FEF,753
042EA:  MOVFF  FEC,754
042EE:  MOVFF  FEC,755
042F2:  MOVFF  FEC,756
042F6:  MOVF   FED,F
042F8:  MOVF   FED,F
042FA:  MOVF   FED,F
042FC:  CLRF   x5A
042FE:  CLRF   x59
04300:  MOVLW  80
04302:  MOVWF  x58
04304:  MOVLW  7F
04306:  MOVWF  x57
04308:  MOVLB  0
0430A:  CALL   0D4C
0430E:  MOVFF  00,FEF
04312:  MOVFF  01,FEC
04316:  MOVFF  02,FEC
0431A:  MOVFF  03,FEC
0431E:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
04320:  MOVF   x0B,W
04322:  MULLW  28
04324:  MOVF   FF3,W
04326:  CLRF   x15
04328:  MOVWF  x14
0432A:  MOVLW  14
0432C:  ADDWF  x14,W
0432E:  MOVWF  01
04330:  MOVLW  00
04332:  ADDWFC x15,W
04334:  MOVWF  03
04336:  MOVF   01,W
04338:  ADDLW  20
0433A:  MOVWF  01
0433C:  MOVLW  00
0433E:  ADDWFC 03,F
04340:  MOVFF  01,714
04344:  MOVFF  03,715
04348:  MOVF   x0B,W
0434A:  MULLW  28
0434C:  MOVF   FF3,W
0434E:  CLRF   x17
04350:  MOVWF  x16
04352:  MOVLW  10
04354:  ADDWF  x16,W
04356:  MOVWF  01
04358:  MOVLW  00
0435A:  ADDWFC x17,W
0435C:  MOVWF  03
0435E:  MOVF   01,W
04360:  ADDLW  20
04362:  MOVWF  FE9
04364:  MOVLW  00
04366:  ADDWFC 03,W
04368:  MOVWF  FEA
0436A:  MOVFF  FEF,00
0436E:  MOVFF  FEC,01
04372:  MOVFF  FEC,02
04376:  MOVFF  FEC,03
0437A:  MOVFF  715,FEA
0437E:  MOVFF  714,FE9
04382:  MOVFF  00,FEF
04386:  MOVFF  01,FEC
0438A:  MOVFF  02,FEC
0438E:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04392:  MOVF   x0B,W
04394:  MULLW  28
04396:  MOVF   FF3,W
04398:  CLRF   x15
0439A:  MOVWF  x14
0439C:  MOVLW  10
0439E:  ADDWF  x14,W
043A0:  MOVWF  01
043A2:  MOVLW  00
043A4:  ADDWFC x15,W
043A6:  MOVWF  03
043A8:  MOVF   01,W
043AA:  ADDLW  20
043AC:  MOVWF  01
043AE:  MOVLW  00
043B0:  ADDWFC 03,F
043B2:  MOVFF  01,714
043B6:  MOVFF  03,715
043BA:  MOVF   x0B,W
043BC:  MULLW  26
043BE:  MOVF   FF3,W
043C0:  CLRF   x17
043C2:  MOVWF  x16
043C4:  MOVLW  1D
043C6:  ADDWF  x16,W
043C8:  MOVWF  01
043CA:  MOVLW  00
043CC:  ADDWFC x17,W
043CE:  MOVWF  03
043D0:  MOVF   01,W
043D2:  ADDLW  17
043D4:  MOVWF  FE9
043D6:  MOVLW  01
043D8:  ADDWFC 03,W
043DA:  MOVWF  FEA
043DC:  MOVFF  FEF,00
043E0:  MOVFF  FEC,01
043E4:  MOVFF  FEC,02
043E8:  MOVFF  FEC,03
043EC:  MOVFF  715,FEA
043F0:  MOVFF  714,FE9
043F4:  MOVFF  00,FEF
043F8:  MOVFF  01,FEC
043FC:  MOVFF  02,FEC
04400:  MOVFF  03,FEC
04404:  MOVLB  0
04406:  GOTO   4562 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xE7,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  7
001CA:  CLRF   x73
001CC:  MOVWF  x72
001CE:  MOVLW  D4
001D0:  ADDWF  x72,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC x73,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xE7,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  7
001E8:  CLRF   x73
001EA:  MOVWF  x72
001EC:  MOVLW  D4
001EE:  ADDWF  x72,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC x73,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1E7,772
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xE7,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xE7,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x73
00222:  MOVWF  x72
00224:  MOVLW  D4
00226:  ADDWF  x72,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x73,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xE7,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  7
00244:  CLRF   x73
00246:  MOVWF  x72
00248:  MOVLW  D4
0024A:  ADDWF  x72,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC x73,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01722:  MOVLB  7
01724:  CLRF   x1F
01726:  CLRF   x1E
01728:  CLRF   x1D
0172A:  CLRF   x1C
0172C:  CLRF   x23
0172E:  CLRF   x22
01730:  CLRF   x21
01732:  CLRF   x20
01734:  CLRF   x27
01736:  CLRF   x26
01738:  CLRF   x25
0173A:  CLRF   x24
0173C:  CLRF   x2B
0173E:  CLRF   x2A
01740:  CLRF   x29
01742:  CLRF   x28
01744:  CLRF   x2F
01746:  CLRF   x2E
01748:  CLRF   x2D
0174A:  CLRF   x2C
0174C:  CLRF   x33
0174E:  CLRF   x32
01750:  CLRF   x31
01752:  CLRF   x30
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01754:  MOVF   x0B,F
01756:  BNZ   177A
....................       sQ_ch = sQ_x;
01758:  MOVLW  01
0175A:  MOVWF  x15
0175C:  MOVLW  80
0175E:  MOVWF  x14
....................       cQ_ch = cQ_x;
01760:  MOVLW  01
01762:  MOVWF  x17
01764:  MOVLW  94
01766:  MOVWF  x16
....................       sIn_ch = &sIn_x;
01768:  MOVLW  01
0176A:  MOVWF  x19
0176C:  MOVLW  D0
0176E:  MOVWF  x18
....................       cIn_ch = &cIn_x;
01770:  MOVLW  01
01772:  MOVWF  x1B
01774:  MOVLW  D1
01776:  MOVWF  x1A
....................    }
01778:  BRA    179E
....................    else if (ch==1){
0177A:  DECFSZ x0B,W
0177C:  BRA    179E
....................       sQ_ch = sQ_y;
0177E:  MOVLW  01
01780:  MOVWF  x15
01782:  MOVLW  A8
01784:  MOVWF  x14
....................       cQ_ch = cQ_y;
01786:  MOVLW  01
01788:  MOVWF  x17
0178A:  MOVLW  BC
0178C:  MOVWF  x16
....................       sIn_ch = &sIn_y;
0178E:  MOVLW  01
01790:  MOVWF  x19
01792:  MOVLW  D2
01794:  MOVWF  x18
....................       cIn_ch = &cIn_y;
01796:  MOVLW  01
01798:  MOVWF  x1B
0179A:  MOVLW  D3
0179C:  MOVWF  x1A
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
0179E:  MOVFF  715,736
017A2:  MOVFF  714,735
017A6:  MOVFF  719,738
017AA:  MOVFF  718,737
017AE:  MOVFF  70F,73C
017B2:  MOVFF  70E,73B
017B6:  MOVFF  70D,73A
017BA:  MOVFF  70C,739
017BE:  MOVLB  0
017C0:  CALL   08B2
....................    push(cQ_ch, cIn_ch, cosCnts);
017C4:  MOVFF  717,736
017C8:  MOVFF  716,735
017CC:  MOVFF  71B,738
017D0:  MOVFF  71A,737
017D4:  MOVFF  713,73C
017D8:  MOVFF  712,73B
017DC:  MOVFF  711,73A
017E0:  MOVFF  710,739
017E4:  CALL   08B2
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
017E8:  MOVLB  7
017EA:  MOVFF  714,FE9
017EE:  MOVFF  715,FEA
017F2:  MOVFF  FEF,724
017F6:  MOVFF  FEC,725
017FA:  MOVFF  FEC,726
017FE:  MOVFF  FEC,727
....................    sinMin=sQ_ch[0];
01802:  MOVFF  714,FE9
01806:  MOVFF  715,FEA
0180A:  MOVFF  FEF,728
0180E:  MOVFF  FEC,729
01812:  MOVFF  FEC,72A
01816:  MOVFF  FEC,72B
....................    cosMax=cQ_ch[0];
0181A:  MOVFF  716,FE9
0181E:  MOVFF  717,FEA
01822:  MOVFF  FEF,72C
01826:  MOVFF  FEC,72D
0182A:  MOVFF  FEC,72E
0182E:  MOVFF  FEC,72F
....................    cosMin=cQ_ch[0];
01832:  MOVFF  716,FE9
01836:  MOVFF  717,FEA
0183A:  MOVFF  FEF,730
0183E:  MOVFF  FEC,731
01842:  MOVFF  FEC,732
01846:  MOVFF  FEC,733
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
0184A:  MOVLW  01
0184C:  MOVWF  x34
0184E:  MOVF   x34,W
01850:  SUBLW  04
01852:  BTFSS  FD8.0
01854:  BRA    1B64
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
01856:  CLRF   x45
01858:  MOVFF  734,744
0185C:  CLRF   x47
0185E:  MOVLW  04
01860:  MOVWF  x46
01862:  MOVLB  0
01864:  CALL   0864
01868:  MOVFF  02,03
0186C:  MOVF   01,W
0186E:  MOVLB  7
01870:  ADDWF  x14,W
01872:  MOVWF  FE9
01874:  MOVF   x15,W
01876:  ADDWFC 02,W
01878:  MOVWF  FEA
0187A:  MOVFF  FEF,00
0187E:  MOVFF  FEC,01
01882:  MOVFF  FEC,02
01886:  MOVFF  FEC,03
0188A:  BTFSS  x27.7
0188C:  BRA    1894
0188E:  BTFSS  03.7
01890:  BRA    18B6
01892:  BRA    1898
01894:  BTFSC  03.7
01896:  BRA    18EC
01898:  MOVF   x27,W
0189A:  SUBWF  03,W
0189C:  BNC   18EC
0189E:  BNZ   18B6
018A0:  MOVF   x26,W
018A2:  SUBWF  02,W
018A4:  BNC   18EC
018A6:  BNZ   18B6
018A8:  MOVF   x25,W
018AA:  SUBWF  01,W
018AC:  BNC   18EC
018AE:  BNZ   18B6
018B0:  MOVF   00,W
018B2:  SUBWF  x24,W
018B4:  BC    18EC
018B6:  CLRF   x45
018B8:  MOVFF  734,744
018BC:  CLRF   x47
018BE:  MOVLW  04
018C0:  MOVWF  x46
018C2:  MOVLB  0
018C4:  CALL   0864
018C8:  MOVFF  02,03
018CC:  MOVF   01,W
018CE:  MOVLB  7
018D0:  ADDWF  x14,W
018D2:  MOVWF  FE9
018D4:  MOVF   x15,W
018D6:  ADDWFC 02,W
018D8:  MOVWF  FEA
018DA:  MOVFF  FEF,724
018DE:  MOVFF  FEC,725
018E2:  MOVFF  FEC,726
018E6:  MOVFF  FEC,727
018EA:  MOVF   x24,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
018EC:  CLRF   x45
018EE:  MOVFF  734,744
018F2:  CLRF   x47
018F4:  MOVLW  04
018F6:  MOVWF  x46
018F8:  MOVLB  0
018FA:  CALL   0864
018FE:  MOVFF  02,03
01902:  MOVF   01,W
01904:  MOVLB  7
01906:  ADDWF  x14,W
01908:  MOVWF  FE9
0190A:  MOVF   x15,W
0190C:  ADDWFC 02,W
0190E:  MOVWF  FEA
01910:  MOVFF  FEF,00
01914:  MOVFF  FEC,01
01918:  MOVFF  FEC,02
0191C:  MOVFF  FEC,03
01920:  BTFSS  03.7
01922:  BRA    192A
01924:  BTFSS  x2B.7
01926:  BRA    194C
01928:  BRA    192E
0192A:  BTFSC  x2B.7
0192C:  BRA    1990
0192E:  MOVF   03,W
01930:  SUBWF  x2B,W
01932:  BNC   1990
01934:  BNZ   194C
01936:  MOVF   02,W
01938:  SUBWF  x2A,W
0193A:  BNC   1990
0193C:  BNZ   194C
0193E:  MOVF   01,W
01940:  SUBWF  x29,W
01942:  BNC   1990
01944:  BNZ   194C
01946:  MOVF   x28,W
01948:  SUBWF  00,W
0194A:  BC    1990
0194C:  CLRF   x45
0194E:  MOVFF  734,744
01952:  CLRF   x47
01954:  MOVLW  04
01956:  MOVWF  x46
01958:  MOVLB  0
0195A:  CALL   0864
0195E:  MOVFF  02,03
01962:  MOVF   01,W
01964:  MOVLB  7
01966:  ADDWF  x14,W
01968:  MOVWF  FE9
0196A:  MOVF   x15,W
0196C:  ADDWFC 02,W
0196E:  MOVWF  FEA
01970:  MOVFF  FEF,728
01974:  MOVFF  FEC,729
01978:  MOVFF  FEC,72A
0197C:  MOVFF  FEC,72B
01980:  MOVFF  728,00
01984:  MOVFF  729,01
01988:  MOVFF  72A,02
0198C:  MOVFF  72B,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
01990:  CLRF   x45
01992:  MOVFF  734,744
01996:  CLRF   x47
01998:  MOVLW  04
0199A:  MOVWF  x46
0199C:  MOVLB  0
0199E:  CALL   0864
019A2:  MOVFF  02,03
019A6:  MOVF   01,W
019A8:  MOVLB  7
019AA:  ADDWF  x16,W
019AC:  MOVWF  FE9
019AE:  MOVF   x17,W
019B0:  ADDWFC 02,W
019B2:  MOVWF  FEA
019B4:  MOVFF  FEF,00
019B8:  MOVFF  FEC,01
019BC:  MOVFF  FEC,02
019C0:  MOVFF  FEC,03
019C4:  BTFSS  x2F.7
019C6:  BRA    19CE
019C8:  BTFSS  03.7
019CA:  BRA    19F0
019CC:  BRA    19D2
019CE:  BTFSC  03.7
019D0:  BRA    1A34
019D2:  MOVF   x2F,W
019D4:  SUBWF  03,W
019D6:  BNC   1A34
019D8:  BNZ   19F0
019DA:  MOVF   x2E,W
019DC:  SUBWF  02,W
019DE:  BNC   1A34
019E0:  BNZ   19F0
019E2:  MOVF   x2D,W
019E4:  SUBWF  01,W
019E6:  BNC   1A34
019E8:  BNZ   19F0
019EA:  MOVF   00,W
019EC:  SUBWF  x2C,W
019EE:  BC    1A34
019F0:  CLRF   x45
019F2:  MOVFF  734,744
019F6:  CLRF   x47
019F8:  MOVLW  04
019FA:  MOVWF  x46
019FC:  MOVLB  0
019FE:  CALL   0864
01A02:  MOVFF  02,03
01A06:  MOVF   01,W
01A08:  MOVLB  7
01A0A:  ADDWF  x16,W
01A0C:  MOVWF  FE9
01A0E:  MOVF   x17,W
01A10:  ADDWFC 02,W
01A12:  MOVWF  FEA
01A14:  MOVFF  FEF,72C
01A18:  MOVFF  FEC,72D
01A1C:  MOVFF  FEC,72E
01A20:  MOVFF  FEC,72F
01A24:  MOVFF  72C,00
01A28:  MOVFF  72D,01
01A2C:  MOVFF  72E,02
01A30:  MOVFF  72F,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A34:  CLRF   x45
01A36:  MOVFF  734,744
01A3A:  CLRF   x47
01A3C:  MOVLW  04
01A3E:  MOVWF  x46
01A40:  MOVLB  0
01A42:  CALL   0864
01A46:  MOVFF  02,03
01A4A:  MOVF   01,W
01A4C:  MOVLB  7
01A4E:  ADDWF  x16,W
01A50:  MOVWF  FE9
01A52:  MOVF   x17,W
01A54:  ADDWFC 02,W
01A56:  MOVWF  FEA
01A58:  MOVFF  FEF,00
01A5C:  MOVFF  FEC,01
01A60:  MOVFF  FEC,02
01A64:  MOVFF  FEC,03
01A68:  BTFSS  03.7
01A6A:  BRA    1A72
01A6C:  BTFSS  x33.7
01A6E:  BRA    1A94
01A70:  BRA    1A76
01A72:  BTFSC  x33.7
01A74:  BRA    1AD8
01A76:  MOVF   03,W
01A78:  SUBWF  x33,W
01A7A:  BNC   1AD8
01A7C:  BNZ   1A94
01A7E:  MOVF   02,W
01A80:  SUBWF  x32,W
01A82:  BNC   1AD8
01A84:  BNZ   1A94
01A86:  MOVF   01,W
01A88:  SUBWF  x31,W
01A8A:  BNC   1AD8
01A8C:  BNZ   1A94
01A8E:  MOVF   x30,W
01A90:  SUBWF  00,W
01A92:  BC    1AD8
01A94:  CLRF   x45
01A96:  MOVFF  734,744
01A9A:  CLRF   x47
01A9C:  MOVLW  04
01A9E:  MOVWF  x46
01AA0:  MOVLB  0
01AA2:  CALL   0864
01AA6:  MOVFF  02,03
01AAA:  MOVF   01,W
01AAC:  MOVLB  7
01AAE:  ADDWF  x16,W
01AB0:  MOVWF  FE9
01AB2:  MOVF   x17,W
01AB4:  ADDWFC 02,W
01AB6:  MOVWF  FEA
01AB8:  MOVFF  FEF,730
01ABC:  MOVFF  FEC,731
01AC0:  MOVFF  FEC,732
01AC4:  MOVFF  FEC,733
01AC8:  MOVFF  730,00
01ACC:  MOVFF  731,01
01AD0:  MOVFF  732,02
01AD4:  MOVFF  733,03
....................       sumSin+=sQ_ch[i];
01AD8:  CLRF   x45
01ADA:  MOVFF  734,744
01ADE:  CLRF   x47
01AE0:  MOVLW  04
01AE2:  MOVWF  x46
01AE4:  MOVLB  0
01AE6:  CALL   0864
01AEA:  MOVFF  02,03
01AEE:  MOVF   01,W
01AF0:  MOVLB  7
01AF2:  ADDWF  x14,W
01AF4:  MOVWF  FE9
01AF6:  MOVF   x15,W
01AF8:  ADDWFC 02,W
01AFA:  MOVWF  FEA
01AFC:  MOVFF  FEF,00
01B00:  MOVFF  FEC,01
01B04:  MOVFF  FEC,02
01B08:  MOVFF  FEC,03
01B0C:  MOVF   00,W
01B0E:  ADDWF  x1C,F
01B10:  MOVF   01,W
01B12:  ADDWFC x1D,F
01B14:  MOVF   02,W
01B16:  ADDWFC x1E,F
01B18:  MOVF   03,W
01B1A:  ADDWFC x1F,F
....................       sumCos+=cQ_ch[i];
01B1C:  CLRF   x45
01B1E:  MOVFF  734,744
01B22:  CLRF   x47
01B24:  MOVLW  04
01B26:  MOVWF  x46
01B28:  MOVLB  0
01B2A:  CALL   0864
01B2E:  MOVFF  02,03
01B32:  MOVF   01,W
01B34:  MOVLB  7
01B36:  ADDWF  x16,W
01B38:  MOVWF  FE9
01B3A:  MOVF   x17,W
01B3C:  ADDWFC 02,W
01B3E:  MOVWF  FEA
01B40:  MOVFF  FEF,00
01B44:  MOVFF  FEC,01
01B48:  MOVFF  FEC,02
01B4C:  MOVFF  FEC,03
01B50:  MOVF   00,W
01B52:  ADDWF  x20,F
01B54:  MOVF   01,W
01B56:  ADDWFC x21,F
01B58:  MOVF   02,W
01B5A:  ADDWFC x22,F
01B5C:  MOVF   03,W
01B5E:  ADDWFC x23,F
01B60:  INCF   x34,F
01B62:  BRA    184E
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01B64:  MOVF   x28,W
01B66:  ADDWF  x24,W
01B68:  MOVWF  00
01B6A:  MOVF   x29,W
01B6C:  ADDWFC x25,W
01B6E:  MOVWF  01
01B70:  MOVF   x2A,W
01B72:  ADDWFC x26,W
01B74:  MOVWF  02
01B76:  MOVF   x2B,W
01B78:  ADDWFC x27,W
01B7A:  MOVWF  03
01B7C:  MOVF   00,W
01B7E:  SUBWF  x1C,F
01B80:  MOVF   01,W
01B82:  SUBWFB x1D,F
01B84:  MOVF   02,W
01B86:  SUBWFB x1E,F
01B88:  MOVF   03,W
01B8A:  SUBWFB x1F,F
....................    sumCos-=(cosMax+cosMin);
01B8C:  MOVF   x30,W
01B8E:  ADDWF  x2C,W
01B90:  MOVWF  00
01B92:  MOVF   x31,W
01B94:  ADDWFC x2D,W
01B96:  MOVWF  01
01B98:  MOVF   x32,W
01B9A:  ADDWFC x2E,W
01B9C:  MOVWF  02
01B9E:  MOVF   x33,W
01BA0:  ADDWFC x2F,W
01BA2:  MOVWF  03
01BA4:  MOVF   00,W
01BA6:  SUBWF  x20,F
01BA8:  MOVF   01,W
01BAA:  SUBWFB x21,F
01BAC:  MOVF   02,W
01BAE:  SUBWFB x22,F
01BB0:  MOVF   03,W
01BB2:  SUBWFB x23,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BB4:  MOVF   x0B,W
01BB6:  MULLW  09
01BB8:  MOVF   FF3,W
01BBA:  CLRF   x36
01BBC:  MOVWF  x35
01BBE:  MOVLW  01
01BC0:  ADDWF  x35,W
01BC2:  MOVWF  01
01BC4:  MOVLW  00
01BC6:  ADDWFC x36,W
01BC8:  MOVWF  03
01BCA:  MOVF   01,W
01BCC:  ADDLW  D4
01BCE:  MOVWF  FE9
01BD0:  MOVLW  01
01BD2:  ADDWFC 03,W
01BD4:  MOVWF  FEA
01BD6:  MOVFF  FEA,738
01BDA:  MOVFF  FE9,737
01BDE:  BCF    FD8.1
01BE0:  MOVFF  71F,73C
01BE4:  MOVFF  71E,73B
01BE8:  MOVFF  71D,73A
01BEC:  MOVFF  71C,739
01BF0:  CLRF   x40
01BF2:  CLRF   x3F
01BF4:  CLRF   x3E
01BF6:  MOVLW  03
01BF8:  MOVWF  x3D
01BFA:  MOVLB  0
01BFC:  RCALL  1638
01BFE:  MOVFF  738,FEA
01C02:  MOVFF  737,FE9
01C06:  MOVFF  00,FEF
01C0A:  MOVFF  01,FEC
01C0E:  MOVFF  02,FEC
01C12:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C16:  MOVLB  7
01C18:  MOVF   x0B,W
01C1A:  MULLW  09
01C1C:  MOVF   FF3,W
01C1E:  CLRF   x36
01C20:  MOVWF  x35
01C22:  MOVLW  05
01C24:  ADDWF  x35,W
01C26:  MOVWF  01
01C28:  MOVLW  00
01C2A:  ADDWFC x36,W
01C2C:  MOVWF  03
01C2E:  MOVF   01,W
01C30:  ADDLW  D4
01C32:  MOVWF  FE9
01C34:  MOVLW  01
01C36:  ADDWFC 03,W
01C38:  MOVWF  FEA
01C3A:  MOVFF  FEA,738
01C3E:  MOVFF  FE9,737
01C42:  BCF    FD8.1
01C44:  MOVFF  723,73C
01C48:  MOVFF  722,73B
01C4C:  MOVFF  721,73A
01C50:  MOVFF  720,739
01C54:  CLRF   x40
01C56:  CLRF   x3F
01C58:  CLRF   x3E
01C5A:  MOVLW  03
01C5C:  MOVWF  x3D
01C5E:  MOVLB  0
01C60:  RCALL  1638
01C62:  MOVFF  738,FEA
01C66:  MOVFF  737,FE9
01C6A:  MOVFF  00,FEF
01C6E:  MOVFF  01,FEC
01C72:  MOVFF  02,FEC
01C76:  MOVFF  03,FEC
01C7A:  GOTO   44EA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
0440A:  MOVLB  7
0440C:  CLRF   x06
0440E:  CLRF   x05
04410:  CLRF   x04
04412:  CLRF   x03
04414:  CLRF   x0A
04416:  CLRF   x09
04418:  CLRF   x08
0441A:  CLRF   x07
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
0441C:  MOVLB  1
0441E:  MOVF   xE8,W
04420:  MULLW  09
04422:  MOVF   FF3,W
04424:  MOVLB  7
04426:  CLRF   x0C
04428:  MOVWF  x0B
0442A:  MOVLW  D4
0442C:  ADDWF  x0B,W
0442E:  MOVWF  FE9
04430:  MOVLW  01
04432:  ADDWFC x0C,W
04434:  MOVWF  FEA
04436:  BTFSC  FEF.1
04438:  BRA    45B6
0443A:  MOVLB  1
0443C:  MOVF   xE8,W
0443E:  MULLW  09
04440:  MOVF   FF3,W
04442:  MOVLB  7
04444:  CLRF   x0E
04446:  MOVWF  x0D
04448:  MOVLW  D4
0444A:  ADDWF  x0D,W
0444C:  MOVWF  FE9
0444E:  MOVLW  01
04450:  ADDWFC x0E,W
04452:  MOVWF  FEA
04454:  BTFSS  FEF.0
04456:  BRA    45B6
....................       smData[ch].adcBusy = true;
04458:  MOVLB  1
0445A:  MOVF   xE8,W
0445C:  MULLW  09
0445E:  MOVF   FF3,W
04460:  MOVLB  7
04462:  CLRF   x0C
04464:  MOVWF  x0B
04466:  MOVLW  D4
04468:  ADDWF  x0B,W
0446A:  MOVWF  FE9
0446C:  MOVLW  01
0446E:  ADDWFC x0C,W
04470:  MOVWF  FEA
04472:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04474:  BCF    FD8.0
04476:  MOVLB  1
04478:  RLCF   xE8,W
0447A:  MOVLB  7
0447C:  MOVWF  x0B
0447E:  MOVWF  x0C
04480:  MOVLB  0
04482:  CALL   080A
04486:  MOVFF  03,706
0448A:  MOVFF  02,705
0448E:  MOVFF  01,704
04492:  MOVFF  00,703
....................       cosNew = ads_read_data(ch*2+1);      
04496:  BCF    FD8.0
04498:  MOVLB  1
0449A:  RLCF   xE8,W
0449C:  ADDLW  01
0449E:  MOVLB  7
044A0:  MOVWF  x0B
044A2:  MOVWF  x0C
044A4:  MOVLB  0
044A6:  CALL   080A
044AA:  MOVFF  03,70A
044AE:  MOVFF  02,709
044B2:  MOVFF  01,708
044B6:  MOVFF  00,707
....................       
....................       if (adcFilter){
044BA:  MOVLB  1
044BC:  BTFSS  x63.0
044BE:  BRA    44EE
....................          iqm_ring_buffer(ch, sinNew, cosNew);
044C0:  MOVFF  1E8,70B
044C4:  MOVFF  706,70F
044C8:  MOVFF  705,70E
044CC:  MOVFF  704,70D
044D0:  MOVFF  703,70C
044D4:  MOVFF  70A,713
044D8:  MOVFF  709,712
044DC:  MOVFF  708,711
044E0:  MOVFF  707,710
044E4:  MOVLB  0
044E6:  GOTO   1722
....................       }
044EA:  BRA    455A
044EC:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
044EE:  MOVF   xE8,W
044F0:  MULLW  09
044F2:  MOVF   FF3,W
044F4:  MOVLB  7
044F6:  CLRF   x0C
044F8:  MOVWF  x0B
044FA:  MOVLW  01
044FC:  ADDWF  x0B,W
044FE:  MOVWF  01
04500:  MOVLW  00
04502:  ADDWFC x0C,W
04504:  MOVWF  03
04506:  MOVF   01,W
04508:  ADDLW  D4
0450A:  MOVWF  FE9
0450C:  MOVLW  01
0450E:  ADDWFC 03,W
04510:  MOVWF  FEA
04512:  MOVFF  703,FEF
04516:  MOVFF  704,FEC
0451A:  MOVFF  705,FEC
0451E:  MOVFF  706,FEC
....................          smData[ch].avgCos = cosNew;
04522:  MOVLB  1
04524:  MOVF   xE8,W
04526:  MULLW  09
04528:  MOVF   FF3,W
0452A:  MOVLB  7
0452C:  CLRF   x0C
0452E:  MOVWF  x0B
04530:  MOVLW  05
04532:  ADDWF  x0B,W
04534:  MOVWF  01
04536:  MOVLW  00
04538:  ADDWFC x0C,W
0453A:  MOVWF  03
0453C:  MOVF   01,W
0453E:  ADDLW  D4
04540:  MOVWF  FE9
04542:  MOVLW  01
04544:  ADDWFC 03,W
04546:  MOVWF  FEA
04548:  MOVFF  707,FEF
0454C:  MOVFF  708,FEC
04550:  MOVFF  709,FEC
04554:  MOVFF  70A,FEC
04558:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
0455A:  MOVFF  1E8,70B
0455E:  GOTO   36B8
....................       ch = !ch;
04562:  MOVLB  1
04564:  MOVF   xE8,F
04566:  BZ    456C
04568:  MOVLW  00
0456A:  BRA    456E
0456C:  MOVLW  01
0456E:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
04570:  MOVF   xE8,F
04572:  BZ    4578
04574:  MOVLW  00
04576:  BRA    457A
04578:  MOVLW  01
0457A:  MULLW  09
0457C:  MOVF   FF3,W
0457E:  MOVLB  7
04580:  CLRF   x0C
04582:  MOVWF  x0B
04584:  MOVLW  D4
04586:  ADDWF  x0B,W
04588:  MOVWF  FE9
0458A:  MOVLW  01
0458C:  ADDWFC x0C,W
0458E:  MOVWF  FEA
04590:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04592:  MOVLB  1
04594:  MOVF   xE8,F
04596:  BZ    459C
04598:  MOVLW  00
0459A:  BRA    459E
0459C:  MOVLW  01
0459E:  MULLW  09
045A0:  MOVF   FF3,W
045A2:  MOVLB  7
045A4:  CLRF   x0C
045A6:  MOVWF  x0B
045A8:  MOVLW  D4
045AA:  ADDWF  x0B,W
045AC:  MOVWF  FE9
045AE:  MOVLW  01
045B0:  ADDWFC x0C,W
045B2:  MOVWF  FEA
045B4:  BCF    FEF.1
....................    }
045B6:  MOVLB  0
045B8:  GOTO   A95E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00918:  MOVLB  7
0091A:  CLRF   x03
0091C:  CLRF   x04
0091E:  CLRF   x05
00920:  CLRF   x06
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00922:  CLRF   x07
00924:  MOVF   x07,W
00926:  SUBLW  03
00928:  BNC   095E
....................       rc0=reg0config;
0092A:  MOVLW  30
0092C:  MOVWF  x03
....................       rc1=reg1config;
0092E:  MOVLW  10
00930:  MOVWF  x04
....................       rc2=reg2config;
00932:  CLRF   x05
....................       rc3=reg3config;
00934:  CLRF   x06
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00936:  MOVFF  707,709
0093A:  MOVFF  703,70A
0093E:  MOVFF  704,70B
00942:  MOVFF  705,70C
00946:  MOVFF  706,70D
0094A:  MOVLB  0
0094C:  BRA    073C
....................       delay_ms(100);
0094E:  MOVLW  64
00950:  MOVLB  7
00952:  MOVWF  x09
00954:  MOVLB  0
00956:  RCALL  042A
00958:  MOVLB  7
0095A:  INCF   x07,F
0095C:  BRA    0924
....................    }
....................    
....................    if (adcFilter){
0095E:  MOVLB  1
00960:  BTFSS  x63.0
00962:  BRA    0A84
....................       for (int i = 0; i < BUFFER_SIZE; i++){
00964:  MOVLB  7
00966:  CLRF   x08
00968:  MOVF   x08,W
0096A:  SUBLW  04
0096C:  BTFSS  FD8.0
0096E:  BRA    0A82
....................          ads_start_conv_all();
00970:  MOVLB  0
00972:  BRA    07DA
....................          delay_ms(50);
00974:  MOVLW  32
00976:  MOVLB  7
00978:  MOVWF  x09
0097A:  MOVLB  0
0097C:  RCALL  042A
....................          push(sQ_x, &sIn_x, ads_read_data(0));
0097E:  MOVLB  7
00980:  CLRF   x0C
00982:  MOVLB  0
00984:  RCALL  080A
00986:  MOVFF  03,70C
0098A:  MOVFF  02,70B
0098E:  MOVFF  01,70A
00992:  MOVFF  00,709
00996:  MOVLW  01
00998:  MOVLB  7
0099A:  MOVWF  x36
0099C:  MOVLW  80
0099E:  MOVWF  x35
009A0:  MOVLW  01
009A2:  MOVWF  x38
009A4:  MOVLW  D0
009A6:  MOVWF  x37
009A8:  MOVFF  03,73C
009AC:  MOVFF  02,73B
009B0:  MOVFF  01,73A
009B4:  MOVFF  00,739
009B8:  MOVLB  0
009BA:  RCALL  08B2
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009BC:  MOVLW  01
009BE:  MOVLB  7
009C0:  MOVWF  x0C
009C2:  MOVLB  0
009C4:  RCALL  080A
009C6:  MOVFF  03,70C
009CA:  MOVFF  02,70B
009CE:  MOVFF  01,70A
009D2:  MOVFF  00,709
009D6:  MOVLW  01
009D8:  MOVLB  7
009DA:  MOVWF  x36
009DC:  MOVLW  94
009DE:  MOVWF  x35
009E0:  MOVLW  01
009E2:  MOVWF  x38
009E4:  MOVLW  D1
009E6:  MOVWF  x37
009E8:  MOVFF  03,73C
009EC:  MOVFF  02,73B
009F0:  MOVFF  01,73A
009F4:  MOVFF  00,739
009F8:  MOVLB  0
009FA:  RCALL  08B2
....................          push(sQ_y, &sIn_y, ads_read_data(2));
009FC:  MOVLW  02
009FE:  MOVLB  7
00A00:  MOVWF  x0C
00A02:  MOVLB  0
00A04:  RCALL  080A
00A06:  MOVFF  03,70C
00A0A:  MOVFF  02,70B
00A0E:  MOVFF  01,70A
00A12:  MOVFF  00,709
00A16:  MOVLW  01
00A18:  MOVLB  7
00A1A:  MOVWF  x36
00A1C:  MOVLW  A8
00A1E:  MOVWF  x35
00A20:  MOVLW  01
00A22:  MOVWF  x38
00A24:  MOVLW  D2
00A26:  MOVWF  x37
00A28:  MOVFF  03,73C
00A2C:  MOVFF  02,73B
00A30:  MOVFF  01,73A
00A34:  MOVFF  00,739
00A38:  MOVLB  0
00A3A:  RCALL  08B2
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A3C:  MOVLW  03
00A3E:  MOVLB  7
00A40:  MOVWF  x0C
00A42:  MOVLB  0
00A44:  RCALL  080A
00A46:  MOVFF  03,70C
00A4A:  MOVFF  02,70B
00A4E:  MOVFF  01,70A
00A52:  MOVFF  00,709
00A56:  MOVLW  01
00A58:  MOVLB  7
00A5A:  MOVWF  x36
00A5C:  MOVLW  BC
00A5E:  MOVWF  x35
00A60:  MOVLW  01
00A62:  MOVWF  x38
00A64:  MOVLW  D3
00A66:  MOVWF  x37
00A68:  MOVFF  03,73C
00A6C:  MOVFF  02,73B
00A70:  MOVFF  01,73A
00A74:  MOVFF  00,739
00A78:  MOVLB  0
00A7A:  RCALL  08B2
00A7C:  MOVLB  7
00A7E:  INCF   x08,F
00A80:  BRA    0968
00A82:  MOVLB  1
....................       }
....................    }
00A84:  MOVLB  0
00A86:  GOTO   0AEA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00A8A:  MOVLW  00
00A8C:  MOVLB  F
00A8E:  MOVWF  x53
00A90:  MOVLW  40
00A92:  MOVWF  x0C
00A94:  MOVLW  00
00A96:  MOVWF  x14
00A98:  MOVLW  03
00A9A:  MOVWF  x1C
00A9C:  MOVLW  0F
00A9E:  MOVWF  x21
00AA0:  MOVLW  00
00AA2:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AA4:  MOVLW  08
00AA6:  MOVWF  x55
00AA8:  CLRF   x56
00AAA:  CLRF   x52
00AAC:  SETF   x57
00AAE:  CLRF   F61
00AB0:  MOVLW  94
00AB2:  MOVWF  x5B
....................    output_high(EN_EXC);
00AB4:  MOVLW  E8
00AB6:  MOVWF  F8B
00AB8:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00ABA:  MOVF   x5A,W
00ABC:  ANDLW  3F
00ABE:  MOVWF  01
00AC0:  MOVLW  06
00AC2:  MOVWF  x5A
00AC4:  BTFSS  x5B.7
00AC6:  BRA    0AD6
00AC8:  MOVF   01,W
00ACA:  SUBLW  06
00ACC:  BZ    0AD6
00ACE:  BSF    x5B.0
00AD0:  NOP   
00AD2:  BTFSC  x5B.0
00AD4:  BRA    0AD2
....................    delay_ms(10);
00AD6:  MOVLW  0A
00AD8:  MOVLB  7
00ADA:  MOVWF  x09
00ADC:  MOVLB  0
00ADE:  RCALL  042A
....................    read_adc(ADC_START_ONLY);
00AE0:  MOVLB  F
00AE2:  BSF    x5B.0
00AE4:  NOP   
....................    setup_external_ADCs();
00AE6:  MOVLB  0
00AE8:  BRA    0918
....................    intTimeoutReg = sensorSampleRate;
00AEA:  MOVLB  1
00AEC:  CLRF   x7F
00AEE:  MOVLW  32
00AF0:  MOVWF  x7E
00AF2:  MOVLB  0
00AF4:  GOTO   A940 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
0467E:  MOVLB  7
04680:  MOVF   x07,W
04682:  MULLW  28
04684:  MOVF   FF3,W
04686:  CLRF   x15
04688:  MOVWF  x14
0468A:  MOVLW  0C
0468C:  ADDWF  x14,W
0468E:  MOVWF  01
04690:  MOVLW  00
04692:  ADDWFC x15,W
04694:  MOVWF  03
04696:  MOVF   01,W
04698:  ADDLW  20
0469A:  MOVWF  FE9
0469C:  MOVLW  00
0469E:  ADDWFC 03,W
046A0:  MOVWF  FEA
046A2:  MOVFF  FEF,752
046A6:  MOVFF  FEC,753
046AA:  MOVFF  FEC,754
046AE:  MOVFF  FEC,755
046B2:  MOVF   x07,W
046B4:  MULLW  28
046B6:  MOVF   FF3,W
046B8:  CLRF   x19
046BA:  MOVWF  x18
046BC:  MOVLW  10
046BE:  ADDWF  x18,W
046C0:  MOVWF  01
046C2:  MOVLW  00
046C4:  ADDWFC x19,W
046C6:  MOVWF  03
046C8:  MOVF   01,W
046CA:  ADDLW  20
046CC:  MOVWF  FE9
046CE:  MOVLW  00
046D0:  ADDWFC 03,W
046D2:  MOVWF  FEA
046D4:  MOVFF  FEF,756
046D8:  MOVFF  FEC,01
046DC:  MOVFF  FEC,02
046E0:  MOVFF  FEC,03
046E4:  MOVFF  FEA,719
046E8:  MOVFF  FE9,718
046EC:  BSF    FD8.1
046EE:  MOVFF  03,759
046F2:  MOVFF  02,758
046F6:  MOVFF  01,757
046FA:  MOVLB  0
046FC:  CALL   0E42
04700:  MOVFF  719,FEA
04704:  MOVFF  718,FE9
04708:  MOVFF  03,70B
0470C:  MOVFF  02,70A
04710:  MOVFF  01,709
04714:  MOVFF  00,708
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
04718:  MOVLB  7
0471A:  MOVF   x07,W
0471C:  MULLW  28
0471E:  MOVF   FF3,W
04720:  CLRF   x15
04722:  MOVWF  x14
04724:  MOVLW  1C
04726:  ADDWF  x14,W
04728:  MOVWF  01
0472A:  MOVLW  00
0472C:  ADDWFC x15,W
0472E:  MOVWF  03
04730:  MOVF   01,W
04732:  ADDLW  20
04734:  MOVWF  01
04736:  MOVLW  00
04738:  ADDWFC 03,F
0473A:  MOVFF  01,714
0473E:  MOVFF  03,715
04742:  MOVFF  03,FEA
04746:  MOVFF  01,FE9
0474A:  MOVFF  FEF,716
0474E:  MOVFF  FEC,717
04752:  MOVFF  FEC,718
04756:  MOVFF  FEC,719
0475A:  MOVF   x07,W
0475C:  MULLW  28
0475E:  MOVF   FF3,W
04760:  CLRF   x1B
04762:  MOVWF  x1A
04764:  MOVLW  04
04766:  ADDWF  x1A,W
04768:  MOVWF  01
0476A:  MOVLW  00
0476C:  ADDWFC x1B,W
0476E:  MOVWF  03
04770:  MOVF   01,W
04772:  ADDLW  20
04774:  MOVWF  FE9
04776:  MOVLW  00
04778:  ADDWFC 03,W
0477A:  MOVWF  FEA
0477C:  MOVFF  FEF,757
04780:  MOVFF  FEC,01
04784:  MOVFF  FEC,02
04788:  MOVFF  FEC,03
0478C:  MOVFF  70B,756
04790:  MOVFF  70A,755
04794:  MOVFF  709,754
04798:  MOVFF  708,753
0479C:  MOVFF  03,75A
047A0:  MOVFF  02,759
047A4:  MOVFF  01,758
047A8:  MOVLB  0
047AA:  CALL   0D4C
047AE:  BCF    FD8.1
047B0:  MOVFF  719,755
047B4:  MOVFF  718,754
047B8:  MOVFF  717,753
047BC:  MOVFF  716,752
047C0:  MOVFF  03,759
047C4:  MOVFF  02,758
047C8:  MOVFF  01,757
047CC:  MOVFF  00,756
047D0:  CALL   0E42
047D4:  MOVFF  715,FEA
047D8:  MOVFF  714,FE9
047DC:  MOVFF  00,FEF
047E0:  MOVFF  01,FEC
047E4:  MOVFF  02,FEC
047E8:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
047EC:  MOVLB  7
047EE:  MOVF   x07,W
047F0:  MULLW  28
047F2:  MOVF   FF3,W
047F4:  CLRF   x15
047F6:  MOVWF  x14
047F8:  MOVLW  1C
047FA:  ADDWF  x14,W
047FC:  MOVWF  01
047FE:  MOVLW  00
04800:  ADDWFC x15,W
04802:  MOVWF  03
04804:  MOVF   01,W
04806:  ADDLW  20
04808:  MOVWF  FE9
0480A:  MOVLW  00
0480C:  ADDWFC 03,W
0480E:  MOVWF  FEA
04810:  MOVFF  FEF,752
04814:  MOVFF  FEC,715
04818:  MOVFF  FEC,754
0481C:  MOVFF  FEC,755
04820:  CLRF   x51
04822:  CLRF   x50
04824:  MOVLW  7C
04826:  MOVWF  x4F
04828:  MOVLW  84
0482A:  MOVWF  x4E
0482C:  MOVFF  715,753
04830:  MOVLB  0
04832:  CALL   1CD8
04836:  BNC   486A
04838:  MOVLB  7
0483A:  MOVF   x07,W
0483C:  MULLW  28
0483E:  MOVF   FF3,W
04840:  CLRF   x15
04842:  MOVWF  x14
04844:  MOVLW  1C
04846:  ADDWF  x14,W
04848:  MOVWF  01
0484A:  MOVLW  00
0484C:  ADDWFC x15,W
0484E:  MOVWF  03
04850:  MOVF   01,W
04852:  ADDLW  20
04854:  MOVWF  FE9
04856:  MOVLW  00
04858:  ADDWFC 03,W
0485A:  MOVWF  FEA
0485C:  MOVLW  84
0485E:  MOVWF  FEF
04860:  MOVLW  7C
04862:  MOVWF  FEC
04864:  CLRF   FEC
04866:  CLRF   FEC
04868:  BRA    48E6
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
0486A:  MOVLB  7
0486C:  MOVF   x07,W
0486E:  MULLW  28
04870:  MOVF   FF3,W
04872:  CLRF   x15
04874:  MOVWF  x14
04876:  MOVLW  1C
04878:  ADDWF  x14,W
0487A:  MOVWF  01
0487C:  MOVLW  00
0487E:  ADDWFC x15,W
04880:  MOVWF  03
04882:  MOVF   01,W
04884:  ADDLW  20
04886:  MOVWF  FE9
04888:  MOVLW  00
0488A:  ADDWFC 03,W
0488C:  MOVWF  FEA
0488E:  MOVFF  FEF,74E
04892:  MOVFF  FEC,715
04896:  MOVFF  FEC,750
0489A:  MOVFF  FEC,751
0489E:  MOVFF  715,74F
048A2:  CLRF   x55
048A4:  CLRF   x54
048A6:  MOVLW  FC
048A8:  MOVWF  x53
048AA:  MOVLW  84
048AC:  MOVWF  x52
048AE:  MOVLB  0
048B0:  CALL   1CD8
048B4:  BNC   48E8
048B6:  MOVLB  7
048B8:  MOVF   x07,W
048BA:  MULLW  28
048BC:  MOVF   FF3,W
048BE:  CLRF   x15
048C0:  MOVWF  x14
048C2:  MOVLW  1C
048C4:  ADDWF  x14,W
048C6:  MOVWF  01
048C8:  MOVLW  00
048CA:  ADDWFC x15,W
048CC:  MOVWF  03
048CE:  MOVF   01,W
048D0:  ADDLW  20
048D2:  MOVWF  FE9
048D4:  MOVLW  00
048D6:  ADDWFC 03,W
048D8:  MOVWF  FEA
048DA:  MOVLW  84
048DC:  MOVWF  FEF
048DE:  MOVLW  FC
048E0:  MOVWF  FEC
048E2:  CLRF   FEC
048E4:  CLRF   FEC
048E6:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
048E8:  MOVLB  7
048EA:  MOVF   x07,W
048EC:  MULLW  28
048EE:  MOVF   FF3,W
048F0:  CLRF   x15
048F2:  MOVWF  x14
048F4:  MOVLW  20
048F6:  ADDWF  x14,W
048F8:  MOVWF  FE9
048FA:  MOVLW  00
048FC:  ADDWFC x15,W
048FE:  MOVWF  FEA
04900:  MOVFF  FEF,757
04904:  MOVFF  FEC,01
04908:  MOVFF  FEC,02
0490C:  MOVFF  FEC,03
04910:  MOVFF  70B,756
04914:  MOVFF  70A,755
04918:  MOVFF  709,754
0491C:  MOVFF  708,753
04920:  MOVFF  03,75A
04924:  MOVFF  02,759
04928:  MOVFF  01,758
0492C:  MOVLB  0
0492E:  CALL   0D4C
04932:  MOVFF  03,70F
04936:  MOVFF  02,70E
0493A:  MOVFF  01,70D
0493E:  MOVFF  00,70C
04942:  MOVLB  7
04944:  MOVF   x07,W
04946:  MULLW  28
04948:  MOVF   FF3,W
0494A:  CLRF   x17
0494C:  MOVWF  x16
0494E:  MOVLW  08
04950:  ADDWF  x16,W
04952:  MOVWF  01
04954:  MOVLW  00
04956:  ADDWFC x17,W
04958:  MOVWF  03
0495A:  MOVF   01,W
0495C:  ADDLW  20
0495E:  MOVWF  FE9
04960:  MOVLW  00
04962:  ADDWFC 03,W
04964:  MOVWF  FEA
04966:  MOVFF  FEF,716
0496A:  MOVFF  FEC,717
0496E:  MOVFF  FEC,718
04972:  MOVFF  FEC,719
04976:  MOVF   x07,W
04978:  MULLW  28
0497A:  MOVF   FF3,W
0497C:  CLRF   x1B
0497E:  MOVWF  x1A
04980:  MOVLW  10
04982:  ADDWF  x1A,W
04984:  MOVWF  01
04986:  MOVLW  00
04988:  ADDWFC x1B,W
0498A:  MOVWF  03
0498C:  MOVF   01,W
0498E:  ADDLW  20
04990:  MOVWF  FE9
04992:  MOVLW  00
04994:  ADDWFC 03,W
04996:  MOVWF  FEA
04998:  MOVFF  FEF,752
0499C:  MOVFF  FEC,753
049A0:  MOVFF  FEC,754
049A4:  MOVFF  FEC,755
049A8:  MOVF   x07,W
049AA:  MULLW  28
049AC:  MOVF   FF3,W
049AE:  CLRF   x1F
049B0:  MOVWF  x1E
049B2:  MOVLW  14
049B4:  ADDWF  x1E,W
049B6:  MOVWF  01
049B8:  MOVLW  00
049BA:  ADDWFC x1F,W
049BC:  MOVWF  03
049BE:  MOVF   01,W
049C0:  ADDLW  20
049C2:  MOVWF  FE9
049C4:  MOVLW  00
049C6:  ADDWFC 03,W
049C8:  MOVWF  FEA
049CA:  MOVFF  FEF,756
049CE:  MOVFF  FEC,01
049D2:  MOVFF  FEC,02
049D6:  MOVFF  FEC,03
049DA:  MOVFF  FEA,71F
049DE:  MOVFF  FE9,71E
049E2:  BSF    FD8.1
049E4:  MOVFF  03,759
049E8:  MOVFF  02,758
049EC:  MOVFF  01,757
049F0:  MOVLB  0
049F2:  CALL   0E42
049F6:  MOVFF  71F,FEA
049FA:  MOVFF  71E,FE9
049FE:  MOVFF  719,756
04A02:  MOVFF  718,755
04A06:  MOVFF  717,754
04A0A:  MOVFF  716,753
04A0E:  MOVFF  03,75A
04A12:  MOVFF  02,759
04A16:  MOVFF  01,758
04A1A:  MOVFF  00,757
04A1E:  CALL   0D4C
04A22:  MOVFF  03,713
04A26:  MOVFF  02,712
04A2A:  MOVFF  01,711
04A2E:  MOVFF  00,710
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A32:  MOVLB  7
04A34:  MOVF   x07,W
04A36:  MULLW  28
04A38:  MOVF   FF3,W
04A3A:  CLRF   x15
04A3C:  MOVWF  x14
04A3E:  MOVLW  18
04A40:  ADDWF  x14,W
04A42:  MOVWF  01
04A44:  MOVLW  00
04A46:  ADDWFC x15,W
04A48:  MOVWF  03
04A4A:  MOVF   01,W
04A4C:  ADDLW  20
04A4E:  MOVWF  01
04A50:  MOVLW  00
04A52:  ADDWFC 03,F
04A54:  MOVFF  01,714
04A58:  MOVFF  03,715
04A5C:  MOVF   x07,W
04A5E:  MULLW  28
04A60:  MOVF   FF3,W
04A62:  CLRF   x17
04A64:  MOVWF  x16
04A66:  MOVLW  1C
04A68:  ADDWF  x16,W
04A6A:  MOVWF  01
04A6C:  MOVLW  00
04A6E:  ADDWFC x17,W
04A70:  MOVWF  03
04A72:  MOVF   01,W
04A74:  ADDLW  20
04A76:  MOVWF  FE9
04A78:  MOVLW  00
04A7A:  ADDWFC 03,W
04A7C:  MOVWF  FEA
04A7E:  MOVFF  FEF,756
04A82:  MOVFF  FEC,01
04A86:  MOVFF  FEC,02
04A8A:  MOVFF  FEC,03
04A8E:  MOVFF  FEA,717
04A92:  MOVFF  FE9,716
04A96:  BCF    FD8.1
04A98:  MOVFF  70F,755
04A9C:  MOVFF  70E,754
04AA0:  MOVFF  70D,753
04AA4:  MOVFF  70C,752
04AA8:  MOVFF  03,759
04AAC:  MOVFF  02,758
04AB0:  MOVFF  01,757
04AB4:  MOVLB  0
04AB6:  CALL   0E42
04ABA:  MOVFF  717,FEA
04ABE:  MOVFF  716,FE9
04AC2:  MOVFF  03,71B
04AC6:  MOVFF  02,71A
04ACA:  MOVFF  01,719
04ACE:  MOVFF  00,718
04AD2:  BCF    FD8.1
04AD4:  MOVFF  03,755
04AD8:  MOVFF  02,754
04ADC:  MOVFF  01,753
04AE0:  MOVFF  00,752
04AE4:  MOVFF  713,759
04AE8:  MOVFF  712,758
04AEC:  MOVFF  711,757
04AF0:  MOVFF  710,756
04AF4:  CALL   0E42
04AF8:  MOVFF  715,FEA
04AFC:  MOVFF  714,FE9
04B00:  MOVFF  00,FEF
04B04:  MOVFF  01,FEC
04B08:  MOVFF  02,FEC
04B0C:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B10:  MOVLB  7
04B12:  MOVF   x07,W
04B14:  MULLW  28
04B16:  MOVF   FF3,W
04B18:  CLRF   x15
04B1A:  MOVWF  x14
04B1C:  MOVLW  18
04B1E:  ADDWF  x14,W
04B20:  MOVWF  01
04B22:  MOVLW  00
04B24:  ADDWFC x15,W
04B26:  MOVWF  03
04B28:  MOVF   01,W
04B2A:  ADDLW  20
04B2C:  MOVWF  FE9
04B2E:  MOVLW  00
04B30:  ADDWFC 03,W
04B32:  MOVWF  FEA
04B34:  MOVFF  FEF,752
04B38:  MOVFF  FEC,715
04B3C:  MOVFF  FEC,754
04B40:  MOVFF  FEC,755
04B44:  CLRF   x51
04B46:  CLRF   x50
04B48:  MOVLW  7C
04B4A:  MOVWF  x4F
04B4C:  MOVLW  84
04B4E:  MOVWF  x4E
04B50:  MOVFF  715,753
04B54:  MOVLB  0
04B56:  CALL   1CD8
04B5A:  BNC   4B8E
04B5C:  MOVLB  7
04B5E:  MOVF   x07,W
04B60:  MULLW  28
04B62:  MOVF   FF3,W
04B64:  CLRF   x15
04B66:  MOVWF  x14
04B68:  MOVLW  18
04B6A:  ADDWF  x14,W
04B6C:  MOVWF  01
04B6E:  MOVLW  00
04B70:  ADDWFC x15,W
04B72:  MOVWF  03
04B74:  MOVF   01,W
04B76:  ADDLW  20
04B78:  MOVWF  FE9
04B7A:  MOVLW  00
04B7C:  ADDWFC 03,W
04B7E:  MOVWF  FEA
04B80:  MOVLW  84
04B82:  MOVWF  FEF
04B84:  MOVLW  7C
04B86:  MOVWF  FEC
04B88:  CLRF   FEC
04B8A:  CLRF   FEC
04B8C:  BRA    4C0A
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04B8E:  MOVLB  7
04B90:  MOVF   x07,W
04B92:  MULLW  28
04B94:  MOVF   FF3,W
04B96:  CLRF   x15
04B98:  MOVWF  x14
04B9A:  MOVLW  18
04B9C:  ADDWF  x14,W
04B9E:  MOVWF  01
04BA0:  MOVLW  00
04BA2:  ADDWFC x15,W
04BA4:  MOVWF  03
04BA6:  MOVF   01,W
04BA8:  ADDLW  20
04BAA:  MOVWF  FE9
04BAC:  MOVLW  00
04BAE:  ADDWFC 03,W
04BB0:  MOVWF  FEA
04BB2:  MOVFF  FEF,74E
04BB6:  MOVFF  FEC,715
04BBA:  MOVFF  FEC,750
04BBE:  MOVFF  FEC,751
04BC2:  MOVFF  715,74F
04BC6:  CLRF   x55
04BC8:  CLRF   x54
04BCA:  MOVLW  FC
04BCC:  MOVWF  x53
04BCE:  MOVLW  84
04BD0:  MOVWF  x52
04BD2:  MOVLB  0
04BD4:  CALL   1CD8
04BD8:  BNC   4C0A
04BDA:  MOVLB  7
04BDC:  MOVF   x07,W
04BDE:  MULLW  28
04BE0:  MOVF   FF3,W
04BE2:  CLRF   x15
04BE4:  MOVWF  x14
04BE6:  MOVLW  18
04BE8:  ADDWF  x14,W
04BEA:  MOVWF  01
04BEC:  MOVLW  00
04BEE:  ADDWFC x15,W
04BF0:  MOVWF  03
04BF2:  MOVF   01,W
04BF4:  ADDLW  20
04BF6:  MOVWF  FE9
04BF8:  MOVLW  00
04BFA:  ADDWFC 03,W
04BFC:  MOVWF  FEA
04BFE:  MOVLW  84
04C00:  MOVWF  FEF
04C02:  MOVLW  FC
04C04:  MOVWF  FEC
04C06:  CLRF   FEC
04C08:  CLRF   FEC
04C0A:  MOVLB  0
04C0C:  GOTO   4C84 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C10:  MOVLB  7
04C12:  MOVF   x06,W
04C14:  MULLW  28
04C16:  MOVF   FF3,W
04C18:  CLRF   x08
04C1A:  MOVWF  x07
04C1C:  MOVLW  0C
04C1E:  ADDWF  x07,W
04C20:  MOVWF  01
04C22:  MOVLW  00
04C24:  ADDWFC x08,W
04C26:  MOVWF  03
04C28:  MOVF   01,W
04C2A:  ADDLW  20
04C2C:  MOVWF  FE9
04C2E:  MOVLW  00
04C30:  ADDWFC 03,W
04C32:  MOVWF  FEA
04C34:  MOVFF  FEF,74E
04C38:  MOVFF  FEC,74F
04C3C:  MOVFF  FEC,750
04C40:  MOVFF  FEC,751
04C44:  MOVF   x06,W
04C46:  MULLW  28
04C48:  MOVF   FF3,W
04C4A:  CLRF   x0C
04C4C:  MOVWF  x0B
04C4E:  MOVLW  10
04C50:  ADDWF  x0B,W
04C52:  MOVWF  01
04C54:  MOVLW  00
04C56:  ADDWFC x0C,W
04C58:  MOVWF  03
04C5A:  MOVF   01,W
04C5C:  ADDLW  20
04C5E:  MOVWF  FE9
04C60:  MOVLW  00
04C62:  ADDWFC 03,W
04C64:  MOVWF  FEA
04C66:  MOVFF  FEF,752
04C6A:  MOVFF  FEC,753
04C6E:  MOVFF  FEC,754
04C72:  MOVFF  FEC,755
04C76:  MOVLB  0
04C78:  CALL   1CD8
04C7C:  BZ    4C84
04C7E:  MOVFF  706,707
04C82:  BRA    467E
....................    if ((index++) >= numChannels) index = 0;
04C84:  MOVLB  1
04C86:  MOVF   xE9,W
04C88:  INCF   xE9,F
04C8A:  SUBLW  01
04C8C:  BC    4C90
04C8E:  CLRF   xE9
04C90:  MOVLB  0
04C92:  GOTO   4D9E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00AF8:  CLRF   03
00AFA:  MOVF   F91,W
00AFC:  MOVFF  708,F91
00B00:  RRCF   F94,W
00B02:  BNC   0B00
00B04:  MOVF   F91,W
00B06:  MOVWF  02
00B08:  MOVFF  707,F91
00B0C:  RRCF   F94,W
00B0E:  BNC   0B0C
00B10:  MOVF   F91,W
00B12:  MOVWF  01
00B14:  MOVFF  706,F91
00B18:  RRCF   F94,W
00B1A:  BNC   0B18
00B1C:  MOVFF  F91,00
00B20:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
045F2:  MOVLB  7
045F4:  MOVF   x07,F
045F6:  BZ    463A
....................       if (chMap[0] == ch) output_low(INV_HVX);
045F8:  MOVLW  00
045FA:  MOVLB  0
045FC:  BTFSC  x70.0
045FE:  MOVLW  01
04600:  MOVLB  7
04602:  SUBWF  x06,W
04604:  BNZ   460C
04606:  MOVLW  04
04608:  MOVWF  F88
0460A:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0460C:  MOVLW  00
0460E:  MOVLB  0
04610:  BTFSC  x70.1
04612:  MOVLW  01
04614:  MOVLB  7
04616:  SUBWF  x06,W
04618:  BNZ   4620
0461A:  MOVLW  04
0461C:  MOVWF  F88
0461E:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04620:  MOVF   x06,W
04622:  MULLW  07
04624:  MOVF   FF3,W
04626:  CLRF   x09
04628:  MOVWF  x08
0462A:  MOVLW  64
0462C:  ADDWF  x08,W
0462E:  MOVWF  FE9
04630:  MOVLW  01
04632:  ADDWFC x09,W
04634:  MOVWF  FEA
04636:  BSF    FEF.0
....................    }
04638:  BRA    467A
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
0463A:  MOVLW  00
0463C:  MOVLB  0
0463E:  BTFSC  x70.0
04640:  MOVLW  01
04642:  MOVLB  7
04644:  SUBWF  x06,W
04646:  BNZ   464E
04648:  MOVLW  04
0464A:  MOVWF  F88
0464C:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
0464E:  MOVLW  00
04650:  MOVLB  0
04652:  BTFSC  x70.1
04654:  MOVLW  01
04656:  MOVLB  7
04658:  SUBWF  x06,W
0465A:  BNZ   4662
0465C:  MOVLW  04
0465E:  MOVWF  F88
04660:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
04662:  MOVF   x06,W
04664:  MULLW  07
04666:  MOVF   FF3,W
04668:  CLRF   x09
0466A:  MOVWF  x08
0466C:  MOVLW  64
0466E:  ADDWF  x08,W
04670:  MOVWF  FE9
04672:  MOVLW  01
04674:  ADDWFC x09,W
04676:  MOVWF  FEA
04678:  BCF    FEF.0
....................    }
0467A:  MOVLB  0
0467C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04C96:  MOVLB  7
04C98:  CLRF   x05
04C9A:  CLRF   x04
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04C9C:  MOVFF  703,710
04CA0:  CLRF   x12
04CA2:  MOVLW  71
04CA4:  MOVWF  x11
04CA6:  MOVLB  0
04CA8:  RCALL  45BC
04CAA:  MOVF   01,F
04CAC:  BNZ   4D98
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04CAE:  MOVLB  7
04CB0:  MOVF   x03,W
04CB2:  MULLW  07
04CB4:  MOVF   FF3,W
04CB6:  CLRF   x07
04CB8:  MOVWF  x06
04CBA:  MOVLW  03
04CBC:  ADDWF  x06,W
04CBE:  MOVWF  01
04CC0:  MOVLW  00
04CC2:  ADDWFC x07,W
04CC4:  MOVWF  03
04CC6:  MOVF   01,W
04CC8:  ADDLW  64
04CCA:  MOVWF  FE9
04CCC:  MOVLW  01
04CCE:  ADDWFC 03,W
04CD0:  MOVWF  FEA
04CD2:  MOVFF  FEF,74E
04CD6:  MOVFF  FEC,74F
04CDA:  MOVFF  FEC,750
04CDE:  MOVFF  FEC,751
04CE2:  CLRF   x55
04CE4:  CLRF   x54
04CE6:  CLRF   x53
04CE8:  CLRF   x52
04CEA:  MOVLB  0
04CEC:  CALL   1CD8
04CF0:  BNC   4D02
04CF2:  MOVFF  703,706
04CF6:  MOVLW  01
04CF8:  MOVLB  7
04CFA:  MOVWF  x07
04CFC:  MOVLB  0
04CFE:  RCALL  45F2
04D00:  BRA    4D0E
....................         else                         invert_voltage(ch, FALSE);
04D02:  MOVFF  703,706
04D06:  MOVLB  7
04D08:  CLRF   x07
04D0A:  MOVLB  0
04D0C:  RCALL  45F2
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D0E:  MOVLB  7
04D10:  MOVF   x03,W
04D12:  MULLW  07
04D14:  MOVF   FF3,W
04D16:  CLRF   x07
04D18:  MOVWF  x06
04D1A:  MOVLW  03
04D1C:  ADDWF  x06,W
04D1E:  MOVWF  01
04D20:  MOVLW  00
04D22:  ADDWFC x07,W
04D24:  MOVWF  03
04D26:  MOVF   01,W
04D28:  ADDLW  64
04D2A:  MOVWF  FE9
04D2C:  MOVLW  01
04D2E:  ADDWFC 03,W
04D30:  MOVWF  FEA
04D32:  MOVFF  FEF,00
04D36:  MOVFF  FEC,01
04D3A:  MOVFF  FEC,02
04D3E:  MOVFF  FEC,03
04D42:  BCF    01.7
04D44:  MOVFF  03,709
04D48:  MOVFF  02,708
04D4C:  MOVFF  01,707
04D50:  MOVFF  00,706
04D54:  MOVFF  03,756
04D58:  MOVFF  02,755
04D5C:  MOVFF  01,754
04D60:  MOVFF  00,753
04D64:  MOVLW  66
04D66:  MOVWF  x5A
04D68:  MOVLW  D6
04D6A:  MOVWF  x59
04D6C:  MOVLW  23
04D6E:  MOVWF  x58
04D70:  MOVLW  88
04D72:  MOVWF  x57
04D74:  MOVLB  0
04D76:  CALL   0D4C
04D7A:  MOVFF  03,751
04D7E:  MOVFF  02,750
04D82:  MOVFF  01,74F
04D86:  MOVFF  00,74E
04D8A:  CALL   26CC
04D8E:  MOVFF  02,705
04D92:  MOVFF  01,704
....................     }
04D96:  BRA    4E88
....................     else {
....................         pid_task(ch);
04D98:  MOVFF  703,706
04D9C:  BRA    4C10
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04D9E:  MOVLB  7
04DA0:  MOVF   x03,W
04DA2:  MULLW  28
04DA4:  MOVF   FF3,W
04DA6:  CLRF   x07
04DA8:  MOVWF  x06
04DAA:  MOVLW  18
04DAC:  ADDWF  x06,W
04DAE:  MOVWF  01
04DB0:  MOVLW  00
04DB2:  ADDWFC x07,W
04DB4:  MOVWF  03
04DB6:  MOVF   01,W
04DB8:  ADDLW  20
04DBA:  MOVWF  FE9
04DBC:  MOVLW  00
04DBE:  ADDWFC 03,W
04DC0:  MOVWF  FEA
04DC2:  MOVFF  FEF,74E
04DC6:  MOVFF  FEC,74F
04DCA:  MOVFF  FEC,750
04DCE:  MOVFF  FEC,751
04DD2:  CLRF   x55
04DD4:  CLRF   x54
04DD6:  CLRF   x53
04DD8:  CLRF   x52
04DDA:  MOVLB  0
04DDC:  CALL   1CD8
04DE0:  BNC   4DF2
04DE2:  MOVFF  703,706
04DE6:  MOVLW  01
04DE8:  MOVLB  7
04DEA:  MOVWF  x07
04DEC:  MOVLB  0
04DEE:  RCALL  45F2
04DF0:  BRA    4E00
....................         else                       invert_voltage(ch, FALSE);
04DF2:  MOVFF  703,706
04DF6:  MOVLB  7
04DF8:  CLRF   x07
04DFA:  MOVLB  0
04DFC:  CALL   45F2
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E00:  MOVLB  7
04E02:  MOVF   x03,W
04E04:  MULLW  28
04E06:  MOVF   FF3,W
04E08:  CLRF   x07
04E0A:  MOVWF  x06
04E0C:  MOVLW  18
04E0E:  ADDWF  x06,W
04E10:  MOVWF  01
04E12:  MOVLW  00
04E14:  ADDWFC x07,W
04E16:  MOVWF  03
04E18:  MOVF   01,W
04E1A:  ADDLW  20
04E1C:  MOVWF  FE9
04E1E:  MOVLW  00
04E20:  ADDWFC 03,W
04E22:  MOVWF  FEA
04E24:  MOVFF  FEF,00
04E28:  MOVFF  FEC,01
04E2C:  MOVFF  FEC,02
04E30:  MOVFF  FEC,03
04E34:  BCF    01.7
04E36:  MOVFF  03,709
04E3A:  MOVFF  02,708
04E3E:  MOVFF  01,707
04E42:  MOVFF  00,706
04E46:  MOVFF  03,756
04E4A:  MOVFF  02,755
04E4E:  MOVFF  01,754
04E52:  MOVFF  00,753
04E56:  MOVLW  66
04E58:  MOVWF  x5A
04E5A:  MOVLW  D6
04E5C:  MOVWF  x59
04E5E:  MOVLW  23
04E60:  MOVWF  x58
04E62:  MOVLW  88
04E64:  MOVWF  x57
04E66:  MOVLB  0
04E68:  CALL   0D4C
04E6C:  MOVFF  03,751
04E70:  MOVFF  02,750
04E74:  MOVFF  01,74F
04E78:  MOVFF  00,74E
04E7C:  CALL   26CC
04E80:  MOVFF  02,705
04E84:  MOVFF  01,704
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04E88:  MOVLB  7
04E8A:  MOVF   x03,W
04E8C:  MULLW  07
04E8E:  MOVF   FF3,W
04E90:  CLRF   x07
04E92:  MOVWF  x06
04E94:  MOVLW  01
04E96:  ADDWF  x06,W
04E98:  MOVWF  01
04E9A:  MOVLW  00
04E9C:  ADDWFC x07,W
04E9E:  MOVWF  03
04EA0:  MOVF   01,W
04EA2:  ADDLW  64
04EA4:  MOVWF  FE9
04EA6:  MOVLW  01
04EA8:  ADDWFC 03,W
04EAA:  MOVWF  FEA
04EAC:  MOVFF  705,FEC
04EB0:  MOVF   FED,F
04EB2:  MOVFF  704,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04EB6:  MOVLW  00
04EB8:  MOVLB  0
04EBA:  BTFSC  x70.0
04EBC:  MOVLW  01
04EBE:  MOVLB  7
04EC0:  SUBWF  x03,W
04EC2:  BNZ   4ECA
04EC4:  MOVLW  E8
04EC6:  MOVWF  F8B
04EC8:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04ECA:  MOVLW  00
04ECC:  MOVLB  0
04ECE:  BTFSC  x70.1
04ED0:  MOVLW  01
04ED2:  MOVLB  7
04ED4:  SUBWF  x03,W
04ED6:  BNZ   4EDE
04ED8:  MOVLW  E8
04EDA:  MOVWF  F8B
04EDC:  BSF    F86.1
....................    
....................     delay_ms(1);
04EDE:  MOVLW  01
04EE0:  MOVWF  x09
04EE2:  MOVLB  0
04EE4:  CALL   042A
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04EE8:  MOVLW  00
04EEA:  BTFSC  x70.0
04EEC:  MOVLW  01
04EEE:  MOVLB  7
04EF0:  SUBWF  x03,W
04EF2:  BNZ   4EFA
04EF4:  MOVLW  E8
04EF6:  MOVWF  F8B
04EF8:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04EFA:  MOVLW  00
04EFC:  MOVLB  0
04EFE:  BTFSC  x70.1
04F00:  MOVLW  01
04F02:  MOVLB  7
04F04:  SUBWF  x03,W
04F06:  BNZ   4F0E
04F08:  MOVLW  E8
04F0A:  MOVWF  F8B
04F0C:  BCF    F86.1
....................     delay_ms(1);
04F0E:  MOVLW  01
04F10:  MOVWF  x09
04F12:  MOVLB  0
04F14:  CALL   042A
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F18:  MOVLB  7
04F1A:  CLRF   x09
04F1C:  CLRF   x08
04F1E:  MOVFF  705,707
04F22:  MOVFF  704,706
04F26:  MOVLB  0
04F28:  CALL   0AF8
....................     delay_ms(1);
04F2C:  MOVLW  01
04F2E:  MOVLB  7
04F30:  MOVWF  x09
04F32:  MOVLB  0
04F34:  CALL   042A
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F38:  MOVLW  00
04F3A:  BTFSC  x70.0
04F3C:  MOVLW  01
04F3E:  MOVLB  7
04F40:  SUBWF  x03,W
04F42:  BNZ   4F4A
04F44:  MOVLW  E8
04F46:  MOVWF  F8B
04F48:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F4A:  MOVLW  00
04F4C:  MOVLB  0
04F4E:  BTFSC  x70.1
04F50:  MOVLW  01
04F52:  MOVLB  7
04F54:  SUBWF  x03,W
04F56:  BNZ   4F5E
04F58:  MOVLW  E8
04F5A:  MOVWF  F8B
04F5C:  BSF    F86.1
04F5E:  MOVLB  0
04F60:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04F62:  MOVLB  1
04F64:  MOVF   xEA,W
04F66:  XORLW  00
04F68:  MOVLB  0
04F6A:  BZ    4F72
04F6C:  XORLW  01
04F6E:  BZ    4F84
04F70:  BRA    4F94
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04F72:  MOVLB  7
04F74:  CLRF   x03
04F76:  MOVLB  0
04F78:  RCALL  4C96
....................          state = 1;
04F7A:  MOVLW  01
04F7C:  MOVLB  1
04F7E:  MOVWF  xEA
....................       break;
04F80:  MOVLB  0
04F82:  BRA    4F94
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04F84:  MOVLW  01
04F86:  MOVLB  7
04F88:  MOVWF  x03
04F8A:  MOVLB  0
04F8C:  RCALL  4C96
....................          state = 0;
04F8E:  MOVLB  1
04F90:  CLRF   xEA
....................       break;
04F92:  MOVLB  0
....................    }
04F94:  GOTO   A970 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B22:  MOVLB  7
00B24:  CLRF   x09
00B26:  CLRF   x08
00B28:  CLRF   x07
00B2A:  CLRF   x06
00B2C:  MOVLB  0
00B2E:  RCALL  0AF8
....................    output_low(_SYNC_X);
00B30:  MOVLW  E8
00B32:  MOVWF  F8B
00B34:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B36:  MOVWF  F8B
00B38:  BCF    F86.1
....................    output_high(_SYNC_X);
00B3A:  MOVWF  F8B
00B3C:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B3E:  MOVWF  F8B
00B40:  BSF    F86.1
00B42:  GOTO   A944 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B46:  MOVLB  7
00B48:  MOVF   x04,W
00B4A:  SUBLW  03
00B4C:  BTFSS  FD8.0
00B4E:  BRA    0CBC
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B50:  CLRF   x05
00B52:  MOVF   x05,W
00B54:  SUBLW  06
00B56:  BNC   0BA6
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B58:  CLRF   x45
00B5A:  MOVFF  704,744
00B5E:  CLRF   x47
00B60:  MOVLW  B5
00B62:  MOVWF  x46
00B64:  MOVLB  0
00B66:  RCALL  0864
00B68:  MOVFF  02,707
00B6C:  MOVFF  01,706
00B70:  MOVLW  06
00B72:  MOVLB  7
00B74:  ADDWF  x06,F
00B76:  MOVLW  00
00B78:  ADDWFC x07,F
00B7A:  CLRF   x45
00B7C:  MOVFF  705,744
00B80:  CLRF   x47
00B82:  MOVLW  19
00B84:  MOVWF  x46
00B86:  MOVLB  0
00B88:  RCALL  0864
00B8A:  MOVF   01,W
00B8C:  MOVLB  7
00B8E:  ADDWF  x06,F
00B90:  MOVF   02,W
00B92:  ADDWFC x07,F
00B94:  MOVLW  EB
00B96:  ADDWF  x06,W
00B98:  MOVWF  FE9
00B9A:  MOVLW  01
00B9C:  ADDWFC x07,W
00B9E:  MOVWF  FEA
00BA0:  CLRF   FEF
00BA2:  INCF   x05,F
00BA4:  BRA    0B52
....................       }
....................       SERcmd[recNum].t = 0;
00BA6:  CLRF   x45
00BA8:  MOVFF  704,744
00BAC:  CLRF   x47
00BAE:  MOVLW  B5
00BB0:  MOVWF  x46
00BB2:  MOVLB  0
00BB4:  RCALL  0864
00BB6:  MOVFF  01,706
00BBA:  MOVLW  05
00BBC:  MOVLB  7
00BBE:  ADDWF  01,W
00BC0:  MOVWF  01
00BC2:  MOVLW  00
00BC4:  ADDWFC 02,W
00BC6:  MOVWF  03
00BC8:  MOVF   01,W
00BCA:  ADDLW  EB
00BCC:  MOVWF  FE9
00BCE:  MOVLW  01
00BD0:  ADDWFC 03,W
00BD2:  MOVWF  FEA
00BD4:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00BD6:  CLRF   x45
00BD8:  MOVFF  704,744
00BDC:  CLRF   x47
00BDE:  MOVLW  B5
00BE0:  MOVWF  x46
00BE2:  MOVLB  0
00BE4:  RCALL  0864
00BE6:  MOVFF  01,706
00BEA:  MOVLW  01
00BEC:  MOVLB  7
00BEE:  ADDWF  01,W
00BF0:  MOVWF  01
00BF2:  MOVLW  00
00BF4:  ADDWFC 02,W
00BF6:  MOVWF  03
00BF8:  MOVF   01,W
00BFA:  ADDLW  EB
00BFC:  MOVWF  FE9
00BFE:  MOVLW  01
00C00:  ADDWFC 03,W
00C02:  MOVWF  FEA
00C04:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C06:  CLRF   x45
00C08:  MOVFF  704,744
00C0C:  CLRF   x47
00C0E:  MOVLW  B5
00C10:  MOVWF  x46
00C12:  MOVLB  0
00C14:  RCALL  0864
00C16:  MOVFF  01,706
00C1A:  MOVLW  02
00C1C:  MOVLB  7
00C1E:  ADDWF  01,W
00C20:  MOVWF  01
00C22:  MOVLW  00
00C24:  ADDWFC 02,W
00C26:  MOVWF  03
00C28:  MOVF   01,W
00C2A:  ADDLW  EB
00C2C:  MOVWF  FE9
00C2E:  MOVLW  01
00C30:  ADDWFC 03,W
00C32:  MOVWF  FEA
00C34:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C36:  CLRF   x45
00C38:  MOVFF  704,744
00C3C:  CLRF   x47
00C3E:  MOVLW  B5
00C40:  MOVWF  x46
00C42:  MOVLB  0
00C44:  RCALL  0864
00C46:  MOVFF  01,706
00C4A:  MOVLW  03
00C4C:  MOVLB  7
00C4E:  ADDWF  01,W
00C50:  MOVWF  01
00C52:  MOVLW  00
00C54:  ADDWFC 02,W
00C56:  MOVWF  03
00C58:  MOVF   01,W
00C5A:  ADDLW  EB
00C5C:  MOVWF  FE9
00C5E:  MOVLW  01
00C60:  ADDWFC 03,W
00C62:  MOVWF  FEA
00C64:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C66:  CLRF   x45
00C68:  MOVFF  704,744
00C6C:  CLRF   x47
00C6E:  MOVLW  B5
00C70:  MOVWF  x46
00C72:  MOVLB  0
00C74:  RCALL  0864
00C76:  MOVFF  01,706
00C7A:  MOVLW  04
00C7C:  MOVLB  7
00C7E:  ADDWF  01,W
00C80:  MOVWF  01
00C82:  MOVLW  00
00C84:  ADDWFC 02,W
00C86:  MOVWF  03
00C88:  MOVF   01,W
00C8A:  ADDLW  EB
00C8C:  MOVWF  FE9
00C8E:  MOVLW  01
00C90:  ADDWFC 03,W
00C92:  MOVWF  FEA
00C94:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00C96:  CLRF   x45
00C98:  MOVFF  704,744
00C9C:  CLRF   x47
00C9E:  MOVLW  B5
00CA0:  MOVWF  x46
00CA2:  MOVLB  0
00CA4:  RCALL  0864
00CA6:  MOVLW  EB
00CA8:  MOVLB  7
00CAA:  ADDWF  01,W
00CAC:  MOVWF  FE9
00CAE:  MOVLW  01
00CB0:  ADDWFC 02,W
00CB2:  MOVWF  FEA
00CB4:  BCF    FEF.0
....................       retData[0] = '\0';
00CB6:  MOVLB  4
00CB8:  CLRF   xC1
00CBA:  MOVLB  7
....................    }
00CBC:  MOVLB  0
00CBE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05554:  MOVLB  7
05556:  CLRF   x45
05558:  MOVFF  4BF,744
0555C:  CLRF   x47
0555E:  MOVLW  B5
05560:  MOVWF  x46
05562:  MOVLB  0
05564:  CALL   0864
05568:  MOVFF  02,705
0556C:  MOVFF  01,704
05570:  MOVLW  EB
05572:  MOVLB  7
05574:  ADDWF  01,W
05576:  MOVWF  FE9
05578:  MOVLW  01
0557A:  ADDWFC 02,W
0557C:  MOVWF  FEA
0557E:  BTFSC  FEF.0
05580:  BRA    55A2
....................    {
....................       if (SRI == SWI) return FALSE;
05582:  MOVLB  4
05584:  MOVF   xC0,W
05586:  SUBWF  xBF,W
05588:  BNZ   5590
0558A:  MOVLW  00
0558C:  MOVWF  01
0558E:  BRA    55A8
....................       SRI +=1;
05590:  MOVLW  01
05592:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05594:  MOVF   xBF,W
05596:  SUBLW  03
05598:  BC    559C
0559A:  CLRF   xBF
0559C:  MOVLB  0
0559E:  BRA    5554
055A0:  MOVLB  7
....................    }
....................    return TRUE;
055A2:  MOVLW  01
055A4:  MOVWF  01
055A6:  MOVLB  4
055A8:  MOVLB  0
055AA:  GOTO   A416 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
04FD0:  MOVLW  01
04FD2:  MOVLB  4
04FD4:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
04FD6:  MOVF   xC0,W
04FD8:  SUBLW  03
04FDA:  BC    4FDE
04FDC:  CLRF   xC0
04FDE:  MOVLB  0
04FE0:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef DEBUG_1
.................... #use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
.................... #endif
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, UART1, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,563
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x63.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
.................... //!#use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* printBuffer){
....................     output_high(TX_ENABLE);
*
0500E:  MOVLW  93
05010:  MOVWF  F89
05012:  BSF    F84.5
....................     delay_us(200);
05014:  MOVLW  C8
05016:  MOVLB  7
05018:  MOVWF  x0F
0501A:  MOVLB  0
0501C:  CALL   06F2
....................     
....................     fprintf(SERIAL, "%s\n", printBuffer);
05020:  MOVFF  705,FEA
05024:  MOVFF  704,FE9
05028:  BRA    4FE2
0502A:  MOVLW  0A
0502C:  MOVLB  E
0502E:  BTFSS  xC8.4
05030:  BRA    502E
05032:  MOVWF  F99
....................     delay_us(200);
05034:  MOVLW  C8
05036:  MOVLB  7
05038:  MOVWF  x0F
0503A:  MOVLB  0
0503C:  CALL   06F2
....................     
....................     output_low(TX_ENABLE);
05040:  MOVLW  93
05042:  MOVWF  F89
05044:  BCF    F84.5
05046:  RETURN 0
.................... }
.................... 
.................... //!void icd_out(char* printBuffer){
.................... //!    fprintf(ICD_STREAM, "%s\n", printBuffer);
.................... //!}
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr() {           
*
000E8:  MOVLB  0
....................     while (kbhit(SERIAL)) {
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................         UART_BUFFER[UART_WR_PTR]=fgetc(SERIAL);
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x61,W
000F6:  ADDLW  25
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,775
00104:  MOVFF  FE9,774
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  775,FEA
00110:  MOVFF  774,FE9
00114:  MOVFF  01,FEF
....................         UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x61,F
....................         if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x61,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x61
....................         BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x63.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................     }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
04F98:  CLRF   03
04F9A:  MOVLB  5
04F9C:  MOVF   x62,W
04F9E:  ADDLW  25
04FA0:  MOVWF  FE9
04FA2:  MOVLW  05
04FA4:  ADDWFC 03,W
04FA6:  MOVWF  FEA
04FA8:  MOVFF  FEF,704
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
04FAC:  MOVLW  01
04FAE:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
04FB0:  MOVF   x62,W
04FB2:  SUBLW  3B
04FB4:  BC    4FB8
04FB6:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
04FB8:  MOVF   x61,W
04FBA:  SUBWF  x62,W
04FBC:  BNZ   4FC4
04FBE:  MOVLB  1
04FC0:  BCF    x63.1
04FC2:  MOVLB  5
....................    return data;
04FC4:  MOVLB  7
04FC6:  MOVFF  704,01
04FCA:  MOVLB  0
04FCC:  GOTO   5090 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
05048:  MOVLB  1
0504A:  BTFSS  x63.1
0504C:  BRA    5548
0504E:  MOVLB  7
05050:  CLRF   x45
05052:  MOVFF  4C0,744
05056:  CLRF   x47
05058:  MOVLW  B5
0505A:  MOVWF  x46
0505C:  MOVLB  0
0505E:  CALL   0864
05062:  MOVFF  02,705
05066:  MOVFF  01,704
0506A:  MOVLW  EB
0506C:  MOVLB  7
0506E:  ADDWF  01,W
05070:  MOVWF  01
05072:  MOVLW  01
05074:  ADDWFC 02,W
05076:  MOVWF  03
05078:  MOVFF  01,FE9
0507C:  MOVWF  FEA
0507E:  BTFSS  FEF.0
05080:  BRA    5086
05082:  MOVLB  1
05084:  BRA    5548
....................    {  
....................       output_high(TX_ENABLE);
05086:  MOVLW  93
05088:  MOVWF  F89
0508A:  BSF    F84.5
....................       unsigned int8 rxChar = getchFromBuffer();
0508C:  MOVLB  0
0508E:  BRA    4F98
05090:  MOVFF  01,703
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05094:  MOVLB  7
05096:  MOVF   x03,W
05098:  SUBLW  0D
0509A:  BZ    50A2
0509C:  MOVF   x03,W
0509E:  SUBLW  20
050A0:  BNZ   50A4
....................       {
....................       }
050A2:  BRA    5542
....................       else if (rxChar == UART_SOT_CHAR)
050A4:  MOVF   x03,W
050A6:  SUBLW  7E
050A8:  BNZ   50EC
....................       {
....................          resetSERcmd(SWI);
050AA:  MOVFF  4C0,704
050AE:  MOVLB  0
050B0:  CALL   0B46
....................          SERcmd[SWI].t = rxChar;
050B4:  MOVLB  7
050B6:  CLRF   x45
050B8:  MOVFF  4C0,744
050BC:  CLRF   x47
050BE:  MOVLW  B5
050C0:  MOVWF  x46
050C2:  MOVLB  0
050C4:  CALL   0864
050C8:  MOVFF  01,704
050CC:  MOVLW  05
050CE:  MOVLB  7
050D0:  ADDWF  01,W
050D2:  MOVWF  01
050D4:  MOVLW  00
050D6:  ADDWFC 02,W
050D8:  MOVWF  03
050DA:  MOVF   01,W
050DC:  ADDLW  EB
050DE:  MOVWF  FE9
050E0:  MOVLW  01
050E2:  ADDWFC 03,W
050E4:  MOVWF  FEA
050E6:  MOVFF  703,FEF
....................       }
050EA:  BRA    5542
....................       else if (rxChar >= oneByteCmdTestValue)
050EC:  MOVF   x03,W
050EE:  SUBLW  7F
050F0:  BC    515C
....................       {
....................          resetSERcmd(SWI);
050F2:  MOVFF  4C0,704
050F6:  MOVLB  0
050F8:  CALL   0B46
....................          SERcmd[SWI].t = rxChar;
050FC:  MOVLB  7
050FE:  CLRF   x45
05100:  MOVFF  4C0,744
05104:  CLRF   x47
05106:  MOVLW  B5
05108:  MOVWF  x46
0510A:  MOVLB  0
0510C:  CALL   0864
05110:  MOVFF  01,704
05114:  MOVLW  05
05116:  MOVLB  7
05118:  ADDWF  01,W
0511A:  MOVWF  01
0511C:  MOVLW  00
0511E:  ADDWFC 02,W
05120:  MOVWF  03
05122:  MOVF   01,W
05124:  ADDLW  EB
05126:  MOVWF  FE9
05128:  MOVLW  01
0512A:  ADDWFC 03,W
0512C:  MOVWF  FEA
0512E:  MOVFF  703,FEF
....................          SERcmd[SWI].full = TRUE;
05132:  CLRF   x45
05134:  MOVFF  4C0,744
05138:  CLRF   x47
0513A:  MOVLW  B5
0513C:  MOVWF  x46
0513E:  MOVLB  0
05140:  CALL   0864
05144:  MOVLW  EB
05146:  MOVLB  7
05148:  ADDWF  01,W
0514A:  MOVWF  FE9
0514C:  MOVLW  01
0514E:  ADDWFC 02,W
05150:  MOVWF  FEA
05152:  BSF    FEF.0
....................          setNextSERWriteIndex();
05154:  MOVLB  0
05156:  RCALL  4FD0
....................       }
05158:  BRA    5540
0515A:  MOVLB  7
....................       else if (rxChar == UART_EOT_CHAR2)
0515C:  MOVF   x03,W
0515E:  SUBLW  0A
05160:  BTFSS  FD8.2
05162:  BRA    5268
....................       {
....................          SERcmd[SWI].full = TRUE;
05164:  CLRF   x45
05166:  MOVFF  4C0,744
0516A:  CLRF   x47
0516C:  MOVLW  B5
0516E:  MOVWF  x46
05170:  MOVLB  0
05172:  CALL   0864
05176:  MOVLW  EB
05178:  MOVLB  7
0517A:  ADDWF  01,W
0517C:  MOVWF  FE9
0517E:  MOVLW  01
05180:  ADDWFC 02,W
05182:  MOVWF  FEA
05184:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05186:  CLRF   x45
05188:  MOVFF  4C0,744
0518C:  CLRF   x47
0518E:  MOVLW  B5
05190:  MOVWF  x46
05192:  MOVLB  0
05194:  CALL   0864
05198:  MOVFF  01,704
0519C:  MOVLW  04
0519E:  MOVLB  7
051A0:  ADDWF  01,W
051A2:  MOVWF  01
051A4:  MOVLW  00
051A6:  ADDWFC 02,W
051A8:  MOVWF  03
051AA:  MOVF   01,W
051AC:  ADDLW  EB
051AE:  MOVWF  01
051B0:  MOVLW  01
051B2:  ADDWFC 03,F
051B4:  MOVFF  01,704
051B8:  MOVFF  03,705
051BC:  CLRF   x45
051BE:  MOVFF  4C0,744
051C2:  CLRF   x47
051C4:  MOVLW  B5
051C6:  MOVWF  x46
051C8:  MOVLB  0
051CA:  CALL   0864
051CE:  MOVFF  01,706
051D2:  MOVLW  02
051D4:  MOVLB  7
051D6:  ADDWF  01,W
051D8:  MOVWF  01
051DA:  MOVLW  00
051DC:  ADDWFC 02,W
051DE:  MOVWF  03
051E0:  MOVF   01,W
051E2:  ADDLW  EB
051E4:  MOVWF  FE9
051E6:  MOVLW  01
051E8:  ADDWFC 03,W
051EA:  MOVWF  FEA
051EC:  MOVFF  FEF,706
051F0:  MOVFF  705,FEA
051F4:  MOVFF  704,FE9
051F8:  MOVFF  706,FEF
....................          SERcmd[SWI].chrIndex = 0;
051FC:  CLRF   x45
051FE:  MOVFF  4C0,744
05202:  CLRF   x47
05204:  MOVLW  B5
05206:  MOVWF  x46
05208:  MOVLB  0
0520A:  CALL   0864
0520E:  MOVFF  01,704
05212:  MOVLW  01
05214:  MOVLB  7
05216:  ADDWF  01,W
05218:  MOVWF  01
0521A:  MOVLW  00
0521C:  ADDWFC 02,W
0521E:  MOVWF  03
05220:  MOVF   01,W
05222:  ADDLW  EB
05224:  MOVWF  FE9
05226:  MOVLW  01
05228:  ADDWFC 03,W
0522A:  MOVWF  FEA
0522C:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
0522E:  CLRF   x45
05230:  MOVFF  4C0,744
05234:  CLRF   x47
05236:  MOVLW  B5
05238:  MOVWF  x46
0523A:  MOVLB  0
0523C:  CALL   0864
05240:  MOVFF  01,704
05244:  MOVLW  02
05246:  MOVLB  7
05248:  ADDWF  01,W
0524A:  MOVWF  01
0524C:  MOVLW  00
0524E:  ADDWFC 02,W
05250:  MOVWF  03
05252:  MOVF   01,W
05254:  ADDLW  EB
05256:  MOVWF  FE9
05258:  MOVLW  01
0525A:  ADDWFC 03,W
0525C:  MOVWF  FEA
0525E:  CLRF   FEF
....................          setNextSERWriteIndex();
05260:  MOVLB  0
05262:  RCALL  4FD0
....................       }
05264:  BRA    5540
05266:  MOVLB  7
....................       else if (rxChar == delimiter)
05268:  MOVF   x03,W
0526A:  SUBLW  2C
0526C:  BNZ   532E
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
0526E:  CLRF   x45
05270:  MOVFF  4C0,744
05274:  CLRF   x47
05276:  MOVLW  B5
05278:  MOVWF  x46
0527A:  MOVLB  0
0527C:  CALL   0864
05280:  MOVFF  02,705
05284:  MOVFF  01,704
05288:  MOVLW  02
0528A:  MOVLB  7
0528C:  ADDWF  01,W
0528E:  MOVWF  01
05290:  MOVLW  00
05292:  ADDWFC 02,W
05294:  MOVWF  03
05296:  MOVF   01,W
05298:  ADDLW  EB
0529A:  MOVWF  FE9
0529C:  MOVLW  01
0529E:  ADDWFC 03,W
052A0:  MOVWF  FEA
052A2:  MOVF   FEF,W
052A4:  SUBLW  05
052A6:  BNC   5312
....................          {
....................             SERcmd[SWI].paramIndex +=1;
052A8:  CLRF   x45
052AA:  MOVFF  4C0,744
052AE:  CLRF   x47
052B0:  MOVLW  B5
052B2:  MOVWF  x46
052B4:  MOVLB  0
052B6:  CALL   0864
052BA:  MOVFF  01,704
052BE:  MOVLW  02
052C0:  MOVLB  7
052C2:  ADDWF  01,W
052C4:  MOVWF  01
052C6:  MOVLW  00
052C8:  ADDWFC 02,W
052CA:  MOVWF  03
052CC:  MOVF   01,W
052CE:  ADDLW  EB
052D0:  MOVWF  FE9
052D2:  MOVLW  01
052D4:  ADDWFC 03,W
052D6:  MOVWF  FEA
052D8:  MOVLW  01
052DA:  ADDWF  FEF,W
052DC:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
052DE:  CLRF   x45
052E0:  MOVFF  4C0,744
052E4:  CLRF   x47
052E6:  MOVLW  B5
052E8:  MOVWF  x46
052EA:  MOVLB  0
052EC:  CALL   0864
052F0:  MOVFF  01,704
052F4:  MOVLW  01
052F6:  MOVLB  7
052F8:  ADDWF  01,W
052FA:  MOVWF  01
052FC:  MOVLW  00
052FE:  ADDWFC 02,W
05300:  MOVWF  03
05302:  MOVF   01,W
05304:  ADDLW  EB
05306:  MOVWF  FE9
05308:  MOVLW  01
0530A:  ADDWFC 03,W
0530C:  MOVWF  FEA
0530E:  CLRF   FEF
....................          }
05310:  BRA    532C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05312:  MOVFF  4C0,704
05316:  MOVLB  0
05318:  CALL   0B46
....................             serial_out(retData);
0531C:  MOVLW  04
0531E:  MOVLB  7
05320:  MOVWF  x05
05322:  MOVLW  C1
05324:  MOVWF  x04
05326:  MOVLB  0
05328:  RCALL  500E
0532A:  MOVLB  7
....................          }
....................       }
0532C:  BRA    5542
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
0532E:  CLRF   x45
05330:  MOVFF  4C0,744
05334:  CLRF   x47
05336:  MOVLW  B5
05338:  MOVWF  x46
0533A:  MOVLB  0
0533C:  CALL   0864
05340:  MOVFF  02,705
05344:  MOVFF  01,704
05348:  MOVLW  01
0534A:  MOVLB  7
0534C:  ADDWF  01,W
0534E:  MOVWF  01
05350:  MOVLW  00
05352:  ADDWFC 02,W
05354:  MOVWF  03
05356:  MOVF   01,W
05358:  ADDLW  EB
0535A:  MOVWF  FE9
0535C:  MOVLW  01
0535E:  ADDWFC 03,W
05360:  MOVWF  FEA
05362:  MOVF   FEF,W
05364:  SUBLW  18
05366:  BTFSS  FD8.0
05368:  BRA    5528
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
0536A:  CLRF   x45
0536C:  MOVFF  4C0,744
05370:  CLRF   x47
05372:  MOVLW  B5
05374:  MOVWF  x46
05376:  MOVLB  0
05378:  CALL   0864
0537C:  MOVFF  02,705
05380:  MOVFF  01,704
05384:  MOVLW  06
05386:  MOVLB  7
05388:  ADDWF  x04,F
0538A:  MOVLW  00
0538C:  ADDWFC x05,F
0538E:  CLRF   x45
05390:  MOVFF  4C0,744
05394:  CLRF   x47
05396:  MOVLW  B5
05398:  MOVWF  x46
0539A:  MOVLB  0
0539C:  CALL   0864
053A0:  MOVFF  02,707
053A4:  MOVFF  01,706
053A8:  MOVLW  02
053AA:  MOVLB  7
053AC:  ADDWF  01,W
053AE:  MOVWF  01
053B0:  MOVLW  00
053B2:  ADDWFC 02,W
053B4:  MOVWF  03
053B6:  MOVF   01,W
053B8:  ADDLW  EB
053BA:  MOVWF  FE9
053BC:  MOVLW  01
053BE:  ADDWFC 03,W
053C0:  MOVWF  FEA
053C2:  CLRF   x45
053C4:  MOVFF  FEF,744
053C8:  CLRF   x47
053CA:  MOVLW  19
053CC:  MOVWF  x46
053CE:  MOVLB  0
053D0:  CALL   0864
053D4:  MOVFF  02,03
053D8:  MOVF   01,W
053DA:  MOVLB  7
053DC:  ADDWF  x04,F
053DE:  MOVF   02,W
053E0:  ADDWFC x05,F
053E2:  CLRF   x45
053E4:  MOVFF  4C0,744
053E8:  CLRF   x47
053EA:  MOVLW  B5
053EC:  MOVWF  x46
053EE:  MOVLB  0
053F0:  CALL   0864
053F4:  MOVFF  01,706
053F8:  MOVLW  01
053FA:  MOVLB  7
053FC:  ADDWF  01,W
053FE:  MOVWF  01
05400:  MOVLW  00
05402:  ADDWFC 02,W
05404:  MOVWF  03
05406:  MOVF   01,W
05408:  ADDLW  EB
0540A:  MOVWF  FE9
0540C:  MOVLW  01
0540E:  ADDWFC 03,W
05410:  MOVWF  FEA
05412:  MOVF   FEF,W
05414:  ADDWF  x04,W
05416:  MOVWF  01
05418:  MOVLW  00
0541A:  ADDWFC x05,W
0541C:  MOVWF  03
0541E:  MOVF   01,W
05420:  ADDLW  EB
05422:  MOVWF  FE9
05424:  MOVLW  01
05426:  ADDWFC 03,W
05428:  MOVWF  FEA
0542A:  MOVFF  703,FEF
....................             SERcmd[SWI].chrIndex += 1;
0542E:  CLRF   x45
05430:  MOVFF  4C0,744
05434:  CLRF   x47
05436:  MOVLW  B5
05438:  MOVWF  x46
0543A:  MOVLB  0
0543C:  CALL   0864
05440:  MOVFF  01,704
05444:  MOVLW  01
05446:  MOVLB  7
05448:  ADDWF  01,W
0544A:  MOVWF  01
0544C:  MOVLW  00
0544E:  ADDWFC 02,W
05450:  MOVWF  03
05452:  MOVF   01,W
05454:  ADDLW  EB
05456:  MOVWF  FE9
05458:  MOVLW  01
0545A:  ADDWFC 03,W
0545C:  MOVWF  FEA
0545E:  MOVLW  01
05460:  ADDWF  FEF,W
05462:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
05464:  CLRF   x45
05466:  MOVFF  4C0,744
0546A:  CLRF   x47
0546C:  MOVLW  B5
0546E:  MOVWF  x46
05470:  MOVLB  0
05472:  CALL   0864
05476:  MOVFF  02,705
0547A:  MOVFF  01,704
0547E:  MOVLW  06
05480:  MOVLB  7
05482:  ADDWF  x04,F
05484:  MOVLW  00
05486:  ADDWFC x05,F
05488:  CLRF   x45
0548A:  MOVFF  4C0,744
0548E:  CLRF   x47
05490:  MOVLW  B5
05492:  MOVWF  x46
05494:  MOVLB  0
05496:  CALL   0864
0549A:  MOVFF  02,707
0549E:  MOVFF  01,706
054A2:  MOVLW  02
054A4:  MOVLB  7
054A6:  ADDWF  01,W
054A8:  MOVWF  01
054AA:  MOVLW  00
054AC:  ADDWFC 02,W
054AE:  MOVWF  03
054B0:  MOVF   01,W
054B2:  ADDLW  EB
054B4:  MOVWF  FE9
054B6:  MOVLW  01
054B8:  ADDWFC 03,W
054BA:  MOVWF  FEA
054BC:  CLRF   x45
054BE:  MOVFF  FEF,744
054C2:  CLRF   x47
054C4:  MOVLW  19
054C6:  MOVWF  x46
054C8:  MOVLB  0
054CA:  CALL   0864
054CE:  MOVFF  02,03
054D2:  MOVF   01,W
054D4:  MOVLB  7
054D6:  ADDWF  x04,F
054D8:  MOVF   02,W
054DA:  ADDWFC x05,F
054DC:  CLRF   x45
054DE:  MOVFF  4C0,744
054E2:  CLRF   x47
054E4:  MOVLW  B5
054E6:  MOVWF  x46
054E8:  MOVLB  0
054EA:  CALL   0864
054EE:  MOVFF  01,706
054F2:  MOVLW  01
054F4:  MOVLB  7
054F6:  ADDWF  01,W
054F8:  MOVWF  01
054FA:  MOVLW  00
054FC:  ADDWFC 02,W
054FE:  MOVWF  03
05500:  MOVF   01,W
05502:  ADDLW  EB
05504:  MOVWF  FE9
05506:  MOVLW  01
05508:  ADDWFC 03,W
0550A:  MOVWF  FEA
0550C:  MOVF   FEF,W
0550E:  ADDWF  x04,W
05510:  MOVWF  01
05512:  MOVLW  00
05514:  ADDWFC x05,W
05516:  MOVWF  03
05518:  MOVF   01,W
0551A:  ADDLW  EB
0551C:  MOVWF  FE9
0551E:  MOVLW  01
05520:  ADDWFC 03,W
05522:  MOVWF  FEA
05524:  CLRF   FEF
....................          }
05526:  BRA    5542
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05528:  MOVFF  4C0,704
0552C:  MOVLB  0
0552E:  CALL   0B46
....................             serial_out(retData);
05532:  MOVLW  04
05534:  MOVLB  7
05536:  MOVWF  x05
05538:  MOVLW  C1
0553A:  MOVWF  x04
0553C:  MOVLB  0
0553E:  RCALL  500E
05540:  MOVLB  7
....................          }
....................       }
05542:  MOVLB  0
05544:  BRA    5048
05546:  MOVLB  1
....................    }
....................    output_low(TX_ENABLE);
05548:  MOVLW  93
0554A:  MOVWF  F89
0554C:  BCF    F84.5
0554E:  MOVLB  0
05550:  GOTO   A984 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00CC0:  MOVLB  7
00CC2:  CLRF   x03
00CC4:  MOVF   x03,W
00CC6:  SUBLW  03
00CC8:  BNC   0CD8
....................    {
....................       resetSERcmd(i);
00CCA:  MOVFF  703,704
00CCE:  MOVLB  0
00CD0:  RCALL  0B46
00CD2:  MOVLB  7
00CD4:  INCF   x03,F
00CD6:  BRA    0CC4
....................    }
....................    enable_interrupts(INT_RDA);
00CD8:  MOVLB  E
00CDA:  BSF    xC0.5
00CDC:  MOVLB  0
00CDE:  GOTO   A948 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00CE2:  MOVLB  E
00CE4:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00CE6:  MOVLW  01
00CE8:  MOVWF  FD1
00CEA:  MOVLW  07
00CEC:  MOVWF  FCE
00CEE:  CLRF   FCF
00CF0:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00CF2:  MOVLB  1
00CF4:  CLRF   x75
00CF6:  CLRF   x74
00CF8:  CLRF   x73
00CFA:  CLRF   x72
....................    timeoutReg1 = 0;
00CFC:  CLRF   x79
00CFE:  CLRF   x78
00D00:  CLRF   x77
00D02:  CLRF   x76
....................    timeoutReg2 = 0;
00D04:  CLRF   x7D
00D06:  CLRF   x7C
00D08:  CLRF   x7B
00D0A:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D0C:  MOVLB  E
00D0E:  BSF    xC1.0
00D10:  MOVLB  0
00D12:  GOTO   A94C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x75,F
0026C:  BNZ   027C
0026E:  MOVF   x74,F
00270:  BNZ   027C
00272:  MOVF   x73,F
00274:  BNZ   027C
00276:  MOVF   x72,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x72,F
00280:  MOVLW  00
00282:  SUBWFB x73,F
00284:  SUBWFB x74,F
00286:  SUBWFB x75,F
00288:  BRA    0292
0028A:  CLRF   x75
0028C:  CLRF   x74
0028E:  CLRF   x73
00290:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x79,F
00294:  BNZ   02A4
00296:  MOVF   x78,F
00298:  BNZ   02A4
0029A:  MOVF   x77,F
0029C:  BNZ   02A4
0029E:  MOVF   x76,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x76,F
002A8:  MOVLW  00
002AA:  SUBWFB x77,F
002AC:  SUBWFB x78,F
002AE:  SUBWFB x79,F
002B0:  BRA    02BA
002B2:  CLRF   x79
002B4:  CLRF   x78
002B6:  CLRF   x77
002B8:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x7D,F
002BC:  BNZ   02CC
002BE:  MOVF   x7C,F
002C0:  BNZ   02CC
002C2:  MOVF   x7B,F
002C4:  BNZ   02CC
002C6:  MOVF   x7A,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x7A,F
002D0:  MOVLW  00
002D2:  SUBWFB x7B,F
002D4:  SUBWFB x7C,F
002D6:  SUBWFB x7D,F
002D8:  BRA    02E2
002DA:  CLRF   x7D
002DC:  CLRF   x7C
002DE:  CLRF   x7B
002E0:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x7E,F
002E4:  BNZ   02EA
002E6:  MOVF   x7F,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x66,F
002F0:  MOVLW  00
002F2:  ADDWFC x67,F
002F4:  ADDWFC x68,F
002F6:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x69,F
002FA:  BNZ   0316
002FC:  MOVF   x68,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x7F,W
00304:  MOVLB  5
00306:  SUBWF  x67,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x7E,W
00310:  MOVLB  5
00312:  SUBWF  x66,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x69
0031E:  CLRF   x68
00320:  CLRF   x67
00322:  CLRF   x66
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63  // CRYO
.................... #define op_lower_bound -63 // CRYO
.................... 
.................... //!#define op_upper_bound 63  // AMBIENT 
.................... //!#define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
.................... 
.................... int8 getTelemetry(unsigned int8);           // gTlm
....................                                                       
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"gTlm",     &getTelemetry},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", version);
*
056FC:  MOVLW  04
056FE:  MOVLB  7
05700:  MOVWF  x45
05702:  MOVLW  C1
05704:  MOVWF  x44
05706:  MOVLB  0
05708:  RCALL  55AE
0570A:  MOVFF  02,03
0570E:  MOVF   01,W
05710:  ADDLW  C1
05712:  MOVLB  7
05714:  MOVWF  x0E
05716:  MOVLW  04
05718:  ADDWFC 02,W
0571A:  MOVWF  x0F
0571C:  MOVFF  FE8,565
05720:  MOVFF  70E,564
05724:  MOVLW  30
05726:  MOVWF  FF6
05728:  MOVLW  03
0572A:  MOVWF  FF7
0572C:  MOVLB  0
0572E:  RCALL  56DC
05730:  MOVLW  2C
05732:  MOVLB  7
05734:  MOVWF  x53
05736:  MOVLB  0
05738:  RCALL  55E6
....................     return SUCCESS;
0573A:  MOVLW  00
0573C:  MOVWF  01
0573E:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", serialID);
05740:  MOVLW  04
05742:  MOVLB  7
05744:  MOVWF  x45
05746:  MOVLW  C1
05748:  MOVWF  x44
0574A:  MOVLB  0
0574C:  RCALL  55AE
0574E:  MOVFF  02,03
05752:  MOVF   01,W
05754:  ADDLW  C1
05756:  MOVLB  7
05758:  MOVWF  x0E
0575A:  MOVLW  04
0575C:  ADDWFC 02,W
0575E:  MOVWF  x0F
05760:  MOVFF  FE8,565
05764:  MOVFF  70E,564
05768:  MOVLW  3A
0576A:  MOVWF  FF6
0576C:  MOVLW  03
0576E:  MOVWF  FF7
05770:  MOVLB  0
05772:  RCALL  56DC
05774:  MOVLW  2C
05776:  MOVLB  7
05778:  MOVWF  x53
0577A:  MOVLB  0
0577C:  RCALL  55E6
....................     return SUCCESS;
0577E:  MOVLW  00
05780:  MOVWF  01
05782:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................    
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05C88:  MOVLB  7
05C8A:  CLRF   x45
05C8C:  MOVFF  698,744
05C90:  CLRF   x47
05C92:  MOVLW  B5
05C94:  MOVWF  x46
05C96:  MOVLB  0
05C98:  CALL   0864
05C9C:  MOVFF  02,710
05CA0:  MOVFF  01,70F
05CA4:  MOVLW  06
05CA6:  MOVLB  7
05CA8:  ADDWF  x0F,F
05CAA:  MOVLW  00
05CAC:  ADDWFC x10,F
05CAE:  MOVLW  32
05CB0:  ADDWF  x0F,W
05CB2:  MOVWF  01
05CB4:  MOVLW  00
05CB6:  ADDWFC x10,W
05CB8:  MOVWF  03
05CBA:  MOVF   01,W
05CBC:  ADDLW  EB
05CBE:  MOVWF  01
05CC0:  MOVLW  01
05CC2:  ADDWFC 03,F
05CC4:  MOVFF  01,70F
05CC8:  MOVFF  03,710
05CCC:  MOVFF  03,737
05CD0:  MOVFF  01,736
05CD4:  MOVLB  0
05CD6:  RCALL  5784
05CD8:  MOVF   01,F
05CDA:  BNZ   5CE4
05CDC:  MOVLW  02
05CDE:  MOVWF  01
05CE0:  BRA    5E2A
05CE2:  BRA    5D40
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05CE4:  MOVLB  7
05CE6:  CLRF   x45
05CE8:  MOVFF  698,744
05CEC:  CLRF   x47
05CEE:  MOVLW  B5
05CF0:  MOVWF  x46
05CF2:  MOVLB  0
05CF4:  CALL   0864
05CF8:  MOVFF  02,710
05CFC:  MOVFF  01,70F
05D00:  MOVLW  06
05D02:  MOVLB  7
05D04:  ADDWF  x0F,F
05D06:  MOVLW  00
05D08:  ADDWFC x10,F
05D0A:  MOVLW  32
05D0C:  ADDWF  x0F,W
05D0E:  MOVWF  01
05D10:  MOVLW  00
05D12:  ADDWFC x10,W
05D14:  MOVWF  03
05D16:  MOVF   01,W
05D18:  ADDLW  EB
05D1A:  MOVWF  01
05D1C:  MOVLW  01
05D1E:  ADDWFC 03,F
05D20:  MOVFF  01,70F
05D24:  MOVFF  03,710
05D28:  MOVFF  03,737
05D2C:  MOVFF  01,736
05D30:  CLRF   x39
05D32:  CLRF   x38
05D34:  MOVLW  0A
05D36:  MOVWF  x3A
05D38:  MOVLB  0
05D3A:  RCALL  5874
05D3C:  MOVFF  01,70E
....................    
....................     /*** GET CHANNEL MAP ***************/ 
....................     if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05D40:  MOVLW  01
05D42:  MOVLB  7
05D44:  SUBWF  x0E,W
05D46:  MOVWF  x10
05D48:  CLRF   x12
05D4A:  MOVLW  70
05D4C:  MOVWF  x11
05D4E:  MOVLB  0
05D50:  CALL   45BC
05D54:  BTFSC  01.0
05D56:  BRA    5DAC
05D58:  MOVLW  04
05D5A:  MOVLB  7
05D5C:  MOVWF  x45
05D5E:  MOVLW  C1
05D60:  MOVWF  x44
05D62:  MOVLB  0
05D64:  RCALL  55AE
05D66:  MOVFF  02,03
05D6A:  MOVF   01,W
05D6C:  ADDLW  C1
05D6E:  MOVLB  7
05D70:  MOVWF  x0F
05D72:  MOVLW  04
05D74:  ADDWFC 02,W
05D76:  MOVWF  x10
05D78:  MOVFF  FE8,565
05D7C:  MOVFF  70F,564
05D80:  MOVFF  70E,737
05D84:  MOVLW  18
05D86:  MOVWF  x38
05D88:  MOVLB  0
05D8A:  RCALL  5BC8
05D8C:  MOVLW  2C
05D8E:  MOVLB  7
05D90:  MOVWF  x53
05D92:  MOVLB  0
05D94:  RCALL  55E6
05D96:  MOVLW  58
05D98:  MOVLB  7
05D9A:  MOVWF  x53
05D9C:  MOVLB  0
05D9E:  RCALL  55E6
05DA0:  MOVLW  2C
05DA2:  MOVLB  7
05DA4:  MOVWF  x53
05DA6:  MOVLB  0
05DA8:  RCALL  55E6
05DAA:  BRA    5E26
....................     else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05DAC:  MOVLW  01
05DAE:  MOVLB  7
05DB0:  SUBWF  x0E,W
05DB2:  MOVWF  x10
05DB4:  CLRF   x12
05DB6:  MOVLW  70
05DB8:  MOVWF  x11
05DBA:  MOVLB  0
05DBC:  CALL   45BC
05DC0:  BTFSS  01.0
05DC2:  BRA    5E20
05DC4:  MOVLW  04
05DC6:  MOVLB  7
05DC8:  MOVWF  x45
05DCA:  MOVLW  C1
05DCC:  MOVWF  x44
05DCE:  MOVLB  0
05DD0:  CALL   55AE
05DD4:  MOVFF  02,03
05DD8:  MOVF   01,W
05DDA:  ADDLW  C1
05DDC:  MOVLB  7
05DDE:  MOVWF  x0F
05DE0:  MOVLW  04
05DE2:  ADDWFC 02,W
05DE4:  MOVWF  x10
05DE6:  MOVFF  FE8,565
05DEA:  MOVFF  70F,564
05DEE:  MOVFF  70E,737
05DF2:  MOVLW  18
05DF4:  MOVWF  x38
05DF6:  MOVLB  0
05DF8:  RCALL  5BC8
05DFA:  MOVLW  2C
05DFC:  MOVLB  7
05DFE:  MOVWF  x53
05E00:  MOVLB  0
05E02:  CALL   55E6
05E06:  MOVLW  59
05E08:  MOVLB  7
05E0A:  MOVWF  x53
05E0C:  MOVLB  0
05E0E:  CALL   55E6
05E12:  MOVLW  2C
05E14:  MOVLB  7
05E16:  MOVWF  x53
05E18:  MOVLB  0
05E1A:  CALL   55E6
05E1E:  BRA    5E26
....................     else return INV_PARAM;
05E20:  MOVLW  02
05E22:  MOVWF  01
05E24:  BRA    5E2A
....................    
....................     return SUCCESS;
05E26:  MOVLW  00
05E28:  MOVWF  01
05E2A:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05E6E:  MOVLB  7
05E70:  CLRF   x45
05E72:  MOVFF  698,744
05E76:  CLRF   x47
05E78:  MOVLW  B5
05E7A:  MOVWF  x46
05E7C:  MOVLB  0
05E7E:  CALL   0864
05E82:  MOVFF  02,711
05E86:  MOVFF  01,710
05E8A:  MOVLW  06
05E8C:  MOVLB  7
05E8E:  ADDWF  x10,F
05E90:  MOVLW  00
05E92:  ADDWFC x11,F
05E94:  MOVLW  32
05E96:  ADDWF  x10,W
05E98:  MOVWF  01
05E9A:  MOVLW  00
05E9C:  ADDWFC x11,W
05E9E:  MOVWF  03
05EA0:  MOVF   01,W
05EA2:  ADDLW  EB
05EA4:  MOVWF  01
05EA6:  MOVLW  01
05EA8:  ADDWFC 03,F
05EAA:  MOVFF  01,710
05EAE:  MOVFF  03,711
05EB2:  MOVFF  03,737
05EB6:  MOVFF  01,736
05EBA:  MOVLB  0
05EBC:  RCALL  5784
05EBE:  MOVF   01,F
05EC0:  BNZ   5ECA
05EC2:  MOVLW  02
05EC4:  MOVWF  01
05EC6:  BRA    601A
05EC8:  BRA    5F26
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05ECA:  MOVLB  7
05ECC:  CLRF   x45
05ECE:  MOVFF  698,744
05ED2:  CLRF   x47
05ED4:  MOVLW  B5
05ED6:  MOVWF  x46
05ED8:  MOVLB  0
05EDA:  CALL   0864
05EDE:  MOVFF  02,711
05EE2:  MOVFF  01,710
05EE6:  MOVLW  06
05EE8:  MOVLB  7
05EEA:  ADDWF  x10,F
05EEC:  MOVLW  00
05EEE:  ADDWFC x11,F
05EF0:  MOVLW  32
05EF2:  ADDWF  x10,W
05EF4:  MOVWF  01
05EF6:  MOVLW  00
05EF8:  ADDWFC x11,W
05EFA:  MOVWF  03
05EFC:  MOVF   01,W
05EFE:  ADDLW  EB
05F00:  MOVWF  01
05F02:  MOVLW  01
05F04:  ADDWFC 03,F
05F06:  MOVFF  01,710
05F0A:  MOVFF  03,711
05F0E:  MOVFF  03,737
05F12:  MOVFF  01,736
05F16:  CLRF   x39
05F18:  CLRF   x38
05F1A:  MOVLW  0A
05F1C:  MOVWF  x3A
05F1E:  MOVLB  0
05F20:  RCALL  5874
05F22:  MOVFF  01,70E
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05F26:  MOVLB  7
05F28:  CLRF   x45
05F2A:  MOVFF  698,744
05F2E:  CLRF   x47
05F30:  MOVLW  B5
05F32:  MOVWF  x46
05F34:  MOVLB  0
05F36:  CALL   0864
05F3A:  MOVFF  02,711
05F3E:  MOVFF  01,710
05F42:  MOVLW  06
05F44:  MOVLB  7
05F46:  ADDWF  x10,F
05F48:  MOVLW  00
05F4A:  ADDWFC x11,F
05F4C:  MOVLW  4B
05F4E:  ADDWF  x10,W
05F50:  MOVWF  01
05F52:  MOVLW  00
05F54:  ADDWFC x11,W
05F56:  MOVWF  03
05F58:  MOVF   01,W
05F5A:  ADDLW  EB
05F5C:  MOVWF  01
05F5E:  MOVLW  01
05F60:  ADDWFC 03,F
05F62:  MOVFF  01,710
05F66:  MOVFF  03,711
05F6A:  MOVFF  03,745
05F6E:  MOVFF  01,744
05F72:  MOVLB  0
05F74:  CALL   55AE
05F78:  MOVFF  02,03
05F7C:  MOVF   01,W
05F7E:  SUBLW  01
05F80:  BNZ   5F86
05F82:  MOVF   03,F
05F84:  BZ    5F8E
05F86:  MOVLW  02
05F88:  MOVWF  01
05F8A:  BRA    601A
05F8C:  BRA    5FCE
....................    else arg2 = SERcmd[rec].p[3][0];
05F8E:  MOVLB  7
05F90:  CLRF   x45
05F92:  MOVFF  698,744
05F96:  CLRF   x47
05F98:  MOVLW  B5
05F9A:  MOVWF  x46
05F9C:  MOVLB  0
05F9E:  CALL   0864
05FA2:  MOVFF  02,711
05FA6:  MOVFF  01,710
05FAA:  MOVLW  06
05FAC:  MOVLB  7
05FAE:  ADDWF  x10,F
05FB0:  MOVLW  00
05FB2:  ADDWFC x11,F
05FB4:  MOVLW  4B
05FB6:  ADDWF  x10,F
05FB8:  MOVLW  00
05FBA:  ADDWFC x11,F
05FBC:  MOVLW  EB
05FBE:  ADDWF  x10,W
05FC0:  MOVWF  FE9
05FC2:  MOVLW  01
05FC4:  ADDWFC x11,W
05FC6:  MOVWF  FEA
05FC8:  MOVFF  FEF,70F
05FCC:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
05FCE:  MOVLB  7
05FD0:  MOVF   x0F,W
05FD2:  SUBLW  58
05FD4:  BNZ   5FEE
05FD6:  MOVLW  01
05FD8:  SUBWF  x0E,W
05FDA:  MOVWF  x10
05FDC:  MOVWF  x25
05FDE:  CLRF   x26
05FE0:  CLRF   x28
05FE2:  MOVLW  70
05FE4:  MOVWF  x27
05FE6:  MOVLB  0
05FE8:  RCALL  5E2C
05FEA:  BRA    6016
05FEC:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
05FEE:  MOVF   x0F,W
05FF0:  SUBLW  59
05FF2:  BNZ   600E
05FF4:  MOVLW  01
05FF6:  SUBWF  x0E,W
05FF8:  MOVWF  x10
05FFA:  MOVWF  x25
05FFC:  MOVLW  01
05FFE:  MOVWF  x26
06000:  CLRF   x28
06002:  MOVLW  70
06004:  MOVWF  x27
06006:  MOVLB  0
06008:  RCALL  5E2C
0600A:  BRA    6016
0600C:  MOVLB  7
....................    else return INV_PARAM;
0600E:  MOVLW  02
06010:  MOVWF  01
06012:  MOVLB  0
06014:  BRA    601A
....................    
....................    return SUCCESS;
06016:  MOVLW  00
06018:  MOVWF  01
0601A:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06046:  MOVLB  7
06048:  CLRF   x45
0604A:  MOVFF  698,744
0604E:  CLRF   x47
06050:  MOVLW  B5
06052:  MOVWF  x46
06054:  MOVLB  0
06056:  CALL   0864
0605A:  MOVFF  02,710
0605E:  MOVFF  01,70F
06062:  MOVLW  06
06064:  MOVLB  7
06066:  ADDWF  x0F,F
06068:  MOVLW  00
0606A:  ADDWFC x10,F
0606C:  MOVLW  32
0606E:  ADDWF  x0F,W
06070:  MOVWF  01
06072:  MOVLW  00
06074:  ADDWFC x10,W
06076:  MOVWF  03
06078:  MOVF   01,W
0607A:  ADDLW  EB
0607C:  MOVWF  01
0607E:  MOVLW  01
06080:  ADDWFC 03,F
06082:  MOVFF  01,70F
06086:  MOVFF  03,710
0608A:  MOVFF  03,737
0608E:  MOVFF  01,736
06092:  MOVLB  0
06094:  CALL   5784
06098:  MOVF   01,F
0609A:  BNZ   60A4
0609C:  MOVLW  02
0609E:  MOVWF  01
060A0:  BRA    61D0
060A2:  BRA    6102
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
060A4:  MOVLB  7
060A6:  CLRF   x45
060A8:  MOVFF  698,744
060AC:  CLRF   x47
060AE:  MOVLW  B5
060B0:  MOVWF  x46
060B2:  MOVLB  0
060B4:  CALL   0864
060B8:  MOVFF  02,710
060BC:  MOVFF  01,70F
060C0:  MOVLW  06
060C2:  MOVLB  7
060C4:  ADDWF  x0F,F
060C6:  MOVLW  00
060C8:  ADDWFC x10,F
060CA:  MOVLW  32
060CC:  ADDWF  x0F,W
060CE:  MOVWF  01
060D0:  MOVLW  00
060D2:  ADDWFC x10,W
060D4:  MOVWF  03
060D6:  MOVF   01,W
060D8:  ADDLW  EB
060DA:  MOVWF  01
060DC:  MOVLW  01
060DE:  ADDWFC 03,F
060E0:  MOVFF  01,70F
060E4:  MOVFF  03,710
060E8:  MOVFF  03,737
060EC:  MOVFF  01,736
060F0:  CLRF   x39
060F2:  CLRF   x38
060F4:  MOVLW  0A
060F6:  MOVWF  x3A
060F8:  MOVLB  0
060FA:  CALL   5874
060FE:  MOVFF  01,70E
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06102:  MOVLW  01
06104:  MOVLB  7
06106:  SUBWF  x0E,W
06108:  MOVWF  x10
0610A:  CLRF   x12
0610C:  MOVLW  71
0610E:  MOVWF  x11
06110:  MOVLB  0
06112:  CALL   45BC
06116:  BTFSC  01.0
06118:  BRA    6164
0611A:  MOVLW  04
0611C:  MOVLB  7
0611E:  MOVWF  x45
06120:  MOVLW  C1
06122:  MOVWF  x44
06124:  MOVLB  0
06126:  CALL   55AE
0612A:  MOVFF  02,03
0612E:  MOVF   01,W
06130:  ADDLW  C1
06132:  MOVLB  7
06134:  MOVWF  x0F
06136:  MOVLW  04
06138:  ADDWFC 02,W
0613A:  MOVWF  x10
0613C:  MOVFF  FE8,565
06140:  MOVFF  70F,564
06144:  MOVFF  70E,737
06148:  MOVLW  18
0614A:  MOVWF  x38
0614C:  MOVLB  0
0614E:  RCALL  5BC8
06150:  MOVLW  42
06152:  MOVWF  FF6
06154:  MOVLW  03
06156:  MOVWF  FF7
06158:  MOVLW  08
0615A:  MOVLB  7
0615C:  MOVWF  x1B
0615E:  MOVLB  0
06160:  RCALL  601C
06162:  BRA    61CC
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06164:  MOVLW  01
06166:  MOVLB  7
06168:  SUBWF  x0E,W
0616A:  MOVWF  x10
0616C:  CLRF   x12
0616E:  MOVLW  71
06170:  MOVWF  x11
06172:  MOVLB  0
06174:  CALL   45BC
06178:  BTFSS  01.0
0617A:  BRA    61C6
0617C:  MOVLW  04
0617E:  MOVLB  7
06180:  MOVWF  x45
06182:  MOVLW  C1
06184:  MOVWF  x44
06186:  MOVLB  0
06188:  CALL   55AE
0618C:  MOVFF  02,03
06190:  MOVF   01,W
06192:  ADDLW  C1
06194:  MOVLB  7
06196:  MOVWF  x0F
06198:  MOVLW  04
0619A:  ADDWFC 02,W
0619C:  MOVWF  x10
0619E:  MOVFF  FE8,565
061A2:  MOVFF  70F,564
061A6:  MOVFF  70E,737
061AA:  MOVLW  18
061AC:  MOVWF  x38
061AE:  MOVLB  0
061B0:  RCALL  5BC8
061B2:  MOVLW  4E
061B4:  MOVWF  FF6
061B6:  MOVLW  03
061B8:  MOVWF  FF7
061BA:  MOVLW  08
061BC:  MOVLB  7
061BE:  MOVWF  x1B
061C0:  MOVLB  0
061C2:  RCALL  601C
061C4:  BRA    61CC
....................    else return INV_PARAM;
061C6:  MOVLW  02
061C8:  MOVWF  01
061CA:  BRA    61D0
....................    
....................    return SUCCESS;
061CC:  MOVLW  00
061CE:  MOVWF  01
061D0:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
061D2:  MOVLW  4D
061D4:  MOVLB  7
061D6:  MOVWF  x13
061D8:  MOVLW  41
061DA:  MOVWF  x14
061DC:  MOVLW  4E
061DE:  MOVWF  x15
061E0:  MOVLW  55
061E2:  MOVWF  x16
061E4:  MOVLW  41
061E6:  MOVWF  x17
061E8:  MOVLW  4C
061EA:  MOVWF  x18
061EC:  CLRF   x19
061EE:  MOVLW  07
061F0:  MOVWF  x12
061F2:  MOVLW  13
061F4:  MOVWF  x11
....................    char *s_magsns = "MAGSNS";
061F6:  MOVLW  4D
061F8:  MOVWF  x1C
061FA:  MOVLW  41
061FC:  MOVWF  x1D
061FE:  MOVLW  47
06200:  MOVWF  x1E
06202:  MOVLW  53
06204:  MOVWF  x1F
06206:  MOVLW  4E
06208:  MOVWF  x20
0620A:  MOVLW  53
0620C:  MOVWF  x21
0620E:  CLRF   x22
06210:  MOVLW  07
06212:  MOVWF  x1B
06214:  MOVLW  1C
06216:  MOVWF  x1A
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06218:  CLRF   x45
0621A:  MOVFF  698,744
0621E:  CLRF   x47
06220:  MOVLW  B5
06222:  MOVWF  x46
06224:  MOVLB  0
06226:  CALL   0864
0622A:  MOVFF  02,724
0622E:  MOVFF  01,723
06232:  MOVLW  06
06234:  MOVLB  7
06236:  ADDWF  x23,F
06238:  MOVLW  00
0623A:  ADDWFC x24,F
0623C:  MOVLW  32
0623E:  ADDWF  x23,W
06240:  MOVWF  01
06242:  MOVLW  00
06244:  ADDWFC x24,W
06246:  MOVWF  03
06248:  MOVF   01,W
0624A:  ADDLW  EB
0624C:  MOVWF  01
0624E:  MOVLW  01
06250:  ADDWFC 03,F
06252:  MOVFF  01,723
06256:  MOVFF  03,724
0625A:  MOVFF  03,737
0625E:  MOVFF  01,736
06262:  MOVLB  0
06264:  CALL   5784
06268:  MOVF   01,F
0626A:  BNZ   6274
0626C:  MOVLW  02
0626E:  MOVWF  01
06270:  BRA    63EA
06272:  BRA    62D2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06274:  MOVLB  7
06276:  CLRF   x45
06278:  MOVFF  698,744
0627C:  CLRF   x47
0627E:  MOVLW  B5
06280:  MOVWF  x46
06282:  MOVLB  0
06284:  CALL   0864
06288:  MOVFF  02,724
0628C:  MOVFF  01,723
06290:  MOVLW  06
06292:  MOVLB  7
06294:  ADDWF  x23,F
06296:  MOVLW  00
06298:  ADDWFC x24,F
0629A:  MOVLW  32
0629C:  ADDWF  x23,W
0629E:  MOVWF  01
062A0:  MOVLW  00
062A2:  ADDWFC x24,W
062A4:  MOVWF  03
062A6:  MOVF   01,W
062A8:  ADDLW  EB
062AA:  MOVWF  01
062AC:  MOVLW  01
062AE:  ADDWFC 03,F
062B0:  MOVFF  01,723
062B4:  MOVFF  03,724
062B8:  MOVFF  03,737
062BC:  MOVFF  01,736
062C0:  CLRF   x39
062C2:  CLRF   x38
062C4:  MOVLW  0A
062C6:  MOVWF  x3A
062C8:  MOVLB  0
062CA:  CALL   5874
062CE:  MOVFF  01,70E
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
062D2:  MOVLB  7
062D4:  CLRF   x45
062D6:  MOVFF  698,744
062DA:  CLRF   x47
062DC:  MOVLW  B5
062DE:  MOVWF  x46
062E0:  MOVLB  0
062E2:  CALL   0864
062E6:  MOVFF  02,724
062EA:  MOVFF  01,723
062EE:  MOVLW  06
062F0:  MOVLB  7
062F2:  ADDWF  x23,F
062F4:  MOVLW  00
062F6:  ADDWFC x24,F
062F8:  MOVLW  4B
062FA:  ADDWF  x23,W
062FC:  MOVWF  01
062FE:  MOVLW  00
06300:  ADDWFC x24,W
06302:  MOVWF  03
06304:  MOVF   01,W
06306:  ADDLW  EB
06308:  MOVWF  01
0630A:  MOVLW  01
0630C:  ADDWFC 03,F
0630E:  MOVFF  01,723
06312:  MOVFF  03,724
06316:  MOVFF  03,745
0631A:  MOVFF  01,744
0631E:  MOVLB  0
06320:  CALL   55AE
06324:  MOVFF  02,03
06328:  MOVF   01,W
0632A:  BNZ   6338
0632C:  MOVF   03,F
0632E:  BNZ   6338
06330:  MOVLW  02
06332:  MOVWF  01
06334:  BRA    63EA
06336:  BRA    637E
....................    else arg2 = SERcmd[rec].p[3];
06338:  MOVLB  7
0633A:  CLRF   x45
0633C:  MOVFF  698,744
06340:  CLRF   x47
06342:  MOVLW  B5
06344:  MOVWF  x46
06346:  MOVLB  0
06348:  CALL   0864
0634C:  MOVFF  02,724
06350:  MOVFF  01,723
06354:  MOVLW  06
06356:  MOVLB  7
06358:  ADDWF  x23,F
0635A:  MOVLW  00
0635C:  ADDWFC x24,F
0635E:  MOVLW  4B
06360:  ADDWF  x23,W
06362:  MOVWF  01
06364:  MOVLW  00
06366:  ADDWFC x24,W
06368:  MOVWF  03
0636A:  MOVF   01,W
0636C:  ADDLW  EB
0636E:  MOVWF  01
06370:  MOVLW  01
06372:  ADDWFC 03,F
06374:  MOVFF  01,70F
06378:  MOVFF  03,710
0637C:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
0637E:  MOVFF  712,745
06382:  MOVFF  711,744
06386:  MOVFF  710,747
0638A:  MOVFF  70F,746
0638E:  CALL   5664
06392:  MOVF   01,F
06394:  BNZ   63AE
06396:  MOVLW  01
06398:  MOVLB  7
0639A:  SUBWF  x0E,W
0639C:  MOVWF  x23
0639E:  MOVWF  x25
063A0:  CLRF   x26
063A2:  CLRF   x28
063A4:  MOVLW  71
063A6:  MOVWF  x27
063A8:  MOVLB  0
063AA:  RCALL  5E2C
063AC:  BRA    63E6
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
063AE:  MOVFF  71B,745
063B2:  MOVFF  71A,744
063B6:  MOVFF  710,747
063BA:  MOVFF  70F,746
063BE:  CALL   5664
063C2:  MOVF   01,F
063C4:  BNZ   63E0
063C6:  MOVLW  01
063C8:  MOVLB  7
063CA:  SUBWF  x0E,W
063CC:  MOVWF  x23
063CE:  MOVWF  x25
063D0:  MOVLW  01
063D2:  MOVWF  x26
063D4:  CLRF   x28
063D6:  MOVLW  71
063D8:  MOVWF  x27
063DA:  MOVLB  0
063DC:  RCALL  5E2C
063DE:  BRA    63E6
....................    else return INV_PARAM;
063E0:  MOVLW  02
063E2:  MOVWF  01
063E4:  BRA    63EA
....................    
....................    return SUCCESS;
063E6:  MOVLW  00
063E8:  MOVWF  01
063EA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06672:  MOVLB  7
06674:  CLRF   x45
06676:  MOVFF  698,744
0667A:  CLRF   x47
0667C:  MOVLW  B5
0667E:  MOVWF  x46
06680:  MOVLB  0
06682:  CALL   0864
06686:  MOVFF  02,711
0668A:  MOVFF  01,710
0668E:  MOVLW  06
06690:  MOVLB  7
06692:  ADDWF  x10,F
06694:  MOVLW  00
06696:  ADDWFC x11,F
06698:  MOVLW  32
0669A:  ADDWF  x10,W
0669C:  MOVWF  01
0669E:  MOVLW  00
066A0:  ADDWFC x11,W
066A2:  MOVWF  03
066A4:  MOVF   01,W
066A6:  ADDLW  EB
066A8:  MOVWF  01
066AA:  MOVLW  01
066AC:  ADDWFC 03,F
066AE:  MOVFF  01,710
066B2:  MOVFF  03,711
066B6:  MOVFF  03,737
066BA:  MOVFF  01,736
066BE:  MOVLB  0
066C0:  CALL   5784
066C4:  MOVF   01,F
066C6:  BNZ   66D0
066C8:  MOVLW  02
066CA:  MOVWF  01
066CC:  BRA    6B26
066CE:  BRA    672E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
066D0:  MOVLB  7
066D2:  CLRF   x45
066D4:  MOVFF  698,744
066D8:  CLRF   x47
066DA:  MOVLW  B5
066DC:  MOVWF  x46
066DE:  MOVLB  0
066E0:  CALL   0864
066E4:  MOVFF  02,711
066E8:  MOVFF  01,710
066EC:  MOVLW  06
066EE:  MOVLB  7
066F0:  ADDWF  x10,F
066F2:  MOVLW  00
066F4:  ADDWFC x11,F
066F6:  MOVLW  32
066F8:  ADDWF  x10,W
066FA:  MOVWF  01
066FC:  MOVLW  00
066FE:  ADDWFC x11,W
06700:  MOVWF  03
06702:  MOVF   01,W
06704:  ADDLW  EB
06706:  MOVWF  01
06708:  MOVLW  01
0670A:  ADDWFC 03,F
0670C:  MOVFF  01,710
06710:  MOVFF  03,711
06714:  MOVFF  03,737
06718:  MOVFF  01,736
0671C:  CLRF   x39
0671E:  CLRF   x38
06720:  MOVLW  0A
06722:  MOVWF  x3A
06724:  MOVLB  0
06726:  CALL   5874
0672A:  MOVFF  01,70E
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0672E:  MOVLB  7
06730:  CLRF   x45
06732:  MOVFF  698,744
06736:  CLRF   x47
06738:  MOVLW  B5
0673A:  MOVWF  x46
0673C:  MOVLB  0
0673E:  CALL   0864
06742:  MOVFF  02,711
06746:  MOVFF  01,710
0674A:  MOVLW  06
0674C:  MOVLB  7
0674E:  ADDWF  x10,F
06750:  MOVLW  00
06752:  ADDWFC x11,F
06754:  MOVLW  4B
06756:  ADDWF  x10,W
06758:  MOVWF  01
0675A:  MOVLW  00
0675C:  ADDWFC x11,W
0675E:  MOVWF  03
06760:  MOVF   01,W
06762:  ADDLW  EB
06764:  MOVWF  01
06766:  MOVLW  01
06768:  ADDWFC 03,F
0676A:  MOVFF  01,710
0676E:  MOVFF  03,711
06772:  MOVFF  03,745
06776:  MOVFF  01,744
0677A:  MOVLB  0
0677C:  CALL   55AE
06780:  MOVFF  02,03
06784:  MOVF   01,W
06786:  SUBLW  01
06788:  BNZ   678E
0678A:  MOVF   03,F
0678C:  BZ    6796
0678E:  MOVLW  02
06790:  MOVWF  01
06792:  BRA    6B26
06794:  BRA    67D6
....................    else arg2 = SERcmd[rec].p[3][0];
06796:  MOVLB  7
06798:  CLRF   x45
0679A:  MOVFF  698,744
0679E:  CLRF   x47
067A0:  MOVLW  B5
067A2:  MOVWF  x46
067A4:  MOVLB  0
067A6:  CALL   0864
067AA:  MOVFF  02,711
067AE:  MOVFF  01,710
067B2:  MOVLW  06
067B4:  MOVLB  7
067B6:  ADDWF  x10,F
067B8:  MOVLW  00
067BA:  ADDWFC x11,F
067BC:  MOVLW  4B
067BE:  ADDWF  x10,F
067C0:  MOVLW  00
067C2:  ADDWFC x11,F
067C4:  MOVLW  EB
067C6:  ADDWF  x10,W
067C8:  MOVWF  FE9
067CA:  MOVLW  01
067CC:  ADDWFC x11,W
067CE:  MOVWF  FEA
067D0:  MOVFF  FEF,70F
067D4:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
067D6:  MOVLB  7
067D8:  MOVF   x0F,W
067DA:  SUBLW  50
067DC:  BNZ   6876
067DE:  MOVLW  04
067E0:  MOVWF  x45
067E2:  MOVLW  C1
067E4:  MOVWF  x44
067E6:  MOVLB  0
067E8:  CALL   55AE
067EC:  MOVFF  02,03
067F0:  MOVF   01,W
067F2:  ADDLW  C1
067F4:  MOVLB  7
067F6:  MOVWF  x10
067F8:  MOVLW  04
067FA:  ADDWFC 02,W
067FC:  MOVWF  x11
067FE:  MOVLW  01
06800:  SUBWF  x0E,W
06802:  MULLW  28
06804:  MOVF   FF3,W
06806:  CLRF   x13
06808:  MOVWF  x12
0680A:  MOVLW  20
0680C:  ADDWF  x12,W
0680E:  MOVWF  FE9
06810:  MOVLW  00
06812:  ADDWFC x13,W
06814:  MOVWF  FEA
06816:  MOVFF  FEF,714
0681A:  MOVFF  FEC,715
0681E:  MOVFF  FEC,716
06822:  MOVFF  FEC,717
06826:  MOVFF  711,565
0682A:  MOVFF  710,564
0682E:  MOVFF  70E,737
06832:  MOVLW  18
06834:  MOVWF  x38
06836:  MOVLB  0
06838:  CALL   5BC8
0683C:  MOVLW  2C
0683E:  MOVLB  7
06840:  MOVWF  x53
06842:  MOVLB  0
06844:  CALL   55E6
06848:  MOVLW  89
0684A:  MOVWF  FE9
0684C:  MOVFF  717,749
06850:  MOVFF  716,748
06854:  MOVFF  715,747
06858:  MOVFF  714,746
0685C:  MOVLW  02
0685E:  MOVLB  7
06860:  MOVWF  x4A
06862:  MOVLB  0
06864:  RCALL  64C2
06866:  MOVLW  2C
06868:  MOVLB  7
0686A:  MOVWF  x53
0686C:  MOVLB  0
0686E:  CALL   55E6
06872:  BRA    6B22
06874:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06876:  MOVF   x0F,W
06878:  SUBLW  49
0687A:  BNZ   691C
0687C:  MOVLW  04
0687E:  MOVWF  x45
06880:  MOVLW  C1
06882:  MOVWF  x44
06884:  MOVLB  0
06886:  CALL   55AE
0688A:  MOVF   01,W
0688C:  ADDLW  C1
0688E:  MOVLB  7
06890:  MOVWF  x10
06892:  MOVLW  04
06894:  ADDWFC 02,W
06896:  MOVWF  x11
06898:  MOVLW  01
0689A:  SUBWF  x0E,W
0689C:  MULLW  28
0689E:  MOVF   FF3,W
068A0:  CLRF   x13
068A2:  MOVWF  x12
068A4:  MOVLW  04
068A6:  ADDWF  x12,W
068A8:  MOVWF  01
068AA:  MOVLW  00
068AC:  ADDWFC x13,W
068AE:  MOVWF  03
068B0:  MOVF   01,W
068B2:  ADDLW  20
068B4:  MOVWF  FE9
068B6:  MOVLW  00
068B8:  ADDWFC 03,W
068BA:  MOVWF  FEA
068BC:  MOVFF  FEF,712
068C0:  MOVFF  FEC,713
068C4:  MOVFF  FEC,714
068C8:  MOVFF  FEC,715
068CC:  MOVFF  711,565
068D0:  MOVFF  710,564
068D4:  MOVFF  70E,737
068D8:  MOVLW  18
068DA:  MOVWF  x38
068DC:  MOVLB  0
068DE:  CALL   5BC8
068E2:  MOVLW  2C
068E4:  MOVLB  7
068E6:  MOVWF  x53
068E8:  MOVLB  0
068EA:  CALL   55E6
068EE:  MOVLW  89
068F0:  MOVWF  FE9
068F2:  MOVFF  715,749
068F6:  MOVFF  714,748
068FA:  MOVFF  713,747
068FE:  MOVFF  712,746
06902:  MOVLW  02
06904:  MOVLB  7
06906:  MOVWF  x4A
06908:  MOVLB  0
0690A:  RCALL  64C2
0690C:  MOVLW  2C
0690E:  MOVLB  7
06910:  MOVWF  x53
06912:  MOVLB  0
06914:  CALL   55E6
06918:  BRA    6B22
0691A:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
0691C:  MOVF   x0F,W
0691E:  SUBLW  44
06920:  BNZ   69C2
06922:  MOVLW  04
06924:  MOVWF  x45
06926:  MOVLW  C1
06928:  MOVWF  x44
0692A:  MOVLB  0
0692C:  CALL   55AE
06930:  MOVF   01,W
06932:  ADDLW  C1
06934:  MOVLB  7
06936:  MOVWF  x10
06938:  MOVLW  04
0693A:  ADDWFC 02,W
0693C:  MOVWF  x11
0693E:  MOVLW  01
06940:  SUBWF  x0E,W
06942:  MULLW  28
06944:  MOVF   FF3,W
06946:  CLRF   x13
06948:  MOVWF  x12
0694A:  MOVLW  08
0694C:  ADDWF  x12,W
0694E:  MOVWF  01
06950:  MOVLW  00
06952:  ADDWFC x13,W
06954:  MOVWF  03
06956:  MOVF   01,W
06958:  ADDLW  20
0695A:  MOVWF  FE9
0695C:  MOVLW  00
0695E:  ADDWFC 03,W
06960:  MOVWF  FEA
06962:  MOVFF  FEF,712
06966:  MOVFF  FEC,713
0696A:  MOVFF  FEC,714
0696E:  MOVFF  FEC,715
06972:  MOVFF  711,565
06976:  MOVFF  710,564
0697A:  MOVFF  70E,737
0697E:  MOVLW  18
06980:  MOVWF  x38
06982:  MOVLB  0
06984:  CALL   5BC8
06988:  MOVLW  2C
0698A:  MOVLB  7
0698C:  MOVWF  x53
0698E:  MOVLB  0
06990:  CALL   55E6
06994:  MOVLW  89
06996:  MOVWF  FE9
06998:  MOVFF  715,749
0699C:  MOVFF  714,748
069A0:  MOVFF  713,747
069A4:  MOVFF  712,746
069A8:  MOVLW  02
069AA:  MOVLB  7
069AC:  MOVWF  x4A
069AE:  MOVLB  0
069B0:  RCALL  64C2
069B2:  MOVLW  2C
069B4:  MOVLB  7
069B6:  MOVWF  x53
069B8:  MOVLB  0
069BA:  CALL   55E6
069BE:  BRA    6B22
069C0:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
069C2:  MOVF   x0F,W
069C4:  SUBLW  41
069C6:  BTFSS  FD8.2
069C8:  BRA    6B1A
069CA:  MOVLW  04
069CC:  MOVWF  x45
069CE:  MOVLW  C1
069D0:  MOVWF  x44
069D2:  MOVLB  0
069D4:  CALL   55AE
069D8:  MOVF   01,W
069DA:  ADDLW  C1
069DC:  MOVLB  7
069DE:  MOVWF  x10
069E0:  MOVLW  04
069E2:  ADDWFC 02,W
069E4:  MOVWF  x11
069E6:  MOVLW  01
069E8:  SUBWF  x0E,W
069EA:  MULLW  28
069EC:  MOVF   FF3,W
069EE:  CLRF   x13
069F0:  MOVWF  x12
069F2:  MOVLW  20
069F4:  ADDWF  x12,W
069F6:  MOVWF  FE9
069F8:  MOVLW  00
069FA:  ADDWFC x13,W
069FC:  MOVWF  FEA
069FE:  MOVFF  FEF,714
06A02:  MOVFF  FEC,715
06A06:  MOVFF  FEC,716
06A0A:  MOVFF  FEC,717
06A0E:  MOVLW  01
06A10:  SUBWF  x0E,W
06A12:  MULLW  28
06A14:  MOVF   FF3,W
06A16:  CLRF   x19
06A18:  MOVWF  x18
06A1A:  MOVLW  04
06A1C:  ADDWF  x18,W
06A1E:  MOVWF  01
06A20:  MOVLW  00
06A22:  ADDWFC x19,W
06A24:  MOVWF  03
06A26:  MOVF   01,W
06A28:  ADDLW  20
06A2A:  MOVWF  FE9
06A2C:  MOVLW  00
06A2E:  ADDWFC 03,W
06A30:  MOVWF  FEA
06A32:  MOVFF  FEF,718
06A36:  MOVFF  FEC,719
06A3A:  MOVFF  FEC,71A
06A3E:  MOVFF  FEC,71B
06A42:  MOVLW  01
06A44:  SUBWF  x0E,W
06A46:  MULLW  28
06A48:  MOVF   FF3,W
06A4A:  CLRF   x1D
06A4C:  MOVWF  x1C
06A4E:  MOVLW  08
06A50:  ADDWF  x1C,W
06A52:  MOVWF  01
06A54:  MOVLW  00
06A56:  ADDWFC x1D,W
06A58:  MOVWF  03
06A5A:  MOVF   01,W
06A5C:  ADDLW  20
06A5E:  MOVWF  FE9
06A60:  MOVLW  00
06A62:  ADDWFC 03,W
06A64:  MOVWF  FEA
06A66:  MOVFF  FEF,71C
06A6A:  MOVFF  FEC,71D
06A6E:  MOVFF  FEC,71E
06A72:  MOVFF  FEC,71F
06A76:  MOVFF  711,565
06A7A:  MOVFF  710,564
06A7E:  MOVFF  70E,737
06A82:  MOVLW  18
06A84:  MOVWF  x38
06A86:  MOVLB  0
06A88:  CALL   5BC8
06A8C:  MOVLW  2C
06A8E:  MOVLB  7
06A90:  MOVWF  x53
06A92:  MOVLB  0
06A94:  CALL   55E6
06A98:  MOVLW  89
06A9A:  MOVWF  FE9
06A9C:  MOVFF  717,749
06AA0:  MOVFF  716,748
06AA4:  MOVFF  715,747
06AA8:  MOVFF  714,746
06AAC:  MOVLW  02
06AAE:  MOVLB  7
06AB0:  MOVWF  x4A
06AB2:  MOVLB  0
06AB4:  RCALL  64C2
06AB6:  MOVLW  2C
06AB8:  MOVLB  7
06ABA:  MOVWF  x53
06ABC:  MOVLB  0
06ABE:  CALL   55E6
06AC2:  MOVLW  89
06AC4:  MOVWF  FE9
06AC6:  MOVFF  71B,749
06ACA:  MOVFF  71A,748
06ACE:  MOVFF  719,747
06AD2:  MOVFF  718,746
06AD6:  MOVLW  02
06AD8:  MOVLB  7
06ADA:  MOVWF  x4A
06ADC:  MOVLB  0
06ADE:  RCALL  64C2
06AE0:  MOVLW  2C
06AE2:  MOVLB  7
06AE4:  MOVWF  x53
06AE6:  MOVLB  0
06AE8:  CALL   55E6
06AEC:  MOVLW  89
06AEE:  MOVWF  FE9
06AF0:  MOVFF  71F,749
06AF4:  MOVFF  71E,748
06AF8:  MOVFF  71D,747
06AFC:  MOVFF  71C,746
06B00:  MOVLW  02
06B02:  MOVLB  7
06B04:  MOVWF  x4A
06B06:  MOVLB  0
06B08:  RCALL  64C2
06B0A:  MOVLW  2C
06B0C:  MOVLB  7
06B0E:  MOVWF  x53
06B10:  MOVLB  0
06B12:  CALL   55E6
06B16:  BRA    6B22
06B18:  MOVLB  7
....................    else return INV_PARAM;
06B1A:  MOVLW  02
06B1C:  MOVWF  01
06B1E:  MOVLB  0
06B20:  BRA    6B26
....................    
....................    return SUCCESS;
06B22:  MOVLW  00
06B24:  MOVWF  01
06B26:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06E44:  MOVLB  7
06E46:  CLRF   x45
06E48:  MOVFF  698,744
06E4C:  CLRF   x47
06E4E:  MOVLW  B5
06E50:  MOVWF  x46
06E52:  MOVLB  0
06E54:  CALL   0864
06E58:  MOVFF  02,715
06E5C:  MOVFF  01,714
06E60:  MOVLW  06
06E62:  MOVLB  7
06E64:  ADDWF  x14,F
06E66:  MOVLW  00
06E68:  ADDWFC x15,F
06E6A:  MOVLW  32
06E6C:  ADDWF  x14,W
06E6E:  MOVWF  01
06E70:  MOVLW  00
06E72:  ADDWFC x15,W
06E74:  MOVWF  03
06E76:  MOVF   01,W
06E78:  ADDLW  EB
06E7A:  MOVWF  01
06E7C:  MOVLW  01
06E7E:  ADDWFC 03,F
06E80:  MOVFF  01,714
06E84:  MOVFF  03,715
06E88:  MOVFF  03,737
06E8C:  MOVFF  01,736
06E90:  MOVLB  0
06E92:  CALL   5784
06E96:  MOVF   01,F
06E98:  BNZ   6EA2
06E9A:  MOVLW  02
06E9C:  MOVWF  01
06E9E:  BRA    7122
06EA0:  BRA    6F00
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06EA2:  MOVLB  7
06EA4:  CLRF   x45
06EA6:  MOVFF  698,744
06EAA:  CLRF   x47
06EAC:  MOVLW  B5
06EAE:  MOVWF  x46
06EB0:  MOVLB  0
06EB2:  CALL   0864
06EB6:  MOVFF  02,715
06EBA:  MOVFF  01,714
06EBE:  MOVLW  06
06EC0:  MOVLB  7
06EC2:  ADDWF  x14,F
06EC4:  MOVLW  00
06EC6:  ADDWFC x15,F
06EC8:  MOVLW  32
06ECA:  ADDWF  x14,W
06ECC:  MOVWF  01
06ECE:  MOVLW  00
06ED0:  ADDWFC x15,W
06ED2:  MOVWF  03
06ED4:  MOVF   01,W
06ED6:  ADDLW  EB
06ED8:  MOVWF  01
06EDA:  MOVLW  01
06EDC:  ADDWFC 03,F
06EDE:  MOVFF  01,714
06EE2:  MOVFF  03,715
06EE6:  MOVFF  03,737
06EEA:  MOVFF  01,736
06EEE:  CLRF   x39
06EF0:  CLRF   x38
06EF2:  MOVLW  0A
06EF4:  MOVWF  x3A
06EF6:  MOVLB  0
06EF8:  CALL   5874
06EFC:  MOVFF  01,70E
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06F00:  MOVLB  7
06F02:  CLRF   x45
06F04:  MOVFF  698,744
06F08:  CLRF   x47
06F0A:  MOVLW  B5
06F0C:  MOVWF  x46
06F0E:  MOVLB  0
06F10:  CALL   0864
06F14:  MOVFF  02,715
06F18:  MOVFF  01,714
06F1C:  MOVLW  06
06F1E:  MOVLB  7
06F20:  ADDWF  x14,F
06F22:  MOVLW  00
06F24:  ADDWFC x15,F
06F26:  MOVLW  4B
06F28:  ADDWF  x14,W
06F2A:  MOVWF  01
06F2C:  MOVLW  00
06F2E:  ADDWFC x15,W
06F30:  MOVWF  03
06F32:  MOVF   01,W
06F34:  ADDLW  EB
06F36:  MOVWF  01
06F38:  MOVLW  01
06F3A:  ADDWFC 03,F
06F3C:  MOVFF  01,714
06F40:  MOVFF  03,715
06F44:  MOVFF  03,745
06F48:  MOVFF  01,744
06F4C:  MOVLB  0
06F4E:  CALL   55AE
06F52:  MOVFF  02,03
06F56:  MOVF   01,W
06F58:  SUBLW  01
06F5A:  BNZ   6F60
06F5C:  MOVF   03,F
06F5E:  BZ    6F68
06F60:  MOVLW  02
06F62:  MOVWF  01
06F64:  BRA    7122
06F66:  BRA    6FA8
....................    else arg2 = SERcmd[rec].p[3][0];
06F68:  MOVLB  7
06F6A:  CLRF   x45
06F6C:  MOVFF  698,744
06F70:  CLRF   x47
06F72:  MOVLW  B5
06F74:  MOVWF  x46
06F76:  MOVLB  0
06F78:  CALL   0864
06F7C:  MOVFF  02,715
06F80:  MOVFF  01,714
06F84:  MOVLW  06
06F86:  MOVLB  7
06F88:  ADDWF  x14,F
06F8A:  MOVLW  00
06F8C:  ADDWFC x15,F
06F8E:  MOVLW  4B
06F90:  ADDWF  x14,F
06F92:  MOVLW  00
06F94:  ADDWFC x15,F
06F96:  MOVLW  EB
06F98:  ADDWF  x14,W
06F9A:  MOVWF  FE9
06F9C:  MOVLW  01
06F9E:  ADDWFC x15,W
06FA0:  MOVWF  FEA
06FA2:  MOVFF  FEF,70F
06FA6:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
06FA8:  MOVLB  7
06FAA:  CLRF   x45
06FAC:  MOVFF  698,744
06FB0:  CLRF   x47
06FB2:  MOVLW  B5
06FB4:  MOVWF  x46
06FB6:  MOVLB  0
06FB8:  CALL   0864
06FBC:  MOVFF  02,715
06FC0:  MOVFF  01,714
06FC4:  MOVLW  06
06FC6:  MOVLB  7
06FC8:  ADDWF  x14,F
06FCA:  MOVLW  00
06FCC:  ADDWFC x15,F
06FCE:  MOVLW  64
06FD0:  ADDWF  x14,W
06FD2:  MOVWF  01
06FD4:  MOVLW  00
06FD6:  ADDWFC x15,W
06FD8:  MOVWF  03
06FDA:  MOVF   01,W
06FDC:  ADDLW  EB
06FDE:  MOVWF  01
06FE0:  MOVLW  01
06FE2:  ADDWFC 03,F
06FE4:  MOVFF  01,714
06FE8:  MOVFF  03,715
06FEC:  MOVFF  03,718
06FF0:  MOVFF  01,717
06FF4:  MOVLB  0
06FF6:  RCALL  6B28
06FF8:  MOVF   01,F
06FFA:  BNZ   7004
06FFC:  MOVLW  02
06FFE:  MOVWF  01
07000:  BRA    7122
07002:  BRA    7068
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07004:  MOVLB  7
07006:  CLRF   x45
07008:  MOVFF  698,744
0700C:  CLRF   x47
0700E:  MOVLW  B5
07010:  MOVWF  x46
07012:  MOVLB  0
07014:  CALL   0864
07018:  MOVFF  02,715
0701C:  MOVFF  01,714
07020:  MOVLW  06
07022:  MOVLB  7
07024:  ADDWF  x14,F
07026:  MOVLW  00
07028:  ADDWFC x15,F
0702A:  MOVLW  64
0702C:  ADDWF  x14,W
0702E:  MOVWF  01
07030:  MOVLW  00
07032:  ADDWFC x15,W
07034:  MOVWF  03
07036:  MOVF   01,W
07038:  ADDLW  EB
0703A:  MOVWF  01
0703C:  MOVLW  01
0703E:  ADDWFC 03,F
07040:  MOVFF  01,714
07044:  MOVFF  03,715
07048:  MOVFF  03,718
0704C:  MOVFF  01,717
07050:  CLRF   x1A
07052:  CLRF   x19
07054:  MOVLB  0
07056:  RCALL  6BEA
07058:  MOVFF  03,713
0705C:  MOVFF  02,712
07060:  MOVFF  01,711
07064:  MOVFF  00,710
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07068:  MOVLB  7
0706A:  MOVF   x0F,W
0706C:  SUBLW  50
0706E:  BNZ   709A
07070:  MOVLW  01
07072:  SUBWF  x0E,W
07074:  MULLW  28
07076:  MOVF   FF3,W
07078:  CLRF   x15
0707A:  MOVWF  x14
0707C:  MOVLW  20
0707E:  ADDWF  x14,W
07080:  MOVWF  FE9
07082:  MOVLW  00
07084:  ADDWFC x15,W
07086:  MOVWF  FEA
07088:  MOVFF  710,FEF
0708C:  MOVFF  711,FEC
07090:  MOVFF  712,FEC
07094:  MOVFF  713,FEC
07098:  BRA    711C
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
0709A:  MOVF   x0F,W
0709C:  SUBLW  49
0709E:  BNZ   70D6
070A0:  MOVLW  01
070A2:  SUBWF  x0E,W
070A4:  MULLW  28
070A6:  MOVF   FF3,W
070A8:  CLRF   x15
070AA:  MOVWF  x14
070AC:  MOVLW  04
070AE:  ADDWF  x14,W
070B0:  MOVWF  01
070B2:  MOVLW  00
070B4:  ADDWFC x15,W
070B6:  MOVWF  03
070B8:  MOVF   01,W
070BA:  ADDLW  20
070BC:  MOVWF  FE9
070BE:  MOVLW  00
070C0:  ADDWFC 03,W
070C2:  MOVWF  FEA
070C4:  MOVFF  710,FEF
070C8:  MOVFF  711,FEC
070CC:  MOVFF  712,FEC
070D0:  MOVFF  713,FEC
070D4:  BRA    711C
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
070D6:  MOVF   x0F,W
070D8:  SUBLW  44
070DA:  BNZ   7112
070DC:  MOVLW  01
070DE:  SUBWF  x0E,W
070E0:  MULLW  28
070E2:  MOVF   FF3,W
070E4:  CLRF   x15
070E6:  MOVWF  x14
070E8:  MOVLW  08
070EA:  ADDWF  x14,W
070EC:  MOVWF  01
070EE:  MOVLW  00
070F0:  ADDWFC x15,W
070F2:  MOVWF  03
070F4:  MOVF   01,W
070F6:  ADDLW  20
070F8:  MOVWF  FE9
070FA:  MOVLW  00
070FC:  ADDWFC 03,W
070FE:  MOVWF  FEA
07100:  MOVFF  710,FEF
07104:  MOVFF  711,FEC
07108:  MOVFF  712,FEC
0710C:  MOVFF  713,FEC
07110:  BRA    711C
....................    else return INV_PARAM;
07112:  MOVLW  02
07114:  MOVWF  01
07116:  MOVLB  0
07118:  BRA    7122
0711A:  MOVLB  7
....................    
....................    return SUCCESS;
0711C:  MOVLW  00
0711E:  MOVWF  01
07120:  MOVLB  0
07122:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07124:  MOVLB  7
07126:  CLRF   x45
07128:  MOVFF  698,744
0712C:  CLRF   x47
0712E:  MOVLW  B5
07130:  MOVWF  x46
07132:  MOVLB  0
07134:  CALL   0864
07138:  MOVFF  02,710
0713C:  MOVFF  01,70F
07140:  MOVLW  06
07142:  MOVLB  7
07144:  ADDWF  x0F,F
07146:  MOVLW  00
07148:  ADDWFC x10,F
0714A:  MOVLW  32
0714C:  ADDWF  x0F,W
0714E:  MOVWF  01
07150:  MOVLW  00
07152:  ADDWFC x10,W
07154:  MOVWF  03
07156:  MOVF   01,W
07158:  ADDLW  EB
0715A:  MOVWF  01
0715C:  MOVLW  01
0715E:  ADDWFC 03,F
07160:  MOVFF  01,70F
07164:  MOVFF  03,710
07168:  MOVFF  03,737
0716C:  MOVFF  01,736
07170:  MOVLB  0
07172:  CALL   5784
07176:  MOVF   01,F
07178:  BNZ   7182
0717A:  MOVLW  02
0717C:  MOVWF  01
0717E:  BRA    7284
07180:  BRA    71E0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07182:  MOVLB  7
07184:  CLRF   x45
07186:  MOVFF  698,744
0718A:  CLRF   x47
0718C:  MOVLW  B5
0718E:  MOVWF  x46
07190:  MOVLB  0
07192:  CALL   0864
07196:  MOVFF  02,710
0719A:  MOVFF  01,70F
0719E:  MOVLW  06
071A0:  MOVLB  7
071A2:  ADDWF  x0F,F
071A4:  MOVLW  00
071A6:  ADDWFC x10,F
071A8:  MOVLW  32
071AA:  ADDWF  x0F,W
071AC:  MOVWF  01
071AE:  MOVLW  00
071B0:  ADDWFC x10,W
071B2:  MOVWF  03
071B4:  MOVF   01,W
071B6:  ADDLW  EB
071B8:  MOVWF  01
071BA:  MOVLW  01
071BC:  ADDWFC 03,F
071BE:  MOVFF  01,70F
071C2:  MOVFF  03,710
071C6:  MOVFF  03,737
071CA:  MOVFF  01,736
071CE:  CLRF   x39
071D0:  CLRF   x38
071D2:  MOVLW  0A
071D4:  MOVWF  x3A
071D6:  MOVLB  0
071D8:  CALL   5874
071DC:  MOVFF  01,70E
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
071E0:  MOVLW  04
071E2:  MOVLB  7
071E4:  MOVWF  x45
071E6:  MOVLW  C1
071E8:  MOVWF  x44
071EA:  MOVLB  0
071EC:  CALL   55AE
071F0:  MOVF   01,W
071F2:  ADDLW  C1
071F4:  MOVLB  7
071F6:  MOVWF  x0F
071F8:  MOVLW  04
071FA:  ADDWFC 02,W
071FC:  MOVWF  x10
071FE:  MOVLW  01
07200:  SUBWF  x0E,W
07202:  MULLW  28
07204:  MOVF   FF3,W
07206:  CLRF   x12
07208:  MOVWF  x11
0720A:  MOVLW  0C
0720C:  ADDWF  x11,W
0720E:  MOVWF  01
07210:  MOVLW  00
07212:  ADDWFC x12,W
07214:  MOVWF  03
07216:  MOVF   01,W
07218:  ADDLW  20
0721A:  MOVWF  FE9
0721C:  MOVLW  00
0721E:  ADDWFC 03,W
07220:  MOVWF  FEA
07222:  MOVFF  FEF,711
07226:  MOVFF  FEC,712
0722A:  MOVFF  FEC,713
0722E:  MOVFF  FEC,714
07232:  MOVFF  710,565
07236:  MOVFF  70F,564
0723A:  MOVFF  70E,737
0723E:  MOVLW  18
07240:  MOVWF  x38
07242:  MOVLB  0
07244:  CALL   5BC8
07248:  MOVLW  2C
0724A:  MOVLB  7
0724C:  MOVWF  x53
0724E:  MOVLB  0
07250:  CALL   55E6
07254:  MOVLW  89
07256:  MOVWF  FE9
07258:  MOVFF  714,749
0725C:  MOVFF  713,748
07260:  MOVFF  712,747
07264:  MOVFF  711,746
07268:  MOVLW  02
0726A:  MOVLB  7
0726C:  MOVWF  x4A
0726E:  MOVLB  0
07270:  CALL   64C2
07274:  MOVLW  2C
07276:  MOVLB  7
07278:  MOVWF  x53
0727A:  MOVLB  0
0727C:  CALL   55E6
....................    return SUCCESS;
07280:  MOVLW  00
07282:  MOVWF  01
07284:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07286:  MOVLB  7
07288:  CLRF   x45
0728A:  MOVFF  698,744
0728E:  CLRF   x47
07290:  MOVLW  B5
07292:  MOVWF  x46
07294:  MOVLB  0
07296:  CALL   0864
0729A:  MOVFF  02,714
0729E:  MOVFF  01,713
072A2:  MOVLW  06
072A4:  MOVLB  7
072A6:  ADDWF  x13,F
072A8:  MOVLW  00
072AA:  ADDWFC x14,F
072AC:  MOVLW  32
072AE:  ADDWF  x13,W
072B0:  MOVWF  01
072B2:  MOVLW  00
072B4:  ADDWFC x14,W
072B6:  MOVWF  03
072B8:  MOVF   01,W
072BA:  ADDLW  EB
072BC:  MOVWF  01
072BE:  MOVLW  01
072C0:  ADDWFC 03,F
072C2:  MOVFF  01,713
072C6:  MOVFF  03,714
072CA:  MOVFF  03,737
072CE:  MOVFF  01,736
072D2:  MOVLB  0
072D4:  CALL   5784
072D8:  MOVF   01,F
072DA:  BNZ   72E4
072DC:  MOVLW  02
072DE:  MOVWF  01
072E0:  BRA    7442
072E2:  BRA    7342
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
072E4:  MOVLB  7
072E6:  CLRF   x45
072E8:  MOVFF  698,744
072EC:  CLRF   x47
072EE:  MOVLW  B5
072F0:  MOVWF  x46
072F2:  MOVLB  0
072F4:  CALL   0864
072F8:  MOVFF  02,714
072FC:  MOVFF  01,713
07300:  MOVLW  06
07302:  MOVLB  7
07304:  ADDWF  x13,F
07306:  MOVLW  00
07308:  ADDWFC x14,F
0730A:  MOVLW  32
0730C:  ADDWF  x13,W
0730E:  MOVWF  01
07310:  MOVLW  00
07312:  ADDWFC x14,W
07314:  MOVWF  03
07316:  MOVF   01,W
07318:  ADDLW  EB
0731A:  MOVWF  01
0731C:  MOVLW  01
0731E:  ADDWFC 03,F
07320:  MOVFF  01,713
07324:  MOVFF  03,714
07328:  MOVFF  03,737
0732C:  MOVFF  01,736
07330:  CLRF   x39
07332:  CLRF   x38
07334:  MOVLW  0A
07336:  MOVWF  x3A
07338:  MOVLB  0
0733A:  CALL   5874
0733E:  MOVFF  01,70E
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07342:  MOVLB  7
07344:  CLRF   x45
07346:  MOVFF  698,744
0734A:  CLRF   x47
0734C:  MOVLW  B5
0734E:  MOVWF  x46
07350:  MOVLB  0
07352:  CALL   0864
07356:  MOVFF  02,714
0735A:  MOVFF  01,713
0735E:  MOVLW  06
07360:  MOVLB  7
07362:  ADDWF  x13,F
07364:  MOVLW  00
07366:  ADDWFC x14,F
07368:  MOVLW  4B
0736A:  ADDWF  x13,W
0736C:  MOVWF  01
0736E:  MOVLW  00
07370:  ADDWFC x14,W
07372:  MOVWF  03
07374:  MOVF   01,W
07376:  ADDLW  EB
07378:  MOVWF  01
0737A:  MOVLW  01
0737C:  ADDWFC 03,F
0737E:  MOVFF  01,713
07382:  MOVFF  03,714
07386:  MOVFF  03,718
0738A:  MOVFF  01,717
0738E:  MOVLB  0
07390:  CALL   6B28
07394:  MOVF   01,F
07396:  BNZ   73A0
07398:  MOVLW  02
0739A:  MOVWF  01
0739C:  BRA    7442
0739E:  BRA    7406
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
073A0:  MOVLB  7
073A2:  CLRF   x45
073A4:  MOVFF  698,744
073A8:  CLRF   x47
073AA:  MOVLW  B5
073AC:  MOVWF  x46
073AE:  MOVLB  0
073B0:  CALL   0864
073B4:  MOVFF  02,714
073B8:  MOVFF  01,713
073BC:  MOVLW  06
073BE:  MOVLB  7
073C0:  ADDWF  x13,F
073C2:  MOVLW  00
073C4:  ADDWFC x14,F
073C6:  MOVLW  4B
073C8:  ADDWF  x13,W
073CA:  MOVWF  01
073CC:  MOVLW  00
073CE:  ADDWFC x14,W
073D0:  MOVWF  03
073D2:  MOVF   01,W
073D4:  ADDLW  EB
073D6:  MOVWF  01
073D8:  MOVLW  01
073DA:  ADDWFC 03,F
073DC:  MOVFF  01,713
073E0:  MOVFF  03,714
073E4:  MOVFF  03,718
073E8:  MOVFF  01,717
073EC:  CLRF   x1A
073EE:  CLRF   x19
073F0:  MOVLB  0
073F2:  CALL   6BEA
073F6:  MOVFF  03,712
073FA:  MOVFF  02,711
073FE:  MOVFF  01,710
07402:  MOVFF  00,70F
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
07406:  MOVLW  01
07408:  MOVLB  7
0740A:  SUBWF  x0E,W
0740C:  MULLW  28
0740E:  MOVF   FF3,W
07410:  CLRF   x14
07412:  MOVWF  x13
07414:  MOVLW  0C
07416:  ADDWF  x13,W
07418:  MOVWF  01
0741A:  MOVLW  00
0741C:  ADDWFC x14,W
0741E:  MOVWF  03
07420:  MOVF   01,W
07422:  ADDLW  20
07424:  MOVWF  FE9
07426:  MOVLW  00
07428:  ADDWFC 03,W
0742A:  MOVWF  FEA
0742C:  MOVFF  70F,FEF
07430:  MOVFF  710,FEC
07434:  MOVFF  711,FEC
07438:  MOVFF  712,FEC
....................    
....................    return SUCCESS;
0743C:  MOVLW  00
0743E:  MOVWF  01
07440:  MOVLB  0
07442:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07444:  MOVLB  7
07446:  CLRF   x45
07448:  MOVFF  698,744
0744C:  CLRF   x47
0744E:  MOVLW  B5
07450:  MOVWF  x46
07452:  MOVLB  0
07454:  CALL   0864
07458:  MOVFF  02,710
0745C:  MOVFF  01,70F
07460:  MOVLW  06
07462:  MOVLB  7
07464:  ADDWF  x0F,F
07466:  MOVLW  00
07468:  ADDWFC x10,F
0746A:  MOVLW  32
0746C:  ADDWF  x0F,W
0746E:  MOVWF  01
07470:  MOVLW  00
07472:  ADDWFC x10,W
07474:  MOVWF  03
07476:  MOVF   01,W
07478:  ADDLW  EB
0747A:  MOVWF  01
0747C:  MOVLW  01
0747E:  ADDWFC 03,F
07480:  MOVFF  01,70F
07484:  MOVFF  03,710
07488:  MOVFF  03,737
0748C:  MOVFF  01,736
07490:  MOVLB  0
07492:  CALL   5784
07496:  MOVF   01,F
07498:  BNZ   74A2
0749A:  MOVLW  02
0749C:  MOVWF  01
0749E:  BRA    77F8
074A0:  BRA    7500
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
074A2:  MOVLB  7
074A4:  CLRF   x45
074A6:  MOVFF  698,744
074AA:  CLRF   x47
074AC:  MOVLW  B5
074AE:  MOVWF  x46
074B0:  MOVLB  0
074B2:  CALL   0864
074B6:  MOVFF  02,710
074BA:  MOVFF  01,70F
074BE:  MOVLW  06
074C0:  MOVLB  7
074C2:  ADDWF  x0F,F
074C4:  MOVLW  00
074C6:  ADDWFC x10,F
074C8:  MOVLW  32
074CA:  ADDWF  x0F,W
074CC:  MOVWF  01
074CE:  MOVLW  00
074D0:  ADDWFC x10,W
074D2:  MOVWF  03
074D4:  MOVF   01,W
074D6:  ADDLW  EB
074D8:  MOVWF  01
074DA:  MOVLW  01
074DC:  ADDWFC 03,F
074DE:  MOVFF  01,70F
074E2:  MOVFF  03,710
074E6:  MOVFF  03,737
074EA:  MOVFF  01,736
074EE:  CLRF   x39
074F0:  CLRF   x38
074F2:  MOVLW  0A
074F4:  MOVWF  x3A
074F6:  MOVLB  0
074F8:  CALL   5874
074FC:  MOVFF  01,70E
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07500:  MOVLW  04
07502:  MOVLB  7
07504:  MOVWF  x45
07506:  MOVLW  C1
07508:  MOVWF  x44
0750A:  MOVLB  0
0750C:  CALL   55AE
07510:  MOVFF  02,03
07514:  MOVF   01,W
07516:  ADDLW  C1
07518:  MOVLB  7
0751A:  MOVWF  x0F
0751C:  MOVLW  04
0751E:  ADDWFC 02,W
07520:  MOVWF  x10
07522:  MOVFF  FE8,565
07526:  MOVFF  70F,564
0752A:  MOVFF  70E,737
0752E:  MOVLW  18
07530:  MOVWF  x38
07532:  MOVLB  0
07534:  CALL   5BC8
07538:  MOVLW  2C
0753A:  MOVLB  7
0753C:  MOVWF  x53
0753E:  MOVLB  0
07540:  CALL   55E6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07544:  MOVLW  04
07546:  MOVLB  7
07548:  MOVWF  x45
0754A:  MOVLW  C1
0754C:  MOVWF  x44
0754E:  MOVLB  0
07550:  CALL   55AE
07554:  MOVFF  02,03
07558:  MOVF   01,W
0755A:  ADDLW  C1
0755C:  MOVLB  7
0755E:  MOVWF  x0F
07560:  MOVLW  04
07562:  ADDWFC 02,W
07564:  MOVWF  x10
07566:  MOVLW  01
07568:  SUBWF  x0E,W
0756A:  MULLW  18
0756C:  MOVF   FF3,W
0756E:  CLRF   x12
07570:  MOVWF  x11
07572:  MOVLW  92
07574:  ADDWF  x11,W
07576:  MOVWF  FE9
07578:  MOVLW  00
0757A:  ADDWFC x12,W
0757C:  MOVWF  FEA
0757E:  MOVFF  FEF,746
07582:  MOVFF  FEC,747
07586:  MOVFF  FEC,748
0758A:  MOVFF  FEC,749
0758E:  MOVFF  710,565
07592:  MOVFF  70F,564
07596:  MOVLW  89
07598:  MOVWF  FE9
0759A:  MOVLW  02
0759C:  MOVWF  x4A
0759E:  MOVLB  0
075A0:  CALL   64C2
075A4:  MOVLW  2C
075A6:  MOVLB  7
075A8:  MOVWF  x53
075AA:  MOVLB  0
075AC:  CALL   55E6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
075B0:  MOVLW  04
075B2:  MOVLB  7
075B4:  MOVWF  x45
075B6:  MOVLW  C1
075B8:  MOVWF  x44
075BA:  MOVLB  0
075BC:  CALL   55AE
075C0:  MOVF   01,W
075C2:  ADDLW  C1
075C4:  MOVLB  7
075C6:  MOVWF  x0F
075C8:  MOVLW  04
075CA:  ADDWFC 02,W
075CC:  MOVWF  x10
075CE:  MOVLW  01
075D0:  SUBWF  x0E,W
075D2:  MULLW  18
075D4:  MOVF   FF3,W
075D6:  CLRF   x12
075D8:  MOVWF  x11
075DA:  MOVLW  04
075DC:  ADDWF  x11,W
075DE:  MOVWF  01
075E0:  MOVLW  00
075E2:  ADDWFC x12,W
075E4:  MOVWF  03
075E6:  MOVF   01,W
075E8:  ADDLW  92
075EA:  MOVWF  FE9
075EC:  MOVLW  00
075EE:  ADDWFC 03,W
075F0:  MOVWF  FEA
075F2:  MOVFF  FEF,746
075F6:  MOVFF  FEC,747
075FA:  MOVFF  FEC,748
075FE:  MOVFF  FEC,749
07602:  MOVFF  710,565
07606:  MOVFF  70F,564
0760A:  MOVLW  89
0760C:  MOVWF  FE9
0760E:  MOVLW  02
07610:  MOVWF  x4A
07612:  MOVLB  0
07614:  CALL   64C2
07618:  MOVLW  2C
0761A:  MOVLB  7
0761C:  MOVWF  x53
0761E:  MOVLB  0
07620:  CALL   55E6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07624:  MOVLW  04
07626:  MOVLB  7
07628:  MOVWF  x45
0762A:  MOVLW  C1
0762C:  MOVWF  x44
0762E:  MOVLB  0
07630:  CALL   55AE
07634:  MOVF   01,W
07636:  ADDLW  C1
07638:  MOVLB  7
0763A:  MOVWF  x0F
0763C:  MOVLW  04
0763E:  ADDWFC 02,W
07640:  MOVWF  x10
07642:  MOVLW  01
07644:  SUBWF  x0E,W
07646:  MULLW  18
07648:  MOVF   FF3,W
0764A:  CLRF   x12
0764C:  MOVWF  x11
0764E:  MOVLW  08
07650:  ADDWF  x11,W
07652:  MOVWF  01
07654:  MOVLW  00
07656:  ADDWFC x12,W
07658:  MOVWF  03
0765A:  MOVF   01,W
0765C:  ADDLW  92
0765E:  MOVWF  FE9
07660:  MOVLW  00
07662:  ADDWFC 03,W
07664:  MOVWF  FEA
07666:  MOVFF  FEF,746
0766A:  MOVFF  FEC,747
0766E:  MOVFF  FEC,748
07672:  MOVFF  FEC,749
07676:  MOVFF  710,565
0767A:  MOVFF  70F,564
0767E:  MOVLW  89
07680:  MOVWF  FE9
07682:  MOVLW  02
07684:  MOVWF  x4A
07686:  MOVLB  0
07688:  CALL   64C2
0768C:  MOVLW  2C
0768E:  MOVLB  7
07690:  MOVWF  x53
07692:  MOVLB  0
07694:  CALL   55E6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
07698:  MOVLW  04
0769A:  MOVLB  7
0769C:  MOVWF  x45
0769E:  MOVLW  C1
076A0:  MOVWF  x44
076A2:  MOVLB  0
076A4:  CALL   55AE
076A8:  MOVF   01,W
076AA:  ADDLW  C1
076AC:  MOVLB  7
076AE:  MOVWF  x0F
076B0:  MOVLW  04
076B2:  ADDWFC 02,W
076B4:  MOVWF  x10
076B6:  MOVLW  01
076B8:  SUBWF  x0E,W
076BA:  MULLW  18
076BC:  MOVF   FF3,W
076BE:  CLRF   x12
076C0:  MOVWF  x11
076C2:  MOVLW  0C
076C4:  ADDWF  x11,W
076C6:  MOVWF  01
076C8:  MOVLW  00
076CA:  ADDWFC x12,W
076CC:  MOVWF  03
076CE:  MOVF   01,W
076D0:  ADDLW  92
076D2:  MOVWF  FE9
076D4:  MOVLW  00
076D6:  ADDWFC 03,W
076D8:  MOVWF  FEA
076DA:  MOVFF  FEF,746
076DE:  MOVFF  FEC,747
076E2:  MOVFF  FEC,748
076E6:  MOVFF  FEC,749
076EA:  MOVFF  710,565
076EE:  MOVFF  70F,564
076F2:  MOVLW  89
076F4:  MOVWF  FE9
076F6:  MOVLW  02
076F8:  MOVWF  x4A
076FA:  MOVLB  0
076FC:  CALL   64C2
07700:  MOVLW  2C
07702:  MOVLB  7
07704:  MOVWF  x53
07706:  MOVLB  0
07708:  CALL   55E6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
0770C:  MOVLW  04
0770E:  MOVLB  7
07710:  MOVWF  x45
07712:  MOVLW  C1
07714:  MOVWF  x44
07716:  MOVLB  0
07718:  CALL   55AE
0771C:  MOVF   01,W
0771E:  ADDLW  C1
07720:  MOVLB  7
07722:  MOVWF  x0F
07724:  MOVLW  04
07726:  ADDWFC 02,W
07728:  MOVWF  x10
0772A:  MOVLW  01
0772C:  SUBWF  x0E,W
0772E:  MULLW  18
07730:  MOVF   FF3,W
07732:  CLRF   x12
07734:  MOVWF  x11
07736:  MOVLW  10
07738:  ADDWF  x11,W
0773A:  MOVWF  01
0773C:  MOVLW  00
0773E:  ADDWFC x12,W
07740:  MOVWF  03
07742:  MOVF   01,W
07744:  ADDLW  92
07746:  MOVWF  FE9
07748:  MOVLW  00
0774A:  ADDWFC 03,W
0774C:  MOVWF  FEA
0774E:  MOVFF  FEF,746
07752:  MOVFF  FEC,747
07756:  MOVFF  FEC,748
0775A:  MOVFF  FEC,749
0775E:  MOVFF  710,565
07762:  MOVFF  70F,564
07766:  MOVLW  89
07768:  MOVWF  FE9
0776A:  MOVLW  02
0776C:  MOVWF  x4A
0776E:  MOVLB  0
07770:  CALL   64C2
07774:  MOVLW  2C
07776:  MOVLB  7
07778:  MOVWF  x53
0777A:  MOVLB  0
0777C:  CALL   55E6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07780:  MOVLW  04
07782:  MOVLB  7
07784:  MOVWF  x45
07786:  MOVLW  C1
07788:  MOVWF  x44
0778A:  MOVLB  0
0778C:  CALL   55AE
07790:  MOVF   01,W
07792:  ADDLW  C1
07794:  MOVLB  7
07796:  MOVWF  x0F
07798:  MOVLW  04
0779A:  ADDWFC 02,W
0779C:  MOVWF  x10
0779E:  MOVLW  01
077A0:  SUBWF  x0E,W
077A2:  MULLW  18
077A4:  MOVF   FF3,W
077A6:  CLRF   x12
077A8:  MOVWF  x11
077AA:  MOVLW  14
077AC:  ADDWF  x11,W
077AE:  MOVWF  01
077B0:  MOVLW  00
077B2:  ADDWFC x12,W
077B4:  MOVWF  03
077B6:  MOVF   01,W
077B8:  ADDLW  92
077BA:  MOVWF  FE9
077BC:  MOVLW  00
077BE:  ADDWFC 03,W
077C0:  MOVWF  FEA
077C2:  MOVFF  FEF,746
077C6:  MOVFF  FEC,747
077CA:  MOVFF  FEC,748
077CE:  MOVFF  FEC,749
077D2:  MOVFF  710,565
077D6:  MOVFF  70F,564
077DA:  MOVLW  89
077DC:  MOVWF  FE9
077DE:  MOVLW  02
077E0:  MOVWF  x4A
077E2:  MOVLB  0
077E4:  CALL   64C2
077E8:  MOVLW  2C
077EA:  MOVLB  7
077EC:  MOVWF  x53
077EE:  MOVLB  0
077F0:  CALL   55E6
....................    
....................    return SUCCESS;
077F4:  MOVLW  00
077F6:  MOVWF  01
077F8:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
077FA:  MOVLB  7
077FC:  CLRF   x45
077FE:  MOVFF  698,744
07802:  CLRF   x47
07804:  MOVLW  B5
07806:  MOVWF  x46
07808:  MOVLB  0
0780A:  CALL   0864
0780E:  MOVFF  02,711
07812:  MOVFF  01,710
07816:  MOVLW  06
07818:  MOVLB  7
0781A:  ADDWF  x10,F
0781C:  MOVLW  00
0781E:  ADDWFC x11,F
07820:  MOVLW  32
07822:  ADDWF  x10,W
07824:  MOVWF  01
07826:  MOVLW  00
07828:  ADDWFC x11,W
0782A:  MOVWF  03
0782C:  MOVF   01,W
0782E:  ADDLW  EB
07830:  MOVWF  01
07832:  MOVLW  01
07834:  ADDWFC 03,F
07836:  MOVFF  01,710
0783A:  MOVFF  03,711
0783E:  MOVFF  03,737
07842:  MOVFF  01,736
07846:  MOVLB  0
07848:  CALL   5784
0784C:  MOVF   01,F
0784E:  BNZ   7858
07850:  MOVLW  02
07852:  MOVWF  01
07854:  BRA    7D54
07856:  BRA    78B6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07858:  MOVLB  7
0785A:  CLRF   x45
0785C:  MOVFF  698,744
07860:  CLRF   x47
07862:  MOVLW  B5
07864:  MOVWF  x46
07866:  MOVLB  0
07868:  CALL   0864
0786C:  MOVFF  02,711
07870:  MOVFF  01,710
07874:  MOVLW  06
07876:  MOVLB  7
07878:  ADDWF  x10,F
0787A:  MOVLW  00
0787C:  ADDWFC x11,F
0787E:  MOVLW  32
07880:  ADDWF  x10,W
07882:  MOVWF  01
07884:  MOVLW  00
07886:  ADDWFC x11,W
07888:  MOVWF  03
0788A:  MOVF   01,W
0788C:  ADDLW  EB
0788E:  MOVWF  01
07890:  MOVLW  01
07892:  ADDWFC 03,F
07894:  MOVFF  01,710
07898:  MOVFF  03,711
0789C:  MOVFF  03,737
078A0:  MOVFF  01,736
078A4:  CLRF   x39
078A6:  CLRF   x38
078A8:  MOVLW  0A
078AA:  MOVWF  x3A
078AC:  MOVLB  0
078AE:  CALL   5874
078B2:  MOVFF  01,70E
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
078B6:  MOVLB  7
078B8:  CLRF   x45
078BA:  MOVFF  698,744
078BE:  CLRF   x47
078C0:  MOVLW  B5
078C2:  MOVWF  x46
078C4:  MOVLB  0
078C6:  CALL   0864
078CA:  MOVFF  02,711
078CE:  MOVFF  01,710
078D2:  MOVLW  06
078D4:  MOVLB  7
078D6:  ADDWF  x10,F
078D8:  MOVLW  00
078DA:  ADDWFC x11,F
078DC:  MOVLW  4B
078DE:  ADDWF  x10,W
078E0:  MOVWF  01
078E2:  MOVLW  00
078E4:  ADDWFC x11,W
078E6:  MOVWF  03
078E8:  MOVF   01,W
078EA:  ADDLW  EB
078EC:  MOVWF  01
078EE:  MOVLW  01
078F0:  ADDWFC 03,F
078F2:  MOVFF  01,710
078F6:  MOVFF  03,711
078FA:  MOVFF  03,745
078FE:  MOVFF  01,744
07902:  MOVLB  0
07904:  CALL   55AE
07908:  MOVFF  02,03
0790C:  MOVF   01,W
0790E:  SUBLW  01
07910:  BNZ   7916
07912:  MOVF   03,F
07914:  BZ    791E
07916:  MOVLW  02
07918:  MOVWF  01
0791A:  BRA    7D54
0791C:  BRA    795E
....................    else arg2 = SERcmd[rec].p[3][0];
0791E:  MOVLB  7
07920:  CLRF   x45
07922:  MOVFF  698,744
07926:  CLRF   x47
07928:  MOVLW  B5
0792A:  MOVWF  x46
0792C:  MOVLB  0
0792E:  CALL   0864
07932:  MOVFF  02,711
07936:  MOVFF  01,710
0793A:  MOVLW  06
0793C:  MOVLB  7
0793E:  ADDWF  x10,F
07940:  MOVLW  00
07942:  ADDWFC x11,F
07944:  MOVLW  4B
07946:  ADDWF  x10,F
07948:  MOVLW  00
0794A:  ADDWFC x11,F
0794C:  MOVLW  EB
0794E:  ADDWF  x10,W
07950:  MOVWF  FE9
07952:  MOVLW  01
07954:  ADDWFC x11,W
07956:  MOVWF  FEA
07958:  MOVFF  FEF,70F
0795C:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
0795E:  MOVLB  7
07960:  MOVF   x0F,W
07962:  SUBLW  30
07964:  BNZ   7A00
07966:  MOVLW  04
07968:  MOVWF  x45
0796A:  MOVLW  C1
0796C:  MOVWF  x44
0796E:  MOVLB  0
07970:  CALL   55AE
07974:  MOVFF  02,03
07978:  MOVF   01,W
0797A:  ADDLW  C1
0797C:  MOVLB  7
0797E:  MOVWF  x10
07980:  MOVLW  04
07982:  ADDWFC 02,W
07984:  MOVWF  x11
07986:  MOVLW  01
07988:  SUBWF  x0E,W
0798A:  MULLW  18
0798C:  MOVF   FF3,W
0798E:  CLRF   x13
07990:  MOVWF  x12
07992:  MOVLW  92
07994:  ADDWF  x12,W
07996:  MOVWF  FE9
07998:  MOVLW  00
0799A:  ADDWFC x13,W
0799C:  MOVWF  FEA
0799E:  MOVFF  FEF,714
079A2:  MOVFF  FEC,715
079A6:  MOVFF  FEC,716
079AA:  MOVFF  FEC,717
079AE:  MOVFF  711,565
079B2:  MOVFF  710,564
079B6:  MOVFF  70E,737
079BA:  MOVLW  18
079BC:  MOVWF  x38
079BE:  MOVLB  0
079C0:  CALL   5BC8
079C4:  MOVLW  2C
079C6:  MOVLB  7
079C8:  MOVWF  x53
079CA:  MOVLB  0
079CC:  CALL   55E6
079D0:  MOVLW  89
079D2:  MOVWF  FE9
079D4:  MOVFF  717,749
079D8:  MOVFF  716,748
079DC:  MOVFF  715,747
079E0:  MOVFF  714,746
079E4:  MOVLW  02
079E6:  MOVLB  7
079E8:  MOVWF  x4A
079EA:  MOVLB  0
079EC:  CALL   64C2
079F0:  MOVLW  2C
079F2:  MOVLB  7
079F4:  MOVWF  x53
079F6:  MOVLB  0
079F8:  CALL   55E6
079FC:  BRA    7D50
079FE:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07A00:  MOVF   x0F,W
07A02:  SUBLW  31
07A04:  BNZ   7AA8
07A06:  MOVLW  04
07A08:  MOVWF  x45
07A0A:  MOVLW  C1
07A0C:  MOVWF  x44
07A0E:  MOVLB  0
07A10:  CALL   55AE
07A14:  MOVF   01,W
07A16:  ADDLW  C1
07A18:  MOVLB  7
07A1A:  MOVWF  x10
07A1C:  MOVLW  04
07A1E:  ADDWFC 02,W
07A20:  MOVWF  x11
07A22:  MOVLW  01
07A24:  SUBWF  x0E,W
07A26:  MULLW  18
07A28:  MOVF   FF3,W
07A2A:  CLRF   x13
07A2C:  MOVWF  x12
07A2E:  MOVLW  04
07A30:  ADDWF  x12,W
07A32:  MOVWF  01
07A34:  MOVLW  00
07A36:  ADDWFC x13,W
07A38:  MOVWF  03
07A3A:  MOVF   01,W
07A3C:  ADDLW  92
07A3E:  MOVWF  FE9
07A40:  MOVLW  00
07A42:  ADDWFC 03,W
07A44:  MOVWF  FEA
07A46:  MOVFF  FEF,712
07A4A:  MOVFF  FEC,713
07A4E:  MOVFF  FEC,714
07A52:  MOVFF  FEC,715
07A56:  MOVFF  711,565
07A5A:  MOVFF  710,564
07A5E:  MOVFF  70E,737
07A62:  MOVLW  18
07A64:  MOVWF  x38
07A66:  MOVLB  0
07A68:  CALL   5BC8
07A6C:  MOVLW  2C
07A6E:  MOVLB  7
07A70:  MOVWF  x53
07A72:  MOVLB  0
07A74:  CALL   55E6
07A78:  MOVLW  89
07A7A:  MOVWF  FE9
07A7C:  MOVFF  715,749
07A80:  MOVFF  714,748
07A84:  MOVFF  713,747
07A88:  MOVFF  712,746
07A8C:  MOVLW  02
07A8E:  MOVLB  7
07A90:  MOVWF  x4A
07A92:  MOVLB  0
07A94:  CALL   64C2
07A98:  MOVLW  2C
07A9A:  MOVLB  7
07A9C:  MOVWF  x53
07A9E:  MOVLB  0
07AA0:  CALL   55E6
07AA4:  BRA    7D50
07AA6:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07AA8:  MOVF   x0F,W
07AAA:  SUBLW  32
07AAC:  BNZ   7B50
07AAE:  MOVLW  04
07AB0:  MOVWF  x45
07AB2:  MOVLW  C1
07AB4:  MOVWF  x44
07AB6:  MOVLB  0
07AB8:  CALL   55AE
07ABC:  MOVF   01,W
07ABE:  ADDLW  C1
07AC0:  MOVLB  7
07AC2:  MOVWF  x10
07AC4:  MOVLW  04
07AC6:  ADDWFC 02,W
07AC8:  MOVWF  x11
07ACA:  MOVLW  01
07ACC:  SUBWF  x0E,W
07ACE:  MULLW  18
07AD0:  MOVF   FF3,W
07AD2:  CLRF   x13
07AD4:  MOVWF  x12
07AD6:  MOVLW  08
07AD8:  ADDWF  x12,W
07ADA:  MOVWF  01
07ADC:  MOVLW  00
07ADE:  ADDWFC x13,W
07AE0:  MOVWF  03
07AE2:  MOVF   01,W
07AE4:  ADDLW  92
07AE6:  MOVWF  FE9
07AE8:  MOVLW  00
07AEA:  ADDWFC 03,W
07AEC:  MOVWF  FEA
07AEE:  MOVFF  FEF,712
07AF2:  MOVFF  FEC,713
07AF6:  MOVFF  FEC,714
07AFA:  MOVFF  FEC,715
07AFE:  MOVFF  711,565
07B02:  MOVFF  710,564
07B06:  MOVFF  70E,737
07B0A:  MOVLW  18
07B0C:  MOVWF  x38
07B0E:  MOVLB  0
07B10:  CALL   5BC8
07B14:  MOVLW  2C
07B16:  MOVLB  7
07B18:  MOVWF  x53
07B1A:  MOVLB  0
07B1C:  CALL   55E6
07B20:  MOVLW  89
07B22:  MOVWF  FE9
07B24:  MOVFF  715,749
07B28:  MOVFF  714,748
07B2C:  MOVFF  713,747
07B30:  MOVFF  712,746
07B34:  MOVLW  02
07B36:  MOVLB  7
07B38:  MOVWF  x4A
07B3A:  MOVLB  0
07B3C:  CALL   64C2
07B40:  MOVLW  2C
07B42:  MOVLB  7
07B44:  MOVWF  x53
07B46:  MOVLB  0
07B48:  CALL   55E6
07B4C:  BRA    7D50
07B4E:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07B50:  MOVF   x0F,W
07B52:  SUBLW  33
07B54:  BNZ   7BF8
07B56:  MOVLW  04
07B58:  MOVWF  x45
07B5A:  MOVLW  C1
07B5C:  MOVWF  x44
07B5E:  MOVLB  0
07B60:  CALL   55AE
07B64:  MOVF   01,W
07B66:  ADDLW  C1
07B68:  MOVLB  7
07B6A:  MOVWF  x10
07B6C:  MOVLW  04
07B6E:  ADDWFC 02,W
07B70:  MOVWF  x11
07B72:  MOVLW  01
07B74:  SUBWF  x0E,W
07B76:  MULLW  18
07B78:  MOVF   FF3,W
07B7A:  CLRF   x13
07B7C:  MOVWF  x12
07B7E:  MOVLW  0C
07B80:  ADDWF  x12,W
07B82:  MOVWF  01
07B84:  MOVLW  00
07B86:  ADDWFC x13,W
07B88:  MOVWF  03
07B8A:  MOVF   01,W
07B8C:  ADDLW  92
07B8E:  MOVWF  FE9
07B90:  MOVLW  00
07B92:  ADDWFC 03,W
07B94:  MOVWF  FEA
07B96:  MOVFF  FEF,712
07B9A:  MOVFF  FEC,713
07B9E:  MOVFF  FEC,714
07BA2:  MOVFF  FEC,715
07BA6:  MOVFF  711,565
07BAA:  MOVFF  710,564
07BAE:  MOVFF  70E,737
07BB2:  MOVLW  18
07BB4:  MOVWF  x38
07BB6:  MOVLB  0
07BB8:  CALL   5BC8
07BBC:  MOVLW  2C
07BBE:  MOVLB  7
07BC0:  MOVWF  x53
07BC2:  MOVLB  0
07BC4:  CALL   55E6
07BC8:  MOVLW  89
07BCA:  MOVWF  FE9
07BCC:  MOVFF  715,749
07BD0:  MOVFF  714,748
07BD4:  MOVFF  713,747
07BD8:  MOVFF  712,746
07BDC:  MOVLW  02
07BDE:  MOVLB  7
07BE0:  MOVWF  x4A
07BE2:  MOVLB  0
07BE4:  CALL   64C2
07BE8:  MOVLW  2C
07BEA:  MOVLB  7
07BEC:  MOVWF  x53
07BEE:  MOVLB  0
07BF0:  CALL   55E6
07BF4:  BRA    7D50
07BF6:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07BF8:  MOVF   x0F,W
07BFA:  SUBLW  34
07BFC:  BNZ   7CA0
07BFE:  MOVLW  04
07C00:  MOVWF  x45
07C02:  MOVLW  C1
07C04:  MOVWF  x44
07C06:  MOVLB  0
07C08:  CALL   55AE
07C0C:  MOVF   01,W
07C0E:  ADDLW  C1
07C10:  MOVLB  7
07C12:  MOVWF  x10
07C14:  MOVLW  04
07C16:  ADDWFC 02,W
07C18:  MOVWF  x11
07C1A:  MOVLW  01
07C1C:  SUBWF  x0E,W
07C1E:  MULLW  18
07C20:  MOVF   FF3,W
07C22:  CLRF   x13
07C24:  MOVWF  x12
07C26:  MOVLW  10
07C28:  ADDWF  x12,W
07C2A:  MOVWF  01
07C2C:  MOVLW  00
07C2E:  ADDWFC x13,W
07C30:  MOVWF  03
07C32:  MOVF   01,W
07C34:  ADDLW  92
07C36:  MOVWF  FE9
07C38:  MOVLW  00
07C3A:  ADDWFC 03,W
07C3C:  MOVWF  FEA
07C3E:  MOVFF  FEF,712
07C42:  MOVFF  FEC,713
07C46:  MOVFF  FEC,714
07C4A:  MOVFF  FEC,715
07C4E:  MOVFF  711,565
07C52:  MOVFF  710,564
07C56:  MOVFF  70E,737
07C5A:  MOVLW  18
07C5C:  MOVWF  x38
07C5E:  MOVLB  0
07C60:  CALL   5BC8
07C64:  MOVLW  2C
07C66:  MOVLB  7
07C68:  MOVWF  x53
07C6A:  MOVLB  0
07C6C:  CALL   55E6
07C70:  MOVLW  89
07C72:  MOVWF  FE9
07C74:  MOVFF  715,749
07C78:  MOVFF  714,748
07C7C:  MOVFF  713,747
07C80:  MOVFF  712,746
07C84:  MOVLW  02
07C86:  MOVLB  7
07C88:  MOVWF  x4A
07C8A:  MOVLB  0
07C8C:  CALL   64C2
07C90:  MOVLW  2C
07C92:  MOVLB  7
07C94:  MOVWF  x53
07C96:  MOVLB  0
07C98:  CALL   55E6
07C9C:  BRA    7D50
07C9E:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07CA0:  MOVF   x0F,W
07CA2:  SUBLW  35
07CA4:  BNZ   7D48
07CA6:  MOVLW  04
07CA8:  MOVWF  x45
07CAA:  MOVLW  C1
07CAC:  MOVWF  x44
07CAE:  MOVLB  0
07CB0:  CALL   55AE
07CB4:  MOVF   01,W
07CB6:  ADDLW  C1
07CB8:  MOVLB  7
07CBA:  MOVWF  x10
07CBC:  MOVLW  04
07CBE:  ADDWFC 02,W
07CC0:  MOVWF  x11
07CC2:  MOVLW  01
07CC4:  SUBWF  x0E,W
07CC6:  MULLW  18
07CC8:  MOVF   FF3,W
07CCA:  CLRF   x13
07CCC:  MOVWF  x12
07CCE:  MOVLW  14
07CD0:  ADDWF  x12,W
07CD2:  MOVWF  01
07CD4:  MOVLW  00
07CD6:  ADDWFC x13,W
07CD8:  MOVWF  03
07CDA:  MOVF   01,W
07CDC:  ADDLW  92
07CDE:  MOVWF  FE9
07CE0:  MOVLW  00
07CE2:  ADDWFC 03,W
07CE4:  MOVWF  FEA
07CE6:  MOVFF  FEF,712
07CEA:  MOVFF  FEC,713
07CEE:  MOVFF  FEC,714
07CF2:  MOVFF  FEC,715
07CF6:  MOVFF  711,565
07CFA:  MOVFF  710,564
07CFE:  MOVFF  70E,737
07D02:  MOVLW  18
07D04:  MOVWF  x38
07D06:  MOVLB  0
07D08:  CALL   5BC8
07D0C:  MOVLW  2C
07D0E:  MOVLB  7
07D10:  MOVWF  x53
07D12:  MOVLB  0
07D14:  CALL   55E6
07D18:  MOVLW  89
07D1A:  MOVWF  FE9
07D1C:  MOVFF  715,749
07D20:  MOVFF  714,748
07D24:  MOVFF  713,747
07D28:  MOVFF  712,746
07D2C:  MOVLW  02
07D2E:  MOVLB  7
07D30:  MOVWF  x4A
07D32:  MOVLB  0
07D34:  CALL   64C2
07D38:  MOVLW  2C
07D3A:  MOVLB  7
07D3C:  MOVWF  x53
07D3E:  MOVLB  0
07D40:  CALL   55E6
07D44:  BRA    7D50
07D46:  MOVLB  7
....................    else return INV_PARAM;
07D48:  MOVLW  02
07D4A:  MOVWF  01
07D4C:  MOVLB  0
07D4E:  BRA    7D54
....................    
....................    return SUCCESS;
07D50:  MOVLW  00
07D52:  MOVWF  01
07D54:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07D56:  MOVLB  7
07D58:  CLRF   x45
07D5A:  MOVFF  698,744
07D5E:  CLRF   x47
07D60:  MOVLW  B5
07D62:  MOVWF  x46
07D64:  MOVLB  0
07D66:  CALL   0864
07D6A:  MOVFF  02,715
07D6E:  MOVFF  01,714
07D72:  MOVLW  06
07D74:  MOVLB  7
07D76:  ADDWF  x14,F
07D78:  MOVLW  00
07D7A:  ADDWFC x15,F
07D7C:  MOVLW  32
07D7E:  ADDWF  x14,W
07D80:  MOVWF  01
07D82:  MOVLW  00
07D84:  ADDWFC x15,W
07D86:  MOVWF  03
07D88:  MOVF   01,W
07D8A:  ADDLW  EB
07D8C:  MOVWF  01
07D8E:  MOVLW  01
07D90:  ADDWFC 03,F
07D92:  MOVFF  01,714
07D96:  MOVFF  03,715
07D9A:  MOVFF  03,737
07D9E:  MOVFF  01,736
07DA2:  MOVLB  0
07DA4:  CALL   5784
07DA8:  MOVF   01,F
07DAA:  BNZ   7DB4
07DAC:  MOVLW  02
07DAE:  MOVWF  01
07DB0:  BRA    80EC
07DB2:  BRA    7E12
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07DB4:  MOVLB  7
07DB6:  CLRF   x45
07DB8:  MOVFF  698,744
07DBC:  CLRF   x47
07DBE:  MOVLW  B5
07DC0:  MOVWF  x46
07DC2:  MOVLB  0
07DC4:  CALL   0864
07DC8:  MOVFF  02,715
07DCC:  MOVFF  01,714
07DD0:  MOVLW  06
07DD2:  MOVLB  7
07DD4:  ADDWF  x14,F
07DD6:  MOVLW  00
07DD8:  ADDWFC x15,F
07DDA:  MOVLW  32
07DDC:  ADDWF  x14,W
07DDE:  MOVWF  01
07DE0:  MOVLW  00
07DE2:  ADDWFC x15,W
07DE4:  MOVWF  03
07DE6:  MOVF   01,W
07DE8:  ADDLW  EB
07DEA:  MOVWF  01
07DEC:  MOVLW  01
07DEE:  ADDWFC 03,F
07DF0:  MOVFF  01,714
07DF4:  MOVFF  03,715
07DF8:  MOVFF  03,737
07DFC:  MOVFF  01,736
07E00:  CLRF   x39
07E02:  CLRF   x38
07E04:  MOVLW  0A
07E06:  MOVWF  x3A
07E08:  MOVLB  0
07E0A:  CALL   5874
07E0E:  MOVFF  01,70E
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07E12:  MOVLB  7
07E14:  CLRF   x45
07E16:  MOVFF  698,744
07E1A:  CLRF   x47
07E1C:  MOVLW  B5
07E1E:  MOVWF  x46
07E20:  MOVLB  0
07E22:  CALL   0864
07E26:  MOVFF  02,715
07E2A:  MOVFF  01,714
07E2E:  MOVLW  06
07E30:  MOVLB  7
07E32:  ADDWF  x14,F
07E34:  MOVLW  00
07E36:  ADDWFC x15,F
07E38:  MOVLW  4B
07E3A:  ADDWF  x14,W
07E3C:  MOVWF  01
07E3E:  MOVLW  00
07E40:  ADDWFC x15,W
07E42:  MOVWF  03
07E44:  MOVF   01,W
07E46:  ADDLW  EB
07E48:  MOVWF  01
07E4A:  MOVLW  01
07E4C:  ADDWFC 03,F
07E4E:  MOVFF  01,714
07E52:  MOVFF  03,715
07E56:  MOVFF  03,745
07E5A:  MOVFF  01,744
07E5E:  MOVLB  0
07E60:  CALL   55AE
07E64:  MOVFF  02,03
07E68:  MOVF   01,W
07E6A:  SUBLW  01
07E6C:  BNZ   7E72
07E6E:  MOVF   03,F
07E70:  BZ    7E7A
07E72:  MOVLW  02
07E74:  MOVWF  01
07E76:  BRA    80EC
07E78:  BRA    7EBA
....................    else arg2 = SERcmd[rec].p[3][0];
07E7A:  MOVLB  7
07E7C:  CLRF   x45
07E7E:  MOVFF  698,744
07E82:  CLRF   x47
07E84:  MOVLW  B5
07E86:  MOVWF  x46
07E88:  MOVLB  0
07E8A:  CALL   0864
07E8E:  MOVFF  02,715
07E92:  MOVFF  01,714
07E96:  MOVLW  06
07E98:  MOVLB  7
07E9A:  ADDWF  x14,F
07E9C:  MOVLW  00
07E9E:  ADDWFC x15,F
07EA0:  MOVLW  4B
07EA2:  ADDWF  x14,F
07EA4:  MOVLW  00
07EA6:  ADDWFC x15,F
07EA8:  MOVLW  EB
07EAA:  ADDWF  x14,W
07EAC:  MOVWF  FE9
07EAE:  MOVLW  01
07EB0:  ADDWFC x15,W
07EB2:  MOVWF  FEA
07EB4:  MOVFF  FEF,70F
07EB8:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07EBA:  MOVLB  7
07EBC:  CLRF   x45
07EBE:  MOVFF  698,744
07EC2:  CLRF   x47
07EC4:  MOVLW  B5
07EC6:  MOVWF  x46
07EC8:  MOVLB  0
07ECA:  CALL   0864
07ECE:  MOVFF  02,715
07ED2:  MOVFF  01,714
07ED6:  MOVLW  06
07ED8:  MOVLB  7
07EDA:  ADDWF  x14,F
07EDC:  MOVLW  00
07EDE:  ADDWFC x15,F
07EE0:  MOVLW  64
07EE2:  ADDWF  x14,W
07EE4:  MOVWF  01
07EE6:  MOVLW  00
07EE8:  ADDWFC x15,W
07EEA:  MOVWF  03
07EEC:  MOVF   01,W
07EEE:  ADDLW  EB
07EF0:  MOVWF  01
07EF2:  MOVLW  01
07EF4:  ADDWFC 03,F
07EF6:  MOVFF  01,714
07EFA:  MOVFF  03,715
07EFE:  MOVFF  03,718
07F02:  MOVFF  01,717
07F06:  MOVLB  0
07F08:  CALL   6B28
07F0C:  MOVF   01,F
07F0E:  BNZ   7F18
07F10:  MOVLW  02
07F12:  MOVWF  01
07F14:  BRA    80EC
07F16:  BRA    7F7E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07F18:  MOVLB  7
07F1A:  CLRF   x45
07F1C:  MOVFF  698,744
07F20:  CLRF   x47
07F22:  MOVLW  B5
07F24:  MOVWF  x46
07F26:  MOVLB  0
07F28:  CALL   0864
07F2C:  MOVFF  02,715
07F30:  MOVFF  01,714
07F34:  MOVLW  06
07F36:  MOVLB  7
07F38:  ADDWF  x14,F
07F3A:  MOVLW  00
07F3C:  ADDWFC x15,F
07F3E:  MOVLW  64
07F40:  ADDWF  x14,W
07F42:  MOVWF  01
07F44:  MOVLW  00
07F46:  ADDWFC x15,W
07F48:  MOVWF  03
07F4A:  MOVF   01,W
07F4C:  ADDLW  EB
07F4E:  MOVWF  01
07F50:  MOVLW  01
07F52:  ADDWFC 03,F
07F54:  MOVFF  01,714
07F58:  MOVFF  03,715
07F5C:  MOVFF  03,718
07F60:  MOVFF  01,717
07F64:  CLRF   x1A
07F66:  CLRF   x19
07F68:  MOVLB  0
07F6A:  CALL   6BEA
07F6E:  MOVFF  03,713
07F72:  MOVFF  02,712
07F76:  MOVFF  01,711
07F7A:  MOVFF  00,710
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
07F7E:  MOVLB  7
07F80:  MOVF   x0F,W
07F82:  SUBLW  30
07F84:  BNZ   7FB0
07F86:  MOVLW  01
07F88:  SUBWF  x0E,W
07F8A:  MULLW  18
07F8C:  MOVF   FF3,W
07F8E:  CLRF   x15
07F90:  MOVWF  x14
07F92:  MOVLW  92
07F94:  ADDWF  x14,W
07F96:  MOVWF  FE9
07F98:  MOVLW  00
07F9A:  ADDWFC x15,W
07F9C:  MOVWF  FEA
07F9E:  MOVFF  710,FEF
07FA2:  MOVFF  711,FEC
07FA6:  MOVFF  712,FEC
07FAA:  MOVFF  713,FEC
07FAE:  BRA    80E6
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
07FB0:  MOVF   x0F,W
07FB2:  SUBLW  31
07FB4:  BNZ   7FEC
07FB6:  MOVLW  01
07FB8:  SUBWF  x0E,W
07FBA:  MULLW  18
07FBC:  MOVF   FF3,W
07FBE:  CLRF   x15
07FC0:  MOVWF  x14
07FC2:  MOVLW  04
07FC4:  ADDWF  x14,W
07FC6:  MOVWF  01
07FC8:  MOVLW  00
07FCA:  ADDWFC x15,W
07FCC:  MOVWF  03
07FCE:  MOVF   01,W
07FD0:  ADDLW  92
07FD2:  MOVWF  FE9
07FD4:  MOVLW  00
07FD6:  ADDWFC 03,W
07FD8:  MOVWF  FEA
07FDA:  MOVFF  710,FEF
07FDE:  MOVFF  711,FEC
07FE2:  MOVFF  712,FEC
07FE6:  MOVFF  713,FEC
07FEA:  BRA    80E6
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
07FEC:  MOVF   x0F,W
07FEE:  SUBLW  32
07FF0:  BNZ   8028
07FF2:  MOVLW  01
07FF4:  SUBWF  x0E,W
07FF6:  MULLW  18
07FF8:  MOVF   FF3,W
07FFA:  CLRF   x15
07FFC:  MOVWF  x14
07FFE:  MOVLW  08
08000:  ADDWF  x14,W
08002:  MOVWF  01
08004:  MOVLW  00
08006:  ADDWFC x15,W
08008:  MOVWF  03
0800A:  MOVF   01,W
0800C:  ADDLW  92
0800E:  MOVWF  FE9
08010:  MOVLW  00
08012:  ADDWFC 03,W
08014:  MOVWF  FEA
08016:  MOVFF  710,FEF
0801A:  MOVFF  711,FEC
0801E:  MOVFF  712,FEC
08022:  MOVFF  713,FEC
08026:  BRA    80E6
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08028:  MOVF   x0F,W
0802A:  SUBLW  33
0802C:  BNZ   8064
0802E:  MOVLW  01
08030:  SUBWF  x0E,W
08032:  MULLW  18
08034:  MOVF   FF3,W
08036:  CLRF   x15
08038:  MOVWF  x14
0803A:  MOVLW  0C
0803C:  ADDWF  x14,W
0803E:  MOVWF  01
08040:  MOVLW  00
08042:  ADDWFC x15,W
08044:  MOVWF  03
08046:  MOVF   01,W
08048:  ADDLW  92
0804A:  MOVWF  FE9
0804C:  MOVLW  00
0804E:  ADDWFC 03,W
08050:  MOVWF  FEA
08052:  MOVFF  710,FEF
08056:  MOVFF  711,FEC
0805A:  MOVFF  712,FEC
0805E:  MOVFF  713,FEC
08062:  BRA    80E6
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08064:  MOVF   x0F,W
08066:  SUBLW  34
08068:  BNZ   80A0
0806A:  MOVLW  01
0806C:  SUBWF  x0E,W
0806E:  MULLW  18
08070:  MOVF   FF3,W
08072:  CLRF   x15
08074:  MOVWF  x14
08076:  MOVLW  10
08078:  ADDWF  x14,W
0807A:  MOVWF  01
0807C:  MOVLW  00
0807E:  ADDWFC x15,W
08080:  MOVWF  03
08082:  MOVF   01,W
08084:  ADDLW  92
08086:  MOVWF  FE9
08088:  MOVLW  00
0808A:  ADDWFC 03,W
0808C:  MOVWF  FEA
0808E:  MOVFF  710,FEF
08092:  MOVFF  711,FEC
08096:  MOVFF  712,FEC
0809A:  MOVFF  713,FEC
0809E:  BRA    80E6
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
080A0:  MOVF   x0F,W
080A2:  SUBLW  35
080A4:  BNZ   80DC
080A6:  MOVLW  01
080A8:  SUBWF  x0E,W
080AA:  MULLW  18
080AC:  MOVF   FF3,W
080AE:  CLRF   x15
080B0:  MOVWF  x14
080B2:  MOVLW  14
080B4:  ADDWF  x14,W
080B6:  MOVWF  01
080B8:  MOVLW  00
080BA:  ADDWFC x15,W
080BC:  MOVWF  03
080BE:  MOVF   01,W
080C0:  ADDLW  92
080C2:  MOVWF  FE9
080C4:  MOVLW  00
080C6:  ADDWFC 03,W
080C8:  MOVWF  FEA
080CA:  MOVFF  710,FEF
080CE:  MOVFF  711,FEC
080D2:  MOVFF  712,FEC
080D6:  MOVFF  713,FEC
080DA:  BRA    80E6
....................    else return INV_PARAM;
080DC:  MOVLW  02
080DE:  MOVWF  01
080E0:  MOVLB  0
080E2:  BRA    80EC
080E4:  MOVLB  7
....................    
....................    return SUCCESS;
080E6:  MOVLW  00
080E8:  MOVWF  01
080EA:  MOVLB  0
080EC:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
080EE:  MOVLW  4E
080F0:  MOVLB  7
080F2:  MOVWF  x12
080F4:  MOVLW  31
080F6:  MOVWF  x13
080F8:  MOVLW  35
080FA:  MOVWF  x14
080FC:  CLRF   x15
080FE:  MOVLW  07
08100:  MOVWF  x11
08102:  MOVLW  12
08104:  MOVWF  x10
....................    char *s_200 = "200";
08106:  MOVLW  32
08108:  MOVWF  x18
0810A:  MOVLW  30
0810C:  MOVWF  x19
0810E:  MOVWF  x1A
08110:  CLRF   x1B
08112:  MOVLW  07
08114:  MOVWF  x17
08116:  MOVLW  18
08118:  MOVWF  x16
....................    char *s_5V6 = "5V6";
0811A:  MOVLW  35
0811C:  MOVWF  x1E
0811E:  MOVLW  56
08120:  MOVWF  x1F
08122:  MOVLW  36
08124:  MOVWF  x20
08126:  CLRF   x21
08128:  MOVLW  07
0812A:  MOVWF  x1D
0812C:  MOVLW  1E
0812E:  MOVWF  x1C
....................    char *s_5VA = "5VA";
08130:  MOVLW  35
08132:  MOVWF  x24
08134:  MOVLW  56
08136:  MOVWF  x25
08138:  MOVLW  41
0813A:  MOVWF  x26
0813C:  CLRF   x27
0813E:  MOVLW  07
08140:  MOVWF  x23
08142:  MOVLW  24
08144:  MOVWF  x22
....................    char *s_3V6X = "3V6X";
08146:  MOVLW  33
08148:  MOVWF  x2A
0814A:  MOVLW  56
0814C:  MOVWF  x2B
0814E:  MOVLW  36
08150:  MOVWF  x2C
08152:  MOVLW  58
08154:  MOVWF  x2D
08156:  CLRF   x2E
08158:  MOVLW  07
0815A:  MOVWF  x29
0815C:  MOVLW  2A
0815E:  MOVWF  x28
....................    char *s_3V3A = "3V3A";
08160:  MOVLW  33
08162:  MOVWF  x31
08164:  MOVLW  56
08166:  MOVWF  x32
08168:  MOVLW  33
0816A:  MOVWF  x33
0816C:  MOVLW  41
0816E:  MOVWF  x34
08170:  CLRF   x35
08172:  MOVLW  07
08174:  MOVWF  x30
08176:  MOVLW  31
08178:  MOVWF  x2F
....................    char *s_3V3D = "3V3D";
0817A:  MOVLW  33
0817C:  MOVWF  x38
0817E:  MOVLW  56
08180:  MOVWF  x39
08182:  MOVLW  33
08184:  MOVWF  x3A
08186:  MOVLW  44
08188:  MOVWF  x3B
0818A:  CLRF   x3C
0818C:  MOVLW  07
0818E:  MOVWF  x37
08190:  MOVLW  38
08192:  MOVWF  x36
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08194:  CLRF   x45
08196:  MOVFF  698,744
0819A:  CLRF   x47
0819C:  MOVLW  B5
0819E:  MOVWF  x46
081A0:  MOVLB  0
081A2:  CALL   0864
081A6:  MOVFF  02,73E
081AA:  MOVFF  01,73D
081AE:  MOVLW  06
081B0:  MOVLB  7
081B2:  ADDWF  x3D,F
081B4:  MOVLW  00
081B6:  ADDWFC x3E,F
081B8:  MOVLW  32
081BA:  ADDWF  x3D,W
081BC:  MOVWF  01
081BE:  MOVLW  00
081C0:  ADDWFC x3E,W
081C2:  MOVWF  03
081C4:  MOVF   01,W
081C6:  ADDLW  EB
081C8:  MOVWF  01
081CA:  MOVLW  01
081CC:  ADDWFC 03,F
081CE:  MOVFF  01,70E
081D2:  MOVFF  03,70F
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
081D6:  MOVFF  711,745
081DA:  MOVFF  710,744
081DE:  MOVFF  70F,747
081E2:  MOVFF  70E,746
081E6:  MOVLB  0
081E8:  CALL   5664
081EC:  MOVF   01,F
081EE:  BNZ   8272
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
081F0:  MOVLW  04
081F2:  MOVLB  7
081F4:  MOVWF  x45
081F6:  MOVLW  C1
081F8:  MOVWF  x44
081FA:  MOVLB  0
081FC:  CALL   55AE
08200:  MOVFF  02,03
08204:  MOVF   01,W
08206:  ADDLW  C1
08208:  MOVLB  7
0820A:  MOVWF  x3D
0820C:  MOVLW  04
0820E:  ADDWFC 02,W
08210:  MOVWF  x3E
08212:  MOVFF  FE8,565
08216:  MOVFF  73D,564
0821A:  MOVLW  89
0821C:  MOVWF  FE9
0821E:  MOVFF  C5,749
08222:  MOVFF  C4,748
08226:  MOVFF  C3,747
0822A:  MOVFF  C2,746
0822E:  MOVLW  02
08230:  MOVWF  x4A
08232:  MOVLB  0
08234:  CALL   64C2
08238:  MOVLW  2C
0823A:  MOVLB  7
0823C:  MOVWF  x53
0823E:  MOVLB  0
08240:  CALL   55E6
08244:  MOVLW  89
08246:  MOVWF  FE9
08248:  MOVFF  C9,749
0824C:  MOVFF  C8,748
08250:  MOVFF  C7,747
08254:  MOVFF  C6,746
08258:  MOVLW  02
0825A:  MOVLB  7
0825C:  MOVWF  x4A
0825E:  MOVLB  0
08260:  CALL   64C2
08264:  MOVLW  2C
08266:  MOVLB  7
08268:  MOVWF  x53
0826A:  MOVLB  0
0826C:  CALL   55E6
....................    }
08270:  BRA    8614
....................    else if (0 == strcmp(s_200, arg1)) {
08272:  MOVFF  717,745
08276:  MOVFF  716,744
0827A:  MOVFF  70F,747
0827E:  MOVFF  70E,746
08282:  CALL   5664
08286:  MOVF   01,F
08288:  BNZ   830C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
0828A:  MOVLW  04
0828C:  MOVLB  7
0828E:  MOVWF  x45
08290:  MOVLW  C1
08292:  MOVWF  x44
08294:  MOVLB  0
08296:  CALL   55AE
0829A:  MOVFF  02,03
0829E:  MOVF   01,W
082A0:  ADDLW  C1
082A2:  MOVLB  7
082A4:  MOVWF  x3D
082A6:  MOVLW  04
082A8:  ADDWFC 02,W
082AA:  MOVWF  x3E
082AC:  MOVFF  FE8,565
082B0:  MOVFF  73D,564
082B4:  MOVLW  89
082B6:  MOVWF  FE9
082B8:  MOVFF  CD,749
082BC:  MOVFF  CC,748
082C0:  MOVFF  CB,747
082C4:  MOVFF  CA,746
082C8:  MOVLW  02
082CA:  MOVWF  x4A
082CC:  MOVLB  0
082CE:  CALL   64C2
082D2:  MOVLW  2C
082D4:  MOVLB  7
082D6:  MOVWF  x53
082D8:  MOVLB  0
082DA:  CALL   55E6
082DE:  MOVLW  89
082E0:  MOVWF  FE9
082E2:  MOVFF  D1,749
082E6:  MOVFF  D0,748
082EA:  MOVFF  CF,747
082EE:  MOVFF  CE,746
082F2:  MOVLW  02
082F4:  MOVLB  7
082F6:  MOVWF  x4A
082F8:  MOVLB  0
082FA:  CALL   64C2
082FE:  MOVLW  2C
08300:  MOVLB  7
08302:  MOVWF  x53
08304:  MOVLB  0
08306:  CALL   55E6
....................    }
0830A:  BRA    8614
....................    else if (0 == strcmp(s_5V6, arg1)) {
0830C:  MOVFF  71D,745
08310:  MOVFF  71C,744
08314:  MOVFF  70F,747
08318:  MOVFF  70E,746
0831C:  CALL   5664
08320:  MOVF   01,F
08322:  BNZ   83A6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08324:  MOVLW  04
08326:  MOVLB  7
08328:  MOVWF  x45
0832A:  MOVLW  C1
0832C:  MOVWF  x44
0832E:  MOVLB  0
08330:  CALL   55AE
08334:  MOVFF  02,03
08338:  MOVF   01,W
0833A:  ADDLW  C1
0833C:  MOVLB  7
0833E:  MOVWF  x3D
08340:  MOVLW  04
08342:  ADDWFC 02,W
08344:  MOVWF  x3E
08346:  MOVFF  FE8,565
0834A:  MOVFF  73D,564
0834E:  MOVLW  89
08350:  MOVWF  FE9
08352:  MOVFF  D5,749
08356:  MOVFF  D4,748
0835A:  MOVFF  D3,747
0835E:  MOVFF  D2,746
08362:  MOVLW  02
08364:  MOVWF  x4A
08366:  MOVLB  0
08368:  CALL   64C2
0836C:  MOVLW  2C
0836E:  MOVLB  7
08370:  MOVWF  x53
08372:  MOVLB  0
08374:  CALL   55E6
08378:  MOVLW  89
0837A:  MOVWF  FE9
0837C:  MOVFF  D9,749
08380:  MOVFF  D8,748
08384:  MOVFF  D7,747
08388:  MOVFF  D6,746
0838C:  MOVLW  02
0838E:  MOVLB  7
08390:  MOVWF  x4A
08392:  MOVLB  0
08394:  CALL   64C2
08398:  MOVLW  2C
0839A:  MOVLB  7
0839C:  MOVWF  x53
0839E:  MOVLB  0
083A0:  CALL   55E6
....................    }
083A4:  BRA    8614
....................    else if (0 == strcmp(s_5VA, arg1)) {
083A6:  MOVFF  723,745
083AA:  MOVFF  722,744
083AE:  MOVFF  70F,747
083B2:  MOVFF  70E,746
083B6:  CALL   5664
083BA:  MOVF   01,F
083BC:  BNZ   8440
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
083BE:  MOVLW  04
083C0:  MOVLB  7
083C2:  MOVWF  x45
083C4:  MOVLW  C1
083C6:  MOVWF  x44
083C8:  MOVLB  0
083CA:  CALL   55AE
083CE:  MOVFF  02,03
083D2:  MOVF   01,W
083D4:  ADDLW  C1
083D6:  MOVLB  7
083D8:  MOVWF  x3D
083DA:  MOVLW  04
083DC:  ADDWFC 02,W
083DE:  MOVWF  x3E
083E0:  MOVFF  FE8,565
083E4:  MOVFF  73D,564
083E8:  MOVLW  89
083EA:  MOVWF  FE9
083EC:  MOVFF  DD,749
083F0:  MOVFF  DC,748
083F4:  MOVFF  DB,747
083F8:  MOVFF  DA,746
083FC:  MOVLW  02
083FE:  MOVWF  x4A
08400:  MOVLB  0
08402:  CALL   64C2
08406:  MOVLW  2C
08408:  MOVLB  7
0840A:  MOVWF  x53
0840C:  MOVLB  0
0840E:  CALL   55E6
08412:  MOVLW  89
08414:  MOVWF  FE9
08416:  MOVFF  E1,749
0841A:  MOVFF  E0,748
0841E:  MOVFF  DF,747
08422:  MOVFF  DE,746
08426:  MOVLW  02
08428:  MOVLB  7
0842A:  MOVWF  x4A
0842C:  MOVLB  0
0842E:  CALL   64C2
08432:  MOVLW  2C
08434:  MOVLB  7
08436:  MOVWF  x53
08438:  MOVLB  0
0843A:  CALL   55E6
....................    }
0843E:  BRA    8614
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08440:  MOVFF  729,745
08444:  MOVFF  728,744
08448:  MOVFF  70F,747
0844C:  MOVFF  70E,746
08450:  CALL   5664
08454:  MOVF   01,F
08456:  BNZ   84DA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08458:  MOVLW  04
0845A:  MOVLB  7
0845C:  MOVWF  x45
0845E:  MOVLW  C1
08460:  MOVWF  x44
08462:  MOVLB  0
08464:  CALL   55AE
08468:  MOVFF  02,03
0846C:  MOVF   01,W
0846E:  ADDLW  C1
08470:  MOVLB  7
08472:  MOVWF  x3D
08474:  MOVLW  04
08476:  ADDWFC 02,W
08478:  MOVWF  x3E
0847A:  MOVFF  FE8,565
0847E:  MOVFF  73D,564
08482:  MOVLW  89
08484:  MOVWF  FE9
08486:  MOVFF  E5,749
0848A:  MOVFF  E4,748
0848E:  MOVFF  E3,747
08492:  MOVFF  E2,746
08496:  MOVLW  02
08498:  MOVWF  x4A
0849A:  MOVLB  0
0849C:  CALL   64C2
084A0:  MOVLW  2C
084A2:  MOVLB  7
084A4:  MOVWF  x53
084A6:  MOVLB  0
084A8:  CALL   55E6
084AC:  MOVLW  89
084AE:  MOVWF  FE9
084B0:  MOVFF  E9,749
084B4:  MOVFF  E8,748
084B8:  MOVFF  E7,747
084BC:  MOVFF  E6,746
084C0:  MOVLW  02
084C2:  MOVLB  7
084C4:  MOVWF  x4A
084C6:  MOVLB  0
084C8:  CALL   64C2
084CC:  MOVLW  2C
084CE:  MOVLB  7
084D0:  MOVWF  x53
084D2:  MOVLB  0
084D4:  CALL   55E6
....................    }
084D8:  BRA    8614
....................    else if (0 == strcmp(s_3V3A, arg1)) {
084DA:  MOVFF  730,745
084DE:  MOVFF  72F,744
084E2:  MOVFF  70F,747
084E6:  MOVFF  70E,746
084EA:  CALL   5664
084EE:  MOVF   01,F
084F0:  BNZ   8574
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
084F2:  MOVLW  04
084F4:  MOVLB  7
084F6:  MOVWF  x45
084F8:  MOVLW  C1
084FA:  MOVWF  x44
084FC:  MOVLB  0
084FE:  CALL   55AE
08502:  MOVFF  02,03
08506:  MOVF   01,W
08508:  ADDLW  C1
0850A:  MOVLB  7
0850C:  MOVWF  x3D
0850E:  MOVLW  04
08510:  ADDWFC 02,W
08512:  MOVWF  x3E
08514:  MOVFF  FE8,565
08518:  MOVFF  73D,564
0851C:  MOVLW  89
0851E:  MOVWF  FE9
08520:  MOVFF  ED,749
08524:  MOVFF  EC,748
08528:  MOVFF  EB,747
0852C:  MOVFF  EA,746
08530:  MOVLW  02
08532:  MOVWF  x4A
08534:  MOVLB  0
08536:  CALL   64C2
0853A:  MOVLW  2C
0853C:  MOVLB  7
0853E:  MOVWF  x53
08540:  MOVLB  0
08542:  CALL   55E6
08546:  MOVLW  89
08548:  MOVWF  FE9
0854A:  MOVFF  F1,749
0854E:  MOVFF  F0,748
08552:  MOVFF  EF,747
08556:  MOVFF  EE,746
0855A:  MOVLW  02
0855C:  MOVLB  7
0855E:  MOVWF  x4A
08560:  MOVLB  0
08562:  CALL   64C2
08566:  MOVLW  2C
08568:  MOVLB  7
0856A:  MOVWF  x53
0856C:  MOVLB  0
0856E:  CALL   55E6
....................    }
08572:  BRA    8614
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08574:  MOVFF  737,745
08578:  MOVFF  736,744
0857C:  MOVFF  70F,747
08580:  MOVFF  70E,746
08584:  CALL   5664
08588:  MOVF   01,F
0858A:  BNZ   860E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
0858C:  MOVLW  04
0858E:  MOVLB  7
08590:  MOVWF  x45
08592:  MOVLW  C1
08594:  MOVWF  x44
08596:  MOVLB  0
08598:  CALL   55AE
0859C:  MOVFF  02,03
085A0:  MOVF   01,W
085A2:  ADDLW  C1
085A4:  MOVLB  7
085A6:  MOVWF  x3D
085A8:  MOVLW  04
085AA:  ADDWFC 02,W
085AC:  MOVWF  x3E
085AE:  MOVFF  FE8,565
085B2:  MOVFF  73D,564
085B6:  MOVLW  89
085B8:  MOVWF  FE9
085BA:  MOVFF  F5,749
085BE:  MOVFF  F4,748
085C2:  MOVFF  F3,747
085C6:  MOVFF  F2,746
085CA:  MOVLW  02
085CC:  MOVWF  x4A
085CE:  MOVLB  0
085D0:  CALL   64C2
085D4:  MOVLW  2C
085D6:  MOVLB  7
085D8:  MOVWF  x53
085DA:  MOVLB  0
085DC:  CALL   55E6
085E0:  MOVLW  89
085E2:  MOVWF  FE9
085E4:  MOVFF  F9,749
085E8:  MOVFF  F8,748
085EC:  MOVFF  F7,747
085F0:  MOVFF  F6,746
085F4:  MOVLW  02
085F6:  MOVLB  7
085F8:  MOVWF  x4A
085FA:  MOVLB  0
085FC:  CALL   64C2
08600:  MOVLW  2C
08602:  MOVLB  7
08604:  MOVWF  x53
08606:  MOVLB  0
08608:  CALL   55E6
....................    }
0860C:  BRA    8614
....................    else return INV_PARAM;
0860E:  MOVLW  02
08610:  MOVWF  01
08612:  BRA    8618
....................    
....................    return SUCCESS;
08614:  MOVLW  00
08616:  MOVWF  01
08618:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
0861A:  MOVLW  00
0861C:  MOVWF  01
0861E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08620:  MOVLW  4E
08622:  MOVLB  7
08624:  MOVWF  x12
08626:  MOVLW  31
08628:  MOVWF  x13
0862A:  MOVLW  35
0862C:  MOVWF  x14
0862E:  CLRF   x15
08630:  MOVLW  07
08632:  MOVWF  x11
08634:  MOVLW  12
08636:  MOVWF  x10
....................    char *s_200 = "200";
08638:  MOVLW  32
0863A:  MOVWF  x18
0863C:  MOVLW  30
0863E:  MOVWF  x19
08640:  MOVWF  x1A
08642:  CLRF   x1B
08644:  MOVLW  07
08646:  MOVWF  x17
08648:  MOVLW  18
0864A:  MOVWF  x16
....................    char *s_5V6 = "5V6";
0864C:  MOVLW  35
0864E:  MOVWF  x1E
08650:  MOVLW  56
08652:  MOVWF  x1F
08654:  MOVLW  36
08656:  MOVWF  x20
08658:  CLRF   x21
0865A:  MOVLW  07
0865C:  MOVWF  x1D
0865E:  MOVLW  1E
08660:  MOVWF  x1C
....................    char *s_5VA = "5VA";
08662:  MOVLW  35
08664:  MOVWF  x24
08666:  MOVLW  56
08668:  MOVWF  x25
0866A:  MOVLW  41
0866C:  MOVWF  x26
0866E:  CLRF   x27
08670:  MOVLW  07
08672:  MOVWF  x23
08674:  MOVLW  24
08676:  MOVWF  x22
....................    char *s_3V6X = "3V6X";
08678:  MOVLW  33
0867A:  MOVWF  x2A
0867C:  MOVLW  56
0867E:  MOVWF  x2B
08680:  MOVLW  36
08682:  MOVWF  x2C
08684:  MOVLW  58
08686:  MOVWF  x2D
08688:  CLRF   x2E
0868A:  MOVLW  07
0868C:  MOVWF  x29
0868E:  MOVLW  2A
08690:  MOVWF  x28
....................    char *s_3V3A = "3V3A";
08692:  MOVLW  33
08694:  MOVWF  x31
08696:  MOVLW  56
08698:  MOVWF  x32
0869A:  MOVLW  33
0869C:  MOVWF  x33
0869E:  MOVLW  41
086A0:  MOVWF  x34
086A2:  CLRF   x35
086A4:  MOVLW  07
086A6:  MOVWF  x30
086A8:  MOVLW  31
086AA:  MOVWF  x2F
....................    char *s_3V3D = "3V3D";
086AC:  MOVLW  33
086AE:  MOVWF  x38
086B0:  MOVLW  56
086B2:  MOVWF  x39
086B4:  MOVLW  33
086B6:  MOVWF  x3A
086B8:  MOVLW  44
086BA:  MOVWF  x3B
086BC:  CLRF   x3C
086BE:  MOVLW  07
086C0:  MOVWF  x37
086C2:  MOVLW  38
086C4:  MOVWF  x36
....................    char *s_all = "all";
086C6:  MOVLW  61
086C8:  MOVWF  x3F
086CA:  MOVLW  6C
086CC:  MOVWF  x40
086CE:  MOVWF  x41
086D0:  CLRF   x42
086D2:  MOVLW  07
086D4:  MOVWF  x3E
086D6:  MOVLW  3F
086D8:  MOVWF  x3D
....................    
....................    arg1 = SERcmd[rec].p[2];
086DA:  CLRF   x45
086DC:  MOVFF  698,744
086E0:  CLRF   x47
086E2:  MOVLW  B5
086E4:  MOVWF  x46
086E6:  MOVLB  0
086E8:  CALL   0864
086EC:  MOVFF  02,744
086F0:  MOVFF  01,743
086F4:  MOVLW  06
086F6:  MOVLB  7
086F8:  ADDWF  x43,F
086FA:  MOVLW  00
086FC:  ADDWFC x44,F
086FE:  MOVLW  32
08700:  ADDWF  x43,W
08702:  MOVWF  01
08704:  MOVLW  00
08706:  ADDWFC x44,W
08708:  MOVWF  03
0870A:  MOVF   01,W
0870C:  ADDLW  EB
0870E:  MOVWF  01
08710:  MOVLW  01
08712:  ADDWFC 03,F
08714:  MOVFF  01,70E
08718:  MOVFF  03,70F
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0871C:  MOVFF  711,745
08720:  MOVFF  710,744
08724:  MOVFF  70F,747
08728:  MOVFF  70E,746
0872C:  MOVLB  0
0872E:  CALL   5664
08732:  MOVF   01,F
08734:  BNZ   878C
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08736:  MOVLW  04
08738:  MOVLB  7
0873A:  MOVWF  x45
0873C:  MOVLW  C1
0873E:  MOVWF  x44
08740:  MOVLB  0
08742:  CALL   55AE
08746:  MOVFF  02,03
0874A:  MOVF   01,W
0874C:  ADDLW  C1
0874E:  MOVLB  7
08750:  MOVWF  x43
08752:  MOVLW  04
08754:  ADDWFC 02,W
08756:  MOVWF  x44
08758:  MOVFF  FE8,565
0875C:  MOVFF  743,564
08760:  MOVLW  89
08762:  MOVWF  FE9
08764:  MOVFF  FE,749
08768:  MOVFF  FD,748
0876C:  MOVFF  FC,747
08770:  MOVFF  FB,746
08774:  MOVLW  02
08776:  MOVWF  x4A
08778:  MOVLB  0
0877A:  CALL   64C2
0877E:  MOVLW  2C
08780:  MOVLB  7
08782:  MOVWF  x53
08784:  MOVLB  0
08786:  CALL   55E6
....................    }
0878A:  BRA    8C8E
....................    else if (0 == strcmp(s_200, arg1)) {
0878C:  MOVFF  717,745
08790:  MOVFF  716,744
08794:  MOVFF  70F,747
08798:  MOVFF  70E,746
0879C:  CALL   5664
087A0:  MOVF   01,F
087A2:  BNZ   87FA
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
087A4:  MOVLW  04
087A6:  MOVLB  7
087A8:  MOVWF  x45
087AA:  MOVLW  C1
087AC:  MOVWF  x44
087AE:  MOVLB  0
087B0:  CALL   55AE
087B4:  MOVFF  02,03
087B8:  MOVF   01,W
087BA:  ADDLW  C1
087BC:  MOVLB  7
087BE:  MOVWF  x43
087C0:  MOVLW  04
087C2:  ADDWFC 02,W
087C4:  MOVWF  x44
087C6:  MOVFF  FE8,565
087CA:  MOVFF  743,564
087CE:  MOVLW  89
087D0:  MOVWF  FE9
087D2:  MOVFF  102,749
087D6:  MOVFF  101,748
087DA:  MOVFF  100,747
087DE:  MOVFF  FF,746
087E2:  MOVLW  01
087E4:  MOVWF  x4A
087E6:  MOVLB  0
087E8:  CALL   64C2
087EC:  MOVLW  2C
087EE:  MOVLB  7
087F0:  MOVWF  x53
087F2:  MOVLB  0
087F4:  CALL   55E6
....................    }
087F8:  BRA    8C8E
....................    else if (0 == strcmp(s_5V6, arg1)) {
087FA:  MOVFF  71D,745
087FE:  MOVFF  71C,744
08802:  MOVFF  70F,747
08806:  MOVFF  70E,746
0880A:  CALL   5664
0880E:  MOVF   01,F
08810:  BNZ   8868
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08812:  MOVLW  04
08814:  MOVLB  7
08816:  MOVWF  x45
08818:  MOVLW  C1
0881A:  MOVWF  x44
0881C:  MOVLB  0
0881E:  CALL   55AE
08822:  MOVFF  02,03
08826:  MOVF   01,W
08828:  ADDLW  C1
0882A:  MOVLB  7
0882C:  MOVWF  x43
0882E:  MOVLW  04
08830:  ADDWFC 02,W
08832:  MOVWF  x44
08834:  MOVFF  FE8,565
08838:  MOVFF  743,564
0883C:  MOVLW  89
0883E:  MOVWF  FE9
08840:  MOVFF  106,749
08844:  MOVFF  105,748
08848:  MOVFF  104,747
0884C:  MOVFF  103,746
08850:  MOVLW  03
08852:  MOVWF  x4A
08854:  MOVLB  0
08856:  CALL   64C2
0885A:  MOVLW  2C
0885C:  MOVLB  7
0885E:  MOVWF  x53
08860:  MOVLB  0
08862:  CALL   55E6
....................    }
08866:  BRA    8C8E
....................    else if (0 == strcmp(s_5VA, arg1)) {
08868:  MOVFF  723,745
0886C:  MOVFF  722,744
08870:  MOVFF  70F,747
08874:  MOVFF  70E,746
08878:  CALL   5664
0887C:  MOVF   01,F
0887E:  BNZ   88D6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08880:  MOVLW  04
08882:  MOVLB  7
08884:  MOVWF  x45
08886:  MOVLW  C1
08888:  MOVWF  x44
0888A:  MOVLB  0
0888C:  CALL   55AE
08890:  MOVFF  02,03
08894:  MOVF   01,W
08896:  ADDLW  C1
08898:  MOVLB  7
0889A:  MOVWF  x43
0889C:  MOVLW  04
0889E:  ADDWFC 02,W
088A0:  MOVWF  x44
088A2:  MOVFF  FE8,565
088A6:  MOVFF  743,564
088AA:  MOVLW  89
088AC:  MOVWF  FE9
088AE:  MOVFF  10A,749
088B2:  MOVFF  109,748
088B6:  MOVFF  108,747
088BA:  MOVFF  107,746
088BE:  MOVLW  03
088C0:  MOVWF  x4A
088C2:  MOVLB  0
088C4:  CALL   64C2
088C8:  MOVLW  2C
088CA:  MOVLB  7
088CC:  MOVWF  x53
088CE:  MOVLB  0
088D0:  CALL   55E6
....................    }
088D4:  BRA    8C8E
....................    else if (0 == strcmp(s_3V6X, arg1)) {
088D6:  MOVFF  729,745
088DA:  MOVFF  728,744
088DE:  MOVFF  70F,747
088E2:  MOVFF  70E,746
088E6:  CALL   5664
088EA:  MOVF   01,F
088EC:  BNZ   8944
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
088EE:  MOVLW  04
088F0:  MOVLB  7
088F2:  MOVWF  x45
088F4:  MOVLW  C1
088F6:  MOVWF  x44
088F8:  MOVLB  0
088FA:  CALL   55AE
088FE:  MOVFF  02,03
08902:  MOVF   01,W
08904:  ADDLW  C1
08906:  MOVLB  7
08908:  MOVWF  x43
0890A:  MOVLW  04
0890C:  ADDWFC 02,W
0890E:  MOVWF  x44
08910:  MOVFF  FE8,565
08914:  MOVFF  743,564
08918:  MOVLW  89
0891A:  MOVWF  FE9
0891C:  MOVFF  10E,749
08920:  MOVFF  10D,748
08924:  MOVFF  10C,747
08928:  MOVFF  10B,746
0892C:  MOVLW  03
0892E:  MOVWF  x4A
08930:  MOVLB  0
08932:  CALL   64C2
08936:  MOVLW  2C
08938:  MOVLB  7
0893A:  MOVWF  x53
0893C:  MOVLB  0
0893E:  CALL   55E6
....................    }
08942:  BRA    8C8E
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08944:  MOVFF  730,745
08948:  MOVFF  72F,744
0894C:  MOVFF  70F,747
08950:  MOVFF  70E,746
08954:  CALL   5664
08958:  MOVF   01,F
0895A:  BNZ   89B2
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
0895C:  MOVLW  04
0895E:  MOVLB  7
08960:  MOVWF  x45
08962:  MOVLW  C1
08964:  MOVWF  x44
08966:  MOVLB  0
08968:  CALL   55AE
0896C:  MOVFF  02,03
08970:  MOVF   01,W
08972:  ADDLW  C1
08974:  MOVLB  7
08976:  MOVWF  x43
08978:  MOVLW  04
0897A:  ADDWFC 02,W
0897C:  MOVWF  x44
0897E:  MOVFF  FE8,565
08982:  MOVFF  743,564
08986:  MOVLW  89
08988:  MOVWF  FE9
0898A:  MOVFF  112,749
0898E:  MOVFF  111,748
08992:  MOVFF  110,747
08996:  MOVFF  10F,746
0899A:  MOVLW  03
0899C:  MOVWF  x4A
0899E:  MOVLB  0
089A0:  CALL   64C2
089A4:  MOVLW  2C
089A6:  MOVLB  7
089A8:  MOVWF  x53
089AA:  MOVLB  0
089AC:  CALL   55E6
....................    }
089B0:  BRA    8C8E
....................    else if (0 == strcmp(s_3V3D, arg1)) {
089B2:  MOVFF  737,745
089B6:  MOVFF  736,744
089BA:  MOVFF  70F,747
089BE:  MOVFF  70E,746
089C2:  CALL   5664
089C6:  MOVF   01,F
089C8:  BNZ   8A20
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
089CA:  MOVLW  04
089CC:  MOVLB  7
089CE:  MOVWF  x45
089D0:  MOVLW  C1
089D2:  MOVWF  x44
089D4:  MOVLB  0
089D6:  CALL   55AE
089DA:  MOVFF  02,03
089DE:  MOVF   01,W
089E0:  ADDLW  C1
089E2:  MOVLB  7
089E4:  MOVWF  x43
089E6:  MOVLW  04
089E8:  ADDWFC 02,W
089EA:  MOVWF  x44
089EC:  MOVFF  FE8,565
089F0:  MOVFF  743,564
089F4:  MOVLW  89
089F6:  MOVWF  FE9
089F8:  MOVFF  116,749
089FC:  MOVFF  115,748
08A00:  MOVFF  114,747
08A04:  MOVFF  113,746
08A08:  MOVLW  03
08A0A:  MOVWF  x4A
08A0C:  MOVLB  0
08A0E:  CALL   64C2
08A12:  MOVLW  2C
08A14:  MOVLB  7
08A16:  MOVWF  x53
08A18:  MOVLB  0
08A1A:  CALL   55E6
....................    }
08A1E:  BRA    8C8E
....................    else if (0 == strcmp(s_all, arg1)) {
08A20:  MOVFF  73E,745
08A24:  MOVFF  73D,744
08A28:  MOVFF  70F,747
08A2C:  MOVFF  70E,746
08A30:  CALL   5664
08A34:  MOVF   01,F
08A36:  BTFSS  FD8.2
08A38:  BRA    8C88
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08A3A:  MOVLW  04
08A3C:  MOVLB  7
08A3E:  MOVWF  x45
08A40:  MOVLW  C1
08A42:  MOVWF  x44
08A44:  MOVLB  0
08A46:  CALL   55AE
08A4A:  MOVFF  02,03
08A4E:  MOVF   01,W
08A50:  ADDLW  C1
08A52:  MOVLB  7
08A54:  MOVWF  x43
08A56:  MOVLW  04
08A58:  ADDWFC 02,W
08A5A:  MOVWF  x44
08A5C:  MOVFF  FE8,565
08A60:  MOVFF  743,564
08A64:  MOVLW  89
08A66:  MOVWF  FE9
08A68:  MOVFF  FE,749
08A6C:  MOVFF  FD,748
08A70:  MOVFF  FC,747
08A74:  MOVFF  FB,746
08A78:  MOVLW  02
08A7A:  MOVWF  x4A
08A7C:  MOVLB  0
08A7E:  CALL   64C2
08A82:  MOVLW  2C
08A84:  MOVLB  7
08A86:  MOVWF  x53
08A88:  MOVLB  0
08A8A:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08A8E:  MOVLW  04
08A90:  MOVLB  7
08A92:  MOVWF  x45
08A94:  MOVLW  C1
08A96:  MOVWF  x44
08A98:  MOVLB  0
08A9A:  CALL   55AE
08A9E:  MOVFF  02,03
08AA2:  MOVF   01,W
08AA4:  ADDLW  C1
08AA6:  MOVLB  7
08AA8:  MOVWF  x43
08AAA:  MOVLW  04
08AAC:  ADDWFC 02,W
08AAE:  MOVWF  x44
08AB0:  MOVFF  FE8,565
08AB4:  MOVFF  743,564
08AB8:  MOVLW  89
08ABA:  MOVWF  FE9
08ABC:  MOVFF  102,749
08AC0:  MOVFF  101,748
08AC4:  MOVFF  100,747
08AC8:  MOVFF  FF,746
08ACC:  MOVLW  01
08ACE:  MOVWF  x4A
08AD0:  MOVLB  0
08AD2:  CALL   64C2
08AD6:  MOVLW  2C
08AD8:  MOVLB  7
08ADA:  MOVWF  x53
08ADC:  MOVLB  0
08ADE:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08AE2:  MOVLW  04
08AE4:  MOVLB  7
08AE6:  MOVWF  x45
08AE8:  MOVLW  C1
08AEA:  MOVWF  x44
08AEC:  MOVLB  0
08AEE:  CALL   55AE
08AF2:  MOVFF  02,03
08AF6:  MOVF   01,W
08AF8:  ADDLW  C1
08AFA:  MOVLB  7
08AFC:  MOVWF  x43
08AFE:  MOVLW  04
08B00:  ADDWFC 02,W
08B02:  MOVWF  x44
08B04:  MOVFF  FE8,565
08B08:  MOVFF  743,564
08B0C:  MOVLW  89
08B0E:  MOVWF  FE9
08B10:  MOVFF  106,749
08B14:  MOVFF  105,748
08B18:  MOVFF  104,747
08B1C:  MOVFF  103,746
08B20:  MOVLW  03
08B22:  MOVWF  x4A
08B24:  MOVLB  0
08B26:  CALL   64C2
08B2A:  MOVLW  2C
08B2C:  MOVLB  7
08B2E:  MOVWF  x53
08B30:  MOVLB  0
08B32:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08B36:  MOVLW  04
08B38:  MOVLB  7
08B3A:  MOVWF  x45
08B3C:  MOVLW  C1
08B3E:  MOVWF  x44
08B40:  MOVLB  0
08B42:  CALL   55AE
08B46:  MOVFF  02,03
08B4A:  MOVF   01,W
08B4C:  ADDLW  C1
08B4E:  MOVLB  7
08B50:  MOVWF  x43
08B52:  MOVLW  04
08B54:  ADDWFC 02,W
08B56:  MOVWF  x44
08B58:  MOVFF  FE8,565
08B5C:  MOVFF  743,564
08B60:  MOVLW  89
08B62:  MOVWF  FE9
08B64:  MOVFF  10A,749
08B68:  MOVFF  109,748
08B6C:  MOVFF  108,747
08B70:  MOVFF  107,746
08B74:  MOVLW  03
08B76:  MOVWF  x4A
08B78:  MOVLB  0
08B7A:  CALL   64C2
08B7E:  MOVLW  2C
08B80:  MOVLB  7
08B82:  MOVWF  x53
08B84:  MOVLB  0
08B86:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08B8A:  MOVLW  04
08B8C:  MOVLB  7
08B8E:  MOVWF  x45
08B90:  MOVLW  C1
08B92:  MOVWF  x44
08B94:  MOVLB  0
08B96:  CALL   55AE
08B9A:  MOVFF  02,03
08B9E:  MOVF   01,W
08BA0:  ADDLW  C1
08BA2:  MOVLB  7
08BA4:  MOVWF  x43
08BA6:  MOVLW  04
08BA8:  ADDWFC 02,W
08BAA:  MOVWF  x44
08BAC:  MOVFF  FE8,565
08BB0:  MOVFF  743,564
08BB4:  MOVLW  89
08BB6:  MOVWF  FE9
08BB8:  MOVFF  10E,749
08BBC:  MOVFF  10D,748
08BC0:  MOVFF  10C,747
08BC4:  MOVFF  10B,746
08BC8:  MOVLW  03
08BCA:  MOVWF  x4A
08BCC:  MOVLB  0
08BCE:  CALL   64C2
08BD2:  MOVLW  2C
08BD4:  MOVLB  7
08BD6:  MOVWF  x53
08BD8:  MOVLB  0
08BDA:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08BDE:  MOVLW  04
08BE0:  MOVLB  7
08BE2:  MOVWF  x45
08BE4:  MOVLW  C1
08BE6:  MOVWF  x44
08BE8:  MOVLB  0
08BEA:  CALL   55AE
08BEE:  MOVFF  02,03
08BF2:  MOVF   01,W
08BF4:  ADDLW  C1
08BF6:  MOVLB  7
08BF8:  MOVWF  x43
08BFA:  MOVLW  04
08BFC:  ADDWFC 02,W
08BFE:  MOVWF  x44
08C00:  MOVFF  FE8,565
08C04:  MOVFF  743,564
08C08:  MOVLW  89
08C0A:  MOVWF  FE9
08C0C:  MOVFF  112,749
08C10:  MOVFF  111,748
08C14:  MOVFF  110,747
08C18:  MOVFF  10F,746
08C1C:  MOVLW  03
08C1E:  MOVWF  x4A
08C20:  MOVLB  0
08C22:  CALL   64C2
08C26:  MOVLW  2C
08C28:  MOVLB  7
08C2A:  MOVWF  x53
08C2C:  MOVLB  0
08C2E:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08C32:  MOVLW  04
08C34:  MOVLB  7
08C36:  MOVWF  x45
08C38:  MOVLW  C1
08C3A:  MOVWF  x44
08C3C:  MOVLB  0
08C3E:  CALL   55AE
08C42:  MOVFF  02,03
08C46:  MOVF   01,W
08C48:  ADDLW  C1
08C4A:  MOVLB  7
08C4C:  MOVWF  x43
08C4E:  MOVLW  04
08C50:  ADDWFC 02,W
08C52:  MOVWF  x44
08C54:  MOVFF  FE8,565
08C58:  MOVFF  743,564
08C5C:  MOVLW  89
08C5E:  MOVWF  FE9
08C60:  MOVFF  116,749
08C64:  MOVFF  115,748
08C68:  MOVFF  114,747
08C6C:  MOVFF  113,746
08C70:  MOVLW  03
08C72:  MOVWF  x4A
08C74:  MOVLB  0
08C76:  CALL   64C2
08C7A:  MOVLW  2C
08C7C:  MOVLB  7
08C7E:  MOVWF  x53
08C80:  MOVLB  0
08C82:  CALL   55E6
....................    }
08C86:  BRA    8C8E
....................    else return INV_PARAM;
08C88:  MOVLW  02
08C8A:  MOVWF  01
08C8C:  BRA    8C92
....................    
....................    return SUCCESS;
08C8E:  MOVLW  00
08C90:  MOVWF  01
08C92:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08C94:  MOVLW  50
08C96:  MOVLB  7
08C98:  MOVWF  x13
08C9A:  MOVLW  56
08C9C:  MOVWF  x14
08C9E:  CLRF   x15
08CA0:  MOVLW  07
08CA2:  MOVWF  x12
08CA4:  MOVLW  13
08CA6:  MOVWF  x11
....................    char *s_CV = "CV";
08CA8:  MOVLW  43
08CAA:  MOVWF  x18
08CAC:  MOVLW  56
08CAE:  MOVWF  x19
08CB0:  CLRF   x1A
08CB2:  MOVLW  07
08CB4:  MOVWF  x17
08CB6:  MOVLW  18
08CB8:  MOVWF  x16
....................    char *s_PVold = "PVold";
08CBA:  MOVLW  50
08CBC:  MOVWF  x1D
08CBE:  MOVLW  56
08CC0:  MOVWF  x1E
08CC2:  MOVLW  6F
08CC4:  MOVWF  x1F
08CC6:  MOVLW  6C
08CC8:  MOVWF  x20
08CCA:  MOVLW  64
08CCC:  MOVWF  x21
08CCE:  CLRF   x22
08CD0:  MOVLW  07
08CD2:  MOVWF  x1C
08CD4:  MOVLW  1D
08CD6:  MOVWF  x1B
....................    char *s_I = "I";
08CD8:  MOVLW  49
08CDA:  MOVWF  x25
08CDC:  CLRF   x26
08CDE:  MOVLW  07
08CE0:  MOVWF  x24
08CE2:  MOVLW  25
08CE4:  MOVWF  x23
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08CE6:  CLRF   x45
08CE8:  MOVFF  698,744
08CEC:  CLRF   x47
08CEE:  MOVLW  B5
08CF0:  MOVWF  x46
08CF2:  MOVLB  0
08CF4:  CALL   0864
08CF8:  MOVFF  02,728
08CFC:  MOVFF  01,727
08D00:  MOVLW  06
08D02:  MOVLB  7
08D04:  ADDWF  x27,F
08D06:  MOVLW  00
08D08:  ADDWFC x28,F
08D0A:  MOVLW  32
08D0C:  ADDWF  x27,W
08D0E:  MOVWF  01
08D10:  MOVLW  00
08D12:  ADDWFC x28,W
08D14:  MOVWF  03
08D16:  MOVF   01,W
08D18:  ADDLW  EB
08D1A:  MOVWF  01
08D1C:  MOVLW  01
08D1E:  ADDWFC 03,F
08D20:  MOVFF  01,727
08D24:  MOVFF  03,728
08D28:  MOVFF  03,737
08D2C:  MOVFF  01,736
08D30:  MOVLB  0
08D32:  CALL   5784
08D36:  MOVF   01,F
08D38:  BNZ   8D42
08D3A:  MOVLW  02
08D3C:  MOVWF  01
08D3E:  BRA    90D8
08D40:  BRA    8DA0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08D42:  MOVLB  7
08D44:  CLRF   x45
08D46:  MOVFF  698,744
08D4A:  CLRF   x47
08D4C:  MOVLW  B5
08D4E:  MOVWF  x46
08D50:  MOVLB  0
08D52:  CALL   0864
08D56:  MOVFF  02,728
08D5A:  MOVFF  01,727
08D5E:  MOVLW  06
08D60:  MOVLB  7
08D62:  ADDWF  x27,F
08D64:  MOVLW  00
08D66:  ADDWFC x28,F
08D68:  MOVLW  32
08D6A:  ADDWF  x27,W
08D6C:  MOVWF  01
08D6E:  MOVLW  00
08D70:  ADDWFC x28,W
08D72:  MOVWF  03
08D74:  MOVF   01,W
08D76:  ADDLW  EB
08D78:  MOVWF  01
08D7A:  MOVLW  01
08D7C:  ADDWFC 03,F
08D7E:  MOVFF  01,727
08D82:  MOVFF  03,728
08D86:  MOVFF  03,737
08D8A:  MOVFF  01,736
08D8E:  CLRF   x39
08D90:  CLRF   x38
08D92:  MOVLW  0A
08D94:  MOVWF  x3A
08D96:  MOVLB  0
08D98:  CALL   5874
08D9C:  MOVFF  01,70E
....................    
....................    arg2 = SERcmd[rec].p[3];
08DA0:  MOVLB  7
08DA2:  CLRF   x45
08DA4:  MOVFF  698,744
08DA8:  CLRF   x47
08DAA:  MOVLW  B5
08DAC:  MOVWF  x46
08DAE:  MOVLB  0
08DB0:  CALL   0864
08DB4:  MOVFF  02,728
08DB8:  MOVFF  01,727
08DBC:  MOVLW  06
08DBE:  MOVLB  7
08DC0:  ADDWF  x27,F
08DC2:  MOVLW  00
08DC4:  ADDWFC x28,F
08DC6:  MOVLW  4B
08DC8:  ADDWF  x27,W
08DCA:  MOVWF  01
08DCC:  MOVLW  00
08DCE:  ADDWFC x28,W
08DD0:  MOVWF  03
08DD2:  MOVF   01,W
08DD4:  ADDLW  EB
08DD6:  MOVWF  01
08DD8:  MOVLW  01
08DDA:  ADDWFC 03,F
08DDC:  MOVFF  01,70F
08DE0:  MOVFF  03,710
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08DE4:  MOVFF  712,745
08DE8:  MOVFF  711,744
08DEC:  MOVFF  710,747
08DF0:  MOVFF  70F,746
08DF4:  MOVLB  0
08DF6:  CALL   5664
08DFA:  MOVF   01,F
08DFC:  BNZ   8EA0
08DFE:  MOVLW  04
08E00:  MOVLB  7
08E02:  MOVWF  x45
08E04:  MOVLW  C1
08E06:  MOVWF  x44
08E08:  MOVLB  0
08E0A:  CALL   55AE
08E0E:  MOVF   01,W
08E10:  ADDLW  C1
08E12:  MOVLB  7
08E14:  MOVWF  x27
08E16:  MOVLW  04
08E18:  ADDWFC 02,W
08E1A:  MOVWF  x28
08E1C:  MOVLW  01
08E1E:  SUBWF  x0E,W
08E20:  MULLW  28
08E22:  MOVF   FF3,W
08E24:  CLRF   x2A
08E26:  MOVWF  x29
08E28:  MOVLW  10
08E2A:  ADDWF  x29,W
08E2C:  MOVWF  01
08E2E:  MOVLW  00
08E30:  ADDWFC x2A,W
08E32:  MOVWF  03
08E34:  MOVF   01,W
08E36:  ADDLW  20
08E38:  MOVWF  FE9
08E3A:  MOVLW  00
08E3C:  ADDWFC 03,W
08E3E:  MOVWF  FEA
08E40:  MOVFF  FEF,729
08E44:  MOVFF  FEC,72A
08E48:  MOVFF  FEC,72B
08E4C:  MOVFF  FEC,72C
08E50:  MOVFF  728,565
08E54:  MOVFF  727,564
08E58:  MOVFF  70E,737
08E5C:  MOVLW  18
08E5E:  MOVWF  x38
08E60:  MOVLB  0
08E62:  CALL   5BC8
08E66:  MOVLW  2C
08E68:  MOVLB  7
08E6A:  MOVWF  x53
08E6C:  MOVLB  0
08E6E:  CALL   55E6
08E72:  MOVLW  89
08E74:  MOVWF  FE9
08E76:  MOVFF  72C,749
08E7A:  MOVFF  72B,748
08E7E:  MOVFF  72A,747
08E82:  MOVFF  729,746
08E86:  MOVLW  02
08E88:  MOVLB  7
08E8A:  MOVWF  x4A
08E8C:  MOVLB  0
08E8E:  CALL   64C2
08E92:  MOVLW  2C
08E94:  MOVLB  7
08E96:  MOVWF  x53
08E98:  MOVLB  0
08E9A:  CALL   55E6
08E9E:  BRA    90D4
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
08EA0:  MOVFF  717,745
08EA4:  MOVFF  716,744
08EA8:  MOVFF  710,747
08EAC:  MOVFF  70F,746
08EB0:  CALL   5664
08EB4:  MOVF   01,F
08EB6:  BNZ   8F5A
08EB8:  MOVLW  04
08EBA:  MOVLB  7
08EBC:  MOVWF  x45
08EBE:  MOVLW  C1
08EC0:  MOVWF  x44
08EC2:  MOVLB  0
08EC4:  CALL   55AE
08EC8:  MOVF   01,W
08ECA:  ADDLW  C1
08ECC:  MOVLB  7
08ECE:  MOVWF  x27
08ED0:  MOVLW  04
08ED2:  ADDWFC 02,W
08ED4:  MOVWF  x28
08ED6:  MOVLW  01
08ED8:  SUBWF  x0E,W
08EDA:  MULLW  28
08EDC:  MOVF   FF3,W
08EDE:  CLRF   x2A
08EE0:  MOVWF  x29
08EE2:  MOVLW  18
08EE4:  ADDWF  x29,W
08EE6:  MOVWF  01
08EE8:  MOVLW  00
08EEA:  ADDWFC x2A,W
08EEC:  MOVWF  03
08EEE:  MOVF   01,W
08EF0:  ADDLW  20
08EF2:  MOVWF  FE9
08EF4:  MOVLW  00
08EF6:  ADDWFC 03,W
08EF8:  MOVWF  FEA
08EFA:  MOVFF  FEF,729
08EFE:  MOVFF  FEC,72A
08F02:  MOVFF  FEC,72B
08F06:  MOVFF  FEC,72C
08F0A:  MOVFF  728,565
08F0E:  MOVFF  727,564
08F12:  MOVFF  70E,737
08F16:  MOVLW  18
08F18:  MOVWF  x38
08F1A:  MOVLB  0
08F1C:  CALL   5BC8
08F20:  MOVLW  2C
08F22:  MOVLB  7
08F24:  MOVWF  x53
08F26:  MOVLB  0
08F28:  CALL   55E6
08F2C:  MOVLW  89
08F2E:  MOVWF  FE9
08F30:  MOVFF  72C,749
08F34:  MOVFF  72B,748
08F38:  MOVFF  72A,747
08F3C:  MOVFF  729,746
08F40:  MOVLW  02
08F42:  MOVLB  7
08F44:  MOVWF  x4A
08F46:  MOVLB  0
08F48:  CALL   64C2
08F4C:  MOVLW  2C
08F4E:  MOVLB  7
08F50:  MOVWF  x53
08F52:  MOVLB  0
08F54:  CALL   55E6
08F58:  BRA    90D4
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
08F5A:  MOVFF  71C,745
08F5E:  MOVFF  71B,744
08F62:  MOVFF  710,747
08F66:  MOVFF  70F,746
08F6A:  CALL   5664
08F6E:  MOVF   01,F
08F70:  BNZ   9014
08F72:  MOVLW  04
08F74:  MOVLB  7
08F76:  MOVWF  x45
08F78:  MOVLW  C1
08F7A:  MOVWF  x44
08F7C:  MOVLB  0
08F7E:  CALL   55AE
08F82:  MOVF   01,W
08F84:  ADDLW  C1
08F86:  MOVLB  7
08F88:  MOVWF  x27
08F8A:  MOVLW  04
08F8C:  ADDWFC 02,W
08F8E:  MOVWF  x28
08F90:  MOVLW  01
08F92:  SUBWF  x0E,W
08F94:  MULLW  28
08F96:  MOVF   FF3,W
08F98:  CLRF   x2A
08F9A:  MOVWF  x29
08F9C:  MOVLW  14
08F9E:  ADDWF  x29,W
08FA0:  MOVWF  01
08FA2:  MOVLW  00
08FA4:  ADDWFC x2A,W
08FA6:  MOVWF  03
08FA8:  MOVF   01,W
08FAA:  ADDLW  20
08FAC:  MOVWF  FE9
08FAE:  MOVLW  00
08FB0:  ADDWFC 03,W
08FB2:  MOVWF  FEA
08FB4:  MOVFF  FEF,729
08FB8:  MOVFF  FEC,72A
08FBC:  MOVFF  FEC,72B
08FC0:  MOVFF  FEC,72C
08FC4:  MOVFF  728,565
08FC8:  MOVFF  727,564
08FCC:  MOVFF  70E,737
08FD0:  MOVLW  18
08FD2:  MOVWF  x38
08FD4:  MOVLB  0
08FD6:  CALL   5BC8
08FDA:  MOVLW  2C
08FDC:  MOVLB  7
08FDE:  MOVWF  x53
08FE0:  MOVLB  0
08FE2:  CALL   55E6
08FE6:  MOVLW  89
08FE8:  MOVWF  FE9
08FEA:  MOVFF  72C,749
08FEE:  MOVFF  72B,748
08FF2:  MOVFF  72A,747
08FF6:  MOVFF  729,746
08FFA:  MOVLW  02
08FFC:  MOVLB  7
08FFE:  MOVWF  x4A
09000:  MOVLB  0
09002:  CALL   64C2
09006:  MOVLW  2C
09008:  MOVLB  7
0900A:  MOVWF  x53
0900C:  MOVLB  0
0900E:  CALL   55E6
09012:  BRA    90D4
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09014:  MOVFF  724,745
09018:  MOVFF  723,744
0901C:  MOVFF  710,747
09020:  MOVFF  70F,746
09024:  CALL   5664
09028:  MOVF   01,F
0902A:  BNZ   90CE
0902C:  MOVLW  04
0902E:  MOVLB  7
09030:  MOVWF  x45
09032:  MOVLW  C1
09034:  MOVWF  x44
09036:  MOVLB  0
09038:  CALL   55AE
0903C:  MOVF   01,W
0903E:  ADDLW  C1
09040:  MOVLB  7
09042:  MOVWF  x27
09044:  MOVLW  04
09046:  ADDWFC 02,W
09048:  MOVWF  x28
0904A:  MOVLW  01
0904C:  SUBWF  x0E,W
0904E:  MULLW  28
09050:  MOVF   FF3,W
09052:  CLRF   x2A
09054:  MOVWF  x29
09056:  MOVLW  1C
09058:  ADDWF  x29,W
0905A:  MOVWF  01
0905C:  MOVLW  00
0905E:  ADDWFC x2A,W
09060:  MOVWF  03
09062:  MOVF   01,W
09064:  ADDLW  20
09066:  MOVWF  FE9
09068:  MOVLW  00
0906A:  ADDWFC 03,W
0906C:  MOVWF  FEA
0906E:  MOVFF  FEF,729
09072:  MOVFF  FEC,72A
09076:  MOVFF  FEC,72B
0907A:  MOVFF  FEC,72C
0907E:  MOVFF  728,565
09082:  MOVFF  727,564
09086:  MOVFF  70E,737
0908A:  MOVLW  18
0908C:  MOVWF  x38
0908E:  MOVLB  0
09090:  CALL   5BC8
09094:  MOVLW  2C
09096:  MOVLB  7
09098:  MOVWF  x53
0909A:  MOVLB  0
0909C:  CALL   55E6
090A0:  MOVLW  89
090A2:  MOVWF  FE9
090A4:  MOVFF  72C,749
090A8:  MOVFF  72B,748
090AC:  MOVFF  72A,747
090B0:  MOVFF  729,746
090B4:  MOVLW  02
090B6:  MOVLB  7
090B8:  MOVWF  x4A
090BA:  MOVLB  0
090BC:  CALL   64C2
090C0:  MOVLW  2C
090C2:  MOVLB  7
090C4:  MOVWF  x53
090C6:  MOVLB  0
090C8:  CALL   55E6
090CC:  BRA    90D4
....................    else return INV_PARAM;
090CE:  MOVLW  02
090D0:  MOVWF  01
090D2:  BRA    90D8
....................    
....................    return SUCCESS;
090D4:  MOVLW  00
090D6:  MOVWF  01
090D8:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
091F8:  MOVLW  72
091FA:  MOVLB  7
091FC:  MOVWF  x13
091FE:  MOVLW  61
09200:  MOVWF  x14
09202:  MOVLW  77
09204:  MOVWF  x15
09206:  CLRF   x16
09208:  MOVLW  07
0920A:  MOVWF  x12
0920C:  MOVLW  13
0920E:  MOVWF  x11
....................    char *s_calibrated = "calib";
09210:  MOVLW  63
09212:  MOVWF  x19
09214:  MOVLW  61
09216:  MOVWF  x1A
09218:  MOVLW  6C
0921A:  MOVWF  x1B
0921C:  MOVLW  69
0921E:  MOVWF  x1C
09220:  MOVLW  62
09222:  MOVWF  x1D
09224:  CLRF   x1E
09226:  MOVLW  07
09228:  MOVWF  x18
0922A:  MOVLW  19
0922C:  MOVWF  x17
....................    char *s_p0 = "p0";
0922E:  MOVLW  70
09230:  MOVWF  x21
09232:  MOVLW  30
09234:  MOVWF  x22
09236:  CLRF   x23
09238:  MOVLW  07
0923A:  MOVWF  x20
0923C:  MOVLW  21
0923E:  MOVWF  x1F
....................    char *s_poles = "poles";
09240:  MOVLW  70
09242:  MOVWF  x26
09244:  MOVLW  6F
09246:  MOVWF  x27
09248:  MOVLW  6C
0924A:  MOVWF  x28
0924C:  MOVLW  65
0924E:  MOVWF  x29
09250:  MOVLW  73
09252:  MOVWF  x2A
09254:  CLRF   x2B
09256:  MOVLW  07
09258:  MOVWF  x25
0925A:  MOVLW  26
0925C:  MOVWF  x24
....................    char *s_real = "real";
0925E:  MOVLW  72
09260:  MOVWF  x2E
09262:  MOVLW  65
09264:  MOVWF  x2F
09266:  MOVLW  61
09268:  MOVWF  x30
0926A:  MOVLW  6C
0926C:  MOVWF  x31
0926E:  CLRF   x32
09270:  MOVLW  07
09272:  MOVWF  x2D
09274:  MOVLW  2E
09276:  MOVWF  x2C
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09278:  CLRF   x45
0927A:  MOVFF  698,744
0927E:  CLRF   x47
09280:  MOVLW  B5
09282:  MOVWF  x46
09284:  MOVLB  0
09286:  CALL   0864
0928A:  MOVFF  02,734
0928E:  MOVFF  01,733
09292:  MOVLW  06
09294:  MOVLB  7
09296:  ADDWF  x33,F
09298:  MOVLW  00
0929A:  ADDWFC x34,F
0929C:  MOVLW  32
0929E:  ADDWF  x33,W
092A0:  MOVWF  01
092A2:  MOVLW  00
092A4:  ADDWFC x34,W
092A6:  MOVWF  03
092A8:  MOVF   01,W
092AA:  ADDLW  EB
092AC:  MOVWF  01
092AE:  MOVLW  01
092B0:  ADDWFC 03,F
092B2:  MOVFF  01,733
092B6:  MOVFF  03,734
092BA:  MOVFF  03,737
092BE:  MOVFF  01,736
092C2:  MOVLB  0
092C4:  CALL   5784
092C8:  MOVF   01,F
092CA:  BNZ   92D4
092CC:  MOVLW  02
092CE:  MOVWF  01
092D0:  BRA    9918
092D2:  BRA    9332
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
092D4:  MOVLB  7
092D6:  CLRF   x45
092D8:  MOVFF  698,744
092DC:  CLRF   x47
092DE:  MOVLW  B5
092E0:  MOVWF  x46
092E2:  MOVLB  0
092E4:  CALL   0864
092E8:  MOVFF  02,734
092EC:  MOVFF  01,733
092F0:  MOVLW  06
092F2:  MOVLB  7
092F4:  ADDWF  x33,F
092F6:  MOVLW  00
092F8:  ADDWFC x34,F
092FA:  MOVLW  32
092FC:  ADDWF  x33,W
092FE:  MOVWF  01
09300:  MOVLW  00
09302:  ADDWFC x34,W
09304:  MOVWF  03
09306:  MOVF   01,W
09308:  ADDLW  EB
0930A:  MOVWF  01
0930C:  MOVLW  01
0930E:  ADDWFC 03,F
09310:  MOVFF  01,733
09314:  MOVFF  03,734
09318:  MOVFF  03,737
0931C:  MOVFF  01,736
09320:  CLRF   x39
09322:  CLRF   x38
09324:  MOVLW  0A
09326:  MOVWF  x3A
09328:  MOVLB  0
0932A:  CALL   5874
0932E:  MOVFF  01,70E
....................    
....................    arg2 = SERcmd[rec].p[3];
09332:  MOVLB  7
09334:  CLRF   x45
09336:  MOVFF  698,744
0933A:  CLRF   x47
0933C:  MOVLW  B5
0933E:  MOVWF  x46
09340:  MOVLB  0
09342:  CALL   0864
09346:  MOVFF  02,734
0934A:  MOVFF  01,733
0934E:  MOVLW  06
09350:  MOVLB  7
09352:  ADDWF  x33,F
09354:  MOVLW  00
09356:  ADDWFC x34,F
09358:  MOVLW  4B
0935A:  ADDWF  x33,W
0935C:  MOVWF  01
0935E:  MOVLW  00
09360:  ADDWFC x34,W
09362:  MOVWF  03
09364:  MOVF   01,W
09366:  ADDLW  EB
09368:  MOVWF  01
0936A:  MOVLW  01
0936C:  ADDWFC 03,F
0936E:  MOVFF  01,70F
09372:  MOVFF  03,710
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09376:  MOVFF  712,745
0937A:  MOVFF  711,744
0937E:  MOVFF  710,747
09382:  MOVFF  70F,746
09386:  MOVLB  0
09388:  CALL   5664
0938C:  MOVF   01,F
0938E:  BTFSS  FD8.2
09390:  BRA    950C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09392:  MOVLW  04
09394:  MOVLB  7
09396:  MOVWF  x45
09398:  MOVLW  C1
0939A:  MOVWF  x44
0939C:  MOVLB  0
0939E:  CALL   55AE
093A2:  MOVFF  02,03
093A6:  MOVF   01,W
093A8:  ADDLW  C1
093AA:  MOVLB  7
093AC:  MOVWF  x33
093AE:  MOVLW  04
093B0:  ADDWFC 02,W
093B2:  MOVWF  x34
093B4:  MOVFF  FE8,565
093B8:  MOVFF  733,564
093BC:  MOVFF  70E,737
093C0:  MOVLW  18
093C2:  MOVWF  x38
093C4:  MOVLB  0
093C6:  CALL   5BC8
093CA:  MOVLW  2C
093CC:  MOVLB  7
093CE:  MOVWF  x53
093D0:  MOVLB  0
093D2:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
093D6:  MOVLW  04
093D8:  MOVLB  7
093DA:  MOVWF  x45
093DC:  MOVLW  C1
093DE:  MOVWF  x44
093E0:  MOVLB  0
093E2:  CALL   55AE
093E6:  MOVFF  02,03
093EA:  MOVF   01,W
093EC:  ADDLW  C1
093EE:  MOVLB  7
093F0:  MOVWF  x33
093F2:  MOVLW  04
093F4:  ADDWFC 02,W
093F6:  MOVWF  x34
093F8:  MOVLW  01
093FA:  SUBWF  x0E,W
093FC:  MULLW  26
093FE:  MOVF   FF3,W
09400:  CLRF   x36
09402:  MOVWF  x35
09404:  MOVLW  17
09406:  ADDWF  x35,W
09408:  MOVWF  FE9
0940A:  MOVLW  01
0940C:  ADDWFC x36,W
0940E:  MOVWF  FEA
09410:  MOVFF  FEF,753
09414:  MOVFF  FEC,01
09418:  MOVFF  FEC,02
0941C:  MOVFF  FEC,03
09420:  MOVFF  03,756
09424:  MOVFF  02,755
09428:  MOVFF  01,754
0942C:  MOVLB  0
0942E:  CALL   63EC
09432:  MOVFF  03,73A
09436:  MOVFF  02,739
0943A:  MOVFF  01,738
0943E:  MOVFF  00,737
09442:  MOVFF  734,565
09446:  MOVFF  733,564
0944A:  MOVLW  41
0944C:  MOVWF  FE9
0944E:  MOVFF  03,73F
09452:  MOVFF  02,73E
09456:  MOVFF  01,73D
0945A:  MOVFF  00,73C
0945E:  RCALL  90DA
09460:  MOVLW  2C
09462:  MOVLB  7
09464:  MOVWF  x53
09466:  MOVLB  0
09468:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0946C:  MOVLW  04
0946E:  MOVLB  7
09470:  MOVWF  x45
09472:  MOVLW  C1
09474:  MOVWF  x44
09476:  MOVLB  0
09478:  CALL   55AE
0947C:  MOVF   01,W
0947E:  ADDLW  C1
09480:  MOVLB  7
09482:  MOVWF  x33
09484:  MOVLW  04
09486:  ADDWFC 02,W
09488:  MOVWF  x34
0948A:  MOVLW  01
0948C:  SUBWF  x0E,W
0948E:  MULLW  26
09490:  MOVF   FF3,W
09492:  CLRF   x36
09494:  MOVWF  x35
09496:  MOVLW  04
09498:  ADDWF  x35,W
0949A:  MOVWF  01
0949C:  MOVLW  00
0949E:  ADDWFC x36,W
094A0:  MOVWF  03
094A2:  MOVF   01,W
094A4:  ADDLW  17
094A6:  MOVWF  FE9
094A8:  MOVLW  01
094AA:  ADDWFC 03,W
094AC:  MOVWF  FEA
094AE:  MOVFF  FEF,753
094B2:  MOVFF  FEC,01
094B6:  MOVFF  FEC,02
094BA:  MOVFF  FEC,03
094BE:  MOVFF  03,756
094C2:  MOVFF  02,755
094C6:  MOVFF  01,754
094CA:  MOVLB  0
094CC:  CALL   63EC
094D0:  MOVFF  03,738
094D4:  MOVFF  02,737
094D8:  MOVFF  01,736
094DC:  MOVFF  00,735
094E0:  MOVFF  734,565
094E4:  MOVFF  733,564
094E8:  MOVLW  41
094EA:  MOVWF  FE9
094EC:  MOVFF  03,73F
094F0:  MOVFF  02,73E
094F4:  MOVFF  01,73D
094F8:  MOVFF  00,73C
094FC:  RCALL  90DA
094FE:  MOVLW  2C
09500:  MOVLB  7
09502:  MOVWF  x53
09504:  MOVLB  0
09506:  CALL   55E6
....................    }
0950A:  BRA    9914
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0950C:  MOVFF  718,745
09510:  MOVFF  717,744
09514:  MOVFF  710,747
09518:  MOVFF  70F,746
0951C:  CALL   5664
09520:  MOVF   01,F
09522:  BTFSS  FD8.2
09524:  BRA    96A8
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09526:  MOVLW  04
09528:  MOVLB  7
0952A:  MOVWF  x45
0952C:  MOVLW  C1
0952E:  MOVWF  x44
09530:  MOVLB  0
09532:  CALL   55AE
09536:  MOVFF  02,03
0953A:  MOVF   01,W
0953C:  ADDLW  C1
0953E:  MOVLB  7
09540:  MOVWF  x33
09542:  MOVLW  04
09544:  ADDWFC 02,W
09546:  MOVWF  x34
09548:  MOVFF  FE8,565
0954C:  MOVFF  733,564
09550:  MOVFF  70E,737
09554:  MOVLW  18
09556:  MOVWF  x38
09558:  MOVLB  0
0955A:  CALL   5BC8
0955E:  MOVLW  2C
09560:  MOVLB  7
09562:  MOVWF  x53
09564:  MOVLB  0
09566:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0956A:  MOVLW  04
0956C:  MOVLB  7
0956E:  MOVWF  x45
09570:  MOVLW  C1
09572:  MOVWF  x44
09574:  MOVLB  0
09576:  CALL   55AE
0957A:  MOVF   01,W
0957C:  ADDLW  C1
0957E:  MOVLB  7
09580:  MOVWF  x33
09582:  MOVLW  04
09584:  ADDWFC 02,W
09586:  MOVWF  x34
09588:  MOVLW  01
0958A:  SUBWF  x0E,W
0958C:  MULLW  26
0958E:  MOVF   FF3,W
09590:  CLRF   x36
09592:  MOVWF  x35
09594:  MOVLW  08
09596:  ADDWF  x35,W
09598:  MOVWF  01
0959A:  MOVLW  00
0959C:  ADDWFC x36,W
0959E:  MOVWF  03
095A0:  MOVF   01,W
095A2:  ADDLW  17
095A4:  MOVWF  FE9
095A6:  MOVLW  01
095A8:  ADDWFC 03,W
095AA:  MOVWF  FEA
095AC:  MOVFF  FEF,753
095B0:  MOVFF  FEC,01
095B4:  MOVFF  FEC,02
095B8:  MOVFF  FEC,03
095BC:  MOVFF  03,756
095C0:  MOVFF  02,755
095C4:  MOVFF  01,754
095C8:  MOVLB  0
095CA:  CALL   63EC
095CE:  MOVFF  03,738
095D2:  MOVFF  02,737
095D6:  MOVFF  01,736
095DA:  MOVFF  00,735
095DE:  MOVFF  734,565
095E2:  MOVFF  733,564
095E6:  MOVLW  41
095E8:  MOVWF  FE9
095EA:  MOVFF  03,73F
095EE:  MOVFF  02,73E
095F2:  MOVFF  01,73D
095F6:  MOVFF  00,73C
095FA:  RCALL  90DA
095FC:  MOVLW  2C
095FE:  MOVLB  7
09600:  MOVWF  x53
09602:  MOVLB  0
09604:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09608:  MOVLW  04
0960A:  MOVLB  7
0960C:  MOVWF  x45
0960E:  MOVLW  C1
09610:  MOVWF  x44
09612:  MOVLB  0
09614:  CALL   55AE
09618:  MOVF   01,W
0961A:  ADDLW  C1
0961C:  MOVLB  7
0961E:  MOVWF  x33
09620:  MOVLW  04
09622:  ADDWFC 02,W
09624:  MOVWF  x34
09626:  MOVLW  01
09628:  SUBWF  x0E,W
0962A:  MULLW  26
0962C:  MOVF   FF3,W
0962E:  CLRF   x36
09630:  MOVWF  x35
09632:  MOVLW  0C
09634:  ADDWF  x35,W
09636:  MOVWF  01
09638:  MOVLW  00
0963A:  ADDWFC x36,W
0963C:  MOVWF  03
0963E:  MOVF   01,W
09640:  ADDLW  17
09642:  MOVWF  FE9
09644:  MOVLW  01
09646:  ADDWFC 03,W
09648:  MOVWF  FEA
0964A:  MOVFF  FEF,753
0964E:  MOVFF  FEC,01
09652:  MOVFF  FEC,02
09656:  MOVFF  FEC,03
0965A:  MOVFF  03,756
0965E:  MOVFF  02,755
09662:  MOVFF  01,754
09666:  MOVLB  0
09668:  CALL   63EC
0966C:  MOVFF  03,738
09670:  MOVFF  02,737
09674:  MOVFF  01,736
09678:  MOVFF  00,735
0967C:  MOVFF  734,565
09680:  MOVFF  733,564
09684:  MOVLW  41
09686:  MOVWF  FE9
09688:  MOVFF  03,73F
0968C:  MOVFF  02,73E
09690:  MOVFF  01,73D
09694:  MOVFF  00,73C
09698:  RCALL  90DA
0969A:  MOVLW  2C
0969C:  MOVLB  7
0969E:  MOVWF  x53
096A0:  MOVLB  0
096A2:  CALL   55E6
....................    }
096A6:  BRA    9914
....................    else if (0 == strcmp(s_p0, arg2)) {
096A8:  MOVFF  720,745
096AC:  MOVFF  71F,744
096B0:  MOVFF  710,747
096B4:  MOVFF  70F,746
096B8:  CALL   5664
096BC:  MOVF   01,F
096BE:  BNZ   977A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
096C0:  MOVLW  04
096C2:  MOVLB  7
096C4:  MOVWF  x45
096C6:  MOVLW  C1
096C8:  MOVWF  x44
096CA:  MOVLB  0
096CC:  CALL   55AE
096D0:  MOVFF  02,03
096D4:  MOVF   01,W
096D6:  ADDLW  C1
096D8:  MOVLB  7
096DA:  MOVWF  x33
096DC:  MOVLW  04
096DE:  ADDWFC 02,W
096E0:  MOVWF  x34
096E2:  MOVFF  FE8,565
096E6:  MOVFF  733,564
096EA:  MOVFF  70E,737
096EE:  MOVLW  18
096F0:  MOVWF  x38
096F2:  MOVLB  0
096F4:  CALL   5BC8
096F8:  MOVLW  2C
096FA:  MOVLB  7
096FC:  MOVWF  x53
096FE:  MOVLB  0
09700:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09704:  MOVLW  04
09706:  MOVLB  7
09708:  MOVWF  x45
0970A:  MOVLW  C1
0970C:  MOVWF  x44
0970E:  MOVLB  0
09710:  CALL   55AE
09714:  MOVF   01,W
09716:  ADDLW  C1
09718:  MOVLB  7
0971A:  MOVWF  x33
0971C:  MOVLW  04
0971E:  ADDWFC 02,W
09720:  MOVWF  x34
09722:  MOVLW  01
09724:  SUBWF  x0E,W
09726:  MULLW  26
09728:  MOVF   FF3,W
0972A:  CLRF   x36
0972C:  MOVWF  x35
0972E:  MOVLW  18
09730:  ADDWF  x35,W
09732:  MOVWF  01
09734:  MOVLW  00
09736:  ADDWFC x36,W
09738:  MOVWF  03
0973A:  MOVF   01,W
0973C:  ADDLW  17
0973E:  MOVWF  FE9
09740:  MOVLW  01
09742:  ADDWFC 03,W
09744:  MOVWF  FEA
09746:  MOVFF  FEF,746
0974A:  MOVFF  FEC,747
0974E:  MOVFF  FEC,748
09752:  MOVFF  FEC,749
09756:  MOVFF  734,565
0975A:  MOVFF  733,564
0975E:  MOVLW  89
09760:  MOVWF  FE9
09762:  MOVLW  02
09764:  MOVWF  x4A
09766:  MOVLB  0
09768:  CALL   64C2
0976C:  MOVLW  2C
0976E:  MOVLB  7
09770:  MOVWF  x53
09772:  MOVLB  0
09774:  CALL   55E6
....................    }
09778:  BRA    9914
....................    else if (0 == strcmp(s_poles, arg2)) {
0977A:  MOVFF  725,745
0977E:  MOVFF  724,744
09782:  MOVFF  710,747
09786:  MOVFF  70F,746
0978A:  CALL   5664
0978E:  MOVF   01,F
09790:  BNZ   983C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09792:  MOVLW  04
09794:  MOVLB  7
09796:  MOVWF  x45
09798:  MOVLW  C1
0979A:  MOVWF  x44
0979C:  MOVLB  0
0979E:  CALL   55AE
097A2:  MOVFF  02,03
097A6:  MOVF   01,W
097A8:  ADDLW  C1
097AA:  MOVLB  7
097AC:  MOVWF  x33
097AE:  MOVLW  04
097B0:  ADDWFC 02,W
097B2:  MOVWF  x34
097B4:  MOVFF  FE8,565
097B8:  MOVFF  733,564
097BC:  MOVFF  70E,737
097C0:  MOVLW  18
097C2:  MOVWF  x38
097C4:  MOVLB  0
097C6:  CALL   5BC8
097CA:  MOVLW  2C
097CC:  MOVLB  7
097CE:  MOVWF  x53
097D0:  MOVLB  0
097D2:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
097D6:  MOVLW  04
097D8:  MOVLB  7
097DA:  MOVWF  x45
097DC:  MOVLW  C1
097DE:  MOVWF  x44
097E0:  MOVLB  0
097E2:  CALL   55AE
097E6:  MOVF   01,W
097E8:  ADDLW  C1
097EA:  MOVLB  7
097EC:  MOVWF  x33
097EE:  MOVLW  04
097F0:  ADDWFC 02,W
097F2:  MOVWF  x34
097F4:  MOVLW  01
097F6:  SUBWF  x0E,W
097F8:  MULLW  26
097FA:  MOVF   FF3,W
097FC:  CLRF   x36
097FE:  MOVWF  x35
09800:  MOVLW  1C
09802:  ADDWF  x35,W
09804:  MOVWF  01
09806:  MOVLW  00
09808:  ADDWFC x36,W
0980A:  MOVWF  03
0980C:  MOVF   01,W
0980E:  ADDLW  17
09810:  MOVWF  FE9
09812:  MOVLW  01
09814:  ADDWFC 03,W
09816:  MOVWF  FEA
09818:  MOVFF  FEF,737
0981C:  MOVFF  734,565
09820:  MOVFF  733,564
09824:  MOVLW  18
09826:  MOVWF  x38
09828:  MOVLB  0
0982A:  CALL   5BC8
0982E:  MOVLW  2C
09830:  MOVLB  7
09832:  MOVWF  x53
09834:  MOVLB  0
09836:  CALL   55E6
....................    }
0983A:  BRA    9914
....................    else if (0 == strcmp(s_real, arg2)) {
0983C:  MOVFF  72D,745
09840:  MOVFF  72C,744
09844:  MOVFF  710,747
09848:  MOVFF  70F,746
0984C:  CALL   5664
09850:  MOVF   01,F
09852:  BNZ   990E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09854:  MOVLW  04
09856:  MOVLB  7
09858:  MOVWF  x45
0985A:  MOVLW  C1
0985C:  MOVWF  x44
0985E:  MOVLB  0
09860:  CALL   55AE
09864:  MOVFF  02,03
09868:  MOVF   01,W
0986A:  ADDLW  C1
0986C:  MOVLB  7
0986E:  MOVWF  x33
09870:  MOVLW  04
09872:  ADDWFC 02,W
09874:  MOVWF  x34
09876:  MOVFF  FE8,565
0987A:  MOVFF  733,564
0987E:  MOVFF  70E,737
09882:  MOVLW  18
09884:  MOVWF  x38
09886:  MOVLB  0
09888:  CALL   5BC8
0988C:  MOVLW  2C
0988E:  MOVLB  7
09890:  MOVWF  x53
09892:  MOVLB  0
09894:  CALL   55E6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09898:  MOVLW  04
0989A:  MOVLB  7
0989C:  MOVWF  x45
0989E:  MOVLW  C1
098A0:  MOVWF  x44
098A2:  MOVLB  0
098A4:  CALL   55AE
098A8:  MOVF   01,W
098AA:  ADDLW  C1
098AC:  MOVLB  7
098AE:  MOVWF  x33
098B0:  MOVLW  04
098B2:  ADDWFC 02,W
098B4:  MOVWF  x34
098B6:  MOVLW  01
098B8:  SUBWF  x0E,W
098BA:  MULLW  26
098BC:  MOVF   FF3,W
098BE:  CLRF   x36
098C0:  MOVWF  x35
098C2:  MOVLW  1D
098C4:  ADDWF  x35,W
098C6:  MOVWF  01
098C8:  MOVLW  00
098CA:  ADDWFC x36,W
098CC:  MOVWF  03
098CE:  MOVF   01,W
098D0:  ADDLW  17
098D2:  MOVWF  FE9
098D4:  MOVLW  01
098D6:  ADDWFC 03,W
098D8:  MOVWF  FEA
098DA:  MOVFF  FEF,746
098DE:  MOVFF  FEC,747
098E2:  MOVFF  FEC,748
098E6:  MOVFF  FEC,749
098EA:  MOVFF  734,565
098EE:  MOVFF  733,564
098F2:  MOVLW  89
098F4:  MOVWF  FE9
098F6:  MOVLW  02
098F8:  MOVWF  x4A
098FA:  MOVLB  0
098FC:  CALL   64C2
09900:  MOVLW  2C
09902:  MOVLB  7
09904:  MOVWF  x53
09906:  MOVLB  0
09908:  CALL   55E6
....................    }
0990C:  BRA    9914
....................    else return INV_PARAM;
0990E:  MOVLW  02
09910:  MOVWF  01
09912:  BRA    9918
....................    
....................    return SUCCESS;
09914:  MOVLW  00
09916:  MOVWF  01
09918:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0991A:  MOVLB  7
0991C:  CLRF   x45
0991E:  MOVFF  698,744
09922:  CLRF   x47
09924:  MOVLW  B5
09926:  MOVWF  x46
09928:  MOVLB  0
0992A:  CALL   0864
0992E:  MOVFF  02,710
09932:  MOVFF  01,70F
09936:  MOVLW  06
09938:  MOVLB  7
0993A:  ADDWF  x0F,F
0993C:  MOVLW  00
0993E:  ADDWFC x10,F
09940:  MOVLW  32
09942:  ADDWF  x0F,W
09944:  MOVWF  01
09946:  MOVLW  00
09948:  ADDWFC x10,W
0994A:  MOVWF  03
0994C:  MOVF   01,W
0994E:  ADDLW  EB
09950:  MOVWF  01
09952:  MOVLW  01
09954:  ADDWFC 03,F
09956:  MOVFF  01,70F
0995A:  MOVFF  03,710
0995E:  MOVFF  03,737
09962:  MOVFF  01,736
09966:  MOVLB  0
09968:  CALL   5784
0996C:  MOVF   01,F
0996E:  BNZ   9978
09970:  MOVLW  02
09972:  MOVWF  01
09974:  BRA    9A7A
09976:  BRA    99D6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09978:  MOVLB  7
0997A:  CLRF   x45
0997C:  MOVFF  698,744
09980:  CLRF   x47
09982:  MOVLW  B5
09984:  MOVWF  x46
09986:  MOVLB  0
09988:  CALL   0864
0998C:  MOVFF  02,710
09990:  MOVFF  01,70F
09994:  MOVLW  06
09996:  MOVLB  7
09998:  ADDWF  x0F,F
0999A:  MOVLW  00
0999C:  ADDWFC x10,F
0999E:  MOVLW  32
099A0:  ADDWF  x0F,W
099A2:  MOVWF  01
099A4:  MOVLW  00
099A6:  ADDWFC x10,W
099A8:  MOVWF  03
099AA:  MOVF   01,W
099AC:  ADDLW  EB
099AE:  MOVWF  01
099B0:  MOVLW  01
099B2:  ADDWFC 03,F
099B4:  MOVFF  01,70F
099B8:  MOVFF  03,710
099BC:  MOVFF  03,737
099C0:  MOVFF  01,736
099C4:  CLRF   x39
099C6:  CLRF   x38
099C8:  MOVLW  0A
099CA:  MOVWF  x3A
099CC:  MOVLB  0
099CE:  CALL   5874
099D2:  MOVFF  01,70E
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
099D6:  MOVLW  04
099D8:  MOVLB  7
099DA:  MOVWF  x45
099DC:  MOVLW  C1
099DE:  MOVWF  x44
099E0:  MOVLB  0
099E2:  CALL   55AE
099E6:  MOVF   01,W
099E8:  ADDLW  C1
099EA:  MOVLB  7
099EC:  MOVWF  x0F
099EE:  MOVLW  04
099F0:  ADDWFC 02,W
099F2:  MOVWF  x10
099F4:  MOVLW  01
099F6:  SUBWF  x0E,W
099F8:  MULLW  07
099FA:  MOVF   FF3,W
099FC:  CLRF   x12
099FE:  MOVWF  x11
09A00:  MOVLW  03
09A02:  ADDWF  x11,W
09A04:  MOVWF  01
09A06:  MOVLW  00
09A08:  ADDWFC x12,W
09A0A:  MOVWF  03
09A0C:  MOVF   01,W
09A0E:  ADDLW  64
09A10:  MOVWF  FE9
09A12:  MOVLW  01
09A14:  ADDWFC 03,W
09A16:  MOVWF  FEA
09A18:  MOVFF  FEF,711
09A1C:  MOVFF  FEC,712
09A20:  MOVFF  FEC,713
09A24:  MOVFF  FEC,714
09A28:  MOVFF  710,565
09A2C:  MOVFF  70F,564
09A30:  MOVFF  70E,737
09A34:  MOVLW  18
09A36:  MOVWF  x38
09A38:  MOVLB  0
09A3A:  CALL   5BC8
09A3E:  MOVLW  2C
09A40:  MOVLB  7
09A42:  MOVWF  x53
09A44:  MOVLB  0
09A46:  CALL   55E6
09A4A:  MOVLW  89
09A4C:  MOVWF  FE9
09A4E:  MOVFF  714,749
09A52:  MOVFF  713,748
09A56:  MOVFF  712,747
09A5A:  MOVFF  711,746
09A5E:  MOVLW  02
09A60:  MOVLB  7
09A62:  MOVWF  x4A
09A64:  MOVLB  0
09A66:  CALL   64C2
09A6A:  MOVLW  2C
09A6C:  MOVLB  7
09A6E:  MOVWF  x53
09A70:  MOVLB  0
09A72:  CALL   55E6
....................    
....................    return SUCCESS;
09A76:  MOVLW  00
09A78:  MOVWF  01
09A7A:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09A7C:  MOVLB  7
09A7E:  CLRF   x45
09A80:  MOVFF  698,744
09A84:  CLRF   x47
09A86:  MOVLW  B5
09A88:  MOVWF  x46
09A8A:  MOVLB  0
09A8C:  CALL   0864
09A90:  MOVFF  02,714
09A94:  MOVFF  01,713
09A98:  MOVLW  06
09A9A:  MOVLB  7
09A9C:  ADDWF  x13,F
09A9E:  MOVLW  00
09AA0:  ADDWFC x14,F
09AA2:  MOVLW  32
09AA4:  ADDWF  x13,W
09AA6:  MOVWF  01
09AA8:  MOVLW  00
09AAA:  ADDWFC x14,W
09AAC:  MOVWF  03
09AAE:  MOVF   01,W
09AB0:  ADDLW  EB
09AB2:  MOVWF  01
09AB4:  MOVLW  01
09AB6:  ADDWFC 03,F
09AB8:  MOVFF  01,713
09ABC:  MOVFF  03,714
09AC0:  MOVFF  03,737
09AC4:  MOVFF  01,736
09AC8:  MOVLB  0
09ACA:  CALL   5784
09ACE:  MOVF   01,F
09AD0:  BNZ   9ADA
09AD2:  MOVLW  02
09AD4:  MOVWF  01
09AD6:  BRA    9CEC
09AD8:  BRA    9B38
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09ADA:  MOVLB  7
09ADC:  CLRF   x45
09ADE:  MOVFF  698,744
09AE2:  CLRF   x47
09AE4:  MOVLW  B5
09AE6:  MOVWF  x46
09AE8:  MOVLB  0
09AEA:  CALL   0864
09AEE:  MOVFF  02,714
09AF2:  MOVFF  01,713
09AF6:  MOVLW  06
09AF8:  MOVLB  7
09AFA:  ADDWF  x13,F
09AFC:  MOVLW  00
09AFE:  ADDWFC x14,F
09B00:  MOVLW  32
09B02:  ADDWF  x13,W
09B04:  MOVWF  01
09B06:  MOVLW  00
09B08:  ADDWFC x14,W
09B0A:  MOVWF  03
09B0C:  MOVF   01,W
09B0E:  ADDLW  EB
09B10:  MOVWF  01
09B12:  MOVLW  01
09B14:  ADDWFC 03,F
09B16:  MOVFF  01,713
09B1A:  MOVFF  03,714
09B1E:  MOVFF  03,737
09B22:  MOVFF  01,736
09B26:  CLRF   x39
09B28:  CLRF   x38
09B2A:  MOVLW  0A
09B2C:  MOVWF  x3A
09B2E:  MOVLB  0
09B30:  CALL   5874
09B34:  MOVFF  01,70E
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09B38:  MOVLB  7
09B3A:  CLRF   x45
09B3C:  MOVFF  698,744
09B40:  CLRF   x47
09B42:  MOVLW  B5
09B44:  MOVWF  x46
09B46:  MOVLB  0
09B48:  CALL   0864
09B4C:  MOVFF  02,714
09B50:  MOVFF  01,713
09B54:  MOVLW  06
09B56:  MOVLB  7
09B58:  ADDWF  x13,F
09B5A:  MOVLW  00
09B5C:  ADDWFC x14,F
09B5E:  MOVLW  4B
09B60:  ADDWF  x13,W
09B62:  MOVWF  01
09B64:  MOVLW  00
09B66:  ADDWFC x14,W
09B68:  MOVWF  03
09B6A:  MOVF   01,W
09B6C:  ADDLW  EB
09B6E:  MOVWF  01
09B70:  MOVLW  01
09B72:  ADDWFC 03,F
09B74:  MOVFF  01,713
09B78:  MOVFF  03,714
09B7C:  MOVFF  03,718
09B80:  MOVFF  01,717
09B84:  MOVLB  0
09B86:  CALL   6B28
09B8A:  MOVF   01,F
09B8C:  BNZ   9B96
09B8E:  MOVLW  02
09B90:  MOVWF  01
09B92:  BRA    9CEC
09B94:  BRA    9BFC
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09B96:  MOVLB  7
09B98:  CLRF   x45
09B9A:  MOVFF  698,744
09B9E:  CLRF   x47
09BA0:  MOVLW  B5
09BA2:  MOVWF  x46
09BA4:  MOVLB  0
09BA6:  CALL   0864
09BAA:  MOVFF  02,714
09BAE:  MOVFF  01,713
09BB2:  MOVLW  06
09BB4:  MOVLB  7
09BB6:  ADDWF  x13,F
09BB8:  MOVLW  00
09BBA:  ADDWFC x14,F
09BBC:  MOVLW  4B
09BBE:  ADDWF  x13,W
09BC0:  MOVWF  01
09BC2:  MOVLW  00
09BC4:  ADDWFC x14,W
09BC6:  MOVWF  03
09BC8:  MOVF   01,W
09BCA:  ADDLW  EB
09BCC:  MOVWF  01
09BCE:  MOVLW  01
09BD0:  ADDWFC 03,F
09BD2:  MOVFF  01,713
09BD6:  MOVFF  03,714
09BDA:  MOVFF  03,718
09BDE:  MOVFF  01,717
09BE2:  CLRF   x1A
09BE4:  CLRF   x19
09BE6:  MOVLB  0
09BE8:  CALL   6BEA
09BEC:  MOVFF  03,712
09BF0:  MOVFF  02,711
09BF4:  MOVFF  01,710
09BF8:  MOVFF  00,70F
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09BFC:  MOVLB  7
09BFE:  CLRF   x51
09C00:  CLRF   x50
09C02:  MOVLW  7C
09C04:  MOVWF  x4F
09C06:  MOVLW  84
09C08:  MOVWF  x4E
09C0A:  MOVFF  712,755
09C0E:  MOVFF  711,754
09C12:  MOVFF  710,753
09C16:  MOVFF  70F,752
09C1A:  MOVLB  0
09C1C:  CALL   1CD8
09C20:  BNC   9C56
09C22:  MOVLW  01
09C24:  MOVLB  7
09C26:  SUBWF  x0E,W
09C28:  MULLW  07
09C2A:  MOVF   FF3,W
09C2C:  CLRF   x14
09C2E:  MOVWF  x13
09C30:  MOVLW  03
09C32:  ADDWF  x13,W
09C34:  MOVWF  01
09C36:  MOVLW  00
09C38:  ADDWFC x14,W
09C3A:  MOVWF  03
09C3C:  MOVF   01,W
09C3E:  ADDLW  64
09C40:  MOVWF  FE9
09C42:  MOVLW  01
09C44:  ADDWFC 03,W
09C46:  MOVWF  FEA
09C48:  MOVLW  84
09C4A:  MOVWF  FEF
09C4C:  MOVLW  7C
09C4E:  MOVWF  FEC
09C50:  CLRF   FEC
09C52:  CLRF   FEC
09C54:  BRA    9CE6
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09C56:  MOVFF  712,751
09C5A:  MOVFF  711,750
09C5E:  MOVFF  710,74F
09C62:  MOVFF  70F,74E
09C66:  MOVLB  7
09C68:  CLRF   x55
09C6A:  CLRF   x54
09C6C:  MOVLW  FC
09C6E:  MOVWF  x53
09C70:  MOVLW  84
09C72:  MOVWF  x52
09C74:  MOVLB  0
09C76:  CALL   1CD8
09C7A:  BNC   9CB0
09C7C:  MOVLW  01
09C7E:  MOVLB  7
09C80:  SUBWF  x0E,W
09C82:  MULLW  07
09C84:  MOVF   FF3,W
09C86:  CLRF   x14
09C88:  MOVWF  x13
09C8A:  MOVLW  03
09C8C:  ADDWF  x13,W
09C8E:  MOVWF  01
09C90:  MOVLW  00
09C92:  ADDWFC x14,W
09C94:  MOVWF  03
09C96:  MOVF   01,W
09C98:  ADDLW  64
09C9A:  MOVWF  FE9
09C9C:  MOVLW  01
09C9E:  ADDWFC 03,W
09CA0:  MOVWF  FEA
09CA2:  MOVLW  84
09CA4:  MOVWF  FEF
09CA6:  MOVLW  FC
09CA8:  MOVWF  FEC
09CAA:  CLRF   FEC
09CAC:  CLRF   FEC
09CAE:  BRA    9CE6
....................    else dacVals[arg1-1].opPcnt = arg2;
09CB0:  MOVLW  01
09CB2:  MOVLB  7
09CB4:  SUBWF  x0E,W
09CB6:  MULLW  07
09CB8:  MOVF   FF3,W
09CBA:  CLRF   x14
09CBC:  MOVWF  x13
09CBE:  MOVLW  03
09CC0:  ADDWF  x13,W
09CC2:  MOVWF  01
09CC4:  MOVLW  00
09CC6:  ADDWFC x14,W
09CC8:  MOVWF  03
09CCA:  MOVF   01,W
09CCC:  ADDLW  64
09CCE:  MOVWF  FE9
09CD0:  MOVLW  01
09CD2:  ADDWFC 03,W
09CD4:  MOVWF  FEA
09CD6:  MOVFF  70F,FEF
09CDA:  MOVFF  710,FEC
09CDE:  MOVFF  711,FEC
09CE2:  MOVFF  712,FEC
....................    
....................    return SUCCESS;
09CE6:  MOVLW  00
09CE8:  MOVWF  01
09CEA:  MOVLB  0
09CEC:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09CEE:  MOVLB  1
09CF0:  BSF    x63.0
....................    return SUCCESS;
09CF2:  MOVLW  00
09CF4:  MOVWF  01
09CF6:  MOVLB  0
09CF8:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09CFA:  MOVLB  1
09CFC:  BCF    x63.0
....................    return SUCCESS;
09CFE:  MOVLW  00
09D00:  MOVWF  01
09D02:  MOVLB  0
09D04:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09D06:  MOVLB  7
09D08:  CLRF   x45
09D0A:  MOVFF  698,744
09D0E:  CLRF   x47
09D10:  MOVLW  B5
09D12:  MOVWF  x46
09D14:  MOVLB  0
09D16:  CALL   0864
09D1A:  MOVFF  02,710
09D1E:  MOVFF  01,70F
09D22:  MOVLW  06
09D24:  MOVLB  7
09D26:  ADDWF  x0F,F
09D28:  MOVLW  00
09D2A:  ADDWFC x10,F
09D2C:  MOVLW  32
09D2E:  ADDWF  x0F,W
09D30:  MOVWF  01
09D32:  MOVLW  00
09D34:  ADDWFC x10,W
09D36:  MOVWF  03
09D38:  MOVF   01,W
09D3A:  ADDLW  EB
09D3C:  MOVWF  01
09D3E:  MOVLW  01
09D40:  ADDWFC 03,F
09D42:  MOVFF  01,70F
09D46:  MOVFF  03,710
09D4A:  MOVFF  03,737
09D4E:  MOVFF  01,736
09D52:  MOVLB  0
09D54:  CALL   5784
09D58:  MOVF   01,F
09D5A:  BNZ   9D64
09D5C:  MOVLW  02
09D5E:  MOVWF  01
09D60:  BRA    9DF0
09D62:  BRA    9DC2
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09D64:  MOVLB  7
09D66:  CLRF   x45
09D68:  MOVFF  698,744
09D6C:  CLRF   x47
09D6E:  MOVLW  B5
09D70:  MOVWF  x46
09D72:  MOVLB  0
09D74:  CALL   0864
09D78:  MOVFF  02,710
09D7C:  MOVFF  01,70F
09D80:  MOVLW  06
09D82:  MOVLB  7
09D84:  ADDWF  x0F,F
09D86:  MOVLW  00
09D88:  ADDWFC x10,F
09D8A:  MOVLW  32
09D8C:  ADDWF  x0F,W
09D8E:  MOVWF  01
09D90:  MOVLW  00
09D92:  ADDWFC x10,W
09D94:  MOVWF  03
09D96:  MOVF   01,W
09D98:  ADDLW  EB
09D9A:  MOVWF  01
09D9C:  MOVLW  01
09D9E:  ADDWFC 03,F
09DA0:  MOVFF  01,70F
09DA4:  MOVFF  03,710
09DA8:  MOVFF  03,737
09DAC:  MOVFF  01,736
09DB0:  CLRF   x39
09DB2:  CLRF   x38
09DB4:  MOVLW  0A
09DB6:  MOVWF  x3A
09DB8:  MOVLB  0
09DBA:  CALL   5874
09DBE:  MOVFF  01,70E
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09DC2:  MOVLW  01
09DC4:  MOVLB  7
09DC6:  SUBWF  x0E,W
09DC8:  MULLW  26
09DCA:  MOVF   FF3,W
09DCC:  CLRF   x10
09DCE:  MOVWF  x0F
09DD0:  MOVLW  25
09DD2:  ADDWF  x0F,W
09DD4:  MOVWF  01
09DD6:  MOVLW  00
09DD8:  ADDWFC x10,W
09DDA:  MOVWF  03
09DDC:  MOVF   01,W
09DDE:  ADDLW  17
09DE0:  MOVWF  FE9
09DE2:  MOVLW  01
09DE4:  ADDWFC 03,W
09DE6:  MOVWF  FEA
09DE8:  BSF    FEF.0
....................     
....................     return SUCCESS;
09DEA:  MOVLW  00
09DEC:  MOVWF  01
09DEE:  MOVLB  0
09DF0:  RETURN 0
.................... }
.................... 
.................... int8 getTelemetry(unsigned int8 rec){
....................     for (int ch=0; ch<2; ch++){
*
09F40:  MOVLB  7
09F42:  CLRF   x0E
09F44:  MOVF   x0E,W
09F46:  SUBLW  01
09F48:  BTFSS  FD8.0
09F4A:  BRA    A27E
....................         sprintf(retData+strlen(retData), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
09F4C:  MOVLW  04
09F4E:  MOVWF  x45
09F50:  MOVLW  C1
09F52:  MOVWF  x44
09F54:  MOVLB  0
09F56:  CALL   55AE
09F5A:  MOVF   01,W
09F5C:  ADDLW  C1
09F5E:  MOVLB  7
09F60:  MOVWF  x0F
09F62:  MOVLW  04
09F64:  ADDWFC 02,W
09F66:  MOVWF  x10
09F68:  MOVLW  01
09F6A:  ADDWF  x0E,W
09F6C:  MOVWF  x11
09F6E:  MOVF   x0E,W
09F70:  MULLW  26
09F72:  MOVF   FF3,W
09F74:  CLRF   x13
09F76:  MOVWF  x12
09F78:  MOVLW  08
09F7A:  ADDWF  x12,W
09F7C:  MOVWF  01
09F7E:  MOVLW  00
09F80:  ADDWFC x13,W
09F82:  MOVWF  03
09F84:  MOVF   01,W
09F86:  ADDLW  17
09F88:  MOVWF  FE9
09F8A:  MOVLW  01
09F8C:  ADDWFC 03,W
09F8E:  MOVWF  FEA
09F90:  MOVFF  FEF,712
09F94:  MOVFF  FEC,713
09F98:  MOVFF  FEC,714
09F9C:  MOVFF  FEC,715
09FA0:  MOVF   x0E,W
09FA2:  MULLW  26
09FA4:  MOVF   FF3,W
09FA6:  CLRF   x17
09FA8:  MOVWF  x16
09FAA:  MOVLW  0C
09FAC:  ADDWF  x16,W
09FAE:  MOVWF  01
09FB0:  MOVLW  00
09FB2:  ADDWFC x17,W
09FB4:  MOVWF  03
09FB6:  MOVF   01,W
09FB8:  ADDLW  17
09FBA:  MOVWF  FE9
09FBC:  MOVLW  01
09FBE:  ADDWFC 03,W
09FC0:  MOVWF  FEA
09FC2:  MOVFF  FEF,716
09FC6:  MOVFF  FEC,717
09FCA:  MOVFF  FEC,718
09FCE:  MOVFF  FEC,719
09FD2:  MOVFF  710,565
09FD6:  MOVFF  70F,564
09FDA:  MOVLW  58
09FDC:  MOVWF  FF6
09FDE:  MOVLW  03
09FE0:  MOVWF  FF7
09FE2:  MOVLW  04
09FE4:  MOVWF  x1B
09FE6:  MOVLB  0
09FE8:  CALL   601C
09FEC:  MOVFF  711,71B
09FF0:  MOVLW  1B
09FF2:  MOVLB  7
09FF4:  MOVWF  x1C
09FF6:  MOVLB  0
09FF8:  RCALL  9DF2
09FFA:  MOVLW  2C
09FFC:  MOVLB  7
09FFE:  MOVWF  x53
0A000:  MOVLB  0
0A002:  CALL   55E6
0A006:  MOVLW  89
0A008:  MOVWF  FE9
0A00A:  MOVFF  715,749
0A00E:  MOVFF  714,748
0A012:  MOVFF  713,747
0A016:  MOVFF  712,746
0A01A:  MOVLB  7
0A01C:  CLRF   x4A
0A01E:  MOVLB  0
0A020:  CALL   64C2
0A024:  MOVLW  2C
0A026:  MOVLB  7
0A028:  MOVWF  x53
0A02A:  MOVLB  0
0A02C:  CALL   55E6
0A030:  MOVLW  89
0A032:  MOVWF  FE9
0A034:  MOVFF  719,749
0A038:  MOVFF  718,748
0A03C:  MOVFF  717,747
0A040:  MOVFF  716,746
0A044:  MOVLB  7
0A046:  CLRF   x4A
0A048:  MOVLB  0
0A04A:  CALL   64C2
0A04E:  MOVLW  3B
0A050:  MOVLB  7
0A052:  MOVWF  x53
0A054:  MOVLB  0
0A056:  CALL   55E6
....................         sprintf(retData+strlen(retData), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
0A05A:  MOVLW  04
0A05C:  MOVLB  7
0A05E:  MOVWF  x45
0A060:  MOVLW  C1
0A062:  MOVWF  x44
0A064:  MOVLB  0
0A066:  CALL   55AE
0A06A:  MOVF   01,W
0A06C:  ADDLW  C1
0A06E:  MOVLB  7
0A070:  MOVWF  x0F
0A072:  MOVLW  04
0A074:  ADDWFC 02,W
0A076:  MOVWF  x10
0A078:  MOVLW  01
0A07A:  ADDWF  x0E,W
0A07C:  MOVWF  x11
0A07E:  MOVF   x0E,W
0A080:  MULLW  26
0A082:  MOVF   FF3,W
0A084:  CLRF   x13
0A086:  MOVWF  x12
0A088:  MOVLW  1D
0A08A:  ADDWF  x12,W
0A08C:  MOVWF  01
0A08E:  MOVLW  00
0A090:  ADDWFC x13,W
0A092:  MOVWF  03
0A094:  MOVF   01,W
0A096:  ADDLW  17
0A098:  MOVWF  FE9
0A09A:  MOVLW  01
0A09C:  ADDWFC 03,W
0A09E:  MOVWF  FEA
0A0A0:  MOVFF  FEF,712
0A0A4:  MOVFF  FEC,713
0A0A8:  MOVFF  FEC,714
0A0AC:  MOVFF  FEC,715
0A0B0:  MOVFF  710,565
0A0B4:  MOVFF  70F,564
0A0B8:  MOVLW  6A
0A0BA:  MOVWF  FF6
0A0BC:  MOVLW  03
0A0BE:  MOVWF  FF7
0A0C0:  MOVLW  04
0A0C2:  MOVWF  x1B
0A0C4:  MOVLB  0
0A0C6:  CALL   601C
0A0CA:  MOVFF  711,71B
0A0CE:  MOVLW  1B
0A0D0:  MOVLB  7
0A0D2:  MOVWF  x1C
0A0D4:  MOVLB  0
0A0D6:  RCALL  9DF2
0A0D8:  MOVLW  2C
0A0DA:  MOVLB  7
0A0DC:  MOVWF  x53
0A0DE:  MOVLB  0
0A0E0:  CALL   55E6
0A0E4:  MOVLW  89
0A0E6:  MOVWF  FE9
0A0E8:  MOVFF  715,749
0A0EC:  MOVFF  714,748
0A0F0:  MOVFF  713,747
0A0F4:  MOVFF  712,746
0A0F8:  MOVLW  03
0A0FA:  MOVLB  7
0A0FC:  MOVWF  x4A
0A0FE:  MOVLB  0
0A100:  CALL   64C2
0A104:  MOVLW  3B
0A106:  MOVLB  7
0A108:  MOVWF  x53
0A10A:  MOVLB  0
0A10C:  CALL   55E6
....................         if ( dacVals[ch].invV ) sprintf(retData+strlen(retData), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A110:  MOVLB  7
0A112:  MOVF   x0E,W
0A114:  MULLW  07
0A116:  MOVF   FF3,W
0A118:  CLRF   x10
0A11A:  MOVWF  x0F
0A11C:  MOVLW  64
0A11E:  ADDWF  x0F,W
0A120:  MOVWF  FE9
0A122:  MOVLW  01
0A124:  ADDWFC x10,W
0A126:  MOVWF  FEA
0A128:  BTFSS  FEF.0
0A12A:  BRA    A1D4
0A12C:  MOVLW  04
0A12E:  MOVWF  x45
0A130:  MOVLW  C1
0A132:  MOVWF  x44
0A134:  MOVLB  0
0A136:  CALL   55AE
0A13A:  MOVF   01,W
0A13C:  ADDLW  C1
0A13E:  MOVLB  7
0A140:  MOVWF  x0F
0A142:  MOVLW  04
0A144:  ADDWFC 02,W
0A146:  MOVWF  x10
0A148:  MOVLW  01
0A14A:  ADDWF  x0E,W
0A14C:  MOVWF  x11
0A14E:  MOVF   x0E,W
0A150:  MULLW  07
0A152:  MOVF   FF3,W
0A154:  CLRF   x13
0A156:  MOVWF  x12
0A158:  MOVLW  01
0A15A:  ADDWF  x12,W
0A15C:  MOVWF  01
0A15E:  MOVLW  00
0A160:  ADDWFC x13,W
0A162:  MOVWF  03
0A164:  MOVF   01,W
0A166:  ADDLW  64
0A168:  MOVWF  FE9
0A16A:  MOVLW  01
0A16C:  ADDWFC 03,W
0A16E:  MOVWF  FEA
0A170:  MOVFF  FEC,713
0A174:  MOVF   FED,F
0A176:  MOVFF  FEF,712
0A17A:  MOVFF  710,565
0A17E:  MOVFF  70F,564
0A182:  MOVLW  78
0A184:  MOVWF  FF6
0A186:  MOVLW  03
0A188:  MOVWF  FF7
0A18A:  MOVLW  04
0A18C:  MOVWF  x1B
0A18E:  MOVLB  0
0A190:  CALL   601C
0A194:  MOVFF  711,71B
0A198:  MOVLW  1B
0A19A:  MOVLB  7
0A19C:  MOVWF  x1C
0A19E:  MOVLB  0
0A1A0:  RCALL  9DF2
0A1A2:  MOVLW  7E
0A1A4:  MOVWF  FF6
0A1A6:  MOVLW  03
0A1A8:  MOVWF  FF7
0A1AA:  MOVLW  03
0A1AC:  MOVLB  7
0A1AE:  MOVWF  x1B
0A1B0:  MOVLB  0
0A1B2:  CALL   601C
0A1B6:  MOVLW  10
0A1B8:  MOVWF  FE9
0A1BA:  MOVFF  713,716
0A1BE:  MOVFF  712,715
0A1C2:  RCALL  9E78
0A1C4:  MOVLW  3B
0A1C6:  MOVLB  7
0A1C8:  MOVWF  x53
0A1CA:  MOVLB  0
0A1CC:  CALL   55E6
0A1D0:  BRA    A278
0A1D2:  MOVLB  7
....................         else                    sprintf(retData+strlen(retData), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0A1D4:  MOVLW  04
0A1D6:  MOVWF  x45
0A1D8:  MOVLW  C1
0A1DA:  MOVWF  x44
0A1DC:  MOVLB  0
0A1DE:  CALL   55AE
0A1E2:  MOVF   01,W
0A1E4:  ADDLW  C1
0A1E6:  MOVLB  7
0A1E8:  MOVWF  x0F
0A1EA:  MOVLW  04
0A1EC:  ADDWFC 02,W
0A1EE:  MOVWF  x10
0A1F0:  MOVLW  01
0A1F2:  ADDWF  x0E,W
0A1F4:  MOVWF  x11
0A1F6:  MOVF   x0E,W
0A1F8:  MULLW  07
0A1FA:  MOVF   FF3,W
0A1FC:  CLRF   x13
0A1FE:  MOVWF  x12
0A200:  MOVLW  01
0A202:  ADDWF  x12,W
0A204:  MOVWF  01
0A206:  MOVLW  00
0A208:  ADDWFC x13,W
0A20A:  MOVWF  03
0A20C:  MOVF   01,W
0A20E:  ADDLW  64
0A210:  MOVWF  FE9
0A212:  MOVLW  01
0A214:  ADDWFC 03,W
0A216:  MOVWF  FEA
0A218:  MOVFF  FEC,713
0A21C:  MOVF   FED,F
0A21E:  MOVFF  FEF,712
0A222:  MOVFF  710,565
0A226:  MOVFF  70F,564
0A22A:  MOVLW  86
0A22C:  MOVWF  FF6
0A22E:  MOVLW  03
0A230:  MOVWF  FF7
0A232:  MOVLW  04
0A234:  MOVWF  x1B
0A236:  MOVLB  0
0A238:  CALL   601C
0A23C:  MOVFF  711,71B
0A240:  MOVLW  1B
0A242:  MOVLB  7
0A244:  MOVWF  x1C
0A246:  MOVLB  0
0A248:  RCALL  9DF2
0A24A:  MOVLW  8C
0A24C:  MOVWF  FF6
0A24E:  MOVLW  03
0A250:  MOVWF  FF7
0A252:  MOVLW  03
0A254:  MOVLB  7
0A256:  MOVWF  x1B
0A258:  MOVLB  0
0A25A:  CALL   601C
0A25E:  MOVLW  10
0A260:  MOVWF  FE9
0A262:  MOVFF  713,716
0A266:  MOVFF  712,715
0A26A:  RCALL  9E78
0A26C:  MOVLW  3B
0A26E:  MOVLB  7
0A270:  MOVWF  x53
0A272:  MOVLB  0
0A274:  CALL   55E6
0A278:  MOVLB  7
0A27A:  INCF   x0E,F
0A27C:  BRA    9F44
....................     }
....................     return SUCCESS;
0A27E:  MOVLW  00
0A280:  MOVWF  01
0A282:  MOVLB  0
0A284:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A286:  MOVLW  01
0A288:  MOVWF  01
0A28A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06B28:  MOVLB  7
06B2A:  BCF    x19.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06B2C:  CLRF   x1A
06B2E:  MOVFF  718,745
06B32:  MOVFF  717,744
06B36:  MOVLB  0
06B38:  CALL   55AE
06B3C:  MOVFF  02,03
06B40:  MOVF   01,W
06B42:  MOVF   03,F
06B44:  BNZ   6B50
06B46:  MOVF   01,W
06B48:  MOVLB  7
06B4A:  SUBWF  x1A,W
06B4C:  BC    6BE2
06B4E:  MOVLB  0
....................       if (!isdigit(arg[i])){
06B50:  MOVLB  7
06B52:  MOVF   x1A,W
06B54:  ADDWF  x17,W
06B56:  MOVWF  FE9
06B58:  MOVLW  00
06B5A:  ADDWFC x18,W
06B5C:  MOVWF  FEA
06B5E:  MOVFF  FEF,71B
06B62:  MOVF   x1B,W
06B64:  SUBLW  2F
06B66:  BC    6B6E
06B68:  MOVF   x1B,W
06B6A:  SUBLW  39
06B6C:  BC    6BDA
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06B6E:  MOVF   x1A,W
06B70:  ADDWF  x17,W
06B72:  MOVWF  FE9
06B74:  MOVLW  00
06B76:  ADDWFC x18,W
06B78:  MOVWF  FEA
06B7A:  MOVF   FEF,W
06B7C:  SUBLW  2D
06B7E:  BZ    6BAA
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06B80:  MOVF   x1A,W
06B82:  ADDWF  x17,W
06B84:  MOVWF  FE9
06B86:  MOVLW  00
06B88:  ADDWFC x18,W
06B8A:  MOVWF  FEA
06B8C:  MOVF   FEF,W
06B8E:  SUBLW  2E
06B90:  BZ    6B9A
06B92:  MOVLW  00
06B94:  MOVWF  01
06B96:  BRA    6BE6
06B98:  BRA    6BA8
....................             else if  (decimal) return FALSE;
06B9A:  BTFSS  x19.0
06B9C:  BRA    6BA6
06B9E:  MOVLW  00
06BA0:  MOVWF  01
06BA2:  BRA    6BE6
06BA4:  BRA    6BA8
....................             else decimal = TRUE;
06BA6:  BSF    x19.0
....................          }
06BA8:  BRA    6BDA
....................          else if (0 != i) return FALSE;
06BAA:  MOVF   x1A,F
06BAC:  BZ    6BB6
06BAE:  MOVLW  00
06BB0:  MOVWF  01
06BB2:  BRA    6BE6
06BB4:  BRA    6BDA
....................          else if (1 == strlen(arg)) return FALSE;
06BB6:  MOVFF  718,745
06BBA:  MOVFF  717,744
06BBE:  MOVLB  0
06BC0:  CALL   55AE
06BC4:  MOVFF  02,03
06BC8:  MOVF   01,W
06BCA:  SUBLW  01
06BCC:  BNZ   6BDC
06BCE:  MOVF   03,F
06BD0:  BNZ   6BDC
06BD2:  MOVLW  00
06BD4:  MOVWF  01
06BD6:  MOVLB  7
06BD8:  BRA    6BE6
06BDA:  MOVLB  0
....................       }
06BDC:  MOVLB  7
06BDE:  INCF   x1A,F
06BE0:  BRA    6B2E
....................    }
....................    return TRUE;
06BE2:  MOVLW  01
06BE4:  MOVWF  01
06BE6:  MOVLB  0
06BE8:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05784:  MOVFF  737,745
05788:  MOVFF  736,744
0578C:  RCALL  55AE
0578E:  MOVFF  02,03
05792:  MOVF   01,W
05794:  SUBLW  01
05796:  BNZ   579C
05798:  MOVF   03,F
0579A:  BZ    57A4
0579C:  MOVLW  00
0579E:  MOVWF  01
057A0:  BRA    57D2
057A2:  BRA    57CA
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
057A4:  MOVLB  7
057A6:  MOVFF  736,FE9
057AA:  MOVFF  737,FEA
057AE:  MOVF   FEF,W
057B0:  SUBLW  31
057B2:  BZ    57CC
057B4:  MOVFF  736,FE9
057B8:  MOVFF  737,FEA
057BC:  MOVF   FEF,W
057BE:  SUBLW  32
057C0:  BZ    57CC
057C2:  MOVLW  00
057C4:  MOVWF  01
057C6:  MOVLB  0
057C8:  BRA    57D2
057CA:  MOVLB  7
....................     return TRUE;
057CC:  MOVLW  01
057CE:  MOVWF  01
057D0:  MOVLB  0
057D2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
0562A:  MOVLB  7
0562C:  MOVF   x0D,W
0562E:  SUBLW  2F
05630:  BC    5642
05632:  MOVF   x0D,W
05634:  SUBLW  39
05636:  BNC   5642
05638:  MOVLW  30
0563A:  SUBWF  x0D,W
0563C:  MOVWF  01
0563E:  BRA    565E
05640:  BRA    565E
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05642:  MOVF   x0D,W
05644:  SUBLW  40
05646:  BC    565A
05648:  MOVF   x0D,W
0564A:  SUBLW  46
0564C:  BNC   565A
0564E:  MOVLW  41
05650:  SUBWF  x0D,W
05652:  ADDLW  0A
05654:  MOVWF  01
05656:  BRA    565E
05658:  BRA    565E
....................    else return 0xFF;
0565A:  MOVLW  FF
0565C:  MOVWF  01
0565E:  MOVLB  0
05660:  GOTO   A330 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    /* NEEDS FIXING
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
....................    */
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A28C:  MOVLB  7
0A28E:  CLRF   x45
0A290:  MOVFF  704,744
0A294:  CLRF   x47
0A296:  MOVLW  B5
0A298:  MOVWF  x46
0A29A:  MOVLB  0
0A29C:  CALL   0864
0A2A0:  MOVFF  02,70D
0A2A4:  MOVFF  01,70C
0A2A8:  MOVLW  06
0A2AA:  MOVLB  7
0A2AC:  ADDWF  x0C,F
0A2AE:  MOVLW  00
0A2B0:  ADDWFC x0D,F
0A2B2:  MOVLW  EB
0A2B4:  ADDWF  x0C,W
0A2B6:  MOVWF  01
0A2B8:  MOVLW  01
0A2BA:  ADDWFC x0D,W
0A2BC:  MOVWF  03
0A2BE:  MOVFF  01,705
0A2C2:  MOVWF  x06
0A2C4:  CLRF   x45
0A2C6:  MOVFF  704,744
0A2CA:  CLRF   x47
0A2CC:  MOVLW  B5
0A2CE:  MOVWF  x46
0A2D0:  MOVLB  0
0A2D2:  CALL   0864
0A2D6:  MOVFF  02,70F
0A2DA:  MOVFF  01,70E
0A2DE:  MOVLW  06
0A2E0:  MOVLB  7
0A2E2:  ADDWF  x0E,F
0A2E4:  MOVLW  00
0A2E6:  ADDWFC x0F,F
0A2E8:  MOVLW  19
0A2EA:  ADDWF  x0E,W
0A2EC:  MOVWF  01
0A2EE:  MOVLW  00
0A2F0:  ADDWFC x0F,W
0A2F2:  MOVWF  03
0A2F4:  MOVF   01,W
0A2F6:  ADDLW  EB
0A2F8:  MOVWF  01
0A2FA:  MOVLW  01
0A2FC:  ADDWFC 03,F
0A2FE:  MOVFF  01,707
0A302:  MOVFF  03,708
0A306:  CLRF   x09
0A308:  CLRF   x0A
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A30A:  MOVFF  705,FE9
0A30E:  MOVFF  706,FEA
0A312:  MOVF   FEF,W
0A314:  SUBLW  44
0A316:  BTFSS  FD8.2
0A318:  BRA    A408
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A31A:  MOVLW  01
0A31C:  ADDWF  x05,W
0A31E:  MOVWF  FE9
0A320:  MOVLW  00
0A322:  ADDWFC x06,W
0A324:  MOVWF  FEA
0A326:  MOVFF  FEF,70D
0A32A:  MOVLB  0
0A32C:  GOTO   562A
0A330:  MOVFF  01,70C
0A334:  MOVLB  7
0A336:  MOVF   x09,W
0A338:  ANDLW  0F
0A33A:  SUBWF  01,W
0A33C:  BNZ   A400
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A33E:  MOVF   x0A,W
0A340:  MULLW  04
0A342:  MOVF   FF3,W
0A344:  CLRF   x0D
0A346:  MOVWF  x0C
0A348:  MOVLW  6A
0A34A:  ADDWF  x0C,W
0A34C:  MOVWF  FE9
0A34E:  MOVLW  05
0A350:  ADDWFC x0D,W
0A352:  MOVWF  FEA
0A354:  MOVFF  FEC,745
0A358:  MOVF   FED,F
0A35A:  MOVFF  FEF,744
0A35E:  MOVLB  0
0A360:  CALL   55AE
0A364:  MOVFF  02,03
0A368:  MOVF   01,W
0A36A:  BNZ   A370
0A36C:  MOVF   03,F
0A36E:  BZ    A3F6
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A370:  MOVLB  7
0A372:  MOVF   x0A,W
0A374:  MULLW  04
0A376:  MOVF   FF3,W
0A378:  CLRF   x0D
0A37A:  MOVWF  x0C
0A37C:  MOVLW  6A
0A37E:  ADDWF  x0C,W
0A380:  MOVWF  FE9
0A382:  MOVLW  05
0A384:  ADDWFC x0D,W
0A386:  MOVWF  FEA
0A388:  MOVFF  FEC,747
0A38C:  MOVF   FED,F
0A38E:  MOVFF  FEF,746
0A392:  MOVFF  708,745
0A396:  MOVFF  707,744
0A39A:  MOVLB  0
0A39C:  CALL   5664
0A3A0:  MOVF   01,F
0A3A2:  BNZ   A3EE
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A3A4:  MOVLB  7
0A3A6:  MOVF   x0A,W
0A3A8:  MULLW  04
0A3AA:  MOVF   FF3,W
0A3AC:  CLRF   x0D
0A3AE:  MOVWF  x0C
0A3B0:  MOVLW  02
0A3B2:  ADDWF  x0C,W
0A3B4:  MOVWF  01
0A3B6:  MOVLW  00
0A3B8:  ADDWFC x0D,W
0A3BA:  MOVWF  03
0A3BC:  MOVF   01,W
0A3BE:  ADDLW  6A
0A3C0:  MOVWF  01
0A3C2:  MOVLW  05
0A3C4:  ADDWFC 03,F
0A3C6:  MOVFF  01,70C
0A3CA:  MOVFF  03,70D
0A3CE:  MOVFF  03,FEA
0A3D2:  MOVFF  01,FE9
0A3D6:  MOVFF  704,698
0A3DA:  MOVLB  0
0A3DC:  CALL   00BC
0A3E0:  MOVFF  01,70B
....................                return return_code;
0A3E4:  MOVLB  7
0A3E6:  MOVFF  70B,01
0A3EA:  BRA    A40C
0A3EC:  MOVLB  0
....................             }
....................             i++;
0A3EE:  MOVLB  7
0A3F0:  INCF   x0A,F
0A3F2:  BRA    A33E
0A3F4:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A3F6:  MOVLW  01
0A3F8:  MOVWF  01
0A3FA:  MOVLB  7
0A3FC:  BRA    A40C
....................       } else return 254; // NOT THIS ADDRESS
0A3FE:  BRA    A406
0A400:  MOVLW  FE
0A402:  MOVWF  01
0A404:  BRA    A40C
....................    } else return 255; // NOT THIS DEVICE TYPE
0A406:  BRA    A40C
0A408:  MOVLW  FF
0A40A:  MOVWF  01
0A40C:  MOVLB  0
0A40E:  GOTO   A4AE (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................     while (getNextSERReadIndex())
0A412:  GOTO   5554
0A416:  MOVF   01,F
0A418:  BTFSC  FD8.2
0A41A:  BRA    A536
....................     {
....................         int8 return_code;
....................         //echo_cmd(SRI);
....................         sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A41C:  MOVLW  04
0A41E:  MOVLB  7
0A420:  MOVWF  x45
0A422:  MOVLW  C1
0A424:  MOVWF  x44
0A426:  MOVLB  0
0A428:  CALL   55AE
0A42C:  MOVFF  02,03
0A430:  MOVF   01,W
0A432:  ADDLW  C1
0A434:  MOVLB  7
0A436:  MOVWF  x04
0A438:  MOVLW  04
0A43A:  ADDWFC 02,W
0A43C:  MOVWF  x05
0A43E:  CLRF   x45
0A440:  MOVFF  4BF,744
0A444:  CLRF   x47
0A446:  MOVLW  B5
0A448:  MOVWF  x46
0A44A:  MOVLB  0
0A44C:  CALL   0864
0A450:  MOVFF  02,707
0A454:  MOVFF  01,706
0A458:  MOVLW  06
0A45A:  MOVLB  7
0A45C:  ADDWF  x06,F
0A45E:  MOVLW  00
0A460:  ADDWFC x07,F
0A462:  MOVLW  EB
0A464:  ADDWF  x06,W
0A466:  MOVWF  01
0A468:  MOVLW  01
0A46A:  ADDWFC x07,W
0A46C:  MOVWF  03
0A46E:  MOVFF  01,708
0A472:  MOVWF  x09
0A474:  MOVFF  705,565
0A478:  MOVFF  704,564
0A47C:  MOVLW  24
0A47E:  MOVWF  x53
0A480:  MOVLB  0
0A482:  CALL   55E6
0A486:  MOVFF  565,FEA
0A48A:  MOVFF  564,FE9
0A48E:  CLRF   FEF
0A490:  MOVFF  709,FEA
0A494:  MOVFF  708,FE9
0A498:  CALL   5606
0A49C:  MOVLW  2C
0A49E:  MOVLB  7
0A4A0:  MOVWF  x53
0A4A2:  MOVLB  0
0A4A4:  CALL   55E6
....................         
....................         return_code = command_parser(SRI);
0A4A8:  MOVFF  4BF,704
0A4AC:  BRA    A28C
0A4AE:  MOVFF  01,703
....................         
....................         sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A4B2:  MOVLW  04
0A4B4:  MOVLB  7
0A4B6:  MOVWF  x45
0A4B8:  MOVLW  C1
0A4BA:  MOVWF  x44
0A4BC:  MOVLB  0
0A4BE:  CALL   55AE
0A4C2:  MOVF   01,W
0A4C4:  ADDLW  C1
0A4C6:  MOVLB  7
0A4C8:  MOVWF  x04
0A4CA:  MOVLW  04
0A4CC:  ADDWFC 02,W
0A4CE:  MOVWF  x05
0A4D0:  MOVF   x03,W
0A4D2:  MULLW  03
0A4D4:  MOVF   FF3,W
0A4D6:  CLRF   x07
0A4D8:  MOVWF  x06
0A4DA:  MOVLW  01
0A4DC:  ADDWF  x06,W
0A4DE:  MOVWF  01
0A4E0:  MOVLW  00
0A4E2:  ADDWFC x07,W
0A4E4:  MOVWF  03
0A4E6:  MOVF   01,W
0A4E8:  ADDLW  65
0A4EA:  MOVWF  FE9
0A4EC:  MOVLW  06
0A4EE:  ADDWFC 03,W
0A4F0:  MOVWF  FEA
0A4F2:  MOVFF  FEC,707
0A4F6:  MOVF   FED,F
0A4F8:  MOVFF  FEF,706
0A4FC:  MOVFF  705,565
0A500:  MOVFF  704,564
0A504:  MOVFF  565,FEA
0A508:  MOVFF  564,FE9
0A50C:  CLRF   FEF
0A50E:  MOVFF  707,FEA
0A512:  MOVFF  706,FE9
0A516:  MOVLB  0
0A518:  CALL   5606
....................         
....................         serial_out(retData);
0A51C:  MOVLW  04
0A51E:  MOVLB  7
0A520:  MOVWF  x05
0A522:  MOVLW  C1
0A524:  MOVWF  x04
0A526:  MOVLB  0
0A528:  CALL   500E
....................         
....................         resetSERcmd(SRI);
0A52C:  MOVFF  4BF,704
0A530:  CALL   0B46
0A534:  BRA    A412
....................     }
0A536:  GOTO   A986 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... //!#define DEBUG_1
.................... 
.................... void main()
0A53A:  CLRF   FF8
0A53C:  BCF    FF2.5
0A53E:  BSF    07.7
0A540:  MOVLB  E
0A542:  MOVLW  55
0A544:  MOVWF  x9B
0A546:  MOVLW  AA
0A548:  MOVWF  x9B
0A54A:  BCF    x9B.0
0A54C:  MOVLW  17
0A54E:  MOVWF  xB0
0A550:  MOVLW  13
0A552:  MOVWF  xB2
0A554:  MOVLW  09
0A556:  MOVWF  x8A
0A558:  MOVLW  0A
0A55A:  MOVWF  x8B
0A55C:  MOVLW  11
0A55E:  MOVWF  xEB
0A560:  MOVLW  12
0A562:  MOVWF  xED
0A564:  MOVLW  10
0A566:  MOVWF  xF4
0A568:  MOVLW  0F
0A56A:  MOVWF  xF5
0A56C:  MOVLW  09
0A56E:  MOVWF  xF8
0A570:  MOVLW  55
0A572:  MOVWF  x9B
0A574:  MOVLW  AA
0A576:  MOVWF  x9B
0A578:  BSF    x9B.0
0A57A:  CLRF   xD8
0A57C:  CLRF   xD5
0A57E:  CLRF   xD7
0A580:  MOVLW  08
0A582:  MOVWF  xD9
0A584:  MOVLW  60
0A586:  MOVWF  xD3
0A588:  MOVLW  AA
0A58A:  MOVLB  0
0A58C:  MOVWF  xFA
0A58E:  MOVLB  1
0A590:  BCF    x63.0
0A592:  CLRF   x75
0A594:  CLRF   x74
0A596:  CLRF   x73
0A598:  CLRF   x72
0A59A:  CLRF   x79
0A59C:  CLRF   x78
0A59E:  CLRF   x77
0A5A0:  CLRF   x76
0A5A2:  CLRF   x7D
0A5A4:  CLRF   x7C
0A5A6:  CLRF   x7B
0A5A8:  CLRF   x7A
0A5AA:  CLRF   x7F
0A5AC:  CLRF   x7E
0A5AE:  MOVLB  E
0A5B0:  BCF    x91.5
0A5B2:  MOVLW  00
0A5B4:  MOVWF  x90
0A5B6:  MOVLW  03
0A5B8:  MOVWF  x8E
0A5BA:  MOVLW  2A
0A5BC:  MOVWF  x91
0A5BE:  MOVLW  04
0A5C0:  MOVWF  F88
0A5C2:  MOVWF  F88
0A5C4:  MOVWF  F88
0A5C6:  MOVLB  1
0A5C8:  CLRF   xD0
0A5CA:  CLRF   xD1
0A5CC:  CLRF   xD2
0A5CE:  CLRF   xD3
0A5D0:  BCF    F95.5
0A5D2:  MOVLW  40
0A5D4:  MOVWF  F94
0A5D6:  MOVLW  9F
0A5D8:  MOVWF  F92
0A5DA:  MOVLW  3A
0A5DC:  MOVWF  F95
0A5DE:  MOVLW  93
0A5E0:  MOVWF  F89
0A5E2:  MOVWF  F89
0A5E4:  MOVLB  4
0A5E6:  CLRF   xBF
0A5E8:  CLRF   xC0
0A5EA:  MOVLB  5
0A5EC:  CLRF   x61
0A5EE:  CLRF   x62
0A5F0:  MOVLB  1
0A5F2:  BCF    x63.1
0A5F4:  MOVLB  5
0A5F6:  CLRF   x63
0A5F8:  BSF    F9E.3
0A5FA:  MOVLW  7C
0A5FC:  MOVWF  F9A
0A5FE:  MOVLW  00
0A600:  MOVWF  F9B
0A602:  MOVLW  A6
0A604:  MOVWF  F9D
0A606:  MOVLW  90
0A608:  MOVWF  F9C
0A60A:  CLRF   x65
0A60C:  CLRF   x64
0A60E:  CLRF   x69
0A610:  CLRF   x68
0A612:  CLRF   x67
0A614:  CLRF   x66
0A616:  MOVLB  F
0A618:  CLRF   x0C
0A61A:  CLRF   x14
0A61C:  CLRF   x1C
0A61E:  CLRF   x21
0A620:  CLRF   x29
0A622:  CLRF   x35
0A624:  CLRF   x36
0A626:  CLRF   x37
0A628:  CLRF   x34
0A62A:  CLRF   x31
0A62C:  CLRF   x32
0A62E:  CLRF   x33
0A630:  CLRF   x30
0A632:  MOVLW  56
0A634:  MOVLB  5
0A636:  MOVWF  x6D
0A638:  MOVLW  FC
0A63A:  MOVWF  x6C
0A63C:  MOVLW  57
0A63E:  MOVWF  x71
0A640:  MOVLW  40
0A642:  MOVWF  x70
0A644:  MOVLW  5C
0A646:  MOVWF  x75
0A648:  MOVLW  88
0A64A:  MOVWF  x74
0A64C:  MOVLW  5E
0A64E:  MOVWF  x79
0A650:  MOVLW  6E
0A652:  MOVWF  x78
0A654:  MOVLW  60
0A656:  MOVWF  x7D
0A658:  MOVLW  46
0A65A:  MOVWF  x7C
0A65C:  MOVLW  61
0A65E:  MOVWF  x81
0A660:  MOVLW  D2
0A662:  MOVWF  x80
0A664:  MOVLW  66
0A666:  MOVWF  x85
0A668:  MOVLW  72
0A66A:  MOVWF  x84
0A66C:  MOVLW  6E
0A66E:  MOVWF  x89
0A670:  MOVLW  44
0A672:  MOVWF  x88
0A674:  MOVLW  71
0A676:  MOVWF  x8D
0A678:  MOVLW  24
0A67A:  MOVWF  x8C
0A67C:  MOVLW  72
0A67E:  MOVWF  x91
0A680:  MOVLW  86
0A682:  MOVWF  x90
0A684:  MOVLW  74
0A686:  MOVWF  x95
0A688:  MOVLW  44
0A68A:  MOVWF  x94
0A68C:  MOVLW  77
0A68E:  MOVWF  x99
0A690:  MOVLW  FA
0A692:  MOVWF  x98
0A694:  MOVLW  7D
0A696:  MOVWF  x9D
0A698:  MOVLW  56
0A69A:  MOVWF  x9C
0A69C:  MOVLW  80
0A69E:  MOVWF  xA1
0A6A0:  MOVLW  EE
0A6A2:  MOVWF  xA0
0A6A4:  MOVLW  86
0A6A6:  MOVWF  xA5
0A6A8:  MOVLW  1A
0A6AA:  MOVWF  xA4
0A6AC:  MOVLW  86
0A6AE:  MOVWF  xA9
0A6B0:  MOVLW  20
0A6B2:  MOVWF  xA8
0A6B4:  MOVLW  8C
0A6B6:  MOVWF  xAD
0A6B8:  MOVLW  94
0A6BA:  MOVWF  xAC
0A6BC:  MOVLW  91
0A6BE:  MOVWF  xB1
0A6C0:  MOVLW  F8
0A6C2:  MOVWF  xB0
0A6C4:  MOVLW  99
0A6C6:  MOVWF  xB5
0A6C8:  MOVLW  1A
0A6CA:  MOVWF  xB4
0A6CC:  MOVLW  9A
0A6CE:  MOVWF  xB9
0A6D0:  MOVLW  7C
0A6D2:  MOVWF  xB8
0A6D4:  MOVLW  9C
0A6D6:  MOVWF  xBD
0A6D8:  MOVLW  EE
0A6DA:  MOVWF  xBC
0A6DC:  MOVLW  9C
0A6DE:  MOVWF  xC1
0A6E0:  MOVLW  FA
0A6E2:  MOVWF  xC0
0A6E4:  MOVLW  9D
0A6E6:  MOVWF  xC5
0A6E8:  MOVLW  06
0A6EA:  MOVWF  xC4
0A6EC:  MOVLW  9F
0A6EE:  MOVWF  xC9
0A6F0:  MOVLW  40
0A6F2:  MOVWF  xC8
0A6F4:  MOVLW  A2
0A6F6:  MOVWF  xCD
0A6F8:  MOVLW  86
0A6FA:  MOVWF  xCC
0A6FC:  BRA    A8E4
0A6FE:  DATA 02,00
0A700:  DATA 1A,00
0A702:  DATA 00,0C
0A704:  DATA 00,20
0A706:  DATA 78,23
0A708:  DATA D7,0A
0A70A:  DATA 7D,19
0A70C:  DATA 99,9A
0A70E:  DATA 7B,4C
0A710:  DATA CC,CD
0A712:  DATA 1C,C0
0A714:  DATA 00,0C
0A716:  DATA 80,78
0A718:  DATA 23,D7
0A71A:  DATA 0A,7D
0A71C:  DATA 19,99
0A71E:  DATA 9A,7B
0A720:  DATA 4C,CC
0A722:  DATA CD,1C
0A724:  DATA C0,00
0A726:  DATA 01,80
0A728:  DATA 02,09
0A72A:  DATA C0,00
0A72C:  DATA 05,80
0A72E:  DATA 7F,00
0A730:  DATA 00,00
0A732:  DATA 7F,0B
0A734:  DATA C0,00
0A736:  DATA 05,80
0A738:  DATA 7F,00
0A73A:  DATA 00,00
0A73C:  DATA 7F,07
0A73E:  DATA C0,00
0A740:  DATA 01,80
0A742:  DATA 7F,17
0A744:  DATA C0,00
0A746:  DATA 01,80
0A748:  DATA 7F,17
0A74A:  DATA C0,00
0A74C:  DATA 04,80
0A74E:  DATA 79,B7
0A750:  DATA F3,BD
0A752:  DATA 04,C0
0A754:  DATA 00,04
0A756:  DATA 80,7C
0A758:  DATA 59,DF
0A75A:  DATA 4E,04
0A75C:  DATA C0,00
0A75E:  DATA 04,80
0A760:  DATA 78,0A
0A762:  DATA 28,88
0A764:  DATA 04,C0
0A766:  DATA 00,04
0A768:  DATA 80,78
0A76A:  DATA 05,EA
0A76C:  DATA 16,04
0A76E:  DATA C0,00
0A770:  DATA 04,80
0A772:  DATA 78,1E
0A774:  DATA 33,D7
0A776:  DATA 04,C0
0A778:  DATA 00,04
0A77A:  DATA 80,77
0A77C:  DATA 68,7B
0A77E:  DATA BB,04
0A780:  DATA C0,00
0A782:  DATA 04,80
0A784:  DATA 77,68
0A786:  DATA 0D,C6
0A788:  DATA 68,40
0A78A:  DATA FB,00
0A78C:  DATA 0E,41
0A78E:  DATA 64,00
0A790:  DATA 17,41
0A792:  DATA D4,00
0A794:  DATA 3C,45
0A796:  DATA 25,00
0A798:  DATA 02,05
0A79A:  DATA 6A,CE
0A79C:  DATA 05,02
0A79E:  DATA 05,6E
0A7A0:  DATA D1,05
0A7A2:  DATA 02,05
0A7A4:  DATA 72,D4
0A7A6:  DATA 05,02
0A7A8:  DATA 05,76
0A7AA:  DATA DB,05
0A7AC:  DATA 02,05
0A7AE:  DATA 7A,E2
0A7B0:  DATA 05,02
0A7B2:  DATA 05,7E
0A7B4:  DATA EA,05
0A7B6:  DATA 02,05
0A7B8:  DATA 82,F2
0A7BA:  DATA 05,02
0A7BC:  DATA 05,86
0A7BE:  DATA F7,05
0A7C0:  DATA 02,05
0A7C2:  DATA 8A,FC
0A7C4:  DATA 05,02
0A7C6:  DATA 05,8E
0A7C8:  DATA 00,06
0A7CA:  DATA 02,05
0A7CC:  DATA 92,04
0A7CE:  DATA 06,02
0A7D0:  DATA 05,96
0A7D2:  DATA 0B,06
0A7D4:  DATA 02,05
0A7D6:  DATA 9A,11
0A7D8:  DATA 06,02
0A7DA:  DATA 05,9E
0A7DC:  DATA 17,06
0A7DE:  DATA 02,05
0A7E0:  DATA A2,1D
0A7E2:  DATA 06,02
0A7E4:  DATA 05,A6
0A7E6:  DATA 23,06
0A7E8:  DATA 02,05
0A7EA:  DATA AA,28
0A7EC:  DATA 06,02
0A7EE:  DATA 05,AE
0A7F0:  DATA 31,06
0A7F2:  DATA 02,05
0A7F4:  DATA B2,39
0A7F6:  DATA 06,02
0A7F8:  DATA 05,B6
0A7FA:  DATA 40,06
0A7FC:  DATA 02,05
0A7FE:  DATA BA,47
0A800:  DATA 06,02
0A802:  DATA 05,BE
0A804:  DATA 4F,06
0A806:  DATA 02,05
0A808:  DATA C2,58
0A80A:  DATA 06,02
0A80C:  DATA 05,C6
0A80E:  DATA 5E,06
0A810:  DATA 02,05
0A812:  DATA CA,63
0A814:  DATA 06,94
0A816:  DATA 05,CE
0A818:  DATA 67,72
0A81A:  DATA 00,67
0A81C:  DATA 73,00
0A81E:  DATA 67,43
0A820:  DATA 68,4D
0A822:  DATA 61,70
0A824:  DATA 00,73
0A826:  DATA 43,68
0A828:  DATA 4D,61
0A82A:  DATA 70,00
0A82C:  DATA 67,43
0A82E:  DATA 68,4D
0A830:  DATA 6F,64
0A832:  DATA 65,00
0A834:  DATA 73,43
0A836:  DATA 68,4D
0A838:  DATA 6F,64
0A83A:  DATA 65,00
0A83C:  DATA 67,50
0A83E:  DATA 49,44
0A840:  DATA 00,73
0A842:  DATA 50,49
0A844:  DATA 44,00
0A846:  DATA 67,53
0A848:  DATA 50,00
0A84A:  DATA 73,53
0A84C:  DATA 50,00
0A84E:  DATA 67,53
0A850:  DATA 43,61
0A852:  DATA 6C,73
0A854:  DATA 00,67
0A856:  DATA 53,43
0A858:  DATA 61,6C
0A85A:  DATA 00,73
0A85C:  DATA 53,43
0A85E:  DATA 61,6C
0A860:  DATA 00,67
0A862:  DATA 4D,43
0A864:  DATA 61,6C
0A866:  DATA 00,73
0A868:  DATA 4D,43
0A86A:  DATA 61,6C
0A86C:  DATA 00,67
0A86E:  DATA 4D,6F
0A870:  DATA 6E,00
0A872:  DATA 67,50
0A874:  DATA 49,44
0A876:  DATA 64,61
0A878:  DATA 74,61
0A87A:  DATA 00,67
0A87C:  DATA 49,50
0A87E:  DATA 64,61
0A880:  DATA 74,61
0A882:  DATA 00,67
0A884:  DATA 4D,61
0A886:  DATA 6E,4F
0A888:  DATA 50,00
0A88A:  DATA 73,4D
0A88C:  DATA 61,6E
0A88E:  DATA 4F,50
0A890:  DATA 00,73
0A892:  DATA 46,69
0A894:  DATA 6C,74
0A896:  DATA 4F,6E
0A898:  DATA 00,73
0A89A:  DATA 46,69
0A89C:  DATA 6C,74
0A89E:  DATA 4F,66
0A8A0:  DATA 66,00
0A8A2:  DATA 73,48
0A8A4:  DATA 6F,6D
0A8A6:  DATA 65,00
0A8A8:  DATA 67,54
0A8AA:  DATA 6C,6D
0A8AC:  DATA 04,C0
0A8AE:  DATA 00,32
0A8B0:  DATA 80,6E
0A8B2:  DATA 06,01
0A8B4:  DATA 76,06
0A8B6:  DATA 02,86
0A8B8:  DATA 06,53
0A8BA:  DATA 55,43
0A8BC:  DATA 43,45
0A8BE:  DATA 53,53
0A8C0:  DATA 00,49
0A8C2:  DATA 4E,56
0A8C4:  DATA 41,4C
0A8C6:  DATA 49,44
0A8C8:  DATA 20,43
0A8CA:  DATA 4F,4D
0A8CC:  DATA 4D,41
0A8CE:  DATA 4E,44
0A8D0:  DATA 00,49
0A8D2:  DATA 4E,56
0A8D4:  DATA 41,4C
0A8D6:  DATA 49,44
0A8D8:  DATA 20,50
0A8DA:  DATA 41,52
0A8DC:  DATA 41,4D
0A8DE:  DATA 45,54
0A8E0:  DATA 45,52
0A8E2:  DATA 00,00
0A8E4:  MOVLW  00
0A8E6:  MOVWF  FF8
0A8E8:  MOVLW  A6
0A8EA:  MOVWF  FF7
0A8EC:  MOVLW  FE
0A8EE:  MOVWF  FF6
0A8F0:  TBLRD*+
0A8F2:  MOVF   FF5,W
0A8F4:  MOVWF  00
0A8F6:  XORLW  00
0A8F8:  BZ    A920
0A8FA:  TBLRD*+
0A8FC:  MOVF   FF5,W
0A8FE:  MOVWF  01
0A900:  BTFSC  FE8.7
0A902:  BRA    A90E
0A904:  ANDLW  3F
0A906:  MOVWF  FEA
0A908:  TBLRD*+
0A90A:  MOVFF  FF5,FE9
0A90E:  BTFSC  01.6
0A910:  TBLRD*+
0A912:  BTFSS  01.6
0A914:  TBLRD*+
0A916:  MOVFF  FF5,FEE
0A91A:  DCFSNZ 00,F
0A91C:  BRA    A8F0
0A91E:  BRA    A912
0A920:  CLRF   FF8
0A922:  MOVLB  6
0A924:  CLRF   x9A
0A926:  MOVLW  64
0A928:  MOVWF  x99
0A92A:  CLRF   x9C
0A92C:  CLRF   x9B
0A92E:  CLRF   x9E
0A930:  CLRF   x9D
.................... {
....................     int16 loopDelay = 100;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A932:  MOVLB  0
0A934:  GOTO   0394
....................     params_init();                // load parameters
0A938:  GOTO   063C
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A93C:  GOTO   0A8A
....................     control_init();               // initialize the output control DACs
0A940:  GOTO   0B22
....................     serial_init();                // setup the serial port
0A944:  GOTO   0CC0
....................     event_timer_init();
0A948:  GOTO   0CE2
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A94C:  MOVLW  C0
0A94E:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A950:  MOVLB  6
0A952:  CLRF   x9F
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A954:  MOVLB  0
0A956:  GOTO   10BA
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A95A:  GOTO   440A
....................       
....................         if (controlCounter >= 2){
0A95E:  MOVLB  6
0A960:  MOVF   x9C,F
0A962:  BNZ   A96A
0A964:  MOVF   x9B,W
0A966:  SUBLW  01
0A968:  BC    A978
....................             control_task();
0A96A:  MOVLB  0
0A96C:  GOTO   4F62
....................             controlCounter = 0;
0A970:  MOVLB  6
0A972:  CLRF   x9C
0A974:  CLRF   x9B
....................         }else controlCounter++;
0A976:  BRA    A97E
0A978:  INCF   x9B,F
0A97A:  BTFSC  FD8.2
0A97C:  INCF   x9C,F
....................       
....................         serial_task();             
0A97E:  MOVLB  0
0A980:  GOTO   5048
....................         command_handler_task();    //execute commands
0A984:  BRA    A412
....................         
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
....................             ch = !ch;
....................             debugCounter = 0;
....................         }else debugCounter++;
.................... //!        fprintf(ICD_STREAM, "%s\n", pBuff);
....................         serial_out(pBuff);
....................         #endif
....................       
....................         delay_ms(loopDelay);
0A986:  MOVFF  69A,703
0A98A:  MOVLB  7
0A98C:  INCF   x03,F
0A98E:  DECF   x03,F
0A990:  BTFSC  FD8.2
0A992:  BRA    A9A0
0A994:  SETF   x09
0A996:  MOVLB  0
0A998:  CALL   042A
0A99C:  MOVLB  7
0A99E:  BRA    A98E
0A9A0:  MOVFF  699,709
0A9A4:  MOVLB  0
0A9A6:  CALL   042A
0A9AA:  BRA    A950
....................     }
.................... }
0A9AC:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
