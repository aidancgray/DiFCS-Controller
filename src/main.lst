CCS PCH C Compiler, Version 5.109, 62303               04-Dec-25 15:07

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43344 bytes (66%)
                           Largest free fragment is 22190
               RAM used:   1658 (46%) at main() level
                           1764 (49%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A23A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,31
00336:  DATA 30,34
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
00358:  DATA 23,44
0035A:  DATA 30,2C
0035C:  DATA 43,4E
0035E:  DATA 54,2C
00360:  DATA 25,75
00362:  DATA 2C,25
00364:  DATA 2E,30
00366:  DATA 66,2C
00368:  DATA 25,2E
0036A:  DATA 30,66
0036C:  DATA 0A,00
0036E:  DATA 23,44
00370:  DATA 30,2C
00372:  DATA 50,4F
00374:  DATA 53,2C
00376:  DATA 25,75
00378:  DATA 2C,25
0037A:  DATA 33,2E
0037C:  DATA 33,66
0037E:  DATA 0A,00
00380:  DATA 23,44
00382:  DATA 30,2C
00384:  DATA 4F,55
00386:  DATA 54,2C
00388:  DATA 25,75
0038A:  DATA 2C,2D
0038C:  DATA 2C,25
0038E:  DATA 4C,75
00390:  DATA 0A,00
00392:  DATA 23,44
00394:  DATA 30,2C
00396:  DATA 4F,55
00398:  DATA 54,2C
0039A:  DATA 25,75
0039C:  DATA 2C,2B
0039E:  DATA 2C,25
003A0:  DATA 4C,75
003A2:  DATA 0A,00
*
006CA:  ADDWF  FE8,W
006CC:  CLRF   FF7
006CE:  RLCF   FF7,F
006D0:  ADDLW  E5
006D2:  MOVWF  FF6
006D4:  MOVLW  06
006D6:  ADDWFC FF7,F
006D8:  TBLRD*-
006DA:  MOVF   FF5,W
006DC:  MOVWF  FFA
006DE:  TBLRD*
006E0:  MOVF   FF5,W
006E2:  MOVWF  FF9
006E4:  DATA 94,06
006E6:  DATA 9E,06
006E8:  DATA A8,06
006EA:  DATA B2,06
*
00876:  MOVLB  6
00878:  MOVF   xB2,W
0087A:  MULWF  xB4
0087C:  MOVFF  FF3,01
00880:  MOVFF  FF4,00
00884:  MULWF  xB5
00886:  MOVF   FF3,W
00888:  ADDWF  00,F
0088A:  MOVF   xB3,W
0088C:  MULWF  xB4
0088E:  MOVF   FF3,W
00890:  ADDWFC 00,W
00892:  MOVWF  02
00894:  MOVLB  0
00896:  RETURN 0
00898:  MOVLB  6
0089A:  MOVF   xB0,W
0089C:  CLRF   01
0089E:  SUBWF  xAF,W
008A0:  BC    08A8
008A2:  MOVFF  6AF,00
008A6:  BRA    08C0
008A8:  CLRF   00
008AA:  MOVLW  08
008AC:  MOVWF  xB1
008AE:  RLCF   xAF,F
008B0:  RLCF   00,F
008B2:  MOVF   xB0,W
008B4:  SUBWF  00,W
008B6:  BTFSC  FD8.0
008B8:  MOVWF  00
008BA:  RLCF   01,F
008BC:  DECFSZ xB1,F
008BE:  BRA    08AE
008C0:  MOVLB  0
008C2:  RETURN 0
*
00D28:  MOVLW  8E
00D2A:  MOVWF  00
00D2C:  MOVFF  6C1,01
00D30:  MOVFF  6C0,02
00D34:  CLRF   03
00D36:  MOVF   01,F
00D38:  BNZ   0D4C
00D3A:  MOVFF  02,01
00D3E:  CLRF   02
00D40:  MOVLW  08
00D42:  SUBWF  00,F
00D44:  MOVF   01,F
00D46:  BNZ   0D4C
00D48:  CLRF   00
00D4A:  BRA    0D5C
00D4C:  BCF    FD8.0
00D4E:  BTFSC  01.7
00D50:  BRA    0D5A
00D52:  RLCF   02,F
00D54:  RLCF   01,F
00D56:  DECF   00,F
00D58:  BRA    0D4C
00D5A:  BCF    01.7
00D5C:  RETURN 0
00D5E:  MOVLB  6
00D60:  MOVF   xC1,W
00D62:  BTFSC  FD8.2
00D64:  BRA    0E48
00D66:  MOVWF  00
00D68:  MOVF   xC5,W
00D6A:  BTFSC  FD8.2
00D6C:  BRA    0E48
00D6E:  ADDWF  00,F
00D70:  BNC   0D7A
00D72:  MOVLW  81
00D74:  ADDWF  00,F
00D76:  BC    0E48
00D78:  BRA    0D82
00D7A:  MOVLW  7F
00D7C:  SUBWF  00,F
00D7E:  BNC   0E48
00D80:  BZ    0E48
00D82:  MOVFF  6C2,6C9
00D86:  MOVF   xC6,W
00D88:  XORWF  xC9,F
00D8A:  BSF    xC2.7
00D8C:  BSF    xC6.7
00D8E:  MOVF   xC4,W
00D90:  MULWF  xC8
00D92:  MOVFF  FF4,6CB
00D96:  MOVF   xC3,W
00D98:  MULWF  xC7
00D9A:  MOVFF  FF4,03
00D9E:  MOVFF  FF3,6CA
00DA2:  MULWF  xC8
00DA4:  MOVF   FF3,W
00DA6:  ADDWF  xCB,F
00DA8:  MOVF   FF4,W
00DAA:  ADDWFC xCA,F
00DAC:  MOVLW  00
00DAE:  ADDWFC 03,F
00DB0:  MOVF   xC4,W
00DB2:  MULWF  xC7
00DB4:  MOVF   FF3,W
00DB6:  ADDWF  xCB,F
00DB8:  MOVF   FF4,W
00DBA:  ADDWFC xCA,F
00DBC:  MOVLW  00
00DBE:  CLRF   02
00DC0:  ADDWFC 03,F
00DC2:  ADDWFC 02,F
00DC4:  MOVF   xC2,W
00DC6:  MULWF  xC8
00DC8:  MOVF   FF3,W
00DCA:  ADDWF  xCA,F
00DCC:  MOVF   FF4,W
00DCE:  ADDWFC 03,F
00DD0:  MOVLW  00
00DD2:  ADDWFC 02,F
00DD4:  MOVF   xC2,W
00DD6:  MULWF  xC7
00DD8:  MOVF   FF3,W
00DDA:  ADDWF  03,F
00DDC:  MOVF   FF4,W
00DDE:  ADDWFC 02,F
00DE0:  MOVLW  00
00DE2:  CLRF   01
00DE4:  ADDWFC 01,F
00DE6:  MOVF   xC4,W
00DE8:  MULWF  xC6
00DEA:  MOVF   FF3,W
00DEC:  ADDWF  xCA,F
00DEE:  MOVF   FF4,W
00DF0:  ADDWFC 03,F
00DF2:  MOVLW  00
00DF4:  ADDWFC 02,F
00DF6:  ADDWFC 01,F
00DF8:  MOVF   xC3,W
00DFA:  MULWF  xC6
00DFC:  MOVF   FF3,W
00DFE:  ADDWF  03,F
00E00:  MOVF   FF4,W
00E02:  ADDWFC 02,F
00E04:  MOVLW  00
00E06:  ADDWFC 01,F
00E08:  MOVF   xC2,W
00E0A:  MULWF  xC6
00E0C:  MOVF   FF3,W
00E0E:  ADDWF  02,F
00E10:  MOVF   FF4,W
00E12:  ADDWFC 01,F
00E14:  INCF   00,F
00E16:  BTFSC  01.7
00E18:  BRA    0E24
00E1A:  RLCF   xCA,F
00E1C:  RLCF   03,F
00E1E:  RLCF   02,F
00E20:  RLCF   01,F
00E22:  DECF   00,F
00E24:  MOVLW  00
00E26:  BTFSS  xCA.7
00E28:  BRA    0E3E
00E2A:  INCF   03,F
00E2C:  ADDWFC 02,F
00E2E:  ADDWFC 01,F
00E30:  MOVF   01,W
00E32:  BNZ   0E3E
00E34:  MOVF   02,W
00E36:  BNZ   0E3E
00E38:  MOVF   03,W
00E3A:  BNZ   0E3E
00E3C:  INCF   00,F
00E3E:  BTFSC  xC9.7
00E40:  BSF    01.7
00E42:  BTFSS  xC9.7
00E44:  BCF    01.7
00E46:  BRA    0E50
00E48:  CLRF   00
00E4A:  CLRF   01
00E4C:  CLRF   02
00E4E:  CLRF   03
00E50:  MOVLB  0
00E52:  RETURN 0
00E54:  MOVLW  80
00E56:  BTFSS  FD8.1
00E58:  BRA    0E5E
00E5A:  MOVLB  6
00E5C:  XORWF  xC5,F
00E5E:  MOVLB  6
00E60:  CLRF   xCA
00E62:  CLRF   xCB
00E64:  MOVFF  6C1,6C9
00E68:  MOVF   xC5,W
00E6A:  XORWF  xC9,F
00E6C:  MOVF   xC0,W
00E6E:  BTFSC  FD8.2
00E70:  BRA    1030
00E72:  MOVWF  xC8
00E74:  MOVWF  00
00E76:  MOVF   xC4,W
00E78:  BTFSC  FD8.2
00E7A:  BRA    1042
00E7C:  SUBWF  xC8,F
00E7E:  BTFSC  FD8.2
00E80:  BRA    0F88
00E82:  BNC   0F00
00E84:  MOVFF  6C5,6CE
00E88:  BSF    xCE.7
00E8A:  MOVFF  6C6,6CD
00E8E:  MOVFF  6C7,6CC
00E92:  CLRF   xCB
00E94:  BCF    FD8.0
00E96:  RRCF   xCE,F
00E98:  RRCF   xCD,F
00E9A:  RRCF   xCC,F
00E9C:  RRCF   xCB,F
00E9E:  DECFSZ xC8,F
00EA0:  BRA    0E92
00EA2:  BTFSS  xC9.7
00EA4:  BRA    0EAC
00EA6:  BSF    xCA.0
00EA8:  BRA    106A
00EAA:  BCF    xCA.0
00EAC:  BCF    xC8.0
00EAE:  BSF    xCA.4
00EB0:  MOVLW  06
00EB2:  MOVWF  FEA
00EB4:  MOVLW  C3
00EB6:  MOVWF  FE9
00EB8:  BRA    1090
00EBA:  BCF    xCA.4
00EBC:  BTFSC  xC9.7
00EBE:  BRA    0ED4
00EC0:  BTFSS  xC8.0
00EC2:  BRA    0EEA
00EC4:  RRCF   xCE,F
00EC6:  RRCF   xCD,F
00EC8:  RRCF   xCC,F
00ECA:  RRCF   xCB,F
00ECC:  INCF   00,F
00ECE:  BTFSC  FD8.2
00ED0:  BRA    1060
00ED2:  BRA    0EEA
00ED4:  BTFSC  xCE.7
00ED6:  BRA    0EF0
00ED8:  BCF    FD8.0
00EDA:  RLCF   xCB,F
00EDC:  RLCF   xCC,F
00EDE:  RLCF   xCD,F
00EE0:  RLCF   xCE,F
00EE2:  DECF   00,F
00EE4:  BTFSC  FD8.2
00EE6:  BRA    1060
00EE8:  BRA    0ED4
00EEA:  BSF    xCA.6
00EEC:  BRA    0FC8
00EEE:  BCF    xCA.6
00EF0:  MOVFF  6C1,6C9
00EF4:  BTFSS  xC1.7
00EF6:  BRA    0EFC
00EF8:  BSF    xCE.7
00EFA:  BRA    1052
00EFC:  BCF    xCE.7
00EFE:  BRA    1052
00F00:  MOVFF  6C4,6C8
00F04:  MOVFF  6C4,00
00F08:  MOVF   xC0,W
00F0A:  SUBWF  xC8,F
00F0C:  MOVFF  6C1,6CE
00F10:  BSF    xCE.7
00F12:  MOVFF  6C2,6CD
00F16:  MOVFF  6C3,6CC
00F1A:  CLRF   xCB
00F1C:  BCF    FD8.0
00F1E:  RRCF   xCE,F
00F20:  RRCF   xCD,F
00F22:  RRCF   xCC,F
00F24:  RRCF   xCB,F
00F26:  DECFSZ xC8,F
00F28:  BRA    0F1A
00F2A:  BTFSS  xC9.7
00F2C:  BRA    0F34
00F2E:  BSF    xCA.1
00F30:  BRA    106A
00F32:  BCF    xCA.1
00F34:  BCF    xC8.0
00F36:  BSF    xCA.5
00F38:  MOVLW  06
00F3A:  MOVWF  FEA
00F3C:  MOVLW  C7
00F3E:  MOVWF  FE9
00F40:  BRA    1090
00F42:  BCF    xCA.5
00F44:  BTFSC  xC9.7
00F46:  BRA    0F5C
00F48:  BTFSS  xC8.0
00F4A:  BRA    0F72
00F4C:  RRCF   xCE,F
00F4E:  RRCF   xCD,F
00F50:  RRCF   xCC,F
00F52:  RRCF   xCB,F
00F54:  INCF   00,F
00F56:  BTFSC  FD8.2
00F58:  BRA    1060
00F5A:  BRA    0F72
00F5C:  BTFSC  xCE.7
00F5E:  BRA    0F78
00F60:  BCF    FD8.0
00F62:  RLCF   xCB,F
00F64:  RLCF   xCC,F
00F66:  RLCF   xCD,F
00F68:  RLCF   xCE,F
00F6A:  DECF   00,F
00F6C:  BTFSC  FD8.2
00F6E:  BRA    1060
00F70:  BRA    0F5C
00F72:  BSF    xCA.7
00F74:  BRA    0FC8
00F76:  BCF    xCA.7
00F78:  MOVFF  6C5,6C9
00F7C:  BTFSS  xC5.7
00F7E:  BRA    0F84
00F80:  BSF    xCE.7
00F82:  BRA    1052
00F84:  BCF    xCE.7
00F86:  BRA    1052
00F88:  MOVFF  6C5,6CE
00F8C:  BSF    xCE.7
00F8E:  MOVFF  6C6,6CD
00F92:  MOVFF  6C7,6CC
00F96:  BTFSS  xC9.7
00F98:  BRA    0FA2
00F9A:  BCF    xCE.7
00F9C:  BSF    xCA.2
00F9E:  BRA    106A
00FA0:  BCF    xCA.2
00FA2:  CLRF   xCB
00FA4:  BCF    xC8.0
00FA6:  MOVLW  06
00FA8:  MOVWF  FEA
00FAA:  MOVLW  C3
00FAC:  MOVWF  FE9
00FAE:  BRA    1090
00FB0:  BTFSC  xC9.7
00FB2:  BRA    0FEC
00FB4:  MOVFF  6C1,6C9
00FB8:  BTFSS  xC8.0
00FBA:  BRA    0FC8
00FBC:  RRCF   xCE,F
00FBE:  RRCF   xCD,F
00FC0:  RRCF   xCC,F
00FC2:  RRCF   xCB,F
00FC4:  INCF   00,F
00FC6:  BZ    1060
00FC8:  BTFSS  xCB.7
00FCA:  BRA    0FE2
00FCC:  INCF   xCC,F
00FCE:  BNZ   0FE2
00FD0:  INCF   xCD,F
00FD2:  BNZ   0FE2
00FD4:  INCF   xCE,F
00FD6:  BNZ   0FE2
00FD8:  RRCF   xCE,F
00FDA:  RRCF   xCD,F
00FDC:  RRCF   xCC,F
00FDE:  INCF   00,F
00FE0:  BZ    1060
00FE2:  BTFSC  xCA.6
00FE4:  BRA    0EEE
00FE6:  BTFSC  xCA.7
00FE8:  BRA    0F76
00FEA:  BRA    1024
00FEC:  MOVLW  80
00FEE:  XORWF  xCE,F
00FF0:  BTFSS  xCE.7
00FF2:  BRA    0FFC
00FF4:  BRA    106A
00FF6:  MOVFF  6C5,6C9
00FFA:  BRA    1010
00FFC:  MOVFF  6C1,6C9
01000:  MOVF   xCE,F
01002:  BNZ   1010
01004:  MOVF   xCD,F
01006:  BNZ   1010
01008:  MOVF   xCC,F
0100A:  BNZ   1010
0100C:  CLRF   00
0100E:  BRA    1052
01010:  BTFSC  xCE.7
01012:  BRA    1024
01014:  BCF    FD8.0
01016:  RLCF   xCB,F
01018:  RLCF   xCC,F
0101A:  RLCF   xCD,F
0101C:  RLCF   xCE,F
0101E:  DECFSZ 00,F
01020:  BRA    1010
01022:  BRA    1060
01024:  BTFSS  xC9.7
01026:  BRA    102C
01028:  BSF    xCE.7
0102A:  BRA    1052
0102C:  BCF    xCE.7
0102E:  BRA    1052
01030:  MOVFF  6C4,00
01034:  MOVFF  6C5,6CE
01038:  MOVFF  6C6,6CD
0103C:  MOVFF  6C7,6CC
01040:  BRA    1052
01042:  MOVFF  6C0,00
01046:  MOVFF  6C1,6CE
0104A:  MOVFF  6C2,6CD
0104E:  MOVFF  6C3,6CC
01052:  MOVFF  6CE,01
01056:  MOVFF  6CD,02
0105A:  MOVFF  6CC,03
0105E:  BRA    10C8
01060:  CLRF   00
01062:  CLRF   01
01064:  CLRF   02
01066:  CLRF   03
01068:  BRA    10C8
0106A:  CLRF   xCB
0106C:  COMF   xCC,F
0106E:  COMF   xCD,F
01070:  COMF   xCE,F
01072:  COMF   xCB,F
01074:  INCF   xCB,F
01076:  BNZ   1082
01078:  INCF   xCC,F
0107A:  BNZ   1082
0107C:  INCF   xCD,F
0107E:  BNZ   1082
01080:  INCF   xCE,F
01082:  BTFSC  xCA.0
01084:  BRA    0EAA
01086:  BTFSC  xCA.1
01088:  BRA    0F32
0108A:  BTFSC  xCA.2
0108C:  BRA    0FA0
0108E:  BRA    0FF6
01090:  MOVF   FEF,W
01092:  ADDWF  xCC,F
01094:  BNC   10A0
01096:  INCF   xCD,F
01098:  BNZ   10A0
0109A:  INCF   xCE,F
0109C:  BTFSC  FD8.2
0109E:  BSF    xC8.0
010A0:  MOVF   FED,F
010A2:  MOVF   FEF,W
010A4:  ADDWF  xCD,F
010A6:  BNC   10AE
010A8:  INCF   xCE,F
010AA:  BTFSC  FD8.2
010AC:  BSF    xC8.0
010AE:  MOVF   FED,F
010B0:  MOVF   FEF,W
010B2:  BTFSC  FEF.7
010B4:  BRA    10B8
010B6:  XORLW  80
010B8:  ADDWF  xCE,F
010BA:  BTFSC  FD8.0
010BC:  BSF    xC8.0
010BE:  BTFSC  xCA.4
010C0:  BRA    0EBA
010C2:  BTFSC  xCA.5
010C4:  BRA    0F42
010C6:  BRA    0FB0
010C8:  MOVLB  0
010CA:  RETURN 0
*
01622:  ADDWF  FE8,W
01624:  CLRF   FF7
01626:  RLCF   FF7,F
01628:  ADDLW  3D
0162A:  MOVWF  FF6
0162C:  MOVLW  16
0162E:  ADDWFC FF7,F
01630:  TBLRD*-
01632:  MOVF   FF5,W
01634:  MOVWF  FFA
01636:  TBLRD*
01638:  MOVF   FF5,W
0163A:  MOVWF  FF9
0163C:  DATA E4,10
0163E:  DATA A4,11
01640:  DATA 64,12
01642:  DATA 24,13
01644:  DATA E4,13
01646:  DATA A4,14
01648:  DATA 64,15
0164A:  BTFSC  FD8.1
0164C:  BRA    1656
0164E:  MOVLW  06
01650:  MOVWF  FEA
01652:  MOVLW  AF
01654:  MOVWF  FE9
01656:  MOVLB  6
01658:  MOVF   xAA,W
0165A:  XORWF  xAE,W
0165C:  ANDLW  80
0165E:  MOVWF  xB4
01660:  BTFSS  xAA.7
01662:  BRA    167A
01664:  COMF   xA7,F
01666:  COMF   xA8,F
01668:  COMF   xA9,F
0166A:  COMF   xAA,F
0166C:  INCF   xA7,F
0166E:  BTFSC  FD8.2
01670:  INCF   xA8,F
01672:  BTFSC  FD8.2
01674:  INCF   xA9,F
01676:  BTFSC  FD8.2
01678:  INCF   xAA,F
0167A:  BTFSS  xAE.7
0167C:  BRA    1694
0167E:  COMF   xAB,F
01680:  COMF   xAC,F
01682:  COMF   xAD,F
01684:  COMF   xAE,F
01686:  INCF   xAB,F
01688:  BTFSC  FD8.2
0168A:  INCF   xAC,F
0168C:  BTFSC  FD8.2
0168E:  INCF   xAD,F
01690:  BTFSC  FD8.2
01692:  INCF   xAE,F
01694:  CLRF   00
01696:  CLRF   01
01698:  CLRF   02
0169A:  CLRF   03
0169C:  CLRF   xAF
0169E:  CLRF   xB0
016A0:  CLRF   xB1
016A2:  CLRF   xB2
016A4:  MOVF   xAE,W
016A6:  IORWF  xAD,W
016A8:  IORWF  xAC,W
016AA:  IORWF  xAB,W
016AC:  BZ    1706
016AE:  MOVLW  20
016B0:  MOVWF  xB3
016B2:  BCF    FD8.0
016B4:  RLCF   xA7,F
016B6:  RLCF   xA8,F
016B8:  RLCF   xA9,F
016BA:  RLCF   xAA,F
016BC:  RLCF   xAF,F
016BE:  RLCF   xB0,F
016C0:  RLCF   xB1,F
016C2:  RLCF   xB2,F
016C4:  MOVF   xAE,W
016C6:  SUBWF  xB2,W
016C8:  BNZ   16DA
016CA:  MOVF   xAD,W
016CC:  SUBWF  xB1,W
016CE:  BNZ   16DA
016D0:  MOVF   xAC,W
016D2:  SUBWF  xB0,W
016D4:  BNZ   16DA
016D6:  MOVF   xAB,W
016D8:  SUBWF  xAF,W
016DA:  BNC   16FA
016DC:  MOVF   xAB,W
016DE:  SUBWF  xAF,F
016E0:  MOVF   xAC,W
016E2:  BTFSS  FD8.0
016E4:  INCFSZ xAC,W
016E6:  SUBWF  xB0,F
016E8:  MOVF   xAD,W
016EA:  BTFSS  FD8.0
016EC:  INCFSZ xAD,W
016EE:  SUBWF  xB1,F
016F0:  MOVF   xAE,W
016F2:  BTFSS  FD8.0
016F4:  INCFSZ xAE,W
016F6:  SUBWF  xB2,F
016F8:  BSF    FD8.0
016FA:  RLCF   00,F
016FC:  RLCF   01,F
016FE:  RLCF   02,F
01700:  RLCF   03,F
01702:  DECFSZ xB3,F
01704:  BRA    16B2
01706:  BTFSS  xB4.7
01708:  BRA    1720
0170A:  COMF   00,F
0170C:  COMF   01,F
0170E:  COMF   02,F
01710:  COMF   03,F
01712:  INCF   00,F
01714:  BTFSC  FD8.2
01716:  INCF   01,F
01718:  BTFSC  FD8.2
0171A:  INCF   02,F
0171C:  BTFSC  FD8.2
0171E:  INCF   03,F
01720:  MOVFF  6AF,FEF
01724:  MOVFF  6B0,FEC
01728:  MOVFF  6B1,FEC
0172C:  MOVFF  6B2,FEC
01730:  MOVLB  0
01732:  RETURN 0
*
01C90:  MOVLW  B6
01C92:  MOVWF  00
01C94:  CLRF   03
01C96:  CLRF   02
01C98:  CLRF   01
01C9A:  MOVLB  6
01C9C:  BCF    x8A.0
01C9E:  BTFSS  x89.7
01CA0:  BRA    1CBA
01CA2:  BSF    x8A.0
01CA4:  COMF   x86,F
01CA6:  COMF   x87,F
01CA8:  COMF   x88,F
01CAA:  COMF   x89,F
01CAC:  INCF   x86,F
01CAE:  BNZ   1CBA
01CB0:  INCF   x87,F
01CB2:  BNZ   1CBA
01CB4:  INCF   x88,F
01CB6:  BTFSC  FD8.2
01CB8:  INCF   x89,F
01CBA:  MOVF   x86,W
01CBC:  IORWF  x87,W
01CBE:  IORWF  x88,W
01CC0:  IORWF  x89,W
01CC2:  BNZ   1CC8
01CC4:  CLRF   00
01CC6:  BRA    1CE6
01CC8:  BCF    FD8.0
01CCA:  BTFSC  01.7
01CCC:  BRA    1CE0
01CCE:  RLCF   x86,F
01CD0:  RLCF   x87,F
01CD2:  RLCF   x88,F
01CD4:  RLCF   x89,F
01CD6:  RLCF   03,F
01CD8:  RLCF   02,F
01CDA:  RLCF   01,F
01CDC:  DECFSZ 00,F
01CDE:  BRA    1CC8
01CE0:  BCF    01.7
01CE2:  BTFSC  x8A.0
01CE4:  BSF    01.7
01CE6:  MOVLB  0
01CE8:  RETURN 0
01CEA:  MOVFF  6BD,6C4
01CEE:  MOVLB  6
01CF0:  MOVF   xC1,W
01CF2:  XORWF  xC4,F
01CF4:  BTFSS  xC4.7
01CF6:  BRA    1D02
01CF8:  BCF    FD8.2
01CFA:  BCF    FD8.0
01CFC:  BTFSC  xBD.7
01CFE:  BSF    FD8.0
01D00:  BRA    1D60
01D02:  MOVFF  6BD,6C4
01D06:  MOVFF  6C0,6C5
01D0A:  MOVF   xBC,W
01D0C:  SUBWF  xC5,F
01D0E:  BZ    1D1C
01D10:  BTFSS  xC4.7
01D12:  BRA    1D60
01D14:  MOVF   FD8,W
01D16:  XORLW  01
01D18:  MOVWF  FD8
01D1A:  BRA    1D60
01D1C:  MOVFF  6C1,6C5
01D20:  MOVF   xBD,W
01D22:  SUBWF  xC5,F
01D24:  BZ    1D32
01D26:  BTFSS  xC4.7
01D28:  BRA    1D60
01D2A:  MOVF   FD8,W
01D2C:  XORLW  01
01D2E:  MOVWF  FD8
01D30:  BRA    1D60
01D32:  MOVFF  6C2,6C5
01D36:  MOVF   xBE,W
01D38:  SUBWF  xC5,F
01D3A:  BZ    1D48
01D3C:  BTFSS  xC4.7
01D3E:  BRA    1D60
01D40:  MOVF   FD8,W
01D42:  XORLW  01
01D44:  MOVWF  FD8
01D46:  BRA    1D60
01D48:  MOVFF  6C3,6C5
01D4C:  MOVF   xBF,W
01D4E:  SUBWF  xC5,F
01D50:  BZ    1D5E
01D52:  BTFSS  xC4.7
01D54:  BRA    1D60
01D56:  MOVF   FD8,W
01D58:  XORLW  01
01D5A:  MOVWF  FD8
01D5C:  BRA    1D60
01D5E:  BCF    FD8.0
01D60:  MOVLB  0
01D62:  RETURN 0
01D64:  MOVLB  6
01D66:  MOVF   xB5,W
01D68:  BTFSC  FD8.2
01D6A:  BRA    1EB6
01D6C:  MOVWF  xC1
01D6E:  MOVF   xB9,W
01D70:  BTFSC  FD8.2
01D72:  BRA    1EB6
01D74:  SUBWF  xC1,F
01D76:  BNC   1D82
01D78:  MOVLW  7F
01D7A:  ADDWF  xC1,F
01D7C:  BTFSC  FD8.0
01D7E:  BRA    1EB6
01D80:  BRA    1D8E
01D82:  MOVLW  81
01D84:  SUBWF  xC1,F
01D86:  BTFSS  FD8.0
01D88:  BRA    1EB6
01D8A:  BTFSC  FD8.2
01D8C:  BRA    1EB6
01D8E:  MOVFF  6C1,00
01D92:  CLRF   01
01D94:  CLRF   02
01D96:  CLRF   03
01D98:  CLRF   xC0
01D9A:  MOVFF  6B6,6BF
01D9E:  BSF    xBF.7
01DA0:  MOVFF  6B7,6BE
01DA4:  MOVFF  6B8,6BD
01DA8:  MOVLW  19
01DAA:  MOVWF  xC1
01DAC:  MOVF   xBC,W
01DAE:  SUBWF  xBD,F
01DB0:  BC    1DCC
01DB2:  MOVLW  01
01DB4:  SUBWF  xBE,F
01DB6:  BC    1DCC
01DB8:  SUBWF  xBF,F
01DBA:  BC    1DCC
01DBC:  SUBWF  xC0,F
01DBE:  BC    1DCC
01DC0:  INCF   xC0,F
01DC2:  INCF   xBF,F
01DC4:  INCF   xBE,F
01DC6:  MOVF   xBC,W
01DC8:  ADDWF  xBD,F
01DCA:  BRA    1E1C
01DCC:  MOVF   xBB,W
01DCE:  SUBWF  xBE,F
01DD0:  BC    1DF6
01DD2:  MOVLW  01
01DD4:  SUBWF  xBF,F
01DD6:  BC    1DF6
01DD8:  SUBWF  xC0,F
01DDA:  BC    1DF6
01DDC:  INCF   xC0,F
01DDE:  INCF   xBF,F
01DE0:  MOVF   xBB,W
01DE2:  ADDWF  xBE,F
01DE4:  MOVF   xBC,W
01DE6:  ADDWF  xBD,F
01DE8:  BNC   1E1C
01DEA:  INCF   xBE,F
01DEC:  BNZ   1E1C
01DEE:  INCF   xBF,F
01DF0:  BNZ   1E1C
01DF2:  INCF   xC0,F
01DF4:  BRA    1E1C
01DF6:  MOVF   xBA,W
01DF8:  IORLW  80
01DFA:  SUBWF  xBF,F
01DFC:  BC    1E1A
01DFE:  MOVLW  01
01E00:  SUBWF  xC0,F
01E02:  BC    1E1A
01E04:  INCF   xC0,F
01E06:  MOVF   xBA,W
01E08:  IORLW  80
01E0A:  ADDWF  xBF,F
01E0C:  MOVF   xBB,W
01E0E:  ADDWF  xBE,F
01E10:  BNC   1DE4
01E12:  INCF   xBF,F
01E14:  BNZ   1DE4
01E16:  INCF   xC0,F
01E18:  BRA    1DE4
01E1A:  BSF    03.0
01E1C:  DECFSZ xC1,F
01E1E:  BRA    1E22
01E20:  BRA    1E38
01E22:  BCF    FD8.0
01E24:  RLCF   xBD,F
01E26:  RLCF   xBE,F
01E28:  RLCF   xBF,F
01E2A:  RLCF   xC0,F
01E2C:  BCF    FD8.0
01E2E:  RLCF   03,F
01E30:  RLCF   02,F
01E32:  RLCF   01,F
01E34:  RLCF   xC2,F
01E36:  BRA    1DAC
01E38:  BTFSS  xC2.0
01E3A:  BRA    1E48
01E3C:  BCF    FD8.0
01E3E:  RRCF   01,F
01E40:  RRCF   02,F
01E42:  RRCF   03,F
01E44:  RRCF   xC2,F
01E46:  BRA    1E4C
01E48:  DECF   00,F
01E4A:  BZ    1EB6
01E4C:  BTFSC  xC2.7
01E4E:  BRA    1E8C
01E50:  BCF    FD8.0
01E52:  RLCF   xBD,F
01E54:  RLCF   xBE,F
01E56:  RLCF   xBF,F
01E58:  RLCF   xC0,F
01E5A:  MOVF   xBC,W
01E5C:  SUBWF  xBD,F
01E5E:  BC    1E6E
01E60:  MOVLW  01
01E62:  SUBWF  xBE,F
01E64:  BC    1E6E
01E66:  SUBWF  xBF,F
01E68:  BC    1E6E
01E6A:  SUBWF  xC0,F
01E6C:  BNC   1EA2
01E6E:  MOVF   xBB,W
01E70:  SUBWF  xBE,F
01E72:  BC    1E7E
01E74:  MOVLW  01
01E76:  SUBWF  xBF,F
01E78:  BC    1E7E
01E7A:  SUBWF  xC0,F
01E7C:  BNC   1EA2
01E7E:  MOVF   xBA,W
01E80:  IORLW  80
01E82:  SUBWF  xBF,F
01E84:  BC    1E8C
01E86:  MOVLW  01
01E88:  SUBWF  xC0,F
01E8A:  BNC   1EA2
01E8C:  INCF   03,F
01E8E:  BNZ   1EA2
01E90:  INCF   02,F
01E92:  BNZ   1EA2
01E94:  INCF   01,F
01E96:  BNZ   1EA2
01E98:  INCF   00,F
01E9A:  BZ    1EB6
01E9C:  RRCF   01,F
01E9E:  RRCF   02,F
01EA0:  RRCF   03,F
01EA2:  MOVFF  6B6,6C1
01EA6:  MOVF   xBA,W
01EA8:  XORWF  xC1,F
01EAA:  BTFSS  xC1.7
01EAC:  BRA    1EB2
01EAE:  BSF    01.7
01EB0:  BRA    1EBE
01EB2:  BCF    01.7
01EB4:  BRA    1EBE
01EB6:  CLRF   00
01EB8:  CLRF   01
01EBA:  CLRF   02
01EBC:  CLRF   03
01EBE:  MOVLB  0
01EC0:  RETURN 0
*
0266C:  ADDWF  FE8,W
0266E:  CLRF   FF7
02670:  RLCF   FF7,F
02672:  ADDLW  87
02674:  MOVWF  FF6
02676:  MOVLW  26
02678:  ADDWFC FF7,F
0267A:  TBLRD*-
0267C:  MOVF   FF5,W
0267E:  MOVWF  FFA
02680:  TBLRD*
02682:  MOVF   FF5,W
02684:  MOVWF  FF9
02686:  DATA 74,25
02688:  DATA 8E,25
0268A:  DATA E2,25
0268C:  DATA 46,26
0268E:  MOVLW  8E
02690:  MOVWF  00
02692:  MOVFF  6B3,01
02696:  MOVFF  6B2,02
0269A:  CLRF   03
0269C:  BTFSS  01.7
0269E:  BRA    26AA
026A0:  COMF   01,F
026A2:  COMF   02,F
026A4:  INCF   02,F
026A6:  BNZ   26AA
026A8:  INCF   01,F
026AA:  MOVF   01,F
026AC:  BNZ   26C0
026AE:  MOVFF  02,01
026B2:  CLRF   02
026B4:  MOVLW  08
026B6:  SUBWF  00,F
026B8:  MOVF   01,F
026BA:  BNZ   26C0
026BC:  CLRF   00
026BE:  BRA    26DC
026C0:  BCF    FD8.0
026C2:  BTFSC  01.7
026C4:  BRA    26CE
026C6:  RLCF   02,F
026C8:  RLCF   01,F
026CA:  DECF   00,F
026CC:  BRA    26C0
026CE:  MOVLB  6
026D0:  BTFSS  xB3.7
026D2:  BRA    26D8
026D4:  MOVLB  0
026D6:  BRA    26DC
026D8:  BCF    01.7
026DA:  MOVLB  0
026DC:  RETURN 0
026DE:  MOVLW  8E
026E0:  MOVWF  00
026E2:  MOVLB  6
026E4:  MOVF   xBC,W
026E6:  SUBWF  00,F
026E8:  MOVFF  6BD,02
026EC:  MOVFF  6BE,01
026F0:  BSF    02.7
026F2:  MOVF   00,F
026F4:  BZ    2708
026F6:  BCF    FD8.0
026F8:  MOVF   02,F
026FA:  BNZ   2700
026FC:  MOVF   01,F
026FE:  BZ    2708
02700:  RRCF   02,F
02702:  RRCF   01,F
02704:  DECFSZ 00,F
02706:  BRA    26F6
02708:  BTFSS  xBD.7
0270A:  BRA    2716
0270C:  COMF   01,F
0270E:  COMF   02,F
02710:  INCF   01,F
02712:  BTFSC  FD8.2
02714:  INCF   02,F
02716:  MOVLB  0
02718:  RETURN 0
*
045CE:  MOVLB  6
045D0:  MOVF   x7E,W
045D2:  ANDLW  07
045D4:  MOVWF  00
045D6:  RRCF   x7E,W
045D8:  MOVWF  01
045DA:  RRCF   01,F
045DC:  RRCF   01,F
045DE:  MOVLW  1F
045E0:  ANDWF  01,F
045E2:  MOVF   01,W
045E4:  ADDWF  x7F,W
045E6:  MOVWF  FE9
045E8:  MOVLW  00
045EA:  ADDWFC x80,W
045EC:  MOVWF  FEA
045EE:  MOVFF  FEF,01
045F2:  INCF   00,F
045F4:  BRA    45F8
045F6:  RRCF   01,F
045F8:  DECFSZ 00,F
045FA:  BRA    45F6
045FC:  MOVLW  01
045FE:  ANDWF  01,F
04600:  MOVLB  0
04602:  RETURN 0
*
05008:  MOVF   FEF,F
0500A:  BZ    502A
0500C:  MOVFF  FEA,677
05010:  MOVFF  FE9,676
05014:  MOVFF  FEF,687
05018:  RCALL  4FE0
0501A:  MOVFF  677,FEA
0501E:  MOVFF  676,FE9
05022:  INCF   FE9,F
05024:  BTFSC  FD8.2
05026:  INCF   FEA,F
05028:  BRA    5008
0502A:  RETURN 0
*
05524:  TBLRD*+
05526:  MOVFF  FF6,67B
0552A:  MOVFF  FF7,67C
0552E:  MOVFF  FF5,687
05532:  RCALL  4FE0
05534:  MOVFF  67B,FF6
05538:  MOVFF  67C,FF7
0553C:  MOVLB  6
0553E:  DECFSZ x7A,F
05540:  BRA    5544
05542:  BRA    5548
05544:  MOVLB  0
05546:  BRA    5524
05548:  MOVLB  0
0554A:  RETURN 0
0554C:  MOVF   01,W
0554E:  MOVFF  67A,6AF
05552:  MOVLW  64
05554:  MOVLB  6
05556:  MOVWF  xB0
05558:  MOVLB  0
0555A:  CALL   0898
0555E:  MOVFF  00,67A
05562:  MOVF   01,W
05564:  MOVLW  30
05566:  BNZ   5578
05568:  MOVLB  6
0556A:  BTFSS  x7B.1
0556C:  BRA    558C
0556E:  BTFSC  x7B.3
05570:  BRA    558C
05572:  BTFSC  x7B.4
05574:  MOVLW  20
05576:  BRA    5580
05578:  MOVLB  6
0557A:  BCF    x7B.3
0557C:  BCF    x7B.4
0557E:  BSF    x7B.0
05580:  ADDWF  01,F
05582:  MOVFF  01,687
05586:  MOVLB  0
05588:  RCALL  4FE0
0558A:  MOVLB  6
0558C:  MOVFF  67A,6AF
05590:  MOVLW  0A
05592:  MOVWF  xB0
05594:  MOVLB  0
05596:  CALL   0898
0559A:  MOVFF  00,67A
0559E:  MOVF   01,W
055A0:  MOVLW  30
055A2:  BNZ   55B4
055A4:  MOVLB  6
055A6:  BTFSC  x7B.3
055A8:  BRA    55BE
055AA:  BTFSS  x7B.0
055AC:  BRA    55BE
055AE:  BTFSC  x7B.4
055B0:  MOVLW  20
055B2:  MOVLB  0
055B4:  ADDWF  01,F
055B6:  MOVFF  01,687
055BA:  RCALL  4FE0
055BC:  MOVLB  6
055BE:  MOVLW  30
055C0:  ADDWF  x7A,F
055C2:  MOVFF  67A,687
055C6:  MOVLB  0
055C8:  RCALL  4FE0
055CA:  RETURN 0
055CC:  MOVLB  6
055CE:  MOVF   xC1,W
055D0:  SUBLW  B6
055D2:  MOVWF  xC1
055D4:  CLRF   03
055D6:  MOVFF  6C2,6C5
055DA:  BSF    xC2.7
055DC:  BCF    FD8.0
055DE:  RRCF   xC2,F
055E0:  RRCF   xC3,F
055E2:  RRCF   xC4,F
055E4:  RRCF   03,F
055E6:  RRCF   02,F
055E8:  RRCF   01,F
055EA:  RRCF   00,F
055EC:  DECFSZ xC1,F
055EE:  BRA    55DC
055F0:  BTFSS  xC5.7
055F2:  BRA    560A
055F4:  COMF   00,F
055F6:  COMF   01,F
055F8:  COMF   02,F
055FA:  COMF   03,F
055FC:  INCF   00,F
055FE:  BTFSC  FD8.2
05600:  INCF   01,F
05602:  BTFSC  FD8.2
05604:  INCF   02,F
05606:  BTFSC  FD8.2
05608:  INCF   03,F
0560A:  MOVLB  0
0560C:  RETURN 0
0560E:  BTFSC  FD8.1
05610:  BRA    561A
05612:  MOVLW  06
05614:  MOVWF  FEA
05616:  MOVLW  C9
05618:  MOVWF  FE9
0561A:  CLRF   00
0561C:  CLRF   01
0561E:  CLRF   02
05620:  CLRF   03
05622:  MOVLB  6
05624:  CLRF   xC9
05626:  CLRF   xCA
05628:  CLRF   xCB
0562A:  CLRF   xCC
0562C:  MOVF   xC8,W
0562E:  IORWF  xC7,W
05630:  IORWF  xC6,W
05632:  IORWF  xC5,W
05634:  BZ    568E
05636:  MOVLW  20
05638:  MOVWF  xCD
0563A:  BCF    FD8.0
0563C:  RLCF   xC1,F
0563E:  RLCF   xC2,F
05640:  RLCF   xC3,F
05642:  RLCF   xC4,F
05644:  RLCF   xC9,F
05646:  RLCF   xCA,F
05648:  RLCF   xCB,F
0564A:  RLCF   xCC,F
0564C:  MOVF   xC8,W
0564E:  SUBWF  xCC,W
05650:  BNZ   5662
05652:  MOVF   xC7,W
05654:  SUBWF  xCB,W
05656:  BNZ   5662
05658:  MOVF   xC6,W
0565A:  SUBWF  xCA,W
0565C:  BNZ   5662
0565E:  MOVF   xC5,W
05660:  SUBWF  xC9,W
05662:  BNC   5682
05664:  MOVF   xC5,W
05666:  SUBWF  xC9,F
05668:  MOVF   xC6,W
0566A:  BTFSS  FD8.0
0566C:  INCFSZ xC6,W
0566E:  SUBWF  xCA,F
05670:  MOVF   xC7,W
05672:  BTFSS  FD8.0
05674:  INCFSZ xC7,W
05676:  SUBWF  xCB,F
05678:  MOVF   xC8,W
0567A:  BTFSS  FD8.0
0567C:  INCFSZ xC8,W
0567E:  SUBWF  xCC,F
05680:  BSF    FD8.0
05682:  RLCF   00,F
05684:  RLCF   01,F
05686:  RLCF   02,F
05688:  RLCF   03,F
0568A:  DECFSZ xCD,F
0568C:  BRA    563A
0568E:  MOVFF  6C9,FEF
05692:  MOVFF  6CA,FEC
05696:  MOVFF  6CB,FEC
0569A:  MOVFF  6CC,FEC
0569E:  MOVLB  0
056A0:  RETURN 0
056A2:  MOVF   FE9,W
056A4:  MOVLB  6
056A6:  MOVWF  x7F
056A8:  MOVF   x7E,W
056AA:  MOVWF  x81
056AC:  BZ    56E6
056AE:  MOVFF  67D,6C4
056B2:  MOVFF  67C,6C3
056B6:  MOVFF  67B,6C2
056BA:  MOVFF  67A,6C1
056BE:  CLRF   xC8
056C0:  CLRF   xC7
056C2:  MOVLW  20
056C4:  MOVWF  xC6
056C6:  MOVLW  82
056C8:  MOVWF  xC5
056CA:  MOVLB  0
056CC:  CALL   0D5E
056D0:  MOVFF  03,67D
056D4:  MOVFF  02,67C
056D8:  MOVFF  01,67B
056DC:  MOVFF  00,67A
056E0:  MOVLB  6
056E2:  DECFSZ x81,F
056E4:  BRA    56AE
056E6:  MOVFF  67D,6C4
056EA:  MOVFF  67C,6C3
056EE:  MOVFF  67B,6C2
056F2:  MOVFF  67A,6C1
056F6:  MOVLB  0
056F8:  RCALL  55CC
056FA:  MOVFF  03,67D
056FE:  MOVFF  02,67C
05702:  MOVFF  01,67B
05706:  MOVFF  00,67A
0570A:  MOVLB  6
0570C:  BTFSS  x7D.7
0570E:  BRA    572A
05710:  DECF   x7F,F
05712:  BSF    x7F.5
05714:  COMF   x7A,F
05716:  COMF   x7B,F
05718:  COMF   x7C,F
0571A:  COMF   x7D,F
0571C:  INCF   x7A,F
0571E:  BTFSC  FD8.2
05720:  INCF   x7B,F
05722:  BTFSC  FD8.2
05724:  INCF   x7C,F
05726:  BTFSC  FD8.2
05728:  INCF   x7D,F
0572A:  MOVLW  3B
0572C:  MOVWF  x86
0572E:  MOVLW  9A
05730:  MOVWF  x85
05732:  MOVLW  CA
05734:  MOVWF  x84
05736:  CLRF   x83
05738:  MOVLW  0A
0573A:  MOVWF  x81
0573C:  MOVF   x7E,W
0573E:  BTFSC  FD8.2
05740:  INCF   x7F,F
05742:  BSF    FD8.1
05744:  MOVLW  06
05746:  MOVWF  FEA
05748:  MOVLW  7A
0574A:  MOVWF  FE9
0574C:  MOVFF  67D,6C4
05750:  MOVFF  67C,6C3
05754:  MOVFF  67B,6C2
05758:  MOVFF  67A,6C1
0575C:  MOVFF  686,6C8
05760:  MOVFF  685,6C7
05764:  MOVFF  684,6C6
05768:  MOVFF  683,6C5
0576C:  MOVLB  0
0576E:  RCALL  560E
05770:  MOVF   01,W
05772:  MOVF   00,F
05774:  BNZ   579C
05776:  MOVLB  6
05778:  INCF   x7E,W
0577A:  SUBWF  x81,W
0577C:  BTFSS  FD8.2
0577E:  BRA    5784
05780:  MOVLB  0
05782:  BRA    579C
05784:  MOVF   x7F,W
05786:  BZ    57A2
05788:  ANDLW  0F
0578A:  SUBWF  x81,W
0578C:  BZ    5790
0578E:  BC    5814
05790:  BTFSC  x7F.7
05792:  BRA    5814
05794:  BTFSC  x7F.6
05796:  BRA    57A2
05798:  MOVLW  20
0579A:  BRA    5806
0579C:  MOVLW  20
0579E:  MOVLB  6
057A0:  ANDWF  x7F,F
057A2:  BTFSS  x7F.5
057A4:  BRA    57C2
057A6:  BCF    x7F.5
057A8:  MOVF   x7E,W
057AA:  BTFSS  FD8.2
057AC:  DECF   x7F,F
057AE:  MOVF   00,W
057B0:  MOVWF  x7F
057B2:  MOVLW  2D
057B4:  MOVWF  x87
057B6:  MOVLB  0
057B8:  RCALL  4FE0
057BA:  MOVLB  6
057BC:  MOVF   x7F,W
057BE:  MOVWF  00
057C0:  CLRF   x7F
057C2:  MOVF   x7E,W
057C4:  SUBWF  x81,W
057C6:  BNZ   57E0
057C8:  MOVF   00,W
057CA:  MOVWF  x7F
057CC:  MOVLW  2E
057CE:  MOVWF  x87
057D0:  MOVLB  0
057D2:  RCALL  4FE0
057D4:  MOVLB  6
057D6:  MOVF   x7F,W
057D8:  MOVWF  00
057DA:  MOVLW  20
057DC:  ANDWF  x7F,F
057DE:  MOVLW  00
057E0:  MOVLW  30
057E2:  BTFSS  x7F.5
057E4:  BRA    5806
057E6:  BCF    x7F.5
057E8:  MOVF   x7E,W
057EA:  BTFSS  FD8.2
057EC:  DECF   x7F,F
057EE:  MOVF   00,W
057F0:  MOVWF  x7F
057F2:  MOVLW  2D
057F4:  MOVWF  x87
057F6:  MOVLB  0
057F8:  CALL   4FE0
057FC:  MOVLB  6
057FE:  MOVF   x7F,W
05800:  MOVWF  00
05802:  CLRF   x7F
05804:  MOVLW  30
05806:  ADDWF  00,F
05808:  MOVFF  00,687
0580C:  MOVLB  0
0580E:  CALL   4FE0
05812:  MOVLB  6
05814:  BCF    FD8.1
05816:  MOVFF  686,6C4
0581A:  MOVFF  685,6C3
0581E:  MOVFF  684,6C2
05822:  MOVFF  683,6C1
05826:  CLRF   xC8
05828:  CLRF   xC7
0582A:  CLRF   xC6
0582C:  MOVLW  0A
0582E:  MOVWF  xC5
05830:  MOVLB  0
05832:  RCALL  560E
05834:  MOVFF  03,686
05838:  MOVFF  02,685
0583C:  MOVFF  01,684
05840:  MOVFF  00,683
05844:  MOVLB  6
05846:  DECFSZ x81,F
05848:  BRA    5742
0584A:  MOVLB  0
0584C:  RETURN 0
0584E:  MOVFF  FEA,67E
05852:  MOVFF  FE9,67D
05856:  MOVLB  6
05858:  SWAPF  x77,W
0585A:  IORLW  F0
0585C:  MOVWF  x79
0585E:  ADDWF  x79,F
05860:  ADDLW  E2
05862:  MOVWF  x7A
05864:  ADDLW  32
05866:  MOVWF  x7C
05868:  MOVF   x77,W
0586A:  ANDLW  0F
0586C:  ADDWF  x7A,F
0586E:  ADDWF  x7A,F
05870:  ADDWF  x7C,F
05872:  ADDLW  E9
05874:  MOVWF  x7B
05876:  ADDWF  x7B,F
05878:  ADDWF  x7B,F
0587A:  SWAPF  x76,W
0587C:  ANDLW  0F
0587E:  ADDWF  x7B,F
05880:  ADDWF  x7C,F
05882:  RLCF   x7B,F
05884:  RLCF   x7C,F
05886:  COMF   x7C,F
05888:  RLCF   x7C,F
0588A:  MOVF   x76,W
0588C:  ANDLW  0F
0588E:  ADDWF  x7C,F
05890:  RLCF   x79,F
05892:  MOVLW  07
05894:  MOVWF  x78
05896:  MOVLW  0A
05898:  DECF   x7B,F
0589A:  ADDWF  x7C,F
0589C:  BNC   5898
0589E:  DECF   x7A,F
058A0:  ADDWF  x7B,F
058A2:  BNC   589E
058A4:  DECF   x79,F
058A6:  ADDWF  x7A,F
058A8:  BNC   58A4
058AA:  DECF   x78,F
058AC:  ADDWF  x79,F
058AE:  BNC   58AA
058B0:  MOVLW  06
058B2:  MOVWF  FEA
058B4:  MOVLW  78
058B6:  MOVWF  FE9
058B8:  MOVLW  07
058BA:  ANDWF  x7D,W
058BC:  BCF    x7D.6
058BE:  ADDWF  FE9,F
058C0:  MOVLW  00
058C2:  ADDWFC FEA,F
058C4:  MOVF   FE9,W
058C6:  SUBLW  7C
058C8:  BNZ   58D2
058CA:  MOVF   FEA,W
058CC:  SUBLW  06
058CE:  BNZ   58D2
058D0:  BSF    x7D.6
058D2:  MOVF   FEF,W
058D4:  MOVWF  00
058D6:  BNZ   58E8
058D8:  BTFSC  x7D.6
058DA:  BRA    58E8
058DC:  BTFSC  x7D.4
058DE:  BRA    590C
058E0:  BTFSC  x7D.3
058E2:  BRA    58E8
058E4:  MOVLW  20
058E6:  BRA    58EE
058E8:  BSF    x7D.3
058EA:  BCF    x7D.4
058EC:  MOVLW  30
058EE:  ADDWF  00,F
058F0:  MOVFF  FEA,677
058F4:  MOVFF  FE9,676
058F8:  MOVFF  00,687
058FC:  MOVLB  0
058FE:  CALL   4FE0
05902:  MOVFF  677,FEA
05906:  MOVFF  676,FE9
0590A:  MOVLB  6
0590C:  MOVF   FEE,W
0590E:  BTFSS  x7D.6
05910:  BRA    58C4
05912:  MOVLB  0
05914:  RETURN 0
*
05A5A:  MOVFF  54B,FEA
05A5E:  MOVFF  54A,FE9
05A62:  MOVFF  6C1,FEF
05A66:  INCF   FE9,F
05A68:  BTFSC  FD8.2
05A6A:  INCF   FEA,F
05A6C:  CLRF   FEF
05A6E:  MOVLB  5
05A70:  INCF   x4A,F
05A72:  BTFSC  FD8.2
05A74:  INCF   x4B,F
05A76:  MOVLB  0
05A78:  RETURN 0
05A7A:  TBLRD*+
05A7C:  MOVF   FF5,F
05A7E:  BZ    5A98
05A80:  MOVFF  FF6,67F
05A84:  MOVFF  FF7,680
05A88:  MOVFF  FF5,6C1
05A8C:  RCALL  5A5A
05A8E:  MOVFF  67F,FF6
05A92:  MOVFF  680,FF7
05A96:  BRA    5A7A
05A98:  RETURN 0
*
05BBC:  MOVLB  6
05BBE:  MOVF   xD9,W
05BC0:  XORWF  xDB,W
05BC2:  ANDLW  80
05BC4:  MOVWF  xDD
05BC6:  BTFSS  xD9.7
05BC8:  BRA    5BD4
05BCA:  COMF   xD8,F
05BCC:  COMF   xD9,F
05BCE:  INCF   xD8,F
05BD0:  BTFSC  FD8.2
05BD2:  INCF   xD9,F
05BD4:  BTFSS  xDB.7
05BD6:  BRA    5BE2
05BD8:  COMF   xDA,F
05BDA:  COMF   xDB,F
05BDC:  INCF   xDA,F
05BDE:  BTFSC  FD8.2
05BE0:  INCF   xDB,F
05BE2:  MOVF   xD8,W
05BE4:  MULWF  xDA
05BE6:  MOVFF  FF3,01
05BEA:  MOVFF  FF4,00
05BEE:  MULWF  xDB
05BF0:  MOVF   FF3,W
05BF2:  ADDWF  00,F
05BF4:  MOVF   xD9,W
05BF6:  MULWF  xDA
05BF8:  MOVF   FF3,W
05BFA:  ADDWFC 00,W
05BFC:  MOVWF  02
05BFE:  BTFSS  xDD.7
05C00:  BRA    5C0C
05C02:  COMF   01,F
05C04:  COMF   02,F
05C06:  INCF   01,F
05C08:  BTFSC  FD8.2
05C0A:  INCF   02,F
05C0C:  MOVLB  0
05C0E:  GOTO   5EA2 (RETURN)
*
05F66:  MOVLW  20
05F68:  MOVLB  6
05F6A:  BTFSS  xA6.4
05F6C:  MOVLW  30
05F6E:  MOVWF  xA7
05F70:  MOVFF  6A5,00
05F74:  BTFSS  00.7
05F76:  BRA    5F88
05F78:  COMF   00,F
05F7A:  INCF   00,F
05F7C:  MOVFF  00,6A5
05F80:  MOVLW  2D
05F82:  MOVWF  xA7
05F84:  BSF    xA6.7
05F86:  BSF    xA6.0
05F88:  MOVF   01,W
05F8A:  MOVFF  6A5,6AF
05F8E:  MOVLW  64
05F90:  MOVWF  xB0
05F92:  MOVLB  0
05F94:  CALL   0898
05F98:  MOVFF  00,6A5
05F9C:  MOVLW  30
05F9E:  ADDWF  01,W
05FA0:  MOVLB  6
05FA2:  MOVWF  xA8
05FA4:  MOVFF  6A5,6AF
05FA8:  MOVLW  0A
05FAA:  MOVWF  xB0
05FAC:  MOVLB  0
05FAE:  CALL   0898
05FB2:  MOVLW  30
05FB4:  ADDWF  00,W
05FB6:  MOVLB  6
05FB8:  MOVWF  xAA
05FBA:  MOVLW  30
05FBC:  ADDWF  01,W
05FBE:  MOVWF  xA9
05FC0:  MOVFF  6A7,00
05FC4:  MOVLW  30
05FC6:  SUBWF  xA8,W
05FC8:  BZ    5FD2
05FCA:  BSF    xA6.1
05FCC:  BTFSC  xA6.7
05FCE:  BSF    xA6.2
05FD0:  BRA    5FF6
05FD2:  MOVFF  6A7,6A8
05FD6:  MOVLW  20
05FD8:  MOVWF  xA7
05FDA:  MOVLW  30
05FDC:  SUBWF  xA9,W
05FDE:  BZ    5FE8
05FE0:  BSF    xA6.0
05FE2:  BTFSC  xA6.7
05FE4:  BSF    xA6.1
05FE6:  BRA    5FF6
05FE8:  BTFSS  FD8.2
05FEA:  BSF    xA6.0
05FEC:  BNZ   5FF6
05FEE:  MOVFF  6A8,6A9
05FF2:  MOVLW  20
05FF4:  MOVWF  xA8
05FF6:  BTFSC  xA6.2
05FF8:  BRA    6004
05FFA:  BTFSC  xA6.1
05FFC:  BRA    600C
05FFE:  BTFSC  xA6.0
06000:  BRA    6014
06002:  BRA    601C
06004:  MOVFF  6A7,6C1
06008:  MOVLB  0
0600A:  RCALL  5A5A
0600C:  MOVFF  6A8,6C1
06010:  MOVLB  0
06012:  RCALL  5A5A
06014:  MOVFF  6A9,6C1
06018:  MOVLB  0
0601A:  RCALL  5A5A
0601C:  MOVFF  6AA,6C1
06020:  MOVLB  0
06022:  RCALL  5A5A
06024:  RETURN 0
*
061C2:  MOVLB  6
061C4:  MOVF   x93,W
061C6:  ANDLW  07
061C8:  MOVWF  00
061CA:  RRCF   x93,W
061CC:  MOVWF  01
061CE:  RRCF   01,F
061D0:  RRCF   01,F
061D2:  MOVLW  1F
061D4:  ANDWF  01,F
061D6:  MOVF   01,W
061D8:  ADDWF  x95,W
061DA:  MOVWF  FE9
061DC:  MOVLW  00
061DE:  ADDWFC x96,W
061E0:  MOVWF  FEA
061E2:  CLRF   01
061E4:  INCF   01,F
061E6:  INCF   00,F
061E8:  BRA    61EC
061EA:  RLCF   01,F
061EC:  DECFSZ 00,F
061EE:  BRA    61EA
061F0:  MOVF   x94,F
061F2:  BZ    61FA
061F4:  MOVF   01,W
061F6:  IORWF  FEF,F
061F8:  BRA    6200
061FA:  COMF   01,F
061FC:  MOVF   01,W
061FE:  ANDWF  FEF,F
06200:  MOVLB  0
06202:  RETURN 0
*
063B2:  TBLRD*+
063B4:  MOVFF  FF6,681
063B8:  MOVFF  FF7,682
063BC:  MOVFF  FF5,6C1
063C0:  CALL   5A5A
063C4:  MOVFF  681,FF6
063C8:  MOVFF  682,FF7
063CC:  MOVLB  6
063CE:  DECFSZ x80,F
063D0:  BRA    63D4
063D2:  BRA    63D8
063D4:  MOVLB  0
063D6:  BRA    63B2
063D8:  MOVLB  0
063DA:  RETURN 0
*
06782:  MOVF   FE9,W
06784:  MOVLB  6
06786:  MOVWF  xB9
06788:  MOVF   xB8,W
0678A:  MOVWF  xBB
0678C:  BZ    67C6
0678E:  MOVFF  6B7,6C4
06792:  MOVFF  6B6,6C3
06796:  MOVFF  6B5,6C2
0679A:  MOVFF  6B4,6C1
0679E:  CLRF   xC8
067A0:  CLRF   xC7
067A2:  MOVLW  20
067A4:  MOVWF  xC6
067A6:  MOVLW  82
067A8:  MOVWF  xC5
067AA:  MOVLB  0
067AC:  CALL   0D5E
067B0:  MOVFF  03,6B7
067B4:  MOVFF  02,6B6
067B8:  MOVFF  01,6B5
067BC:  MOVFF  00,6B4
067C0:  MOVLB  6
067C2:  DECFSZ xBB,F
067C4:  BRA    678E
067C6:  MOVFF  6B7,6C4
067CA:  MOVFF  6B6,6C3
067CE:  MOVFF  6B5,6C2
067D2:  MOVFF  6B4,6C1
067D6:  MOVLB  0
067D8:  CALL   55CC
067DC:  MOVFF  03,6B7
067E0:  MOVFF  02,6B6
067E4:  MOVFF  01,6B5
067E8:  MOVFF  00,6B4
067EC:  MOVLB  6
067EE:  BTFSS  xB7.7
067F0:  BRA    680C
067F2:  DECF   xB9,F
067F4:  BSF    xB9.5
067F6:  COMF   xB4,F
067F8:  COMF   xB5,F
067FA:  COMF   xB6,F
067FC:  COMF   xB7,F
067FE:  INCF   xB4,F
06800:  BTFSC  FD8.2
06802:  INCF   xB5,F
06804:  BTFSC  FD8.2
06806:  INCF   xB6,F
06808:  BTFSC  FD8.2
0680A:  INCF   xB7,F
0680C:  MOVLW  3B
0680E:  MOVWF  xC0
06810:  MOVLW  9A
06812:  MOVWF  xBF
06814:  MOVLW  CA
06816:  MOVWF  xBE
06818:  CLRF   xBD
0681A:  MOVLW  0A
0681C:  MOVWF  xBB
0681E:  MOVF   xB8,W
06820:  BTFSC  FD8.2
06822:  INCF   xB9,F
06824:  BSF    FD8.1
06826:  MOVLW  06
06828:  MOVWF  FEA
0682A:  MOVLW  B4
0682C:  MOVWF  FE9
0682E:  MOVFF  6B7,6C4
06832:  MOVFF  6B6,6C3
06836:  MOVFF  6B5,6C2
0683A:  MOVFF  6B4,6C1
0683E:  MOVFF  6C0,6C8
06842:  MOVFF  6BF,6C7
06846:  MOVFF  6BE,6C6
0684A:  MOVFF  6BD,6C5
0684E:  MOVLB  0
06850:  CALL   560E
06854:  MOVF   01,W
06856:  MOVF   00,F
06858:  BNZ   6880
0685A:  MOVLB  6
0685C:  INCF   xB8,W
0685E:  SUBWF  xBB,W
06860:  BTFSS  FD8.2
06862:  BRA    6868
06864:  MOVLB  0
06866:  BRA    6880
06868:  MOVF   xB9,W
0686A:  BZ    6886
0686C:  ANDLW  0F
0686E:  SUBWF  xBB,W
06870:  BZ    6874
06872:  BC    68FC
06874:  BTFSC  xB9.7
06876:  BRA    68FC
06878:  BTFSC  xB9.6
0687A:  BRA    6886
0687C:  MOVLW  20
0687E:  BRA    68EE
06880:  MOVLW  20
06882:  MOVLB  6
06884:  ANDWF  xB9,F
06886:  BTFSS  xB9.5
06888:  BRA    68A8
0688A:  BCF    xB9.5
0688C:  MOVF   xB8,W
0688E:  BTFSS  FD8.2
06890:  DECF   xB9,F
06892:  MOVF   00,W
06894:  MOVWF  xB9
06896:  MOVLW  2D
06898:  MOVWF  xC1
0689A:  MOVLB  0
0689C:  CALL   5A5A
068A0:  MOVLB  6
068A2:  MOVF   xB9,W
068A4:  MOVWF  00
068A6:  CLRF   xB9
068A8:  MOVF   xB8,W
068AA:  SUBWF  xBB,W
068AC:  BNZ   68C8
068AE:  MOVF   00,W
068B0:  MOVWF  xB9
068B2:  MOVLW  2E
068B4:  MOVWF  xC1
068B6:  MOVLB  0
068B8:  CALL   5A5A
068BC:  MOVLB  6
068BE:  MOVF   xB9,W
068C0:  MOVWF  00
068C2:  MOVLW  20
068C4:  ANDWF  xB9,F
068C6:  MOVLW  00
068C8:  MOVLW  30
068CA:  BTFSS  xB9.5
068CC:  BRA    68EE
068CE:  BCF    xB9.5
068D0:  MOVF   xB8,W
068D2:  BTFSS  FD8.2
068D4:  DECF   xB9,F
068D6:  MOVF   00,W
068D8:  MOVWF  xB9
068DA:  MOVLW  2D
068DC:  MOVWF  xC1
068DE:  MOVLB  0
068E0:  CALL   5A5A
068E4:  MOVLB  6
068E6:  MOVF   xB9,W
068E8:  MOVWF  00
068EA:  CLRF   xB9
068EC:  MOVLW  30
068EE:  ADDWF  00,F
068F0:  MOVFF  00,6C1
068F4:  MOVLB  0
068F6:  CALL   5A5A
068FA:  MOVLB  6
068FC:  BCF    FD8.1
068FE:  MOVFF  6C0,6C4
06902:  MOVFF  6BF,6C3
06906:  MOVFF  6BE,6C2
0690A:  MOVFF  6BD,6C1
0690E:  CLRF   xC8
06910:  CLRF   xC7
06912:  CLRF   xC6
06914:  MOVLW  0A
06916:  MOVWF  xC5
06918:  MOVLB  0
0691A:  CALL   560E
0691E:  MOVFF  03,6C0
06922:  MOVFF  02,6BF
06926:  MOVFF  01,6BE
0692A:  MOVFF  00,6BD
0692E:  MOVLB  6
06930:  DECFSZ xBB,F
06932:  BRA    6824
06934:  MOVLB  0
06936:  RETURN 0
*
093A0:  MOVF   FE9,W
093A2:  MOVLB  6
093A4:  MOVWF  xAE
093A6:  BTFSS  xAD.7
093A8:  BRA    93C4
093AA:  DECF   xAE,F
093AC:  BSF    xAE.5
093AE:  COMF   xAA,F
093B0:  COMF   xAB,F
093B2:  COMF   xAC,F
093B4:  COMF   xAD,F
093B6:  INCF   xAA,F
093B8:  BTFSC  FD8.2
093BA:  INCF   xAB,F
093BC:  BTFSC  FD8.2
093BE:  INCF   xAC,F
093C0:  BTFSC  FD8.2
093C2:  INCF   xAD,F
093C4:  MOVLW  3B
093C6:  MOVWF  xB5
093C8:  MOVLW  9A
093CA:  MOVWF  xB4
093CC:  MOVLW  CA
093CE:  MOVWF  xB3
093D0:  CLRF   xB2
093D2:  MOVLW  0A
093D4:  MOVWF  xB0
093D6:  BSF    FD8.1
093D8:  MOVLW  06
093DA:  MOVWF  FEA
093DC:  MOVLW  AA
093DE:  MOVWF  FE9
093E0:  MOVFF  6AD,6C4
093E4:  MOVFF  6AC,6C3
093E8:  MOVFF  6AB,6C2
093EC:  MOVFF  6AA,6C1
093F0:  MOVFF  6B5,6C8
093F4:  MOVFF  6B4,6C7
093F8:  MOVFF  6B3,6C6
093FC:  MOVFF  6B2,6C5
09400:  MOVLB  0
09402:  CALL   560E
09406:  MOVF   01,W
09408:  MOVF   00,F
0940A:  BNZ   9432
0940C:  MOVLB  6
0940E:  MOVF   xB0,W
09410:  XORLW  01
09412:  BTFSS  FD8.2
09414:  BRA    941A
09416:  MOVLB  0
09418:  BRA    9432
0941A:  MOVF   xAE,W
0941C:  BZ    9438
0941E:  ANDLW  0F
09420:  SUBWF  xB0,W
09422:  BZ    9426
09424:  BC    9482
09426:  BTFSC  xAE.7
09428:  BRA    9482
0942A:  BTFSC  xAE.6
0942C:  BRA    9438
0942E:  MOVLW  20
09430:  BRA    9474
09432:  MOVLW  20
09434:  MOVLB  6
09436:  ANDWF  xAE,F
09438:  BTFSS  xAE.5
0943A:  BRA    9454
0943C:  BCF    xAE.5
0943E:  MOVFF  00,6AE
09442:  MOVLW  2D
09444:  MOVWF  xC1
09446:  MOVLB  0
09448:  CALL   5A5A
0944C:  MOVLB  6
0944E:  MOVFF  6AE,00
09452:  CLRF   xAE
09454:  MOVLW  30
09456:  BTFSS  xAE.5
09458:  BRA    9474
0945A:  BCF    xAE.5
0945C:  MOVFF  00,6AE
09460:  MOVLW  2D
09462:  MOVWF  xC1
09464:  MOVLB  0
09466:  CALL   5A5A
0946A:  MOVLB  6
0946C:  MOVFF  6AE,00
09470:  CLRF   xAE
09472:  MOVLW  30
09474:  ADDWF  00,F
09476:  MOVFF  00,6C1
0947A:  MOVLB  0
0947C:  CALL   5A5A
09480:  MOVLB  6
09482:  BCF    FD8.1
09484:  MOVFF  6B5,6C4
09488:  MOVFF  6B4,6C3
0948C:  MOVFF  6B3,6C2
09490:  MOVFF  6B2,6C1
09494:  CLRF   xC8
09496:  CLRF   xC7
09498:  CLRF   xC6
0949A:  MOVLW  0A
0949C:  MOVWF  xC5
0949E:  MOVLB  0
094A0:  CALL   560E
094A4:  MOVFF  03,6B5
094A8:  MOVFF  02,6B4
094AC:  MOVFF  01,6B3
094B0:  MOVFF  00,6B2
094B4:  MOVLB  6
094B6:  DECFSZ xB0,F
094B8:  BRA    93D6
094BA:  MOVLB  0
094BC:  RETURN 0
*
0A118:  MOVF   FEF,F
0A11A:  BZ    A13C
0A11C:  MOVFF  FEA,677
0A120:  MOVFF  FE9,676
0A124:  MOVFF  FEF,6C1
0A128:  CALL   5A5A
0A12C:  MOVFF  677,FEA
0A130:  MOVFF  676,FE9
0A134:  INCF   FE9,F
0A136:  BTFSC  FD8.2
0A138:  INCF   FEA,F
0A13A:  BRA    A118
0A13C:  GOTO   A1BA (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
0043A:  MOVLW  06
0043C:  MOVWF  FEA
0043E:  MOVLW  77
00440:  MOVWF  FE9
00442:  MOVF   FEF,W
00444:  BZ    0462
00446:  MOVLW  14
00448:  MOVWF  01
0044A:  CLRF   00
0044C:  DECFSZ 00,F
0044E:  BRA    044C
00450:  DECFSZ 01,F
00452:  BRA    044A
00454:  MOVLW  BF
00456:  MOVWF  00
00458:  DECFSZ 00,F
0045A:  BRA    0458
0045C:  BRA    045E
0045E:  DECFSZ FEF,F
00460:  BRA    0446
00462:  RETURN 0
*
00702:  MOVLW  01
00704:  MOVLB  6
00706:  SUBWF  x7D,F
00708:  BNC   0722
0070A:  MOVLW  06
0070C:  MOVWF  FEA
0070E:  MOVLW  7D
00710:  MOVWF  FE9
00712:  MOVF   FEF,W
00714:  BZ    0722
00716:  MOVLW  04
00718:  MOVWF  00
0071A:  DECFSZ 00,F
0071C:  BRA    071A
0071E:  DECFSZ FEF,F
00720:  BRA    0716
00722:  MOVLB  0
00724:  GOTO   076A (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003A4:  MOVLW  CF
003A6:  MOVWF  F87
003A8:  CLRF   F82
....................    output_b(portB_reset);
003AA:  MOVLW  C4
003AC:  MOVWF  F88
003AE:  CLRF   F83
....................    output_c(portC_reset);
003B0:  MOVLW  93
003B2:  MOVWF  F89
003B4:  CLRF   F84
....................    output_d(portD_reset);
003B6:  MOVLW  1F
003B8:  MOVWF  F8A
003BA:  CLRF   F85
....................    output_e(portE_reset);
003BC:  BCF    F8B.0
003BE:  BCF    F8B.1
003C0:  BCF    F8B.2
003C2:  BCF    F8B.3
003C4:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003C6:  MOVLB  F
003C8:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003CA:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003CC:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003CE:  SETF   x20
....................    port_e_pullups(portE_pullups);
003D0:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003D2:  MOVLW  40
003D4:  MOVWF  x0C
003D6:  CLRF   x14
003D8:  MOVLW  03
003DA:  MOVWF  x1C
003DC:  MOVLW  0F
003DE:  MOVWF  x21
003E0:  CLRF   x29
003E2:  MOVLB  0
003E4:  GOTO   A616 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
059E2:  MOVFF  6B3,FEA
059E6:  MOVLB  6
059E8:  MOVFF  6B2,FE9
059EC:  MOVFF  FEF,6B6
059F0:  MOVFF  6B5,FEA
059F4:  MOVFF  6B4,FE9
059F8:  MOVF   FEF,W
059FA:  SUBWF  xB6,W
059FC:  BNZ   5A2C
....................       if (*s1 == '\0')
059FE:  MOVFF  6B3,03
05A02:  MOVFF  6B2,FE9
05A06:  MOVFF  03,FEA
05A0A:  MOVF   FEF,F
05A0C:  BNZ   5A14
....................          return(0);
05A0E:  MOVLW  00
05A10:  MOVWF  01
05A12:  BRA    5A56
05A14:  MOVFF  6B3,03
05A18:  MOVF   xB2,W
05A1A:  INCF   xB2,F
05A1C:  BTFSC  FD8.2
05A1E:  INCF   xB3,F
05A20:  INCF   xB4,F
05A22:  BTFSC  FD8.2
05A24:  INCF   xB5,F
05A26:  MOVLB  0
05A28:  BRA    59E2
05A2A:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
05A2C:  MOVFF  6B3,03
05A30:  MOVFF  6B2,FE9
05A34:  MOVFF  03,FEA
05A38:  MOVFF  FEF,6B6
05A3C:  MOVFF  6B5,03
05A40:  MOVFF  6B4,FE9
05A44:  MOVFF  03,FEA
05A48:  MOVF   FEF,W
05A4A:  SUBWF  xB6,W
05A4C:  BC    5A52
05A4E:  MOVLW  FF
05A50:  BRA    5A54
05A52:  MOVLW  01
05A54:  MOVWF  01
05A56:  MOVLB  0
05A58:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05B72:  MOVFF  6D9,6DC
....................    for(su=s;0<n;++su,--n)
05B76:  MOVFF  6D8,6DE
05B7A:  MOVFF  6D7,6DD
05B7E:  MOVLB  6
05B80:  MOVF   xDB,F
05B82:  BNZ   5B8A
05B84:  MOVF   xDA,W
05B86:  SUBLW  00
05B88:  BC    5BB2
....................       if(*su==uc)
05B8A:  MOVFF  6DE,FEA
05B8E:  MOVFF  6DD,FE9
05B92:  MOVF   xDC,W
05B94:  SUBWF  FEF,W
05B96:  BNZ   5BA2
....................       return su;
05B98:  MOVFF  6DD,01
05B9C:  MOVFF  6DE,02
05BA0:  BRA    5BB8
05BA2:  INCF   xDD,F
05BA4:  BTFSC  FD8.2
05BA6:  INCF   xDE,F
05BA8:  MOVF   xDA,W
05BAA:  BTFSC  FD8.2
05BAC:  DECF   xDB,F
05BAE:  DECF   xDA,F
05BB0:  BRA    5B80
....................    return NULL;
05BB2:  MOVLW  00
05BB4:  MOVWF  01
05BB6:  MOVWF  02
05BB8:  MOVLB  0
05BBA:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
059AA:  MOVFF  6B3,6B5
059AE:  MOVFF  6B2,6B4
059B2:  MOVFF  6B5,FEA
059B6:  MOVLB  6
059B8:  MOVFF  6B4,FE9
059BC:  MOVF   FEF,F
059BE:  BZ    59CC
059C0:  INCF   xB4,F
059C2:  BTFSC  FD8.2
059C4:  INCF   xB5,F
059C6:  MOVLB  0
059C8:  BRA    59B2
059CA:  MOVLB  6
....................    return(sc - s);
059CC:  MOVF   xB2,W
059CE:  SUBWF  xB4,W
059D0:  MOVWF  00
059D2:  MOVF   xB3,W
059D4:  SUBWFB xB5,W
059D6:  MOVWF  03
059D8:  MOVFF  00,01
059DC:  MOVWF  02
059DE:  MOVLB  0
059E0:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06EB0:  MOVLB  6
06EB2:  CLRF   x8C
06EB4:  CLRF   x8B
06EB6:  CLRF   x8A
06EB8:  MOVLW  7F
06EBA:  MOVWF  x89
06EBC:  CLRF   x90
06EBE:  CLRF   x8F
06EC0:  CLRF   x8E
06EC2:  CLRF   x8D
06EC4:  BSF    x91.0
06EC6:  BCF    x91.1
06EC8:  BCF    x91.2
06ECA:  CLRF   x93
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06ECC:  MOVF   x85,W
06ECE:  IORWF  x86,W
06ED0:  BNZ   6EDC
....................       return 0;
06ED2:  CLRF   00
06ED4:  CLRF   01
06ED6:  CLRF   02
06ED8:  CLRF   03
06EDA:  BRA    7106
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06EDC:  MOVF   x93,W
06EDE:  INCF   x93,F
06EE0:  ADDWF  x85,W
06EE2:  MOVWF  FE9
06EE4:  MOVLW  00
06EE6:  ADDWFC x86,W
06EE8:  MOVWF  FEA
06EEA:  MOVFF  FEF,692
06EEE:  MOVF   x92,F
06EF0:  BTFSC  FD8.2
06EF2:  BRA    708A
....................    {
....................       if (skip && !isspace(c))
06EF4:  BTFSS  x91.0
06EF6:  BRA    6F16
06EF8:  MOVF   x92,W
06EFA:  SUBLW  20
06EFC:  BZ    6F16
....................       {
....................          skip = 0;
06EFE:  BCF    x91.0
....................          if (c == '+')
06F00:  MOVF   x92,W
06F02:  SUBLW  2B
06F04:  BNZ   6F0C
....................          {
....................             sign = 0;
06F06:  BCF    x91.1
....................             continue;
06F08:  BRA    7072
....................          }            
06F0A:  BRA    6F16
....................          else if (c == '-')
06F0C:  MOVF   x92,W
06F0E:  SUBLW  2D
06F10:  BNZ   6F16
....................          {
....................             sign = 1;
06F12:  BSF    x91.1
....................             continue;
06F14:  BRA    7072
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06F16:  BTFSC  x91.0
06F18:  BRA    6F28
06F1A:  MOVF   x92,W
06F1C:  SUBLW  2E
06F1E:  BNZ   6F28
06F20:  BTFSC  x91.2
06F22:  BRA    6F28
....................          point = 1;
06F24:  BSF    x91.2
06F26:  BRA    7072
....................       else if (!skip && isdigit(c))
06F28:  BTFSC  x91.0
06F2A:  BRA    706C
06F2C:  MOVF   x92,W
06F2E:  SUBLW  2F
06F30:  BTFSC  FD8.0
06F32:  BRA    706C
06F34:  MOVF   x92,W
06F36:  SUBLW  39
06F38:  BTFSS  FD8.0
06F3A:  BRA    706C
....................       {
....................          c -= '0';
06F3C:  MOVLW  30
06F3E:  SUBWF  x92,F
....................          if (point)
06F40:  BTFSS  x91.2
06F42:  BRA    6FF2
....................          {
....................             pow10 = pow10 * 10.0;
06F44:  MOVFF  68C,6C4
06F48:  MOVFF  68B,6C3
06F4C:  MOVFF  68A,6C2
06F50:  MOVFF  689,6C1
06F54:  CLRF   xC8
06F56:  CLRF   xC7
06F58:  MOVLW  20
06F5A:  MOVWF  xC6
06F5C:  MOVLW  82
06F5E:  MOVWF  xC5
06F60:  MOVLB  0
06F62:  CALL   0D5E
06F66:  MOVFF  03,68C
06F6A:  MOVFF  02,68B
06F6E:  MOVFF  01,68A
06F72:  MOVFF  00,689
....................             result += (float)c / pow10;   
06F76:  MOVLB  6
06F78:  CLRF   xC1
06F7A:  MOVFF  692,6C0
06F7E:  MOVLB  0
06F80:  CALL   0D28
06F84:  MOVFF  03,697
06F88:  MOVFF  02,696
06F8C:  MOVFF  01,695
06F90:  MOVFF  00,694
06F94:  MOVFF  03,6B8
06F98:  MOVFF  02,6B7
06F9C:  MOVFF  01,6B6
06FA0:  MOVFF  00,6B5
06FA4:  MOVFF  68C,6BC
06FA8:  MOVFF  68B,6BB
06FAC:  MOVFF  68A,6BA
06FB0:  MOVFF  689,6B9
06FB4:  CALL   1D64
06FB8:  BCF    FD8.1
06FBA:  MOVFF  690,6C3
06FBE:  MOVFF  68F,6C2
06FC2:  MOVFF  68E,6C1
06FC6:  MOVFF  68D,6C0
06FCA:  MOVFF  03,6C7
06FCE:  MOVFF  02,6C6
06FD2:  MOVFF  01,6C5
06FD6:  MOVFF  00,6C4
06FDA:  CALL   0E54
06FDE:  MOVFF  03,690
06FE2:  MOVFF  02,68F
06FE6:  MOVFF  01,68E
06FEA:  MOVFF  00,68D
....................          }
06FEE:  BRA    7068
06FF0:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06FF2:  CLRF   xC4
06FF4:  CLRF   xC3
06FF6:  MOVLW  20
06FF8:  MOVWF  xC2
06FFA:  MOVLW  82
06FFC:  MOVWF  xC1
06FFE:  MOVFF  690,6C8
07002:  MOVFF  68F,6C7
07006:  MOVFF  68E,6C6
0700A:  MOVFF  68D,6C5
0700E:  MOVLB  0
07010:  CALL   0D5E
07014:  MOVFF  03,697
07018:  MOVFF  02,696
0701C:  MOVFF  01,695
07020:  MOVFF  00,694
07024:  MOVLB  6
07026:  CLRF   xC1
07028:  MOVFF  692,6C0
0702C:  MOVLB  0
0702E:  CALL   0D28
07032:  BCF    FD8.1
07034:  MOVFF  697,6C3
07038:  MOVFF  696,6C2
0703C:  MOVFF  695,6C1
07040:  MOVFF  694,6C0
07044:  MOVFF  03,6C7
07048:  MOVFF  02,6C6
0704C:  MOVFF  01,6C5
07050:  MOVFF  00,6C4
07054:  CALL   0E54
07058:  MOVFF  03,690
0705C:  MOVFF  02,68F
07060:  MOVFF  01,68E
07064:  MOVFF  00,68D
....................          }
....................       }
07068:  BRA    7074
0706A:  MOVLB  6
....................       else if (!skip)
0706C:  BTFSC  x91.0
0706E:  BRA    7072
....................          break;
07070:  BRA    708A
07072:  MOVLB  0
07074:  MOVLB  6
07076:  MOVF   x93,W
07078:  INCF   x93,F
0707A:  ADDWF  x85,W
0707C:  MOVWF  FE9
0707E:  MOVLW  00
07080:  ADDWFC x86,W
07082:  MOVWF  FEA
07084:  MOVFF  FEF,692
07088:  BRA    6EEE
....................    }
.................... 
....................    if (sign)
0708A:  BTFSS  x91.1
0708C:  BRA    70C2
....................       result = -1*result;
0708E:  CLRF   xC4
07090:  CLRF   xC3
07092:  MOVLW  80
07094:  MOVWF  xC2
07096:  MOVLW  7F
07098:  MOVWF  xC1
0709A:  MOVFF  690,6C8
0709E:  MOVFF  68F,6C7
070A2:  MOVFF  68E,6C6
070A6:  MOVFF  68D,6C5
070AA:  MOVLB  0
070AC:  CALL   0D5E
070B0:  MOVFF  03,690
070B4:  MOVFF  02,68F
070B8:  MOVFF  01,68E
070BC:  MOVFF  00,68D
070C0:  MOVLB  6
....................       
....................    if(endptr)
070C2:  MOVF   x87,W
070C4:  IORWF  x88,W
070C6:  BZ    70F6
....................    {
....................       if (ptr) {
070C8:  MOVF   x93,F
070CA:  BZ    70E4
....................          ptr--;
070CC:  DECF   x93,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
070CE:  MOVFF  688,FEA
070D2:  MOVFF  687,FE9
070D6:  MOVF   x93,W
070D8:  ADDWF  x85,W
070DA:  MOVWF  FEF
070DC:  MOVLW  00
070DE:  ADDWFC x86,W
070E0:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
070E2:  BRA    70F6
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
070E4:  MOVFF  688,FEA
070E8:  MOVFF  687,FE9
070EC:  MOVFF  686,FEC
070F0:  MOVF   FED,F
070F2:  MOVFF  685,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
070F6:  MOVFF  68D,00
070FA:  MOVFF  68E,01
070FE:  MOVFF  68F,02
07102:  MOVFF  690,03
07106:  MOVLB  0
07108:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05C12:  MOVLB  6
05C14:  CLRF   xB0
05C16:  CLRF   xAF
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05C18:  MOVLW  30
05C1A:  MOVWF  xB2
05C1C:  MOVLW  31
05C1E:  MOVWF  xB3
05C20:  MOVLW  32
05C22:  MOVWF  xB4
05C24:  MOVLW  33
05C26:  MOVWF  xB5
05C28:  MOVLW  34
05C2A:  MOVWF  xB6
05C2C:  MOVLW  35
05C2E:  MOVWF  xB7
05C30:  MOVLW  36
05C32:  MOVWF  xB8
05C34:  MOVLW  37
05C36:  MOVWF  xB9
05C38:  MOVLW  38
05C3A:  MOVWF  xBA
05C3C:  MOVLW  39
05C3E:  MOVWF  xBB
05C40:  MOVLW  61
05C42:  MOVWF  xBC
05C44:  MOVLW  62
05C46:  MOVWF  xBD
05C48:  MOVLW  63
05C4A:  MOVWF  xBE
05C4C:  MOVLW  64
05C4E:  MOVWF  xBF
05C50:  MOVLW  65
05C52:  MOVWF  xC0
05C54:  MOVLW  66
05C56:  MOVWF  xC1
05C58:  MOVLW  67
05C5A:  MOVWF  xC2
05C5C:  MOVLW  68
05C5E:  MOVWF  xC3
05C60:  MOVLW  69
05C62:  MOVWF  xC4
05C64:  MOVLW  6A
05C66:  MOVWF  xC5
05C68:  MOVLW  6B
05C6A:  MOVWF  xC6
05C6C:  MOVLW  6C
05C6E:  MOVWF  xC7
05C70:  MOVLW  6D
05C72:  MOVWF  xC8
05C74:  MOVLW  6E
05C76:  MOVWF  xC9
05C78:  MOVLW  6F
05C7A:  MOVWF  xCA
05C7C:  MOVLW  70
05C7E:  MOVWF  xCB
05C80:  MOVLW  71
05C82:  MOVWF  xCC
05C84:  MOVLW  73
05C86:  MOVWF  xCD
05C88:  MOVLW  74
05C8A:  MOVWF  xCE
05C8C:  MOVLW  75
05C8E:  MOVWF  xCF
05C90:  MOVLW  76
05C92:  MOVWF  xD0
05C94:  MOVLW  77
05C96:  MOVWF  xD1
05C98:  MOVLW  78
05C9A:  MOVWF  xD2
05C9C:  MOVLW  79
05C9E:  MOVWF  xD3
05CA0:  MOVLW  7A
05CA2:  MOVWF  xD4
05CA4:  CLRF   xD5
....................    for(sc=s;isspace(*sc);++sc);
05CA6:  MOVFF  6A5,6AA
05CAA:  MOVFF  6A4,6A9
05CAE:  MOVFF  6AA,FEA
05CB2:  MOVFF  6A9,FE9
05CB6:  MOVF   FEF,W
05CB8:  SUBLW  20
05CBA:  BNZ   5CC4
05CBC:  INCF   xA9,F
05CBE:  BTFSC  FD8.2
05CC0:  INCF   xAA,F
05CC2:  BRA    5CAE
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05CC4:  MOVFF  6AA,03
05CC8:  MOVFF  6A9,FE9
05CCC:  MOVFF  03,FEA
05CD0:  MOVF   FEF,W
05CD2:  SUBLW  2D
05CD4:  BZ    5CE4
05CD6:  MOVFF  6AA,FEA
05CDA:  MOVFF  6A9,FE9
05CDE:  MOVF   FEF,W
05CE0:  SUBLW  2B
05CE2:  BNZ   5CF6
05CE4:  MOVFF  6AA,FEA
05CE8:  MOVF   xA9,W
05CEA:  INCF   xA9,F
05CEC:  BTFSC  FD8.2
05CEE:  INCF   xAA,F
05CF0:  MOVWF  FE9
05CF2:  MOVF   FEF,W
05CF4:  BRA    5CF8
05CF6:  MOVLW  2B
05CF8:  MOVWF  xB1
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05CFA:  MOVF   xB1,W
05CFC:  SUBLW  2D
05CFE:  BZ    5D14
05D00:  BTFSC  xA8.7
05D02:  BRA    5D14
05D04:  DECFSZ xA8,W
05D06:  BRA    5D0A
05D08:  BRA    5D14
05D0A:  BTFSC  xA8.7
05D0C:  BRA    5D18
05D0E:  MOVF   xA8,W
05D10:  SUBLW  24
05D12:  BC    5D18
....................    goto StrtoulGO;
05D14:  BRA    5F20
05D16:  BRA    5E10
.................... 
....................    else if (base)
05D18:  MOVF   xA8,F
05D1A:  BZ    5DA8
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05D1C:  MOVF   xA8,W
05D1E:  SUBLW  10
05D20:  BNZ   5D5C
05D22:  MOVFF  6AA,FEA
05D26:  MOVFF  6A9,FE9
05D2A:  MOVF   FEF,W
05D2C:  SUBLW  30
05D2E:  BNZ   5D5C
05D30:  MOVLW  01
05D32:  ADDWF  xA9,W
05D34:  MOVWF  FE9
05D36:  MOVLW  00
05D38:  ADDWFC xAA,W
05D3A:  MOVWF  FEA
05D3C:  MOVF   FEF,W
05D3E:  SUBLW  78
05D40:  BZ    5D54
05D42:  MOVLW  01
05D44:  ADDWF  xA9,W
05D46:  MOVWF  FE9
05D48:  MOVLW  00
05D4A:  ADDWFC xAA,W
05D4C:  MOVWF  FEA
05D4E:  MOVF   FEF,W
05D50:  SUBLW  58
05D52:  BNZ   5D5C
....................          sc+=2;
05D54:  MOVLW  02
05D56:  ADDWF  xA9,F
05D58:  MOVLW  00
05D5A:  ADDWFC xAA,F
....................       if(base==8 && *sc =='0')
05D5C:  MOVF   xA8,W
05D5E:  SUBLW  08
05D60:  BNZ   5D78
05D62:  MOVFF  6AA,FEA
05D66:  MOVFF  6A9,FE9
05D6A:  MOVF   FEF,W
05D6C:  SUBLW  30
05D6E:  BNZ   5D78
....................          sc+=1;
05D70:  MOVLW  01
05D72:  ADDWF  xA9,F
05D74:  MOVLW  00
05D76:  ADDWFC xAA,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05D78:  MOVF   xA8,W
05D7A:  SUBLW  02
05D7C:  BNZ   5DA6
05D7E:  MOVFF  6AA,FEA
05D82:  MOVFF  6A9,FE9
05D86:  MOVF   FEF,W
05D88:  SUBLW  30
05D8A:  BNZ   5DA6
05D8C:  MOVLW  01
05D8E:  ADDWF  xA9,W
05D90:  MOVWF  FE9
05D92:  MOVLW  00
05D94:  ADDWFC xAA,W
05D96:  MOVWF  FEA
05D98:  MOVF   FEF,W
05D9A:  SUBLW  62
05D9C:  BNZ   5DA6
....................          sc+=2;
05D9E:  MOVLW  02
05DA0:  ADDWF  xA9,F
05DA2:  MOVLW  00
05DA4:  ADDWFC xAA,F
.................... 
....................    }
05DA6:  BRA    5E10
....................    else if(*sc!='0') // base is 0, find base
05DA8:  MOVFF  6AA,FEA
05DAC:  MOVFF  6A9,FE9
05DB0:  MOVF   FEF,W
05DB2:  SUBLW  30
05DB4:  BZ    5DBC
....................       base=10;
05DB6:  MOVLW  0A
05DB8:  MOVWF  xA8
05DBA:  BRA    5E10
....................    else if (sc[1]=='x' || sc[1]=='X')
05DBC:  MOVLW  01
05DBE:  ADDWF  xA9,W
05DC0:  MOVWF  FE9
05DC2:  MOVLW  00
05DC4:  ADDWFC xAA,W
05DC6:  MOVWF  FEA
05DC8:  MOVF   FEF,W
05DCA:  SUBLW  78
05DCC:  BZ    5DE0
05DCE:  MOVLW  01
05DD0:  ADDWF  xA9,W
05DD2:  MOVWF  FE9
05DD4:  MOVLW  00
05DD6:  ADDWFC xAA,W
05DD8:  MOVWF  FEA
05DDA:  MOVF   FEF,W
05DDC:  SUBLW  58
05DDE:  BNZ   5DEE
....................       base =16,sc+=2;
05DE0:  MOVLW  10
05DE2:  MOVWF  xA8
05DE4:  MOVLW  02
05DE6:  ADDWF  xA9,F
05DE8:  MOVLW  00
05DEA:  ADDWFC xAA,F
05DEC:  BRA    5E10
....................    else if(sc[1]=='b')
05DEE:  MOVLW  01
05DF0:  ADDWF  xA9,W
05DF2:  MOVWF  FE9
05DF4:  MOVLW  00
05DF6:  ADDWFC xAA,W
05DF8:  MOVWF  FEA
05DFA:  MOVF   FEF,W
05DFC:  SUBLW  62
05DFE:  BNZ   5E0C
....................       base=2,sc+=2;
05E00:  MOVLW  02
05E02:  MOVWF  xA8
05E04:  ADDWF  xA9,F
05E06:  MOVLW  00
05E08:  ADDWFC xAA,F
05E0A:  BRA    5E10
....................    else
....................       base=8;
05E0C:  MOVLW  08
05E0E:  MOVWF  xA8
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05E10:  MOVFF  6AA,6AC
05E14:  MOVFF  6A9,6AB
05E18:  MOVFF  6AA,FEA
05E1C:  MOVFF  6A9,FE9
05E20:  MOVF   FEF,W
05E22:  SUBLW  30
05E24:  BNZ   5E2E
05E26:  INCF   xA9,F
05E28:  BTFSC  FD8.2
05E2A:  INCF   xAA,F
05E2C:  BRA    5E18
....................    sd=memchr(digits,tolower(*sc),base);
05E2E:  MOVFF  6AA,03
05E32:  MOVFF  6A9,FE9
05E36:  MOVFF  03,FEA
05E3A:  MOVFF  FEF,6D6
05E3E:  MOVF   xD6,W
05E40:  SUBLW  40
05E42:  BC    5E50
05E44:  MOVF   xD6,W
05E46:  SUBLW  5A
05E48:  BNC   5E50
05E4A:  MOVF   xD6,W
05E4C:  IORLW  20
05E4E:  BRA    5E52
05E50:  MOVF   xD6,W
05E52:  MOVWF  xD6
05E54:  MOVLW  06
05E56:  MOVWF  xD8
05E58:  MOVLW  B2
05E5A:  MOVWF  xD7
05E5C:  MOVFF  6D6,6D9
05E60:  CLRF   xDB
05E62:  MOVFF  6A8,6DA
05E66:  BTFSC  xDA.7
05E68:  DECF   xDB,F
05E6A:  MOVLB  0
05E6C:  RCALL  5B72
05E6E:  MOVFF  02,6AE
05E72:  MOVFF  01,6AD
....................    for(; sd!=0; )
05E76:  MOVLB  6
05E78:  MOVF   xAD,F
05E7A:  BNZ   5E80
05E7C:  MOVF   xAE,F
05E7E:  BZ    5F14
....................    {
....................       x=x*base+(int16)(sd-digits);
05E80:  CLRF   03
05E82:  MOVF   xA8,W
05E84:  MOVWF  00
05E86:  BTFSC  FE8.7
05E88:  DECF   03,F
05E8A:  MOVWF  xD6
05E8C:  MOVFF  03,6D7
05E90:  MOVFF  6B0,6D9
05E94:  MOVFF  6AF,6D8
05E98:  MOVFF  03,6DB
05E9C:  MOVWF  xDA
05E9E:  MOVLB  0
05EA0:  BRA    5BBC
05EA2:  MOVFF  01,6D6
05EA6:  MOVLW  B2
05EA8:  MOVLB  6
05EAA:  SUBWF  xAD,W
05EAC:  MOVWF  00
05EAE:  MOVLW  06
05EB0:  SUBWFB xAE,W
05EB2:  MOVWF  03
05EB4:  MOVF   00,W
05EB6:  ADDWF  01,W
05EB8:  MOVWF  01
05EBA:  MOVF   02,W
05EBC:  ADDWFC 03,F
05EBE:  MOVFF  01,6AF
05EC2:  MOVFF  03,6B0
....................       ++sc;
05EC6:  INCF   xA9,F
05EC8:  BTFSC  FD8.2
05ECA:  INCF   xAA,F
....................       sd=memchr(digits,tolower(*sc),base);
05ECC:  MOVFF  6AA,FEA
05ED0:  MOVFF  6A9,FE9
05ED4:  MOVFF  FEF,6D6
05ED8:  MOVF   xD6,W
05EDA:  SUBLW  40
05EDC:  BC    5EEA
05EDE:  MOVF   xD6,W
05EE0:  SUBLW  5A
05EE2:  BNC   5EEA
05EE4:  MOVF   xD6,W
05EE6:  IORLW  20
05EE8:  BRA    5EEC
05EEA:  MOVF   xD6,W
05EEC:  MOVWF  xD6
05EEE:  MOVLW  06
05EF0:  MOVWF  xD8
05EF2:  MOVLW  B2
05EF4:  MOVWF  xD7
05EF6:  MOVFF  6D6,6D9
05EFA:  CLRF   xDB
05EFC:  MOVFF  6A8,6DA
05F00:  BTFSC  xDA.7
05F02:  DECF   xDB,F
05F04:  MOVLB  0
05F06:  RCALL  5B72
05F08:  MOVFF  02,6AE
05F0C:  MOVFF  01,6AD
05F10:  BRA    5E76
05F12:  MOVLB  6
....................    }
....................    if(s1==sc)
05F14:  MOVF   xA9,W
05F16:  SUBWF  xAB,W
05F18:  BNZ   5F42
05F1A:  MOVF   xAA,W
05F1C:  SUBWF  xAC,W
05F1E:  BNZ   5F42
....................    {
....................    StrtoulGO:
....................       if (endptr)
05F20:  MOVLB  6
05F22:  MOVF   xA6,W
05F24:  IORWF  xA7,W
05F26:  BZ    5F3A
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05F28:  MOVFF  6A7,FEA
05F2C:  MOVFF  6A6,FE9
05F30:  MOVFF  6A5,FEC
05F34:  MOVF   FED,F
05F36:  MOVFF  6A4,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05F3A:  MOVLW  00
05F3C:  MOVWF  01
05F3E:  MOVWF  02
05F40:  BRA    5F62
....................    }
....................    if (endptr)
05F42:  MOVF   xA6,W
05F44:  IORWF  xA7,W
05F46:  BZ    5F5A
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05F48:  MOVFF  6A7,FEA
05F4C:  MOVFF  6A6,FE9
05F50:  MOVFF  6AA,FEC
05F54:  MOVF   FED,F
05F56:  MOVFF  6A9,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05F5A:  MOVFF  6AF,01
05F5E:  MOVFF  6B0,02
05F62:  MOVLB  0
05F64:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00464:  MOVLB  6
00466:  CLRF   x76
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00468:  CLRF   x76
0046A:  MOVF   x75,W
0046C:  SUBWF  x76,W
0046E:  BC    04C6
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00470:  MOVF   x76,W
00472:  ADDWF  x73,W
00474:  MOVWF  x77
00476:  MOVLW  00
00478:  ADDWFC x74,W
0047A:  MOVWF  x78
0047C:  MOVF   x76,W
0047E:  ADDWF  x71,W
00480:  MOVWF  01
00482:  MOVLW  00
00484:  ADDWFC x72,W
00486:  MOVWF  03
00488:  MOVF   01,W
0048A:  MOVWF  FE9
0048C:  MOVFF  03,FEA
00490:  MOVFF  FEF,679
00494:  BSF    F7F.7
00496:  MOVF   FF2,W
00498:  MOVWF  00
0049A:  BCF    FF2.7
0049C:  MOVFF  678,F7A
004A0:  MOVFF  677,F79
004A4:  MOVLW  31
004A6:  MOVWF  F7B
004A8:  MOVFF  679,F7C
004AC:  MOVLB  F
004AE:  MOVLW  55
004B0:  MOVWF  F81
004B2:  MOVLW  AA
004B4:  MOVWF  F81
004B6:  BSF    F80.4
004B8:  BTFSC  F80.4
004BA:  BRA    04B8
004BC:  MOVF   00,W
004BE:  IORWF  FF2,F
004C0:  MOVLB  6
004C2:  INCF   x76,F
004C4:  BRA    046A
....................    }
004C6:  MOVLB  0
004C8:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003E8:  MOVLB  6
003EA:  CLRF   x76
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003EC:  CLRF   x76
003EE:  MOVF   x75,W
003F0:  SUBWF  x76,W
003F2:  BC    0436
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003F4:  MOVF   x76,W
003F6:  ADDWF  x71,W
003F8:  MOVWF  01
003FA:  MOVLW  00
003FC:  ADDWFC x72,W
003FE:  MOVWF  03
00400:  MOVF   01,W
00402:  MOVWF  FE9
00404:  MOVFF  03,FEA
00408:  MOVF   x76,W
0040A:  ADDWF  x73,W
0040C:  MOVWF  x79
0040E:  MOVLW  00
00410:  ADDWFC x74,W
00412:  MOVWF  x7A
00414:  BSF    F7F.7
00416:  MOVFF  FF2,67B
0041A:  BCF    FF2.7
0041C:  MOVFF  67A,F7A
00420:  MOVFF  679,F79
00424:  MOVLW  31
00426:  MOVWF  F7B
00428:  BSF    F80.0
0042A:  MOVF   F7C,W
0042C:  BTFSC  x7B.7
0042E:  BSF    FF2.7
00430:  MOVWF  FEF
00432:  INCF   x76,F
00434:  BRA    03EE
....................    }
00436:  MOVLB  0
00438:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004CA:  MOVLB  6
004CC:  CLRF   x72
004CE:  MOVLW  20
004D0:  MOVWF  x71
004D2:  CLRF   x74
004D4:  CLRF   x73
004D6:  MOVLW  80
004D8:  MOVWF  x75
004DA:  MOVLB  0
004DC:  RCALL  0464
....................    delay_ms(1);
004DE:  MOVLW  01
004E0:  MOVLB  6
004E2:  MOVWF  x77
004E4:  MOVLB  0
004E6:  RCALL  043A
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E8:  MOVLB  6
004EA:  CLRF   x72
004EC:  MOVLW  60
004EE:  MOVWF  x71
004F0:  CLRF   x74
004F2:  MOVLW  80
004F4:  MOVWF  x73
004F6:  MOVLW  02
004F8:  MOVWF  x75
004FA:  MOVLB  0
004FC:  RCALL  0464
....................    delay_ms(1);
004FE:  MOVLW  01
00500:  MOVLB  6
00502:  MOVWF  x77
00504:  MOVLB  0
00506:  RCALL  043A
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00508:  MOVLB  6
0050A:  CLRF   x72
0050C:  MOVLW  61
0050E:  MOVWF  x71
00510:  CLRF   x74
00512:  MOVLW  90
00514:  MOVWF  x73
00516:  MOVLW  02
00518:  MOVWF  x75
0051A:  MOVLB  0
0051C:  RCALL  0464
....................    delay_ms(1);
0051E:  MOVLW  01
00520:  MOVLB  6
00522:  MOVWF  x77
00524:  MOVLB  0
00526:  RCALL  043A
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00528:  MOVLB  6
0052A:  CLRF   x72
0052C:  MOVLW  62
0052E:  MOVWF  x71
00530:  CLRF   x74
00532:  MOVLW  A0
00534:  MOVWF  x73
00536:  MOVLW  20
00538:  MOVWF  x75
0053A:  MOVLB  0
0053C:  RCALL  0464
....................    delay_ms(1);
0053E:  MOVLW  01
00540:  MOVLB  6
00542:  MOVWF  x77
00544:  MOVLB  0
00546:  RCALL  043A
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00548:  MOVLB  6
0054A:  CLRF   x72
0054C:  MOVLW  82
0054E:  MOVWF  x71
00550:  CLRF   x74
00552:  MOVLW  C0
00554:  MOVWF  x73
00556:  MOVLW  30
00558:  MOVWF  x75
0055A:  MOVLB  0
0055C:  RCALL  0464
....................    delay_ms(1);
0055E:  MOVLW  01
00560:  MOVLB  6
00562:  MOVWF  x77
00564:  MOVLB  0
00566:  RCALL  043A
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00568:  MOVLB  6
0056A:  CLRF   x72
0056C:  MOVLW  B2
0056E:  MOVWF  x71
00570:  CLRF   x74
00572:  MOVLW  F0
00574:  MOVWF  x73
00576:  MOVLW  38
00578:  MOVWF  x75
0057A:  MOVLB  0
0057C:  RCALL  0464
....................    delay_ms(1);
0057E:  MOVLW  01
00580:  MOVLB  6
00582:  MOVWF  x77
00584:  MOVLB  0
00586:  RCALL  043A
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00588:  MOVLB  6
0058A:  CLRF   x72
0058C:  MOVLW  EA
0058E:  MOVWF  x71
00590:  MOVLW  01
00592:  MOVWF  x74
00594:  MOVLW  40
00596:  MOVWF  x73
00598:  MOVLW  01
0059A:  MOVWF  x75
0059C:  MOVLB  0
0059E:  RCALL  0464
....................    delay_ms(1);
005A0:  MOVLW  01
005A2:  MOVLB  6
005A4:  MOVWF  x77
005A6:  MOVLB  0
005A8:  RCALL  043A
005AA:  GOTO   067A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005AE:  MOVLB  6
005B0:  CLRF   x72
005B2:  MOVLW  20
005B4:  MOVWF  x71
005B6:  CLRF   x74
005B8:  CLRF   x73
005BA:  MOVLW  80
005BC:  MOVWF  x75
005BE:  MOVLB  0
005C0:  RCALL  03E8
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005C2:  MOVLB  6
005C4:  CLRF   x72
005C6:  MOVLW  60
005C8:  MOVWF  x71
005CA:  CLRF   x74
005CC:  MOVLW  80
005CE:  MOVWF  x73
005D0:  MOVLW  02
005D2:  MOVWF  x75
005D4:  MOVLB  0
005D6:  RCALL  03E8
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D8:  MOVLB  6
005DA:  CLRF   x72
005DC:  MOVLW  61
005DE:  MOVWF  x71
005E0:  CLRF   x74
005E2:  MOVLW  90
005E4:  MOVWF  x73
005E6:  MOVLW  02
005E8:  MOVWF  x75
005EA:  MOVLB  0
005EC:  RCALL  03E8
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005EE:  MOVLB  6
005F0:  CLRF   x72
005F2:  MOVLW  62
005F4:  MOVWF  x71
005F6:  CLRF   x74
005F8:  MOVLW  A0
005FA:  MOVWF  x73
005FC:  MOVLW  20
005FE:  MOVWF  x75
00600:  MOVLB  0
00602:  RCALL  03E8
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00604:  MOVLB  6
00606:  CLRF   x72
00608:  MOVLW  82
0060A:  MOVWF  x71
0060C:  CLRF   x74
0060E:  MOVLW  C0
00610:  MOVWF  x73
00612:  MOVLW  30
00614:  MOVWF  x75
00616:  MOVLB  0
00618:  RCALL  03E8
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0061A:  MOVLB  6
0061C:  CLRF   x72
0061E:  MOVLW  B2
00620:  MOVWF  x71
00622:  CLRF   x74
00624:  MOVLW  F0
00626:  MOVWF  x73
00628:  MOVLW  38
0062A:  MOVWF  x75
0062C:  MOVLB  0
0062E:  RCALL  03E8
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00630:  MOVLB  6
00632:  CLRF   x72
00634:  MOVLW  EA
00636:  MOVWF  x71
00638:  MOVLW  01
0063A:  MOVWF  x74
0063C:  MOVLW  40
0063E:  MOVWF  x73
00640:  MOVLW  01
00642:  MOVWF  x75
00644:  MOVLB  0
00646:  RCALL  03E8
00648:  GOTO   067E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064C:  MOVLB  6
0064E:  CLRF   x72
00650:  MOVLW  EA
00652:  MOVWF  x71
00654:  MOVLW  01
00656:  MOVWF  x74
00658:  MOVLW  40
0065A:  MOVWF  x73
0065C:  MOVLW  01
0065E:  MOVWF  x75
00660:  MOVLB  0
00662:  RCALL  03E8
....................    delay_ms(1);
00664:  MOVLW  01
00666:  MOVLB  6
00668:  MOVWF  x77
0066A:  MOVLB  0
0066C:  RCALL  043A
....................    if (paramsValid != isValid)
0066E:  MOVF   xEA,W
00670:  SUBLW  AA
00672:  BZ    067C
....................    {
....................       paramsValid = isValid;
00674:  MOVLW  AA
00676:  MOVWF  xEA
....................       params_save_to_ee(); // saves the base parameters on first boot
00678:  BRA    04CA
....................    }
0067A:  BRA    067E
....................    else
....................    {
....................       params_load_from_ee();
0067C:  BRA    05AE
....................    }
0067E:  GOTO   A61A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  C4
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00682:  RCALL  0138
....................    switch(ch)
00684:  MOVLB  6
00686:  MOVF   x82,W
00688:  ADDLW  FC
0068A:  BC    06BE
0068C:  ADDLW  04
0068E:  MOVLB  0
00690:  GOTO   06CA
....................    {
....................       case 0:
....................          output_low(_CS0);
00694:  MOVLW  1F
00696:  MOVWF  F8A
00698:  BCF    F85.5
....................       break; 
0069A:  MOVLB  6
0069C:  BRA    06BE
....................       case 1:
....................          output_low(_CS1);
0069E:  MOVLW  1F
006A0:  MOVWF  F8A
006A2:  BCF    F85.6
....................       break;   
006A4:  MOVLB  6
006A6:  BRA    06BE
....................       case 2:
....................          output_low(_CS2);
006A8:  MOVLW  1F
006AA:  MOVWF  F8A
006AC:  BCF    F85.7
....................       break;
006AE:  MOVLB  6
006B0:  BRA    06BE
....................       case 3:
....................          output_low(_CS3);
006B2:  MOVLW  C4
006B4:  MOVWF  F88
006B6:  BCF    F83.0
....................       break;              
006B8:  MOVLB  6
006BA:  BRA    06BE
006BC:  MOVLB  6
....................    }
....................    delay_us(10);
006BE:  MOVLW  35
006C0:  MOVWF  00
006C2:  DECFSZ 00,F
006C4:  BRA    06C2
006C6:  MOVLB  0
006C8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  6
0015A:  MOVF   xE3,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  C4
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007B8:  MOVLW  1F
007BA:  MOVWF  F8A
007BC:  BCF    F85.5
....................    output_low(_CS1);
007BE:  MOVWF  F8A
007C0:  BCF    F85.6
....................    output_low(_CS2);
007C2:  MOVWF  F8A
007C4:  BCF    F85.7
....................    output_low(_CS3);
007C6:  MOVLW  C4
007C8:  MOVWF  F88
007CA:  BCF    F83.0
....................    delay_us(10);
007CC:  MOVLW  35
007CE:  MOVWF  00
007D0:  DECFSZ 00,F
007D2:  BRA    07D0
007D4:  GOTO   07DA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006EC:  MOVFF  680,682
006F0:  RCALL  0682
....................    spi_write2(command);
006F2:  MOVLB  E
006F4:  MOVF   x8D,W
006F6:  MOVFF  681,E8D
006FA:  RRCF   x90,W
006FC:  BNC   06FA
006FE:  MOVLB  0
00700:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  6E1,6E3
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  6E2,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007D8:  BRA    07B8
....................    spi_write2(command);
007DA:  MOVLB  E
007DC:  MOVF   x8D,W
007DE:  MOVFF  677,E8D
007E2:  RRCF   x90,W
007E4:  BNC   07E2
007E6:  MOVLB  0
007E8:  GOTO   07F6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00804:  MOVFF  67F,682
00808:  RCALL  0682
....................    spi_read2(command);
0080A:  MOVLB  E
0080C:  MOVF   x8D,W
0080E:  MOVFF  680,E8D
00812:  RRCF   x90,W
00814:  BNC   0812
00816:  MOVLB  0
00818:  GOTO   082A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00728:  MOVLB  6
0072A:  MOVF   x7D,W
0072C:  IORLW  40
0072E:  MOVWF  x7F
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00730:  MOVFF  67C,680
00734:  MOVFF  67F,681
00738:  MOVLB  0
0073A:  RCALL  06EC
....................    spi_write2(data);
0073C:  MOVLB  E
0073E:  MOVF   x8D,W
00740:  MOVFF  67E,E8D
00744:  RRCF   x90,W
00746:  BNC   0744
....................    ads_deselect_all();
00748:  MOVLB  0
0074A:  RCALL  0138
0074C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  6E0,6E1
001A8:  MOVLW  08
001AA:  MOVLB  6
001AC:  MOVWF  xE2
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007EC:  MOVLW  08
007EE:  MOVLB  6
007F0:  MOVWF  x77
007F2:  MOVLB  0
007F4:  BRA    07D8
....................    delay_us(10);
007F6:  MOVLW  35
007F8:  MOVWF  00
007FA:  DECFSZ 00,F
007FC:  BRA    07FA
....................    ads_deselect_all();
007FE:  RCALL  0138
00800:  GOTO   0986 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0081C:  MOVFF  67A,67F
00820:  MOVLW  10
00822:  MOVLB  6
00824:  MOVWF  x80
00826:  MOVLB  0
00828:  BRA    0804
....................    data.dBytes[3] = 0;
0082A:  MOVLB  6
0082C:  CLRF   x7E
....................    data.dBytes[2] = spi_read2(0);
0082E:  MOVLB  E
00830:  MOVF   x8D,W
00832:  CLRF   x8D
00834:  RRCF   x90,W
00836:  BNC   0834
00838:  MOVFF  E8D,67D
....................    data.dBytes[1] = spi_read2(0);
0083C:  MOVF   x8D,W
0083E:  CLRF   x8D
00840:  RRCF   x90,W
00842:  BNC   0840
00844:  MOVFF  E8D,67C
....................    data.dBytes[0] = spi_read2(0);
00848:  MOVF   x8D,W
0084A:  CLRF   x8D
0084C:  RRCF   x90,W
0084E:  BNC   084C
00850:  MOVFF  E8D,67B
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00854:  MOVLB  6
00856:  MOVF   x7D,W
00858:  ANDLW  80
0085A:  BZ    0860
0085C:  MOVLW  FF
0085E:  IORWF  x7E,F
....................    
....................    ads_deselect_all();
00860:  MOVLB  0
00862:  RCALL  0138
....................    return data.dWord;
00864:  MOVFF  67B,00
00868:  MOVFF  67C,01
0086C:  MOVFF  67D,02
00870:  MOVFF  67E,03
00874:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0074E:  MOVFF  677,680
00752:  MOVLW  06
00754:  MOVLB  6
00756:  MOVWF  x81
00758:  MOVLB  0
0075A:  RCALL  06EC
....................    delay_us(300);                    
0075C:  MOVLW  02
0075E:  MOVLB  6
00760:  MOVWF  x7C
00762:  MOVLW  96
00764:  MOVWF  x7D
00766:  MOVLB  0
00768:  BRA    0702
0076A:  MOVLB  6
0076C:  DECFSZ x7C,F
0076E:  BRA    0762
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
00770:  MOVFF  677,67C
00774:  CLRF   x7D
00776:  MOVFF  678,67E
0077A:  MOVLB  0
0077C:  RCALL  0728
....................    ads_write_reg(ch, reg1, rc1);
0077E:  MOVFF  677,67C
00782:  MOVLW  04
00784:  MOVLB  6
00786:  MOVWF  x7D
00788:  MOVFF  679,67E
0078C:  MOVLB  0
0078E:  RCALL  0728
....................    ads_write_reg(ch, reg2, rc2);
00790:  MOVFF  677,67C
00794:  MOVLW  08
00796:  MOVLB  6
00798:  MOVWF  x7D
0079A:  MOVFF  67A,67E
0079E:  MOVLB  0
007A0:  RCALL  0728
....................    ads_write_reg(ch, reg3, rc3);  
007A2:  MOVFF  677,67C
007A6:  MOVLW  0C
007A8:  MOVLB  6
007AA:  MOVWF  x7D
007AC:  MOVFF  67B,67E
007B0:  MOVLB  0
007B2:  RCALL  0728
007B4:  GOTO   0960 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
0271A:  MOVLB  6
0271C:  BCF    xBB.0
....................    y = x;
0271E:  MOVFF  6AF,6B4
02722:  MOVFF  6AE,6B3
02726:  MOVFF  6AD,6B2
0272A:  MOVFF  6AC,6B1
.................... 
....................    if (x < 0)
0272E:  MOVFF  6AF,6BF
02732:  MOVFF  6AE,6BE
02736:  MOVFF  6AD,6BD
0273A:  MOVFF  6AC,6BC
0273E:  CLRF   xC3
02740:  CLRF   xC2
02742:  CLRF   xC1
02744:  CLRF   xC0
02746:  MOVLB  0
02748:  CALL   1CEA
0274C:  BNC   275A
....................    {
....................       s = 1;
0274E:  MOVLB  6
02750:  BSF    xBB.0
....................       y = -y;
02752:  MOVF   xB2,W
02754:  XORLW  80
02756:  MOVWF  xB2
02758:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
0275A:  MOVFF  6B4,6BF
0275E:  MOVFF  6B3,6BE
02762:  MOVFF  6B2,6BD
02766:  MOVFF  6B1,6BC
0276A:  MOVLB  6
0276C:  CLRF   xC3
0276E:  CLRF   xC2
02770:  CLRF   xC1
02772:  MOVLW  8E
02774:  MOVWF  xC0
02776:  MOVLB  0
02778:  CALL   1CEA
0277C:  BC    2780
0277E:  BNZ   27B0
....................       res = (float32)(unsigned int16)y;
02780:  MOVFF  6B4,6BF
02784:  MOVFF  6B3,6BE
02788:  MOVFF  6B2,6BD
0278C:  MOVFF  6B1,6BC
02790:  RCALL  26DE
02792:  MOVFF  02,6C1
02796:  MOVFF  01,6C0
0279A:  CALL   0D28
0279E:  MOVFF  03,6B8
027A2:  MOVFF  02,6B7
027A6:  MOVFF  01,6B6
027AA:  MOVFF  00,6B5
027AE:  BRA    2952
.................... 
....................  else if (y < 10000000.0)
027B0:  MOVFF  6B4,6BF
027B4:  MOVFF  6B3,6BE
027B8:  MOVFF  6B2,6BD
027BC:  MOVFF  6B1,6BC
027C0:  MOVLW  80
027C2:  MOVLB  6
027C4:  MOVWF  xC3
027C6:  MOVLW  96
027C8:  MOVWF  xC2
027CA:  MOVLW  18
027CC:  MOVWF  xC1
027CE:  MOVLW  96
027D0:  MOVWF  xC0
027D2:  MOVLB  0
027D4:  CALL   1CEA
027D8:  BTFSS  FD8.0
027DA:  BRA    2942
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
027DC:  MOVFF  6B4,6C4
027E0:  MOVFF  6B3,6C3
027E4:  MOVFF  6B2,6C2
027E8:  MOVFF  6B1,6C1
027EC:  MOVLB  6
027EE:  CLRF   xC8
027F0:  CLRF   xC7
027F2:  CLRF   xC6
027F4:  MOVLW  70
027F6:  MOVWF  xC5
027F8:  MOVLB  0
027FA:  CALL   0D5E
027FE:  MOVFF  03,6BF
02802:  MOVFF  02,6BE
02806:  MOVFF  01,6BD
0280A:  MOVFF  00,6BC
0280E:  RCALL  26DE
02810:  MOVFF  02,6BA
02814:  MOVFF  01,6B9
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02818:  MOVFF  6B4,6C4
0281C:  MOVFF  6B3,6C3
02820:  MOVFF  6B2,6C2
02824:  MOVFF  6B1,6C1
02828:  MOVLB  6
0282A:  CLRF   xC8
0282C:  CLRF   xC7
0282E:  CLRF   xC6
02830:  MOVLW  70
02832:  MOVWF  xC5
02834:  MOVLB  0
02836:  CALL   0D5E
0283A:  MOVFF  03,6BF
0283E:  MOVFF  02,6BE
02842:  MOVFF  01,6BD
02846:  MOVFF  00,6BC
0284A:  MOVFF  6BA,6C1
0284E:  MOVFF  6B9,6C0
02852:  CALL   0D28
02856:  BSF    FD8.1
02858:  MOVFF  6BF,6C3
0285C:  MOVFF  6BE,6C2
02860:  MOVFF  6BD,6C1
02864:  MOVFF  6BC,6C0
02868:  MOVFF  03,6C7
0286C:  MOVFF  02,6C6
02870:  MOVFF  01,6C5
02874:  MOVFF  00,6C4
02878:  CALL   0E54
0287C:  MOVLB  6
0287E:  CLRF   xC4
02880:  CLRF   xC3
02882:  CLRF   xC2
02884:  MOVLW  8E
02886:  MOVWF  xC1
02888:  MOVFF  03,6C8
0288C:  MOVFF  02,6C7
02890:  MOVFF  01,6C6
02894:  MOVFF  00,6C5
02898:  MOVLB  0
0289A:  CALL   0D5E
0289E:  MOVFF  03,6B4
028A2:  MOVFF  02,6B3
028A6:  MOVFF  01,6B2
028AA:  MOVFF  00,6B1
....................       res = 32768.0*(float32)l;
028AE:  MOVFF  6BA,6C1
028B2:  MOVFF  6B9,6C0
028B6:  CALL   0D28
028BA:  MOVLB  6
028BC:  CLRF   xC4
028BE:  CLRF   xC3
028C0:  CLRF   xC2
028C2:  MOVLW  8E
028C4:  MOVWF  xC1
028C6:  MOVFF  03,6C8
028CA:  MOVFF  02,6C7
028CE:  MOVFF  01,6C6
028D2:  MOVFF  00,6C5
028D6:  MOVLB  0
028D8:  CALL   0D5E
028DC:  MOVFF  03,6B8
028E0:  MOVFF  02,6B7
028E4:  MOVFF  01,6B6
028E8:  MOVFF  00,6B5
....................       res += (float32)(unsigned int16)y;
028EC:  MOVFF  6B4,6BF
028F0:  MOVFF  6B3,6BE
028F4:  MOVFF  6B2,6BD
028F8:  MOVFF  6B1,6BC
028FC:  RCALL  26DE
028FE:  MOVFF  02,6C1
02902:  MOVFF  01,6C0
02906:  CALL   0D28
0290A:  BCF    FD8.1
0290C:  MOVFF  6B8,6C3
02910:  MOVFF  6B7,6C2
02914:  MOVFF  6B6,6C1
02918:  MOVFF  6B5,6C0
0291C:  MOVFF  03,6C7
02920:  MOVFF  02,6C6
02924:  MOVFF  01,6C5
02928:  MOVFF  00,6C4
0292C:  CALL   0E54
02930:  MOVFF  03,6B8
02934:  MOVFF  02,6B7
02938:  MOVFF  01,6B6
0293C:  MOVFF  00,6B5
....................    }
02940:  BRA    2952
.................... 
....................  else
....................   res = y;
02942:  MOVFF  6B4,6B8
02946:  MOVFF  6B3,6B7
0294A:  MOVFF  6B2,6B6
0294E:  MOVFF  6B1,6B5
.................... 
....................  y = y - (float32)(unsigned int16)y;
02952:  MOVFF  6B4,6BF
02956:  MOVFF  6B3,6BE
0295A:  MOVFF  6B2,6BD
0295E:  MOVFF  6B1,6BC
02962:  RCALL  26DE
02964:  MOVFF  02,6C1
02968:  MOVFF  01,6C0
0296C:  CALL   0D28
02970:  BSF    FD8.1
02972:  MOVFF  6B4,6C3
02976:  MOVFF  6B3,6C2
0297A:  MOVFF  6B2,6C1
0297E:  MOVFF  6B1,6C0
02982:  MOVFF  03,6C7
02986:  MOVFF  02,6C6
0298A:  MOVFF  01,6C5
0298E:  MOVFF  00,6C4
02992:  CALL   0E54
02996:  MOVFF  03,6B4
0299A:  MOVFF  02,6B3
0299E:  MOVFF  01,6B2
029A2:  MOVFF  00,6B1
.................... 
....................  if (s)
029A6:  MOVLB  6
029A8:  BTFSS  xBB.0
029AA:  BRA    29B2
....................   res = -res;
029AC:  MOVF   xB6,W
029AE:  XORLW  80
029B0:  MOVWF  xB6
.................... 
....................  if (y != 0)
029B2:  MOVFF  6B4,6BF
029B6:  MOVFF  6B3,6BE
029BA:  MOVFF  6B2,6BD
029BE:  MOVFF  6B1,6BC
029C2:  CLRF   xC3
029C4:  CLRF   xC2
029C6:  CLRF   xC1
029C8:  CLRF   xC0
029CA:  MOVLB  0
029CC:  CALL   1CEA
029D0:  BZ    2A4A
....................  {
....................   if (s == 1 && n == 0)
029D2:  MOVLB  6
029D4:  BTFSS  xBB.0
029D6:  BRA    2A10
029D8:  MOVF   xB0,F
029DA:  BNZ   2A10
....................    res -= 1.0;
029DC:  BSF    FD8.1
029DE:  MOVFF  6B8,6C3
029E2:  MOVFF  6B7,6C2
029E6:  MOVFF  6B6,6C1
029EA:  MOVFF  6B5,6C0
029EE:  CLRF   xC7
029F0:  CLRF   xC6
029F2:  CLRF   xC5
029F4:  MOVLW  7F
029F6:  MOVWF  xC4
029F8:  MOVLB  0
029FA:  CALL   0E54
029FE:  MOVFF  03,6B8
02A02:  MOVFF  02,6B7
02A06:  MOVFF  01,6B6
02A0A:  MOVFF  00,6B5
02A0E:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
02A10:  BTFSC  xBB.0
02A12:  BRA    2A4C
02A14:  DECFSZ xB0,W
02A16:  BRA    2A4C
....................    res += 1.0;
02A18:  BCF    FD8.1
02A1A:  MOVFF  6B8,6C3
02A1E:  MOVFF  6B7,6C2
02A22:  MOVFF  6B6,6C1
02A26:  MOVFF  6B5,6C0
02A2A:  CLRF   xC7
02A2C:  CLRF   xC6
02A2E:  CLRF   xC5
02A30:  MOVLW  7F
02A32:  MOVWF  xC4
02A34:  MOVLB  0
02A36:  CALL   0E54
02A3A:  MOVFF  03,6B8
02A3E:  MOVFF  02,6B7
02A42:  MOVFF  01,6B6
02A46:  MOVFF  00,6B5
02A4A:  MOVLB  6
....................  }
....................  if (x == 0)
02A4C:  MOVFF  6AF,6BF
02A50:  MOVFF  6AE,6BE
02A54:  MOVFF  6AD,6BD
02A58:  MOVFF  6AC,6BC
02A5C:  CLRF   xC3
02A5E:  CLRF   xC2
02A60:  CLRF   xC1
02A62:  CLRF   xC0
02A64:  MOVLB  0
02A66:  CALL   1CEA
02A6A:  BNZ   2A78
....................     res = 0;
02A6C:  MOVLB  6
02A6E:  CLRF   xB8
02A70:  CLRF   xB7
02A72:  CLRF   xB6
02A74:  CLRF   xB5
02A76:  MOVLB  0
.................... 
....................  return (res);
02A78:  MOVFF  6B5,00
02A7C:  MOVFF  6B6,01
02A80:  MOVFF  6B7,02
02A84:  MOVFF  6B8,03
02A88:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AA8:  MOVFF  6AB,6AF
02AAC:  MOVFF  6AA,6AE
02AB0:  MOVFF  6A9,6AD
02AB4:  MOVFF  6A8,6AC
02AB8:  MOVLB  6
02ABA:  CLRF   xB0
02ABC:  MOVLB  0
02ABE:  RCALL  271A
02AC0:  GOTO   2BCC (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02A8A:  MOVFF  6AB,6AF
02A8E:  MOVFF  6AA,6AE
02A92:  MOVFF  6A9,6AD
02A96:  MOVFF  6A8,6AC
02A9A:  MOVLW  01
02A9C:  MOVLB  6
02A9E:  MOVWF  xB0
02AA0:  MOVLB  0
02AA2:  RCALL  271A
02AA4:  GOTO   2B84 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AC4:  MOVFF  69F,6BF
02AC8:  MOVFF  69E,6BE
02ACC:  MOVFF  69D,6BD
02AD0:  MOVFF  69C,6BC
02AD4:  MOVLB  6
02AD6:  CLRF   xC3
02AD8:  CLRF   xC2
02ADA:  CLRF   xC1
02ADC:  CLRF   xC0
02ADE:  MOVLB  0
02AE0:  CALL   1CEA
02AE4:  BTFSC  FD8.2
02AE6:  BRA    2C28
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02AE8:  MOVFF  69B,6B8
02AEC:  MOVFF  69A,6B7
02AF0:  MOVFF  699,6B6
02AF4:  MOVFF  698,6B5
02AF8:  MOVFF  69F,6BC
02AFC:  MOVFF  69E,6BB
02B00:  MOVFF  69D,6BA
02B04:  MOVFF  69C,6B9
02B08:  CALL   1D64
02B0C:  MOVFF  03,6A7
02B10:  MOVFF  02,6A6
02B14:  MOVFF  01,6A5
02B18:  MOVFF  00,6A4
02B1C:  MOVFF  03,6BF
02B20:  MOVFF  02,6BE
02B24:  MOVFF  01,6BD
02B28:  MOVFF  00,6BC
02B2C:  MOVLB  6
02B2E:  CLRF   xC3
02B30:  CLRF   xC2
02B32:  CLRF   xC1
02B34:  CLRF   xC0
02B36:  MOVLB  0
02B38:  CALL   1CEA
02B3C:  BNC   2B86
02B3E:  MOVFF  69B,6B8
02B42:  MOVFF  69A,6B7
02B46:  MOVFF  699,6B6
02B4A:  MOVFF  698,6B5
02B4E:  MOVFF  69F,6BC
02B52:  MOVFF  69E,6BB
02B56:  MOVFF  69D,6BA
02B5A:  MOVFF  69C,6B9
02B5E:  CALL   1D64
02B62:  MOVFF  03,6A7
02B66:  MOVFF  02,6A6
02B6A:  MOVFF  01,6A5
02B6E:  MOVFF  00,6A4
02B72:  MOVFF  03,6AB
02B76:  MOVFF  02,6AA
02B7A:  MOVFF  01,6A9
02B7E:  MOVFF  00,6A8
02B82:  BRA    2A8A
02B84:  BRA    2BCC
02B86:  MOVFF  69B,6B8
02B8A:  MOVFF  69A,6B7
02B8E:  MOVFF  699,6B6
02B92:  MOVFF  698,6B5
02B96:  MOVFF  69F,6BC
02B9A:  MOVFF  69E,6BB
02B9E:  MOVFF  69D,6BA
02BA2:  MOVFF  69C,6B9
02BA6:  CALL   1D64
02BAA:  MOVFF  03,6A7
02BAE:  MOVFF  02,6A6
02BB2:  MOVFF  01,6A5
02BB6:  MOVFF  00,6A4
02BBA:  MOVFF  03,6AB
02BBE:  MOVFF  02,6AA
02BC2:  MOVFF  01,6A9
02BC6:  MOVFF  00,6A8
02BCA:  BRA    2AA8
02BCC:  MOVFF  03,6A3
02BD0:  MOVFF  02,6A2
02BD4:  MOVFF  01,6A1
02BD8:  MOVFF  00,6A0
....................       return(x-(i*y));
02BDC:  MOVFF  6A3,6C4
02BE0:  MOVFF  6A2,6C3
02BE4:  MOVFF  6A1,6C2
02BE8:  MOVFF  6A0,6C1
02BEC:  MOVFF  69F,6C8
02BF0:  MOVFF  69E,6C7
02BF4:  MOVFF  69D,6C6
02BF8:  MOVFF  69C,6C5
02BFC:  CALL   0D5E
02C00:  BSF    FD8.1
02C02:  MOVFF  69B,6C3
02C06:  MOVFF  69A,6C2
02C0A:  MOVFF  699,6C1
02C0E:  MOVFF  698,6C0
02C12:  MOVFF  03,6C7
02C16:  MOVFF  02,6C6
02C1A:  MOVFF  01,6C5
02C1E:  MOVFF  00,6C4
02C22:  CALL   0E54
02C26:  BRA    2C28
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C28:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FBE:  MOVFF  69F,6C4
02FC2:  MOVFF  69E,6C3
02FC6:  MOVFF  69D,6C2
02FCA:  MOVFF  69C,6C1
02FCE:  MOVLW  3B
02FD0:  MOVLB  6
02FD2:  MOVWF  xC8
02FD4:  MOVLW  AA
02FD6:  MOVWF  xC7
02FD8:  MOVLW  38
02FDA:  MOVWF  xC6
02FDC:  MOVLW  7F
02FDE:  MOVWF  xC5
02FE0:  MOVLB  0
02FE2:  CALL   0D5E
02FE6:  MOVFF  03,6BF
02FEA:  MOVFF  02,6BE
02FEE:  MOVFF  01,6BD
02FF2:  MOVFF  00,6BC
02FF6:  CALL   26DE
02FFA:  MOVFF  01,6AC
....................    s = 0;
02FFE:  MOVLB  6
03000:  BCF    xAD.0
....................    y = x;
03002:  MOVFF  69F,6A3
03006:  MOVFF  69E,6A2
0300A:  MOVFF  69D,6A1
0300E:  MOVFF  69C,6A0
.................... 
....................    if (x < 0)
03012:  MOVFF  69F,6BF
03016:  MOVFF  69E,6BE
0301A:  MOVFF  69D,6BD
0301E:  MOVFF  69C,6BC
03022:  CLRF   xC3
03024:  CLRF   xC2
03026:  CLRF   xC1
03028:  CLRF   xC0
0302A:  MOVLB  0
0302C:  CALL   1CEA
03030:  BNC   3040
....................    {
....................       s = 1;
03032:  MOVLB  6
03034:  BSF    xAD.0
....................       n = -n;
03036:  NEGF   xAC
....................       y = -y;
03038:  MOVF   xA1,W
0303A:  XORLW  80
0303C:  MOVWF  xA1
0303E:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03040:  MOVLB  6
03042:  CLRF   xA7
03044:  CLRF   xA6
03046:  CLRF   xA5
03048:  CLRF   xA4
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
0304A:  MOVLW  06
0304C:  MOVWF  xAF
0304E:  MOVLW  A4
03050:  MOVFF  6AF,FEA
03054:  MOVWF  FE9
03056:  MOVLW  7F
03058:  ADDWF  xAC,W
0305A:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0305C:  MOVFF  6A3,6C4
03060:  MOVFF  6A2,6C3
03064:  MOVFF  6A1,6C2
03068:  MOVFF  6A0,6C1
0306C:  MOVLW  3B
0306E:  MOVWF  xC8
03070:  MOVLW  AA
03072:  MOVWF  xC7
03074:  MOVLW  38
03076:  MOVWF  xC6
03078:  MOVLW  7F
0307A:  MOVWF  xC5
0307C:  MOVLB  0
0307E:  CALL   0D5E
03082:  MOVFF  03,6B1
03086:  MOVFF  02,6B0
0308A:  MOVFF  01,6AF
0308E:  MOVFF  00,6AE
03092:  MOVLB  6
03094:  CLRF   xB3
03096:  MOVFF  6AC,6B2
0309A:  BTFSC  xB2.7
0309C:  DECF   xB3,F
0309E:  MOVLB  0
030A0:  CALL   268E
030A4:  BSF    FD8.1
030A6:  MOVFF  6B1,6C3
030AA:  MOVFF  6B0,6C2
030AE:  MOVFF  6AF,6C1
030B2:  MOVFF  6AE,6C0
030B6:  MOVFF  03,6C7
030BA:  MOVFF  02,6C6
030BE:  MOVFF  01,6C5
030C2:  MOVFF  00,6C4
030C6:  CALL   0E54
030CA:  MOVFF  03,6A3
030CE:  MOVFF  02,6A2
030D2:  MOVFF  01,6A1
030D6:  MOVFF  00,6A0
.................... 
....................    r = pe[0]*y + pe[1];
030DA:  MOVLW  7C
030DC:  MOVLB  6
030DE:  MOVWF  xC4
030E0:  MOVLW  88
030E2:  MOVWF  xC3
030E4:  MOVLW  59
030E6:  MOVWF  xC2
030E8:  MOVLW  72
030EA:  MOVWF  xC1
030EC:  MOVFF  6A3,6C8
030F0:  MOVFF  6A2,6C7
030F4:  MOVFF  6A1,6C6
030F8:  MOVFF  6A0,6C5
030FC:  MOVLB  0
030FE:  CALL   0D5E
03102:  MOVFF  03,6B1
03106:  MOVFF  02,6B0
0310A:  MOVFF  01,6AF
0310E:  MOVFF  00,6AE
03112:  BCF    FD8.1
03114:  MOVFF  03,6C3
03118:  MOVFF  02,6C2
0311C:  MOVFF  01,6C1
03120:  MOVFF  00,6C0
03124:  MOVLW  E0
03126:  MOVLB  6
03128:  MOVWF  xC7
0312A:  MOVLW  97
0312C:  MOVWF  xC6
0312E:  MOVLW  26
03130:  MOVWF  xC5
03132:  MOVLW  75
03134:  MOVWF  xC4
03136:  MOVLB  0
03138:  CALL   0E54
0313C:  MOVFF  03,6AB
03140:  MOVFF  02,6AA
03144:  MOVFF  01,6A9
03148:  MOVFF  00,6A8
....................    r = r*y + pe[2];
0314C:  MOVFF  6AB,6C4
03150:  MOVFF  6AA,6C3
03154:  MOVFF  6A9,6C2
03158:  MOVFF  6A8,6C1
0315C:  MOVFF  6A3,6C8
03160:  MOVFF  6A2,6C7
03164:  MOVFF  6A1,6C6
03168:  MOVFF  6A0,6C5
0316C:  CALL   0D5E
03170:  MOVFF  03,6B1
03174:  MOVFF  02,6B0
03178:  MOVFF  01,6AF
0317C:  MOVFF  00,6AE
03180:  BCF    FD8.1
03182:  MOVFF  03,6C3
03186:  MOVFF  02,6C2
0318A:  MOVFF  01,6C1
0318E:  MOVFF  00,6C0
03192:  MOVLW  C4
03194:  MOVLB  6
03196:  MOVWF  xC7
03198:  MOVLW  1D
0319A:  MOVWF  xC6
0319C:  MOVLW  1E
0319E:  MOVWF  xC5
031A0:  MOVLW  78
031A2:  MOVWF  xC4
031A4:  MOVLB  0
031A6:  CALL   0E54
031AA:  MOVFF  03,6AB
031AE:  MOVFF  02,6AA
031B2:  MOVFF  01,6A9
031B6:  MOVFF  00,6A8
....................    r = r*y + pe[3];
031BA:  MOVFF  6AB,6C4
031BE:  MOVFF  6AA,6C3
031C2:  MOVFF  6A9,6C2
031C6:  MOVFF  6A8,6C1
031CA:  MOVFF  6A3,6C8
031CE:  MOVFF  6A2,6C7
031D2:  MOVFF  6A1,6C6
031D6:  MOVFF  6A0,6C5
031DA:  CALL   0D5E
031DE:  MOVFF  03,6B1
031E2:  MOVFF  02,6B0
031E6:  MOVFF  01,6AF
031EA:  MOVFF  00,6AE
031EE:  BCF    FD8.1
031F0:  MOVFF  03,6C3
031F4:  MOVFF  02,6C2
031F8:  MOVFF  01,6C1
031FC:  MOVFF  00,6C0
03200:  MOVLW  5E
03202:  MOVLB  6
03204:  MOVWF  xC7
03206:  MOVLW  50
03208:  MOVWF  xC6
0320A:  MOVLW  63
0320C:  MOVWF  xC5
0320E:  MOVLW  7A
03210:  MOVWF  xC4
03212:  MOVLB  0
03214:  CALL   0E54
03218:  MOVFF  03,6AB
0321C:  MOVFF  02,6AA
03220:  MOVFF  01,6A9
03224:  MOVFF  00,6A8
....................    r = r*y + pe[4];
03228:  MOVFF  6AB,6C4
0322C:  MOVFF  6AA,6C3
03230:  MOVFF  6A9,6C2
03234:  MOVFF  6A8,6C1
03238:  MOVFF  6A3,6C8
0323C:  MOVFF  6A2,6C7
03240:  MOVFF  6A1,6C6
03244:  MOVFF  6A0,6C5
03248:  CALL   0D5E
0324C:  MOVFF  03,6B1
03250:  MOVFF  02,6B0
03254:  MOVFF  01,6AF
03258:  MOVFF  00,6AE
0325C:  BCF    FD8.1
0325E:  MOVFF  03,6C3
03262:  MOVFF  02,6C2
03266:  MOVFF  01,6C1
0326A:  MOVFF  00,6C0
0326E:  MOVLW  1A
03270:  MOVLB  6
03272:  MOVWF  xC7
03274:  MOVLW  FE
03276:  MOVWF  xC6
03278:  MOVLW  75
0327A:  MOVWF  xC5
0327C:  MOVLW  7C
0327E:  MOVWF  xC4
03280:  MOVLB  0
03282:  CALL   0E54
03286:  MOVFF  03,6AB
0328A:  MOVFF  02,6AA
0328E:  MOVFF  01,6A9
03292:  MOVFF  00,6A8
....................    r = r*y + pe[5];
03296:  MOVFF  6AB,6C4
0329A:  MOVFF  6AA,6C3
0329E:  MOVFF  6A9,6C2
032A2:  MOVFF  6A8,6C1
032A6:  MOVFF  6A3,6C8
032AA:  MOVFF  6A2,6C7
032AE:  MOVFF  6A1,6C6
032B2:  MOVFF  6A0,6C5
032B6:  CALL   0D5E
032BA:  MOVFF  03,6B1
032BE:  MOVFF  02,6B0
032C2:  MOVFF  01,6AF
032C6:  MOVFF  00,6AE
032CA:  BCF    FD8.1
032CC:  MOVFF  03,6C3
032D0:  MOVFF  02,6C2
032D4:  MOVFF  01,6C1
032D8:  MOVFF  00,6C0
032DC:  MOVLW  18
032DE:  MOVLB  6
032E0:  MOVWF  xC7
032E2:  MOVLW  72
032E4:  MOVWF  xC6
032E6:  MOVLW  31
032E8:  MOVWF  xC5
032EA:  MOVLW  7E
032EC:  MOVWF  xC4
032EE:  MOVLB  0
032F0:  CALL   0E54
032F4:  MOVFF  03,6AB
032F8:  MOVFF  02,6AA
032FC:  MOVFF  01,6A9
03300:  MOVFF  00,6A8
.................... 
....................    res = res*(1.0 + y*r);
03304:  MOVFF  6A3,6C4
03308:  MOVFF  6A2,6C3
0330C:  MOVFF  6A1,6C2
03310:  MOVFF  6A0,6C1
03314:  MOVFF  6AB,6C8
03318:  MOVFF  6AA,6C7
0331C:  MOVFF  6A9,6C6
03320:  MOVFF  6A8,6C5
03324:  CALL   0D5E
03328:  BCF    FD8.1
0332A:  MOVLB  6
0332C:  CLRF   xC3
0332E:  CLRF   xC2
03330:  CLRF   xC1
03332:  MOVLW  7F
03334:  MOVWF  xC0
03336:  MOVFF  03,6C7
0333A:  MOVFF  02,6C6
0333E:  MOVFF  01,6C5
03342:  MOVFF  00,6C4
03346:  MOVLB  0
03348:  CALL   0E54
0334C:  MOVFF  6A7,6C4
03350:  MOVFF  6A6,6C3
03354:  MOVFF  6A5,6C2
03358:  MOVFF  6A4,6C1
0335C:  MOVFF  03,6C8
03360:  MOVFF  02,6C7
03364:  MOVFF  01,6C6
03368:  MOVFF  00,6C5
0336C:  CALL   0D5E
03370:  MOVFF  03,6A7
03374:  MOVFF  02,6A6
03378:  MOVFF  01,6A5
0337C:  MOVFF  00,6A4
.................... 
....................    if (s)
03380:  MOVLB  6
03382:  BTFSS  xAD.0
03384:  BRA    33B8
....................       res = 1.0/res;
03386:  CLRF   xB8
03388:  CLRF   xB7
0338A:  CLRF   xB6
0338C:  MOVLW  7F
0338E:  MOVWF  xB5
03390:  MOVFF  6A7,6BC
03394:  MOVFF  6A6,6BB
03398:  MOVFF  6A5,6BA
0339C:  MOVFF  6A4,6B9
033A0:  MOVLB  0
033A2:  CALL   1D64
033A6:  MOVFF  03,6A7
033AA:  MOVFF  02,6A6
033AE:  MOVFF  01,6A5
033B2:  MOVFF  00,6A4
033B6:  MOVLB  6
....................    return(res);
033B8:  MOVFF  6A4,00
033BC:  MOVFF  6A5,01
033C0:  MOVFF  6A6,02
033C4:  MOVFF  6A7,03
033C8:  MOVLB  0
033CA:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C2A:  MOVFF  69F,6A3
02C2E:  MOVFF  69E,6A2
02C32:  MOVFF  69D,6A1
02C36:  MOVFF  69C,6A0
.................... 
....................    if (y != 1.0)
02C3A:  MOVFF  6A3,6BF
02C3E:  MOVFF  6A2,6BE
02C42:  MOVFF  6A1,6BD
02C46:  MOVFF  6A0,6BC
02C4A:  MOVLB  6
02C4C:  CLRF   xC3
02C4E:  CLRF   xC2
02C50:  CLRF   xC1
02C52:  MOVLW  7F
02C54:  MOVWF  xC0
02C56:  MOVLB  0
02C58:  CALL   1CEA
02C5C:  BTFSC  FD8.2
02C5E:  BRA    2FA0
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C60:  MOVLW  06
02C62:  MOVLB  6
02C64:  MOVWF  xB2
02C66:  MOVLW  A0
02C68:  MOVFF  6B2,FEA
02C6C:  MOVWF  FE9
02C6E:  MOVLW  7E
02C70:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02C72:  BSF    FD8.1
02C74:  MOVFF  6A3,6C3
02C78:  MOVFF  6A2,6C2
02C7C:  MOVFF  6A1,6C1
02C80:  MOVFF  6A0,6C0
02C84:  CLRF   xC7
02C86:  CLRF   xC6
02C88:  CLRF   xC5
02C8A:  MOVLW  7F
02C8C:  MOVWF  xC4
02C8E:  MOVLB  0
02C90:  CALL   0E54
02C94:  MOVFF  03,6B4
02C98:  MOVFF  02,6B3
02C9C:  MOVFF  01,6B2
02CA0:  MOVFF  00,6B1
02CA4:  BCF    FD8.1
02CA6:  MOVFF  6A3,6C3
02CAA:  MOVFF  6A2,6C2
02CAE:  MOVFF  6A1,6C1
02CB2:  MOVFF  6A0,6C0
02CB6:  MOVLB  6
02CB8:  CLRF   xC7
02CBA:  CLRF   xC6
02CBC:  CLRF   xC5
02CBE:  MOVLW  7F
02CC0:  MOVWF  xC4
02CC2:  MOVLB  0
02CC4:  CALL   0E54
02CC8:  MOVFF  6B4,6B8
02CCC:  MOVFF  6B3,6B7
02CD0:  MOVFF  6B2,6B6
02CD4:  MOVFF  6B1,6B5
02CD8:  MOVFF  03,6BC
02CDC:  MOVFF  02,6BB
02CE0:  MOVFF  01,6BA
02CE4:  MOVFF  00,6B9
02CE8:  CALL   1D64
02CEC:  MOVFF  03,6A3
02CF0:  MOVFF  02,6A2
02CF4:  MOVFF  01,6A1
02CF8:  MOVFF  00,6A0
.................... 
....................       y2=y*y;
02CFC:  MOVFF  6A3,6C4
02D00:  MOVFF  6A2,6C3
02D04:  MOVFF  6A1,6C2
02D08:  MOVFF  6A0,6C1
02D0C:  MOVFF  6A3,6C8
02D10:  MOVFF  6A2,6C7
02D14:  MOVFF  6A1,6C6
02D18:  MOVFF  6A0,6C5
02D1C:  CALL   0D5E
02D20:  MOVFF  03,6AF
02D24:  MOVFF  02,6AE
02D28:  MOVFF  01,6AD
02D2C:  MOVFF  00,6AC
.................... 
....................       res = pl[0]*y2 + pl[1];
02D30:  MOVLW  99
02D32:  MOVLB  6
02D34:  MOVWF  xC4
02D36:  MOVLW  47
02D38:  MOVWF  xC3
02D3A:  MOVLW  8A
02D3C:  MOVWF  xC2
02D3E:  MOVLW  7F
02D40:  MOVWF  xC1
02D42:  MOVFF  6AF,6C8
02D46:  MOVFF  6AE,6C7
02D4A:  MOVFF  6AD,6C6
02D4E:  MOVFF  6AC,6C5
02D52:  MOVLB  0
02D54:  CALL   0D5E
02D58:  MOVFF  03,6B4
02D5C:  MOVFF  02,6B3
02D60:  MOVFF  01,6B2
02D64:  MOVFF  00,6B1
02D68:  BCF    FD8.1
02D6A:  MOVFF  03,6C3
02D6E:  MOVFF  02,6C2
02D72:  MOVFF  01,6C1
02D76:  MOVFF  00,6C0
02D7A:  MOVLB  6
02D7C:  CLRF   xC7
02D7E:  CLRF   xC6
02D80:  CLRF   xC5
02D82:  MOVLW  80
02D84:  MOVWF  xC4
02D86:  MOVLB  0
02D88:  CALL   0E54
02D8C:  MOVFF  03,6A7
02D90:  MOVFF  02,6A6
02D94:  MOVFF  01,6A5
02D98:  MOVFF  00,6A4
.................... 
....................       r = ql[0]*y2 + ql[1];
02D9C:  MOVLW  4C
02D9E:  MOVLB  6
02DA0:  MOVWF  xC4
02DA2:  MOVLW  F3
02DA4:  MOVWF  xC3
02DA6:  MOVLW  3A
02DA8:  MOVWF  xC2
02DAA:  MOVLW  7B
02DAC:  MOVWF  xC1
02DAE:  MOVFF  6AF,6C8
02DB2:  MOVFF  6AE,6C7
02DB6:  MOVFF  6AD,6C6
02DBA:  MOVFF  6AC,6C5
02DBE:  MOVLB  0
02DC0:  CALL   0D5E
02DC4:  MOVFF  03,6B4
02DC8:  MOVFF  02,6B3
02DCC:  MOVFF  01,6B2
02DD0:  MOVFF  00,6B1
02DD4:  BCF    FD8.1
02DD6:  MOVFF  03,6C3
02DDA:  MOVFF  02,6C2
02DDE:  MOVFF  01,6C1
02DE2:  MOVFF  00,6C0
02DE6:  MOVLW  2B
02DE8:  MOVLB  6
02DEA:  MOVWF  xC7
02DEC:  MOVLW  9D
02DEE:  MOVWF  xC6
02DF0:  MOVLW  DF
02DF2:  MOVWF  xC5
02DF4:  MOVLW  7E
02DF6:  MOVWF  xC4
02DF8:  MOVLB  0
02DFA:  CALL   0E54
02DFE:  MOVFF  03,6AB
02E02:  MOVFF  02,6AA
02E06:  MOVFF  01,6A9
02E0A:  MOVFF  00,6A8
....................       r = r*y2 + 1.0;
02E0E:  MOVFF  6AB,6C4
02E12:  MOVFF  6AA,6C3
02E16:  MOVFF  6A9,6C2
02E1A:  MOVFF  6A8,6C1
02E1E:  MOVFF  6AF,6C8
02E22:  MOVFF  6AE,6C7
02E26:  MOVFF  6AD,6C6
02E2A:  MOVFF  6AC,6C5
02E2E:  CALL   0D5E
02E32:  MOVFF  03,6B4
02E36:  MOVFF  02,6B3
02E3A:  MOVFF  01,6B2
02E3E:  MOVFF  00,6B1
02E42:  BCF    FD8.1
02E44:  MOVFF  03,6C3
02E48:  MOVFF  02,6C2
02E4C:  MOVFF  01,6C1
02E50:  MOVFF  00,6C0
02E54:  MOVLB  6
02E56:  CLRF   xC7
02E58:  CLRF   xC6
02E5A:  CLRF   xC5
02E5C:  MOVLW  7F
02E5E:  MOVWF  xC4
02E60:  MOVLB  0
02E62:  CALL   0E54
02E66:  MOVFF  03,6AB
02E6A:  MOVFF  02,6AA
02E6E:  MOVFF  01,6A9
02E72:  MOVFF  00,6A8
.................... 
....................       res = y*res/r;
02E76:  MOVFF  6A3,6C4
02E7A:  MOVFF  6A2,6C3
02E7E:  MOVFF  6A1,6C2
02E82:  MOVFF  6A0,6C1
02E86:  MOVFF  6A7,6C8
02E8A:  MOVFF  6A6,6C7
02E8E:  MOVFF  6A5,6C6
02E92:  MOVFF  6A4,6C5
02E96:  CALL   0D5E
02E9A:  MOVFF  03,6B4
02E9E:  MOVFF  02,6B3
02EA2:  MOVFF  01,6B2
02EA6:  MOVFF  00,6B1
02EAA:  MOVFF  03,6B8
02EAE:  MOVFF  02,6B7
02EB2:  MOVFF  01,6B6
02EB6:  MOVFF  00,6B5
02EBA:  MOVFF  6AB,6BC
02EBE:  MOVFF  6AA,6BB
02EC2:  MOVFF  6A9,6BA
02EC6:  MOVFF  6A8,6B9
02ECA:  CALL   1D64
02ECE:  MOVFF  03,6A7
02ED2:  MOVFF  02,6A6
02ED6:  MOVFF  01,6A5
02EDA:  MOVFF  00,6A4
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02EDE:  MOVLW  06
02EE0:  MOVLB  6
02EE2:  MOVWF  xB2
02EE4:  MOVLW  9C
02EE6:  MOVFF  6B2,FEA
02EEA:  MOVWF  FE9
02EEC:  MOVLW  7E
02EEE:  SUBWF  FEF,W
02EF0:  MOVWF  xB0
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02EF2:  BTFSS  xB0.7
02EF4:  BRA    2F20
....................          r = -(float32)-n;
02EF6:  MOVLW  00
02EF8:  BSF    FD8.0
02EFA:  SUBFWB xB0,W
02EFC:  CLRF   xB3
02EFE:  MOVWF  xB2
02F00:  BTFSC  xB2.7
02F02:  DECF   xB3,F
02F04:  MOVLB  0
02F06:  CALL   268E
02F0A:  MOVFF  00,6A8
02F0E:  MOVF   01,W
02F10:  XORLW  80
02F12:  MOVLB  6
02F14:  MOVWF  xA9
02F16:  MOVFF  02,6AA
02F1A:  MOVFF  03,6AB
02F1E:  BRA    2F42
....................       else
....................          r = (float32)n;
02F20:  CLRF   xB3
02F22:  MOVFF  6B0,6B2
02F26:  BTFSC  xB2.7
02F28:  DECF   xB3,F
02F2A:  MOVLB  0
02F2C:  CALL   268E
02F30:  MOVFF  03,6AB
02F34:  MOVFF  02,6AA
02F38:  MOVFF  01,6A9
02F3C:  MOVFF  00,6A8
02F40:  MOVLB  6
.................... 
....................       res += r*LN2;
02F42:  MOVFF  6AB,6C4
02F46:  MOVFF  6AA,6C3
02F4A:  MOVFF  6A9,6C2
02F4E:  MOVFF  6A8,6C1
02F52:  MOVLW  18
02F54:  MOVWF  xC8
02F56:  MOVLW  72
02F58:  MOVWF  xC7
02F5A:  MOVLW  31
02F5C:  MOVWF  xC6
02F5E:  MOVLW  7E
02F60:  MOVWF  xC5
02F62:  MOVLB  0
02F64:  CALL   0D5E
02F68:  BCF    FD8.1
02F6A:  MOVFF  6A7,6C3
02F6E:  MOVFF  6A6,6C2
02F72:  MOVFF  6A5,6C1
02F76:  MOVFF  6A4,6C0
02F7A:  MOVFF  03,6C7
02F7E:  MOVFF  02,6C6
02F82:  MOVFF  01,6C5
02F86:  MOVFF  00,6C4
02F8A:  CALL   0E54
02F8E:  MOVFF  03,6A7
02F92:  MOVFF  02,6A6
02F96:  MOVFF  01,6A5
02F9A:  MOVFF  00,6A4
....................    }
02F9E:  BRA    2FAC
.................... 
....................    else
....................       res = 0.0;
02FA0:  MOVLB  6
02FA2:  CLRF   xA7
02FA4:  CLRF   xA6
02FA6:  CLRF   xA5
02FA8:  CLRF   xA4
02FAA:  MOVLB  0
.................... 
....................    return(res);
02FAC:  MOVFF  6A4,00
02FB0:  MOVFF  6A5,01
02FB4:  MOVFF  6A6,02
02FB8:  MOVFF  6A7,03
02FBC:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
033CC:  MOVFF  693,6BF
033D0:  MOVFF  692,6BE
033D4:  MOVFF  691,6BD
033D8:  MOVFF  690,6BC
033DC:  MOVLB  6
033DE:  CLRF   xC3
033E0:  CLRF   xC2
033E2:  CLRF   xC1
033E4:  CLRF   xC0
033E6:  MOVLB  0
033E8:  CALL   1CEA
033EC:  BTFSS  FD8.0
033EE:  BRA    358A
033F0:  MOVFF  697,69B
033F4:  MOVFF  696,69A
033F8:  MOVFF  695,699
033FC:  MOVFF  694,698
03400:  MOVLB  6
03402:  CLRF   x9F
03404:  CLRF   x9E
03406:  CLRF   x9D
03408:  MOVLW  7F
0340A:  MOVWF  x9C
0340C:  MOVLB  0
0340E:  CALL   2AC4
03412:  MOVFF  03,69B
03416:  MOVFF  02,69A
0341A:  MOVFF  01,699
0341E:  MOVFF  00,698
03422:  MOVFF  03,6BF
03426:  MOVFF  02,6BE
0342A:  MOVFF  01,6BD
0342E:  MOVFF  00,6BC
03432:  MOVLB  6
03434:  CLRF   xC3
03436:  CLRF   xC2
03438:  CLRF   xC1
0343A:  CLRF   xC0
0343C:  MOVLB  0
0343E:  CALL   1CEA
03442:  BTFSS  FD8.2
03444:  BRA    358A
....................       if(fmod(y, 2) == 0) {
03446:  MOVFF  697,69B
0344A:  MOVFF  696,69A
0344E:  MOVFF  695,699
03452:  MOVFF  694,698
03456:  MOVLB  6
03458:  CLRF   x9F
0345A:  CLRF   x9E
0345C:  CLRF   x9D
0345E:  MOVLW  80
03460:  MOVWF  x9C
03462:  MOVLB  0
03464:  CALL   2AC4
03468:  MOVFF  03,69B
0346C:  MOVFF  02,69A
03470:  MOVFF  01,699
03474:  MOVFF  00,698
03478:  MOVFF  03,6BF
0347C:  MOVFF  02,6BE
03480:  MOVFF  01,6BD
03484:  MOVFF  00,6BC
03488:  MOVLB  6
0348A:  CLRF   xC3
0348C:  CLRF   xC2
0348E:  CLRF   xC1
03490:  CLRF   xC0
03492:  MOVLB  0
03494:  CALL   1CEA
03498:  BNZ   3510
....................          return (exp(log(-x) * y));
0349A:  MOVLB  6
0349C:  MOVF   x91,W
0349E:  XORLW  80
034A0:  MOVWF  x99
034A2:  MOVFF  693,69F
034A6:  MOVFF  692,69E
034AA:  MOVWF  x9D
034AC:  MOVFF  690,69C
034B0:  MOVLB  0
034B2:  CALL   2C2A
034B6:  MOVFF  03,69B
034BA:  MOVFF  02,69A
034BE:  MOVFF  01,699
034C2:  MOVFF  00,698
034C6:  MOVFF  03,6C4
034CA:  MOVFF  02,6C3
034CE:  MOVFF  01,6C2
034D2:  MOVFF  00,6C1
034D6:  MOVFF  697,6C8
034DA:  MOVFF  696,6C7
034DE:  MOVFF  695,6C6
034E2:  MOVFF  694,6C5
034E6:  CALL   0D5E
034EA:  MOVFF  03,69B
034EE:  MOVFF  02,69A
034F2:  MOVFF  01,699
034F6:  MOVFF  00,698
034FA:  MOVFF  03,69F
034FE:  MOVFF  02,69E
03502:  MOVFF  01,69D
03506:  MOVFF  00,69C
0350A:  RCALL  2FBE
0350C:  BRA    36C8
....................       } else {
0350E:  BRA    3588
....................          return (-exp(log(-x) * y));
03510:  MOVLB  6
03512:  MOVF   x91,W
03514:  XORLW  80
03516:  MOVWF  x99
03518:  MOVFF  693,69F
0351C:  MOVFF  692,69E
03520:  MOVWF  x9D
03522:  MOVFF  690,69C
03526:  MOVLB  0
03528:  CALL   2C2A
0352C:  MOVFF  03,69B
03530:  MOVFF  02,69A
03534:  MOVFF  01,699
03538:  MOVFF  00,698
0353C:  MOVFF  03,6C4
03540:  MOVFF  02,6C3
03544:  MOVFF  01,6C2
03548:  MOVFF  00,6C1
0354C:  MOVFF  697,6C8
03550:  MOVFF  696,6C7
03554:  MOVFF  695,6C6
03558:  MOVFF  694,6C5
0355C:  CALL   0D5E
03560:  MOVFF  03,69B
03564:  MOVFF  02,69A
03568:  MOVFF  01,699
0356C:  MOVFF  00,698
03570:  MOVFF  03,69F
03574:  MOVFF  02,69E
03578:  MOVFF  01,69D
0357C:  MOVFF  00,69C
03580:  RCALL  2FBE
03582:  MOVLW  80
03584:  XORWF  01,F
03586:  BRA    36C8
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03588:  BRA    36C8
0358A:  MOVFF  693,6BF
0358E:  MOVFF  692,6BE
03592:  MOVFF  691,6BD
03596:  MOVFF  690,6BC
0359A:  MOVLB  6
0359C:  CLRF   xC3
0359E:  CLRF   xC2
035A0:  CLRF   xC1
035A2:  CLRF   xC0
035A4:  MOVLB  0
035A6:  CALL   1CEA
035AA:  BNC   360C
035AC:  MOVFF  697,69B
035B0:  MOVFF  696,69A
035B4:  MOVFF  695,699
035B8:  MOVFF  694,698
035BC:  MOVLB  6
035BE:  CLRF   x9F
035C0:  CLRF   x9E
035C2:  CLRF   x9D
035C4:  MOVLW  7F
035C6:  MOVWF  x9C
035C8:  MOVLB  0
035CA:  CALL   2AC4
035CE:  MOVFF  03,69B
035D2:  MOVFF  02,69A
035D6:  MOVFF  01,699
035DA:  MOVFF  00,698
035DE:  MOVFF  03,6BF
035E2:  MOVFF  02,6BE
035E6:  MOVFF  01,6BD
035EA:  MOVFF  00,6BC
035EE:  MOVLB  6
035F0:  CLRF   xC3
035F2:  CLRF   xC2
035F4:  CLRF   xC1
035F6:  CLRF   xC0
035F8:  MOVLB  0
035FA:  CALL   1CEA
035FE:  BZ    360C
....................       return 0;
03600:  CLRF   00
03602:  CLRF   01
03604:  CLRF   02
03606:  CLRF   03
03608:  BRA    36C8
....................    } else {
0360A:  BRA    36C8
....................       if(x != 0 || 0 >= y) {
0360C:  MOVFF  693,6BF
03610:  MOVFF  692,6BE
03614:  MOVFF  691,6BD
03618:  MOVFF  690,6BC
0361C:  MOVLB  6
0361E:  CLRF   xC3
03620:  CLRF   xC2
03622:  CLRF   xC1
03624:  CLRF   xC0
03626:  MOVLB  0
03628:  CALL   1CEA
0362C:  BNZ   3652
0362E:  MOVFF  697,6BF
03632:  MOVFF  696,6BE
03636:  MOVFF  695,6BD
0363A:  MOVFF  694,6BC
0363E:  MOVLB  6
03640:  CLRF   xC3
03642:  CLRF   xC2
03644:  CLRF   xC1
03646:  CLRF   xC0
03648:  MOVLB  0
0364A:  CALL   1CEA
0364E:  BC    3652
03650:  BNZ   36C0
....................          return (exp(log(x) * y));
03652:  MOVFF  693,69F
03656:  MOVFF  692,69E
0365A:  MOVFF  691,69D
0365E:  MOVFF  690,69C
03662:  CALL   2C2A
03666:  MOVFF  03,69B
0366A:  MOVFF  02,69A
0366E:  MOVFF  01,699
03672:  MOVFF  00,698
03676:  MOVFF  03,6C4
0367A:  MOVFF  02,6C3
0367E:  MOVFF  01,6C2
03682:  MOVFF  00,6C1
03686:  MOVFF  697,6C8
0368A:  MOVFF  696,6C7
0368E:  MOVFF  695,6C6
03692:  MOVFF  694,6C5
03696:  CALL   0D5E
0369A:  MOVFF  03,69B
0369E:  MOVFF  02,69A
036A2:  MOVFF  01,699
036A6:  MOVFF  00,698
036AA:  MOVFF  03,69F
036AE:  MOVFF  02,69E
036B2:  MOVFF  01,69D
036B6:  MOVFF  00,69C
036BA:  RCALL  2FBE
036BC:  BRA    36C8
....................       } else return 0;
036BE:  BRA    36C8
036C0:  CLRF   00
036C2:  CLRF   01
036C4:  CLRF   02
036C6:  CLRF   03
....................    }
036C8:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01EC2:  MOVLB  6
01EC4:  BCF    xAE.0
....................    flag = 0;
01EC6:  BCF    xAE.1
....................    y = x;
01EC8:  MOVFF  6A1,6A5
01ECC:  MOVFF  6A0,6A4
01ED0:  MOVFF  69F,6A3
01ED4:  MOVFF  69E,6A2
.................... 
....................    if (x < 0)
01ED8:  MOVFF  6A1,6BF
01EDC:  MOVFF  6A0,6BE
01EE0:  MOVFF  69F,6BD
01EE4:  MOVFF  69E,6BC
01EE8:  CLRF   xC3
01EEA:  CLRF   xC2
01EEC:  CLRF   xC1
01EEE:  CLRF   xC0
01EF0:  MOVLB  0
01EF2:  RCALL  1CEA
01EF4:  BNC   1F02
....................    {
....................       s = 1;
01EF6:  MOVLB  6
01EF8:  BSF    xAE.0
....................       y = -y;
01EFA:  MOVF   xA3,W
01EFC:  XORLW  80
01EFE:  MOVWF  xA3
01F00:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F02:  MOVLB  6
01F04:  CLRF   xBF
01F06:  CLRF   xBE
01F08:  CLRF   xBD
01F0A:  MOVLW  7F
01F0C:  MOVWF  xBC
01F0E:  MOVFF  6A5,6C3
01F12:  MOVFF  6A4,6C2
01F16:  MOVFF  6A3,6C1
01F1A:  MOVFF  6A2,6C0
01F1E:  MOVLB  0
01F20:  RCALL  1CEA
01F22:  BNC   1F5A
....................    {
....................       y = 1.0/y;
01F24:  MOVLB  6
01F26:  CLRF   xB8
01F28:  CLRF   xB7
01F2A:  CLRF   xB6
01F2C:  MOVLW  7F
01F2E:  MOVWF  xB5
01F30:  MOVFF  6A5,6BC
01F34:  MOVFF  6A4,6BB
01F38:  MOVFF  6A3,6BA
01F3C:  MOVFF  6A2,6B9
01F40:  MOVLB  0
01F42:  RCALL  1D64
01F44:  MOVFF  03,6A5
01F48:  MOVFF  02,6A4
01F4C:  MOVFF  01,6A3
01F50:  MOVFF  00,6A2
....................       flag = 1;
01F54:  MOVLB  6
01F56:  BSF    xAE.1
01F58:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F5A:  MOVLW  0A
01F5C:  MOVLB  6
01F5E:  MOVWF  xC4
01F60:  MOVLW  89
01F62:  MOVWF  xC3
01F64:  MOVLW  34
01F66:  MOVWF  xC2
01F68:  MOVLW  7C
01F6A:  MOVWF  xC1
01F6C:  MOVFF  6A5,6C8
01F70:  MOVFF  6A4,6C7
01F74:  MOVFF  6A3,6C6
01F78:  MOVFF  6A2,6C5
01F7C:  MOVLB  0
01F7E:  CALL   0D5E
01F82:  MOVFF  03,6B2
01F86:  MOVFF  02,6B1
01F8A:  MOVFF  01,6B0
01F8E:  MOVFF  00,6AF
01F92:  MOVFF  03,6C4
01F96:  MOVFF  02,6C3
01F9A:  MOVFF  01,6C2
01F9E:  MOVFF  00,6C1
01FA2:  MOVFF  6A5,6C8
01FA6:  MOVFF  6A4,6C7
01FAA:  MOVFF  6A3,6C6
01FAE:  MOVFF  6A2,6C5
01FB2:  CALL   0D5E
01FB6:  MOVFF  03,6B2
01FBA:  MOVFF  02,6B1
01FBE:  MOVFF  01,6B0
01FC2:  MOVFF  00,6AF
01FC6:  BCF    FD8.1
01FC8:  MOVFF  03,6C3
01FCC:  MOVFF  02,6C2
01FD0:  MOVFF  01,6C1
01FD4:  MOVFF  00,6C0
01FD8:  MOVLW  7C
01FDA:  MOVLB  6
01FDC:  MOVWF  xC7
01FDE:  MOVLW  79
01FE0:  MOVWF  xC6
01FE2:  MOVLW  35
01FE4:  MOVWF  xC5
01FE6:  MOVLW  81
01FE8:  MOVWF  xC4
01FEA:  MOVLB  0
01FEC:  CALL   0E54
01FF0:  MOVFF  03,6A9
01FF4:  MOVFF  02,6A8
01FF8:  MOVFF  01,6A7
01FFC:  MOVFF  00,6A6
....................    res = res*y*y + pat[2];
02000:  MOVFF  6A9,6C4
02004:  MOVFF  6A8,6C3
02008:  MOVFF  6A7,6C2
0200C:  MOVFF  6A6,6C1
02010:  MOVFF  6A5,6C8
02014:  MOVFF  6A4,6C7
02018:  MOVFF  6A3,6C6
0201C:  MOVFF  6A2,6C5
02020:  CALL   0D5E
02024:  MOVFF  03,6B2
02028:  MOVFF  02,6B1
0202C:  MOVFF  01,6B0
02030:  MOVFF  00,6AF
02034:  MOVFF  03,6C4
02038:  MOVFF  02,6C3
0203C:  MOVFF  01,6C2
02040:  MOVFF  00,6C1
02044:  MOVFF  6A5,6C8
02048:  MOVFF  6A4,6C7
0204C:  MOVFF  6A3,6C6
02050:  MOVFF  6A2,6C5
02054:  CALL   0D5E
02058:  MOVFF  03,6B2
0205C:  MOVFF  02,6B1
02060:  MOVFF  01,6B0
02064:  MOVFF  00,6AF
02068:  BCF    FD8.1
0206A:  MOVFF  03,6C3
0206E:  MOVFF  02,6C2
02072:  MOVFF  01,6C1
02076:  MOVFF  00,6C0
0207A:  MOVLW  3F
0207C:  MOVLB  6
0207E:  MOVWF  xC7
02080:  MOVLW  02
02082:  MOVWF  xC6
02084:  MOVLW  33
02086:  MOVWF  xC5
02088:  MOVLW  83
0208A:  MOVWF  xC4
0208C:  MOVLB  0
0208E:  CALL   0E54
02092:  MOVFF  03,6A9
02096:  MOVFF  02,6A8
0209A:  MOVFF  01,6A7
0209E:  MOVFF  00,6A6
....................    res = res*y*y + pat[3];
020A2:  MOVFF  6A9,6C4
020A6:  MOVFF  6A8,6C3
020AA:  MOVFF  6A7,6C2
020AE:  MOVFF  6A6,6C1
020B2:  MOVFF  6A5,6C8
020B6:  MOVFF  6A4,6C7
020BA:  MOVFF  6A3,6C6
020BE:  MOVFF  6A2,6C5
020C2:  CALL   0D5E
020C6:  MOVFF  03,6B2
020CA:  MOVFF  02,6B1
020CE:  MOVFF  01,6B0
020D2:  MOVFF  00,6AF
020D6:  MOVFF  03,6C4
020DA:  MOVFF  02,6C3
020DE:  MOVFF  01,6C2
020E2:  MOVFF  00,6C1
020E6:  MOVFF  6A5,6C8
020EA:  MOVFF  6A4,6C7
020EE:  MOVFF  6A3,6C6
020F2:  MOVFF  6A2,6C5
020F6:  CALL   0D5E
020FA:  MOVFF  03,6B2
020FE:  MOVFF  02,6B1
02102:  MOVFF  01,6B0
02106:  MOVFF  00,6AF
0210A:  BCF    FD8.1
0210C:  MOVFF  03,6C3
02110:  MOVFF  02,6C2
02114:  MOVFF  01,6C1
02118:  MOVFF  00,6C0
0211C:  MOVLW  33
0211E:  MOVLB  6
02120:  MOVWF  xC7
02122:  MOVLW  8C
02124:  MOVWF  xC6
02126:  MOVLW  1E
02128:  MOVWF  xC5
0212A:  MOVLW  83
0212C:  MOVWF  xC4
0212E:  MOVLB  0
02130:  CALL   0E54
02134:  MOVFF  03,6A9
02138:  MOVFF  02,6A8
0213C:  MOVFF  01,6A7
02140:  MOVFF  00,6A6
.................... 
....................    r = qat[0]*y*y + qat[1];
02144:  MOVLB  6
02146:  CLRF   xC4
02148:  CLRF   xC3
0214A:  CLRF   xC2
0214C:  MOVLW  7F
0214E:  MOVWF  xC1
02150:  MOVFF  6A5,6C8
02154:  MOVFF  6A4,6C7
02158:  MOVFF  6A3,6C6
0215C:  MOVFF  6A2,6C5
02160:  MOVLB  0
02162:  CALL   0D5E
02166:  MOVFF  03,6B2
0216A:  MOVFF  02,6B1
0216E:  MOVFF  01,6B0
02172:  MOVFF  00,6AF
02176:  MOVFF  03,6C4
0217A:  MOVFF  02,6C3
0217E:  MOVFF  01,6C2
02182:  MOVFF  00,6C1
02186:  MOVFF  6A5,6C8
0218A:  MOVFF  6A4,6C7
0218E:  MOVFF  6A3,6C6
02192:  MOVFF  6A2,6C5
02196:  CALL   0D5E
0219A:  MOVFF  03,6B2
0219E:  MOVFF  02,6B1
021A2:  MOVFF  01,6B0
021A6:  MOVFF  00,6AF
021AA:  BCF    FD8.1
021AC:  MOVFF  03,6C3
021B0:  MOVFF  02,6C2
021B4:  MOVFF  01,6C1
021B8:  MOVFF  00,6C0
021BC:  MOVLW  1B
021BE:  MOVLB  6
021C0:  MOVWF  xC7
021C2:  MOVLW  E4
021C4:  MOVWF  xC6
021C6:  MOVLW  35
021C8:  MOVWF  xC5
021CA:  MOVLW  82
021CC:  MOVWF  xC4
021CE:  MOVLB  0
021D0:  CALL   0E54
021D4:  MOVFF  03,6AD
021D8:  MOVFF  02,6AC
021DC:  MOVFF  01,6AB
021E0:  MOVFF  00,6AA
....................    r = r*y*y + qat[2];
021E4:  MOVFF  6AD,6C4
021E8:  MOVFF  6AC,6C3
021EC:  MOVFF  6AB,6C2
021F0:  MOVFF  6AA,6C1
021F4:  MOVFF  6A5,6C8
021F8:  MOVFF  6A4,6C7
021FC:  MOVFF  6A3,6C6
02200:  MOVFF  6A2,6C5
02204:  CALL   0D5E
02208:  MOVFF  03,6B2
0220C:  MOVFF  02,6B1
02210:  MOVFF  01,6B0
02214:  MOVFF  00,6AF
02218:  MOVFF  03,6C4
0221C:  MOVFF  02,6C3
02220:  MOVFF  01,6C2
02224:  MOVFF  00,6C1
02228:  MOVFF  6A5,6C8
0222C:  MOVFF  6A4,6C7
02230:  MOVFF  6A3,6C6
02234:  MOVFF  6A2,6C5
02238:  CALL   0D5E
0223C:  MOVFF  03,6B2
02240:  MOVFF  02,6B1
02244:  MOVFF  01,6B0
02248:  MOVFF  00,6AF
0224C:  BCF    FD8.1
0224E:  MOVFF  03,6C3
02252:  MOVFF  02,6C2
02256:  MOVFF  01,6C1
0225A:  MOVFF  00,6C0
0225E:  MOVLW  A4
02260:  MOVLB  6
02262:  MOVWF  xC7
02264:  MOVLW  DB
02266:  MOVWF  xC6
02268:  MOVLW  67
0226A:  MOVWF  xC5
0226C:  MOVLW  83
0226E:  MOVWF  xC4
02270:  MOVLB  0
02272:  CALL   0E54
02276:  MOVFF  03,6AD
0227A:  MOVFF  02,6AC
0227E:  MOVFF  01,6AB
02282:  MOVFF  00,6AA
....................    r = r*y*y + qat[3];
02286:  MOVFF  6AD,6C4
0228A:  MOVFF  6AC,6C3
0228E:  MOVFF  6AB,6C2
02292:  MOVFF  6AA,6C1
02296:  MOVFF  6A5,6C8
0229A:  MOVFF  6A4,6C7
0229E:  MOVFF  6A3,6C6
022A2:  MOVFF  6A2,6C5
022A6:  CALL   0D5E
022AA:  MOVFF  03,6B2
022AE:  MOVFF  02,6B1
022B2:  MOVFF  01,6B0
022B6:  MOVFF  00,6AF
022BA:  MOVFF  03,6C4
022BE:  MOVFF  02,6C3
022C2:  MOVFF  01,6C2
022C6:  MOVFF  00,6C1
022CA:  MOVFF  6A5,6C8
022CE:  MOVFF  6A4,6C7
022D2:  MOVFF  6A3,6C6
022D6:  MOVFF  6A2,6C5
022DA:  CALL   0D5E
022DE:  MOVFF  03,6B2
022E2:  MOVFF  02,6B1
022E6:  MOVFF  01,6B0
022EA:  MOVFF  00,6AF
022EE:  BCF    FD8.1
022F0:  MOVFF  03,6C3
022F4:  MOVFF  02,6C2
022F8:  MOVFF  01,6C1
022FC:  MOVFF  00,6C0
02300:  MOVLW  33
02302:  MOVLB  6
02304:  MOVWF  xC7
02306:  MOVLW  8C
02308:  MOVWF  xC6
0230A:  MOVLW  1E
0230C:  MOVWF  xC5
0230E:  MOVLW  83
02310:  MOVWF  xC4
02312:  MOVLB  0
02314:  CALL   0E54
02318:  MOVFF  03,6AD
0231C:  MOVFF  02,6AC
02320:  MOVFF  01,6AB
02324:  MOVFF  00,6AA
.................... 
....................    res = y*res/r;
02328:  MOVFF  6A5,6C4
0232C:  MOVFF  6A4,6C3
02330:  MOVFF  6A3,6C2
02334:  MOVFF  6A2,6C1
02338:  MOVFF  6A9,6C8
0233C:  MOVFF  6A8,6C7
02340:  MOVFF  6A7,6C6
02344:  MOVFF  6A6,6C5
02348:  CALL   0D5E
0234C:  MOVFF  03,6B2
02350:  MOVFF  02,6B1
02354:  MOVFF  01,6B0
02358:  MOVFF  00,6AF
0235C:  MOVFF  03,6B8
02360:  MOVFF  02,6B7
02364:  MOVFF  01,6B6
02368:  MOVFF  00,6B5
0236C:  MOVFF  6AD,6BC
02370:  MOVFF  6AC,6BB
02374:  MOVFF  6AB,6BA
02378:  MOVFF  6AA,6B9
0237C:  RCALL  1D64
0237E:  MOVFF  03,6A9
02382:  MOVFF  02,6A8
02386:  MOVFF  01,6A7
0238A:  MOVFF  00,6A6
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
0238E:  MOVLB  6
02390:  BTFSS  xAE.1
02392:  BRA    23CE
....................       res = PI_DIV_BY_TWO - res;
02394:  BSF    FD8.1
02396:  MOVLW  DB
02398:  MOVWF  xC3
0239A:  MOVLW  0F
0239C:  MOVWF  xC2
0239E:  MOVLW  49
023A0:  MOVWF  xC1
023A2:  MOVLW  7F
023A4:  MOVWF  xC0
023A6:  MOVFF  6A9,6C7
023AA:  MOVFF  6A8,6C6
023AE:  MOVFF  6A7,6C5
023B2:  MOVFF  6A6,6C4
023B6:  MOVLB  0
023B8:  CALL   0E54
023BC:  MOVFF  03,6A9
023C0:  MOVFF  02,6A8
023C4:  MOVFF  01,6A7
023C8:  MOVFF  00,6A6
023CC:  MOVLB  6
....................    if (s)
023CE:  BTFSS  xAE.0
023D0:  BRA    23D8
....................       res = -res;
023D2:  MOVF   xA7,W
023D4:  XORLW  80
023D6:  MOVWF  xA7
.................... 
....................    return(res);
023D8:  MOVFF  6A6,00
023DC:  MOVFF  6A7,01
023E0:  MOVFF  6A8,02
023E4:  MOVFF  6A9,03
023E8:  MOVLB  0
023EA:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
023EC:  MOVLB  6
023EE:  BCF    x9C.0
....................    quad=0; //quadrant
023F0:  CLRF   x9D
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
023F2:  MOVFF  693,6BF
023F6:  MOVFF  692,6BE
023FA:  MOVFF  691,6BD
023FE:  MOVFF  690,6BC
02402:  CLRF   xC3
02404:  CLRF   xC2
02406:  CLRF   xC1
02408:  CLRF   xC0
0240A:  MOVLB  0
0240C:  RCALL  1CEA
0240E:  BC    2412
02410:  BNZ   243C
02412:  MOVFF  697,6BF
02416:  MOVFF  696,6BE
0241A:  MOVFF  695,6BD
0241E:  MOVFF  694,6BC
02422:  MOVLB  6
02424:  CLRF   xC3
02426:  CLRF   xC2
02428:  CLRF   xC1
0242A:  CLRF   xC0
0242C:  MOVLB  0
0242E:  RCALL  1CEA
02430:  BC    2434
02432:  BNZ   2438
02434:  MOVLW  03
02436:  BRA    243A
02438:  MOVLW  04
0243A:  BRA    2462
0243C:  MOVFF  697,6BF
02440:  MOVFF  696,6BE
02444:  MOVFF  695,6BD
02448:  MOVFF  694,6BC
0244C:  MOVLB  6
0244E:  CLRF   xC3
02450:  CLRF   xC2
02452:  CLRF   xC1
02454:  CLRF   xC0
02456:  MOVLB  0
02458:  RCALL  1CEA
0245A:  BNC   2460
0245C:  MOVLW  02
0245E:  BRA    2462
02460:  MOVLW  01
02462:  MOVLB  6
02464:  MOVWF  x9D
....................    if(y<0.0)
02466:  MOVFF  693,6BF
0246A:  MOVFF  692,6BE
0246E:  MOVFF  691,6BD
02472:  MOVFF  690,6BC
02476:  CLRF   xC3
02478:  CLRF   xC2
0247A:  CLRF   xC1
0247C:  CLRF   xC0
0247E:  MOVLB  0
02480:  RCALL  1CEA
02482:  BNC   2490
....................    {
....................       sign=1;
02484:  MOVLB  6
02486:  BSF    x9C.0
....................       y=-y;
02488:  MOVF   x91,W
0248A:  XORLW  80
0248C:  MOVWF  x91
0248E:  MOVLB  0
....................    }
....................    if(x<0.0)
02490:  MOVFF  697,6BF
02494:  MOVFF  696,6BE
02498:  MOVFF  695,6BD
0249C:  MOVFF  694,6BC
024A0:  MOVLB  6
024A2:  CLRF   xC3
024A4:  CLRF   xC2
024A6:  CLRF   xC1
024A8:  CLRF   xC0
024AA:  MOVLB  0
024AC:  RCALL  1CEA
024AE:  BNC   24BA
....................    {
....................       x=-x;
024B0:  MOVLB  6
024B2:  MOVF   x95,W
024B4:  XORLW  80
024B6:  MOVWF  x95
024B8:  MOVLB  0
....................    }
....................    if (x==0.0)
024BA:  MOVFF  697,6BF
024BE:  MOVFF  696,6BE
024C2:  MOVFF  695,6BD
024C6:  MOVFF  694,6BC
024CA:  MOVLB  6
024CC:  CLRF   xC3
024CE:  CLRF   xC2
024D0:  CLRF   xC1
024D2:  CLRF   xC0
024D4:  MOVLB  0
024D6:  RCALL  1CEA
024D8:  BNZ   252E
....................    {
....................       if(y==0.0)
024DA:  MOVFF  693,6BF
024DE:  MOVFF  692,6BE
024E2:  MOVFF  691,6BD
024E6:  MOVFF  690,6BC
024EA:  MOVLB  6
024EC:  CLRF   xC3
024EE:  CLRF   xC2
024F0:  CLRF   xC1
024F2:  CLRF   xC0
024F4:  MOVLB  0
024F6:  CALL   1CEA
024FA:  BNZ   24FE
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
024FC:  BRA    252C
....................       else
....................       {
....................          if(sign)
024FE:  MOVLB  6
02500:  BTFSS  x9C.0
02502:  BRA    2518
....................          {
....................          return (-(PI_DIV_BY_TWO));
02504:  MOVLW  7F
02506:  MOVWF  00
02508:  MOVLW  C9
0250A:  MOVWF  01
0250C:  MOVLW  0F
0250E:  MOVWF  02
02510:  MOVLW  DB
02512:  MOVWF  03
02514:  BRA    2666
....................          }
02516:  BRA    252A
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02518:  MOVLW  7F
0251A:  MOVWF  00
0251C:  MOVLW  49
0251E:  MOVWF  01
02520:  MOVLW  0F
02522:  MOVWF  02
02524:  MOVLW  DB
02526:  MOVWF  03
02528:  BRA    2666
0252A:  MOVLB  0
....................          }
....................       }
....................    }
0252C:  BRA    2664
....................    else
....................    {
....................       z=y/x;
0252E:  MOVFF  693,6B8
02532:  MOVFF  692,6B7
02536:  MOVFF  691,6B6
0253A:  MOVFF  690,6B5
0253E:  MOVFF  697,6BC
02542:  MOVFF  696,6BB
02546:  MOVFF  695,6BA
0254A:  MOVFF  694,6B9
0254E:  RCALL  1D64
02550:  MOVFF  03,69B
02554:  MOVFF  02,69A
02558:  MOVFF  01,699
0255C:  MOVFF  00,698
....................       switch(quad)
02560:  MOVLW  01
02562:  MOVLB  6
02564:  SUBWF  x9D,W
02566:  ADDLW  FC
02568:  BTFSC  FD8.0
0256A:  BRA    2666
0256C:  ADDLW  04
0256E:  MOVLB  0
02570:  GOTO   266C
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02574:  MOVFF  69B,6A1
02578:  MOVFF  69A,6A0
0257C:  MOVFF  699,69F
02580:  MOVFF  698,69E
02584:  RCALL  1EC2
02586:  MOVLB  6
02588:  BRA    2666
....................             break;
0258A:  BRA    2666
0258C:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
0258E:  MOVFF  69B,6A1
02592:  MOVFF  69A,6A0
02596:  MOVFF  699,69F
0259A:  MOVFF  698,69E
0259E:  RCALL  1EC2
025A0:  MOVFF  FEA,69F
025A4:  MOVFF  FE9,69E
025A8:  BSF    FD8.1
025AA:  MOVLW  DB
025AC:  MOVLB  6
025AE:  MOVWF  xC3
025B0:  MOVLW  0F
025B2:  MOVWF  xC2
025B4:  MOVLW  49
025B6:  MOVWF  xC1
025B8:  MOVLW  80
025BA:  MOVWF  xC0
025BC:  MOVFF  03,6C7
025C0:  MOVFF  02,6C6
025C4:  MOVFF  01,6C5
025C8:  MOVFF  00,6C4
025CC:  MOVLB  0
025CE:  CALL   0E54
025D2:  MOVFF  69F,FEA
025D6:  MOVFF  69E,FE9
025DA:  MOVLB  6
025DC:  BRA    2666
....................             break;
025DE:  BRA    2666
025E0:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
025E2:  MOVFF  69B,6A1
025E6:  MOVFF  69A,6A0
025EA:  MOVFF  699,69F
025EE:  MOVFF  698,69E
025F2:  RCALL  1EC2
025F4:  MOVFF  03,6A1
025F8:  MOVFF  02,6A0
025FC:  MOVFF  01,69F
02600:  MOVFF  00,69E
02604:  MOVFF  FEA,6A3
02608:  MOVFF  FE9,6A2
0260C:  BSF    FD8.1
0260E:  MOVFF  03,6C3
02612:  MOVFF  02,6C2
02616:  MOVFF  01,6C1
0261A:  MOVFF  00,6C0
0261E:  MOVLW  DB
02620:  MOVLB  6
02622:  MOVWF  xC7
02624:  MOVLW  0F
02626:  MOVWF  xC6
02628:  MOVLW  49
0262A:  MOVWF  xC5
0262C:  MOVLW  80
0262E:  MOVWF  xC4
02630:  MOVLB  0
02632:  CALL   0E54
02636:  MOVFF  6A3,FEA
0263A:  MOVFF  6A2,FE9
0263E:  MOVLB  6
02640:  BRA    2666
....................             break;
02642:  BRA    2666
02644:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02646:  MOVFF  69B,6A1
0264A:  MOVFF  69A,6A0
0264E:  MOVFF  699,69F
02652:  MOVFF  698,69E
02656:  RCALL  1EC2
02658:  MOVLW  80
0265A:  XORWF  01,F
0265C:  MOVLB  6
0265E:  BRA    2666
....................             break;
02660:  BRA    2666
02662:  MOVLB  0
02664:  MOVLB  6
....................          }
....................       }
....................    }
02666:  MOVLB  0
02668:  GOTO   3D72 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008C4:  MOVFF  6A6,FEA
008C8:  MOVLB  6
008CA:  MOVFF  6A5,FE9
008CE:  CLRF   xB3
008D0:  MOVFF  FEF,6B2
008D4:  CLRF   xB5
008D6:  MOVLW  04
008D8:  MOVWF  xB4
008DA:  MOVLB  0
008DC:  RCALL  0876
008DE:  MOVF   01,W
008E0:  MOVLB  6
008E2:  ADDWF  xA3,W
008E4:  MOVWF  FE9
008E6:  MOVF   xA4,W
008E8:  ADDWFC 02,W
008EA:  MOVWF  FEA
008EC:  MOVFF  6A7,FEF
008F0:  MOVFF  6A8,FEC
008F4:  MOVFF  6A9,FEC
008F8:  MOVFF  6AA,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
008FC:  MOVFF  6A6,6AC
00900:  MOVFF  6A6,FEA
00904:  MOVFF  6A5,FE9
00908:  MOVLW  01
0090A:  ADDWF  FEF,W
0090C:  MOVWF  xAE
0090E:  MOVWF  xAF
00910:  MOVLW  05
00912:  MOVWF  xB0
00914:  MOVLB  0
00916:  RCALL  0898
00918:  MOVLB  6
0091A:  MOVFF  6AC,FEA
0091E:  MOVFF  6A5,FE9
00922:  MOVFF  00,FEF
00926:  MOVLB  0
00928:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
010CC:  MOVLB  F
010CE:  BTFSC  x5B.0
010D0:  BRA    161C
....................       switch (state)
010D2:  MOVLB  1
010D4:  MOVF   xCC,W
010D6:  ADDLW  F9
010D8:  BTFSC  FD8.0
010DA:  BRA    161A
010DC:  ADDLW  07
010DE:  MOVLB  0
010E0:  GOTO   1622
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
010E4:  MOVLB  F
010E6:  BTFSC  x5B.0
010E8:  BRA    10E6
010EA:  MOVFF  F5F,02
010EE:  MOVFF  F5E,01
010F2:  MOVFF  02,672
010F6:  MOVFF  01,671
010FA:  MOVFF  02,6C1
010FE:  MOVFF  01,6C0
01102:  MOVLB  0
01104:  RCALL  0D28
01106:  MOVFF  03,6C4
0110A:  MOVFF  02,6C3
0110E:  MOVFF  01,6C2
01112:  MOVFF  00,6C1
01116:  MOVFF  B9,6C8
0111A:  MOVFF  B8,6C7
0111E:  MOVFF  B7,6C6
01122:  MOVFF  B6,6C5
01126:  RCALL  0D5E
01128:  MOVFF  03,674
0112C:  MOVFF  02,673
01130:  MOVFF  01,672
01134:  MOVFF  00,671
01138:  BCF    FD8.1
0113A:  MOVFF  03,6C3
0113E:  MOVFF  02,6C2
01142:  MOVFF  01,6C1
01146:  MOVFF  00,6C0
0114A:  MOVFF  B5,6C7
0114E:  MOVFF  B4,6C6
01152:  MOVFF  B3,6C5
01156:  MOVFF  B2,6C4
0115A:  RCALL  0E54
0115C:  MOVFF  03,EE
01160:  MOVFF  02,ED
01164:  MOVFF  01,EC
01168:  MOVFF  00,EB
....................             set_adc_channel(vMon200);
0116C:  MOVLB  F
0116E:  MOVF   x5A,W
01170:  ANDLW  3F
01172:  MOVWF  01
01174:  MOVLW  10
01176:  MOVWF  x5A
01178:  BTFSS  x5B.7
0117A:  BRA    118A
0117C:  MOVF   01,W
0117E:  SUBLW  10
01180:  BZ    118A
01182:  BSF    x5B.0
01184:  NOP   
01186:  BTFSC  x5B.0
01188:  BRA    1186
....................             delay_ms(10);
0118A:  MOVLW  0A
0118C:  MOVLB  6
0118E:  MOVWF  x77
01190:  MOVLB  0
01192:  CALL   043A
....................             read_adc(ADC_START_ONLY);
01196:  MOVLB  F
01198:  BSF    x5B.0
0119A:  NOP   
....................             state = 1;
0119C:  MOVLW  01
0119E:  MOVLB  1
011A0:  MOVWF  xCC
....................          break;
011A2:  BRA    161A
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011A4:  MOVLB  F
011A6:  BTFSC  x5B.0
011A8:  BRA    11A6
011AA:  MOVFF  F5F,02
011AE:  MOVFF  F5E,01
011B2:  MOVFF  02,672
011B6:  MOVFF  01,671
011BA:  MOVFF  02,6C1
011BE:  MOVFF  01,6C0
011C2:  MOVLB  0
011C4:  RCALL  0D28
011C6:  MOVFF  03,6C4
011CA:  MOVFF  02,6C3
011CE:  MOVFF  01,6C2
011D2:  MOVFF  00,6C1
011D6:  MOVFF  C1,6C8
011DA:  MOVFF  C0,6C7
011DE:  MOVFF  BF,6C6
011E2:  MOVFF  BE,6C5
011E6:  RCALL  0D5E
011E8:  MOVFF  03,674
011EC:  MOVFF  02,673
011F0:  MOVFF  01,672
011F4:  MOVFF  00,671
011F8:  BCF    FD8.1
011FA:  MOVFF  03,6C3
011FE:  MOVFF  02,6C2
01202:  MOVFF  01,6C1
01206:  MOVFF  00,6C0
0120A:  MOVFF  BD,6C7
0120E:  MOVFF  BC,6C6
01212:  MOVFF  BB,6C5
01216:  MOVFF  BA,6C4
0121A:  RCALL  0E54
0121C:  MOVFF  03,F2
01220:  MOVFF  02,F1
01224:  MOVFF  01,F0
01228:  MOVFF  00,EF
....................             set_adc_channel(vMon5V6);
0122C:  MOVLB  F
0122E:  MOVF   x5A,W
01230:  ANDLW  3F
01232:  MOVWF  01
01234:  MOVLW  18
01236:  MOVWF  x5A
01238:  BTFSS  x5B.7
0123A:  BRA    124A
0123C:  MOVF   01,W
0123E:  SUBLW  18
01240:  BZ    124A
01242:  BSF    x5B.0
01244:  NOP   
01246:  BTFSC  x5B.0
01248:  BRA    1246
....................             delay_ms(10);
0124A:  MOVLW  0A
0124C:  MOVLB  6
0124E:  MOVWF  x77
01250:  MOVLB  0
01252:  CALL   043A
....................             read_adc(ADC_START_ONLY);
01256:  MOVLB  F
01258:  BSF    x5B.0
0125A:  NOP   
....................             state = 2;
0125C:  MOVLW  02
0125E:  MOVLB  1
01260:  MOVWF  xCC
....................          break;
01262:  BRA    161A
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01264:  MOVLB  F
01266:  BTFSC  x5B.0
01268:  BRA    1266
0126A:  MOVFF  F5F,02
0126E:  MOVFF  F5E,01
01272:  MOVFF  02,672
01276:  MOVFF  01,671
0127A:  MOVFF  02,6C1
0127E:  MOVFF  01,6C0
01282:  MOVLB  0
01284:  RCALL  0D28
01286:  MOVFF  03,6C4
0128A:  MOVFF  02,6C3
0128E:  MOVFF  01,6C2
01292:  MOVFF  00,6C1
01296:  MOVFF  C9,6C8
0129A:  MOVFF  C8,6C7
0129E:  MOVFF  C7,6C6
012A2:  MOVFF  C6,6C5
012A6:  RCALL  0D5E
012A8:  MOVFF  03,674
012AC:  MOVFF  02,673
012B0:  MOVFF  01,672
012B4:  MOVFF  00,671
012B8:  BCF    FD8.1
012BA:  MOVFF  03,6C3
012BE:  MOVFF  02,6C2
012C2:  MOVFF  01,6C1
012C6:  MOVFF  00,6C0
012CA:  MOVFF  C5,6C7
012CE:  MOVFF  C4,6C6
012D2:  MOVFF  C3,6C5
012D6:  MOVFF  C2,6C4
012DA:  RCALL  0E54
012DC:  MOVFF  03,F6
012E0:  MOVFF  02,F5
012E4:  MOVFF  01,F4
012E8:  MOVFF  00,F3
....................             set_adc_channel(vMon5VA);
012EC:  MOVLB  F
012EE:  MOVF   x5A,W
012F0:  ANDLW  3F
012F2:  MOVWF  01
012F4:  MOVLW  19
012F6:  MOVWF  x5A
012F8:  BTFSS  x5B.7
012FA:  BRA    130A
012FC:  MOVF   01,W
012FE:  SUBLW  19
01300:  BZ    130A
01302:  BSF    x5B.0
01304:  NOP   
01306:  BTFSC  x5B.0
01308:  BRA    1306
....................             delay_ms(10);
0130A:  MOVLW  0A
0130C:  MOVLB  6
0130E:  MOVWF  x77
01310:  MOVLB  0
01312:  CALL   043A
....................             read_adc(ADC_START_ONLY);
01316:  MOVLB  F
01318:  BSF    x5B.0
0131A:  NOP   
....................             state = 3;
0131C:  MOVLW  03
0131E:  MOVLB  1
01320:  MOVWF  xCC
....................          break;
01322:  BRA    161A
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01324:  MOVLB  F
01326:  BTFSC  x5B.0
01328:  BRA    1326
0132A:  MOVFF  F5F,02
0132E:  MOVFF  F5E,01
01332:  MOVFF  02,672
01336:  MOVFF  01,671
0133A:  MOVFF  02,6C1
0133E:  MOVFF  01,6C0
01342:  MOVLB  0
01344:  RCALL  0D28
01346:  MOVFF  03,6C4
0134A:  MOVFF  02,6C3
0134E:  MOVFF  01,6C2
01352:  MOVFF  00,6C1
01356:  MOVFF  D1,6C8
0135A:  MOVFF  D0,6C7
0135E:  MOVFF  CF,6C6
01362:  MOVFF  CE,6C5
01366:  RCALL  0D5E
01368:  MOVFF  03,674
0136C:  MOVFF  02,673
01370:  MOVFF  01,672
01374:  MOVFF  00,671
01378:  BCF    FD8.1
0137A:  MOVFF  03,6C3
0137E:  MOVFF  02,6C2
01382:  MOVFF  01,6C1
01386:  MOVFF  00,6C0
0138A:  MOVFF  CD,6C7
0138E:  MOVFF  CC,6C6
01392:  MOVFF  CB,6C5
01396:  MOVFF  CA,6C4
0139A:  RCALL  0E54
0139C:  MOVFF  03,FA
013A0:  MOVFF  02,F9
013A4:  MOVFF  01,F8
013A8:  MOVFF  00,F7
....................             set_adc_channel(vMon3V6X);
013AC:  MOVLB  F
013AE:  MOVF   x5A,W
013B0:  ANDLW  3F
013B2:  MOVWF  01
013B4:  MOVLW  11
013B6:  MOVWF  x5A
013B8:  BTFSS  x5B.7
013BA:  BRA    13CA
013BC:  MOVF   01,W
013BE:  SUBLW  11
013C0:  BZ    13CA
013C2:  BSF    x5B.0
013C4:  NOP   
013C6:  BTFSC  x5B.0
013C8:  BRA    13C6
....................             delay_ms(10);
013CA:  MOVLW  0A
013CC:  MOVLB  6
013CE:  MOVWF  x77
013D0:  MOVLB  0
013D2:  CALL   043A
....................             read_adc(ADC_START_ONLY);
013D6:  MOVLB  F
013D8:  BSF    x5B.0
013DA:  NOP   
....................             state = 4;
013DC:  MOVLW  04
013DE:  MOVLB  1
013E0:  MOVWF  xCC
....................          break;
013E2:  BRA    161A
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
013E4:  MOVLB  F
013E6:  BTFSC  x5B.0
013E8:  BRA    13E6
013EA:  MOVFF  F5F,02
013EE:  MOVFF  F5E,01
013F2:  MOVFF  02,672
013F6:  MOVFF  01,671
013FA:  MOVFF  02,6C1
013FE:  MOVFF  01,6C0
01402:  MOVLB  0
01404:  RCALL  0D28
01406:  MOVFF  03,6C4
0140A:  MOVFF  02,6C3
0140E:  MOVFF  01,6C2
01412:  MOVFF  00,6C1
01416:  MOVFF  D9,6C8
0141A:  MOVFF  D8,6C7
0141E:  MOVFF  D7,6C6
01422:  MOVFF  D6,6C5
01426:  RCALL  0D5E
01428:  MOVFF  03,674
0142C:  MOVFF  02,673
01430:  MOVFF  01,672
01434:  MOVFF  00,671
01438:  BCF    FD8.1
0143A:  MOVFF  03,6C3
0143E:  MOVFF  02,6C2
01442:  MOVFF  01,6C1
01446:  MOVFF  00,6C0
0144A:  MOVFF  D5,6C7
0144E:  MOVFF  D4,6C6
01452:  MOVFF  D3,6C5
01456:  MOVFF  D2,6C4
0145A:  RCALL  0E54
0145C:  MOVFF  03,FE
01460:  MOVFF  02,FD
01464:  MOVFF  01,FC
01468:  MOVFF  00,FB
....................             set_adc_channel(vMon3V3A);
0146C:  MOVLB  F
0146E:  MOVF   x5A,W
01470:  ANDLW  3F
01472:  MOVWF  01
01474:  MOVLW  1B
01476:  MOVWF  x5A
01478:  BTFSS  x5B.7
0147A:  BRA    148A
0147C:  MOVF   01,W
0147E:  SUBLW  1B
01480:  BZ    148A
01482:  BSF    x5B.0
01484:  NOP   
01486:  BTFSC  x5B.0
01488:  BRA    1486
....................             delay_ms(10);
0148A:  MOVLW  0A
0148C:  MOVLB  6
0148E:  MOVWF  x77
01490:  MOVLB  0
01492:  CALL   043A
....................             read_adc(ADC_START_ONLY);
01496:  MOVLB  F
01498:  BSF    x5B.0
0149A:  NOP   
....................             state = 5;
0149C:  MOVLW  05
0149E:  MOVLB  1
014A0:  MOVWF  xCC
....................          break;
014A2:  BRA    161A
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014A4:  MOVLB  F
014A6:  BTFSC  x5B.0
014A8:  BRA    14A6
014AA:  MOVFF  F5F,02
014AE:  MOVFF  F5E,01
014B2:  MOVFF  02,672
014B6:  MOVFF  01,671
014BA:  MOVFF  02,6C1
014BE:  MOVFF  01,6C0
014C2:  MOVLB  0
014C4:  RCALL  0D28
014C6:  MOVFF  03,6C4
014CA:  MOVFF  02,6C3
014CE:  MOVFF  01,6C2
014D2:  MOVFF  00,6C1
014D6:  MOVFF  E1,6C8
014DA:  MOVFF  E0,6C7
014DE:  MOVFF  DF,6C6
014E2:  MOVFF  DE,6C5
014E6:  RCALL  0D5E
014E8:  MOVFF  03,674
014EC:  MOVFF  02,673
014F0:  MOVFF  01,672
014F4:  MOVFF  00,671
014F8:  BCF    FD8.1
014FA:  MOVFF  03,6C3
014FE:  MOVFF  02,6C2
01502:  MOVFF  01,6C1
01506:  MOVFF  00,6C0
0150A:  MOVFF  DD,6C7
0150E:  MOVFF  DC,6C6
01512:  MOVFF  DB,6C5
01516:  MOVFF  DA,6C4
0151A:  RCALL  0E54
0151C:  MOVFF  03,102
01520:  MOVFF  02,101
01524:  MOVFF  01,100
01528:  MOVFF  00,FF
....................             set_adc_channel(vMon3V3D);
0152C:  MOVLB  F
0152E:  MOVF   x5A,W
01530:  ANDLW  3F
01532:  MOVWF  01
01534:  MOVLW  1A
01536:  MOVWF  x5A
01538:  BTFSS  x5B.7
0153A:  BRA    154A
0153C:  MOVF   01,W
0153E:  SUBLW  1A
01540:  BZ    154A
01542:  BSF    x5B.0
01544:  NOP   
01546:  BTFSC  x5B.0
01548:  BRA    1546
....................             delay_ms(10);
0154A:  MOVLW  0A
0154C:  MOVLB  6
0154E:  MOVWF  x77
01550:  MOVLB  0
01552:  CALL   043A
....................             read_adc(ADC_START_ONLY);
01556:  MOVLB  F
01558:  BSF    x5B.0
0155A:  NOP   
....................             state = 6;
0155C:  MOVLW  06
0155E:  MOVLB  1
01560:  MOVWF  xCC
....................          break;
01562:  BRA    161A
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01564:  MOVLB  F
01566:  BTFSC  x5B.0
01568:  BRA    1566
0156A:  MOVFF  F5F,02
0156E:  MOVFF  F5E,01
01572:  MOVFF  02,672
01576:  MOVFF  01,671
0157A:  MOVFF  02,6C1
0157E:  MOVFF  01,6C0
01582:  MOVLB  0
01584:  CALL   0D28
01588:  MOVFF  03,6C4
0158C:  MOVFF  02,6C3
01590:  MOVFF  01,6C2
01594:  MOVFF  00,6C1
01598:  MOVFF  E9,6C8
0159C:  MOVFF  E8,6C7
015A0:  MOVFF  E7,6C6
015A4:  MOVFF  E6,6C5
015A8:  CALL   0D5E
015AC:  MOVFF  03,674
015B0:  MOVFF  02,673
015B4:  MOVFF  01,672
015B8:  MOVFF  00,671
015BC:  BCF    FD8.1
015BE:  MOVFF  03,6C3
015C2:  MOVFF  02,6C2
015C6:  MOVFF  01,6C1
015CA:  MOVFF  00,6C0
015CE:  MOVFF  E5,6C7
015D2:  MOVFF  E4,6C6
015D6:  MOVFF  E3,6C5
015DA:  MOVFF  E2,6C4
015DE:  RCALL  0E54
015E0:  MOVFF  03,106
015E4:  MOVFF  02,105
015E8:  MOVFF  01,104
015EC:  MOVFF  00,103
....................             set_adc_channel(vMonN15);
015F0:  MOVLB  F
015F2:  MOVF   x5A,W
015F4:  ANDLW  3F
015F6:  MOVWF  01
015F8:  MOVLW  06
015FA:  MOVWF  x5A
015FC:  BTFSS  x5B.7
015FE:  BRA    160E
01600:  MOVF   01,W
01602:  SUBLW  06
01604:  BZ    160E
01606:  BSF    x5B.0
01608:  NOP   
0160A:  BTFSC  x5B.0
0160C:  BRA    160A
....................             read_adc(ADC_START_ONLY);
0160E:  BSF    x5B.0
01610:  NOP   
....................             state = 0;
01612:  MOVLB  1
01614:  CLRF   xCC
....................          break;   
01616:  BRA    161A
01618:  MOVLB  1
0161A:  MOVLB  F
....................       }
....................    }
0161C:  MOVLB  0
0161E:  GOTO   A632 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
036CA:  MOVLB  6
036CC:  MOVF   x79,W
036CE:  MULLW  21
036D0:  MOVF   FF3,W
036D2:  CLRF   x83
036D4:  MOVWF  x82
036D6:  MOVLW  10
036D8:  ADDWF  x82,W
036DA:  MOVWF  01
036DC:  MOVLW  00
036DE:  ADDWFC x83,W
036E0:  MOVWF  03
036E2:  MOVF   01,W
036E4:  ADDLW  07
036E6:  MOVWF  01
036E8:  MOVLW  01
036EA:  ADDWFC 03,F
036EC:  MOVFF  01,682
036F0:  MOVFF  03,683
036F4:  MOVF   x79,W
036F6:  MULLW  21
036F8:  MOVF   FF3,W
036FA:  CLRF   x85
036FC:  MOVWF  x84
036FE:  MOVLW  08
03700:  ADDWF  x84,W
03702:  MOVWF  01
03704:  MOVLW  00
03706:  ADDWFC x85,W
03708:  MOVWF  03
0370A:  MOVF   01,W
0370C:  ADDLW  07
0370E:  MOVWF  FE9
03710:  MOVLW  01
03712:  ADDWFC 03,W
03714:  MOVWF  FEA
03716:  MOVFF  FEF,00
0371A:  MOVFF  FEC,01
0371E:  MOVFF  FEC,02
03722:  MOVFF  FEC,03
03726:  MOVFF  683,FEA
0372A:  MOVFF  682,FE9
0372E:  MOVFF  00,FEF
03732:  MOVFF  01,FEC
03736:  MOVFF  02,FEC
0373A:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
0373E:  MOVF   x79,W
03740:  MULLW  21
03742:  MOVF   FF3,W
03744:  CLRF   x83
03746:  MOVWF  x82
03748:  MOVLW  14
0374A:  ADDWF  x82,W
0374C:  MOVWF  01
0374E:  MOVLW  00
03750:  ADDWFC x83,W
03752:  MOVWF  03
03754:  MOVF   01,W
03756:  ADDLW  07
03758:  MOVWF  01
0375A:  MOVLW  01
0375C:  ADDWFC 03,F
0375E:  MOVFF  01,682
03762:  MOVFF  03,683
03766:  MOVF   x79,W
03768:  MULLW  21
0376A:  MOVF   FF3,W
0376C:  CLRF   x85
0376E:  MOVWF  x84
03770:  MOVLW  0C
03772:  ADDWF  x84,W
03774:  MOVWF  01
03776:  MOVLW  00
03778:  ADDWFC x85,W
0377A:  MOVWF  03
0377C:  MOVF   01,W
0377E:  ADDLW  07
03780:  MOVWF  FE9
03782:  MOVLW  01
03784:  ADDWFC 03,W
03786:  MOVWF  FEA
03788:  MOVFF  FEF,00
0378C:  MOVFF  FEC,01
03790:  MOVFF  FEC,02
03794:  MOVFF  FEC,03
03798:  MOVFF  683,FEA
0379C:  MOVFF  682,FE9
037A0:  MOVFF  00,FEF
037A4:  MOVFF  01,FEC
037A8:  MOVFF  02,FEC
037AC:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037B0:  MOVF   x79,W
037B2:  MULLW  21
037B4:  MOVF   FF3,W
037B6:  CLRF   x83
037B8:  MOVWF  x82
037BA:  MOVLW  07
037BC:  ADDWF  x82,W
037BE:  MOVWF  01
037C0:  MOVLW  01
037C2:  ADDWFC x83,W
037C4:  MOVWF  03
037C6:  MOVFF  01,684
037CA:  MOVWF  x85
037CC:  MOVF   x79,W
037CE:  MULLW  09
037D0:  MOVF   FF3,W
037D2:  CLRF   x87
037D4:  MOVWF  x86
037D6:  MOVLW  01
037D8:  ADDWF  x86,W
037DA:  MOVWF  01
037DC:  MOVLW  00
037DE:  ADDWFC x87,W
037E0:  MOVWF  03
037E2:  MOVF   01,W
037E4:  ADDLW  BA
037E6:  MOVWF  FE9
037E8:  MOVLW  01
037EA:  ADDWFC 03,W
037EC:  MOVWF  FEA
037EE:  MOVFF  FEF,686
037F2:  MOVFF  FEC,01
037F6:  MOVFF  FEC,02
037FA:  MOVFF  FEC,03
037FE:  MOVFF  03,689
03802:  MOVFF  02,688
03806:  MOVFF  01,687
0380A:  MOVLB  0
0380C:  CALL   1C90
03810:  MOVFF  685,FEA
03814:  MOVFF  684,FE9
03818:  MOVFF  00,FEF
0381C:  MOVFF  01,FEC
03820:  MOVFF  02,FEC
03824:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03828:  MOVLB  6
0382A:  MOVF   x79,W
0382C:  MULLW  21
0382E:  MOVF   FF3,W
03830:  CLRF   x83
03832:  MOVWF  x82
03834:  MOVLW  04
03836:  ADDWF  x82,W
03838:  MOVWF  01
0383A:  MOVLW  00
0383C:  ADDWFC x83,W
0383E:  MOVWF  03
03840:  MOVF   01,W
03842:  ADDLW  07
03844:  MOVWF  01
03846:  MOVLW  01
03848:  ADDWFC 03,F
0384A:  MOVFF  01,682
0384E:  MOVFF  03,683
03852:  MOVF   x79,W
03854:  MULLW  09
03856:  MOVF   FF3,W
03858:  CLRF   x85
0385A:  MOVWF  x84
0385C:  MOVLW  05
0385E:  ADDWF  x84,W
03860:  MOVWF  01
03862:  MOVLW  00
03864:  ADDWFC x85,W
03866:  MOVWF  03
03868:  MOVF   01,W
0386A:  ADDLW  BA
0386C:  MOVWF  FE9
0386E:  MOVLW  01
03870:  ADDWFC 03,W
03872:  MOVWF  FEA
03874:  MOVFF  FEF,686
03878:  MOVFF  FEC,01
0387C:  MOVFF  FEC,02
03880:  MOVFF  FEC,03
03884:  MOVFF  03,689
03888:  MOVFF  02,688
0388C:  MOVFF  01,687
03890:  MOVLB  0
03892:  CALL   1C90
03896:  MOVFF  683,FEA
0389A:  MOVFF  682,FE9
0389E:  MOVFF  00,FEF
038A2:  MOVFF  01,FEC
038A6:  MOVFF  02,FEC
038AA:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038AE:  MOVLB  6
038B0:  MOVF   x79,W
038B2:  MULLW  21
038B4:  MOVF   FF3,W
038B6:  CLRF   x83
038B8:  MOVWF  x82
038BA:  MOVLW  08
038BC:  ADDWF  x82,W
038BE:  MOVWF  01
038C0:  MOVLW  00
038C2:  ADDWFC x83,W
038C4:  MOVWF  03
038C6:  MOVF   01,W
038C8:  ADDLW  07
038CA:  MOVWF  01
038CC:  MOVLW  01
038CE:  ADDWFC 03,F
038D0:  MOVFF  01,682
038D4:  MOVFF  03,683
038D8:  MOVF   x79,W
038DA:  MULLW  21
038DC:  MOVF   FF3,W
038DE:  CLRF   x85
038E0:  MOVWF  x84
038E2:  MOVLW  07
038E4:  ADDWF  x84,W
038E6:  MOVWF  FE9
038E8:  MOVLW  01
038EA:  ADDWFC x85,W
038EC:  MOVWF  FEA
038EE:  MOVFF  FEF,6C1
038F2:  MOVFF  FEC,6C2
038F6:  MOVFF  FEC,6C3
038FA:  MOVFF  FEC,6C4
038FE:  MOVF   x79,W
03900:  MULLW  10
03902:  MOVF   FF3,W
03904:  CLRF   x8B
03906:  MOVWF  x8A
03908:  MOVLW  08
0390A:  ADDWF  x8A,W
0390C:  MOVWF  01
0390E:  MOVLW  00
03910:  ADDWFC x8B,W
03912:  MOVWF  03
03914:  MOVF   01,W
03916:  ADDLW  62
03918:  MOVWF  FE9
0391A:  MOVLW  00
0391C:  ADDWFC 03,W
0391E:  MOVWF  FEA
03920:  MOVFF  FEF,6C5
03924:  MOVFF  FEC,01
03928:  MOVFF  FEC,02
0392C:  MOVFF  FEC,03
03930:  MOVFF  03,6C8
03934:  MOVFF  02,6C7
03938:  MOVFF  01,6C6
0393C:  MOVLB  0
0393E:  CALL   0D5E
03942:  MOVFF  03,6C3
03946:  MOVFF  02,6C2
0394A:  MOVFF  01,6C1
0394E:  MOVFF  00,6C0
03952:  MOVLB  6
03954:  MOVF   x79,W
03956:  MULLW  10
03958:  MOVF   FF3,W
0395A:  CLRF   x8B
0395C:  MOVWF  x8A
0395E:  MOVLW  62
03960:  ADDWF  x8A,W
03962:  MOVWF  FE9
03964:  MOVLW  00
03966:  ADDWFC x8B,W
03968:  MOVWF  FEA
0396A:  MOVFF  FEF,6C4
0396E:  MOVFF  FEC,01
03972:  MOVFF  FEC,02
03976:  MOVFF  FEC,03
0397A:  BCF    FD8.1
0397C:  MOVFF  03,6C7
03980:  MOVFF  02,6C6
03984:  MOVFF  01,6C5
03988:  MOVLB  0
0398A:  CALL   0E54
0398E:  MOVFF  683,FEA
03992:  MOVFF  682,FE9
03996:  MOVFF  00,FEF
0399A:  MOVFF  01,FEC
0399E:  MOVFF  02,FEC
039A2:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039A6:  MOVLB  6
039A8:  MOVF   x79,W
039AA:  MULLW  21
039AC:  MOVF   FF3,W
039AE:  CLRF   x83
039B0:  MOVWF  x82
039B2:  MOVLW  0C
039B4:  ADDWF  x82,W
039B6:  MOVWF  01
039B8:  MOVLW  00
039BA:  ADDWFC x83,W
039BC:  MOVWF  03
039BE:  MOVF   01,W
039C0:  ADDLW  07
039C2:  MOVWF  01
039C4:  MOVLW  01
039C6:  ADDWFC 03,F
039C8:  MOVFF  01,682
039CC:  MOVFF  03,683
039D0:  MOVF   x79,W
039D2:  MULLW  21
039D4:  MOVF   FF3,W
039D6:  CLRF   x85
039D8:  MOVWF  x84
039DA:  MOVLW  04
039DC:  ADDWF  x84,W
039DE:  MOVWF  01
039E0:  MOVLW  00
039E2:  ADDWFC x85,W
039E4:  MOVWF  03
039E6:  MOVF   01,W
039E8:  ADDLW  07
039EA:  MOVWF  FE9
039EC:  MOVLW  01
039EE:  ADDWFC 03,W
039F0:  MOVWF  FEA
039F2:  MOVFF  FEF,6C1
039F6:  MOVFF  FEC,6C2
039FA:  MOVFF  FEC,6C3
039FE:  MOVFF  FEC,6C4
03A02:  MOVF   x79,W
03A04:  MULLW  10
03A06:  MOVF   FF3,W
03A08:  CLRF   x89
03A0A:  MOVWF  x88
03A0C:  MOVLW  0C
03A0E:  ADDWF  x88,W
03A10:  MOVWF  01
03A12:  MOVLW  00
03A14:  ADDWFC x89,W
03A16:  MOVWF  03
03A18:  MOVF   01,W
03A1A:  ADDLW  62
03A1C:  MOVWF  FE9
03A1E:  MOVLW  00
03A20:  ADDWFC 03,W
03A22:  MOVWF  FEA
03A24:  MOVFF  FEF,6C5
03A28:  MOVFF  FEC,01
03A2C:  MOVFF  FEC,02
03A30:  MOVFF  FEC,03
03A34:  MOVFF  03,6C8
03A38:  MOVFF  02,6C7
03A3C:  MOVFF  01,6C6
03A40:  MOVLB  0
03A42:  CALL   0D5E
03A46:  MOVFF  03,6C3
03A4A:  MOVFF  02,6C2
03A4E:  MOVFF  01,6C1
03A52:  MOVFF  00,6C0
03A56:  MOVLB  6
03A58:  MOVF   x79,W
03A5A:  MULLW  10
03A5C:  MOVF   FF3,W
03A5E:  CLRF   x89
03A60:  MOVWF  x88
03A62:  MOVLW  04
03A64:  ADDWF  x88,W
03A66:  MOVWF  01
03A68:  MOVLW  00
03A6A:  ADDWFC x89,W
03A6C:  MOVWF  03
03A6E:  MOVF   01,W
03A70:  ADDLW  62
03A72:  MOVWF  FE9
03A74:  MOVLW  00
03A76:  ADDWFC 03,W
03A78:  MOVWF  FEA
03A7A:  MOVFF  FEF,6C4
03A7E:  MOVFF  FEC,01
03A82:  MOVFF  FEC,02
03A86:  MOVFF  FEC,03
03A8A:  BCF    FD8.1
03A8C:  MOVFF  03,6C7
03A90:  MOVFF  02,6C6
03A94:  MOVFF  01,6C5
03A98:  MOVLB  0
03A9A:  CALL   0E54
03A9E:  MOVFF  683,FEA
03AA2:  MOVFF  682,FE9
03AA6:  MOVFF  00,FEF
03AAA:  MOVFF  01,FEC
03AAE:  MOVFF  02,FEC
03AB2:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AB6:  MOVLB  6
03AB8:  CLRF   x7D
03ABA:  CLRF   x7C
03ABC:  CLRF   x7B
03ABE:  CLRF   x7A
03AC0:  CLRF   x81
03AC2:  CLRF   x80
03AC4:  CLRF   x7F
03AC6:  MOVLW  7F
03AC8:  MOVWF  x7E
....................    
....................    if (adcVals[ch].cosCounts < 0){
03ACA:  MOVF   x79,W
03ACC:  MULLW  21
03ACE:  MOVF   FF3,W
03AD0:  CLRF   x83
03AD2:  MOVWF  x82
03AD4:  MOVLW  0C
03AD6:  ADDWF  x82,W
03AD8:  MOVWF  01
03ADA:  MOVLW  00
03ADC:  ADDWFC x83,W
03ADE:  MOVWF  03
03AE0:  MOVF   01,W
03AE2:  ADDLW  07
03AE4:  MOVWF  FE9
03AE6:  MOVLW  01
03AE8:  ADDWFC 03,W
03AEA:  MOVWF  FEA
03AEC:  MOVFF  FEF,6BC
03AF0:  MOVFF  FEC,6BD
03AF4:  MOVFF  FEC,6BE
03AF8:  MOVFF  FEC,6BF
03AFC:  CLRF   xC3
03AFE:  CLRF   xC2
03B00:  CLRF   xC1
03B02:  CLRF   xC0
03B04:  MOVLB  0
03B06:  CALL   1CEA
03B0A:  BTFSS  FD8.0
03B0C:  BRA    3C76
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B0E:  MOVLB  6
03B10:  MOVF   x79,W
03B12:  MULLW  21
03B14:  MOVF   FF3,W
03B16:  CLRF   x83
03B18:  MOVWF  x82
03B1A:  MOVLW  08
03B1C:  ADDWF  x82,W
03B1E:  MOVWF  01
03B20:  MOVLW  00
03B22:  ADDWFC x83,W
03B24:  MOVWF  03
03B26:  MOVF   01,W
03B28:  ADDLW  07
03B2A:  MOVWF  FE9
03B2C:  MOVLW  01
03B2E:  ADDWFC 03,W
03B30:  MOVWF  FEA
03B32:  MOVFF  FEF,6C0
03B36:  MOVFF  FEC,683
03B3A:  MOVFF  FEC,6C2
03B3E:  MOVFF  FEC,6C3
03B42:  CLRF   xBF
03B44:  CLRF   xBE
03B46:  CLRF   xBD
03B48:  CLRF   xBC
03B4A:  MOVFF  683,6C1
03B4E:  MOVLB  0
03B50:  CALL   1CEA
03B54:  BNC   3BC2
03B56:  MOVLB  6
03B58:  MOVF   x79,W
03B5A:  MULLW  21
03B5C:  MOVF   FF3,W
03B5E:  CLRF   x83
03B60:  MOVWF  x82
03B62:  MOVLW  10
03B64:  ADDWF  x82,W
03B66:  MOVWF  01
03B68:  MOVLW  00
03B6A:  ADDWFC x83,W
03B6C:  MOVWF  03
03B6E:  MOVF   01,W
03B70:  ADDLW  07
03B72:  MOVWF  FE9
03B74:  MOVLW  01
03B76:  ADDWFC 03,W
03B78:  MOVWF  FEA
03B7A:  MOVFF  FEF,6BC
03B7E:  MOVFF  FEC,6BD
03B82:  MOVFF  FEC,6BE
03B86:  MOVFF  FEC,6BF
03B8A:  CLRF   xC3
03B8C:  CLRF   xC2
03B8E:  CLRF   xC1
03B90:  CLRF   xC0
03B92:  MOVLB  0
03B94:  CALL   1CEA
03B98:  BNC   3BC2
....................          adcVals[ch].npoles--;
03B9A:  MOVLB  6
03B9C:  MOVF   x79,W
03B9E:  MULLW  21
03BA0:  MOVF   FF3,W
03BA2:  CLRF   x83
03BA4:  MOVWF  x82
03BA6:  MOVLW  1C
03BA8:  ADDWF  x82,W
03BAA:  MOVWF  01
03BAC:  MOVLW  00
03BAE:  ADDWFC x83,W
03BB0:  MOVWF  03
03BB2:  MOVF   01,W
03BB4:  ADDLW  07
03BB6:  MOVWF  FE9
03BB8:  MOVLW  01
03BBA:  ADDWFC 03,W
03BBC:  MOVWF  FEA
03BBE:  DECF   FEF,F
....................       }
03BC0:  BRA    3C74
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03BC2:  MOVLB  6
03BC4:  MOVF   x79,W
03BC6:  MULLW  21
03BC8:  MOVF   FF3,W
03BCA:  CLRF   x83
03BCC:  MOVWF  x82
03BCE:  MOVLW  08
03BD0:  ADDWF  x82,W
03BD2:  MOVWF  01
03BD4:  MOVLW  00
03BD6:  ADDWFC x83,W
03BD8:  MOVWF  03
03BDA:  MOVF   01,W
03BDC:  ADDLW  07
03BDE:  MOVWF  FE9
03BE0:  MOVLW  01
03BE2:  ADDWFC 03,W
03BE4:  MOVWF  FEA
03BE6:  MOVFF  FEF,6BC
03BEA:  MOVFF  FEC,683
03BEE:  MOVFF  FEC,6BE
03BF2:  MOVFF  FEC,6BF
03BF6:  MOVFF  683,6BD
03BFA:  CLRF   xC3
03BFC:  CLRF   xC2
03BFE:  CLRF   xC1
03C00:  CLRF   xC0
03C02:  MOVLB  0
03C04:  CALL   1CEA
03C08:  BNC   3C76
03C0A:  MOVLB  6
03C0C:  MOVF   x79,W
03C0E:  MULLW  21
03C10:  MOVF   FF3,W
03C12:  CLRF   x83
03C14:  MOVWF  x82
03C16:  MOVLW  10
03C18:  ADDWF  x82,W
03C1A:  MOVWF  01
03C1C:  MOVLW  00
03C1E:  ADDWFC x83,W
03C20:  MOVWF  03
03C22:  MOVF   01,W
03C24:  ADDLW  07
03C26:  MOVWF  FE9
03C28:  MOVLW  01
03C2A:  ADDWFC 03,W
03C2C:  MOVWF  FEA
03C2E:  MOVFF  FEF,6C0
03C32:  MOVFF  FEC,6C1
03C36:  MOVFF  FEC,6C2
03C3A:  MOVFF  FEC,6C3
03C3E:  CLRF   xBF
03C40:  CLRF   xBE
03C42:  CLRF   xBD
03C44:  CLRF   xBC
03C46:  MOVLB  0
03C48:  CALL   1CEA
03C4C:  BNC   3C76
....................          adcVals[ch].npoles++;
03C4E:  MOVLB  6
03C50:  MOVF   x79,W
03C52:  MULLW  21
03C54:  MOVF   FF3,W
03C56:  CLRF   x83
03C58:  MOVWF  x82
03C5A:  MOVLW  1C
03C5C:  ADDWF  x82,W
03C5E:  MOVWF  01
03C60:  MOVLW  00
03C62:  ADDWFC x83,W
03C64:  MOVWF  03
03C66:  MOVF   01,W
03C68:  ADDLW  07
03C6A:  MOVWF  FE9
03C6C:  MOVLW  01
03C6E:  ADDWFC 03,W
03C70:  MOVWF  FEA
03C72:  INCF   FEF,F
03C74:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03C76:  MOVLB  6
03C78:  MOVF   x79,W
03C7A:  MULLW  21
03C7C:  MOVF   FF3,W
03C7E:  CLRF   x83
03C80:  MOVWF  x82
03C82:  MOVLW  18
03C84:  ADDWF  x82,W
03C86:  MOVWF  01
03C88:  MOVLW  00
03C8A:  ADDWFC x83,W
03C8C:  MOVWF  03
03C8E:  MOVF   01,W
03C90:  ADDLW  07
03C92:  MOVWF  01
03C94:  MOVLW  01
03C96:  ADDWFC 03,F
03C98:  MOVFF  01,682
03C9C:  MOVFF  03,683
03CA0:  MOVFF  681,6C4
03CA4:  MOVFF  680,6C3
03CA8:  MOVFF  67F,6C2
03CAC:  MOVFF  67E,6C1
03CB0:  MOVLW  AA
03CB2:  MOVWF  xC8
03CB4:  MOVLW  27
03CB6:  MOVWF  xC7
03CB8:  MOVLW  1F
03CBA:  MOVWF  xC6
03CBC:  MOVLW  86
03CBE:  MOVWF  xC5
03CC0:  MOVLB  0
03CC2:  CALL   0D5E
03CC6:  MOVFF  03,687
03CCA:  MOVFF  02,686
03CCE:  MOVFF  01,685
03CD2:  MOVFF  00,684
03CD6:  MOVLB  6
03CD8:  MOVF   x79,W
03CDA:  MULLW  21
03CDC:  MOVF   FF3,W
03CDE:  CLRF   x89
03CE0:  MOVWF  x88
03CE2:  MOVLW  08
03CE4:  ADDWF  x88,W
03CE6:  MOVWF  01
03CE8:  MOVLW  00
03CEA:  ADDWFC x89,W
03CEC:  MOVWF  03
03CEE:  MOVF   01,W
03CF0:  ADDLW  07
03CF2:  MOVWF  FE9
03CF4:  MOVLW  01
03CF6:  ADDWFC 03,W
03CF8:  MOVWF  FEA
03CFA:  MOVFF  FEF,688
03CFE:  MOVFF  FEC,689
03D02:  MOVFF  FEC,68A
03D06:  MOVFF  FEC,68B
03D0A:  MOVF   x79,W
03D0C:  MULLW  21
03D0E:  MOVF   FF3,W
03D10:  CLRF   x8D
03D12:  MOVWF  x8C
03D14:  MOVLW  0C
03D16:  ADDWF  x8C,W
03D18:  MOVWF  01
03D1A:  MOVLW  00
03D1C:  ADDWFC x8D,W
03D1E:  MOVWF  03
03D20:  MOVF   01,W
03D22:  ADDLW  07
03D24:  MOVWF  FE9
03D26:  MOVLW  01
03D28:  ADDWFC 03,W
03D2A:  MOVWF  FEA
03D2C:  MOVFF  FEF,00
03D30:  MOVFF  FEC,01
03D34:  MOVFF  FEC,02
03D38:  MOVFF  FEC,03
03D3C:  MOVFF  03,68F
03D40:  MOVFF  02,68E
03D44:  MOVFF  01,68D
03D48:  MOVFF  00,68C
03D4C:  MOVFF  68B,693
03D50:  MOVFF  68A,692
03D54:  MOVFF  689,691
03D58:  MOVFF  688,690
03D5C:  MOVFF  03,697
03D60:  MOVFF  02,696
03D64:  MOVFF  01,695
03D68:  MOVFF  00,694
03D6C:  MOVLB  0
03D6E:  GOTO   23EC
03D72:  MOVFF  687,6C4
03D76:  MOVFF  686,6C3
03D7A:  MOVFF  685,6C2
03D7E:  MOVFF  684,6C1
03D82:  MOVFF  03,6C8
03D86:  MOVFF  02,6C7
03D8A:  MOVFF  01,6C6
03D8E:  MOVFF  00,6C5
03D92:  CALL   0D5E
03D96:  MOVFF  683,FEA
03D9A:  MOVFF  682,FE9
03D9E:  MOVFF  00,FEF
03DA2:  MOVFF  01,FEC
03DA6:  MOVFF  02,FEC
03DAA:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DAE:  MOVLB  6
03DB0:  MOVF   x79,W
03DB2:  MULLW  21
03DB4:  MOVF   FF3,W
03DB6:  CLRF   x83
03DB8:  MOVWF  x82
03DBA:  MOVLW  18
03DBC:  ADDWF  x82,W
03DBE:  MOVWF  01
03DC0:  MOVLW  00
03DC2:  ADDWFC x83,W
03DC4:  MOVWF  03
03DC6:  MOVF   01,W
03DC8:  ADDLW  07
03DCA:  MOVWF  FE9
03DCC:  MOVLW  01
03DCE:  ADDWFC 03,W
03DD0:  MOVWF  FEA
03DD2:  MOVFF  FEF,682
03DD6:  MOVFF  FEC,683
03DDA:  MOVFF  FEC,684
03DDE:  MOVFF  FEC,685
03DE2:  CLRF   xC4
03DE4:  CLRF   xC3
03DE6:  MOVLW  7A
03DE8:  MOVWF  xC2
03DEA:  MOVLW  88
03DEC:  MOVWF  xC1
03DEE:  MOVFF  681,6C8
03DF2:  MOVFF  680,6C7
03DF6:  MOVFF  67F,6C6
03DFA:  MOVFF  67E,6C5
03DFE:  MOVLB  0
03E00:  CALL   0D5E
03E04:  MOVFF  03,689
03E08:  MOVFF  02,688
03E0C:  MOVFF  01,687
03E10:  MOVFF  00,686
03E14:  MOVLB  6
03E16:  MOVF   x79,W
03E18:  MULLW  21
03E1A:  MOVF   FF3,W
03E1C:  CLRF   x8B
03E1E:  MOVWF  x8A
03E20:  MOVLW  1C
03E22:  ADDWF  x8A,W
03E24:  MOVWF  01
03E26:  MOVLW  00
03E28:  ADDWFC x8B,W
03E2A:  MOVWF  03
03E2C:  MOVF   01,W
03E2E:  ADDLW  07
03E30:  MOVWF  FE9
03E32:  MOVLW  01
03E34:  ADDWFC 03,W
03E36:  MOVWF  FEA
03E38:  MOVF   FEF,W
03E3A:  CLRF   xB3
03E3C:  MOVWF  xB2
03E3E:  BTFSC  xB2.7
03E40:  DECF   xB3,F
03E42:  MOVLB  0
03E44:  CALL   268E
03E48:  MOVFF  689,6C4
03E4C:  MOVFF  688,6C3
03E50:  MOVFF  687,6C2
03E54:  MOVFF  686,6C1
03E58:  MOVFF  03,6C8
03E5C:  MOVFF  02,6C7
03E60:  MOVFF  01,6C6
03E64:  MOVFF  00,6C5
03E68:  CALL   0D5E
03E6C:  MOVFF  FEA,687
03E70:  MOVFF  FE9,686
03E74:  BCF    FD8.1
03E76:  MOVFF  685,6C3
03E7A:  MOVFF  684,6C2
03E7E:  MOVFF  683,6C1
03E82:  MOVFF  682,6C0
03E86:  MOVFF  03,6C7
03E8A:  MOVFF  02,6C6
03E8E:  MOVFF  01,6C5
03E92:  MOVFF  00,6C4
03E96:  CALL   0E54
03E9A:  MOVFF  687,FEA
03E9E:  MOVFF  686,FE9
03EA2:  MOVFF  03,67D
03EA6:  MOVFF  02,67C
03EAA:  MOVFF  01,67B
03EAE:  MOVFF  00,67A
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EB2:  MOVLB  6
03EB4:  MOVF   x79,W
03EB6:  MULLW  21
03EB8:  MOVF   FF3,W
03EBA:  CLRF   x83
03EBC:  MOVWF  x82
03EBE:  MOVLW  1D
03EC0:  ADDWF  x82,W
03EC2:  MOVWF  01
03EC4:  MOVLW  00
03EC6:  ADDWFC x83,W
03EC8:  MOVWF  03
03ECA:  MOVF   01,W
03ECC:  ADDLW  07
03ECE:  MOVWF  01
03ED0:  MOVLW  01
03ED2:  ADDWFC 03,F
03ED4:  MOVFF  01,682
03ED8:  MOVFF  03,683
03EDC:  MOVF   x79,W
03EDE:  MULLW  18
03EE0:  MOVF   FF3,W
03EE2:  CLRF   x85
03EE4:  MOVWF  x84
03EE6:  MOVLW  14
03EE8:  ADDWF  x84,W
03EEA:  MOVWF  01
03EEC:  MOVLW  00
03EEE:  ADDWFC x85,W
03EF0:  MOVWF  03
03EF2:  MOVF   01,W
03EF4:  ADDLW  82
03EF6:  MOVWF  FE9
03EF8:  MOVLW  00
03EFA:  ADDWFC 03,W
03EFC:  MOVWF  FEA
03EFE:  MOVFF  FEF,6C5
03F02:  MOVFF  FEC,01
03F06:  MOVFF  FEC,02
03F0A:  MOVFF  FEC,03
03F0E:  MOVFF  67D,6C4
03F12:  MOVFF  67C,6C3
03F16:  MOVFF  67B,6C2
03F1A:  MOVFF  67A,6C1
03F1E:  MOVFF  03,6C8
03F22:  MOVFF  02,6C7
03F26:  MOVFF  01,6C6
03F2A:  MOVLB  0
03F2C:  CALL   0D5E
03F30:  MOVFF  03,687
03F34:  MOVFF  02,686
03F38:  MOVFF  01,685
03F3C:  MOVFF  00,684
03F40:  MOVFF  03,693
03F44:  MOVFF  02,692
03F48:  MOVFF  01,691
03F4C:  MOVFF  00,690
03F50:  MOVLB  6
03F52:  CLRF   x97
03F54:  CLRF   x96
03F56:  MOVLW  20
03F58:  MOVWF  x95
03F5A:  MOVLW  81
03F5C:  MOVWF  x94
03F5E:  MOVLB  0
03F60:  CALL   33CC
03F64:  MOVFF  03,687
03F68:  MOVFF  02,686
03F6C:  MOVFF  01,685
03F70:  MOVFF  00,684
03F74:  MOVLB  6
03F76:  MOVF   x79,W
03F78:  MULLW  18
03F7A:  MOVF   FF3,W
03F7C:  CLRF   x89
03F7E:  MOVWF  x88
03F80:  MOVLW  10
03F82:  ADDWF  x88,W
03F84:  MOVWF  01
03F86:  MOVLW  00
03F88:  ADDWFC x89,W
03F8A:  MOVWF  03
03F8C:  MOVF   01,W
03F8E:  ADDLW  82
03F90:  MOVWF  FE9
03F92:  MOVLW  00
03F94:  ADDWFC 03,W
03F96:  MOVWF  FEA
03F98:  MOVFF  FEF,6C5
03F9C:  MOVFF  FEC,01
03FA0:  MOVFF  FEC,02
03FA4:  MOVFF  FEC,03
03FA8:  MOVFF  67D,6C4
03FAC:  MOVFF  67C,6C3
03FB0:  MOVFF  67B,6C2
03FB4:  MOVFF  67A,6C1
03FB8:  MOVFF  03,6C8
03FBC:  MOVFF  02,6C7
03FC0:  MOVFF  01,6C6
03FC4:  MOVLB  0
03FC6:  CALL   0D5E
03FCA:  MOVFF  03,68B
03FCE:  MOVFF  02,68A
03FD2:  MOVFF  01,689
03FD6:  MOVFF  00,688
03FDA:  MOVFF  03,693
03FDE:  MOVFF  02,692
03FE2:  MOVFF  01,691
03FE6:  MOVFF  00,690
03FEA:  MOVLB  6
03FEC:  CLRF   x97
03FEE:  CLRF   x96
03FF0:  CLRF   x95
03FF2:  MOVLW  81
03FF4:  MOVWF  x94
03FF6:  MOVLB  0
03FF8:  CALL   33CC
03FFC:  MOVFF  FEA,689
04000:  MOVFF  FE9,688
04004:  BCF    FD8.1
04006:  MOVFF  687,6C3
0400A:  MOVFF  686,6C2
0400E:  MOVFF  685,6C1
04012:  MOVFF  684,6C0
04016:  MOVFF  03,6C7
0401A:  MOVFF  02,6C6
0401E:  MOVFF  01,6C5
04022:  MOVFF  00,6C4
04026:  CALL   0E54
0402A:  MOVFF  689,FEA
0402E:  MOVFF  688,FE9
04032:  MOVFF  03,687
04036:  MOVFF  02,686
0403A:  MOVFF  01,685
0403E:  MOVFF  00,684
04042:  MOVLB  6
04044:  MOVF   x79,W
04046:  MULLW  18
04048:  MOVF   FF3,W
0404A:  CLRF   x8B
0404C:  MOVWF  x8A
0404E:  MOVLW  0C
04050:  ADDWF  x8A,W
04052:  MOVWF  01
04054:  MOVLW  00
04056:  ADDWFC x8B,W
04058:  MOVWF  03
0405A:  MOVF   01,W
0405C:  ADDLW  82
0405E:  MOVWF  FE9
04060:  MOVLW  00
04062:  ADDWFC 03,W
04064:  MOVWF  FEA
04066:  MOVFF  FEF,6C5
0406A:  MOVFF  FEC,01
0406E:  MOVFF  FEC,02
04072:  MOVFF  FEC,03
04076:  MOVFF  67D,6C4
0407A:  MOVFF  67C,6C3
0407E:  MOVFF  67B,6C2
04082:  MOVFF  67A,6C1
04086:  MOVFF  03,6C8
0408A:  MOVFF  02,6C7
0408E:  MOVFF  01,6C6
04092:  MOVLB  0
04094:  CALL   0D5E
04098:  MOVFF  03,68D
0409C:  MOVFF  02,68C
040A0:  MOVFF  01,68B
040A4:  MOVFF  00,68A
040A8:  MOVFF  03,693
040AC:  MOVFF  02,692
040B0:  MOVFF  01,691
040B4:  MOVFF  00,690
040B8:  MOVLB  6
040BA:  CLRF   x97
040BC:  CLRF   x96
040BE:  MOVLW  40
040C0:  MOVWF  x95
040C2:  MOVLW  80
040C4:  MOVWF  x94
040C6:  MOVLB  0
040C8:  CALL   33CC
040CC:  MOVFF  FEA,68B
040D0:  MOVFF  FE9,68A
040D4:  BCF    FD8.1
040D6:  MOVFF  687,6C3
040DA:  MOVFF  686,6C2
040DE:  MOVFF  685,6C1
040E2:  MOVFF  684,6C0
040E6:  MOVFF  03,6C7
040EA:  MOVFF  02,6C6
040EE:  MOVFF  01,6C5
040F2:  MOVFF  00,6C4
040F6:  CALL   0E54
040FA:  MOVFF  68B,FEA
040FE:  MOVFF  68A,FE9
04102:  MOVFF  03,687
04106:  MOVFF  02,686
0410A:  MOVFF  01,685
0410E:  MOVFF  00,684
04112:  MOVLB  6
04114:  MOVF   x79,W
04116:  MULLW  18
04118:  MOVF   FF3,W
0411A:  CLRF   x8D
0411C:  MOVWF  x8C
0411E:  MOVLW  08
04120:  ADDWF  x8C,W
04122:  MOVWF  01
04124:  MOVLW  00
04126:  ADDWFC x8D,W
04128:  MOVWF  03
0412A:  MOVF   01,W
0412C:  ADDLW  82
0412E:  MOVWF  FE9
04130:  MOVLW  00
04132:  ADDWFC 03,W
04134:  MOVWF  FEA
04136:  MOVFF  FEF,6C5
0413A:  MOVFF  FEC,01
0413E:  MOVFF  FEC,02
04142:  MOVFF  FEC,03
04146:  MOVFF  67D,6C4
0414A:  MOVFF  67C,6C3
0414E:  MOVFF  67B,6C2
04152:  MOVFF  67A,6C1
04156:  MOVFF  03,6C8
0415A:  MOVFF  02,6C7
0415E:  MOVFF  01,6C6
04162:  MOVLB  0
04164:  CALL   0D5E
04168:  MOVFF  03,68F
0416C:  MOVFF  02,68E
04170:  MOVFF  01,68D
04174:  MOVFF  00,68C
04178:  MOVFF  03,693
0417C:  MOVFF  02,692
04180:  MOVFF  01,691
04184:  MOVFF  00,690
04188:  MOVLB  6
0418A:  CLRF   x97
0418C:  CLRF   x96
0418E:  CLRF   x95
04190:  MOVLW  80
04192:  MOVWF  x94
04194:  MOVLB  0
04196:  CALL   33CC
0419A:  MOVFF  FEA,68D
0419E:  MOVFF  FE9,68C
041A2:  BCF    FD8.1
041A4:  MOVFF  687,6C3
041A8:  MOVFF  686,6C2
041AC:  MOVFF  685,6C1
041B0:  MOVFF  684,6C0
041B4:  MOVFF  03,6C7
041B8:  MOVFF  02,6C6
041BC:  MOVFF  01,6C5
041C0:  MOVFF  00,6C4
041C4:  CALL   0E54
041C8:  MOVFF  68D,FEA
041CC:  MOVFF  68C,FE9
041D0:  MOVFF  03,687
041D4:  MOVFF  02,686
041D8:  MOVFF  01,685
041DC:  MOVFF  00,684
041E0:  MOVLB  6
041E2:  MOVF   x79,W
041E4:  MULLW  18
041E6:  MOVF   FF3,W
041E8:  CLRF   x8F
041EA:  MOVWF  x8E
041EC:  MOVLW  04
041EE:  ADDWF  x8E,W
041F0:  MOVWF  01
041F2:  MOVLW  00
041F4:  ADDWFC x8F,W
041F6:  MOVWF  03
041F8:  MOVF   01,W
041FA:  ADDLW  82
041FC:  MOVWF  FE9
041FE:  MOVLW  00
04200:  ADDWFC 03,W
04202:  MOVWF  FEA
04204:  MOVFF  FEF,6C5
04208:  MOVFF  FEC,01
0420C:  MOVFF  FEC,02
04210:  MOVFF  FEC,03
04214:  MOVFF  67D,6C4
04218:  MOVFF  67C,6C3
0421C:  MOVFF  67B,6C2
04220:  MOVFF  67A,6C1
04224:  MOVFF  03,6C8
04228:  MOVFF  02,6C7
0422C:  MOVFF  01,6C6
04230:  MOVLB  0
04232:  CALL   0D5E
04236:  MOVFF  FEA,68F
0423A:  MOVFF  FE9,68E
0423E:  BCF    FD8.1
04240:  MOVFF  687,6C3
04244:  MOVFF  686,6C2
04248:  MOVFF  685,6C1
0424C:  MOVFF  684,6C0
04250:  MOVFF  03,6C7
04254:  MOVFF  02,6C6
04258:  MOVFF  01,6C5
0425C:  MOVFF  00,6C4
04260:  CALL   0E54
04264:  MOVFF  68F,FEA
04268:  MOVFF  68E,FE9
0426C:  MOVFF  03,6C3
04270:  MOVFF  02,6C2
04274:  MOVFF  01,6C1
04278:  MOVFF  00,6C0
0427C:  MOVLB  6
0427E:  MOVF   x79,W
04280:  MULLW  18
04282:  MOVF   FF3,W
04284:  CLRF   x91
04286:  MOVWF  x90
04288:  MOVLW  82
0428A:  ADDWF  x90,W
0428C:  MOVWF  FE9
0428E:  MOVLW  00
04290:  ADDWFC x91,W
04292:  MOVWF  FEA
04294:  MOVFF  FEF,6C4
04298:  MOVFF  FEC,01
0429C:  MOVFF  FEC,02
042A0:  MOVFF  FEC,03
042A4:  BCF    FD8.1
042A6:  MOVFF  03,6C7
042AA:  MOVFF  02,6C6
042AE:  MOVFF  01,6C5
042B2:  MOVLB  0
042B4:  CALL   0E54
042B8:  MOVFF  683,FEA
042BC:  MOVFF  682,FE9
042C0:  MOVFF  00,FEF
042C4:  MOVFF  01,FEC
042C8:  MOVFF  02,FEC
042CC:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
042D0:  MOVLB  6
042D2:  MOVF   x79,F
042D4:  BNZ   4332
042D6:  MOVF   x79,W
042D8:  MULLW  21
042DA:  MOVF   FF3,W
042DC:  CLRF   x83
042DE:  MOVWF  x82
042E0:  MOVLW  1D
042E2:  ADDWF  x82,W
042E4:  MOVWF  01
042E6:  MOVLW  00
042E8:  ADDWFC x83,W
042EA:  MOVWF  03
042EC:  MOVF   01,W
042EE:  ADDLW  07
042F0:  MOVWF  FE9
042F2:  MOVLW  01
042F4:  ADDWFC 03,W
042F6:  MOVWF  FEA
042F8:  MOVFF  FEF,6C1
042FC:  MOVFF  FEC,6C2
04300:  MOVFF  FEC,6C3
04304:  MOVFF  FEC,6C4
04308:  MOVF   FED,F
0430A:  MOVF   FED,F
0430C:  MOVF   FED,F
0430E:  CLRF   xC8
04310:  CLRF   xC7
04312:  MOVLW  80
04314:  MOVWF  xC6
04316:  MOVLW  7F
04318:  MOVWF  xC5
0431A:  MOVLB  0
0431C:  CALL   0D5E
04320:  MOVFF  00,FEF
04324:  MOVFF  01,FEC
04328:  MOVFF  02,FEC
0432C:  MOVFF  03,FEC
04330:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
04332:  MOVF   x79,W
04334:  MULLW  20
04336:  MOVF   FF3,W
04338:  CLRF   x83
0433A:  MOVWF  x82
0433C:  MOVLW  14
0433E:  ADDWF  x82,W
04340:  MOVWF  01
04342:  MOVLW  00
04344:  ADDWFC x83,W
04346:  MOVWF  03
04348:  MOVF   01,W
0434A:  ADDLW  20
0434C:  MOVWF  01
0434E:  MOVLW  00
04350:  ADDWFC 03,F
04352:  MOVFF  01,682
04356:  MOVFF  03,683
0435A:  MOVF   x79,W
0435C:  MULLW  20
0435E:  MOVF   FF3,W
04360:  CLRF   x85
04362:  MOVWF  x84
04364:  MOVLW  10
04366:  ADDWF  x84,W
04368:  MOVWF  01
0436A:  MOVLW  00
0436C:  ADDWFC x85,W
0436E:  MOVWF  03
04370:  MOVF   01,W
04372:  ADDLW  20
04374:  MOVWF  FE9
04376:  MOVLW  00
04378:  ADDWFC 03,W
0437A:  MOVWF  FEA
0437C:  MOVFF  FEF,00
04380:  MOVFF  FEC,01
04384:  MOVFF  FEC,02
04388:  MOVFF  FEC,03
0438C:  MOVFF  683,FEA
04390:  MOVFF  682,FE9
04394:  MOVFF  00,FEF
04398:  MOVFF  01,FEC
0439C:  MOVFF  02,FEC
043A0:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043A4:  MOVF   x79,W
043A6:  MULLW  20
043A8:  MOVF   FF3,W
043AA:  CLRF   x83
043AC:  MOVWF  x82
043AE:  MOVLW  10
043B0:  ADDWF  x82,W
043B2:  MOVWF  01
043B4:  MOVLW  00
043B6:  ADDWFC x83,W
043B8:  MOVWF  03
043BA:  MOVF   01,W
043BC:  ADDLW  20
043BE:  MOVWF  01
043C0:  MOVLW  00
043C2:  ADDWFC 03,F
043C4:  MOVFF  01,682
043C8:  MOVFF  03,683
043CC:  MOVF   x79,W
043CE:  MULLW  21
043D0:  MOVF   FF3,W
043D2:  CLRF   x85
043D4:  MOVWF  x84
043D6:  MOVLW  1D
043D8:  ADDWF  x84,W
043DA:  MOVWF  01
043DC:  MOVLW  00
043DE:  ADDWFC x85,W
043E0:  MOVWF  03
043E2:  MOVF   01,W
043E4:  ADDLW  07
043E6:  MOVWF  FE9
043E8:  MOVLW  01
043EA:  ADDWFC 03,W
043EC:  MOVWF  FEA
043EE:  MOVFF  FEF,00
043F2:  MOVFF  FEC,01
043F6:  MOVFF  FEC,02
043FA:  MOVFF  FEC,03
043FE:  MOVFF  683,FEA
04402:  MOVFF  682,FE9
04406:  MOVFF  00,FEF
0440A:  MOVFF  01,FEC
0440E:  MOVFF  02,FEC
04412:  MOVFF  03,FEC
04416:  MOVLB  0
04418:  GOTO   4574 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xCD,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  6
001CA:  CLRF   xE1
001CC:  MOVWF  xE0
001CE:  MOVLW  BA
001D0:  ADDWF  xE0,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC xE1,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xCD,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  6
001E8:  CLRF   xE1
001EA:  MOVWF  xE0
001EC:  MOVLW  BA
001EE:  ADDWF  xE0,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC xE1,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1CD,6E0
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xCD,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xCD
....................       
....................       smData[!ch].dataReady = true;
00210:  MOVF   xCD,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  6
00220:  CLRF   xE1
00222:  MOVWF  xE0
00224:  MOVLW  BA
00226:  ADDWF  xE0,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC xE1,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xCD,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  6
00244:  CLRF   xE1
00246:  MOVWF  xE0
00248:  MOVLW  BA
0024A:  ADDWF  xE0,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC xE1,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01734:  MOVLB  6
01736:  CLRF   x8D
01738:  CLRF   x8C
0173A:  CLRF   x8B
0173C:  CLRF   x8A
0173E:  CLRF   x91
01740:  CLRF   x90
01742:  CLRF   x8F
01744:  CLRF   x8E
01746:  CLRF   x95
01748:  CLRF   x94
0174A:  CLRF   x93
0174C:  CLRF   x92
0174E:  CLRF   x99
01750:  CLRF   x98
01752:  CLRF   x97
01754:  CLRF   x96
01756:  CLRF   x9D
01758:  CLRF   x9C
0175A:  CLRF   x9B
0175C:  CLRF   x9A
0175E:  CLRF   xA1
01760:  CLRF   xA0
01762:  CLRF   x9F
01764:  CLRF   x9E
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01766:  MOVF   x79,F
01768:  BNZ   178C
....................       sQ_ch = sQ_x;
0176A:  MOVLW  01
0176C:  MOVWF  x83
0176E:  MOVLW  66
01770:  MOVWF  x82
....................       cQ_ch = cQ_x;
01772:  MOVLW  01
01774:  MOVWF  x85
01776:  MOVLW  7A
01778:  MOVWF  x84
....................       sIn_ch = &sIn_x;
0177A:  MOVLW  01
0177C:  MOVWF  x87
0177E:  MOVLW  B6
01780:  MOVWF  x86
....................       cIn_ch = &cIn_x;
01782:  MOVLW  01
01784:  MOVWF  x89
01786:  MOVLW  B7
01788:  MOVWF  x88
....................    }
0178A:  BRA    17B0
....................    else if (ch==1){
0178C:  DECFSZ x79,W
0178E:  BRA    17B0
....................       sQ_ch = sQ_y;
01790:  MOVLW  01
01792:  MOVWF  x83
01794:  MOVLW  8E
01796:  MOVWF  x82
....................       cQ_ch = cQ_y;
01798:  MOVLW  01
0179A:  MOVWF  x85
0179C:  MOVLW  A2
0179E:  MOVWF  x84
....................       sIn_ch = &sIn_y;
017A0:  MOVLW  01
017A2:  MOVWF  x87
017A4:  MOVLW  B8
017A6:  MOVWF  x86
....................       cIn_ch = &cIn_y;
017A8:  MOVLW  01
017AA:  MOVWF  x89
017AC:  MOVLW  B9
017AE:  MOVWF  x88
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017B0:  MOVFF  683,6A4
017B4:  MOVFF  682,6A3
017B8:  MOVFF  687,6A6
017BC:  MOVFF  686,6A5
017C0:  MOVFF  67D,6AA
017C4:  MOVFF  67C,6A9
017C8:  MOVFF  67B,6A8
017CC:  MOVFF  67A,6A7
017D0:  MOVLB  0
017D2:  CALL   08C4
....................    push(cQ_ch, cIn_ch, cosCnts);
017D6:  MOVFF  685,6A4
017DA:  MOVFF  684,6A3
017DE:  MOVFF  689,6A6
017E2:  MOVFF  688,6A5
017E6:  MOVFF  681,6AA
017EA:  MOVFF  680,6A9
017EE:  MOVFF  67F,6A8
017F2:  MOVFF  67E,6A7
017F6:  CALL   08C4
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
017FA:  MOVLB  6
017FC:  MOVFF  682,FE9
01800:  MOVFF  683,FEA
01804:  MOVFF  FEF,692
01808:  MOVFF  FEC,693
0180C:  MOVFF  FEC,694
01810:  MOVFF  FEC,695
....................    sinMin=sQ_ch[0];
01814:  MOVFF  682,FE9
01818:  MOVFF  683,FEA
0181C:  MOVFF  FEF,696
01820:  MOVFF  FEC,697
01824:  MOVFF  FEC,698
01828:  MOVFF  FEC,699
....................    cosMax=cQ_ch[0];
0182C:  MOVFF  684,FE9
01830:  MOVFF  685,FEA
01834:  MOVFF  FEF,69A
01838:  MOVFF  FEC,69B
0183C:  MOVFF  FEC,69C
01840:  MOVFF  FEC,69D
....................    cosMin=cQ_ch[0];
01844:  MOVFF  684,FE9
01848:  MOVFF  685,FEA
0184C:  MOVFF  FEF,69E
01850:  MOVFF  FEC,69F
01854:  MOVFF  FEC,6A0
01858:  MOVFF  FEC,6A1
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
0185C:  MOVLW  01
0185E:  MOVWF  xA2
01860:  MOVF   xA2,W
01862:  SUBLW  04
01864:  BTFSS  FD8.0
01866:  BRA    1B76
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
01868:  CLRF   xB3
0186A:  MOVFF  6A2,6B2
0186E:  CLRF   xB5
01870:  MOVLW  04
01872:  MOVWF  xB4
01874:  MOVLB  0
01876:  CALL   0876
0187A:  MOVFF  02,03
0187E:  MOVF   01,W
01880:  MOVLB  6
01882:  ADDWF  x82,W
01884:  MOVWF  FE9
01886:  MOVF   x83,W
01888:  ADDWFC 02,W
0188A:  MOVWF  FEA
0188C:  MOVFF  FEF,00
01890:  MOVFF  FEC,01
01894:  MOVFF  FEC,02
01898:  MOVFF  FEC,03
0189C:  BTFSS  x95.7
0189E:  BRA    18A6
018A0:  BTFSS  03.7
018A2:  BRA    18C8
018A4:  BRA    18AA
018A6:  BTFSC  03.7
018A8:  BRA    18FE
018AA:  MOVF   x95,W
018AC:  SUBWF  03,W
018AE:  BNC   18FE
018B0:  BNZ   18C8
018B2:  MOVF   x94,W
018B4:  SUBWF  02,W
018B6:  BNC   18FE
018B8:  BNZ   18C8
018BA:  MOVF   x93,W
018BC:  SUBWF  01,W
018BE:  BNC   18FE
018C0:  BNZ   18C8
018C2:  MOVF   00,W
018C4:  SUBWF  x92,W
018C6:  BC    18FE
018C8:  CLRF   xB3
018CA:  MOVFF  6A2,6B2
018CE:  CLRF   xB5
018D0:  MOVLW  04
018D2:  MOVWF  xB4
018D4:  MOVLB  0
018D6:  CALL   0876
018DA:  MOVFF  02,03
018DE:  MOVF   01,W
018E0:  MOVLB  6
018E2:  ADDWF  x82,W
018E4:  MOVWF  FE9
018E6:  MOVF   x83,W
018E8:  ADDWFC 02,W
018EA:  MOVWF  FEA
018EC:  MOVFF  FEF,692
018F0:  MOVFF  FEC,693
018F4:  MOVFF  FEC,694
018F8:  MOVFF  FEC,695
018FC:  MOVF   x92,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
018FE:  CLRF   xB3
01900:  MOVFF  6A2,6B2
01904:  CLRF   xB5
01906:  MOVLW  04
01908:  MOVWF  xB4
0190A:  MOVLB  0
0190C:  CALL   0876
01910:  MOVFF  02,03
01914:  MOVF   01,W
01916:  MOVLB  6
01918:  ADDWF  x82,W
0191A:  MOVWF  FE9
0191C:  MOVF   x83,W
0191E:  ADDWFC 02,W
01920:  MOVWF  FEA
01922:  MOVFF  FEF,00
01926:  MOVFF  FEC,01
0192A:  MOVFF  FEC,02
0192E:  MOVFF  FEC,03
01932:  BTFSS  03.7
01934:  BRA    193C
01936:  BTFSS  x99.7
01938:  BRA    195E
0193A:  BRA    1940
0193C:  BTFSC  x99.7
0193E:  BRA    19A2
01940:  MOVF   03,W
01942:  SUBWF  x99,W
01944:  BNC   19A2
01946:  BNZ   195E
01948:  MOVF   02,W
0194A:  SUBWF  x98,W
0194C:  BNC   19A2
0194E:  BNZ   195E
01950:  MOVF   01,W
01952:  SUBWF  x97,W
01954:  BNC   19A2
01956:  BNZ   195E
01958:  MOVF   x96,W
0195A:  SUBWF  00,W
0195C:  BC    19A2
0195E:  CLRF   xB3
01960:  MOVFF  6A2,6B2
01964:  CLRF   xB5
01966:  MOVLW  04
01968:  MOVWF  xB4
0196A:  MOVLB  0
0196C:  CALL   0876
01970:  MOVFF  02,03
01974:  MOVF   01,W
01976:  MOVLB  6
01978:  ADDWF  x82,W
0197A:  MOVWF  FE9
0197C:  MOVF   x83,W
0197E:  ADDWFC 02,W
01980:  MOVWF  FEA
01982:  MOVFF  FEF,696
01986:  MOVFF  FEC,697
0198A:  MOVFF  FEC,698
0198E:  MOVFF  FEC,699
01992:  MOVFF  696,00
01996:  MOVFF  697,01
0199A:  MOVFF  698,02
0199E:  MOVFF  699,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019A2:  CLRF   xB3
019A4:  MOVFF  6A2,6B2
019A8:  CLRF   xB5
019AA:  MOVLW  04
019AC:  MOVWF  xB4
019AE:  MOVLB  0
019B0:  CALL   0876
019B4:  MOVFF  02,03
019B8:  MOVF   01,W
019BA:  MOVLB  6
019BC:  ADDWF  x84,W
019BE:  MOVWF  FE9
019C0:  MOVF   x85,W
019C2:  ADDWFC 02,W
019C4:  MOVWF  FEA
019C6:  MOVFF  FEF,00
019CA:  MOVFF  FEC,01
019CE:  MOVFF  FEC,02
019D2:  MOVFF  FEC,03
019D6:  BTFSS  x9D.7
019D8:  BRA    19E0
019DA:  BTFSS  03.7
019DC:  BRA    1A02
019DE:  BRA    19E4
019E0:  BTFSC  03.7
019E2:  BRA    1A46
019E4:  MOVF   x9D,W
019E6:  SUBWF  03,W
019E8:  BNC   1A46
019EA:  BNZ   1A02
019EC:  MOVF   x9C,W
019EE:  SUBWF  02,W
019F0:  BNC   1A46
019F2:  BNZ   1A02
019F4:  MOVF   x9B,W
019F6:  SUBWF  01,W
019F8:  BNC   1A46
019FA:  BNZ   1A02
019FC:  MOVF   00,W
019FE:  SUBWF  x9A,W
01A00:  BC    1A46
01A02:  CLRF   xB3
01A04:  MOVFF  6A2,6B2
01A08:  CLRF   xB5
01A0A:  MOVLW  04
01A0C:  MOVWF  xB4
01A0E:  MOVLB  0
01A10:  CALL   0876
01A14:  MOVFF  02,03
01A18:  MOVF   01,W
01A1A:  MOVLB  6
01A1C:  ADDWF  x84,W
01A1E:  MOVWF  FE9
01A20:  MOVF   x85,W
01A22:  ADDWFC 02,W
01A24:  MOVWF  FEA
01A26:  MOVFF  FEF,69A
01A2A:  MOVFF  FEC,69B
01A2E:  MOVFF  FEC,69C
01A32:  MOVFF  FEC,69D
01A36:  MOVFF  69A,00
01A3A:  MOVFF  69B,01
01A3E:  MOVFF  69C,02
01A42:  MOVFF  69D,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A46:  CLRF   xB3
01A48:  MOVFF  6A2,6B2
01A4C:  CLRF   xB5
01A4E:  MOVLW  04
01A50:  MOVWF  xB4
01A52:  MOVLB  0
01A54:  CALL   0876
01A58:  MOVFF  02,03
01A5C:  MOVF   01,W
01A5E:  MOVLB  6
01A60:  ADDWF  x84,W
01A62:  MOVWF  FE9
01A64:  MOVF   x85,W
01A66:  ADDWFC 02,W
01A68:  MOVWF  FEA
01A6A:  MOVFF  FEF,00
01A6E:  MOVFF  FEC,01
01A72:  MOVFF  FEC,02
01A76:  MOVFF  FEC,03
01A7A:  BTFSS  03.7
01A7C:  BRA    1A84
01A7E:  BTFSS  xA1.7
01A80:  BRA    1AA6
01A82:  BRA    1A88
01A84:  BTFSC  xA1.7
01A86:  BRA    1AEA
01A88:  MOVF   03,W
01A8A:  SUBWF  xA1,W
01A8C:  BNC   1AEA
01A8E:  BNZ   1AA6
01A90:  MOVF   02,W
01A92:  SUBWF  xA0,W
01A94:  BNC   1AEA
01A96:  BNZ   1AA6
01A98:  MOVF   01,W
01A9A:  SUBWF  x9F,W
01A9C:  BNC   1AEA
01A9E:  BNZ   1AA6
01AA0:  MOVF   x9E,W
01AA2:  SUBWF  00,W
01AA4:  BC    1AEA
01AA6:  CLRF   xB3
01AA8:  MOVFF  6A2,6B2
01AAC:  CLRF   xB5
01AAE:  MOVLW  04
01AB0:  MOVWF  xB4
01AB2:  MOVLB  0
01AB4:  CALL   0876
01AB8:  MOVFF  02,03
01ABC:  MOVF   01,W
01ABE:  MOVLB  6
01AC0:  ADDWF  x84,W
01AC2:  MOVWF  FE9
01AC4:  MOVF   x85,W
01AC6:  ADDWFC 02,W
01AC8:  MOVWF  FEA
01ACA:  MOVFF  FEF,69E
01ACE:  MOVFF  FEC,69F
01AD2:  MOVFF  FEC,6A0
01AD6:  MOVFF  FEC,6A1
01ADA:  MOVFF  69E,00
01ADE:  MOVFF  69F,01
01AE2:  MOVFF  6A0,02
01AE6:  MOVFF  6A1,03
....................       sumSin+=sQ_ch[i];
01AEA:  CLRF   xB3
01AEC:  MOVFF  6A2,6B2
01AF0:  CLRF   xB5
01AF2:  MOVLW  04
01AF4:  MOVWF  xB4
01AF6:  MOVLB  0
01AF8:  CALL   0876
01AFC:  MOVFF  02,03
01B00:  MOVF   01,W
01B02:  MOVLB  6
01B04:  ADDWF  x82,W
01B06:  MOVWF  FE9
01B08:  MOVF   x83,W
01B0A:  ADDWFC 02,W
01B0C:  MOVWF  FEA
01B0E:  MOVFF  FEF,00
01B12:  MOVFF  FEC,01
01B16:  MOVFF  FEC,02
01B1A:  MOVFF  FEC,03
01B1E:  MOVF   00,W
01B20:  ADDWF  x8A,F
01B22:  MOVF   01,W
01B24:  ADDWFC x8B,F
01B26:  MOVF   02,W
01B28:  ADDWFC x8C,F
01B2A:  MOVF   03,W
01B2C:  ADDWFC x8D,F
....................       sumCos+=cQ_ch[i];
01B2E:  CLRF   xB3
01B30:  MOVFF  6A2,6B2
01B34:  CLRF   xB5
01B36:  MOVLW  04
01B38:  MOVWF  xB4
01B3A:  MOVLB  0
01B3C:  CALL   0876
01B40:  MOVFF  02,03
01B44:  MOVF   01,W
01B46:  MOVLB  6
01B48:  ADDWF  x84,W
01B4A:  MOVWF  FE9
01B4C:  MOVF   x85,W
01B4E:  ADDWFC 02,W
01B50:  MOVWF  FEA
01B52:  MOVFF  FEF,00
01B56:  MOVFF  FEC,01
01B5A:  MOVFF  FEC,02
01B5E:  MOVFF  FEC,03
01B62:  MOVF   00,W
01B64:  ADDWF  x8E,F
01B66:  MOVF   01,W
01B68:  ADDWFC x8F,F
01B6A:  MOVF   02,W
01B6C:  ADDWFC x90,F
01B6E:  MOVF   03,W
01B70:  ADDWFC x91,F
01B72:  INCF   xA2,F
01B74:  BRA    1860
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01B76:  MOVF   x96,W
01B78:  ADDWF  x92,W
01B7A:  MOVWF  00
01B7C:  MOVF   x97,W
01B7E:  ADDWFC x93,W
01B80:  MOVWF  01
01B82:  MOVF   x98,W
01B84:  ADDWFC x94,W
01B86:  MOVWF  02
01B88:  MOVF   x99,W
01B8A:  ADDWFC x95,W
01B8C:  MOVWF  03
01B8E:  MOVF   00,W
01B90:  SUBWF  x8A,F
01B92:  MOVF   01,W
01B94:  SUBWFB x8B,F
01B96:  MOVF   02,W
01B98:  SUBWFB x8C,F
01B9A:  MOVF   03,W
01B9C:  SUBWFB x8D,F
....................    sumCos-=(cosMax+cosMin);
01B9E:  MOVF   x9E,W
01BA0:  ADDWF  x9A,W
01BA2:  MOVWF  00
01BA4:  MOVF   x9F,W
01BA6:  ADDWFC x9B,W
01BA8:  MOVWF  01
01BAA:  MOVF   xA0,W
01BAC:  ADDWFC x9C,W
01BAE:  MOVWF  02
01BB0:  MOVF   xA1,W
01BB2:  ADDWFC x9D,W
01BB4:  MOVWF  03
01BB6:  MOVF   00,W
01BB8:  SUBWF  x8E,F
01BBA:  MOVF   01,W
01BBC:  SUBWFB x8F,F
01BBE:  MOVF   02,W
01BC0:  SUBWFB x90,F
01BC2:  MOVF   03,W
01BC4:  SUBWFB x91,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BC6:  MOVF   x79,W
01BC8:  MULLW  09
01BCA:  MOVF   FF3,W
01BCC:  CLRF   xA4
01BCE:  MOVWF  xA3
01BD0:  MOVLW  01
01BD2:  ADDWF  xA3,W
01BD4:  MOVWF  01
01BD6:  MOVLW  00
01BD8:  ADDWFC xA4,W
01BDA:  MOVWF  03
01BDC:  MOVF   01,W
01BDE:  ADDLW  BA
01BE0:  MOVWF  FE9
01BE2:  MOVLW  01
01BE4:  ADDWFC 03,W
01BE6:  MOVWF  FEA
01BE8:  MOVFF  FEA,6A6
01BEC:  MOVFF  FE9,6A5
01BF0:  BCF    FD8.1
01BF2:  MOVFF  68D,6AA
01BF6:  MOVFF  68C,6A9
01BFA:  MOVFF  68B,6A8
01BFE:  MOVFF  68A,6A7
01C02:  CLRF   xAE
01C04:  CLRF   xAD
01C06:  CLRF   xAC
01C08:  MOVLW  03
01C0A:  MOVWF  xAB
01C0C:  MOVLB  0
01C0E:  RCALL  164A
01C10:  MOVFF  6A6,FEA
01C14:  MOVFF  6A5,FE9
01C18:  MOVFF  00,FEF
01C1C:  MOVFF  01,FEC
01C20:  MOVFF  02,FEC
01C24:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C28:  MOVLB  6
01C2A:  MOVF   x79,W
01C2C:  MULLW  09
01C2E:  MOVF   FF3,W
01C30:  CLRF   xA4
01C32:  MOVWF  xA3
01C34:  MOVLW  05
01C36:  ADDWF  xA3,W
01C38:  MOVWF  01
01C3A:  MOVLW  00
01C3C:  ADDWFC xA4,W
01C3E:  MOVWF  03
01C40:  MOVF   01,W
01C42:  ADDLW  BA
01C44:  MOVWF  FE9
01C46:  MOVLW  01
01C48:  ADDWFC 03,W
01C4A:  MOVWF  FEA
01C4C:  MOVFF  FEA,6A6
01C50:  MOVFF  FE9,6A5
01C54:  BCF    FD8.1
01C56:  MOVFF  691,6AA
01C5A:  MOVFF  690,6A9
01C5E:  MOVFF  68F,6A8
01C62:  MOVFF  68E,6A7
01C66:  CLRF   xAE
01C68:  CLRF   xAD
01C6A:  CLRF   xAC
01C6C:  MOVLW  03
01C6E:  MOVWF  xAB
01C70:  MOVLB  0
01C72:  RCALL  164A
01C74:  MOVFF  6A6,FEA
01C78:  MOVFF  6A5,FE9
01C7C:  MOVFF  00,FEF
01C80:  MOVFF  01,FEC
01C84:  MOVFF  02,FEC
01C88:  MOVFF  03,FEC
01C8C:  GOTO   44FC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
0441C:  MOVLB  6
0441E:  CLRF   x74
04420:  CLRF   x73
04422:  CLRF   x72
04424:  CLRF   x71
04426:  CLRF   x78
04428:  CLRF   x77
0442A:  CLRF   x76
0442C:  CLRF   x75
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
0442E:  MOVLB  1
04430:  MOVF   xCE,W
04432:  MULLW  09
04434:  MOVF   FF3,W
04436:  MOVLB  6
04438:  CLRF   x7A
0443A:  MOVWF  x79
0443C:  MOVLW  BA
0443E:  ADDWF  x79,W
04440:  MOVWF  FE9
04442:  MOVLW  01
04444:  ADDWFC x7A,W
04446:  MOVWF  FEA
04448:  BTFSC  FEF.1
0444A:  BRA    45C8
0444C:  MOVLB  1
0444E:  MOVF   xCE,W
04450:  MULLW  09
04452:  MOVF   FF3,W
04454:  MOVLB  6
04456:  CLRF   x7C
04458:  MOVWF  x7B
0445A:  MOVLW  BA
0445C:  ADDWF  x7B,W
0445E:  MOVWF  FE9
04460:  MOVLW  01
04462:  ADDWFC x7C,W
04464:  MOVWF  FEA
04466:  BTFSS  FEF.0
04468:  BRA    45C8
....................       smData[ch].adcBusy = true;
0446A:  MOVLB  1
0446C:  MOVF   xCE,W
0446E:  MULLW  09
04470:  MOVF   FF3,W
04472:  MOVLB  6
04474:  CLRF   x7A
04476:  MOVWF  x79
04478:  MOVLW  BA
0447A:  ADDWF  x79,W
0447C:  MOVWF  FE9
0447E:  MOVLW  01
04480:  ADDWFC x7A,W
04482:  MOVWF  FEA
04484:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04486:  BCF    FD8.0
04488:  MOVLB  1
0448A:  RLCF   xCE,W
0448C:  MOVLB  6
0448E:  MOVWF  x79
04490:  MOVWF  x7A
04492:  MOVLB  0
04494:  CALL   081C
04498:  MOVFF  03,674
0449C:  MOVFF  02,673
044A0:  MOVFF  01,672
044A4:  MOVFF  00,671
....................       cosNew = ads_read_data(ch*2+1);      
044A8:  BCF    FD8.0
044AA:  MOVLB  1
044AC:  RLCF   xCE,W
044AE:  ADDLW  01
044B0:  MOVLB  6
044B2:  MOVWF  x79
044B4:  MOVWF  x7A
044B6:  MOVLB  0
044B8:  CALL   081C
044BC:  MOVFF  03,678
044C0:  MOVFF  02,677
044C4:  MOVFF  01,676
044C8:  MOVFF  00,675
....................       
....................       if (adcFilter){
044CC:  MOVLB  1
044CE:  BTFSS  x49.0
044D0:  BRA    4500
....................          iqm_ring_buffer(ch, sinNew, cosNew);
044D2:  MOVFF  1CE,679
044D6:  MOVFF  674,67D
044DA:  MOVFF  673,67C
044DE:  MOVFF  672,67B
044E2:  MOVFF  671,67A
044E6:  MOVFF  678,681
044EA:  MOVFF  677,680
044EE:  MOVFF  676,67F
044F2:  MOVFF  675,67E
044F6:  MOVLB  0
044F8:  GOTO   1734
....................       }
044FC:  BRA    456C
044FE:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04500:  MOVF   xCE,W
04502:  MULLW  09
04504:  MOVF   FF3,W
04506:  MOVLB  6
04508:  CLRF   x7A
0450A:  MOVWF  x79
0450C:  MOVLW  01
0450E:  ADDWF  x79,W
04510:  MOVWF  01
04512:  MOVLW  00
04514:  ADDWFC x7A,W
04516:  MOVWF  03
04518:  MOVF   01,W
0451A:  ADDLW  BA
0451C:  MOVWF  FE9
0451E:  MOVLW  01
04520:  ADDWFC 03,W
04522:  MOVWF  FEA
04524:  MOVFF  671,FEF
04528:  MOVFF  672,FEC
0452C:  MOVFF  673,FEC
04530:  MOVFF  674,FEC
....................          smData[ch].avgCos = cosNew;
04534:  MOVLB  1
04536:  MOVF   xCE,W
04538:  MULLW  09
0453A:  MOVF   FF3,W
0453C:  MOVLB  6
0453E:  CLRF   x7A
04540:  MOVWF  x79
04542:  MOVLW  05
04544:  ADDWF  x79,W
04546:  MOVWF  01
04548:  MOVLW  00
0454A:  ADDWFC x7A,W
0454C:  MOVWF  03
0454E:  MOVF   01,W
04550:  ADDLW  BA
04552:  MOVWF  FE9
04554:  MOVLW  01
04556:  ADDWFC 03,W
04558:  MOVWF  FEA
0455A:  MOVFF  675,FEF
0455E:  MOVFF  676,FEC
04562:  MOVFF  677,FEC
04566:  MOVFF  678,FEC
0456A:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
0456C:  MOVFF  1CE,679
04570:  GOTO   36CA
....................       ch = !ch;
04574:  MOVLB  1
04576:  MOVF   xCE,F
04578:  BZ    457E
0457A:  MOVLW  00
0457C:  BRA    4580
0457E:  MOVLW  01
04580:  MOVWF  xCE
....................       
....................       smData[!ch].dataReady = false;
04582:  MOVF   xCE,F
04584:  BZ    458A
04586:  MOVLW  00
04588:  BRA    458C
0458A:  MOVLW  01
0458C:  MULLW  09
0458E:  MOVF   FF3,W
04590:  MOVLB  6
04592:  CLRF   x7A
04594:  MOVWF  x79
04596:  MOVLW  BA
04598:  ADDWF  x79,W
0459A:  MOVWF  FE9
0459C:  MOVLW  01
0459E:  ADDWFC x7A,W
045A0:  MOVWF  FEA
045A2:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045A4:  MOVLB  1
045A6:  MOVF   xCE,F
045A8:  BZ    45AE
045AA:  MOVLW  00
045AC:  BRA    45B0
045AE:  MOVLW  01
045B0:  MULLW  09
045B2:  MOVF   FF3,W
045B4:  MOVLB  6
045B6:  CLRF   x7A
045B8:  MOVWF  x79
045BA:  MOVLW  BA
045BC:  ADDWF  x79,W
045BE:  MOVWF  FE9
045C0:  MOVLW  01
045C2:  ADDWFC x7A,W
045C4:  MOVWF  FEA
045C6:  BCF    FEF.1
....................    }
045C8:  MOVLB  0
045CA:  GOTO   A636 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
0092A:  MOVLB  6
0092C:  CLRF   x71
0092E:  CLRF   x72
00930:  CLRF   x73
00932:  CLRF   x74
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00934:  CLRF   x75
00936:  MOVF   x75,W
00938:  SUBLW  03
0093A:  BNC   0970
....................       rc0=reg0config;
0093C:  MOVLW  30
0093E:  MOVWF  x71
....................       rc1=reg1config;
00940:  MOVLW  10
00942:  MOVWF  x72
....................       rc2=reg2config;
00944:  CLRF   x73
....................       rc3=reg3config;
00946:  CLRF   x74
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00948:  MOVFF  675,677
0094C:  MOVFF  671,678
00950:  MOVFF  672,679
00954:  MOVFF  673,67A
00958:  MOVFF  674,67B
0095C:  MOVLB  0
0095E:  BRA    074E
....................       delay_ms(100);
00960:  MOVLW  64
00962:  MOVLB  6
00964:  MOVWF  x77
00966:  MOVLB  0
00968:  RCALL  043A
0096A:  MOVLB  6
0096C:  INCF   x75,F
0096E:  BRA    0936
....................    }
....................    
....................    if (adcFilter){
00970:  MOVLB  1
00972:  BTFSS  x49.0
00974:  BRA    0A96
....................       for (int i = 0; i < BUFFER_SIZE; i++){
00976:  MOVLB  6
00978:  CLRF   x76
0097A:  MOVF   x76,W
0097C:  SUBLW  04
0097E:  BTFSS  FD8.0
00980:  BRA    0A94
....................          ads_start_conv_all();
00982:  MOVLB  0
00984:  BRA    07EC
....................          delay_ms(50);
00986:  MOVLW  32
00988:  MOVLB  6
0098A:  MOVWF  x77
0098C:  MOVLB  0
0098E:  RCALL  043A
....................          push(sQ_x, &sIn_x, ads_read_data(0));
00990:  MOVLB  6
00992:  CLRF   x7A
00994:  MOVLB  0
00996:  RCALL  081C
00998:  MOVFF  03,67A
0099C:  MOVFF  02,679
009A0:  MOVFF  01,678
009A4:  MOVFF  00,677
009A8:  MOVLW  01
009AA:  MOVLB  6
009AC:  MOVWF  xA4
009AE:  MOVLW  66
009B0:  MOVWF  xA3
009B2:  MOVLW  01
009B4:  MOVWF  xA6
009B6:  MOVLW  B6
009B8:  MOVWF  xA5
009BA:  MOVFF  03,6AA
009BE:  MOVFF  02,6A9
009C2:  MOVFF  01,6A8
009C6:  MOVFF  00,6A7
009CA:  MOVLB  0
009CC:  RCALL  08C4
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009CE:  MOVLW  01
009D0:  MOVLB  6
009D2:  MOVWF  x7A
009D4:  MOVLB  0
009D6:  RCALL  081C
009D8:  MOVFF  03,67A
009DC:  MOVFF  02,679
009E0:  MOVFF  01,678
009E4:  MOVFF  00,677
009E8:  MOVLW  01
009EA:  MOVLB  6
009EC:  MOVWF  xA4
009EE:  MOVLW  7A
009F0:  MOVWF  xA3
009F2:  MOVLW  01
009F4:  MOVWF  xA6
009F6:  MOVLW  B7
009F8:  MOVWF  xA5
009FA:  MOVFF  03,6AA
009FE:  MOVFF  02,6A9
00A02:  MOVFF  01,6A8
00A06:  MOVFF  00,6A7
00A0A:  MOVLB  0
00A0C:  RCALL  08C4
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A0E:  MOVLW  02
00A10:  MOVLB  6
00A12:  MOVWF  x7A
00A14:  MOVLB  0
00A16:  RCALL  081C
00A18:  MOVFF  03,67A
00A1C:  MOVFF  02,679
00A20:  MOVFF  01,678
00A24:  MOVFF  00,677
00A28:  MOVLW  01
00A2A:  MOVLB  6
00A2C:  MOVWF  xA4
00A2E:  MOVLW  8E
00A30:  MOVWF  xA3
00A32:  MOVLW  01
00A34:  MOVWF  xA6
00A36:  MOVLW  B8
00A38:  MOVWF  xA5
00A3A:  MOVFF  03,6AA
00A3E:  MOVFF  02,6A9
00A42:  MOVFF  01,6A8
00A46:  MOVFF  00,6A7
00A4A:  MOVLB  0
00A4C:  RCALL  08C4
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A4E:  MOVLW  03
00A50:  MOVLB  6
00A52:  MOVWF  x7A
00A54:  MOVLB  0
00A56:  RCALL  081C
00A58:  MOVFF  03,67A
00A5C:  MOVFF  02,679
00A60:  MOVFF  01,678
00A64:  MOVFF  00,677
00A68:  MOVLW  01
00A6A:  MOVLB  6
00A6C:  MOVWF  xA4
00A6E:  MOVLW  A2
00A70:  MOVWF  xA3
00A72:  MOVLW  01
00A74:  MOVWF  xA6
00A76:  MOVLW  B9
00A78:  MOVWF  xA5
00A7A:  MOVFF  03,6AA
00A7E:  MOVFF  02,6A9
00A82:  MOVFF  01,6A8
00A86:  MOVFF  00,6A7
00A8A:  MOVLB  0
00A8C:  RCALL  08C4
00A8E:  MOVLB  6
00A90:  INCF   x76,F
00A92:  BRA    097A
00A94:  MOVLB  1
....................       }
....................    }
00A96:  MOVLB  0
00A98:  GOTO   0AFC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00A9C:  MOVLW  00
00A9E:  MOVLB  F
00AA0:  MOVWF  x53
00AA2:  MOVLW  40
00AA4:  MOVWF  x0C
00AA6:  MOVLW  00
00AA8:  MOVWF  x14
00AAA:  MOVLW  03
00AAC:  MOVWF  x1C
00AAE:  MOVLW  0F
00AB0:  MOVWF  x21
00AB2:  MOVLW  00
00AB4:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AB6:  MOVLW  08
00AB8:  MOVWF  x55
00ABA:  CLRF   x56
00ABC:  CLRF   x52
00ABE:  SETF   x57
00AC0:  CLRF   F61
00AC2:  MOVLW  94
00AC4:  MOVWF  x5B
....................    output_high(EN_EXC);
00AC6:  MOVLW  E8
00AC8:  MOVWF  F8B
00ACA:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00ACC:  MOVF   x5A,W
00ACE:  ANDLW  3F
00AD0:  MOVWF  01
00AD2:  MOVLW  06
00AD4:  MOVWF  x5A
00AD6:  BTFSS  x5B.7
00AD8:  BRA    0AE8
00ADA:  MOVF   01,W
00ADC:  SUBLW  06
00ADE:  BZ    0AE8
00AE0:  BSF    x5B.0
00AE2:  NOP   
00AE4:  BTFSC  x5B.0
00AE6:  BRA    0AE4
....................    delay_ms(10);
00AE8:  MOVLW  0A
00AEA:  MOVLB  6
00AEC:  MOVWF  x77
00AEE:  MOVLB  0
00AF0:  RCALL  043A
....................    read_adc(ADC_START_ONLY);
00AF2:  MOVLB  F
00AF4:  BSF    x5B.0
00AF6:  NOP   
....................    setup_external_ADCs();
00AF8:  MOVLB  0
00AFA:  BRA    092A
....................    intTimeoutReg = sensorSampleRate;
00AFC:  MOVLB  1
00AFE:  CLRF   x65
00B00:  MOVLW  32
00B02:  MOVWF  x64
00B04:  MOVLB  0
00B06:  GOTO   A61E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046A8:  MOVLB  6
046AA:  MOVF   x75,W
046AC:  MULLW  20
046AE:  MOVF   FF3,W
046B0:  CLRF   x83
046B2:  MOVWF  x82
046B4:  MOVLW  0C
046B6:  ADDWF  x82,W
046B8:  MOVWF  01
046BA:  MOVLW  00
046BC:  ADDWFC x83,W
046BE:  MOVWF  03
046C0:  MOVF   01,W
046C2:  ADDLW  20
046C4:  MOVWF  FE9
046C6:  MOVLW  00
046C8:  ADDWFC 03,W
046CA:  MOVWF  FEA
046CC:  MOVFF  FEF,6C0
046D0:  MOVFF  FEC,6C1
046D4:  MOVFF  FEC,6C2
046D8:  MOVFF  FEC,6C3
046DC:  MOVF   x75,W
046DE:  MULLW  20
046E0:  MOVF   FF3,W
046E2:  CLRF   x87
046E4:  MOVWF  x86
046E6:  MOVLW  10
046E8:  ADDWF  x86,W
046EA:  MOVWF  01
046EC:  MOVLW  00
046EE:  ADDWFC x87,W
046F0:  MOVWF  03
046F2:  MOVF   01,W
046F4:  ADDLW  20
046F6:  MOVWF  FE9
046F8:  MOVLW  00
046FA:  ADDWFC 03,W
046FC:  MOVWF  FEA
046FE:  MOVFF  FEF,6C4
04702:  MOVFF  FEC,01
04706:  MOVFF  FEC,02
0470A:  MOVFF  FEC,03
0470E:  MOVFF  FEA,687
04712:  MOVFF  FE9,686
04716:  BSF    FD8.1
04718:  MOVFF  03,6C7
0471C:  MOVFF  02,6C6
04720:  MOVFF  01,6C5
04724:  MOVLB  0
04726:  CALL   0E54
0472A:  MOVFF  687,FEA
0472E:  MOVFF  686,FE9
04732:  MOVFF  03,679
04736:  MOVFF  02,678
0473A:  MOVFF  01,677
0473E:  MOVFF  00,676
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
04742:  MOVLB  6
04744:  MOVF   x75,W
04746:  MULLW  20
04748:  MOVF   FF3,W
0474A:  CLRF   x83
0474C:  MOVWF  x82
0474E:  MOVLW  1C
04750:  ADDWF  x82,W
04752:  MOVWF  01
04754:  MOVLW  00
04756:  ADDWFC x83,W
04758:  MOVWF  03
0475A:  MOVF   01,W
0475C:  ADDLW  20
0475E:  MOVWF  01
04760:  MOVLW  00
04762:  ADDWFC 03,F
04764:  MOVFF  01,682
04768:  MOVFF  03,683
0476C:  MOVFF  03,FEA
04770:  MOVFF  01,FE9
04774:  MOVFF  FEF,684
04778:  MOVFF  FEC,685
0477C:  MOVFF  FEC,686
04780:  MOVFF  FEC,687
04784:  MOVF   x75,W
04786:  MULLW  20
04788:  MOVF   FF3,W
0478A:  CLRF   x89
0478C:  MOVWF  x88
0478E:  MOVLW  04
04790:  ADDWF  x88,W
04792:  MOVWF  01
04794:  MOVLW  00
04796:  ADDWFC x89,W
04798:  MOVWF  03
0479A:  MOVF   01,W
0479C:  ADDLW  20
0479E:  MOVWF  FE9
047A0:  MOVLW  00
047A2:  ADDWFC 03,W
047A4:  MOVWF  FEA
047A6:  MOVFF  FEF,6C5
047AA:  MOVFF  FEC,01
047AE:  MOVFF  FEC,02
047B2:  MOVFF  FEC,03
047B6:  MOVFF  679,6C4
047BA:  MOVFF  678,6C3
047BE:  MOVFF  677,6C2
047C2:  MOVFF  676,6C1
047C6:  MOVFF  03,6C8
047CA:  MOVFF  02,6C7
047CE:  MOVFF  01,6C6
047D2:  MOVLB  0
047D4:  CALL   0D5E
047D8:  BCF    FD8.1
047DA:  MOVFF  687,6C3
047DE:  MOVFF  686,6C2
047E2:  MOVFF  685,6C1
047E6:  MOVFF  684,6C0
047EA:  MOVFF  03,6C7
047EE:  MOVFF  02,6C6
047F2:  MOVFF  01,6C5
047F6:  MOVFF  00,6C4
047FA:  CALL   0E54
047FE:  MOVFF  683,FEA
04802:  MOVFF  682,FE9
04806:  MOVFF  00,FEF
0480A:  MOVFF  01,FEC
0480E:  MOVFF  02,FEC
04812:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
04816:  MOVLB  6
04818:  MOVF   x75,W
0481A:  MULLW  20
0481C:  MOVF   FF3,W
0481E:  CLRF   x83
04820:  MOVWF  x82
04822:  MOVLW  1C
04824:  ADDWF  x82,W
04826:  MOVWF  01
04828:  MOVLW  00
0482A:  ADDWFC x83,W
0482C:  MOVWF  03
0482E:  MOVF   01,W
04830:  ADDLW  20
04832:  MOVWF  FE9
04834:  MOVLW  00
04836:  ADDWFC 03,W
04838:  MOVWF  FEA
0483A:  MOVFF  FEF,6C0
0483E:  MOVFF  FEC,683
04842:  MOVFF  FEC,6C2
04846:  MOVFF  FEC,6C3
0484A:  CLRF   xBF
0484C:  CLRF   xBE
0484E:  MOVLW  7C
04850:  MOVWF  xBD
04852:  MOVLW  84
04854:  MOVWF  xBC
04856:  MOVFF  683,6C1
0485A:  MOVLB  0
0485C:  CALL   1CEA
04860:  BNC   4894
04862:  MOVLB  6
04864:  MOVF   x75,W
04866:  MULLW  20
04868:  MOVF   FF3,W
0486A:  CLRF   x83
0486C:  MOVWF  x82
0486E:  MOVLW  1C
04870:  ADDWF  x82,W
04872:  MOVWF  01
04874:  MOVLW  00
04876:  ADDWFC x83,W
04878:  MOVWF  03
0487A:  MOVF   01,W
0487C:  ADDLW  20
0487E:  MOVWF  FE9
04880:  MOVLW  00
04882:  ADDWFC 03,W
04884:  MOVWF  FEA
04886:  MOVLW  84
04888:  MOVWF  FEF
0488A:  MOVLW  7C
0488C:  MOVWF  FEC
0488E:  CLRF   FEC
04890:  CLRF   FEC
04892:  BRA    4910
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
04894:  MOVLB  6
04896:  MOVF   x75,W
04898:  MULLW  20
0489A:  MOVF   FF3,W
0489C:  CLRF   x83
0489E:  MOVWF  x82
048A0:  MOVLW  1C
048A2:  ADDWF  x82,W
048A4:  MOVWF  01
048A6:  MOVLW  00
048A8:  ADDWFC x83,W
048AA:  MOVWF  03
048AC:  MOVF   01,W
048AE:  ADDLW  20
048B0:  MOVWF  FE9
048B2:  MOVLW  00
048B4:  ADDWFC 03,W
048B6:  MOVWF  FEA
048B8:  MOVFF  FEF,6BC
048BC:  MOVFF  FEC,683
048C0:  MOVFF  FEC,6BE
048C4:  MOVFF  FEC,6BF
048C8:  MOVFF  683,6BD
048CC:  CLRF   xC3
048CE:  CLRF   xC2
048D0:  MOVLW  FC
048D2:  MOVWF  xC1
048D4:  MOVLW  84
048D6:  MOVWF  xC0
048D8:  MOVLB  0
048DA:  CALL   1CEA
048DE:  BNC   4912
048E0:  MOVLB  6
048E2:  MOVF   x75,W
048E4:  MULLW  20
048E6:  MOVF   FF3,W
048E8:  CLRF   x83
048EA:  MOVWF  x82
048EC:  MOVLW  1C
048EE:  ADDWF  x82,W
048F0:  MOVWF  01
048F2:  MOVLW  00
048F4:  ADDWFC x83,W
048F6:  MOVWF  03
048F8:  MOVF   01,W
048FA:  ADDLW  20
048FC:  MOVWF  FE9
048FE:  MOVLW  00
04900:  ADDWFC 03,W
04902:  MOVWF  FEA
04904:  MOVLW  84
04906:  MOVWF  FEF
04908:  MOVLW  FC
0490A:  MOVWF  FEC
0490C:  CLRF   FEC
0490E:  CLRF   FEC
04910:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04912:  MOVLB  6
04914:  MOVF   x75,W
04916:  MULLW  20
04918:  MOVF   FF3,W
0491A:  CLRF   x83
0491C:  MOVWF  x82
0491E:  MOVLW  20
04920:  ADDWF  x82,W
04922:  MOVWF  FE9
04924:  MOVLW  00
04926:  ADDWFC x83,W
04928:  MOVWF  FEA
0492A:  MOVFF  FEF,6C5
0492E:  MOVFF  FEC,01
04932:  MOVFF  FEC,02
04936:  MOVFF  FEC,03
0493A:  MOVFF  679,6C4
0493E:  MOVFF  678,6C3
04942:  MOVFF  677,6C2
04946:  MOVFF  676,6C1
0494A:  MOVFF  03,6C8
0494E:  MOVFF  02,6C7
04952:  MOVFF  01,6C6
04956:  MOVLB  0
04958:  CALL   0D5E
0495C:  MOVFF  03,67D
04960:  MOVFF  02,67C
04964:  MOVFF  01,67B
04968:  MOVFF  00,67A
0496C:  MOVLB  6
0496E:  MOVF   x75,W
04970:  MULLW  20
04972:  MOVF   FF3,W
04974:  CLRF   x85
04976:  MOVWF  x84
04978:  MOVLW  08
0497A:  ADDWF  x84,W
0497C:  MOVWF  01
0497E:  MOVLW  00
04980:  ADDWFC x85,W
04982:  MOVWF  03
04984:  MOVF   01,W
04986:  ADDLW  20
04988:  MOVWF  FE9
0498A:  MOVLW  00
0498C:  ADDWFC 03,W
0498E:  MOVWF  FEA
04990:  MOVFF  FEF,684
04994:  MOVFF  FEC,685
04998:  MOVFF  FEC,686
0499C:  MOVFF  FEC,687
049A0:  MOVF   x75,W
049A2:  MULLW  20
049A4:  MOVF   FF3,W
049A6:  CLRF   x89
049A8:  MOVWF  x88
049AA:  MOVLW  10
049AC:  ADDWF  x88,W
049AE:  MOVWF  01
049B0:  MOVLW  00
049B2:  ADDWFC x89,W
049B4:  MOVWF  03
049B6:  MOVF   01,W
049B8:  ADDLW  20
049BA:  MOVWF  FE9
049BC:  MOVLW  00
049BE:  ADDWFC 03,W
049C0:  MOVWF  FEA
049C2:  MOVFF  FEF,6C0
049C6:  MOVFF  FEC,6C1
049CA:  MOVFF  FEC,6C2
049CE:  MOVFF  FEC,6C3
049D2:  MOVF   x75,W
049D4:  MULLW  20
049D6:  MOVF   FF3,W
049D8:  CLRF   x8D
049DA:  MOVWF  x8C
049DC:  MOVLW  14
049DE:  ADDWF  x8C,W
049E0:  MOVWF  01
049E2:  MOVLW  00
049E4:  ADDWFC x8D,W
049E6:  MOVWF  03
049E8:  MOVF   01,W
049EA:  ADDLW  20
049EC:  MOVWF  FE9
049EE:  MOVLW  00
049F0:  ADDWFC 03,W
049F2:  MOVWF  FEA
049F4:  MOVFF  FEF,6C4
049F8:  MOVFF  FEC,01
049FC:  MOVFF  FEC,02
04A00:  MOVFF  FEC,03
04A04:  MOVFF  FEA,68D
04A08:  MOVFF  FE9,68C
04A0C:  BSF    FD8.1
04A0E:  MOVFF  03,6C7
04A12:  MOVFF  02,6C6
04A16:  MOVFF  01,6C5
04A1A:  MOVLB  0
04A1C:  CALL   0E54
04A20:  MOVFF  68D,FEA
04A24:  MOVFF  68C,FE9
04A28:  MOVFF  687,6C4
04A2C:  MOVFF  686,6C3
04A30:  MOVFF  685,6C2
04A34:  MOVFF  684,6C1
04A38:  MOVFF  03,6C8
04A3C:  MOVFF  02,6C7
04A40:  MOVFF  01,6C6
04A44:  MOVFF  00,6C5
04A48:  CALL   0D5E
04A4C:  MOVFF  03,681
04A50:  MOVFF  02,680
04A54:  MOVFF  01,67F
04A58:  MOVFF  00,67E
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A5C:  MOVLB  6
04A5E:  MOVF   x75,W
04A60:  MULLW  20
04A62:  MOVF   FF3,W
04A64:  CLRF   x83
04A66:  MOVWF  x82
04A68:  MOVLW  18
04A6A:  ADDWF  x82,W
04A6C:  MOVWF  01
04A6E:  MOVLW  00
04A70:  ADDWFC x83,W
04A72:  MOVWF  03
04A74:  MOVF   01,W
04A76:  ADDLW  20
04A78:  MOVWF  01
04A7A:  MOVLW  00
04A7C:  ADDWFC 03,F
04A7E:  MOVFF  01,682
04A82:  MOVFF  03,683
04A86:  MOVF   x75,W
04A88:  MULLW  20
04A8A:  MOVF   FF3,W
04A8C:  CLRF   x85
04A8E:  MOVWF  x84
04A90:  MOVLW  1C
04A92:  ADDWF  x84,W
04A94:  MOVWF  01
04A96:  MOVLW  00
04A98:  ADDWFC x85,W
04A9A:  MOVWF  03
04A9C:  MOVF   01,W
04A9E:  ADDLW  20
04AA0:  MOVWF  FE9
04AA2:  MOVLW  00
04AA4:  ADDWFC 03,W
04AA6:  MOVWF  FEA
04AA8:  MOVFF  FEF,6C4
04AAC:  MOVFF  FEC,01
04AB0:  MOVFF  FEC,02
04AB4:  MOVFF  FEC,03
04AB8:  MOVFF  FEA,685
04ABC:  MOVFF  FE9,684
04AC0:  BCF    FD8.1
04AC2:  MOVFF  67D,6C3
04AC6:  MOVFF  67C,6C2
04ACA:  MOVFF  67B,6C1
04ACE:  MOVFF  67A,6C0
04AD2:  MOVFF  03,6C7
04AD6:  MOVFF  02,6C6
04ADA:  MOVFF  01,6C5
04ADE:  MOVLB  0
04AE0:  CALL   0E54
04AE4:  MOVFF  685,FEA
04AE8:  MOVFF  684,FE9
04AEC:  MOVFF  03,689
04AF0:  MOVFF  02,688
04AF4:  MOVFF  01,687
04AF8:  MOVFF  00,686
04AFC:  BCF    FD8.1
04AFE:  MOVFF  03,6C3
04B02:  MOVFF  02,6C2
04B06:  MOVFF  01,6C1
04B0A:  MOVFF  00,6C0
04B0E:  MOVFF  681,6C7
04B12:  MOVFF  680,6C6
04B16:  MOVFF  67F,6C5
04B1A:  MOVFF  67E,6C4
04B1E:  CALL   0E54
04B22:  MOVFF  683,FEA
04B26:  MOVFF  682,FE9
04B2A:  MOVFF  00,FEF
04B2E:  MOVFF  01,FEC
04B32:  MOVFF  02,FEC
04B36:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B3A:  MOVLB  6
04B3C:  MOVF   x75,W
04B3E:  MULLW  20
04B40:  MOVF   FF3,W
04B42:  CLRF   x83
04B44:  MOVWF  x82
04B46:  MOVLW  18
04B48:  ADDWF  x82,W
04B4A:  MOVWF  01
04B4C:  MOVLW  00
04B4E:  ADDWFC x83,W
04B50:  MOVWF  03
04B52:  MOVF   01,W
04B54:  ADDLW  20
04B56:  MOVWF  FE9
04B58:  MOVLW  00
04B5A:  ADDWFC 03,W
04B5C:  MOVWF  FEA
04B5E:  MOVFF  FEF,6C0
04B62:  MOVFF  FEC,683
04B66:  MOVFF  FEC,6C2
04B6A:  MOVFF  FEC,6C3
04B6E:  CLRF   xBF
04B70:  CLRF   xBE
04B72:  MOVLW  7C
04B74:  MOVWF  xBD
04B76:  MOVLW  84
04B78:  MOVWF  xBC
04B7A:  MOVFF  683,6C1
04B7E:  MOVLB  0
04B80:  CALL   1CEA
04B84:  BNC   4BB8
04B86:  MOVLB  6
04B88:  MOVF   x75,W
04B8A:  MULLW  20
04B8C:  MOVF   FF3,W
04B8E:  CLRF   x83
04B90:  MOVWF  x82
04B92:  MOVLW  18
04B94:  ADDWF  x82,W
04B96:  MOVWF  01
04B98:  MOVLW  00
04B9A:  ADDWFC x83,W
04B9C:  MOVWF  03
04B9E:  MOVF   01,W
04BA0:  ADDLW  20
04BA2:  MOVWF  FE9
04BA4:  MOVLW  00
04BA6:  ADDWFC 03,W
04BA8:  MOVWF  FEA
04BAA:  MOVLW  84
04BAC:  MOVWF  FEF
04BAE:  MOVLW  7C
04BB0:  MOVWF  FEC
04BB2:  CLRF   FEC
04BB4:  CLRF   FEC
04BB6:  BRA    4C34
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BB8:  MOVLB  6
04BBA:  MOVF   x75,W
04BBC:  MULLW  20
04BBE:  MOVF   FF3,W
04BC0:  CLRF   x83
04BC2:  MOVWF  x82
04BC4:  MOVLW  18
04BC6:  ADDWF  x82,W
04BC8:  MOVWF  01
04BCA:  MOVLW  00
04BCC:  ADDWFC x83,W
04BCE:  MOVWF  03
04BD0:  MOVF   01,W
04BD2:  ADDLW  20
04BD4:  MOVWF  FE9
04BD6:  MOVLW  00
04BD8:  ADDWFC 03,W
04BDA:  MOVWF  FEA
04BDC:  MOVFF  FEF,6BC
04BE0:  MOVFF  FEC,683
04BE4:  MOVFF  FEC,6BE
04BE8:  MOVFF  FEC,6BF
04BEC:  MOVFF  683,6BD
04BF0:  CLRF   xC3
04BF2:  CLRF   xC2
04BF4:  MOVLW  FC
04BF6:  MOVWF  xC1
04BF8:  MOVLW  84
04BFA:  MOVWF  xC0
04BFC:  MOVLB  0
04BFE:  CALL   1CEA
04C02:  BNC   4C34
04C04:  MOVLB  6
04C06:  MOVF   x75,W
04C08:  MULLW  20
04C0A:  MOVF   FF3,W
04C0C:  CLRF   x83
04C0E:  MOVWF  x82
04C10:  MOVLW  18
04C12:  ADDWF  x82,W
04C14:  MOVWF  01
04C16:  MOVLW  00
04C18:  ADDWFC x83,W
04C1A:  MOVWF  03
04C1C:  MOVF   01,W
04C1E:  ADDLW  20
04C20:  MOVWF  FE9
04C22:  MOVLW  00
04C24:  ADDWFC 03,W
04C26:  MOVWF  FEA
04C28:  MOVLW  84
04C2A:  MOVWF  FEF
04C2C:  MOVLW  FC
04C2E:  MOVWF  FEC
04C30:  CLRF   FEC
04C32:  CLRF   FEC
04C34:  MOVLB  0
04C36:  GOTO   4CAE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C3A:  MOVLB  6
04C3C:  MOVF   x74,W
04C3E:  MULLW  20
04C40:  MOVF   FF3,W
04C42:  CLRF   x76
04C44:  MOVWF  x75
04C46:  MOVLW  0C
04C48:  ADDWF  x75,W
04C4A:  MOVWF  01
04C4C:  MOVLW  00
04C4E:  ADDWFC x76,W
04C50:  MOVWF  03
04C52:  MOVF   01,W
04C54:  ADDLW  20
04C56:  MOVWF  FE9
04C58:  MOVLW  00
04C5A:  ADDWFC 03,W
04C5C:  MOVWF  FEA
04C5E:  MOVFF  FEF,6BC
04C62:  MOVFF  FEC,6BD
04C66:  MOVFF  FEC,6BE
04C6A:  MOVFF  FEC,6BF
04C6E:  MOVF   x74,W
04C70:  MULLW  20
04C72:  MOVF   FF3,W
04C74:  CLRF   x7A
04C76:  MOVWF  x79
04C78:  MOVLW  10
04C7A:  ADDWF  x79,W
04C7C:  MOVWF  01
04C7E:  MOVLW  00
04C80:  ADDWFC x7A,W
04C82:  MOVWF  03
04C84:  MOVF   01,W
04C86:  ADDLW  20
04C88:  MOVWF  FE9
04C8A:  MOVLW  00
04C8C:  ADDWFC 03,W
04C8E:  MOVWF  FEA
04C90:  MOVFF  FEF,6C0
04C94:  MOVFF  FEC,6C1
04C98:  MOVFF  FEC,6C2
04C9C:  MOVFF  FEC,6C3
04CA0:  MOVLB  0
04CA2:  CALL   1CEA
04CA6:  BZ    4CAE
04CA8:  MOVFF  674,675
04CAC:  BRA    46A8
....................    if ((index++) >= numChannels) index = 0;
04CAE:  MOVLB  1
04CB0:  MOVF   xCF,W
04CB2:  INCF   xCF,F
04CB4:  SUBLW  01
04CB6:  BC    4CBA
04CB8:  CLRF   xCF
04CBA:  MOVLB  0
04CBC:  GOTO   4DA8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B0A:  CLRF   03
00B0C:  MOVF   F91,W
00B0E:  MOVFF  676,F91
00B12:  RRCF   F94,W
00B14:  BNC   0B12
00B16:  MOVF   F91,W
00B18:  MOVWF  02
00B1A:  MOVFF  675,F91
00B1E:  RRCF   F94,W
00B20:  BNC   0B1E
00B22:  MOVF   F91,W
00B24:  MOVWF  01
00B26:  MOVFF  674,F91
00B2A:  RRCF   F94,W
00B2C:  BNC   0B2A
00B2E:  MOVFF  F91,00
00B32:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04604:  MOVLB  6
04606:  MOVF   x75,F
04608:  BZ    4658
....................       if (chMap[0] == ch) output_low(INV_HVX);
0460A:  MOVLW  00
0460C:  MOVLB  0
0460E:  BTFSC  x60.0
04610:  MOVLW  01
04612:  MOVLB  6
04614:  SUBWF  x74,W
04616:  BNZ   461E
04618:  MOVLW  C4
0461A:  MOVWF  F88
0461C:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0461E:  MOVLW  00
04620:  MOVLB  0
04622:  BTFSC  x60.1
04624:  MOVLW  01
04626:  MOVLB  6
04628:  SUBWF  x74,W
0462A:  BNZ   4632
0462C:  MOVLW  C4
0462E:  MOVWF  F88
04630:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04632:  MOVF   x74,W
04634:  MULLW  03
04636:  MOVF   FF3,W
04638:  CLRF   x77
0463A:  MOVWF  x76
0463C:  MOVLW  02
0463E:  ADDWF  x76,W
04640:  MOVWF  01
04642:  MOVLW  00
04644:  ADDWFC x77,W
04646:  MOVWF  03
04648:  MOVF   01,W
0464A:  ADDLW  4A
0464C:  MOVWF  FE9
0464E:  MOVLW  01
04650:  ADDWFC 03,W
04652:  MOVWF  FEA
04654:  BSF    FEF.0
....................    }
04656:  BRA    46A4
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
04658:  MOVLW  00
0465A:  MOVLB  0
0465C:  BTFSC  x60.0
0465E:  MOVLW  01
04660:  MOVLB  6
04662:  SUBWF  x74,W
04664:  BNZ   466C
04666:  MOVLW  C4
04668:  MOVWF  F88
0466A:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
0466C:  MOVLW  00
0466E:  MOVLB  0
04670:  BTFSC  x60.1
04672:  MOVLW  01
04674:  MOVLB  6
04676:  SUBWF  x74,W
04678:  BNZ   4680
0467A:  MOVLW  C4
0467C:  MOVWF  F88
0467E:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
04680:  MOVF   x74,W
04682:  MULLW  03
04684:  MOVF   FF3,W
04686:  CLRF   x77
04688:  MOVWF  x76
0468A:  MOVLW  02
0468C:  ADDWF  x76,W
0468E:  MOVWF  01
04690:  MOVLW  00
04692:  ADDWFC x77,W
04694:  MOVWF  03
04696:  MOVF   01,W
04698:  ADDLW  4A
0469A:  MOVWF  FE9
0469C:  MOVLW  01
0469E:  ADDWFC 03,W
046A0:  MOVWF  FEA
046A2:  BCF    FEF.0
....................    }
046A4:  MOVLB  0
046A6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04CC0:  MOVLB  6
04CC2:  CLRF   x73
04CC4:  CLRF   x72
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04CC6:  MOVFF  671,67E
04CCA:  CLRF   x80
04CCC:  MOVLW  61
04CCE:  MOVWF  x7F
04CD0:  MOVLB  0
04CD2:  RCALL  45CE
04CD4:  MOVF   01,F
04CD6:  BNZ   4DA2
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04CD8:  MOVLB  6
04CDA:  MOVF   x71,W
04CDC:  MULLW  04
04CDE:  MOVF   FF3,W
04CE0:  CLRF   03
04CE2:  ADDLW  50
04CE4:  MOVWF  FE9
04CE6:  MOVLW  01
04CE8:  ADDWFC 03,W
04CEA:  MOVWF  FEA
04CEC:  MOVFF  FEF,6BC
04CF0:  MOVFF  FEC,6BD
04CF4:  MOVFF  FEC,6BE
04CF8:  MOVFF  FEC,6BF
04CFC:  CLRF   xC3
04CFE:  CLRF   xC2
04D00:  CLRF   xC1
04D02:  CLRF   xC0
04D04:  MOVLB  0
04D06:  CALL   1CEA
04D0A:  BNC   4D1C
04D0C:  MOVFF  671,674
04D10:  MOVLW  01
04D12:  MOVLB  6
04D14:  MOVWF  x75
04D16:  MOVLB  0
04D18:  RCALL  4604
04D1A:  BRA    4D28
....................       else                             invert_voltage(ch, FALSE);
04D1C:  MOVFF  671,674
04D20:  MOVLB  6
04D22:  CLRF   x75
04D24:  MOVLB  0
04D26:  RCALL  4604
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04D28:  MOVLB  6
04D2A:  MOVF   x71,W
04D2C:  MULLW  04
04D2E:  MOVF   FF3,W
04D30:  CLRF   03
04D32:  ADDLW  50
04D34:  MOVWF  FE9
04D36:  MOVLW  01
04D38:  ADDWFC 03,W
04D3A:  MOVWF  FEA
04D3C:  MOVFF  FEF,00
04D40:  MOVFF  FEC,01
04D44:  MOVFF  FEC,02
04D48:  MOVFF  FEC,03
04D4C:  BCF    01.7
04D4E:  MOVFF  03,677
04D52:  MOVFF  02,676
04D56:  MOVFF  01,675
04D5A:  MOVFF  00,674
04D5E:  MOVFF  03,6C4
04D62:  MOVFF  02,6C3
04D66:  MOVFF  01,6C2
04D6A:  MOVFF  00,6C1
04D6E:  MOVLW  66
04D70:  MOVWF  xC8
04D72:  MOVLW  D6
04D74:  MOVWF  xC7
04D76:  MOVLW  23
04D78:  MOVWF  xC6
04D7A:  MOVLW  88
04D7C:  MOVWF  xC5
04D7E:  MOVLB  0
04D80:  CALL   0D5E
04D84:  MOVFF  03,6BF
04D88:  MOVFF  02,6BE
04D8C:  MOVFF  01,6BD
04D90:  MOVFF  00,6BC
04D94:  CALL   26DE
04D98:  MOVFF  02,673
04D9C:  MOVFF  01,672
....................    }
04DA0:  BRA    4E92
....................    else {
....................       pid_task(ch);
04DA2:  MOVFF  671,674
04DA6:  BRA    4C3A
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04DA8:  MOVLB  6
04DAA:  MOVF   x71,W
04DAC:  MULLW  20
04DAE:  MOVF   FF3,W
04DB0:  CLRF   x75
04DB2:  MOVWF  x74
04DB4:  MOVLW  18
04DB6:  ADDWF  x74,W
04DB8:  MOVWF  01
04DBA:  MOVLW  00
04DBC:  ADDWFC x75,W
04DBE:  MOVWF  03
04DC0:  MOVF   01,W
04DC2:  ADDLW  20
04DC4:  MOVWF  FE9
04DC6:  MOVLW  00
04DC8:  ADDWFC 03,W
04DCA:  MOVWF  FEA
04DCC:  MOVFF  FEF,6BC
04DD0:  MOVFF  FEC,6BD
04DD4:  MOVFF  FEC,6BE
04DD8:  MOVFF  FEC,6BF
04DDC:  CLRF   xC3
04DDE:  CLRF   xC2
04DE0:  CLRF   xC1
04DE2:  CLRF   xC0
04DE4:  MOVLB  0
04DE6:  CALL   1CEA
04DEA:  BNC   4DFC
04DEC:  MOVFF  671,674
04DF0:  MOVLW  01
04DF2:  MOVLB  6
04DF4:  MOVWF  x75
04DF6:  MOVLB  0
04DF8:  RCALL  4604
04DFA:  BRA    4E0A
....................       else                       invert_voltage(ch, FALSE);
04DFC:  MOVFF  671,674
04E00:  MOVLB  6
04E02:  CLRF   x75
04E04:  MOVLB  0
04E06:  CALL   4604
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E0A:  MOVLB  6
04E0C:  MOVF   x71,W
04E0E:  MULLW  20
04E10:  MOVF   FF3,W
04E12:  CLRF   x75
04E14:  MOVWF  x74
04E16:  MOVLW  18
04E18:  ADDWF  x74,W
04E1A:  MOVWF  01
04E1C:  MOVLW  00
04E1E:  ADDWFC x75,W
04E20:  MOVWF  03
04E22:  MOVF   01,W
04E24:  ADDLW  20
04E26:  MOVWF  FE9
04E28:  MOVLW  00
04E2A:  ADDWFC 03,W
04E2C:  MOVWF  FEA
04E2E:  MOVFF  FEF,00
04E32:  MOVFF  FEC,01
04E36:  MOVFF  FEC,02
04E3A:  MOVFF  FEC,03
04E3E:  BCF    01.7
04E40:  MOVFF  03,677
04E44:  MOVFF  02,676
04E48:  MOVFF  01,675
04E4C:  MOVFF  00,674
04E50:  MOVFF  03,6C4
04E54:  MOVFF  02,6C3
04E58:  MOVFF  01,6C2
04E5C:  MOVFF  00,6C1
04E60:  MOVLW  66
04E62:  MOVWF  xC8
04E64:  MOVLW  D6
04E66:  MOVWF  xC7
04E68:  MOVLW  23
04E6A:  MOVWF  xC6
04E6C:  MOVLW  88
04E6E:  MOVWF  xC5
04E70:  MOVLB  0
04E72:  CALL   0D5E
04E76:  MOVFF  03,6BF
04E7A:  MOVFF  02,6BE
04E7E:  MOVFF  01,6BD
04E82:  MOVFF  00,6BC
04E86:  CALL   26DE
04E8A:  MOVFF  02,673
04E8E:  MOVFF  01,672
....................    }
....................    
....................    dacVals[ch].val = txData;
04E92:  MOVLB  6
04E94:  MOVF   x71,W
04E96:  MULLW  03
04E98:  MOVF   FF3,W
04E9A:  CLRF   x75
04E9C:  MOVWF  x74
04E9E:  MOVLW  4A
04EA0:  ADDWF  x74,W
04EA2:  MOVWF  FE9
04EA4:  MOVLW  01
04EA6:  ADDWFC x75,W
04EA8:  MOVWF  FEA
04EAA:  MOVFF  673,FEC
04EAE:  MOVF   FED,F
04EB0:  MOVFF  672,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04EB4:  MOVLW  00
04EB6:  MOVLB  0
04EB8:  BTFSC  x60.0
04EBA:  MOVLW  01
04EBC:  MOVLB  6
04EBE:  SUBWF  x71,W
04EC0:  BNZ   4EC8
04EC2:  MOVLW  E8
04EC4:  MOVWF  F8B
04EC6:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04EC8:  MOVLW  00
04ECA:  MOVLB  0
04ECC:  BTFSC  x60.1
04ECE:  MOVLW  01
04ED0:  MOVLB  6
04ED2:  SUBWF  x71,W
04ED4:  BNZ   4EDC
04ED6:  MOVLW  E8
04ED8:  MOVWF  F8B
04EDA:  BSF    F86.1
....................    
....................    delay_ms(1);
04EDC:  MOVLW  01
04EDE:  MOVWF  x77
04EE0:  MOVLB  0
04EE2:  CALL   043A
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04EE6:  MOVLW  00
04EE8:  BTFSC  x60.0
04EEA:  MOVLW  01
04EEC:  MOVLB  6
04EEE:  SUBWF  x71,W
04EF0:  BNZ   4EF8
04EF2:  MOVLW  E8
04EF4:  MOVWF  F8B
04EF6:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04EF8:  MOVLW  00
04EFA:  MOVLB  0
04EFC:  BTFSC  x60.1
04EFE:  MOVLW  01
04F00:  MOVLB  6
04F02:  SUBWF  x71,W
04F04:  BNZ   4F0C
04F06:  MOVLW  E8
04F08:  MOVWF  F8B
04F0A:  BCF    F86.1
....................    delay_ms(1);
04F0C:  MOVLW  01
04F0E:  MOVWF  x77
04F10:  MOVLB  0
04F12:  CALL   043A
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04F16:  MOVLB  6
04F18:  CLRF   x77
04F1A:  CLRF   x76
04F1C:  MOVFF  673,675
04F20:  MOVFF  672,674
04F24:  MOVLB  0
04F26:  CALL   0B0A
....................    delay_ms(1);
04F2A:  MOVLW  01
04F2C:  MOVLB  6
04F2E:  MOVWF  x77
04F30:  MOVLB  0
04F32:  CALL   043A
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04F36:  MOVLW  00
04F38:  BTFSC  x60.0
04F3A:  MOVLW  01
04F3C:  MOVLB  6
04F3E:  SUBWF  x71,W
04F40:  BNZ   4F48
04F42:  MOVLW  E8
04F44:  MOVWF  F8B
04F46:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04F48:  MOVLW  00
04F4A:  MOVLB  0
04F4C:  BTFSC  x60.1
04F4E:  MOVLW  01
04F50:  MOVLB  6
04F52:  SUBWF  x71,W
04F54:  BNZ   4F5C
04F56:  MOVLW  E8
04F58:  MOVWF  F8B
04F5A:  BSF    F86.1
04F5C:  MOVLB  0
04F5E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04F60:  MOVLB  1
04F62:  MOVF   xD0,W
04F64:  XORLW  00
04F66:  MOVLB  0
04F68:  BZ    4F70
04F6A:  XORLW  01
04F6C:  BZ    4F82
04F6E:  BRA    4F92
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04F70:  MOVLB  6
04F72:  CLRF   x71
04F74:  MOVLB  0
04F76:  RCALL  4CC0
....................          state = 1;
04F78:  MOVLW  01
04F7A:  MOVLB  1
04F7C:  MOVWF  xD0
....................       break;
04F7E:  MOVLB  0
04F80:  BRA    4F92
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04F82:  MOVLW  01
04F84:  MOVLB  6
04F86:  MOVWF  x71
04F88:  MOVLB  0
04F8A:  RCALL  4CC0
....................          state = 0;
04F8C:  MOVLB  1
04F8E:  CLRF   xD0
....................       break;
04F90:  MOVLB  0
....................    }
04F92:  GOTO   A63A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B34:  MOVLB  6
00B36:  CLRF   x77
00B38:  CLRF   x76
00B3A:  CLRF   x75
00B3C:  CLRF   x74
00B3E:  MOVLB  0
00B40:  RCALL  0B0A
....................    output_low(_SYNC_X);
00B42:  MOVLW  E8
00B44:  MOVWF  F8B
00B46:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B48:  MOVWF  F8B
00B4A:  BCF    F86.1
....................    output_high(_SYNC_X);
00B4C:  MOVWF  F8B
00B4E:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B50:  MOVWF  F8B
00B52:  BSF    F86.1
00B54:  GOTO   A622 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B58:  MOVLB  6
00B5A:  MOVF   x72,W
00B5C:  SUBLW  03
00B5E:  BTFSS  FD8.0
00B60:  BRA    0CCE
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B62:  CLRF   x73
00B64:  MOVF   x73,W
00B66:  SUBLW  06
00B68:  BNC   0BB8
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B6A:  CLRF   xB3
00B6C:  MOVFF  672,6B2
00B70:  CLRF   xB5
00B72:  MOVLW  B5
00B74:  MOVWF  xB4
00B76:  MOVLB  0
00B78:  RCALL  0876
00B7A:  MOVFF  02,675
00B7E:  MOVFF  01,674
00B82:  MOVLW  06
00B84:  MOVLB  6
00B86:  ADDWF  x74,F
00B88:  MOVLW  00
00B8A:  ADDWFC x75,F
00B8C:  CLRF   xB3
00B8E:  MOVFF  673,6B2
00B92:  CLRF   xB5
00B94:  MOVLW  19
00B96:  MOVWF  xB4
00B98:  MOVLB  0
00B9A:  RCALL  0876
00B9C:  MOVF   01,W
00B9E:  MOVLB  6
00BA0:  ADDWF  x74,F
00BA2:  MOVF   02,W
00BA4:  ADDWFC x75,F
00BA6:  MOVLW  D1
00BA8:  ADDWF  x74,W
00BAA:  MOVWF  FE9
00BAC:  MOVLW  01
00BAE:  ADDWFC x75,W
00BB0:  MOVWF  FEA
00BB2:  CLRF   FEF
00BB4:  INCF   x73,F
00BB6:  BRA    0B64
....................       }
....................       SERcmd[recNum].t = 0;
00BB8:  CLRF   xB3
00BBA:  MOVFF  672,6B2
00BBE:  CLRF   xB5
00BC0:  MOVLW  B5
00BC2:  MOVWF  xB4
00BC4:  MOVLB  0
00BC6:  RCALL  0876
00BC8:  MOVFF  01,674
00BCC:  MOVLW  05
00BCE:  MOVLB  6
00BD0:  ADDWF  01,W
00BD2:  MOVWF  01
00BD4:  MOVLW  00
00BD6:  ADDWFC 02,W
00BD8:  MOVWF  03
00BDA:  MOVF   01,W
00BDC:  ADDLW  D1
00BDE:  MOVWF  FE9
00BE0:  MOVLW  01
00BE2:  ADDWFC 03,W
00BE4:  MOVWF  FEA
00BE6:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00BE8:  CLRF   xB3
00BEA:  MOVFF  672,6B2
00BEE:  CLRF   xB5
00BF0:  MOVLW  B5
00BF2:  MOVWF  xB4
00BF4:  MOVLB  0
00BF6:  RCALL  0876
00BF8:  MOVFF  01,674
00BFC:  MOVLW  01
00BFE:  MOVLB  6
00C00:  ADDWF  01,W
00C02:  MOVWF  01
00C04:  MOVLW  00
00C06:  ADDWFC 02,W
00C08:  MOVWF  03
00C0A:  MOVF   01,W
00C0C:  ADDLW  D1
00C0E:  MOVWF  FE9
00C10:  MOVLW  01
00C12:  ADDWFC 03,W
00C14:  MOVWF  FEA
00C16:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C18:  CLRF   xB3
00C1A:  MOVFF  672,6B2
00C1E:  CLRF   xB5
00C20:  MOVLW  B5
00C22:  MOVWF  xB4
00C24:  MOVLB  0
00C26:  RCALL  0876
00C28:  MOVFF  01,674
00C2C:  MOVLW  02
00C2E:  MOVLB  6
00C30:  ADDWF  01,W
00C32:  MOVWF  01
00C34:  MOVLW  00
00C36:  ADDWFC 02,W
00C38:  MOVWF  03
00C3A:  MOVF   01,W
00C3C:  ADDLW  D1
00C3E:  MOVWF  FE9
00C40:  MOVLW  01
00C42:  ADDWFC 03,W
00C44:  MOVWF  FEA
00C46:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C48:  CLRF   xB3
00C4A:  MOVFF  672,6B2
00C4E:  CLRF   xB5
00C50:  MOVLW  B5
00C52:  MOVWF  xB4
00C54:  MOVLB  0
00C56:  RCALL  0876
00C58:  MOVFF  01,674
00C5C:  MOVLW  03
00C5E:  MOVLB  6
00C60:  ADDWF  01,W
00C62:  MOVWF  01
00C64:  MOVLW  00
00C66:  ADDWFC 02,W
00C68:  MOVWF  03
00C6A:  MOVF   01,W
00C6C:  ADDLW  D1
00C6E:  MOVWF  FE9
00C70:  MOVLW  01
00C72:  ADDWFC 03,W
00C74:  MOVWF  FEA
00C76:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C78:  CLRF   xB3
00C7A:  MOVFF  672,6B2
00C7E:  CLRF   xB5
00C80:  MOVLW  B5
00C82:  MOVWF  xB4
00C84:  MOVLB  0
00C86:  RCALL  0876
00C88:  MOVFF  01,674
00C8C:  MOVLW  04
00C8E:  MOVLB  6
00C90:  ADDWF  01,W
00C92:  MOVWF  01
00C94:  MOVLW  00
00C96:  ADDWFC 02,W
00C98:  MOVWF  03
00C9A:  MOVF   01,W
00C9C:  ADDLW  D1
00C9E:  MOVWF  FE9
00CA0:  MOVLW  01
00CA2:  ADDWFC 03,W
00CA4:  MOVWF  FEA
00CA6:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CA8:  CLRF   xB3
00CAA:  MOVFF  672,6B2
00CAE:  CLRF   xB5
00CB0:  MOVLW  B5
00CB2:  MOVWF  xB4
00CB4:  MOVLB  0
00CB6:  RCALL  0876
00CB8:  MOVLW  D1
00CBA:  MOVLB  6
00CBC:  ADDWF  01,W
00CBE:  MOVWF  FE9
00CC0:  MOVLW  01
00CC2:  ADDWFC 02,W
00CC4:  MOVWF  FEA
00CC6:  BCF    FEF.0
....................       retData[0] = '\0';
00CC8:  MOVLB  4
00CCA:  CLRF   xA7
00CCC:  MOVLB  6
....................    }
00CCE:  MOVLB  0
00CD0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05916:  MOVLB  6
05918:  CLRF   xB3
0591A:  MOVFF  4A5,6B2
0591E:  CLRF   xB5
05920:  MOVLW  B5
05922:  MOVWF  xB4
05924:  MOVLB  0
05926:  CALL   0876
0592A:  MOVFF  02,673
0592E:  MOVFF  01,672
05932:  MOVLW  D1
05934:  MOVLB  6
05936:  ADDWF  01,W
05938:  MOVWF  FE9
0593A:  MOVLW  01
0593C:  ADDWFC 02,W
0593E:  MOVWF  FEA
05940:  BTFSC  FEF.0
05942:  BRA    5964
....................    {
....................       if (SRI == SWI) return FALSE;
05944:  MOVLB  4
05946:  MOVF   xA6,W
05948:  SUBWF  xA5,W
0594A:  BNZ   5952
0594C:  MOVLW  00
0594E:  MOVWF  01
05950:  BRA    596A
....................       SRI +=1;
05952:  MOVLW  01
05954:  ADDWF  xA5,F
....................       if (SRI >= numRecords) SRI=0;
05956:  MOVF   xA5,W
05958:  SUBLW  03
0595A:  BC    595E
0595C:  CLRF   xA5
0595E:  MOVLB  0
05960:  BRA    5916
05962:  MOVLB  6
....................    }
....................    return TRUE;
05964:  MOVLW  01
05966:  MOVWF  01
05968:  MOVLB  4
0596A:  MOVLB  0
0596C:  GOTO   A144 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
04FCE:  MOVLW  01
04FD0:  MOVLB  4
04FD2:  ADDWF  xA6,F
....................    if (SWI >= numRecords) SWI=0;
04FD4:  MOVF   xA6,W
04FD6:  SUBLW  03
04FD8:  BC    4FDC
04FDA:  CLRF   xA6
04FDC:  MOVLB  0
04FDE:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,549
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x49.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
04FE0:  MOVLW  93
04FE2:  MOVWF  F89
04FE4:  BSF    F84.5
04FE6:  MOVLB  E
04FE8:  BTFSS  xC8.4
04FEA:  BRA    4FE8
04FEC:  MOVLW  93
04FEE:  MOVWF  F89
04FF0:  BSF    F84.5
04FF2:  MOVLB  6
04FF4:  MOVFF  687,F99
04FF8:  NOP   
04FFA:  BTFSS  F9D.1
04FFC:  BRA    4FFA
04FFE:  MOVLW  93
05000:  MOVWF  F89
05002:  BCF    F84.5
05004:  MOVLB  0
05006:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x47,W
000F6:  ADDLW  0B
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,6E3
00104:  MOVFF  FE9,6E2
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  6E3,FEA
00110:  MOVFF  6E2,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x47,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x47,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x47
....................       BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x49.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................    }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
04F96:  CLRF   03
04F98:  MOVLB  5
04F9A:  MOVF   x48,W
04F9C:  ADDLW  0B
04F9E:  MOVWF  FE9
04FA0:  MOVLW  05
04FA2:  ADDWFC 03,W
04FA4:  MOVWF  FEA
04FA6:  MOVFF  FEF,672
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
04FAA:  MOVLW  01
04FAC:  ADDWF  x48,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
04FAE:  MOVF   x48,W
04FB0:  SUBLW  3B
04FB2:  BC    4FB6
04FB4:  CLRF   x48
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
04FB6:  MOVF   x47,W
04FB8:  SUBWF  x48,W
04FBA:  BNZ   4FC2
04FBC:  MOVLB  1
04FBE:  BCF    x49.1
04FC0:  MOVLB  5
....................    return data;
04FC2:  MOVLB  6
04FC4:  MOVFF  672,01
04FC8:  MOVLB  0
04FCA:  GOTO   506E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
0502C:  MOVLB  1
0502E:  BTFSS  x49.1
05030:  BRA    551E
05032:  MOVLB  6
05034:  CLRF   xB3
05036:  MOVFF  4A6,6B2
0503A:  CLRF   xB5
0503C:  MOVLW  B5
0503E:  MOVWF  xB4
05040:  MOVLB  0
05042:  CALL   0876
05046:  MOVFF  02,673
0504A:  MOVFF  01,672
0504E:  MOVLW  D1
05050:  MOVLB  6
05052:  ADDWF  01,W
05054:  MOVWF  01
05056:  MOVLW  01
05058:  ADDWFC 02,W
0505A:  MOVWF  03
0505C:  MOVFF  01,FE9
05060:  MOVWF  FEA
05062:  BTFSS  FEF.0
05064:  BRA    506A
05066:  MOVLB  1
05068:  BRA    551E
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
0506A:  MOVLB  0
0506C:  BRA    4F96
0506E:  MOVFF  01,671
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05072:  MOVLB  6
05074:  MOVF   x71,W
05076:  SUBLW  0D
05078:  BZ    5080
0507A:  MOVF   x71,W
0507C:  SUBLW  20
0507E:  BNZ   5082
....................       {
....................       }
05080:  BRA    5518
....................       else if (rxChar == UART_SOT_CHAR)
05082:  MOVF   x71,W
05084:  SUBLW  7E
05086:  BNZ   50CA
....................       {
....................          resetSERcmd(SWI);
05088:  MOVFF  4A6,672
0508C:  MOVLB  0
0508E:  CALL   0B58
....................          SERcmd[SWI].t = rxChar;
05092:  MOVLB  6
05094:  CLRF   xB3
05096:  MOVFF  4A6,6B2
0509A:  CLRF   xB5
0509C:  MOVLW  B5
0509E:  MOVWF  xB4
050A0:  MOVLB  0
050A2:  CALL   0876
050A6:  MOVFF  01,672
050AA:  MOVLW  05
050AC:  MOVLB  6
050AE:  ADDWF  01,W
050B0:  MOVWF  01
050B2:  MOVLW  00
050B4:  ADDWFC 02,W
050B6:  MOVWF  03
050B8:  MOVF   01,W
050BA:  ADDLW  D1
050BC:  MOVWF  FE9
050BE:  MOVLW  01
050C0:  ADDWFC 03,W
050C2:  MOVWF  FEA
050C4:  MOVFF  671,FEF
....................       }
050C8:  BRA    5518
....................       else if (rxChar >= oneByteCmdTestValue)
050CA:  MOVF   x71,W
050CC:  SUBLW  7F
050CE:  BC    513A
....................       {
....................          resetSERcmd(SWI);
050D0:  MOVFF  4A6,672
050D4:  MOVLB  0
050D6:  CALL   0B58
....................          SERcmd[SWI].t = rxChar;
050DA:  MOVLB  6
050DC:  CLRF   xB3
050DE:  MOVFF  4A6,6B2
050E2:  CLRF   xB5
050E4:  MOVLW  B5
050E6:  MOVWF  xB4
050E8:  MOVLB  0
050EA:  CALL   0876
050EE:  MOVFF  01,672
050F2:  MOVLW  05
050F4:  MOVLB  6
050F6:  ADDWF  01,W
050F8:  MOVWF  01
050FA:  MOVLW  00
050FC:  ADDWFC 02,W
050FE:  MOVWF  03
05100:  MOVF   01,W
05102:  ADDLW  D1
05104:  MOVWF  FE9
05106:  MOVLW  01
05108:  ADDWFC 03,W
0510A:  MOVWF  FEA
0510C:  MOVFF  671,FEF
....................          SERcmd[SWI].full = TRUE;
05110:  CLRF   xB3
05112:  MOVFF  4A6,6B2
05116:  CLRF   xB5
05118:  MOVLW  B5
0511A:  MOVWF  xB4
0511C:  MOVLB  0
0511E:  CALL   0876
05122:  MOVLW  D1
05124:  MOVLB  6
05126:  ADDWF  01,W
05128:  MOVWF  FE9
0512A:  MOVLW  01
0512C:  ADDWFC 02,W
0512E:  MOVWF  FEA
05130:  BSF    FEF.0
....................          setNextSERWriteIndex();
05132:  MOVLB  0
05134:  RCALL  4FCE
....................       }
05136:  BRA    5516
05138:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
0513A:  MOVF   x71,W
0513C:  SUBLW  0A
0513E:  BTFSS  FD8.2
05140:  BRA    5246
....................       {
....................          SERcmd[SWI].full = TRUE;
05142:  CLRF   xB3
05144:  MOVFF  4A6,6B2
05148:  CLRF   xB5
0514A:  MOVLW  B5
0514C:  MOVWF  xB4
0514E:  MOVLB  0
05150:  CALL   0876
05154:  MOVLW  D1
05156:  MOVLB  6
05158:  ADDWF  01,W
0515A:  MOVWF  FE9
0515C:  MOVLW  01
0515E:  ADDWFC 02,W
05160:  MOVWF  FEA
05162:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
05164:  CLRF   xB3
05166:  MOVFF  4A6,6B2
0516A:  CLRF   xB5
0516C:  MOVLW  B5
0516E:  MOVWF  xB4
05170:  MOVLB  0
05172:  CALL   0876
05176:  MOVFF  01,672
0517A:  MOVLW  04
0517C:  MOVLB  6
0517E:  ADDWF  01,W
05180:  MOVWF  01
05182:  MOVLW  00
05184:  ADDWFC 02,W
05186:  MOVWF  03
05188:  MOVF   01,W
0518A:  ADDLW  D1
0518C:  MOVWF  01
0518E:  MOVLW  01
05190:  ADDWFC 03,F
05192:  MOVFF  01,672
05196:  MOVFF  03,673
0519A:  CLRF   xB3
0519C:  MOVFF  4A6,6B2
051A0:  CLRF   xB5
051A2:  MOVLW  B5
051A4:  MOVWF  xB4
051A6:  MOVLB  0
051A8:  CALL   0876
051AC:  MOVFF  01,674
051B0:  MOVLW  02
051B2:  MOVLB  6
051B4:  ADDWF  01,W
051B6:  MOVWF  01
051B8:  MOVLW  00
051BA:  ADDWFC 02,W
051BC:  MOVWF  03
051BE:  MOVF   01,W
051C0:  ADDLW  D1
051C2:  MOVWF  FE9
051C4:  MOVLW  01
051C6:  ADDWFC 03,W
051C8:  MOVWF  FEA
051CA:  MOVFF  FEF,674
051CE:  MOVFF  673,FEA
051D2:  MOVFF  672,FE9
051D6:  MOVFF  674,FEF
....................          SERcmd[SWI].chrIndex = 0;
051DA:  CLRF   xB3
051DC:  MOVFF  4A6,6B2
051E0:  CLRF   xB5
051E2:  MOVLW  B5
051E4:  MOVWF  xB4
051E6:  MOVLB  0
051E8:  CALL   0876
051EC:  MOVFF  01,672
051F0:  MOVLW  01
051F2:  MOVLB  6
051F4:  ADDWF  01,W
051F6:  MOVWF  01
051F8:  MOVLW  00
051FA:  ADDWFC 02,W
051FC:  MOVWF  03
051FE:  MOVF   01,W
05200:  ADDLW  D1
05202:  MOVWF  FE9
05204:  MOVLW  01
05206:  ADDWFC 03,W
05208:  MOVWF  FEA
0520A:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
0520C:  CLRF   xB3
0520E:  MOVFF  4A6,6B2
05212:  CLRF   xB5
05214:  MOVLW  B5
05216:  MOVWF  xB4
05218:  MOVLB  0
0521A:  CALL   0876
0521E:  MOVFF  01,672
05222:  MOVLW  02
05224:  MOVLB  6
05226:  ADDWF  01,W
05228:  MOVWF  01
0522A:  MOVLW  00
0522C:  ADDWFC 02,W
0522E:  MOVWF  03
05230:  MOVF   01,W
05232:  ADDLW  D1
05234:  MOVWF  FE9
05236:  MOVLW  01
05238:  ADDWFC 03,W
0523A:  MOVWF  FEA
0523C:  CLRF   FEF
....................          setNextSERWriteIndex();
0523E:  MOVLB  0
05240:  RCALL  4FCE
....................       }
05242:  BRA    5516
05244:  MOVLB  6
....................       else if (rxChar == delimiter)
05246:  MOVF   x71,W
05248:  SUBLW  2C
0524A:  BNZ   5308
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
0524C:  CLRF   xB3
0524E:  MOVFF  4A6,6B2
05252:  CLRF   xB5
05254:  MOVLW  B5
05256:  MOVWF  xB4
05258:  MOVLB  0
0525A:  CALL   0876
0525E:  MOVFF  02,673
05262:  MOVFF  01,672
05266:  MOVLW  02
05268:  MOVLB  6
0526A:  ADDWF  01,W
0526C:  MOVWF  01
0526E:  MOVLW  00
05270:  ADDWFC 02,W
05272:  MOVWF  03
05274:  MOVF   01,W
05276:  ADDLW  D1
05278:  MOVWF  FE9
0527A:  MOVLW  01
0527C:  ADDWFC 03,W
0527E:  MOVWF  FEA
05280:  MOVF   FEF,W
05282:  SUBLW  05
05284:  BNC   52F0
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05286:  CLRF   xB3
05288:  MOVFF  4A6,6B2
0528C:  CLRF   xB5
0528E:  MOVLW  B5
05290:  MOVWF  xB4
05292:  MOVLB  0
05294:  CALL   0876
05298:  MOVFF  01,672
0529C:  MOVLW  02
0529E:  MOVLB  6
052A0:  ADDWF  01,W
052A2:  MOVWF  01
052A4:  MOVLW  00
052A6:  ADDWFC 02,W
052A8:  MOVWF  03
052AA:  MOVF   01,W
052AC:  ADDLW  D1
052AE:  MOVWF  FE9
052B0:  MOVLW  01
052B2:  ADDWFC 03,W
052B4:  MOVWF  FEA
052B6:  MOVLW  01
052B8:  ADDWF  FEF,W
052BA:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
052BC:  CLRF   xB3
052BE:  MOVFF  4A6,6B2
052C2:  CLRF   xB5
052C4:  MOVLW  B5
052C6:  MOVWF  xB4
052C8:  MOVLB  0
052CA:  CALL   0876
052CE:  MOVFF  01,672
052D2:  MOVLW  01
052D4:  MOVLB  6
052D6:  ADDWF  01,W
052D8:  MOVWF  01
052DA:  MOVLW  00
052DC:  ADDWFC 02,W
052DE:  MOVWF  03
052E0:  MOVF   01,W
052E2:  ADDLW  D1
052E4:  MOVWF  FE9
052E6:  MOVLW  01
052E8:  ADDWFC 03,W
052EA:  MOVWF  FEA
052EC:  CLRF   FEF
....................          }
052EE:  BRA    5306
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
052F0:  MOVFF  4A6,672
052F4:  MOVLB  0
052F6:  CALL   0B58
....................             fprintf(SERIAL, retData);
052FA:  MOVLW  04
052FC:  MOVWF  FEA
052FE:  MOVLW  A7
05300:  MOVWF  FE9
05302:  RCALL  5008
05304:  MOVLB  6
....................          }
....................       }
05306:  BRA    5518
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05308:  CLRF   xB3
0530A:  MOVFF  4A6,6B2
0530E:  CLRF   xB5
05310:  MOVLW  B5
05312:  MOVWF  xB4
05314:  MOVLB  0
05316:  CALL   0876
0531A:  MOVFF  02,673
0531E:  MOVFF  01,672
05322:  MOVLW  01
05324:  MOVLB  6
05326:  ADDWF  01,W
05328:  MOVWF  01
0532A:  MOVLW  00
0532C:  ADDWFC 02,W
0532E:  MOVWF  03
05330:  MOVF   01,W
05332:  ADDLW  D1
05334:  MOVWF  FE9
05336:  MOVLW  01
05338:  ADDWFC 03,W
0533A:  MOVWF  FEA
0533C:  MOVF   FEF,W
0533E:  SUBLW  18
05340:  BTFSS  FD8.0
05342:  BRA    5502
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
05344:  CLRF   xB3
05346:  MOVFF  4A6,6B2
0534A:  CLRF   xB5
0534C:  MOVLW  B5
0534E:  MOVWF  xB4
05350:  MOVLB  0
05352:  CALL   0876
05356:  MOVFF  02,673
0535A:  MOVFF  01,672
0535E:  MOVLW  06
05360:  MOVLB  6
05362:  ADDWF  x72,F
05364:  MOVLW  00
05366:  ADDWFC x73,F
05368:  CLRF   xB3
0536A:  MOVFF  4A6,6B2
0536E:  CLRF   xB5
05370:  MOVLW  B5
05372:  MOVWF  xB4
05374:  MOVLB  0
05376:  CALL   0876
0537A:  MOVFF  02,675
0537E:  MOVFF  01,674
05382:  MOVLW  02
05384:  MOVLB  6
05386:  ADDWF  01,W
05388:  MOVWF  01
0538A:  MOVLW  00
0538C:  ADDWFC 02,W
0538E:  MOVWF  03
05390:  MOVF   01,W
05392:  ADDLW  D1
05394:  MOVWF  FE9
05396:  MOVLW  01
05398:  ADDWFC 03,W
0539A:  MOVWF  FEA
0539C:  CLRF   xB3
0539E:  MOVFF  FEF,6B2
053A2:  CLRF   xB5
053A4:  MOVLW  19
053A6:  MOVWF  xB4
053A8:  MOVLB  0
053AA:  CALL   0876
053AE:  MOVFF  02,03
053B2:  MOVF   01,W
053B4:  MOVLB  6
053B6:  ADDWF  x72,F
053B8:  MOVF   02,W
053BA:  ADDWFC x73,F
053BC:  CLRF   xB3
053BE:  MOVFF  4A6,6B2
053C2:  CLRF   xB5
053C4:  MOVLW  B5
053C6:  MOVWF  xB4
053C8:  MOVLB  0
053CA:  CALL   0876
053CE:  MOVFF  01,674
053D2:  MOVLW  01
053D4:  MOVLB  6
053D6:  ADDWF  01,W
053D8:  MOVWF  01
053DA:  MOVLW  00
053DC:  ADDWFC 02,W
053DE:  MOVWF  03
053E0:  MOVF   01,W
053E2:  ADDLW  D1
053E4:  MOVWF  FE9
053E6:  MOVLW  01
053E8:  ADDWFC 03,W
053EA:  MOVWF  FEA
053EC:  MOVF   FEF,W
053EE:  ADDWF  x72,W
053F0:  MOVWF  01
053F2:  MOVLW  00
053F4:  ADDWFC x73,W
053F6:  MOVWF  03
053F8:  MOVF   01,W
053FA:  ADDLW  D1
053FC:  MOVWF  FE9
053FE:  MOVLW  01
05400:  ADDWFC 03,W
05402:  MOVWF  FEA
05404:  MOVFF  671,FEF
....................             SERcmd[SWI].chrIndex += 1;
05408:  CLRF   xB3
0540A:  MOVFF  4A6,6B2
0540E:  CLRF   xB5
05410:  MOVLW  B5
05412:  MOVWF  xB4
05414:  MOVLB  0
05416:  CALL   0876
0541A:  MOVFF  01,672
0541E:  MOVLW  01
05420:  MOVLB  6
05422:  ADDWF  01,W
05424:  MOVWF  01
05426:  MOVLW  00
05428:  ADDWFC 02,W
0542A:  MOVWF  03
0542C:  MOVF   01,W
0542E:  ADDLW  D1
05430:  MOVWF  FE9
05432:  MOVLW  01
05434:  ADDWFC 03,W
05436:  MOVWF  FEA
05438:  MOVLW  01
0543A:  ADDWF  FEF,W
0543C:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
0543E:  CLRF   xB3
05440:  MOVFF  4A6,6B2
05444:  CLRF   xB5
05446:  MOVLW  B5
05448:  MOVWF  xB4
0544A:  MOVLB  0
0544C:  CALL   0876
05450:  MOVFF  02,673
05454:  MOVFF  01,672
05458:  MOVLW  06
0545A:  MOVLB  6
0545C:  ADDWF  x72,F
0545E:  MOVLW  00
05460:  ADDWFC x73,F
05462:  CLRF   xB3
05464:  MOVFF  4A6,6B2
05468:  CLRF   xB5
0546A:  MOVLW  B5
0546C:  MOVWF  xB4
0546E:  MOVLB  0
05470:  CALL   0876
05474:  MOVFF  02,675
05478:  MOVFF  01,674
0547C:  MOVLW  02
0547E:  MOVLB  6
05480:  ADDWF  01,W
05482:  MOVWF  01
05484:  MOVLW  00
05486:  ADDWFC 02,W
05488:  MOVWF  03
0548A:  MOVF   01,W
0548C:  ADDLW  D1
0548E:  MOVWF  FE9
05490:  MOVLW  01
05492:  ADDWFC 03,W
05494:  MOVWF  FEA
05496:  CLRF   xB3
05498:  MOVFF  FEF,6B2
0549C:  CLRF   xB5
0549E:  MOVLW  19
054A0:  MOVWF  xB4
054A2:  MOVLB  0
054A4:  CALL   0876
054A8:  MOVFF  02,03
054AC:  MOVF   01,W
054AE:  MOVLB  6
054B0:  ADDWF  x72,F
054B2:  MOVF   02,W
054B4:  ADDWFC x73,F
054B6:  CLRF   xB3
054B8:  MOVFF  4A6,6B2
054BC:  CLRF   xB5
054BE:  MOVLW  B5
054C0:  MOVWF  xB4
054C2:  MOVLB  0
054C4:  CALL   0876
054C8:  MOVFF  01,674
054CC:  MOVLW  01
054CE:  MOVLB  6
054D0:  ADDWF  01,W
054D2:  MOVWF  01
054D4:  MOVLW  00
054D6:  ADDWFC 02,W
054D8:  MOVWF  03
054DA:  MOVF   01,W
054DC:  ADDLW  D1
054DE:  MOVWF  FE9
054E0:  MOVLW  01
054E2:  ADDWFC 03,W
054E4:  MOVWF  FEA
054E6:  MOVF   FEF,W
054E8:  ADDWF  x72,W
054EA:  MOVWF  01
054EC:  MOVLW  00
054EE:  ADDWFC x73,W
054F0:  MOVWF  03
054F2:  MOVF   01,W
054F4:  ADDLW  D1
054F6:  MOVWF  FE9
054F8:  MOVLW  01
054FA:  ADDWFC 03,W
054FC:  MOVWF  FEA
054FE:  CLRF   FEF
....................          }
05500:  BRA    5518
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
05502:  MOVFF  4A6,672
05506:  MOVLB  0
05508:  CALL   0B58
....................             fprintf(SERIAL, retData);
0550C:  MOVLW  04
0550E:  MOVWF  FEA
05510:  MOVLW  A7
05512:  MOVWF  FE9
05514:  RCALL  5008
05516:  MOVLB  6
....................          }
....................       }
05518:  MOVLB  0
0551A:  BRA    502C
0551C:  MOVLB  1
....................    }          
0551E:  MOVLB  0
05520:  GOTO   A63E (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00CD2:  MOVLB  6
00CD4:  CLRF   x71
00CD6:  MOVF   x71,W
00CD8:  SUBLW  03
00CDA:  BNC   0CEA
....................    {
....................       resetSERcmd(i);
00CDC:  MOVFF  671,672
00CE0:  MOVLB  0
00CE2:  RCALL  0B58
00CE4:  MOVLB  6
00CE6:  INCF   x71,F
00CE8:  BRA    0CD6
....................    }
....................    enable_interrupts(INT_RDA);
00CEA:  MOVLB  E
00CEC:  BSF    xC0.5
00CEE:  MOVLB  0
00CF0:  GOTO   A626 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00CF4:  MOVLB  E
00CF6:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00CF8:  MOVLW  01
00CFA:  MOVWF  FD1
00CFC:  MOVLW  07
00CFE:  MOVWF  FCE
00D00:  CLRF   FCF
00D02:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D04:  MOVLB  1
00D06:  CLRF   x5B
00D08:  CLRF   x5A
00D0A:  CLRF   x59
00D0C:  CLRF   x58
....................    timeoutReg1 = 0;
00D0E:  CLRF   x5F
00D10:  CLRF   x5E
00D12:  CLRF   x5D
00D14:  CLRF   x5C
....................    timeoutReg2 = 0;
00D16:  CLRF   x63
00D18:  CLRF   x62
00D1A:  CLRF   x61
00D1C:  CLRF   x60
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D1E:  MOVLB  E
00D20:  BSF    xC1.0
00D22:  MOVLB  0
00D24:  GOTO   A62A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x5B,F
0026C:  BNZ   027C
0026E:  MOVF   x5A,F
00270:  BNZ   027C
00272:  MOVF   x59,F
00274:  BNZ   027C
00276:  MOVF   x58,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x58,F
00280:  MOVLW  00
00282:  SUBWFB x59,F
00284:  SUBWFB x5A,F
00286:  SUBWFB x5B,F
00288:  BRA    0292
0028A:  CLRF   x5B
0028C:  CLRF   x5A
0028E:  CLRF   x59
00290:  CLRF   x58
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x5F,F
00294:  BNZ   02A4
00296:  MOVF   x5E,F
00298:  BNZ   02A4
0029A:  MOVF   x5D,F
0029C:  BNZ   02A4
0029E:  MOVF   x5C,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x5C,F
002A8:  MOVLW  00
002AA:  SUBWFB x5D,F
002AC:  SUBWFB x5E,F
002AE:  SUBWFB x5F,F
002B0:  BRA    02BA
002B2:  CLRF   x5F
002B4:  CLRF   x5E
002B6:  CLRF   x5D
002B8:  CLRF   x5C
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x63,F
002BC:  BNZ   02CC
002BE:  MOVF   x62,F
002C0:  BNZ   02CC
002C2:  MOVF   x61,F
002C4:  BNZ   02CC
002C6:  MOVF   x60,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x60,F
002D0:  MOVLW  00
002D2:  SUBWFB x61,F
002D4:  SUBWFB x62,F
002D6:  SUBWFB x63,F
002D8:  BRA    02E2
002DA:  CLRF   x63
002DC:  CLRF   x62
002DE:  CLRF   x61
002E0:  CLRF   x60
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x64,F
002E4:  BNZ   02EA
002E6:  MOVF   x65,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x4C,F
002F0:  MOVLW  00
002F2:  ADDWFC x4D,F
002F4:  ADDWFC x4E,F
002F6:  ADDWFC x4F,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x4F,F
002FA:  BNZ   0316
002FC:  MOVF   x4E,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x65,W
00304:  MOVLB  5
00306:  SUBWF  x4D,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x64,W
00310:  MOVLB  5
00312:  SUBWF  x4C,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x4F
0031E:  CLRF   x4E
00320:  CLRF   x4D
00322:  CLRF   x4C
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = TRUE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);           // sFiltOn
.................... int8 setFilterOff(unsigned int8);          // sFiltOff
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"sFiltOn",  &setFilterOn},
....................    {"sFiltOff", &setFilterOff},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05A9A:  MOVLW  04
05A9C:  MOVLB  6
05A9E:  MOVWF  xB3
05AA0:  MOVLW  A7
05AA2:  MOVWF  xB2
05AA4:  MOVLB  0
05AA6:  RCALL  59AA
05AA8:  MOVFF  02,03
05AAC:  MOVF   01,W
05AAE:  ADDLW  A7
05AB0:  MOVLB  6
05AB2:  MOVWF  x7C
05AB4:  MOVLW  04
05AB6:  ADDWFC 02,W
05AB8:  MOVWF  x7D
05ABA:  MOVFF  FE8,54B
05ABE:  MOVFF  67C,54A
05AC2:  MOVLW  30
05AC4:  MOVWF  FF6
05AC6:  MOVLW  03
05AC8:  MOVWF  FF7
05ACA:  MOVLB  0
05ACC:  RCALL  5A7A
05ACE:  MOVLW  2C
05AD0:  MOVLB  6
05AD2:  MOVWF  xC1
05AD4:  MOVLB  0
05AD6:  RCALL  5A5A
....................    return SUCCESS;
05AD8:  MOVLW  00
05ADA:  MOVWF  01
05ADC:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05ADE:  MOVLW  04
05AE0:  MOVLB  6
05AE2:  MOVWF  xB3
05AE4:  MOVLW  A7
05AE6:  MOVWF  xB2
05AE8:  MOVLB  0
05AEA:  RCALL  59AA
05AEC:  MOVFF  02,03
05AF0:  MOVF   01,W
05AF2:  ADDLW  A7
05AF4:  MOVLB  6
05AF6:  MOVWF  x7C
05AF8:  MOVLW  04
05AFA:  ADDWFC 02,W
05AFC:  MOVWF  x7D
05AFE:  MOVFF  FE8,54B
05B02:  MOVFF  67C,54A
05B06:  MOVLW  3A
05B08:  MOVWF  FF6
05B0A:  MOVLW  03
05B0C:  MOVWF  FF7
05B0E:  MOVLB  0
05B10:  RCALL  5A7A
05B12:  MOVLW  2C
05B14:  MOVLB  6
05B16:  MOVWF  xC1
05B18:  MOVLB  0
05B1A:  RCALL  5A5A
....................    return SUCCESS;
05B1C:  MOVLW  00
05B1E:  MOVWF  01
05B20:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06026:  MOVLB  6
06028:  CLRF   xB3
0602A:  MOVFF  66C,6B2
0602E:  CLRF   xB5
06030:  MOVLW  B5
06032:  MOVWF  xB4
06034:  MOVLB  0
06036:  CALL   0876
0603A:  MOVFF  02,67E
0603E:  MOVFF  01,67D
06042:  MOVLW  06
06044:  MOVLB  6
06046:  ADDWF  x7D,F
06048:  MOVLW  00
0604A:  ADDWFC x7E,F
0604C:  MOVLW  32
0604E:  ADDWF  x7D,W
06050:  MOVWF  01
06052:  MOVLW  00
06054:  ADDWFC x7E,W
06056:  MOVWF  03
06058:  MOVF   01,W
0605A:  ADDLW  D1
0605C:  MOVWF  01
0605E:  MOVLW  01
06060:  ADDWFC 03,F
06062:  MOVFF  01,67D
06066:  MOVFF  03,67E
0606A:  MOVFF  03,6A5
0606E:  MOVFF  01,6A4
06072:  MOVLB  0
06074:  RCALL  5B22
06076:  MOVF   01,F
06078:  BNZ   6082
0607A:  MOVLW  02
0607C:  MOVWF  01
0607E:  BRA    61C0
06080:  BRA    60DE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06082:  MOVLB  6
06084:  CLRF   xB3
06086:  MOVFF  66C,6B2
0608A:  CLRF   xB5
0608C:  MOVLW  B5
0608E:  MOVWF  xB4
06090:  MOVLB  0
06092:  CALL   0876
06096:  MOVFF  02,67E
0609A:  MOVFF  01,67D
0609E:  MOVLW  06
060A0:  MOVLB  6
060A2:  ADDWF  x7D,F
060A4:  MOVLW  00
060A6:  ADDWFC x7E,F
060A8:  MOVLW  32
060AA:  ADDWF  x7D,W
060AC:  MOVWF  01
060AE:  MOVLW  00
060B0:  ADDWFC x7E,W
060B2:  MOVWF  03
060B4:  MOVF   01,W
060B6:  ADDLW  D1
060B8:  MOVWF  01
060BA:  MOVLW  01
060BC:  ADDWFC 03,F
060BE:  MOVFF  01,67D
060C2:  MOVFF  03,67E
060C6:  MOVFF  03,6A5
060CA:  MOVFF  01,6A4
060CE:  CLRF   xA7
060D0:  CLRF   xA6
060D2:  MOVLW  0A
060D4:  MOVWF  xA8
060D6:  MOVLB  0
060D8:  RCALL  5C12
060DA:  MOVFF  01,67C
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
060DE:  MOVLW  01
060E0:  MOVLB  6
060E2:  SUBWF  x7C,W
060E4:  MOVWF  x7E
060E6:  CLRF   x80
060E8:  MOVLW  60
060EA:  MOVWF  x7F
060EC:  MOVLB  0
060EE:  CALL   45CE
060F2:  BTFSC  01.0
060F4:  BRA    614A
060F6:  MOVLW  04
060F8:  MOVLB  6
060FA:  MOVWF  xB3
060FC:  MOVLW  A7
060FE:  MOVWF  xB2
06100:  MOVLB  0
06102:  RCALL  59AA
06104:  MOVFF  02,03
06108:  MOVF   01,W
0610A:  ADDLW  A7
0610C:  MOVLB  6
0610E:  MOVWF  x7D
06110:  MOVLW  04
06112:  ADDWFC 02,W
06114:  MOVWF  x7E
06116:  MOVFF  FE8,54B
0611A:  MOVFF  67D,54A
0611E:  MOVFF  67C,6A5
06122:  MOVLW  18
06124:  MOVWF  xA6
06126:  MOVLB  0
06128:  RCALL  5F66
0612A:  MOVLW  2C
0612C:  MOVLB  6
0612E:  MOVWF  xC1
06130:  MOVLB  0
06132:  RCALL  5A5A
06134:  MOVLW  58
06136:  MOVLB  6
06138:  MOVWF  xC1
0613A:  MOVLB  0
0613C:  RCALL  5A5A
0613E:  MOVLW  2C
06140:  MOVLB  6
06142:  MOVWF  xC1
06144:  MOVLB  0
06146:  RCALL  5A5A
06148:  BRA    61BC
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
0614A:  MOVLW  01
0614C:  MOVLB  6
0614E:  SUBWF  x7C,W
06150:  MOVWF  x7E
06152:  CLRF   x80
06154:  MOVLW  60
06156:  MOVWF  x7F
06158:  MOVLB  0
0615A:  CALL   45CE
0615E:  BTFSS  01.0
06160:  BRA    61B6
06162:  MOVLW  04
06164:  MOVLB  6
06166:  MOVWF  xB3
06168:  MOVLW  A7
0616A:  MOVWF  xB2
0616C:  MOVLB  0
0616E:  RCALL  59AA
06170:  MOVFF  02,03
06174:  MOVF   01,W
06176:  ADDLW  A7
06178:  MOVLB  6
0617A:  MOVWF  x7D
0617C:  MOVLW  04
0617E:  ADDWFC 02,W
06180:  MOVWF  x7E
06182:  MOVFF  FE8,54B
06186:  MOVFF  67D,54A
0618A:  MOVFF  67C,6A5
0618E:  MOVLW  18
06190:  MOVWF  xA6
06192:  MOVLB  0
06194:  RCALL  5F66
06196:  MOVLW  2C
06198:  MOVLB  6
0619A:  MOVWF  xC1
0619C:  MOVLB  0
0619E:  RCALL  5A5A
061A0:  MOVLW  59
061A2:  MOVLB  6
061A4:  MOVWF  xC1
061A6:  MOVLB  0
061A8:  RCALL  5A5A
061AA:  MOVLW  2C
061AC:  MOVLB  6
061AE:  MOVWF  xC1
061B0:  MOVLB  0
061B2:  RCALL  5A5A
061B4:  BRA    61BC
....................    else return INV_PARAM;
061B6:  MOVLW  02
061B8:  MOVWF  01
061BA:  BRA    61C0
....................    
....................    return SUCCESS;
061BC:  MOVLW  00
061BE:  MOVWF  01
061C0:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06204:  MOVLB  6
06206:  CLRF   xB3
06208:  MOVFF  66C,6B2
0620C:  CLRF   xB5
0620E:  MOVLW  B5
06210:  MOVWF  xB4
06212:  MOVLB  0
06214:  CALL   0876
06218:  MOVFF  02,67F
0621C:  MOVFF  01,67E
06220:  MOVLW  06
06222:  MOVLB  6
06224:  ADDWF  x7E,F
06226:  MOVLW  00
06228:  ADDWFC x7F,F
0622A:  MOVLW  32
0622C:  ADDWF  x7E,W
0622E:  MOVWF  01
06230:  MOVLW  00
06232:  ADDWFC x7F,W
06234:  MOVWF  03
06236:  MOVF   01,W
06238:  ADDLW  D1
0623A:  MOVWF  01
0623C:  MOVLW  01
0623E:  ADDWFC 03,F
06240:  MOVFF  01,67E
06244:  MOVFF  03,67F
06248:  MOVFF  03,6A5
0624C:  MOVFF  01,6A4
06250:  MOVLB  0
06252:  RCALL  5B22
06254:  MOVF   01,F
06256:  BNZ   6260
06258:  MOVLW  02
0625A:  MOVWF  01
0625C:  BRA    63B0
0625E:  BRA    62BC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06260:  MOVLB  6
06262:  CLRF   xB3
06264:  MOVFF  66C,6B2
06268:  CLRF   xB5
0626A:  MOVLW  B5
0626C:  MOVWF  xB4
0626E:  MOVLB  0
06270:  CALL   0876
06274:  MOVFF  02,67F
06278:  MOVFF  01,67E
0627C:  MOVLW  06
0627E:  MOVLB  6
06280:  ADDWF  x7E,F
06282:  MOVLW  00
06284:  ADDWFC x7F,F
06286:  MOVLW  32
06288:  ADDWF  x7E,W
0628A:  MOVWF  01
0628C:  MOVLW  00
0628E:  ADDWFC x7F,W
06290:  MOVWF  03
06292:  MOVF   01,W
06294:  ADDLW  D1
06296:  MOVWF  01
06298:  MOVLW  01
0629A:  ADDWFC 03,F
0629C:  MOVFF  01,67E
062A0:  MOVFF  03,67F
062A4:  MOVFF  03,6A5
062A8:  MOVFF  01,6A4
062AC:  CLRF   xA7
062AE:  CLRF   xA6
062B0:  MOVLW  0A
062B2:  MOVWF  xA8
062B4:  MOVLB  0
062B6:  RCALL  5C12
062B8:  MOVFF  01,67C
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
062BC:  MOVLB  6
062BE:  CLRF   xB3
062C0:  MOVFF  66C,6B2
062C4:  CLRF   xB5
062C6:  MOVLW  B5
062C8:  MOVWF  xB4
062CA:  MOVLB  0
062CC:  CALL   0876
062D0:  MOVFF  02,67F
062D4:  MOVFF  01,67E
062D8:  MOVLW  06
062DA:  MOVLB  6
062DC:  ADDWF  x7E,F
062DE:  MOVLW  00
062E0:  ADDWFC x7F,F
062E2:  MOVLW  4B
062E4:  ADDWF  x7E,W
062E6:  MOVWF  01
062E8:  MOVLW  00
062EA:  ADDWFC x7F,W
062EC:  MOVWF  03
062EE:  MOVF   01,W
062F0:  ADDLW  D1
062F2:  MOVWF  01
062F4:  MOVLW  01
062F6:  ADDWFC 03,F
062F8:  MOVFF  01,67E
062FC:  MOVFF  03,67F
06300:  MOVFF  03,6B3
06304:  MOVFF  01,6B2
06308:  MOVLB  0
0630A:  CALL   59AA
0630E:  MOVFF  02,03
06312:  MOVF   01,W
06314:  SUBLW  01
06316:  BNZ   631C
06318:  MOVF   03,F
0631A:  BZ    6324
0631C:  MOVLW  02
0631E:  MOVWF  01
06320:  BRA    63B0
06322:  BRA    6364
....................    else arg2 = SERcmd[rec].p[3][0];
06324:  MOVLB  6
06326:  CLRF   xB3
06328:  MOVFF  66C,6B2
0632C:  CLRF   xB5
0632E:  MOVLW  B5
06330:  MOVWF  xB4
06332:  MOVLB  0
06334:  CALL   0876
06338:  MOVFF  02,67F
0633C:  MOVFF  01,67E
06340:  MOVLW  06
06342:  MOVLB  6
06344:  ADDWF  x7E,F
06346:  MOVLW  00
06348:  ADDWFC x7F,F
0634A:  MOVLW  4B
0634C:  ADDWF  x7E,F
0634E:  MOVLW  00
06350:  ADDWFC x7F,F
06352:  MOVLW  D1
06354:  ADDWF  x7E,W
06356:  MOVWF  FE9
06358:  MOVLW  01
0635A:  ADDWFC x7F,W
0635C:  MOVWF  FEA
0635E:  MOVFF  FEF,67D
06362:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06364:  MOVLB  6
06366:  MOVF   x7D,W
06368:  SUBLW  58
0636A:  BNZ   6384
0636C:  MOVLW  01
0636E:  SUBWF  x7C,W
06370:  MOVWF  x7E
06372:  MOVWF  x93
06374:  CLRF   x94
06376:  CLRF   x96
06378:  MOVLW  60
0637A:  MOVWF  x95
0637C:  MOVLB  0
0637E:  RCALL  61C2
06380:  BRA    63AC
06382:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06384:  MOVF   x7D,W
06386:  SUBLW  59
06388:  BNZ   63A4
0638A:  MOVLW  01
0638C:  SUBWF  x7C,W
0638E:  MOVWF  x7E
06390:  MOVWF  x93
06392:  MOVLW  01
06394:  MOVWF  x94
06396:  CLRF   x96
06398:  MOVLW  60
0639A:  MOVWF  x95
0639C:  MOVLB  0
0639E:  RCALL  61C2
063A0:  BRA    63AC
063A2:  MOVLB  6
....................    else return INV_PARAM;
063A4:  MOVLW  02
063A6:  MOVWF  01
063A8:  MOVLB  0
063AA:  BRA    63B0
....................    
....................    return SUCCESS;
063AC:  MOVLW  00
063AE:  MOVWF  01
063B0:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
063DC:  MOVLB  6
063DE:  CLRF   xB3
063E0:  MOVFF  66C,6B2
063E4:  CLRF   xB5
063E6:  MOVLW  B5
063E8:  MOVWF  xB4
063EA:  MOVLB  0
063EC:  CALL   0876
063F0:  MOVFF  02,67E
063F4:  MOVFF  01,67D
063F8:  MOVLW  06
063FA:  MOVLB  6
063FC:  ADDWF  x7D,F
063FE:  MOVLW  00
06400:  ADDWFC x7E,F
06402:  MOVLW  32
06404:  ADDWF  x7D,W
06406:  MOVWF  01
06408:  MOVLW  00
0640A:  ADDWFC x7E,W
0640C:  MOVWF  03
0640E:  MOVF   01,W
06410:  ADDLW  D1
06412:  MOVWF  01
06414:  MOVLW  01
06416:  ADDWFC 03,F
06418:  MOVFF  01,67D
0641C:  MOVFF  03,67E
06420:  MOVFF  03,6A5
06424:  MOVFF  01,6A4
06428:  MOVLB  0
0642A:  CALL   5B22
0642E:  MOVF   01,F
06430:  BNZ   643A
06432:  MOVLW  02
06434:  MOVWF  01
06436:  BRA    6566
06438:  BRA    6498
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0643A:  MOVLB  6
0643C:  CLRF   xB3
0643E:  MOVFF  66C,6B2
06442:  CLRF   xB5
06444:  MOVLW  B5
06446:  MOVWF  xB4
06448:  MOVLB  0
0644A:  CALL   0876
0644E:  MOVFF  02,67E
06452:  MOVFF  01,67D
06456:  MOVLW  06
06458:  MOVLB  6
0645A:  ADDWF  x7D,F
0645C:  MOVLW  00
0645E:  ADDWFC x7E,F
06460:  MOVLW  32
06462:  ADDWF  x7D,W
06464:  MOVWF  01
06466:  MOVLW  00
06468:  ADDWFC x7E,W
0646A:  MOVWF  03
0646C:  MOVF   01,W
0646E:  ADDLW  D1
06470:  MOVWF  01
06472:  MOVLW  01
06474:  ADDWFC 03,F
06476:  MOVFF  01,67D
0647A:  MOVFF  03,67E
0647E:  MOVFF  03,6A5
06482:  MOVFF  01,6A4
06486:  CLRF   xA7
06488:  CLRF   xA6
0648A:  MOVLW  0A
0648C:  MOVWF  xA8
0648E:  MOVLB  0
06490:  CALL   5C12
06494:  MOVFF  01,67C
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06498:  MOVLW  01
0649A:  MOVLB  6
0649C:  SUBWF  x7C,W
0649E:  MOVWF  x7E
064A0:  CLRF   x80
064A2:  MOVLW  61
064A4:  MOVWF  x7F
064A6:  MOVLB  0
064A8:  CALL   45CE
064AC:  BTFSC  01.0
064AE:  BRA    64FA
064B0:  MOVLW  04
064B2:  MOVLB  6
064B4:  MOVWF  xB3
064B6:  MOVLW  A7
064B8:  MOVWF  xB2
064BA:  MOVLB  0
064BC:  CALL   59AA
064C0:  MOVFF  02,03
064C4:  MOVF   01,W
064C6:  ADDLW  A7
064C8:  MOVLB  6
064CA:  MOVWF  x7D
064CC:  MOVLW  04
064CE:  ADDWFC 02,W
064D0:  MOVWF  x7E
064D2:  MOVFF  FE8,54B
064D6:  MOVFF  67D,54A
064DA:  MOVFF  67C,6A5
064DE:  MOVLW  18
064E0:  MOVWF  xA6
064E2:  MOVLB  0
064E4:  RCALL  5F66
064E6:  MOVLW  42
064E8:  MOVWF  FF6
064EA:  MOVLW  03
064EC:  MOVWF  FF7
064EE:  MOVLW  08
064F0:  MOVLB  6
064F2:  MOVWF  x80
064F4:  MOVLB  0
064F6:  RCALL  63B2
064F8:  BRA    6562
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
064FA:  MOVLW  01
064FC:  MOVLB  6
064FE:  SUBWF  x7C,W
06500:  MOVWF  x7E
06502:  CLRF   x80
06504:  MOVLW  61
06506:  MOVWF  x7F
06508:  MOVLB  0
0650A:  CALL   45CE
0650E:  BTFSS  01.0
06510:  BRA    655C
06512:  MOVLW  04
06514:  MOVLB  6
06516:  MOVWF  xB3
06518:  MOVLW  A7
0651A:  MOVWF  xB2
0651C:  MOVLB  0
0651E:  CALL   59AA
06522:  MOVFF  02,03
06526:  MOVF   01,W
06528:  ADDLW  A7
0652A:  MOVLB  6
0652C:  MOVWF  x7D
0652E:  MOVLW  04
06530:  ADDWFC 02,W
06532:  MOVWF  x7E
06534:  MOVFF  FE8,54B
06538:  MOVFF  67D,54A
0653C:  MOVFF  67C,6A5
06540:  MOVLW  18
06542:  MOVWF  xA6
06544:  MOVLB  0
06546:  RCALL  5F66
06548:  MOVLW  4E
0654A:  MOVWF  FF6
0654C:  MOVLW  03
0654E:  MOVWF  FF7
06550:  MOVLW  08
06552:  MOVLB  6
06554:  MOVWF  x80
06556:  MOVLB  0
06558:  RCALL  63B2
0655A:  BRA    6562
....................    else return INV_PARAM;
0655C:  MOVLW  02
0655E:  MOVWF  01
06560:  BRA    6566
....................    
....................    return SUCCESS;
06562:  MOVLW  00
06564:  MOVWF  01
06566:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06568:  MOVLW  4D
0656A:  MOVLB  6
0656C:  MOVWF  x81
0656E:  MOVLW  41
06570:  MOVWF  x82
06572:  MOVLW  4E
06574:  MOVWF  x83
06576:  MOVLW  55
06578:  MOVWF  x84
0657A:  MOVLW  41
0657C:  MOVWF  x85
0657E:  MOVLW  4C
06580:  MOVWF  x86
06582:  CLRF   x87
06584:  MOVLW  06
06586:  MOVWF  x80
06588:  MOVLW  81
0658A:  MOVWF  x7F
....................    char *s_magsns = "MAGSNS";
0658C:  MOVLW  4D
0658E:  MOVWF  x8A
06590:  MOVLW  41
06592:  MOVWF  x8B
06594:  MOVLW  47
06596:  MOVWF  x8C
06598:  MOVLW  53
0659A:  MOVWF  x8D
0659C:  MOVLW  4E
0659E:  MOVWF  x8E
065A0:  MOVLW  53
065A2:  MOVWF  x8F
065A4:  CLRF   x90
065A6:  MOVLW  06
065A8:  MOVWF  x89
065AA:  MOVLW  8A
065AC:  MOVWF  x88
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
065AE:  CLRF   xB3
065B0:  MOVFF  66C,6B2
065B4:  CLRF   xB5
065B6:  MOVLW  B5
065B8:  MOVWF  xB4
065BA:  MOVLB  0
065BC:  CALL   0876
065C0:  MOVFF  02,692
065C4:  MOVFF  01,691
065C8:  MOVLW  06
065CA:  MOVLB  6
065CC:  ADDWF  x91,F
065CE:  MOVLW  00
065D0:  ADDWFC x92,F
065D2:  MOVLW  32
065D4:  ADDWF  x91,W
065D6:  MOVWF  01
065D8:  MOVLW  00
065DA:  ADDWFC x92,W
065DC:  MOVWF  03
065DE:  MOVF   01,W
065E0:  ADDLW  D1
065E2:  MOVWF  01
065E4:  MOVLW  01
065E6:  ADDWFC 03,F
065E8:  MOVFF  01,691
065EC:  MOVFF  03,692
065F0:  MOVFF  03,6A5
065F4:  MOVFF  01,6A4
065F8:  MOVLB  0
065FA:  CALL   5B22
065FE:  MOVF   01,F
06600:  BNZ   660A
06602:  MOVLW  02
06604:  MOVWF  01
06606:  BRA    6780
06608:  BRA    6668
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0660A:  MOVLB  6
0660C:  CLRF   xB3
0660E:  MOVFF  66C,6B2
06612:  CLRF   xB5
06614:  MOVLW  B5
06616:  MOVWF  xB4
06618:  MOVLB  0
0661A:  CALL   0876
0661E:  MOVFF  02,692
06622:  MOVFF  01,691
06626:  MOVLW  06
06628:  MOVLB  6
0662A:  ADDWF  x91,F
0662C:  MOVLW  00
0662E:  ADDWFC x92,F
06630:  MOVLW  32
06632:  ADDWF  x91,W
06634:  MOVWF  01
06636:  MOVLW  00
06638:  ADDWFC x92,W
0663A:  MOVWF  03
0663C:  MOVF   01,W
0663E:  ADDLW  D1
06640:  MOVWF  01
06642:  MOVLW  01
06644:  ADDWFC 03,F
06646:  MOVFF  01,691
0664A:  MOVFF  03,692
0664E:  MOVFF  03,6A5
06652:  MOVFF  01,6A4
06656:  CLRF   xA7
06658:  CLRF   xA6
0665A:  MOVLW  0A
0665C:  MOVWF  xA8
0665E:  MOVLB  0
06660:  CALL   5C12
06664:  MOVFF  01,67C
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06668:  MOVLB  6
0666A:  CLRF   xB3
0666C:  MOVFF  66C,6B2
06670:  CLRF   xB5
06672:  MOVLW  B5
06674:  MOVWF  xB4
06676:  MOVLB  0
06678:  CALL   0876
0667C:  MOVFF  02,692
06680:  MOVFF  01,691
06684:  MOVLW  06
06686:  MOVLB  6
06688:  ADDWF  x91,F
0668A:  MOVLW  00
0668C:  ADDWFC x92,F
0668E:  MOVLW  4B
06690:  ADDWF  x91,W
06692:  MOVWF  01
06694:  MOVLW  00
06696:  ADDWFC x92,W
06698:  MOVWF  03
0669A:  MOVF   01,W
0669C:  ADDLW  D1
0669E:  MOVWF  01
066A0:  MOVLW  01
066A2:  ADDWFC 03,F
066A4:  MOVFF  01,691
066A8:  MOVFF  03,692
066AC:  MOVFF  03,6B3
066B0:  MOVFF  01,6B2
066B4:  MOVLB  0
066B6:  CALL   59AA
066BA:  MOVFF  02,03
066BE:  MOVF   01,W
066C0:  BNZ   66CE
066C2:  MOVF   03,F
066C4:  BNZ   66CE
066C6:  MOVLW  02
066C8:  MOVWF  01
066CA:  BRA    6780
066CC:  BRA    6714
....................    else arg2 = SERcmd[rec].p[3];
066CE:  MOVLB  6
066D0:  CLRF   xB3
066D2:  MOVFF  66C,6B2
066D6:  CLRF   xB5
066D8:  MOVLW  B5
066DA:  MOVWF  xB4
066DC:  MOVLB  0
066DE:  CALL   0876
066E2:  MOVFF  02,692
066E6:  MOVFF  01,691
066EA:  MOVLW  06
066EC:  MOVLB  6
066EE:  ADDWF  x91,F
066F0:  MOVLW  00
066F2:  ADDWFC x92,F
066F4:  MOVLW  4B
066F6:  ADDWF  x91,W
066F8:  MOVWF  01
066FA:  MOVLW  00
066FC:  ADDWFC x92,W
066FE:  MOVWF  03
06700:  MOVF   01,W
06702:  ADDLW  D1
06704:  MOVWF  01
06706:  MOVLW  01
06708:  ADDWFC 03,F
0670A:  MOVFF  01,67D
0670E:  MOVFF  03,67E
06712:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
06714:  MOVFF  680,6B3
06718:  MOVFF  67F,6B2
0671C:  MOVFF  67E,6B5
06720:  MOVFF  67D,6B4
06724:  CALL   59E2
06728:  MOVF   01,F
0672A:  BNZ   6744
0672C:  MOVLW  01
0672E:  MOVLB  6
06730:  SUBWF  x7C,W
06732:  MOVWF  x91
06734:  MOVWF  x93
06736:  CLRF   x94
06738:  CLRF   x96
0673A:  MOVLW  61
0673C:  MOVWF  x95
0673E:  MOVLB  0
06740:  RCALL  61C2
06742:  BRA    677C
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06744:  MOVFF  689,6B3
06748:  MOVFF  688,6B2
0674C:  MOVFF  67E,6B5
06750:  MOVFF  67D,6B4
06754:  CALL   59E2
06758:  MOVF   01,F
0675A:  BNZ   6776
0675C:  MOVLW  01
0675E:  MOVLB  6
06760:  SUBWF  x7C,W
06762:  MOVWF  x91
06764:  MOVWF  x93
06766:  MOVLW  01
06768:  MOVWF  x94
0676A:  CLRF   x96
0676C:  MOVLW  61
0676E:  MOVWF  x95
06770:  MOVLB  0
06772:  RCALL  61C2
06774:  BRA    677C
....................    else return INV_PARAM;
06776:  MOVLW  02
06778:  MOVWF  01
0677A:  BRA    6780
....................    
....................    return SUCCESS;
0677C:  MOVLW  00
0677E:  MOVWF  01
06780:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06938:  MOVLB  6
0693A:  CLRF   xB3
0693C:  MOVFF  66C,6B2
06940:  CLRF   xB5
06942:  MOVLW  B5
06944:  MOVWF  xB4
06946:  MOVLB  0
06948:  CALL   0876
0694C:  MOVFF  02,67F
06950:  MOVFF  01,67E
06954:  MOVLW  06
06956:  MOVLB  6
06958:  ADDWF  x7E,F
0695A:  MOVLW  00
0695C:  ADDWFC x7F,F
0695E:  MOVLW  32
06960:  ADDWF  x7E,W
06962:  MOVWF  01
06964:  MOVLW  00
06966:  ADDWFC x7F,W
06968:  MOVWF  03
0696A:  MOVF   01,W
0696C:  ADDLW  D1
0696E:  MOVWF  01
06970:  MOVLW  01
06972:  ADDWFC 03,F
06974:  MOVFF  01,67E
06978:  MOVFF  03,67F
0697C:  MOVFF  03,6A5
06980:  MOVFF  01,6A4
06984:  MOVLB  0
06986:  CALL   5B22
0698A:  MOVF   01,F
0698C:  BNZ   6996
0698E:  MOVLW  02
06990:  MOVWF  01
06992:  BRA    6DEC
06994:  BRA    69F4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06996:  MOVLB  6
06998:  CLRF   xB3
0699A:  MOVFF  66C,6B2
0699E:  CLRF   xB5
069A0:  MOVLW  B5
069A2:  MOVWF  xB4
069A4:  MOVLB  0
069A6:  CALL   0876
069AA:  MOVFF  02,67F
069AE:  MOVFF  01,67E
069B2:  MOVLW  06
069B4:  MOVLB  6
069B6:  ADDWF  x7E,F
069B8:  MOVLW  00
069BA:  ADDWFC x7F,F
069BC:  MOVLW  32
069BE:  ADDWF  x7E,W
069C0:  MOVWF  01
069C2:  MOVLW  00
069C4:  ADDWFC x7F,W
069C6:  MOVWF  03
069C8:  MOVF   01,W
069CA:  ADDLW  D1
069CC:  MOVWF  01
069CE:  MOVLW  01
069D0:  ADDWFC 03,F
069D2:  MOVFF  01,67E
069D6:  MOVFF  03,67F
069DA:  MOVFF  03,6A5
069DE:  MOVFF  01,6A4
069E2:  CLRF   xA7
069E4:  CLRF   xA6
069E6:  MOVLW  0A
069E8:  MOVWF  xA8
069EA:  MOVLB  0
069EC:  CALL   5C12
069F0:  MOVFF  01,67C
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
069F4:  MOVLB  6
069F6:  CLRF   xB3
069F8:  MOVFF  66C,6B2
069FC:  CLRF   xB5
069FE:  MOVLW  B5
06A00:  MOVWF  xB4
06A02:  MOVLB  0
06A04:  CALL   0876
06A08:  MOVFF  02,67F
06A0C:  MOVFF  01,67E
06A10:  MOVLW  06
06A12:  MOVLB  6
06A14:  ADDWF  x7E,F
06A16:  MOVLW  00
06A18:  ADDWFC x7F,F
06A1A:  MOVLW  4B
06A1C:  ADDWF  x7E,W
06A1E:  MOVWF  01
06A20:  MOVLW  00
06A22:  ADDWFC x7F,W
06A24:  MOVWF  03
06A26:  MOVF   01,W
06A28:  ADDLW  D1
06A2A:  MOVWF  01
06A2C:  MOVLW  01
06A2E:  ADDWFC 03,F
06A30:  MOVFF  01,67E
06A34:  MOVFF  03,67F
06A38:  MOVFF  03,6B3
06A3C:  MOVFF  01,6B2
06A40:  MOVLB  0
06A42:  CALL   59AA
06A46:  MOVFF  02,03
06A4A:  MOVF   01,W
06A4C:  SUBLW  01
06A4E:  BNZ   6A54
06A50:  MOVF   03,F
06A52:  BZ    6A5C
06A54:  MOVLW  02
06A56:  MOVWF  01
06A58:  BRA    6DEC
06A5A:  BRA    6A9C
....................    else arg2 = SERcmd[rec].p[3][0];
06A5C:  MOVLB  6
06A5E:  CLRF   xB3
06A60:  MOVFF  66C,6B2
06A64:  CLRF   xB5
06A66:  MOVLW  B5
06A68:  MOVWF  xB4
06A6A:  MOVLB  0
06A6C:  CALL   0876
06A70:  MOVFF  02,67F
06A74:  MOVFF  01,67E
06A78:  MOVLW  06
06A7A:  MOVLB  6
06A7C:  ADDWF  x7E,F
06A7E:  MOVLW  00
06A80:  ADDWFC x7F,F
06A82:  MOVLW  4B
06A84:  ADDWF  x7E,F
06A86:  MOVLW  00
06A88:  ADDWFC x7F,F
06A8A:  MOVLW  D1
06A8C:  ADDWF  x7E,W
06A8E:  MOVWF  FE9
06A90:  MOVLW  01
06A92:  ADDWFC x7F,W
06A94:  MOVWF  FEA
06A96:  MOVFF  FEF,67D
06A9A:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06A9C:  MOVLB  6
06A9E:  MOVF   x7D,W
06AA0:  SUBLW  50
06AA2:  BNZ   6B3C
06AA4:  MOVLW  04
06AA6:  MOVWF  xB3
06AA8:  MOVLW  A7
06AAA:  MOVWF  xB2
06AAC:  MOVLB  0
06AAE:  CALL   59AA
06AB2:  MOVFF  02,03
06AB6:  MOVF   01,W
06AB8:  ADDLW  A7
06ABA:  MOVLB  6
06ABC:  MOVWF  x7E
06ABE:  MOVLW  04
06AC0:  ADDWFC 02,W
06AC2:  MOVWF  x7F
06AC4:  MOVLW  01
06AC6:  SUBWF  x7C,W
06AC8:  MULLW  20
06ACA:  MOVF   FF3,W
06ACC:  CLRF   x81
06ACE:  MOVWF  x80
06AD0:  MOVLW  20
06AD2:  ADDWF  x80,W
06AD4:  MOVWF  FE9
06AD6:  MOVLW  00
06AD8:  ADDWFC x81,W
06ADA:  MOVWF  FEA
06ADC:  MOVFF  FEF,682
06AE0:  MOVFF  FEC,683
06AE4:  MOVFF  FEC,684
06AE8:  MOVFF  FEC,685
06AEC:  MOVFF  67F,54B
06AF0:  MOVFF  67E,54A
06AF4:  MOVFF  67C,6A5
06AF8:  MOVLW  18
06AFA:  MOVWF  xA6
06AFC:  MOVLB  0
06AFE:  CALL   5F66
06B02:  MOVLW  2C
06B04:  MOVLB  6
06B06:  MOVWF  xC1
06B08:  MOVLB  0
06B0A:  CALL   5A5A
06B0E:  MOVLW  89
06B10:  MOVWF  FE9
06B12:  MOVFF  685,6B7
06B16:  MOVFF  684,6B6
06B1A:  MOVFF  683,6B5
06B1E:  MOVFF  682,6B4
06B22:  MOVLW  02
06B24:  MOVLB  6
06B26:  MOVWF  xB8
06B28:  MOVLB  0
06B2A:  RCALL  6782
06B2C:  MOVLW  2C
06B2E:  MOVLB  6
06B30:  MOVWF  xC1
06B32:  MOVLB  0
06B34:  CALL   5A5A
06B38:  BRA    6DE8
06B3A:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06B3C:  MOVF   x7D,W
06B3E:  SUBLW  49
06B40:  BNZ   6BE2
06B42:  MOVLW  04
06B44:  MOVWF  xB3
06B46:  MOVLW  A7
06B48:  MOVWF  xB2
06B4A:  MOVLB  0
06B4C:  CALL   59AA
06B50:  MOVF   01,W
06B52:  ADDLW  A7
06B54:  MOVLB  6
06B56:  MOVWF  x7E
06B58:  MOVLW  04
06B5A:  ADDWFC 02,W
06B5C:  MOVWF  x7F
06B5E:  MOVLW  01
06B60:  SUBWF  x7C,W
06B62:  MULLW  20
06B64:  MOVF   FF3,W
06B66:  CLRF   x81
06B68:  MOVWF  x80
06B6A:  MOVLW  04
06B6C:  ADDWF  x80,W
06B6E:  MOVWF  01
06B70:  MOVLW  00
06B72:  ADDWFC x81,W
06B74:  MOVWF  03
06B76:  MOVF   01,W
06B78:  ADDLW  20
06B7A:  MOVWF  FE9
06B7C:  MOVLW  00
06B7E:  ADDWFC 03,W
06B80:  MOVWF  FEA
06B82:  MOVFF  FEF,680
06B86:  MOVFF  FEC,681
06B8A:  MOVFF  FEC,682
06B8E:  MOVFF  FEC,683
06B92:  MOVFF  67F,54B
06B96:  MOVFF  67E,54A
06B9A:  MOVFF  67C,6A5
06B9E:  MOVLW  18
06BA0:  MOVWF  xA6
06BA2:  MOVLB  0
06BA4:  CALL   5F66
06BA8:  MOVLW  2C
06BAA:  MOVLB  6
06BAC:  MOVWF  xC1
06BAE:  MOVLB  0
06BB0:  CALL   5A5A
06BB4:  MOVLW  89
06BB6:  MOVWF  FE9
06BB8:  MOVFF  683,6B7
06BBC:  MOVFF  682,6B6
06BC0:  MOVFF  681,6B5
06BC4:  MOVFF  680,6B4
06BC8:  MOVLW  02
06BCA:  MOVLB  6
06BCC:  MOVWF  xB8
06BCE:  MOVLB  0
06BD0:  RCALL  6782
06BD2:  MOVLW  2C
06BD4:  MOVLB  6
06BD6:  MOVWF  xC1
06BD8:  MOVLB  0
06BDA:  CALL   5A5A
06BDE:  BRA    6DE8
06BE0:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06BE2:  MOVF   x7D,W
06BE4:  SUBLW  44
06BE6:  BNZ   6C88
06BE8:  MOVLW  04
06BEA:  MOVWF  xB3
06BEC:  MOVLW  A7
06BEE:  MOVWF  xB2
06BF0:  MOVLB  0
06BF2:  CALL   59AA
06BF6:  MOVF   01,W
06BF8:  ADDLW  A7
06BFA:  MOVLB  6
06BFC:  MOVWF  x7E
06BFE:  MOVLW  04
06C00:  ADDWFC 02,W
06C02:  MOVWF  x7F
06C04:  MOVLW  01
06C06:  SUBWF  x7C,W
06C08:  MULLW  20
06C0A:  MOVF   FF3,W
06C0C:  CLRF   x81
06C0E:  MOVWF  x80
06C10:  MOVLW  08
06C12:  ADDWF  x80,W
06C14:  MOVWF  01
06C16:  MOVLW  00
06C18:  ADDWFC x81,W
06C1A:  MOVWF  03
06C1C:  MOVF   01,W
06C1E:  ADDLW  20
06C20:  MOVWF  FE9
06C22:  MOVLW  00
06C24:  ADDWFC 03,W
06C26:  MOVWF  FEA
06C28:  MOVFF  FEF,680
06C2C:  MOVFF  FEC,681
06C30:  MOVFF  FEC,682
06C34:  MOVFF  FEC,683
06C38:  MOVFF  67F,54B
06C3C:  MOVFF  67E,54A
06C40:  MOVFF  67C,6A5
06C44:  MOVLW  18
06C46:  MOVWF  xA6
06C48:  MOVLB  0
06C4A:  CALL   5F66
06C4E:  MOVLW  2C
06C50:  MOVLB  6
06C52:  MOVWF  xC1
06C54:  MOVLB  0
06C56:  CALL   5A5A
06C5A:  MOVLW  89
06C5C:  MOVWF  FE9
06C5E:  MOVFF  683,6B7
06C62:  MOVFF  682,6B6
06C66:  MOVFF  681,6B5
06C6A:  MOVFF  680,6B4
06C6E:  MOVLW  02
06C70:  MOVLB  6
06C72:  MOVWF  xB8
06C74:  MOVLB  0
06C76:  RCALL  6782
06C78:  MOVLW  2C
06C7A:  MOVLB  6
06C7C:  MOVWF  xC1
06C7E:  MOVLB  0
06C80:  CALL   5A5A
06C84:  BRA    6DE8
06C86:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06C88:  MOVF   x7D,W
06C8A:  SUBLW  41
06C8C:  BTFSS  FD8.2
06C8E:  BRA    6DE0
06C90:  MOVLW  04
06C92:  MOVWF  xB3
06C94:  MOVLW  A7
06C96:  MOVWF  xB2
06C98:  MOVLB  0
06C9A:  CALL   59AA
06C9E:  MOVF   01,W
06CA0:  ADDLW  A7
06CA2:  MOVLB  6
06CA4:  MOVWF  x7E
06CA6:  MOVLW  04
06CA8:  ADDWFC 02,W
06CAA:  MOVWF  x7F
06CAC:  MOVLW  01
06CAE:  SUBWF  x7C,W
06CB0:  MULLW  20
06CB2:  MOVF   FF3,W
06CB4:  CLRF   x81
06CB6:  MOVWF  x80
06CB8:  MOVLW  20
06CBA:  ADDWF  x80,W
06CBC:  MOVWF  FE9
06CBE:  MOVLW  00
06CC0:  ADDWFC x81,W
06CC2:  MOVWF  FEA
06CC4:  MOVFF  FEF,682
06CC8:  MOVFF  FEC,683
06CCC:  MOVFF  FEC,684
06CD0:  MOVFF  FEC,685
06CD4:  MOVLW  01
06CD6:  SUBWF  x7C,W
06CD8:  MULLW  20
06CDA:  MOVF   FF3,W
06CDC:  CLRF   x87
06CDE:  MOVWF  x86
06CE0:  MOVLW  04
06CE2:  ADDWF  x86,W
06CE4:  MOVWF  01
06CE6:  MOVLW  00
06CE8:  ADDWFC x87,W
06CEA:  MOVWF  03
06CEC:  MOVF   01,W
06CEE:  ADDLW  20
06CF0:  MOVWF  FE9
06CF2:  MOVLW  00
06CF4:  ADDWFC 03,W
06CF6:  MOVWF  FEA
06CF8:  MOVFF  FEF,686
06CFC:  MOVFF  FEC,687
06D00:  MOVFF  FEC,688
06D04:  MOVFF  FEC,689
06D08:  MOVLW  01
06D0A:  SUBWF  x7C,W
06D0C:  MULLW  20
06D0E:  MOVF   FF3,W
06D10:  CLRF   x8B
06D12:  MOVWF  x8A
06D14:  MOVLW  08
06D16:  ADDWF  x8A,W
06D18:  MOVWF  01
06D1A:  MOVLW  00
06D1C:  ADDWFC x8B,W
06D1E:  MOVWF  03
06D20:  MOVF   01,W
06D22:  ADDLW  20
06D24:  MOVWF  FE9
06D26:  MOVLW  00
06D28:  ADDWFC 03,W
06D2A:  MOVWF  FEA
06D2C:  MOVFF  FEF,68A
06D30:  MOVFF  FEC,68B
06D34:  MOVFF  FEC,68C
06D38:  MOVFF  FEC,68D
06D3C:  MOVFF  67F,54B
06D40:  MOVFF  67E,54A
06D44:  MOVFF  67C,6A5
06D48:  MOVLW  18
06D4A:  MOVWF  xA6
06D4C:  MOVLB  0
06D4E:  CALL   5F66
06D52:  MOVLW  2C
06D54:  MOVLB  6
06D56:  MOVWF  xC1
06D58:  MOVLB  0
06D5A:  CALL   5A5A
06D5E:  MOVLW  89
06D60:  MOVWF  FE9
06D62:  MOVFF  685,6B7
06D66:  MOVFF  684,6B6
06D6A:  MOVFF  683,6B5
06D6E:  MOVFF  682,6B4
06D72:  MOVLW  02
06D74:  MOVLB  6
06D76:  MOVWF  xB8
06D78:  MOVLB  0
06D7A:  RCALL  6782
06D7C:  MOVLW  2C
06D7E:  MOVLB  6
06D80:  MOVWF  xC1
06D82:  MOVLB  0
06D84:  CALL   5A5A
06D88:  MOVLW  89
06D8A:  MOVWF  FE9
06D8C:  MOVFF  689,6B7
06D90:  MOVFF  688,6B6
06D94:  MOVFF  687,6B5
06D98:  MOVFF  686,6B4
06D9C:  MOVLW  02
06D9E:  MOVLB  6
06DA0:  MOVWF  xB8
06DA2:  MOVLB  0
06DA4:  RCALL  6782
06DA6:  MOVLW  2C
06DA8:  MOVLB  6
06DAA:  MOVWF  xC1
06DAC:  MOVLB  0
06DAE:  CALL   5A5A
06DB2:  MOVLW  89
06DB4:  MOVWF  FE9
06DB6:  MOVFF  68D,6B7
06DBA:  MOVFF  68C,6B6
06DBE:  MOVFF  68B,6B5
06DC2:  MOVFF  68A,6B4
06DC6:  MOVLW  02
06DC8:  MOVLB  6
06DCA:  MOVWF  xB8
06DCC:  MOVLB  0
06DCE:  RCALL  6782
06DD0:  MOVLW  2C
06DD2:  MOVLB  6
06DD4:  MOVWF  xC1
06DD6:  MOVLB  0
06DD8:  CALL   5A5A
06DDC:  BRA    6DE8
06DDE:  MOVLB  6
....................    else return INV_PARAM;
06DE0:  MOVLW  02
06DE2:  MOVWF  01
06DE4:  MOVLB  0
06DE6:  BRA    6DEC
....................    
....................    return SUCCESS;
06DE8:  MOVLW  00
06DEA:  MOVWF  01
06DEC:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0710A:  MOVLB  6
0710C:  CLRF   xB3
0710E:  MOVFF  66C,6B2
07112:  CLRF   xB5
07114:  MOVLW  B5
07116:  MOVWF  xB4
07118:  MOVLB  0
0711A:  CALL   0876
0711E:  MOVFF  02,683
07122:  MOVFF  01,682
07126:  MOVLW  06
07128:  MOVLB  6
0712A:  ADDWF  x82,F
0712C:  MOVLW  00
0712E:  ADDWFC x83,F
07130:  MOVLW  32
07132:  ADDWF  x82,W
07134:  MOVWF  01
07136:  MOVLW  00
07138:  ADDWFC x83,W
0713A:  MOVWF  03
0713C:  MOVF   01,W
0713E:  ADDLW  D1
07140:  MOVWF  01
07142:  MOVLW  01
07144:  ADDWFC 03,F
07146:  MOVFF  01,682
0714A:  MOVFF  03,683
0714E:  MOVFF  03,6A5
07152:  MOVFF  01,6A4
07156:  MOVLB  0
07158:  CALL   5B22
0715C:  MOVF   01,F
0715E:  BNZ   7168
07160:  MOVLW  02
07162:  MOVWF  01
07164:  BRA    73E8
07166:  BRA    71C6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07168:  MOVLB  6
0716A:  CLRF   xB3
0716C:  MOVFF  66C,6B2
07170:  CLRF   xB5
07172:  MOVLW  B5
07174:  MOVWF  xB4
07176:  MOVLB  0
07178:  CALL   0876
0717C:  MOVFF  02,683
07180:  MOVFF  01,682
07184:  MOVLW  06
07186:  MOVLB  6
07188:  ADDWF  x82,F
0718A:  MOVLW  00
0718C:  ADDWFC x83,F
0718E:  MOVLW  32
07190:  ADDWF  x82,W
07192:  MOVWF  01
07194:  MOVLW  00
07196:  ADDWFC x83,W
07198:  MOVWF  03
0719A:  MOVF   01,W
0719C:  ADDLW  D1
0719E:  MOVWF  01
071A0:  MOVLW  01
071A2:  ADDWFC 03,F
071A4:  MOVFF  01,682
071A8:  MOVFF  03,683
071AC:  MOVFF  03,6A5
071B0:  MOVFF  01,6A4
071B4:  CLRF   xA7
071B6:  CLRF   xA6
071B8:  MOVLW  0A
071BA:  MOVWF  xA8
071BC:  MOVLB  0
071BE:  CALL   5C12
071C2:  MOVFF  01,67C
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
071C6:  MOVLB  6
071C8:  CLRF   xB3
071CA:  MOVFF  66C,6B2
071CE:  CLRF   xB5
071D0:  MOVLW  B5
071D2:  MOVWF  xB4
071D4:  MOVLB  0
071D6:  CALL   0876
071DA:  MOVFF  02,683
071DE:  MOVFF  01,682
071E2:  MOVLW  06
071E4:  MOVLB  6
071E6:  ADDWF  x82,F
071E8:  MOVLW  00
071EA:  ADDWFC x83,F
071EC:  MOVLW  4B
071EE:  ADDWF  x82,W
071F0:  MOVWF  01
071F2:  MOVLW  00
071F4:  ADDWFC x83,W
071F6:  MOVWF  03
071F8:  MOVF   01,W
071FA:  ADDLW  D1
071FC:  MOVWF  01
071FE:  MOVLW  01
07200:  ADDWFC 03,F
07202:  MOVFF  01,682
07206:  MOVFF  03,683
0720A:  MOVFF  03,6B3
0720E:  MOVFF  01,6B2
07212:  MOVLB  0
07214:  CALL   59AA
07218:  MOVFF  02,03
0721C:  MOVF   01,W
0721E:  SUBLW  01
07220:  BNZ   7226
07222:  MOVF   03,F
07224:  BZ    722E
07226:  MOVLW  02
07228:  MOVWF  01
0722A:  BRA    73E8
0722C:  BRA    726E
....................    else arg2 = SERcmd[rec].p[3][0];
0722E:  MOVLB  6
07230:  CLRF   xB3
07232:  MOVFF  66C,6B2
07236:  CLRF   xB5
07238:  MOVLW  B5
0723A:  MOVWF  xB4
0723C:  MOVLB  0
0723E:  CALL   0876
07242:  MOVFF  02,683
07246:  MOVFF  01,682
0724A:  MOVLW  06
0724C:  MOVLB  6
0724E:  ADDWF  x82,F
07250:  MOVLW  00
07252:  ADDWFC x83,F
07254:  MOVLW  4B
07256:  ADDWF  x82,F
07258:  MOVLW  00
0725A:  ADDWFC x83,F
0725C:  MOVLW  D1
0725E:  ADDWF  x82,W
07260:  MOVWF  FE9
07262:  MOVLW  01
07264:  ADDWFC x83,W
07266:  MOVWF  FEA
07268:  MOVFF  FEF,67D
0726C:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0726E:  MOVLB  6
07270:  CLRF   xB3
07272:  MOVFF  66C,6B2
07276:  CLRF   xB5
07278:  MOVLW  B5
0727A:  MOVWF  xB4
0727C:  MOVLB  0
0727E:  CALL   0876
07282:  MOVFF  02,683
07286:  MOVFF  01,682
0728A:  MOVLW  06
0728C:  MOVLB  6
0728E:  ADDWF  x82,F
07290:  MOVLW  00
07292:  ADDWFC x83,F
07294:  MOVLW  64
07296:  ADDWF  x82,W
07298:  MOVWF  01
0729A:  MOVLW  00
0729C:  ADDWFC x83,W
0729E:  MOVWF  03
072A0:  MOVF   01,W
072A2:  ADDLW  D1
072A4:  MOVWF  01
072A6:  MOVLW  01
072A8:  ADDWFC 03,F
072AA:  MOVFF  01,682
072AE:  MOVFF  03,683
072B2:  MOVFF  03,686
072B6:  MOVFF  01,685
072BA:  MOVLB  0
072BC:  RCALL  6DEE
072BE:  MOVF   01,F
072C0:  BNZ   72CA
072C2:  MOVLW  02
072C4:  MOVWF  01
072C6:  BRA    73E8
072C8:  BRA    732E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
072CA:  MOVLB  6
072CC:  CLRF   xB3
072CE:  MOVFF  66C,6B2
072D2:  CLRF   xB5
072D4:  MOVLW  B5
072D6:  MOVWF  xB4
072D8:  MOVLB  0
072DA:  CALL   0876
072DE:  MOVFF  02,683
072E2:  MOVFF  01,682
072E6:  MOVLW  06
072E8:  MOVLB  6
072EA:  ADDWF  x82,F
072EC:  MOVLW  00
072EE:  ADDWFC x83,F
072F0:  MOVLW  64
072F2:  ADDWF  x82,W
072F4:  MOVWF  01
072F6:  MOVLW  00
072F8:  ADDWFC x83,W
072FA:  MOVWF  03
072FC:  MOVF   01,W
072FE:  ADDLW  D1
07300:  MOVWF  01
07302:  MOVLW  01
07304:  ADDWFC 03,F
07306:  MOVFF  01,682
0730A:  MOVFF  03,683
0730E:  MOVFF  03,686
07312:  MOVFF  01,685
07316:  CLRF   x88
07318:  CLRF   x87
0731A:  MOVLB  0
0731C:  RCALL  6EB0
0731E:  MOVFF  03,681
07322:  MOVFF  02,680
07326:  MOVFF  01,67F
0732A:  MOVFF  00,67E
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
0732E:  MOVLB  6
07330:  MOVF   x7D,W
07332:  SUBLW  50
07334:  BNZ   7360
07336:  MOVLW  01
07338:  SUBWF  x7C,W
0733A:  MULLW  20
0733C:  MOVF   FF3,W
0733E:  CLRF   x83
07340:  MOVWF  x82
07342:  MOVLW  20
07344:  ADDWF  x82,W
07346:  MOVWF  FE9
07348:  MOVLW  00
0734A:  ADDWFC x83,W
0734C:  MOVWF  FEA
0734E:  MOVFF  67E,FEF
07352:  MOVFF  67F,FEC
07356:  MOVFF  680,FEC
0735A:  MOVFF  681,FEC
0735E:  BRA    73E2
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07360:  MOVF   x7D,W
07362:  SUBLW  49
07364:  BNZ   739C
07366:  MOVLW  01
07368:  SUBWF  x7C,W
0736A:  MULLW  20
0736C:  MOVF   FF3,W
0736E:  CLRF   x83
07370:  MOVWF  x82
07372:  MOVLW  04
07374:  ADDWF  x82,W
07376:  MOVWF  01
07378:  MOVLW  00
0737A:  ADDWFC x83,W
0737C:  MOVWF  03
0737E:  MOVF   01,W
07380:  ADDLW  20
07382:  MOVWF  FE9
07384:  MOVLW  00
07386:  ADDWFC 03,W
07388:  MOVWF  FEA
0738A:  MOVFF  67E,FEF
0738E:  MOVFF  67F,FEC
07392:  MOVFF  680,FEC
07396:  MOVFF  681,FEC
0739A:  BRA    73E2
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
0739C:  MOVF   x7D,W
0739E:  SUBLW  44
073A0:  BNZ   73D8
073A2:  MOVLW  01
073A4:  SUBWF  x7C,W
073A6:  MULLW  20
073A8:  MOVF   FF3,W
073AA:  CLRF   x83
073AC:  MOVWF  x82
073AE:  MOVLW  08
073B0:  ADDWF  x82,W
073B2:  MOVWF  01
073B4:  MOVLW  00
073B6:  ADDWFC x83,W
073B8:  MOVWF  03
073BA:  MOVF   01,W
073BC:  ADDLW  20
073BE:  MOVWF  FE9
073C0:  MOVLW  00
073C2:  ADDWFC 03,W
073C4:  MOVWF  FEA
073C6:  MOVFF  67E,FEF
073CA:  MOVFF  67F,FEC
073CE:  MOVFF  680,FEC
073D2:  MOVFF  681,FEC
073D6:  BRA    73E2
....................    else return INV_PARAM;
073D8:  MOVLW  02
073DA:  MOVWF  01
073DC:  MOVLB  0
073DE:  BRA    73E8
073E0:  MOVLB  6
....................    
....................    return SUCCESS;
073E2:  MOVLW  00
073E4:  MOVWF  01
073E6:  MOVLB  0
073E8:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
073EA:  MOVLB  6
073EC:  CLRF   xB3
073EE:  MOVFF  66C,6B2
073F2:  CLRF   xB5
073F4:  MOVLW  B5
073F6:  MOVWF  xB4
073F8:  MOVLB  0
073FA:  CALL   0876
073FE:  MOVFF  02,67E
07402:  MOVFF  01,67D
07406:  MOVLW  06
07408:  MOVLB  6
0740A:  ADDWF  x7D,F
0740C:  MOVLW  00
0740E:  ADDWFC x7E,F
07410:  MOVLW  32
07412:  ADDWF  x7D,W
07414:  MOVWF  01
07416:  MOVLW  00
07418:  ADDWFC x7E,W
0741A:  MOVWF  03
0741C:  MOVF   01,W
0741E:  ADDLW  D1
07420:  MOVWF  01
07422:  MOVLW  01
07424:  ADDWFC 03,F
07426:  MOVFF  01,67D
0742A:  MOVFF  03,67E
0742E:  MOVFF  03,6A5
07432:  MOVFF  01,6A4
07436:  MOVLB  0
07438:  CALL   5B22
0743C:  MOVF   01,F
0743E:  BNZ   7448
07440:  MOVLW  02
07442:  MOVWF  01
07444:  BRA    754A
07446:  BRA    74A6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07448:  MOVLB  6
0744A:  CLRF   xB3
0744C:  MOVFF  66C,6B2
07450:  CLRF   xB5
07452:  MOVLW  B5
07454:  MOVWF  xB4
07456:  MOVLB  0
07458:  CALL   0876
0745C:  MOVFF  02,67E
07460:  MOVFF  01,67D
07464:  MOVLW  06
07466:  MOVLB  6
07468:  ADDWF  x7D,F
0746A:  MOVLW  00
0746C:  ADDWFC x7E,F
0746E:  MOVLW  32
07470:  ADDWF  x7D,W
07472:  MOVWF  01
07474:  MOVLW  00
07476:  ADDWFC x7E,W
07478:  MOVWF  03
0747A:  MOVF   01,W
0747C:  ADDLW  D1
0747E:  MOVWF  01
07480:  MOVLW  01
07482:  ADDWFC 03,F
07484:  MOVFF  01,67D
07488:  MOVFF  03,67E
0748C:  MOVFF  03,6A5
07490:  MOVFF  01,6A4
07494:  CLRF   xA7
07496:  CLRF   xA6
07498:  MOVLW  0A
0749A:  MOVWF  xA8
0749C:  MOVLB  0
0749E:  CALL   5C12
074A2:  MOVFF  01,67C
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
074A6:  MOVLW  04
074A8:  MOVLB  6
074AA:  MOVWF  xB3
074AC:  MOVLW  A7
074AE:  MOVWF  xB2
074B0:  MOVLB  0
074B2:  CALL   59AA
074B6:  MOVF   01,W
074B8:  ADDLW  A7
074BA:  MOVLB  6
074BC:  MOVWF  x7D
074BE:  MOVLW  04
074C0:  ADDWFC 02,W
074C2:  MOVWF  x7E
074C4:  MOVLW  01
074C6:  SUBWF  x7C,W
074C8:  MULLW  20
074CA:  MOVF   FF3,W
074CC:  CLRF   x80
074CE:  MOVWF  x7F
074D0:  MOVLW  0C
074D2:  ADDWF  x7F,W
074D4:  MOVWF  01
074D6:  MOVLW  00
074D8:  ADDWFC x80,W
074DA:  MOVWF  03
074DC:  MOVF   01,W
074DE:  ADDLW  20
074E0:  MOVWF  FE9
074E2:  MOVLW  00
074E4:  ADDWFC 03,W
074E6:  MOVWF  FEA
074E8:  MOVFF  FEF,67F
074EC:  MOVFF  FEC,680
074F0:  MOVFF  FEC,681
074F4:  MOVFF  FEC,682
074F8:  MOVFF  67E,54B
074FC:  MOVFF  67D,54A
07500:  MOVFF  67C,6A5
07504:  MOVLW  18
07506:  MOVWF  xA6
07508:  MOVLB  0
0750A:  CALL   5F66
0750E:  MOVLW  2C
07510:  MOVLB  6
07512:  MOVWF  xC1
07514:  MOVLB  0
07516:  CALL   5A5A
0751A:  MOVLW  89
0751C:  MOVWF  FE9
0751E:  MOVFF  682,6B7
07522:  MOVFF  681,6B6
07526:  MOVFF  680,6B5
0752A:  MOVFF  67F,6B4
0752E:  MOVLW  02
07530:  MOVLB  6
07532:  MOVWF  xB8
07534:  MOVLB  0
07536:  CALL   6782
0753A:  MOVLW  2C
0753C:  MOVLB  6
0753E:  MOVWF  xC1
07540:  MOVLB  0
07542:  CALL   5A5A
....................    return SUCCESS;
07546:  MOVLW  00
07548:  MOVWF  01
0754A:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0754C:  MOVLB  6
0754E:  CLRF   xB3
07550:  MOVFF  66C,6B2
07554:  CLRF   xB5
07556:  MOVLW  B5
07558:  MOVWF  xB4
0755A:  MOVLB  0
0755C:  CALL   0876
07560:  MOVFF  02,682
07564:  MOVFF  01,681
07568:  MOVLW  06
0756A:  MOVLB  6
0756C:  ADDWF  x81,F
0756E:  MOVLW  00
07570:  ADDWFC x82,F
07572:  MOVLW  32
07574:  ADDWF  x81,W
07576:  MOVWF  01
07578:  MOVLW  00
0757A:  ADDWFC x82,W
0757C:  MOVWF  03
0757E:  MOVF   01,W
07580:  ADDLW  D1
07582:  MOVWF  01
07584:  MOVLW  01
07586:  ADDWFC 03,F
07588:  MOVFF  01,681
0758C:  MOVFF  03,682
07590:  MOVFF  03,6A5
07594:  MOVFF  01,6A4
07598:  MOVLB  0
0759A:  CALL   5B22
0759E:  MOVF   01,F
075A0:  BNZ   75AA
075A2:  MOVLW  02
075A4:  MOVWF  01
075A6:  BRA    7708
075A8:  BRA    7608
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
075AA:  MOVLB  6
075AC:  CLRF   xB3
075AE:  MOVFF  66C,6B2
075B2:  CLRF   xB5
075B4:  MOVLW  B5
075B6:  MOVWF  xB4
075B8:  MOVLB  0
075BA:  CALL   0876
075BE:  MOVFF  02,682
075C2:  MOVFF  01,681
075C6:  MOVLW  06
075C8:  MOVLB  6
075CA:  ADDWF  x81,F
075CC:  MOVLW  00
075CE:  ADDWFC x82,F
075D0:  MOVLW  32
075D2:  ADDWF  x81,W
075D4:  MOVWF  01
075D6:  MOVLW  00
075D8:  ADDWFC x82,W
075DA:  MOVWF  03
075DC:  MOVF   01,W
075DE:  ADDLW  D1
075E0:  MOVWF  01
075E2:  MOVLW  01
075E4:  ADDWFC 03,F
075E6:  MOVFF  01,681
075EA:  MOVFF  03,682
075EE:  MOVFF  03,6A5
075F2:  MOVFF  01,6A4
075F6:  CLRF   xA7
075F8:  CLRF   xA6
075FA:  MOVLW  0A
075FC:  MOVWF  xA8
075FE:  MOVLB  0
07600:  CALL   5C12
07604:  MOVFF  01,67C
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07608:  MOVLB  6
0760A:  CLRF   xB3
0760C:  MOVFF  66C,6B2
07610:  CLRF   xB5
07612:  MOVLW  B5
07614:  MOVWF  xB4
07616:  MOVLB  0
07618:  CALL   0876
0761C:  MOVFF  02,682
07620:  MOVFF  01,681
07624:  MOVLW  06
07626:  MOVLB  6
07628:  ADDWF  x81,F
0762A:  MOVLW  00
0762C:  ADDWFC x82,F
0762E:  MOVLW  4B
07630:  ADDWF  x81,W
07632:  MOVWF  01
07634:  MOVLW  00
07636:  ADDWFC x82,W
07638:  MOVWF  03
0763A:  MOVF   01,W
0763C:  ADDLW  D1
0763E:  MOVWF  01
07640:  MOVLW  01
07642:  ADDWFC 03,F
07644:  MOVFF  01,681
07648:  MOVFF  03,682
0764C:  MOVFF  03,686
07650:  MOVFF  01,685
07654:  MOVLB  0
07656:  CALL   6DEE
0765A:  MOVF   01,F
0765C:  BNZ   7666
0765E:  MOVLW  02
07660:  MOVWF  01
07662:  BRA    7708
07664:  BRA    76CC
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
07666:  MOVLB  6
07668:  CLRF   xB3
0766A:  MOVFF  66C,6B2
0766E:  CLRF   xB5
07670:  MOVLW  B5
07672:  MOVWF  xB4
07674:  MOVLB  0
07676:  CALL   0876
0767A:  MOVFF  02,682
0767E:  MOVFF  01,681
07682:  MOVLW  06
07684:  MOVLB  6
07686:  ADDWF  x81,F
07688:  MOVLW  00
0768A:  ADDWFC x82,F
0768C:  MOVLW  4B
0768E:  ADDWF  x81,W
07690:  MOVWF  01
07692:  MOVLW  00
07694:  ADDWFC x82,W
07696:  MOVWF  03
07698:  MOVF   01,W
0769A:  ADDLW  D1
0769C:  MOVWF  01
0769E:  MOVLW  01
076A0:  ADDWFC 03,F
076A2:  MOVFF  01,681
076A6:  MOVFF  03,682
076AA:  MOVFF  03,686
076AE:  MOVFF  01,685
076B2:  CLRF   x88
076B4:  CLRF   x87
076B6:  MOVLB  0
076B8:  CALL   6EB0
076BC:  MOVFF  03,680
076C0:  MOVFF  02,67F
076C4:  MOVFF  01,67E
076C8:  MOVFF  00,67D
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
076CC:  MOVLW  01
076CE:  MOVLB  6
076D0:  SUBWF  x7C,W
076D2:  MULLW  20
076D4:  MOVF   FF3,W
076D6:  CLRF   x82
076D8:  MOVWF  x81
076DA:  MOVLW  0C
076DC:  ADDWF  x81,W
076DE:  MOVWF  01
076E0:  MOVLW  00
076E2:  ADDWFC x82,W
076E4:  MOVWF  03
076E6:  MOVF   01,W
076E8:  ADDLW  20
076EA:  MOVWF  FE9
076EC:  MOVLW  00
076EE:  ADDWFC 03,W
076F0:  MOVWF  FEA
076F2:  MOVFF  67D,FEF
076F6:  MOVFF  67E,FEC
076FA:  MOVFF  67F,FEC
076FE:  MOVFF  680,FEC
....................    
....................    return SUCCESS;
07702:  MOVLW  00
07704:  MOVWF  01
07706:  MOVLB  0
07708:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0770A:  MOVLB  6
0770C:  CLRF   xB3
0770E:  MOVFF  66C,6B2
07712:  CLRF   xB5
07714:  MOVLW  B5
07716:  MOVWF  xB4
07718:  MOVLB  0
0771A:  CALL   0876
0771E:  MOVFF  02,67E
07722:  MOVFF  01,67D
07726:  MOVLW  06
07728:  MOVLB  6
0772A:  ADDWF  x7D,F
0772C:  MOVLW  00
0772E:  ADDWFC x7E,F
07730:  MOVLW  32
07732:  ADDWF  x7D,W
07734:  MOVWF  01
07736:  MOVLW  00
07738:  ADDWFC x7E,W
0773A:  MOVWF  03
0773C:  MOVF   01,W
0773E:  ADDLW  D1
07740:  MOVWF  01
07742:  MOVLW  01
07744:  ADDWFC 03,F
07746:  MOVFF  01,67D
0774A:  MOVFF  03,67E
0774E:  MOVFF  03,6A5
07752:  MOVFF  01,6A4
07756:  MOVLB  0
07758:  CALL   5B22
0775C:  MOVF   01,F
0775E:  BNZ   7768
07760:  MOVLW  02
07762:  MOVWF  01
07764:  BRA    7ABE
07766:  BRA    77C6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07768:  MOVLB  6
0776A:  CLRF   xB3
0776C:  MOVFF  66C,6B2
07770:  CLRF   xB5
07772:  MOVLW  B5
07774:  MOVWF  xB4
07776:  MOVLB  0
07778:  CALL   0876
0777C:  MOVFF  02,67E
07780:  MOVFF  01,67D
07784:  MOVLW  06
07786:  MOVLB  6
07788:  ADDWF  x7D,F
0778A:  MOVLW  00
0778C:  ADDWFC x7E,F
0778E:  MOVLW  32
07790:  ADDWF  x7D,W
07792:  MOVWF  01
07794:  MOVLW  00
07796:  ADDWFC x7E,W
07798:  MOVWF  03
0779A:  MOVF   01,W
0779C:  ADDLW  D1
0779E:  MOVWF  01
077A0:  MOVLW  01
077A2:  ADDWFC 03,F
077A4:  MOVFF  01,67D
077A8:  MOVFF  03,67E
077AC:  MOVFF  03,6A5
077B0:  MOVFF  01,6A4
077B4:  CLRF   xA7
077B6:  CLRF   xA6
077B8:  MOVLW  0A
077BA:  MOVWF  xA8
077BC:  MOVLB  0
077BE:  CALL   5C12
077C2:  MOVFF  01,67C
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
077C6:  MOVLW  04
077C8:  MOVLB  6
077CA:  MOVWF  xB3
077CC:  MOVLW  A7
077CE:  MOVWF  xB2
077D0:  MOVLB  0
077D2:  CALL   59AA
077D6:  MOVFF  02,03
077DA:  MOVF   01,W
077DC:  ADDLW  A7
077DE:  MOVLB  6
077E0:  MOVWF  x7D
077E2:  MOVLW  04
077E4:  ADDWFC 02,W
077E6:  MOVWF  x7E
077E8:  MOVFF  FE8,54B
077EC:  MOVFF  67D,54A
077F0:  MOVFF  67C,6A5
077F4:  MOVLW  18
077F6:  MOVWF  xA6
077F8:  MOVLB  0
077FA:  CALL   5F66
077FE:  MOVLW  2C
07800:  MOVLB  6
07802:  MOVWF  xC1
07804:  MOVLB  0
07806:  CALL   5A5A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0780A:  MOVLW  04
0780C:  MOVLB  6
0780E:  MOVWF  xB3
07810:  MOVLW  A7
07812:  MOVWF  xB2
07814:  MOVLB  0
07816:  CALL   59AA
0781A:  MOVFF  02,03
0781E:  MOVF   01,W
07820:  ADDLW  A7
07822:  MOVLB  6
07824:  MOVWF  x7D
07826:  MOVLW  04
07828:  ADDWFC 02,W
0782A:  MOVWF  x7E
0782C:  MOVLW  01
0782E:  SUBWF  x7C,W
07830:  MULLW  18
07832:  MOVF   FF3,W
07834:  CLRF   x80
07836:  MOVWF  x7F
07838:  MOVLW  82
0783A:  ADDWF  x7F,W
0783C:  MOVWF  FE9
0783E:  MOVLW  00
07840:  ADDWFC x80,W
07842:  MOVWF  FEA
07844:  MOVFF  FEF,6B4
07848:  MOVFF  FEC,6B5
0784C:  MOVFF  FEC,6B6
07850:  MOVFF  FEC,6B7
07854:  MOVFF  67E,54B
07858:  MOVFF  67D,54A
0785C:  MOVLW  89
0785E:  MOVWF  FE9
07860:  MOVLW  02
07862:  MOVWF  xB8
07864:  MOVLB  0
07866:  CALL   6782
0786A:  MOVLW  2C
0786C:  MOVLB  6
0786E:  MOVWF  xC1
07870:  MOVLB  0
07872:  CALL   5A5A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07876:  MOVLW  04
07878:  MOVLB  6
0787A:  MOVWF  xB3
0787C:  MOVLW  A7
0787E:  MOVWF  xB2
07880:  MOVLB  0
07882:  CALL   59AA
07886:  MOVF   01,W
07888:  ADDLW  A7
0788A:  MOVLB  6
0788C:  MOVWF  x7D
0788E:  MOVLW  04
07890:  ADDWFC 02,W
07892:  MOVWF  x7E
07894:  MOVLW  01
07896:  SUBWF  x7C,W
07898:  MULLW  18
0789A:  MOVF   FF3,W
0789C:  CLRF   x80
0789E:  MOVWF  x7F
078A0:  MOVLW  04
078A2:  ADDWF  x7F,W
078A4:  MOVWF  01
078A6:  MOVLW  00
078A8:  ADDWFC x80,W
078AA:  MOVWF  03
078AC:  MOVF   01,W
078AE:  ADDLW  82
078B0:  MOVWF  FE9
078B2:  MOVLW  00
078B4:  ADDWFC 03,W
078B6:  MOVWF  FEA
078B8:  MOVFF  FEF,6B4
078BC:  MOVFF  FEC,6B5
078C0:  MOVFF  FEC,6B6
078C4:  MOVFF  FEC,6B7
078C8:  MOVFF  67E,54B
078CC:  MOVFF  67D,54A
078D0:  MOVLW  89
078D2:  MOVWF  FE9
078D4:  MOVLW  02
078D6:  MOVWF  xB8
078D8:  MOVLB  0
078DA:  CALL   6782
078DE:  MOVLW  2C
078E0:  MOVLB  6
078E2:  MOVWF  xC1
078E4:  MOVLB  0
078E6:  CALL   5A5A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
078EA:  MOVLW  04
078EC:  MOVLB  6
078EE:  MOVWF  xB3
078F0:  MOVLW  A7
078F2:  MOVWF  xB2
078F4:  MOVLB  0
078F6:  CALL   59AA
078FA:  MOVF   01,W
078FC:  ADDLW  A7
078FE:  MOVLB  6
07900:  MOVWF  x7D
07902:  MOVLW  04
07904:  ADDWFC 02,W
07906:  MOVWF  x7E
07908:  MOVLW  01
0790A:  SUBWF  x7C,W
0790C:  MULLW  18
0790E:  MOVF   FF3,W
07910:  CLRF   x80
07912:  MOVWF  x7F
07914:  MOVLW  08
07916:  ADDWF  x7F,W
07918:  MOVWF  01
0791A:  MOVLW  00
0791C:  ADDWFC x80,W
0791E:  MOVWF  03
07920:  MOVF   01,W
07922:  ADDLW  82
07924:  MOVWF  FE9
07926:  MOVLW  00
07928:  ADDWFC 03,W
0792A:  MOVWF  FEA
0792C:  MOVFF  FEF,6B4
07930:  MOVFF  FEC,6B5
07934:  MOVFF  FEC,6B6
07938:  MOVFF  FEC,6B7
0793C:  MOVFF  67E,54B
07940:  MOVFF  67D,54A
07944:  MOVLW  89
07946:  MOVWF  FE9
07948:  MOVLW  02
0794A:  MOVWF  xB8
0794C:  MOVLB  0
0794E:  CALL   6782
07952:  MOVLW  2C
07954:  MOVLB  6
07956:  MOVWF  xC1
07958:  MOVLB  0
0795A:  CALL   5A5A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
0795E:  MOVLW  04
07960:  MOVLB  6
07962:  MOVWF  xB3
07964:  MOVLW  A7
07966:  MOVWF  xB2
07968:  MOVLB  0
0796A:  CALL   59AA
0796E:  MOVF   01,W
07970:  ADDLW  A7
07972:  MOVLB  6
07974:  MOVWF  x7D
07976:  MOVLW  04
07978:  ADDWFC 02,W
0797A:  MOVWF  x7E
0797C:  MOVLW  01
0797E:  SUBWF  x7C,W
07980:  MULLW  18
07982:  MOVF   FF3,W
07984:  CLRF   x80
07986:  MOVWF  x7F
07988:  MOVLW  0C
0798A:  ADDWF  x7F,W
0798C:  MOVWF  01
0798E:  MOVLW  00
07990:  ADDWFC x80,W
07992:  MOVWF  03
07994:  MOVF   01,W
07996:  ADDLW  82
07998:  MOVWF  FE9
0799A:  MOVLW  00
0799C:  ADDWFC 03,W
0799E:  MOVWF  FEA
079A0:  MOVFF  FEF,6B4
079A4:  MOVFF  FEC,6B5
079A8:  MOVFF  FEC,6B6
079AC:  MOVFF  FEC,6B7
079B0:  MOVFF  67E,54B
079B4:  MOVFF  67D,54A
079B8:  MOVLW  89
079BA:  MOVWF  FE9
079BC:  MOVLW  02
079BE:  MOVWF  xB8
079C0:  MOVLB  0
079C2:  CALL   6782
079C6:  MOVLW  2C
079C8:  MOVLB  6
079CA:  MOVWF  xC1
079CC:  MOVLB  0
079CE:  CALL   5A5A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
079D2:  MOVLW  04
079D4:  MOVLB  6
079D6:  MOVWF  xB3
079D8:  MOVLW  A7
079DA:  MOVWF  xB2
079DC:  MOVLB  0
079DE:  CALL   59AA
079E2:  MOVF   01,W
079E4:  ADDLW  A7
079E6:  MOVLB  6
079E8:  MOVWF  x7D
079EA:  MOVLW  04
079EC:  ADDWFC 02,W
079EE:  MOVWF  x7E
079F0:  MOVLW  01
079F2:  SUBWF  x7C,W
079F4:  MULLW  18
079F6:  MOVF   FF3,W
079F8:  CLRF   x80
079FA:  MOVWF  x7F
079FC:  MOVLW  10
079FE:  ADDWF  x7F,W
07A00:  MOVWF  01
07A02:  MOVLW  00
07A04:  ADDWFC x80,W
07A06:  MOVWF  03
07A08:  MOVF   01,W
07A0A:  ADDLW  82
07A0C:  MOVWF  FE9
07A0E:  MOVLW  00
07A10:  ADDWFC 03,W
07A12:  MOVWF  FEA
07A14:  MOVFF  FEF,6B4
07A18:  MOVFF  FEC,6B5
07A1C:  MOVFF  FEC,6B6
07A20:  MOVFF  FEC,6B7
07A24:  MOVFF  67E,54B
07A28:  MOVFF  67D,54A
07A2C:  MOVLW  89
07A2E:  MOVWF  FE9
07A30:  MOVLW  02
07A32:  MOVWF  xB8
07A34:  MOVLB  0
07A36:  CALL   6782
07A3A:  MOVLW  2C
07A3C:  MOVLB  6
07A3E:  MOVWF  xC1
07A40:  MOVLB  0
07A42:  CALL   5A5A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07A46:  MOVLW  04
07A48:  MOVLB  6
07A4A:  MOVWF  xB3
07A4C:  MOVLW  A7
07A4E:  MOVWF  xB2
07A50:  MOVLB  0
07A52:  CALL   59AA
07A56:  MOVF   01,W
07A58:  ADDLW  A7
07A5A:  MOVLB  6
07A5C:  MOVWF  x7D
07A5E:  MOVLW  04
07A60:  ADDWFC 02,W
07A62:  MOVWF  x7E
07A64:  MOVLW  01
07A66:  SUBWF  x7C,W
07A68:  MULLW  18
07A6A:  MOVF   FF3,W
07A6C:  CLRF   x80
07A6E:  MOVWF  x7F
07A70:  MOVLW  14
07A72:  ADDWF  x7F,W
07A74:  MOVWF  01
07A76:  MOVLW  00
07A78:  ADDWFC x80,W
07A7A:  MOVWF  03
07A7C:  MOVF   01,W
07A7E:  ADDLW  82
07A80:  MOVWF  FE9
07A82:  MOVLW  00
07A84:  ADDWFC 03,W
07A86:  MOVWF  FEA
07A88:  MOVFF  FEF,6B4
07A8C:  MOVFF  FEC,6B5
07A90:  MOVFF  FEC,6B6
07A94:  MOVFF  FEC,6B7
07A98:  MOVFF  67E,54B
07A9C:  MOVFF  67D,54A
07AA0:  MOVLW  89
07AA2:  MOVWF  FE9
07AA4:  MOVLW  02
07AA6:  MOVWF  xB8
07AA8:  MOVLB  0
07AAA:  CALL   6782
07AAE:  MOVLW  2C
07AB0:  MOVLB  6
07AB2:  MOVWF  xC1
07AB4:  MOVLB  0
07AB6:  CALL   5A5A
....................    
....................    return SUCCESS;
07ABA:  MOVLW  00
07ABC:  MOVWF  01
07ABE:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07AC0:  MOVLB  6
07AC2:  CLRF   xB3
07AC4:  MOVFF  66C,6B2
07AC8:  CLRF   xB5
07ACA:  MOVLW  B5
07ACC:  MOVWF  xB4
07ACE:  MOVLB  0
07AD0:  CALL   0876
07AD4:  MOVFF  02,67F
07AD8:  MOVFF  01,67E
07ADC:  MOVLW  06
07ADE:  MOVLB  6
07AE0:  ADDWF  x7E,F
07AE2:  MOVLW  00
07AE4:  ADDWFC x7F,F
07AE6:  MOVLW  32
07AE8:  ADDWF  x7E,W
07AEA:  MOVWF  01
07AEC:  MOVLW  00
07AEE:  ADDWFC x7F,W
07AF0:  MOVWF  03
07AF2:  MOVF   01,W
07AF4:  ADDLW  D1
07AF6:  MOVWF  01
07AF8:  MOVLW  01
07AFA:  ADDWFC 03,F
07AFC:  MOVFF  01,67E
07B00:  MOVFF  03,67F
07B04:  MOVFF  03,6A5
07B08:  MOVFF  01,6A4
07B0C:  MOVLB  0
07B0E:  CALL   5B22
07B12:  MOVF   01,F
07B14:  BNZ   7B1E
07B16:  MOVLW  02
07B18:  MOVWF  01
07B1A:  BRA    801A
07B1C:  BRA    7B7C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07B1E:  MOVLB  6
07B20:  CLRF   xB3
07B22:  MOVFF  66C,6B2
07B26:  CLRF   xB5
07B28:  MOVLW  B5
07B2A:  MOVWF  xB4
07B2C:  MOVLB  0
07B2E:  CALL   0876
07B32:  MOVFF  02,67F
07B36:  MOVFF  01,67E
07B3A:  MOVLW  06
07B3C:  MOVLB  6
07B3E:  ADDWF  x7E,F
07B40:  MOVLW  00
07B42:  ADDWFC x7F,F
07B44:  MOVLW  32
07B46:  ADDWF  x7E,W
07B48:  MOVWF  01
07B4A:  MOVLW  00
07B4C:  ADDWFC x7F,W
07B4E:  MOVWF  03
07B50:  MOVF   01,W
07B52:  ADDLW  D1
07B54:  MOVWF  01
07B56:  MOVLW  01
07B58:  ADDWFC 03,F
07B5A:  MOVFF  01,67E
07B5E:  MOVFF  03,67F
07B62:  MOVFF  03,6A5
07B66:  MOVFF  01,6A4
07B6A:  CLRF   xA7
07B6C:  CLRF   xA6
07B6E:  MOVLW  0A
07B70:  MOVWF  xA8
07B72:  MOVLB  0
07B74:  CALL   5C12
07B78:  MOVFF  01,67C
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07B7C:  MOVLB  6
07B7E:  CLRF   xB3
07B80:  MOVFF  66C,6B2
07B84:  CLRF   xB5
07B86:  MOVLW  B5
07B88:  MOVWF  xB4
07B8A:  MOVLB  0
07B8C:  CALL   0876
07B90:  MOVFF  02,67F
07B94:  MOVFF  01,67E
07B98:  MOVLW  06
07B9A:  MOVLB  6
07B9C:  ADDWF  x7E,F
07B9E:  MOVLW  00
07BA0:  ADDWFC x7F,F
07BA2:  MOVLW  4B
07BA4:  ADDWF  x7E,W
07BA6:  MOVWF  01
07BA8:  MOVLW  00
07BAA:  ADDWFC x7F,W
07BAC:  MOVWF  03
07BAE:  MOVF   01,W
07BB0:  ADDLW  D1
07BB2:  MOVWF  01
07BB4:  MOVLW  01
07BB6:  ADDWFC 03,F
07BB8:  MOVFF  01,67E
07BBC:  MOVFF  03,67F
07BC0:  MOVFF  03,6B3
07BC4:  MOVFF  01,6B2
07BC8:  MOVLB  0
07BCA:  CALL   59AA
07BCE:  MOVFF  02,03
07BD2:  MOVF   01,W
07BD4:  SUBLW  01
07BD6:  BNZ   7BDC
07BD8:  MOVF   03,F
07BDA:  BZ    7BE4
07BDC:  MOVLW  02
07BDE:  MOVWF  01
07BE0:  BRA    801A
07BE2:  BRA    7C24
....................    else arg2 = SERcmd[rec].p[3][0];
07BE4:  MOVLB  6
07BE6:  CLRF   xB3
07BE8:  MOVFF  66C,6B2
07BEC:  CLRF   xB5
07BEE:  MOVLW  B5
07BF0:  MOVWF  xB4
07BF2:  MOVLB  0
07BF4:  CALL   0876
07BF8:  MOVFF  02,67F
07BFC:  MOVFF  01,67E
07C00:  MOVLW  06
07C02:  MOVLB  6
07C04:  ADDWF  x7E,F
07C06:  MOVLW  00
07C08:  ADDWFC x7F,F
07C0A:  MOVLW  4B
07C0C:  ADDWF  x7E,F
07C0E:  MOVLW  00
07C10:  ADDWFC x7F,F
07C12:  MOVLW  D1
07C14:  ADDWF  x7E,W
07C16:  MOVWF  FE9
07C18:  MOVLW  01
07C1A:  ADDWFC x7F,W
07C1C:  MOVWF  FEA
07C1E:  MOVFF  FEF,67D
07C22:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07C24:  MOVLB  6
07C26:  MOVF   x7D,W
07C28:  SUBLW  30
07C2A:  BNZ   7CC6
07C2C:  MOVLW  04
07C2E:  MOVWF  xB3
07C30:  MOVLW  A7
07C32:  MOVWF  xB2
07C34:  MOVLB  0
07C36:  CALL   59AA
07C3A:  MOVFF  02,03
07C3E:  MOVF   01,W
07C40:  ADDLW  A7
07C42:  MOVLB  6
07C44:  MOVWF  x7E
07C46:  MOVLW  04
07C48:  ADDWFC 02,W
07C4A:  MOVWF  x7F
07C4C:  MOVLW  01
07C4E:  SUBWF  x7C,W
07C50:  MULLW  18
07C52:  MOVF   FF3,W
07C54:  CLRF   x81
07C56:  MOVWF  x80
07C58:  MOVLW  82
07C5A:  ADDWF  x80,W
07C5C:  MOVWF  FE9
07C5E:  MOVLW  00
07C60:  ADDWFC x81,W
07C62:  MOVWF  FEA
07C64:  MOVFF  FEF,682
07C68:  MOVFF  FEC,683
07C6C:  MOVFF  FEC,684
07C70:  MOVFF  FEC,685
07C74:  MOVFF  67F,54B
07C78:  MOVFF  67E,54A
07C7C:  MOVFF  67C,6A5
07C80:  MOVLW  18
07C82:  MOVWF  xA6
07C84:  MOVLB  0
07C86:  CALL   5F66
07C8A:  MOVLW  2C
07C8C:  MOVLB  6
07C8E:  MOVWF  xC1
07C90:  MOVLB  0
07C92:  CALL   5A5A
07C96:  MOVLW  89
07C98:  MOVWF  FE9
07C9A:  MOVFF  685,6B7
07C9E:  MOVFF  684,6B6
07CA2:  MOVFF  683,6B5
07CA6:  MOVFF  682,6B4
07CAA:  MOVLW  02
07CAC:  MOVLB  6
07CAE:  MOVWF  xB8
07CB0:  MOVLB  0
07CB2:  CALL   6782
07CB6:  MOVLW  2C
07CB8:  MOVLB  6
07CBA:  MOVWF  xC1
07CBC:  MOVLB  0
07CBE:  CALL   5A5A
07CC2:  BRA    8016
07CC4:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07CC6:  MOVF   x7D,W
07CC8:  SUBLW  31
07CCA:  BNZ   7D6E
07CCC:  MOVLW  04
07CCE:  MOVWF  xB3
07CD0:  MOVLW  A7
07CD2:  MOVWF  xB2
07CD4:  MOVLB  0
07CD6:  CALL   59AA
07CDA:  MOVF   01,W
07CDC:  ADDLW  A7
07CDE:  MOVLB  6
07CE0:  MOVWF  x7E
07CE2:  MOVLW  04
07CE4:  ADDWFC 02,W
07CE6:  MOVWF  x7F
07CE8:  MOVLW  01
07CEA:  SUBWF  x7C,W
07CEC:  MULLW  18
07CEE:  MOVF   FF3,W
07CF0:  CLRF   x81
07CF2:  MOVWF  x80
07CF4:  MOVLW  04
07CF6:  ADDWF  x80,W
07CF8:  MOVWF  01
07CFA:  MOVLW  00
07CFC:  ADDWFC x81,W
07CFE:  MOVWF  03
07D00:  MOVF   01,W
07D02:  ADDLW  82
07D04:  MOVWF  FE9
07D06:  MOVLW  00
07D08:  ADDWFC 03,W
07D0A:  MOVWF  FEA
07D0C:  MOVFF  FEF,680
07D10:  MOVFF  FEC,681
07D14:  MOVFF  FEC,682
07D18:  MOVFF  FEC,683
07D1C:  MOVFF  67F,54B
07D20:  MOVFF  67E,54A
07D24:  MOVFF  67C,6A5
07D28:  MOVLW  18
07D2A:  MOVWF  xA6
07D2C:  MOVLB  0
07D2E:  CALL   5F66
07D32:  MOVLW  2C
07D34:  MOVLB  6
07D36:  MOVWF  xC1
07D38:  MOVLB  0
07D3A:  CALL   5A5A
07D3E:  MOVLW  89
07D40:  MOVWF  FE9
07D42:  MOVFF  683,6B7
07D46:  MOVFF  682,6B6
07D4A:  MOVFF  681,6B5
07D4E:  MOVFF  680,6B4
07D52:  MOVLW  02
07D54:  MOVLB  6
07D56:  MOVWF  xB8
07D58:  MOVLB  0
07D5A:  CALL   6782
07D5E:  MOVLW  2C
07D60:  MOVLB  6
07D62:  MOVWF  xC1
07D64:  MOVLB  0
07D66:  CALL   5A5A
07D6A:  BRA    8016
07D6C:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07D6E:  MOVF   x7D,W
07D70:  SUBLW  32
07D72:  BNZ   7E16
07D74:  MOVLW  04
07D76:  MOVWF  xB3
07D78:  MOVLW  A7
07D7A:  MOVWF  xB2
07D7C:  MOVLB  0
07D7E:  CALL   59AA
07D82:  MOVF   01,W
07D84:  ADDLW  A7
07D86:  MOVLB  6
07D88:  MOVWF  x7E
07D8A:  MOVLW  04
07D8C:  ADDWFC 02,W
07D8E:  MOVWF  x7F
07D90:  MOVLW  01
07D92:  SUBWF  x7C,W
07D94:  MULLW  18
07D96:  MOVF   FF3,W
07D98:  CLRF   x81
07D9A:  MOVWF  x80
07D9C:  MOVLW  08
07D9E:  ADDWF  x80,W
07DA0:  MOVWF  01
07DA2:  MOVLW  00
07DA4:  ADDWFC x81,W
07DA6:  MOVWF  03
07DA8:  MOVF   01,W
07DAA:  ADDLW  82
07DAC:  MOVWF  FE9
07DAE:  MOVLW  00
07DB0:  ADDWFC 03,W
07DB2:  MOVWF  FEA
07DB4:  MOVFF  FEF,680
07DB8:  MOVFF  FEC,681
07DBC:  MOVFF  FEC,682
07DC0:  MOVFF  FEC,683
07DC4:  MOVFF  67F,54B
07DC8:  MOVFF  67E,54A
07DCC:  MOVFF  67C,6A5
07DD0:  MOVLW  18
07DD2:  MOVWF  xA6
07DD4:  MOVLB  0
07DD6:  CALL   5F66
07DDA:  MOVLW  2C
07DDC:  MOVLB  6
07DDE:  MOVWF  xC1
07DE0:  MOVLB  0
07DE2:  CALL   5A5A
07DE6:  MOVLW  89
07DE8:  MOVWF  FE9
07DEA:  MOVFF  683,6B7
07DEE:  MOVFF  682,6B6
07DF2:  MOVFF  681,6B5
07DF6:  MOVFF  680,6B4
07DFA:  MOVLW  02
07DFC:  MOVLB  6
07DFE:  MOVWF  xB8
07E00:  MOVLB  0
07E02:  CALL   6782
07E06:  MOVLW  2C
07E08:  MOVLB  6
07E0A:  MOVWF  xC1
07E0C:  MOVLB  0
07E0E:  CALL   5A5A
07E12:  BRA    8016
07E14:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07E16:  MOVF   x7D,W
07E18:  SUBLW  33
07E1A:  BNZ   7EBE
07E1C:  MOVLW  04
07E1E:  MOVWF  xB3
07E20:  MOVLW  A7
07E22:  MOVWF  xB2
07E24:  MOVLB  0
07E26:  CALL   59AA
07E2A:  MOVF   01,W
07E2C:  ADDLW  A7
07E2E:  MOVLB  6
07E30:  MOVWF  x7E
07E32:  MOVLW  04
07E34:  ADDWFC 02,W
07E36:  MOVWF  x7F
07E38:  MOVLW  01
07E3A:  SUBWF  x7C,W
07E3C:  MULLW  18
07E3E:  MOVF   FF3,W
07E40:  CLRF   x81
07E42:  MOVWF  x80
07E44:  MOVLW  0C
07E46:  ADDWF  x80,W
07E48:  MOVWF  01
07E4A:  MOVLW  00
07E4C:  ADDWFC x81,W
07E4E:  MOVWF  03
07E50:  MOVF   01,W
07E52:  ADDLW  82
07E54:  MOVWF  FE9
07E56:  MOVLW  00
07E58:  ADDWFC 03,W
07E5A:  MOVWF  FEA
07E5C:  MOVFF  FEF,680
07E60:  MOVFF  FEC,681
07E64:  MOVFF  FEC,682
07E68:  MOVFF  FEC,683
07E6C:  MOVFF  67F,54B
07E70:  MOVFF  67E,54A
07E74:  MOVFF  67C,6A5
07E78:  MOVLW  18
07E7A:  MOVWF  xA6
07E7C:  MOVLB  0
07E7E:  CALL   5F66
07E82:  MOVLW  2C
07E84:  MOVLB  6
07E86:  MOVWF  xC1
07E88:  MOVLB  0
07E8A:  CALL   5A5A
07E8E:  MOVLW  89
07E90:  MOVWF  FE9
07E92:  MOVFF  683,6B7
07E96:  MOVFF  682,6B6
07E9A:  MOVFF  681,6B5
07E9E:  MOVFF  680,6B4
07EA2:  MOVLW  02
07EA4:  MOVLB  6
07EA6:  MOVWF  xB8
07EA8:  MOVLB  0
07EAA:  CALL   6782
07EAE:  MOVLW  2C
07EB0:  MOVLB  6
07EB2:  MOVWF  xC1
07EB4:  MOVLB  0
07EB6:  CALL   5A5A
07EBA:  BRA    8016
07EBC:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07EBE:  MOVF   x7D,W
07EC0:  SUBLW  34
07EC2:  BNZ   7F66
07EC4:  MOVLW  04
07EC6:  MOVWF  xB3
07EC8:  MOVLW  A7
07ECA:  MOVWF  xB2
07ECC:  MOVLB  0
07ECE:  CALL   59AA
07ED2:  MOVF   01,W
07ED4:  ADDLW  A7
07ED6:  MOVLB  6
07ED8:  MOVWF  x7E
07EDA:  MOVLW  04
07EDC:  ADDWFC 02,W
07EDE:  MOVWF  x7F
07EE0:  MOVLW  01
07EE2:  SUBWF  x7C,W
07EE4:  MULLW  18
07EE6:  MOVF   FF3,W
07EE8:  CLRF   x81
07EEA:  MOVWF  x80
07EEC:  MOVLW  10
07EEE:  ADDWF  x80,W
07EF0:  MOVWF  01
07EF2:  MOVLW  00
07EF4:  ADDWFC x81,W
07EF6:  MOVWF  03
07EF8:  MOVF   01,W
07EFA:  ADDLW  82
07EFC:  MOVWF  FE9
07EFE:  MOVLW  00
07F00:  ADDWFC 03,W
07F02:  MOVWF  FEA
07F04:  MOVFF  FEF,680
07F08:  MOVFF  FEC,681
07F0C:  MOVFF  FEC,682
07F10:  MOVFF  FEC,683
07F14:  MOVFF  67F,54B
07F18:  MOVFF  67E,54A
07F1C:  MOVFF  67C,6A5
07F20:  MOVLW  18
07F22:  MOVWF  xA6
07F24:  MOVLB  0
07F26:  CALL   5F66
07F2A:  MOVLW  2C
07F2C:  MOVLB  6
07F2E:  MOVWF  xC1
07F30:  MOVLB  0
07F32:  CALL   5A5A
07F36:  MOVLW  89
07F38:  MOVWF  FE9
07F3A:  MOVFF  683,6B7
07F3E:  MOVFF  682,6B6
07F42:  MOVFF  681,6B5
07F46:  MOVFF  680,6B4
07F4A:  MOVLW  02
07F4C:  MOVLB  6
07F4E:  MOVWF  xB8
07F50:  MOVLB  0
07F52:  CALL   6782
07F56:  MOVLW  2C
07F58:  MOVLB  6
07F5A:  MOVWF  xC1
07F5C:  MOVLB  0
07F5E:  CALL   5A5A
07F62:  BRA    8016
07F64:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07F66:  MOVF   x7D,W
07F68:  SUBLW  35
07F6A:  BNZ   800E
07F6C:  MOVLW  04
07F6E:  MOVWF  xB3
07F70:  MOVLW  A7
07F72:  MOVWF  xB2
07F74:  MOVLB  0
07F76:  CALL   59AA
07F7A:  MOVF   01,W
07F7C:  ADDLW  A7
07F7E:  MOVLB  6
07F80:  MOVWF  x7E
07F82:  MOVLW  04
07F84:  ADDWFC 02,W
07F86:  MOVWF  x7F
07F88:  MOVLW  01
07F8A:  SUBWF  x7C,W
07F8C:  MULLW  18
07F8E:  MOVF   FF3,W
07F90:  CLRF   x81
07F92:  MOVWF  x80
07F94:  MOVLW  14
07F96:  ADDWF  x80,W
07F98:  MOVWF  01
07F9A:  MOVLW  00
07F9C:  ADDWFC x81,W
07F9E:  MOVWF  03
07FA0:  MOVF   01,W
07FA2:  ADDLW  82
07FA4:  MOVWF  FE9
07FA6:  MOVLW  00
07FA8:  ADDWFC 03,W
07FAA:  MOVWF  FEA
07FAC:  MOVFF  FEF,680
07FB0:  MOVFF  FEC,681
07FB4:  MOVFF  FEC,682
07FB8:  MOVFF  FEC,683
07FBC:  MOVFF  67F,54B
07FC0:  MOVFF  67E,54A
07FC4:  MOVFF  67C,6A5
07FC8:  MOVLW  18
07FCA:  MOVWF  xA6
07FCC:  MOVLB  0
07FCE:  CALL   5F66
07FD2:  MOVLW  2C
07FD4:  MOVLB  6
07FD6:  MOVWF  xC1
07FD8:  MOVLB  0
07FDA:  CALL   5A5A
07FDE:  MOVLW  89
07FE0:  MOVWF  FE9
07FE2:  MOVFF  683,6B7
07FE6:  MOVFF  682,6B6
07FEA:  MOVFF  681,6B5
07FEE:  MOVFF  680,6B4
07FF2:  MOVLW  02
07FF4:  MOVLB  6
07FF6:  MOVWF  xB8
07FF8:  MOVLB  0
07FFA:  CALL   6782
07FFE:  MOVLW  2C
08000:  MOVLB  6
08002:  MOVWF  xC1
08004:  MOVLB  0
08006:  CALL   5A5A
0800A:  BRA    8016
0800C:  MOVLB  6
....................    else return INV_PARAM;
0800E:  MOVLW  02
08010:  MOVWF  01
08012:  MOVLB  0
08014:  BRA    801A
....................    
....................    return SUCCESS;
08016:  MOVLW  00
08018:  MOVWF  01
0801A:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0801C:  MOVLB  6
0801E:  CLRF   xB3
08020:  MOVFF  66C,6B2
08024:  CLRF   xB5
08026:  MOVLW  B5
08028:  MOVWF  xB4
0802A:  MOVLB  0
0802C:  CALL   0876
08030:  MOVFF  02,683
08034:  MOVFF  01,682
08038:  MOVLW  06
0803A:  MOVLB  6
0803C:  ADDWF  x82,F
0803E:  MOVLW  00
08040:  ADDWFC x83,F
08042:  MOVLW  32
08044:  ADDWF  x82,W
08046:  MOVWF  01
08048:  MOVLW  00
0804A:  ADDWFC x83,W
0804C:  MOVWF  03
0804E:  MOVF   01,W
08050:  ADDLW  D1
08052:  MOVWF  01
08054:  MOVLW  01
08056:  ADDWFC 03,F
08058:  MOVFF  01,682
0805C:  MOVFF  03,683
08060:  MOVFF  03,6A5
08064:  MOVFF  01,6A4
08068:  MOVLB  0
0806A:  CALL   5B22
0806E:  MOVF   01,F
08070:  BNZ   807A
08072:  MOVLW  02
08074:  MOVWF  01
08076:  BRA    83B2
08078:  BRA    80D8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0807A:  MOVLB  6
0807C:  CLRF   xB3
0807E:  MOVFF  66C,6B2
08082:  CLRF   xB5
08084:  MOVLW  B5
08086:  MOVWF  xB4
08088:  MOVLB  0
0808A:  CALL   0876
0808E:  MOVFF  02,683
08092:  MOVFF  01,682
08096:  MOVLW  06
08098:  MOVLB  6
0809A:  ADDWF  x82,F
0809C:  MOVLW  00
0809E:  ADDWFC x83,F
080A0:  MOVLW  32
080A2:  ADDWF  x82,W
080A4:  MOVWF  01
080A6:  MOVLW  00
080A8:  ADDWFC x83,W
080AA:  MOVWF  03
080AC:  MOVF   01,W
080AE:  ADDLW  D1
080B0:  MOVWF  01
080B2:  MOVLW  01
080B4:  ADDWFC 03,F
080B6:  MOVFF  01,682
080BA:  MOVFF  03,683
080BE:  MOVFF  03,6A5
080C2:  MOVFF  01,6A4
080C6:  CLRF   xA7
080C8:  CLRF   xA6
080CA:  MOVLW  0A
080CC:  MOVWF  xA8
080CE:  MOVLB  0
080D0:  CALL   5C12
080D4:  MOVFF  01,67C
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
080D8:  MOVLB  6
080DA:  CLRF   xB3
080DC:  MOVFF  66C,6B2
080E0:  CLRF   xB5
080E2:  MOVLW  B5
080E4:  MOVWF  xB4
080E6:  MOVLB  0
080E8:  CALL   0876
080EC:  MOVFF  02,683
080F0:  MOVFF  01,682
080F4:  MOVLW  06
080F6:  MOVLB  6
080F8:  ADDWF  x82,F
080FA:  MOVLW  00
080FC:  ADDWFC x83,F
080FE:  MOVLW  4B
08100:  ADDWF  x82,W
08102:  MOVWF  01
08104:  MOVLW  00
08106:  ADDWFC x83,W
08108:  MOVWF  03
0810A:  MOVF   01,W
0810C:  ADDLW  D1
0810E:  MOVWF  01
08110:  MOVLW  01
08112:  ADDWFC 03,F
08114:  MOVFF  01,682
08118:  MOVFF  03,683
0811C:  MOVFF  03,6B3
08120:  MOVFF  01,6B2
08124:  MOVLB  0
08126:  CALL   59AA
0812A:  MOVFF  02,03
0812E:  MOVF   01,W
08130:  SUBLW  01
08132:  BNZ   8138
08134:  MOVF   03,F
08136:  BZ    8140
08138:  MOVLW  02
0813A:  MOVWF  01
0813C:  BRA    83B2
0813E:  BRA    8180
....................    else arg2 = SERcmd[rec].p[3][0];
08140:  MOVLB  6
08142:  CLRF   xB3
08144:  MOVFF  66C,6B2
08148:  CLRF   xB5
0814A:  MOVLW  B5
0814C:  MOVWF  xB4
0814E:  MOVLB  0
08150:  CALL   0876
08154:  MOVFF  02,683
08158:  MOVFF  01,682
0815C:  MOVLW  06
0815E:  MOVLB  6
08160:  ADDWF  x82,F
08162:  MOVLW  00
08164:  ADDWFC x83,F
08166:  MOVLW  4B
08168:  ADDWF  x82,F
0816A:  MOVLW  00
0816C:  ADDWFC x83,F
0816E:  MOVLW  D1
08170:  ADDWF  x82,W
08172:  MOVWF  FE9
08174:  MOVLW  01
08176:  ADDWFC x83,W
08178:  MOVWF  FEA
0817A:  MOVFF  FEF,67D
0817E:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
08180:  MOVLB  6
08182:  CLRF   xB3
08184:  MOVFF  66C,6B2
08188:  CLRF   xB5
0818A:  MOVLW  B5
0818C:  MOVWF  xB4
0818E:  MOVLB  0
08190:  CALL   0876
08194:  MOVFF  02,683
08198:  MOVFF  01,682
0819C:  MOVLW  06
0819E:  MOVLB  6
081A0:  ADDWF  x82,F
081A2:  MOVLW  00
081A4:  ADDWFC x83,F
081A6:  MOVLW  64
081A8:  ADDWF  x82,W
081AA:  MOVWF  01
081AC:  MOVLW  00
081AE:  ADDWFC x83,W
081B0:  MOVWF  03
081B2:  MOVF   01,W
081B4:  ADDLW  D1
081B6:  MOVWF  01
081B8:  MOVLW  01
081BA:  ADDWFC 03,F
081BC:  MOVFF  01,682
081C0:  MOVFF  03,683
081C4:  MOVFF  03,686
081C8:  MOVFF  01,685
081CC:  MOVLB  0
081CE:  CALL   6DEE
081D2:  MOVF   01,F
081D4:  BNZ   81DE
081D6:  MOVLW  02
081D8:  MOVWF  01
081DA:  BRA    83B2
081DC:  BRA    8244
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
081DE:  MOVLB  6
081E0:  CLRF   xB3
081E2:  MOVFF  66C,6B2
081E6:  CLRF   xB5
081E8:  MOVLW  B5
081EA:  MOVWF  xB4
081EC:  MOVLB  0
081EE:  CALL   0876
081F2:  MOVFF  02,683
081F6:  MOVFF  01,682
081FA:  MOVLW  06
081FC:  MOVLB  6
081FE:  ADDWF  x82,F
08200:  MOVLW  00
08202:  ADDWFC x83,F
08204:  MOVLW  64
08206:  ADDWF  x82,W
08208:  MOVWF  01
0820A:  MOVLW  00
0820C:  ADDWFC x83,W
0820E:  MOVWF  03
08210:  MOVF   01,W
08212:  ADDLW  D1
08214:  MOVWF  01
08216:  MOVLW  01
08218:  ADDWFC 03,F
0821A:  MOVFF  01,682
0821E:  MOVFF  03,683
08222:  MOVFF  03,686
08226:  MOVFF  01,685
0822A:  CLRF   x88
0822C:  CLRF   x87
0822E:  MOVLB  0
08230:  CALL   6EB0
08234:  MOVFF  03,681
08238:  MOVFF  02,680
0823C:  MOVFF  01,67F
08240:  MOVFF  00,67E
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08244:  MOVLB  6
08246:  MOVF   x7D,W
08248:  SUBLW  30
0824A:  BNZ   8276
0824C:  MOVLW  01
0824E:  SUBWF  x7C,W
08250:  MULLW  18
08252:  MOVF   FF3,W
08254:  CLRF   x83
08256:  MOVWF  x82
08258:  MOVLW  82
0825A:  ADDWF  x82,W
0825C:  MOVWF  FE9
0825E:  MOVLW  00
08260:  ADDWFC x83,W
08262:  MOVWF  FEA
08264:  MOVFF  67E,FEF
08268:  MOVFF  67F,FEC
0826C:  MOVFF  680,FEC
08270:  MOVFF  681,FEC
08274:  BRA    83AC
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08276:  MOVF   x7D,W
08278:  SUBLW  31
0827A:  BNZ   82B2
0827C:  MOVLW  01
0827E:  SUBWF  x7C,W
08280:  MULLW  18
08282:  MOVF   FF3,W
08284:  CLRF   x83
08286:  MOVWF  x82
08288:  MOVLW  04
0828A:  ADDWF  x82,W
0828C:  MOVWF  01
0828E:  MOVLW  00
08290:  ADDWFC x83,W
08292:  MOVWF  03
08294:  MOVF   01,W
08296:  ADDLW  82
08298:  MOVWF  FE9
0829A:  MOVLW  00
0829C:  ADDWFC 03,W
0829E:  MOVWF  FEA
082A0:  MOVFF  67E,FEF
082A4:  MOVFF  67F,FEC
082A8:  MOVFF  680,FEC
082AC:  MOVFF  681,FEC
082B0:  BRA    83AC
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
082B2:  MOVF   x7D,W
082B4:  SUBLW  32
082B6:  BNZ   82EE
082B8:  MOVLW  01
082BA:  SUBWF  x7C,W
082BC:  MULLW  18
082BE:  MOVF   FF3,W
082C0:  CLRF   x83
082C2:  MOVWF  x82
082C4:  MOVLW  08
082C6:  ADDWF  x82,W
082C8:  MOVWF  01
082CA:  MOVLW  00
082CC:  ADDWFC x83,W
082CE:  MOVWF  03
082D0:  MOVF   01,W
082D2:  ADDLW  82
082D4:  MOVWF  FE9
082D6:  MOVLW  00
082D8:  ADDWFC 03,W
082DA:  MOVWF  FEA
082DC:  MOVFF  67E,FEF
082E0:  MOVFF  67F,FEC
082E4:  MOVFF  680,FEC
082E8:  MOVFF  681,FEC
082EC:  BRA    83AC
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
082EE:  MOVF   x7D,W
082F0:  SUBLW  33
082F2:  BNZ   832A
082F4:  MOVLW  01
082F6:  SUBWF  x7C,W
082F8:  MULLW  18
082FA:  MOVF   FF3,W
082FC:  CLRF   x83
082FE:  MOVWF  x82
08300:  MOVLW  0C
08302:  ADDWF  x82,W
08304:  MOVWF  01
08306:  MOVLW  00
08308:  ADDWFC x83,W
0830A:  MOVWF  03
0830C:  MOVF   01,W
0830E:  ADDLW  82
08310:  MOVWF  FE9
08312:  MOVLW  00
08314:  ADDWFC 03,W
08316:  MOVWF  FEA
08318:  MOVFF  67E,FEF
0831C:  MOVFF  67F,FEC
08320:  MOVFF  680,FEC
08324:  MOVFF  681,FEC
08328:  BRA    83AC
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
0832A:  MOVF   x7D,W
0832C:  SUBLW  34
0832E:  BNZ   8366
08330:  MOVLW  01
08332:  SUBWF  x7C,W
08334:  MULLW  18
08336:  MOVF   FF3,W
08338:  CLRF   x83
0833A:  MOVWF  x82
0833C:  MOVLW  10
0833E:  ADDWF  x82,W
08340:  MOVWF  01
08342:  MOVLW  00
08344:  ADDWFC x83,W
08346:  MOVWF  03
08348:  MOVF   01,W
0834A:  ADDLW  82
0834C:  MOVWF  FE9
0834E:  MOVLW  00
08350:  ADDWFC 03,W
08352:  MOVWF  FEA
08354:  MOVFF  67E,FEF
08358:  MOVFF  67F,FEC
0835C:  MOVFF  680,FEC
08360:  MOVFF  681,FEC
08364:  BRA    83AC
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08366:  MOVF   x7D,W
08368:  SUBLW  35
0836A:  BNZ   83A2
0836C:  MOVLW  01
0836E:  SUBWF  x7C,W
08370:  MULLW  18
08372:  MOVF   FF3,W
08374:  CLRF   x83
08376:  MOVWF  x82
08378:  MOVLW  14
0837A:  ADDWF  x82,W
0837C:  MOVWF  01
0837E:  MOVLW  00
08380:  ADDWFC x83,W
08382:  MOVWF  03
08384:  MOVF   01,W
08386:  ADDLW  82
08388:  MOVWF  FE9
0838A:  MOVLW  00
0838C:  ADDWFC 03,W
0838E:  MOVWF  FEA
08390:  MOVFF  67E,FEF
08394:  MOVFF  67F,FEC
08398:  MOVFF  680,FEC
0839C:  MOVFF  681,FEC
083A0:  BRA    83AC
....................    else return INV_PARAM;
083A2:  MOVLW  02
083A4:  MOVWF  01
083A6:  MOVLB  0
083A8:  BRA    83B2
083AA:  MOVLB  6
....................    
....................    return SUCCESS;
083AC:  MOVLW  00
083AE:  MOVWF  01
083B0:  MOVLB  0
083B2:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
083B4:  MOVLW  4E
083B6:  MOVLB  6
083B8:  MOVWF  x80
083BA:  MOVLW  31
083BC:  MOVWF  x81
083BE:  MOVLW  35
083C0:  MOVWF  x82
083C2:  CLRF   x83
083C4:  MOVLW  06
083C6:  MOVWF  x7F
083C8:  MOVLW  80
083CA:  MOVWF  x7E
....................    char *s_200 = "200";
083CC:  MOVLW  32
083CE:  MOVWF  x86
083D0:  MOVLW  30
083D2:  MOVWF  x87
083D4:  MOVWF  x88
083D6:  CLRF   x89
083D8:  MOVLW  06
083DA:  MOVWF  x85
083DC:  MOVLW  86
083DE:  MOVWF  x84
....................    char *s_5V6 = "5V6";
083E0:  MOVLW  35
083E2:  MOVWF  x8C
083E4:  MOVLW  56
083E6:  MOVWF  x8D
083E8:  MOVLW  36
083EA:  MOVWF  x8E
083EC:  CLRF   x8F
083EE:  MOVLW  06
083F0:  MOVWF  x8B
083F2:  MOVLW  8C
083F4:  MOVWF  x8A
....................    char *s_5VA = "5VA";
083F6:  MOVLW  35
083F8:  MOVWF  x92
083FA:  MOVLW  56
083FC:  MOVWF  x93
083FE:  MOVLW  41
08400:  MOVWF  x94
08402:  CLRF   x95
08404:  MOVLW  06
08406:  MOVWF  x91
08408:  MOVLW  92
0840A:  MOVWF  x90
....................    char *s_3V6X = "3V6X";
0840C:  MOVLW  33
0840E:  MOVWF  x98
08410:  MOVLW  56
08412:  MOVWF  x99
08414:  MOVLW  36
08416:  MOVWF  x9A
08418:  MOVLW  58
0841A:  MOVWF  x9B
0841C:  CLRF   x9C
0841E:  MOVLW  06
08420:  MOVWF  x97
08422:  MOVLW  98
08424:  MOVWF  x96
....................    char *s_3V3A = "3V3A";
08426:  MOVLW  33
08428:  MOVWF  x9F
0842A:  MOVLW  56
0842C:  MOVWF  xA0
0842E:  MOVLW  33
08430:  MOVWF  xA1
08432:  MOVLW  41
08434:  MOVWF  xA2
08436:  CLRF   xA3
08438:  MOVLW  06
0843A:  MOVWF  x9E
0843C:  MOVLW  9F
0843E:  MOVWF  x9D
....................    char *s_3V3D = "3V3D";
08440:  MOVLW  33
08442:  MOVWF  xA6
08444:  MOVLW  56
08446:  MOVWF  xA7
08448:  MOVLW  33
0844A:  MOVWF  xA8
0844C:  MOVLW  44
0844E:  MOVWF  xA9
08450:  CLRF   xAA
08452:  MOVLW  06
08454:  MOVWF  xA5
08456:  MOVLW  A6
08458:  MOVWF  xA4
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
0845A:  CLRF   xB3
0845C:  MOVFF  66C,6B2
08460:  CLRF   xB5
08462:  MOVLW  B5
08464:  MOVWF  xB4
08466:  MOVLB  0
08468:  CALL   0876
0846C:  MOVFF  02,6AC
08470:  MOVFF  01,6AB
08474:  MOVLW  06
08476:  MOVLB  6
08478:  ADDWF  xAB,F
0847A:  MOVLW  00
0847C:  ADDWFC xAC,F
0847E:  MOVLW  32
08480:  ADDWF  xAB,W
08482:  MOVWF  01
08484:  MOVLW  00
08486:  ADDWFC xAC,W
08488:  MOVWF  03
0848A:  MOVF   01,W
0848C:  ADDLW  D1
0848E:  MOVWF  01
08490:  MOVLW  01
08492:  ADDWFC 03,F
08494:  MOVFF  01,67C
08498:  MOVFF  03,67D
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0849C:  MOVFF  67F,6B3
084A0:  MOVFF  67E,6B2
084A4:  MOVFF  67D,6B5
084A8:  MOVFF  67C,6B4
084AC:  MOVLB  0
084AE:  CALL   59E2
084B2:  MOVF   01,F
084B4:  BNZ   8538
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
084B6:  MOVLW  04
084B8:  MOVLB  6
084BA:  MOVWF  xB3
084BC:  MOVLW  A7
084BE:  MOVWF  xB2
084C0:  MOVLB  0
084C2:  CALL   59AA
084C6:  MOVFF  02,03
084CA:  MOVF   01,W
084CC:  ADDLW  A7
084CE:  MOVLB  6
084D0:  MOVWF  xAB
084D2:  MOVLW  04
084D4:  ADDWFC 02,W
084D6:  MOVWF  xAC
084D8:  MOVFF  FE8,54B
084DC:  MOVFF  6AB,54A
084E0:  MOVLW  89
084E2:  MOVWF  FE9
084E4:  MOVFF  B5,6B7
084E8:  MOVFF  B4,6B6
084EC:  MOVFF  B3,6B5
084F0:  MOVFF  B2,6B4
084F4:  MOVLW  02
084F6:  MOVWF  xB8
084F8:  MOVLB  0
084FA:  CALL   6782
084FE:  MOVLW  2C
08500:  MOVLB  6
08502:  MOVWF  xC1
08504:  MOVLB  0
08506:  CALL   5A5A
0850A:  MOVLW  89
0850C:  MOVWF  FE9
0850E:  MOVFF  B9,6B7
08512:  MOVFF  B8,6B6
08516:  MOVFF  B7,6B5
0851A:  MOVFF  B6,6B4
0851E:  MOVLW  02
08520:  MOVLB  6
08522:  MOVWF  xB8
08524:  MOVLB  0
08526:  CALL   6782
0852A:  MOVLW  2C
0852C:  MOVLB  6
0852E:  MOVWF  xC1
08530:  MOVLB  0
08532:  CALL   5A5A
....................    }
08536:  BRA    88DA
....................    else if (0 == strcmp(s_200, arg1)) {
08538:  MOVFF  685,6B3
0853C:  MOVFF  684,6B2
08540:  MOVFF  67D,6B5
08544:  MOVFF  67C,6B4
08548:  CALL   59E2
0854C:  MOVF   01,F
0854E:  BNZ   85D2
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
08550:  MOVLW  04
08552:  MOVLB  6
08554:  MOVWF  xB3
08556:  MOVLW  A7
08558:  MOVWF  xB2
0855A:  MOVLB  0
0855C:  CALL   59AA
08560:  MOVFF  02,03
08564:  MOVF   01,W
08566:  ADDLW  A7
08568:  MOVLB  6
0856A:  MOVWF  xAB
0856C:  MOVLW  04
0856E:  ADDWFC 02,W
08570:  MOVWF  xAC
08572:  MOVFF  FE8,54B
08576:  MOVFF  6AB,54A
0857A:  MOVLW  89
0857C:  MOVWF  FE9
0857E:  MOVFF  BD,6B7
08582:  MOVFF  BC,6B6
08586:  MOVFF  BB,6B5
0858A:  MOVFF  BA,6B4
0858E:  MOVLW  02
08590:  MOVWF  xB8
08592:  MOVLB  0
08594:  CALL   6782
08598:  MOVLW  2C
0859A:  MOVLB  6
0859C:  MOVWF  xC1
0859E:  MOVLB  0
085A0:  CALL   5A5A
085A4:  MOVLW  89
085A6:  MOVWF  FE9
085A8:  MOVFF  C1,6B7
085AC:  MOVFF  C0,6B6
085B0:  MOVFF  BF,6B5
085B4:  MOVFF  BE,6B4
085B8:  MOVLW  02
085BA:  MOVLB  6
085BC:  MOVWF  xB8
085BE:  MOVLB  0
085C0:  CALL   6782
085C4:  MOVLW  2C
085C6:  MOVLB  6
085C8:  MOVWF  xC1
085CA:  MOVLB  0
085CC:  CALL   5A5A
....................    }
085D0:  BRA    88DA
....................    else if (0 == strcmp(s_5V6, arg1)) {
085D2:  MOVFF  68B,6B3
085D6:  MOVFF  68A,6B2
085DA:  MOVFF  67D,6B5
085DE:  MOVFF  67C,6B4
085E2:  CALL   59E2
085E6:  MOVF   01,F
085E8:  BNZ   866C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
085EA:  MOVLW  04
085EC:  MOVLB  6
085EE:  MOVWF  xB3
085F0:  MOVLW  A7
085F2:  MOVWF  xB2
085F4:  MOVLB  0
085F6:  CALL   59AA
085FA:  MOVFF  02,03
085FE:  MOVF   01,W
08600:  ADDLW  A7
08602:  MOVLB  6
08604:  MOVWF  xAB
08606:  MOVLW  04
08608:  ADDWFC 02,W
0860A:  MOVWF  xAC
0860C:  MOVFF  FE8,54B
08610:  MOVFF  6AB,54A
08614:  MOVLW  89
08616:  MOVWF  FE9
08618:  MOVFF  C5,6B7
0861C:  MOVFF  C4,6B6
08620:  MOVFF  C3,6B5
08624:  MOVFF  C2,6B4
08628:  MOVLW  02
0862A:  MOVWF  xB8
0862C:  MOVLB  0
0862E:  CALL   6782
08632:  MOVLW  2C
08634:  MOVLB  6
08636:  MOVWF  xC1
08638:  MOVLB  0
0863A:  CALL   5A5A
0863E:  MOVLW  89
08640:  MOVWF  FE9
08642:  MOVFF  C9,6B7
08646:  MOVFF  C8,6B6
0864A:  MOVFF  C7,6B5
0864E:  MOVFF  C6,6B4
08652:  MOVLW  02
08654:  MOVLB  6
08656:  MOVWF  xB8
08658:  MOVLB  0
0865A:  CALL   6782
0865E:  MOVLW  2C
08660:  MOVLB  6
08662:  MOVWF  xC1
08664:  MOVLB  0
08666:  CALL   5A5A
....................    }
0866A:  BRA    88DA
....................    else if (0 == strcmp(s_5VA, arg1)) {
0866C:  MOVFF  691,6B3
08670:  MOVFF  690,6B2
08674:  MOVFF  67D,6B5
08678:  MOVFF  67C,6B4
0867C:  CALL   59E2
08680:  MOVF   01,F
08682:  BNZ   8706
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08684:  MOVLW  04
08686:  MOVLB  6
08688:  MOVWF  xB3
0868A:  MOVLW  A7
0868C:  MOVWF  xB2
0868E:  MOVLB  0
08690:  CALL   59AA
08694:  MOVFF  02,03
08698:  MOVF   01,W
0869A:  ADDLW  A7
0869C:  MOVLB  6
0869E:  MOVWF  xAB
086A0:  MOVLW  04
086A2:  ADDWFC 02,W
086A4:  MOVWF  xAC
086A6:  MOVFF  FE8,54B
086AA:  MOVFF  6AB,54A
086AE:  MOVLW  89
086B0:  MOVWF  FE9
086B2:  MOVFF  CD,6B7
086B6:  MOVFF  CC,6B6
086BA:  MOVFF  CB,6B5
086BE:  MOVFF  CA,6B4
086C2:  MOVLW  02
086C4:  MOVWF  xB8
086C6:  MOVLB  0
086C8:  CALL   6782
086CC:  MOVLW  2C
086CE:  MOVLB  6
086D0:  MOVWF  xC1
086D2:  MOVLB  0
086D4:  CALL   5A5A
086D8:  MOVLW  89
086DA:  MOVWF  FE9
086DC:  MOVFF  D1,6B7
086E0:  MOVFF  D0,6B6
086E4:  MOVFF  CF,6B5
086E8:  MOVFF  CE,6B4
086EC:  MOVLW  02
086EE:  MOVLB  6
086F0:  MOVWF  xB8
086F2:  MOVLB  0
086F4:  CALL   6782
086F8:  MOVLW  2C
086FA:  MOVLB  6
086FC:  MOVWF  xC1
086FE:  MOVLB  0
08700:  CALL   5A5A
....................    }
08704:  BRA    88DA
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08706:  MOVFF  697,6B3
0870A:  MOVFF  696,6B2
0870E:  MOVFF  67D,6B5
08712:  MOVFF  67C,6B4
08716:  CALL   59E2
0871A:  MOVF   01,F
0871C:  BNZ   87A0
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
0871E:  MOVLW  04
08720:  MOVLB  6
08722:  MOVWF  xB3
08724:  MOVLW  A7
08726:  MOVWF  xB2
08728:  MOVLB  0
0872A:  CALL   59AA
0872E:  MOVFF  02,03
08732:  MOVF   01,W
08734:  ADDLW  A7
08736:  MOVLB  6
08738:  MOVWF  xAB
0873A:  MOVLW  04
0873C:  ADDWFC 02,W
0873E:  MOVWF  xAC
08740:  MOVFF  FE8,54B
08744:  MOVFF  6AB,54A
08748:  MOVLW  89
0874A:  MOVWF  FE9
0874C:  MOVFF  D5,6B7
08750:  MOVFF  D4,6B6
08754:  MOVFF  D3,6B5
08758:  MOVFF  D2,6B4
0875C:  MOVLW  02
0875E:  MOVWF  xB8
08760:  MOVLB  0
08762:  CALL   6782
08766:  MOVLW  2C
08768:  MOVLB  6
0876A:  MOVWF  xC1
0876C:  MOVLB  0
0876E:  CALL   5A5A
08772:  MOVLW  89
08774:  MOVWF  FE9
08776:  MOVFF  D9,6B7
0877A:  MOVFF  D8,6B6
0877E:  MOVFF  D7,6B5
08782:  MOVFF  D6,6B4
08786:  MOVLW  02
08788:  MOVLB  6
0878A:  MOVWF  xB8
0878C:  MOVLB  0
0878E:  CALL   6782
08792:  MOVLW  2C
08794:  MOVLB  6
08796:  MOVWF  xC1
08798:  MOVLB  0
0879A:  CALL   5A5A
....................    }
0879E:  BRA    88DA
....................    else if (0 == strcmp(s_3V3A, arg1)) {
087A0:  MOVFF  69E,6B3
087A4:  MOVFF  69D,6B2
087A8:  MOVFF  67D,6B5
087AC:  MOVFF  67C,6B4
087B0:  CALL   59E2
087B4:  MOVF   01,F
087B6:  BNZ   883A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
087B8:  MOVLW  04
087BA:  MOVLB  6
087BC:  MOVWF  xB3
087BE:  MOVLW  A7
087C0:  MOVWF  xB2
087C2:  MOVLB  0
087C4:  CALL   59AA
087C8:  MOVFF  02,03
087CC:  MOVF   01,W
087CE:  ADDLW  A7
087D0:  MOVLB  6
087D2:  MOVWF  xAB
087D4:  MOVLW  04
087D6:  ADDWFC 02,W
087D8:  MOVWF  xAC
087DA:  MOVFF  FE8,54B
087DE:  MOVFF  6AB,54A
087E2:  MOVLW  89
087E4:  MOVWF  FE9
087E6:  MOVFF  DD,6B7
087EA:  MOVFF  DC,6B6
087EE:  MOVFF  DB,6B5
087F2:  MOVFF  DA,6B4
087F6:  MOVLW  02
087F8:  MOVWF  xB8
087FA:  MOVLB  0
087FC:  CALL   6782
08800:  MOVLW  2C
08802:  MOVLB  6
08804:  MOVWF  xC1
08806:  MOVLB  0
08808:  CALL   5A5A
0880C:  MOVLW  89
0880E:  MOVWF  FE9
08810:  MOVFF  E1,6B7
08814:  MOVFF  E0,6B6
08818:  MOVFF  DF,6B5
0881C:  MOVFF  DE,6B4
08820:  MOVLW  02
08822:  MOVLB  6
08824:  MOVWF  xB8
08826:  MOVLB  0
08828:  CALL   6782
0882C:  MOVLW  2C
0882E:  MOVLB  6
08830:  MOVWF  xC1
08832:  MOVLB  0
08834:  CALL   5A5A
....................    }
08838:  BRA    88DA
....................    else if (0 == strcmp(s_3V3D, arg1)) {
0883A:  MOVFF  6A5,6B3
0883E:  MOVFF  6A4,6B2
08842:  MOVFF  67D,6B5
08846:  MOVFF  67C,6B4
0884A:  CALL   59E2
0884E:  MOVF   01,F
08850:  BNZ   88D4
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
08852:  MOVLW  04
08854:  MOVLB  6
08856:  MOVWF  xB3
08858:  MOVLW  A7
0885A:  MOVWF  xB2
0885C:  MOVLB  0
0885E:  CALL   59AA
08862:  MOVFF  02,03
08866:  MOVF   01,W
08868:  ADDLW  A7
0886A:  MOVLB  6
0886C:  MOVWF  xAB
0886E:  MOVLW  04
08870:  ADDWFC 02,W
08872:  MOVWF  xAC
08874:  MOVFF  FE8,54B
08878:  MOVFF  6AB,54A
0887C:  MOVLW  89
0887E:  MOVWF  FE9
08880:  MOVFF  E5,6B7
08884:  MOVFF  E4,6B6
08888:  MOVFF  E3,6B5
0888C:  MOVFF  E2,6B4
08890:  MOVLW  02
08892:  MOVWF  xB8
08894:  MOVLB  0
08896:  CALL   6782
0889A:  MOVLW  2C
0889C:  MOVLB  6
0889E:  MOVWF  xC1
088A0:  MOVLB  0
088A2:  CALL   5A5A
088A6:  MOVLW  89
088A8:  MOVWF  FE9
088AA:  MOVFF  E9,6B7
088AE:  MOVFF  E8,6B6
088B2:  MOVFF  E7,6B5
088B6:  MOVFF  E6,6B4
088BA:  MOVLW  02
088BC:  MOVLB  6
088BE:  MOVWF  xB8
088C0:  MOVLB  0
088C2:  CALL   6782
088C6:  MOVLW  2C
088C8:  MOVLB  6
088CA:  MOVWF  xC1
088CC:  MOVLB  0
088CE:  CALL   5A5A
....................    }
088D2:  BRA    88DA
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
088D4:  MOVLW  02
088D6:  MOVWF  01
088D8:  BRA    88DE
....................    
....................    return SUCCESS;
088DA:  MOVLW  00
088DC:  MOVWF  01
088DE:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
088E0:  MOVLW  00
088E2:  MOVWF  01
088E4:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
088E6:  MOVLW  4E
088E8:  MOVLB  6
088EA:  MOVWF  x80
088EC:  MOVLW  31
088EE:  MOVWF  x81
088F0:  MOVLW  35
088F2:  MOVWF  x82
088F4:  CLRF   x83
088F6:  MOVLW  06
088F8:  MOVWF  x7F
088FA:  MOVLW  80
088FC:  MOVWF  x7E
....................    char *s_200 = "200";
088FE:  MOVLW  32
08900:  MOVWF  x86
08902:  MOVLW  30
08904:  MOVWF  x87
08906:  MOVWF  x88
08908:  CLRF   x89
0890A:  MOVLW  06
0890C:  MOVWF  x85
0890E:  MOVLW  86
08910:  MOVWF  x84
....................    char *s_5V6 = "5V6";
08912:  MOVLW  35
08914:  MOVWF  x8C
08916:  MOVLW  56
08918:  MOVWF  x8D
0891A:  MOVLW  36
0891C:  MOVWF  x8E
0891E:  CLRF   x8F
08920:  MOVLW  06
08922:  MOVWF  x8B
08924:  MOVLW  8C
08926:  MOVWF  x8A
....................    char *s_5VA = "5VA";
08928:  MOVLW  35
0892A:  MOVWF  x92
0892C:  MOVLW  56
0892E:  MOVWF  x93
08930:  MOVLW  41
08932:  MOVWF  x94
08934:  CLRF   x95
08936:  MOVLW  06
08938:  MOVWF  x91
0893A:  MOVLW  92
0893C:  MOVWF  x90
....................    char *s_3V6X = "3V6X";
0893E:  MOVLW  33
08940:  MOVWF  x98
08942:  MOVLW  56
08944:  MOVWF  x99
08946:  MOVLW  36
08948:  MOVWF  x9A
0894A:  MOVLW  58
0894C:  MOVWF  x9B
0894E:  CLRF   x9C
08950:  MOVLW  06
08952:  MOVWF  x97
08954:  MOVLW  98
08956:  MOVWF  x96
....................    char *s_3V3A = "3V3A";
08958:  MOVLW  33
0895A:  MOVWF  x9F
0895C:  MOVLW  56
0895E:  MOVWF  xA0
08960:  MOVLW  33
08962:  MOVWF  xA1
08964:  MOVLW  41
08966:  MOVWF  xA2
08968:  CLRF   xA3
0896A:  MOVLW  06
0896C:  MOVWF  x9E
0896E:  MOVLW  9F
08970:  MOVWF  x9D
....................    char *s_3V3D = "3V3D";
08972:  MOVLW  33
08974:  MOVWF  xA6
08976:  MOVLW  56
08978:  MOVWF  xA7
0897A:  MOVLW  33
0897C:  MOVWF  xA8
0897E:  MOVLW  44
08980:  MOVWF  xA9
08982:  CLRF   xAA
08984:  MOVLW  06
08986:  MOVWF  xA5
08988:  MOVLW  A6
0898A:  MOVWF  xA4
....................    char *s_all = "all";
0898C:  MOVLW  61
0898E:  MOVWF  xAD
08990:  MOVLW  6C
08992:  MOVWF  xAE
08994:  MOVWF  xAF
08996:  CLRF   xB0
08998:  MOVLW  06
0899A:  MOVWF  xAC
0899C:  MOVLW  AD
0899E:  MOVWF  xAB
....................    
....................    arg1 = SERcmd[rec].p[2];
089A0:  CLRF   xB3
089A2:  MOVFF  66C,6B2
089A6:  CLRF   xB5
089A8:  MOVLW  B5
089AA:  MOVWF  xB4
089AC:  MOVLB  0
089AE:  CALL   0876
089B2:  MOVFF  02,6B2
089B6:  MOVFF  01,6B1
089BA:  MOVLW  06
089BC:  MOVLB  6
089BE:  ADDWF  xB1,F
089C0:  MOVLW  00
089C2:  ADDWFC xB2,F
089C4:  MOVLW  32
089C6:  ADDWF  xB1,W
089C8:  MOVWF  01
089CA:  MOVLW  00
089CC:  ADDWFC xB2,W
089CE:  MOVWF  03
089D0:  MOVF   01,W
089D2:  ADDLW  D1
089D4:  MOVWF  01
089D6:  MOVLW  01
089D8:  ADDWFC 03,F
089DA:  MOVFF  01,67C
089DE:  MOVFF  03,67D
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
089E2:  MOVFF  67F,6B3
089E6:  MOVFF  67E,6B2
089EA:  MOVFF  67D,6B5
089EE:  MOVFF  67C,6B4
089F2:  MOVLB  0
089F4:  CALL   59E2
089F8:  MOVF   01,F
089FA:  BNZ   8A52
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
089FC:  MOVLW  04
089FE:  MOVLB  6
08A00:  MOVWF  xB3
08A02:  MOVLW  A7
08A04:  MOVWF  xB2
08A06:  MOVLB  0
08A08:  CALL   59AA
08A0C:  MOVFF  02,03
08A10:  MOVF   01,W
08A12:  ADDLW  A7
08A14:  MOVLB  6
08A16:  MOVWF  xB1
08A18:  MOVLW  04
08A1A:  ADDWFC 02,W
08A1C:  MOVWF  xB2
08A1E:  MOVFF  FE8,54B
08A22:  MOVFF  6B1,54A
08A26:  MOVLW  89
08A28:  MOVWF  FE9
08A2A:  MOVFF  EE,6B7
08A2E:  MOVFF  ED,6B6
08A32:  MOVFF  EC,6B5
08A36:  MOVFF  EB,6B4
08A3A:  MOVLW  02
08A3C:  MOVWF  xB8
08A3E:  MOVLB  0
08A40:  CALL   6782
08A44:  MOVLW  2C
08A46:  MOVLB  6
08A48:  MOVWF  xC1
08A4A:  MOVLB  0
08A4C:  CALL   5A5A
....................    }
08A50:  BRA    8F54
....................    else if (0 == strcmp(s_200, arg1)) {
08A52:  MOVFF  685,6B3
08A56:  MOVFF  684,6B2
08A5A:  MOVFF  67D,6B5
08A5E:  MOVFF  67C,6B4
08A62:  CALL   59E2
08A66:  MOVF   01,F
08A68:  BNZ   8AC0
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08A6A:  MOVLW  04
08A6C:  MOVLB  6
08A6E:  MOVWF  xB3
08A70:  MOVLW  A7
08A72:  MOVWF  xB2
08A74:  MOVLB  0
08A76:  CALL   59AA
08A7A:  MOVFF  02,03
08A7E:  MOVF   01,W
08A80:  ADDLW  A7
08A82:  MOVLB  6
08A84:  MOVWF  xB1
08A86:  MOVLW  04
08A88:  ADDWFC 02,W
08A8A:  MOVWF  xB2
08A8C:  MOVFF  FE8,54B
08A90:  MOVFF  6B1,54A
08A94:  MOVLW  89
08A96:  MOVWF  FE9
08A98:  MOVFF  F2,6B7
08A9C:  MOVFF  F1,6B6
08AA0:  MOVFF  F0,6B5
08AA4:  MOVFF  EF,6B4
08AA8:  MOVLW  01
08AAA:  MOVWF  xB8
08AAC:  MOVLB  0
08AAE:  CALL   6782
08AB2:  MOVLW  2C
08AB4:  MOVLB  6
08AB6:  MOVWF  xC1
08AB8:  MOVLB  0
08ABA:  CALL   5A5A
....................    }
08ABE:  BRA    8F54
....................    else if (0 == strcmp(s_5V6, arg1)) {
08AC0:  MOVFF  68B,6B3
08AC4:  MOVFF  68A,6B2
08AC8:  MOVFF  67D,6B5
08ACC:  MOVFF  67C,6B4
08AD0:  CALL   59E2
08AD4:  MOVF   01,F
08AD6:  BNZ   8B2E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08AD8:  MOVLW  04
08ADA:  MOVLB  6
08ADC:  MOVWF  xB3
08ADE:  MOVLW  A7
08AE0:  MOVWF  xB2
08AE2:  MOVLB  0
08AE4:  CALL   59AA
08AE8:  MOVFF  02,03
08AEC:  MOVF   01,W
08AEE:  ADDLW  A7
08AF0:  MOVLB  6
08AF2:  MOVWF  xB1
08AF4:  MOVLW  04
08AF6:  ADDWFC 02,W
08AF8:  MOVWF  xB2
08AFA:  MOVFF  FE8,54B
08AFE:  MOVFF  6B1,54A
08B02:  MOVLW  89
08B04:  MOVWF  FE9
08B06:  MOVFF  F6,6B7
08B0A:  MOVFF  F5,6B6
08B0E:  MOVFF  F4,6B5
08B12:  MOVFF  F3,6B4
08B16:  MOVLW  03
08B18:  MOVWF  xB8
08B1A:  MOVLB  0
08B1C:  CALL   6782
08B20:  MOVLW  2C
08B22:  MOVLB  6
08B24:  MOVWF  xC1
08B26:  MOVLB  0
08B28:  CALL   5A5A
....................    }
08B2C:  BRA    8F54
....................    else if (0 == strcmp(s_5VA, arg1)) {
08B2E:  MOVFF  691,6B3
08B32:  MOVFF  690,6B2
08B36:  MOVFF  67D,6B5
08B3A:  MOVFF  67C,6B4
08B3E:  CALL   59E2
08B42:  MOVF   01,F
08B44:  BNZ   8B9C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08B46:  MOVLW  04
08B48:  MOVLB  6
08B4A:  MOVWF  xB3
08B4C:  MOVLW  A7
08B4E:  MOVWF  xB2
08B50:  MOVLB  0
08B52:  CALL   59AA
08B56:  MOVFF  02,03
08B5A:  MOVF   01,W
08B5C:  ADDLW  A7
08B5E:  MOVLB  6
08B60:  MOVWF  xB1
08B62:  MOVLW  04
08B64:  ADDWFC 02,W
08B66:  MOVWF  xB2
08B68:  MOVFF  FE8,54B
08B6C:  MOVFF  6B1,54A
08B70:  MOVLW  89
08B72:  MOVWF  FE9
08B74:  MOVFF  FA,6B7
08B78:  MOVFF  F9,6B6
08B7C:  MOVFF  F8,6B5
08B80:  MOVFF  F7,6B4
08B84:  MOVLW  03
08B86:  MOVWF  xB8
08B88:  MOVLB  0
08B8A:  CALL   6782
08B8E:  MOVLW  2C
08B90:  MOVLB  6
08B92:  MOVWF  xC1
08B94:  MOVLB  0
08B96:  CALL   5A5A
....................    }
08B9A:  BRA    8F54
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08B9C:  MOVFF  697,6B3
08BA0:  MOVFF  696,6B2
08BA4:  MOVFF  67D,6B5
08BA8:  MOVFF  67C,6B4
08BAC:  CALL   59E2
08BB0:  MOVF   01,F
08BB2:  BNZ   8C0A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08BB4:  MOVLW  04
08BB6:  MOVLB  6
08BB8:  MOVWF  xB3
08BBA:  MOVLW  A7
08BBC:  MOVWF  xB2
08BBE:  MOVLB  0
08BC0:  CALL   59AA
08BC4:  MOVFF  02,03
08BC8:  MOVF   01,W
08BCA:  ADDLW  A7
08BCC:  MOVLB  6
08BCE:  MOVWF  xB1
08BD0:  MOVLW  04
08BD2:  ADDWFC 02,W
08BD4:  MOVWF  xB2
08BD6:  MOVFF  FE8,54B
08BDA:  MOVFF  6B1,54A
08BDE:  MOVLW  89
08BE0:  MOVWF  FE9
08BE2:  MOVFF  FE,6B7
08BE6:  MOVFF  FD,6B6
08BEA:  MOVFF  FC,6B5
08BEE:  MOVFF  FB,6B4
08BF2:  MOVLW  03
08BF4:  MOVWF  xB8
08BF6:  MOVLB  0
08BF8:  CALL   6782
08BFC:  MOVLW  2C
08BFE:  MOVLB  6
08C00:  MOVWF  xC1
08C02:  MOVLB  0
08C04:  CALL   5A5A
....................    }
08C08:  BRA    8F54
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08C0A:  MOVFF  69E,6B3
08C0E:  MOVFF  69D,6B2
08C12:  MOVFF  67D,6B5
08C16:  MOVFF  67C,6B4
08C1A:  CALL   59E2
08C1E:  MOVF   01,F
08C20:  BNZ   8C78
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08C22:  MOVLW  04
08C24:  MOVLB  6
08C26:  MOVWF  xB3
08C28:  MOVLW  A7
08C2A:  MOVWF  xB2
08C2C:  MOVLB  0
08C2E:  CALL   59AA
08C32:  MOVFF  02,03
08C36:  MOVF   01,W
08C38:  ADDLW  A7
08C3A:  MOVLB  6
08C3C:  MOVWF  xB1
08C3E:  MOVLW  04
08C40:  ADDWFC 02,W
08C42:  MOVWF  xB2
08C44:  MOVFF  FE8,54B
08C48:  MOVFF  6B1,54A
08C4C:  MOVLW  89
08C4E:  MOVWF  FE9
08C50:  MOVFF  102,6B7
08C54:  MOVFF  101,6B6
08C58:  MOVFF  100,6B5
08C5C:  MOVFF  FF,6B4
08C60:  MOVLW  03
08C62:  MOVWF  xB8
08C64:  MOVLB  0
08C66:  CALL   6782
08C6A:  MOVLW  2C
08C6C:  MOVLB  6
08C6E:  MOVWF  xC1
08C70:  MOVLB  0
08C72:  CALL   5A5A
....................    }
08C76:  BRA    8F54
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08C78:  MOVFF  6A5,6B3
08C7C:  MOVFF  6A4,6B2
08C80:  MOVFF  67D,6B5
08C84:  MOVFF  67C,6B4
08C88:  CALL   59E2
08C8C:  MOVF   01,F
08C8E:  BNZ   8CE6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08C90:  MOVLW  04
08C92:  MOVLB  6
08C94:  MOVWF  xB3
08C96:  MOVLW  A7
08C98:  MOVWF  xB2
08C9A:  MOVLB  0
08C9C:  CALL   59AA
08CA0:  MOVFF  02,03
08CA4:  MOVF   01,W
08CA6:  ADDLW  A7
08CA8:  MOVLB  6
08CAA:  MOVWF  xB1
08CAC:  MOVLW  04
08CAE:  ADDWFC 02,W
08CB0:  MOVWF  xB2
08CB2:  MOVFF  FE8,54B
08CB6:  MOVFF  6B1,54A
08CBA:  MOVLW  89
08CBC:  MOVWF  FE9
08CBE:  MOVFF  106,6B7
08CC2:  MOVFF  105,6B6
08CC6:  MOVFF  104,6B5
08CCA:  MOVFF  103,6B4
08CCE:  MOVLW  03
08CD0:  MOVWF  xB8
08CD2:  MOVLB  0
08CD4:  CALL   6782
08CD8:  MOVLW  2C
08CDA:  MOVLB  6
08CDC:  MOVWF  xC1
08CDE:  MOVLB  0
08CE0:  CALL   5A5A
....................    }
08CE4:  BRA    8F54
....................    else if (0 == strcmp(s_all, arg1)) {
08CE6:  MOVFF  6AC,6B3
08CEA:  MOVFF  6AB,6B2
08CEE:  MOVFF  67D,6B5
08CF2:  MOVFF  67C,6B4
08CF6:  CALL   59E2
08CFA:  MOVF   01,F
08CFC:  BTFSS  FD8.2
08CFE:  BRA    8F4E
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08D00:  MOVLW  04
08D02:  MOVLB  6
08D04:  MOVWF  xB3
08D06:  MOVLW  A7
08D08:  MOVWF  xB2
08D0A:  MOVLB  0
08D0C:  CALL   59AA
08D10:  MOVFF  02,03
08D14:  MOVF   01,W
08D16:  ADDLW  A7
08D18:  MOVLB  6
08D1A:  MOVWF  xB1
08D1C:  MOVLW  04
08D1E:  ADDWFC 02,W
08D20:  MOVWF  xB2
08D22:  MOVFF  FE8,54B
08D26:  MOVFF  6B1,54A
08D2A:  MOVLW  89
08D2C:  MOVWF  FE9
08D2E:  MOVFF  EE,6B7
08D32:  MOVFF  ED,6B6
08D36:  MOVFF  EC,6B5
08D3A:  MOVFF  EB,6B4
08D3E:  MOVLW  02
08D40:  MOVWF  xB8
08D42:  MOVLB  0
08D44:  CALL   6782
08D48:  MOVLW  2C
08D4A:  MOVLB  6
08D4C:  MOVWF  xC1
08D4E:  MOVLB  0
08D50:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08D54:  MOVLW  04
08D56:  MOVLB  6
08D58:  MOVWF  xB3
08D5A:  MOVLW  A7
08D5C:  MOVWF  xB2
08D5E:  MOVLB  0
08D60:  CALL   59AA
08D64:  MOVFF  02,03
08D68:  MOVF   01,W
08D6A:  ADDLW  A7
08D6C:  MOVLB  6
08D6E:  MOVWF  xB1
08D70:  MOVLW  04
08D72:  ADDWFC 02,W
08D74:  MOVWF  xB2
08D76:  MOVFF  FE8,54B
08D7A:  MOVFF  6B1,54A
08D7E:  MOVLW  89
08D80:  MOVWF  FE9
08D82:  MOVFF  F2,6B7
08D86:  MOVFF  F1,6B6
08D8A:  MOVFF  F0,6B5
08D8E:  MOVFF  EF,6B4
08D92:  MOVLW  01
08D94:  MOVWF  xB8
08D96:  MOVLB  0
08D98:  CALL   6782
08D9C:  MOVLW  2C
08D9E:  MOVLB  6
08DA0:  MOVWF  xC1
08DA2:  MOVLB  0
08DA4:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08DA8:  MOVLW  04
08DAA:  MOVLB  6
08DAC:  MOVWF  xB3
08DAE:  MOVLW  A7
08DB0:  MOVWF  xB2
08DB2:  MOVLB  0
08DB4:  CALL   59AA
08DB8:  MOVFF  02,03
08DBC:  MOVF   01,W
08DBE:  ADDLW  A7
08DC0:  MOVLB  6
08DC2:  MOVWF  xB1
08DC4:  MOVLW  04
08DC6:  ADDWFC 02,W
08DC8:  MOVWF  xB2
08DCA:  MOVFF  FE8,54B
08DCE:  MOVFF  6B1,54A
08DD2:  MOVLW  89
08DD4:  MOVWF  FE9
08DD6:  MOVFF  F6,6B7
08DDA:  MOVFF  F5,6B6
08DDE:  MOVFF  F4,6B5
08DE2:  MOVFF  F3,6B4
08DE6:  MOVLW  03
08DE8:  MOVWF  xB8
08DEA:  MOVLB  0
08DEC:  CALL   6782
08DF0:  MOVLW  2C
08DF2:  MOVLB  6
08DF4:  MOVWF  xC1
08DF6:  MOVLB  0
08DF8:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08DFC:  MOVLW  04
08DFE:  MOVLB  6
08E00:  MOVWF  xB3
08E02:  MOVLW  A7
08E04:  MOVWF  xB2
08E06:  MOVLB  0
08E08:  CALL   59AA
08E0C:  MOVFF  02,03
08E10:  MOVF   01,W
08E12:  ADDLW  A7
08E14:  MOVLB  6
08E16:  MOVWF  xB1
08E18:  MOVLW  04
08E1A:  ADDWFC 02,W
08E1C:  MOVWF  xB2
08E1E:  MOVFF  FE8,54B
08E22:  MOVFF  6B1,54A
08E26:  MOVLW  89
08E28:  MOVWF  FE9
08E2A:  MOVFF  FA,6B7
08E2E:  MOVFF  F9,6B6
08E32:  MOVFF  F8,6B5
08E36:  MOVFF  F7,6B4
08E3A:  MOVLW  03
08E3C:  MOVWF  xB8
08E3E:  MOVLB  0
08E40:  CALL   6782
08E44:  MOVLW  2C
08E46:  MOVLB  6
08E48:  MOVWF  xC1
08E4A:  MOVLB  0
08E4C:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08E50:  MOVLW  04
08E52:  MOVLB  6
08E54:  MOVWF  xB3
08E56:  MOVLW  A7
08E58:  MOVWF  xB2
08E5A:  MOVLB  0
08E5C:  CALL   59AA
08E60:  MOVFF  02,03
08E64:  MOVF   01,W
08E66:  ADDLW  A7
08E68:  MOVLB  6
08E6A:  MOVWF  xB1
08E6C:  MOVLW  04
08E6E:  ADDWFC 02,W
08E70:  MOVWF  xB2
08E72:  MOVFF  FE8,54B
08E76:  MOVFF  6B1,54A
08E7A:  MOVLW  89
08E7C:  MOVWF  FE9
08E7E:  MOVFF  FE,6B7
08E82:  MOVFF  FD,6B6
08E86:  MOVFF  FC,6B5
08E8A:  MOVFF  FB,6B4
08E8E:  MOVLW  03
08E90:  MOVWF  xB8
08E92:  MOVLB  0
08E94:  CALL   6782
08E98:  MOVLW  2C
08E9A:  MOVLB  6
08E9C:  MOVWF  xC1
08E9E:  MOVLB  0
08EA0:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08EA4:  MOVLW  04
08EA6:  MOVLB  6
08EA8:  MOVWF  xB3
08EAA:  MOVLW  A7
08EAC:  MOVWF  xB2
08EAE:  MOVLB  0
08EB0:  CALL   59AA
08EB4:  MOVFF  02,03
08EB8:  MOVF   01,W
08EBA:  ADDLW  A7
08EBC:  MOVLB  6
08EBE:  MOVWF  xB1
08EC0:  MOVLW  04
08EC2:  ADDWFC 02,W
08EC4:  MOVWF  xB2
08EC6:  MOVFF  FE8,54B
08ECA:  MOVFF  6B1,54A
08ECE:  MOVLW  89
08ED0:  MOVWF  FE9
08ED2:  MOVFF  102,6B7
08ED6:  MOVFF  101,6B6
08EDA:  MOVFF  100,6B5
08EDE:  MOVFF  FF,6B4
08EE2:  MOVLW  03
08EE4:  MOVWF  xB8
08EE6:  MOVLB  0
08EE8:  CALL   6782
08EEC:  MOVLW  2C
08EEE:  MOVLB  6
08EF0:  MOVWF  xC1
08EF2:  MOVLB  0
08EF4:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08EF8:  MOVLW  04
08EFA:  MOVLB  6
08EFC:  MOVWF  xB3
08EFE:  MOVLW  A7
08F00:  MOVWF  xB2
08F02:  MOVLB  0
08F04:  CALL   59AA
08F08:  MOVFF  02,03
08F0C:  MOVF   01,W
08F0E:  ADDLW  A7
08F10:  MOVLB  6
08F12:  MOVWF  xB1
08F14:  MOVLW  04
08F16:  ADDWFC 02,W
08F18:  MOVWF  xB2
08F1A:  MOVFF  FE8,54B
08F1E:  MOVFF  6B1,54A
08F22:  MOVLW  89
08F24:  MOVWF  FE9
08F26:  MOVFF  106,6B7
08F2A:  MOVFF  105,6B6
08F2E:  MOVFF  104,6B5
08F32:  MOVFF  103,6B4
08F36:  MOVLW  03
08F38:  MOVWF  xB8
08F3A:  MOVLB  0
08F3C:  CALL   6782
08F40:  MOVLW  2C
08F42:  MOVLB  6
08F44:  MOVWF  xC1
08F46:  MOVLB  0
08F48:  CALL   5A5A
....................    }
08F4C:  BRA    8F54
....................    else return INV_PARAM;
08F4E:  MOVLW  02
08F50:  MOVWF  01
08F52:  BRA    8F58
....................    
....................    return SUCCESS;
08F54:  MOVLW  00
08F56:  MOVWF  01
08F58:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08F5A:  MOVLW  50
08F5C:  MOVLB  6
08F5E:  MOVWF  x81
08F60:  MOVLW  56
08F62:  MOVWF  x82
08F64:  CLRF   x83
08F66:  MOVLW  06
08F68:  MOVWF  x80
08F6A:  MOVLW  81
08F6C:  MOVWF  x7F
....................    char *s_CV = "CV";
08F6E:  MOVLW  43
08F70:  MOVWF  x86
08F72:  MOVLW  56
08F74:  MOVWF  x87
08F76:  CLRF   x88
08F78:  MOVLW  06
08F7A:  MOVWF  x85
08F7C:  MOVLW  86
08F7E:  MOVWF  x84
....................    char *s_PVold = "PVold";
08F80:  MOVLW  50
08F82:  MOVWF  x8B
08F84:  MOVLW  56
08F86:  MOVWF  x8C
08F88:  MOVLW  6F
08F8A:  MOVWF  x8D
08F8C:  MOVLW  6C
08F8E:  MOVWF  x8E
08F90:  MOVLW  64
08F92:  MOVWF  x8F
08F94:  CLRF   x90
08F96:  MOVLW  06
08F98:  MOVWF  x8A
08F9A:  MOVLW  8B
08F9C:  MOVWF  x89
....................    char *s_I = "I";
08F9E:  MOVLW  49
08FA0:  MOVWF  x93
08FA2:  CLRF   x94
08FA4:  MOVLW  06
08FA6:  MOVWF  x92
08FA8:  MOVLW  93
08FAA:  MOVWF  x91
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08FAC:  CLRF   xB3
08FAE:  MOVFF  66C,6B2
08FB2:  CLRF   xB5
08FB4:  MOVLW  B5
08FB6:  MOVWF  xB4
08FB8:  MOVLB  0
08FBA:  CALL   0876
08FBE:  MOVFF  02,696
08FC2:  MOVFF  01,695
08FC6:  MOVLW  06
08FC8:  MOVLB  6
08FCA:  ADDWF  x95,F
08FCC:  MOVLW  00
08FCE:  ADDWFC x96,F
08FD0:  MOVLW  32
08FD2:  ADDWF  x95,W
08FD4:  MOVWF  01
08FD6:  MOVLW  00
08FD8:  ADDWFC x96,W
08FDA:  MOVWF  03
08FDC:  MOVF   01,W
08FDE:  ADDLW  D1
08FE0:  MOVWF  01
08FE2:  MOVLW  01
08FE4:  ADDWFC 03,F
08FE6:  MOVFF  01,695
08FEA:  MOVFF  03,696
08FEE:  MOVFF  03,6A5
08FF2:  MOVFF  01,6A4
08FF6:  MOVLB  0
08FF8:  CALL   5B22
08FFC:  MOVF   01,F
08FFE:  BNZ   9008
09000:  MOVLW  02
09002:  MOVWF  01
09004:  BRA    939E
09006:  BRA    9066
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09008:  MOVLB  6
0900A:  CLRF   xB3
0900C:  MOVFF  66C,6B2
09010:  CLRF   xB5
09012:  MOVLW  B5
09014:  MOVWF  xB4
09016:  MOVLB  0
09018:  CALL   0876
0901C:  MOVFF  02,696
09020:  MOVFF  01,695
09024:  MOVLW  06
09026:  MOVLB  6
09028:  ADDWF  x95,F
0902A:  MOVLW  00
0902C:  ADDWFC x96,F
0902E:  MOVLW  32
09030:  ADDWF  x95,W
09032:  MOVWF  01
09034:  MOVLW  00
09036:  ADDWFC x96,W
09038:  MOVWF  03
0903A:  MOVF   01,W
0903C:  ADDLW  D1
0903E:  MOVWF  01
09040:  MOVLW  01
09042:  ADDWFC 03,F
09044:  MOVFF  01,695
09048:  MOVFF  03,696
0904C:  MOVFF  03,6A5
09050:  MOVFF  01,6A4
09054:  CLRF   xA7
09056:  CLRF   xA6
09058:  MOVLW  0A
0905A:  MOVWF  xA8
0905C:  MOVLB  0
0905E:  CALL   5C12
09062:  MOVFF  01,67C
....................    
....................    arg2 = SERcmd[rec].p[3];
09066:  MOVLB  6
09068:  CLRF   xB3
0906A:  MOVFF  66C,6B2
0906E:  CLRF   xB5
09070:  MOVLW  B5
09072:  MOVWF  xB4
09074:  MOVLB  0
09076:  CALL   0876
0907A:  MOVFF  02,696
0907E:  MOVFF  01,695
09082:  MOVLW  06
09084:  MOVLB  6
09086:  ADDWF  x95,F
09088:  MOVLW  00
0908A:  ADDWFC x96,F
0908C:  MOVLW  4B
0908E:  ADDWF  x95,W
09090:  MOVWF  01
09092:  MOVLW  00
09094:  ADDWFC x96,W
09096:  MOVWF  03
09098:  MOVF   01,W
0909A:  ADDLW  D1
0909C:  MOVWF  01
0909E:  MOVLW  01
090A0:  ADDWFC 03,F
090A2:  MOVFF  01,67D
090A6:  MOVFF  03,67E
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
090AA:  MOVFF  680,6B3
090AE:  MOVFF  67F,6B2
090B2:  MOVFF  67E,6B5
090B6:  MOVFF  67D,6B4
090BA:  MOVLB  0
090BC:  CALL   59E2
090C0:  MOVF   01,F
090C2:  BNZ   9166
090C4:  MOVLW  04
090C6:  MOVLB  6
090C8:  MOVWF  xB3
090CA:  MOVLW  A7
090CC:  MOVWF  xB2
090CE:  MOVLB  0
090D0:  CALL   59AA
090D4:  MOVF   01,W
090D6:  ADDLW  A7
090D8:  MOVLB  6
090DA:  MOVWF  x95
090DC:  MOVLW  04
090DE:  ADDWFC 02,W
090E0:  MOVWF  x96
090E2:  MOVLW  01
090E4:  SUBWF  x7C,W
090E6:  MULLW  20
090E8:  MOVF   FF3,W
090EA:  CLRF   x98
090EC:  MOVWF  x97
090EE:  MOVLW  10
090F0:  ADDWF  x97,W
090F2:  MOVWF  01
090F4:  MOVLW  00
090F6:  ADDWFC x98,W
090F8:  MOVWF  03
090FA:  MOVF   01,W
090FC:  ADDLW  20
090FE:  MOVWF  FE9
09100:  MOVLW  00
09102:  ADDWFC 03,W
09104:  MOVWF  FEA
09106:  MOVFF  FEF,697
0910A:  MOVFF  FEC,698
0910E:  MOVFF  FEC,699
09112:  MOVFF  FEC,69A
09116:  MOVFF  696,54B
0911A:  MOVFF  695,54A
0911E:  MOVFF  67C,6A5
09122:  MOVLW  18
09124:  MOVWF  xA6
09126:  MOVLB  0
09128:  CALL   5F66
0912C:  MOVLW  2C
0912E:  MOVLB  6
09130:  MOVWF  xC1
09132:  MOVLB  0
09134:  CALL   5A5A
09138:  MOVLW  89
0913A:  MOVWF  FE9
0913C:  MOVFF  69A,6B7
09140:  MOVFF  699,6B6
09144:  MOVFF  698,6B5
09148:  MOVFF  697,6B4
0914C:  MOVLW  02
0914E:  MOVLB  6
09150:  MOVWF  xB8
09152:  MOVLB  0
09154:  CALL   6782
09158:  MOVLW  2C
0915A:  MOVLB  6
0915C:  MOVWF  xC1
0915E:  MOVLB  0
09160:  CALL   5A5A
09164:  BRA    939A
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
09166:  MOVFF  685,6B3
0916A:  MOVFF  684,6B2
0916E:  MOVFF  67E,6B5
09172:  MOVFF  67D,6B4
09176:  CALL   59E2
0917A:  MOVF   01,F
0917C:  BNZ   9220
0917E:  MOVLW  04
09180:  MOVLB  6
09182:  MOVWF  xB3
09184:  MOVLW  A7
09186:  MOVWF  xB2
09188:  MOVLB  0
0918A:  CALL   59AA
0918E:  MOVF   01,W
09190:  ADDLW  A7
09192:  MOVLB  6
09194:  MOVWF  x95
09196:  MOVLW  04
09198:  ADDWFC 02,W
0919A:  MOVWF  x96
0919C:  MOVLW  01
0919E:  SUBWF  x7C,W
091A0:  MULLW  20
091A2:  MOVF   FF3,W
091A4:  CLRF   x98
091A6:  MOVWF  x97
091A8:  MOVLW  18
091AA:  ADDWF  x97,W
091AC:  MOVWF  01
091AE:  MOVLW  00
091B0:  ADDWFC x98,W
091B2:  MOVWF  03
091B4:  MOVF   01,W
091B6:  ADDLW  20
091B8:  MOVWF  FE9
091BA:  MOVLW  00
091BC:  ADDWFC 03,W
091BE:  MOVWF  FEA
091C0:  MOVFF  FEF,697
091C4:  MOVFF  FEC,698
091C8:  MOVFF  FEC,699
091CC:  MOVFF  FEC,69A
091D0:  MOVFF  696,54B
091D4:  MOVFF  695,54A
091D8:  MOVFF  67C,6A5
091DC:  MOVLW  18
091DE:  MOVWF  xA6
091E0:  MOVLB  0
091E2:  CALL   5F66
091E6:  MOVLW  2C
091E8:  MOVLB  6
091EA:  MOVWF  xC1
091EC:  MOVLB  0
091EE:  CALL   5A5A
091F2:  MOVLW  89
091F4:  MOVWF  FE9
091F6:  MOVFF  69A,6B7
091FA:  MOVFF  699,6B6
091FE:  MOVFF  698,6B5
09202:  MOVFF  697,6B4
09206:  MOVLW  02
09208:  MOVLB  6
0920A:  MOVWF  xB8
0920C:  MOVLB  0
0920E:  CALL   6782
09212:  MOVLW  2C
09214:  MOVLB  6
09216:  MOVWF  xC1
09218:  MOVLB  0
0921A:  CALL   5A5A
0921E:  BRA    939A
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
09220:  MOVFF  68A,6B3
09224:  MOVFF  689,6B2
09228:  MOVFF  67E,6B5
0922C:  MOVFF  67D,6B4
09230:  CALL   59E2
09234:  MOVF   01,F
09236:  BNZ   92DA
09238:  MOVLW  04
0923A:  MOVLB  6
0923C:  MOVWF  xB3
0923E:  MOVLW  A7
09240:  MOVWF  xB2
09242:  MOVLB  0
09244:  CALL   59AA
09248:  MOVF   01,W
0924A:  ADDLW  A7
0924C:  MOVLB  6
0924E:  MOVWF  x95
09250:  MOVLW  04
09252:  ADDWFC 02,W
09254:  MOVWF  x96
09256:  MOVLW  01
09258:  SUBWF  x7C,W
0925A:  MULLW  20
0925C:  MOVF   FF3,W
0925E:  CLRF   x98
09260:  MOVWF  x97
09262:  MOVLW  14
09264:  ADDWF  x97,W
09266:  MOVWF  01
09268:  MOVLW  00
0926A:  ADDWFC x98,W
0926C:  MOVWF  03
0926E:  MOVF   01,W
09270:  ADDLW  20
09272:  MOVWF  FE9
09274:  MOVLW  00
09276:  ADDWFC 03,W
09278:  MOVWF  FEA
0927A:  MOVFF  FEF,697
0927E:  MOVFF  FEC,698
09282:  MOVFF  FEC,699
09286:  MOVFF  FEC,69A
0928A:  MOVFF  696,54B
0928E:  MOVFF  695,54A
09292:  MOVFF  67C,6A5
09296:  MOVLW  18
09298:  MOVWF  xA6
0929A:  MOVLB  0
0929C:  CALL   5F66
092A0:  MOVLW  2C
092A2:  MOVLB  6
092A4:  MOVWF  xC1
092A6:  MOVLB  0
092A8:  CALL   5A5A
092AC:  MOVLW  89
092AE:  MOVWF  FE9
092B0:  MOVFF  69A,6B7
092B4:  MOVFF  699,6B6
092B8:  MOVFF  698,6B5
092BC:  MOVFF  697,6B4
092C0:  MOVLW  02
092C2:  MOVLB  6
092C4:  MOVWF  xB8
092C6:  MOVLB  0
092C8:  CALL   6782
092CC:  MOVLW  2C
092CE:  MOVLB  6
092D0:  MOVWF  xC1
092D2:  MOVLB  0
092D4:  CALL   5A5A
092D8:  BRA    939A
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
092DA:  MOVFF  692,6B3
092DE:  MOVFF  691,6B2
092E2:  MOVFF  67E,6B5
092E6:  MOVFF  67D,6B4
092EA:  CALL   59E2
092EE:  MOVF   01,F
092F0:  BNZ   9394
092F2:  MOVLW  04
092F4:  MOVLB  6
092F6:  MOVWF  xB3
092F8:  MOVLW  A7
092FA:  MOVWF  xB2
092FC:  MOVLB  0
092FE:  CALL   59AA
09302:  MOVF   01,W
09304:  ADDLW  A7
09306:  MOVLB  6
09308:  MOVWF  x95
0930A:  MOVLW  04
0930C:  ADDWFC 02,W
0930E:  MOVWF  x96
09310:  MOVLW  01
09312:  SUBWF  x7C,W
09314:  MULLW  20
09316:  MOVF   FF3,W
09318:  CLRF   x98
0931A:  MOVWF  x97
0931C:  MOVLW  1C
0931E:  ADDWF  x97,W
09320:  MOVWF  01
09322:  MOVLW  00
09324:  ADDWFC x98,W
09326:  MOVWF  03
09328:  MOVF   01,W
0932A:  ADDLW  20
0932C:  MOVWF  FE9
0932E:  MOVLW  00
09330:  ADDWFC 03,W
09332:  MOVWF  FEA
09334:  MOVFF  FEF,697
09338:  MOVFF  FEC,698
0933C:  MOVFF  FEC,699
09340:  MOVFF  FEC,69A
09344:  MOVFF  696,54B
09348:  MOVFF  695,54A
0934C:  MOVFF  67C,6A5
09350:  MOVLW  18
09352:  MOVWF  xA6
09354:  MOVLB  0
09356:  CALL   5F66
0935A:  MOVLW  2C
0935C:  MOVLB  6
0935E:  MOVWF  xC1
09360:  MOVLB  0
09362:  CALL   5A5A
09366:  MOVLW  89
09368:  MOVWF  FE9
0936A:  MOVFF  69A,6B7
0936E:  MOVFF  699,6B6
09372:  MOVFF  698,6B5
09376:  MOVFF  697,6B4
0937A:  MOVLW  02
0937C:  MOVLB  6
0937E:  MOVWF  xB8
09380:  MOVLB  0
09382:  CALL   6782
09386:  MOVLW  2C
09388:  MOVLB  6
0938A:  MOVWF  xC1
0938C:  MOVLB  0
0938E:  CALL   5A5A
09392:  BRA    939A
....................    else return INV_PARAM;
09394:  MOVLW  02
09396:  MOVWF  01
09398:  BRA    939E
....................    
....................    return SUCCESS;
0939A:  MOVLW  00
0939C:  MOVWF  01
0939E:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
094BE:  MOVLW  72
094C0:  MOVLB  6
094C2:  MOVWF  x81
094C4:  MOVLW  61
094C6:  MOVWF  x82
094C8:  MOVLW  77
094CA:  MOVWF  x83
094CC:  CLRF   x84
094CE:  MOVLW  06
094D0:  MOVWF  x80
094D2:  MOVLW  81
094D4:  MOVWF  x7F
....................    char *s_calibrated = "calib";
094D6:  MOVLW  63
094D8:  MOVWF  x87
094DA:  MOVLW  61
094DC:  MOVWF  x88
094DE:  MOVLW  6C
094E0:  MOVWF  x89
094E2:  MOVLW  69
094E4:  MOVWF  x8A
094E6:  MOVLW  62
094E8:  MOVWF  x8B
094EA:  CLRF   x8C
094EC:  MOVLW  06
094EE:  MOVWF  x86
094F0:  MOVLW  87
094F2:  MOVWF  x85
....................    char *s_p0 = "p0";
094F4:  MOVLW  70
094F6:  MOVWF  x8F
094F8:  MOVLW  30
094FA:  MOVWF  x90
094FC:  CLRF   x91
094FE:  MOVLW  06
09500:  MOVWF  x8E
09502:  MOVLW  8F
09504:  MOVWF  x8D
....................    char *s_poles = "poles";
09506:  MOVLW  70
09508:  MOVWF  x94
0950A:  MOVLW  6F
0950C:  MOVWF  x95
0950E:  MOVLW  6C
09510:  MOVWF  x96
09512:  MOVLW  65
09514:  MOVWF  x97
09516:  MOVLW  73
09518:  MOVWF  x98
0951A:  CLRF   x99
0951C:  MOVLW  06
0951E:  MOVWF  x93
09520:  MOVLW  94
09522:  MOVWF  x92
....................    char *s_real = "real";
09524:  MOVLW  72
09526:  MOVWF  x9C
09528:  MOVLW  65
0952A:  MOVWF  x9D
0952C:  MOVLW  61
0952E:  MOVWF  x9E
09530:  MOVLW  6C
09532:  MOVWF  x9F
09534:  CLRF   xA0
09536:  MOVLW  06
09538:  MOVWF  x9B
0953A:  MOVLW  9C
0953C:  MOVWF  x9A
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0953E:  CLRF   xB3
09540:  MOVFF  66C,6B2
09544:  CLRF   xB5
09546:  MOVLW  B5
09548:  MOVWF  xB4
0954A:  MOVLB  0
0954C:  CALL   0876
09550:  MOVFF  02,6A2
09554:  MOVFF  01,6A1
09558:  MOVLW  06
0955A:  MOVLB  6
0955C:  ADDWF  xA1,F
0955E:  MOVLW  00
09560:  ADDWFC xA2,F
09562:  MOVLW  32
09564:  ADDWF  xA1,W
09566:  MOVWF  01
09568:  MOVLW  00
0956A:  ADDWFC xA2,W
0956C:  MOVWF  03
0956E:  MOVF   01,W
09570:  ADDLW  D1
09572:  MOVWF  01
09574:  MOVLW  01
09576:  ADDWFC 03,F
09578:  MOVFF  01,6A1
0957C:  MOVFF  03,6A2
09580:  MOVFF  03,6A5
09584:  MOVFF  01,6A4
09588:  MOVLB  0
0958A:  CALL   5B22
0958E:  MOVF   01,F
09590:  BNZ   959A
09592:  MOVLW  02
09594:  MOVWF  01
09596:  BRA    9BDE
09598:  BRA    95F8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0959A:  MOVLB  6
0959C:  CLRF   xB3
0959E:  MOVFF  66C,6B2
095A2:  CLRF   xB5
095A4:  MOVLW  B5
095A6:  MOVWF  xB4
095A8:  MOVLB  0
095AA:  CALL   0876
095AE:  MOVFF  02,6A2
095B2:  MOVFF  01,6A1
095B6:  MOVLW  06
095B8:  MOVLB  6
095BA:  ADDWF  xA1,F
095BC:  MOVLW  00
095BE:  ADDWFC xA2,F
095C0:  MOVLW  32
095C2:  ADDWF  xA1,W
095C4:  MOVWF  01
095C6:  MOVLW  00
095C8:  ADDWFC xA2,W
095CA:  MOVWF  03
095CC:  MOVF   01,W
095CE:  ADDLW  D1
095D0:  MOVWF  01
095D2:  MOVLW  01
095D4:  ADDWFC 03,F
095D6:  MOVFF  01,6A1
095DA:  MOVFF  03,6A2
095DE:  MOVFF  03,6A5
095E2:  MOVFF  01,6A4
095E6:  CLRF   xA7
095E8:  CLRF   xA6
095EA:  MOVLW  0A
095EC:  MOVWF  xA8
095EE:  MOVLB  0
095F0:  CALL   5C12
095F4:  MOVFF  01,67C
....................    
....................    arg2 = SERcmd[rec].p[3];
095F8:  MOVLB  6
095FA:  CLRF   xB3
095FC:  MOVFF  66C,6B2
09600:  CLRF   xB5
09602:  MOVLW  B5
09604:  MOVWF  xB4
09606:  MOVLB  0
09608:  CALL   0876
0960C:  MOVFF  02,6A2
09610:  MOVFF  01,6A1
09614:  MOVLW  06
09616:  MOVLB  6
09618:  ADDWF  xA1,F
0961A:  MOVLW  00
0961C:  ADDWFC xA2,F
0961E:  MOVLW  4B
09620:  ADDWF  xA1,W
09622:  MOVWF  01
09624:  MOVLW  00
09626:  ADDWFC xA2,W
09628:  MOVWF  03
0962A:  MOVF   01,W
0962C:  ADDLW  D1
0962E:  MOVWF  01
09630:  MOVLW  01
09632:  ADDWFC 03,F
09634:  MOVFF  01,67D
09638:  MOVFF  03,67E
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
0963C:  MOVFF  680,6B3
09640:  MOVFF  67F,6B2
09644:  MOVFF  67E,6B5
09648:  MOVFF  67D,6B4
0964C:  MOVLB  0
0964E:  CALL   59E2
09652:  MOVF   01,F
09654:  BTFSS  FD8.2
09656:  BRA    97D2
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09658:  MOVLW  04
0965A:  MOVLB  6
0965C:  MOVWF  xB3
0965E:  MOVLW  A7
09660:  MOVWF  xB2
09662:  MOVLB  0
09664:  CALL   59AA
09668:  MOVFF  02,03
0966C:  MOVF   01,W
0966E:  ADDLW  A7
09670:  MOVLB  6
09672:  MOVWF  xA1
09674:  MOVLW  04
09676:  ADDWFC 02,W
09678:  MOVWF  xA2
0967A:  MOVFF  FE8,54B
0967E:  MOVFF  6A1,54A
09682:  MOVFF  67C,6A5
09686:  MOVLW  18
09688:  MOVWF  xA6
0968A:  MOVLB  0
0968C:  CALL   5F66
09690:  MOVLW  2C
09692:  MOVLB  6
09694:  MOVWF  xC1
09696:  MOVLB  0
09698:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0969C:  MOVLW  04
0969E:  MOVLB  6
096A0:  MOVWF  xB3
096A2:  MOVLW  A7
096A4:  MOVWF  xB2
096A6:  MOVLB  0
096A8:  CALL   59AA
096AC:  MOVFF  02,03
096B0:  MOVF   01,W
096B2:  ADDLW  A7
096B4:  MOVLB  6
096B6:  MOVWF  xA1
096B8:  MOVLW  04
096BA:  ADDWFC 02,W
096BC:  MOVWF  xA2
096BE:  MOVLW  01
096C0:  SUBWF  x7C,W
096C2:  MULLW  21
096C4:  MOVF   FF3,W
096C6:  CLRF   xA4
096C8:  MOVWF  xA3
096CA:  MOVLW  07
096CC:  ADDWF  xA3,W
096CE:  MOVWF  FE9
096D0:  MOVLW  01
096D2:  ADDWFC xA4,W
096D4:  MOVWF  FEA
096D6:  MOVFF  FEF,6C1
096DA:  MOVFF  FEC,01
096DE:  MOVFF  FEC,02
096E2:  MOVFF  FEC,03
096E6:  MOVFF  03,6C4
096EA:  MOVFF  02,6C3
096EE:  MOVFF  01,6C2
096F2:  MOVLB  0
096F4:  CALL   55CC
096F8:  MOVFF  03,6A8
096FC:  MOVFF  02,6A7
09700:  MOVFF  01,6A6
09704:  MOVFF  00,6A5
09708:  MOVFF  6A2,54B
0970C:  MOVFF  6A1,54A
09710:  MOVLW  41
09712:  MOVWF  FE9
09714:  MOVFF  03,6AD
09718:  MOVFF  02,6AC
0971C:  MOVFF  01,6AB
09720:  MOVFF  00,6AA
09724:  RCALL  93A0
09726:  MOVLW  2C
09728:  MOVLB  6
0972A:  MOVWF  xC1
0972C:  MOVLB  0
0972E:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
09732:  MOVLW  04
09734:  MOVLB  6
09736:  MOVWF  xB3
09738:  MOVLW  A7
0973A:  MOVWF  xB2
0973C:  MOVLB  0
0973E:  CALL   59AA
09742:  MOVF   01,W
09744:  ADDLW  A7
09746:  MOVLB  6
09748:  MOVWF  xA1
0974A:  MOVLW  04
0974C:  ADDWFC 02,W
0974E:  MOVWF  xA2
09750:  MOVLW  01
09752:  SUBWF  x7C,W
09754:  MULLW  21
09756:  MOVF   FF3,W
09758:  CLRF   xA4
0975A:  MOVWF  xA3
0975C:  MOVLW  04
0975E:  ADDWF  xA3,W
09760:  MOVWF  01
09762:  MOVLW  00
09764:  ADDWFC xA4,W
09766:  MOVWF  03
09768:  MOVF   01,W
0976A:  ADDLW  07
0976C:  MOVWF  FE9
0976E:  MOVLW  01
09770:  ADDWFC 03,W
09772:  MOVWF  FEA
09774:  MOVFF  FEF,6C1
09778:  MOVFF  FEC,01
0977C:  MOVFF  FEC,02
09780:  MOVFF  FEC,03
09784:  MOVFF  03,6C4
09788:  MOVFF  02,6C3
0978C:  MOVFF  01,6C2
09790:  MOVLB  0
09792:  CALL   55CC
09796:  MOVFF  03,6A6
0979A:  MOVFF  02,6A5
0979E:  MOVFF  01,6A4
097A2:  MOVFF  00,6A3
097A6:  MOVFF  6A2,54B
097AA:  MOVFF  6A1,54A
097AE:  MOVLW  41
097B0:  MOVWF  FE9
097B2:  MOVFF  03,6AD
097B6:  MOVFF  02,6AC
097BA:  MOVFF  01,6AB
097BE:  MOVFF  00,6AA
097C2:  RCALL  93A0
097C4:  MOVLW  2C
097C6:  MOVLB  6
097C8:  MOVWF  xC1
097CA:  MOVLB  0
097CC:  CALL   5A5A
....................    }
097D0:  BRA    9BDA
....................    else if (0 == strcmp(s_calibrated, arg2)) {
097D2:  MOVFF  686,6B3
097D6:  MOVFF  685,6B2
097DA:  MOVFF  67E,6B5
097DE:  MOVFF  67D,6B4
097E2:  CALL   59E2
097E6:  MOVF   01,F
097E8:  BTFSS  FD8.2
097EA:  BRA    996E
....................       sprintf(retData+strlen(retData), "%d,", arg1);
097EC:  MOVLW  04
097EE:  MOVLB  6
097F0:  MOVWF  xB3
097F2:  MOVLW  A7
097F4:  MOVWF  xB2
097F6:  MOVLB  0
097F8:  CALL   59AA
097FC:  MOVFF  02,03
09800:  MOVF   01,W
09802:  ADDLW  A7
09804:  MOVLB  6
09806:  MOVWF  xA1
09808:  MOVLW  04
0980A:  ADDWFC 02,W
0980C:  MOVWF  xA2
0980E:  MOVFF  FE8,54B
09812:  MOVFF  6A1,54A
09816:  MOVFF  67C,6A5
0981A:  MOVLW  18
0981C:  MOVWF  xA6
0981E:  MOVLB  0
09820:  CALL   5F66
09824:  MOVLW  2C
09826:  MOVLB  6
09828:  MOVWF  xC1
0982A:  MOVLB  0
0982C:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
09830:  MOVLW  04
09832:  MOVLB  6
09834:  MOVWF  xB3
09836:  MOVLW  A7
09838:  MOVWF  xB2
0983A:  MOVLB  0
0983C:  CALL   59AA
09840:  MOVF   01,W
09842:  ADDLW  A7
09844:  MOVLB  6
09846:  MOVWF  xA1
09848:  MOVLW  04
0984A:  ADDWFC 02,W
0984C:  MOVWF  xA2
0984E:  MOVLW  01
09850:  SUBWF  x7C,W
09852:  MULLW  21
09854:  MOVF   FF3,W
09856:  CLRF   xA4
09858:  MOVWF  xA3
0985A:  MOVLW  08
0985C:  ADDWF  xA3,W
0985E:  MOVWF  01
09860:  MOVLW  00
09862:  ADDWFC xA4,W
09864:  MOVWF  03
09866:  MOVF   01,W
09868:  ADDLW  07
0986A:  MOVWF  FE9
0986C:  MOVLW  01
0986E:  ADDWFC 03,W
09870:  MOVWF  FEA
09872:  MOVFF  FEF,6C1
09876:  MOVFF  FEC,01
0987A:  MOVFF  FEC,02
0987E:  MOVFF  FEC,03
09882:  MOVFF  03,6C4
09886:  MOVFF  02,6C3
0988A:  MOVFF  01,6C2
0988E:  MOVLB  0
09890:  CALL   55CC
09894:  MOVFF  03,6A6
09898:  MOVFF  02,6A5
0989C:  MOVFF  01,6A4
098A0:  MOVFF  00,6A3
098A4:  MOVFF  6A2,54B
098A8:  MOVFF  6A1,54A
098AC:  MOVLW  41
098AE:  MOVWF  FE9
098B0:  MOVFF  03,6AD
098B4:  MOVFF  02,6AC
098B8:  MOVFF  01,6AB
098BC:  MOVFF  00,6AA
098C0:  RCALL  93A0
098C2:  MOVLW  2C
098C4:  MOVLB  6
098C6:  MOVWF  xC1
098C8:  MOVLB  0
098CA:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
098CE:  MOVLW  04
098D0:  MOVLB  6
098D2:  MOVWF  xB3
098D4:  MOVLW  A7
098D6:  MOVWF  xB2
098D8:  MOVLB  0
098DA:  CALL   59AA
098DE:  MOVF   01,W
098E0:  ADDLW  A7
098E2:  MOVLB  6
098E4:  MOVWF  xA1
098E6:  MOVLW  04
098E8:  ADDWFC 02,W
098EA:  MOVWF  xA2
098EC:  MOVLW  01
098EE:  SUBWF  x7C,W
098F0:  MULLW  21
098F2:  MOVF   FF3,W
098F4:  CLRF   xA4
098F6:  MOVWF  xA3
098F8:  MOVLW  0C
098FA:  ADDWF  xA3,W
098FC:  MOVWF  01
098FE:  MOVLW  00
09900:  ADDWFC xA4,W
09902:  MOVWF  03
09904:  MOVF   01,W
09906:  ADDLW  07
09908:  MOVWF  FE9
0990A:  MOVLW  01
0990C:  ADDWFC 03,W
0990E:  MOVWF  FEA
09910:  MOVFF  FEF,6C1
09914:  MOVFF  FEC,01
09918:  MOVFF  FEC,02
0991C:  MOVFF  FEC,03
09920:  MOVFF  03,6C4
09924:  MOVFF  02,6C3
09928:  MOVFF  01,6C2
0992C:  MOVLB  0
0992E:  CALL   55CC
09932:  MOVFF  03,6A6
09936:  MOVFF  02,6A5
0993A:  MOVFF  01,6A4
0993E:  MOVFF  00,6A3
09942:  MOVFF  6A2,54B
09946:  MOVFF  6A1,54A
0994A:  MOVLW  41
0994C:  MOVWF  FE9
0994E:  MOVFF  03,6AD
09952:  MOVFF  02,6AC
09956:  MOVFF  01,6AB
0995A:  MOVFF  00,6AA
0995E:  RCALL  93A0
09960:  MOVLW  2C
09962:  MOVLB  6
09964:  MOVWF  xC1
09966:  MOVLB  0
09968:  CALL   5A5A
....................    }
0996C:  BRA    9BDA
....................    else if (0 == strcmp(s_p0, arg2)) {
0996E:  MOVFF  68E,6B3
09972:  MOVFF  68D,6B2
09976:  MOVFF  67E,6B5
0997A:  MOVFF  67D,6B4
0997E:  CALL   59E2
09982:  MOVF   01,F
09984:  BNZ   9A40
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09986:  MOVLW  04
09988:  MOVLB  6
0998A:  MOVWF  xB3
0998C:  MOVLW  A7
0998E:  MOVWF  xB2
09990:  MOVLB  0
09992:  CALL   59AA
09996:  MOVFF  02,03
0999A:  MOVF   01,W
0999C:  ADDLW  A7
0999E:  MOVLB  6
099A0:  MOVWF  xA1
099A2:  MOVLW  04
099A4:  ADDWFC 02,W
099A6:  MOVWF  xA2
099A8:  MOVFF  FE8,54B
099AC:  MOVFF  6A1,54A
099B0:  MOVFF  67C,6A5
099B4:  MOVLW  18
099B6:  MOVWF  xA6
099B8:  MOVLB  0
099BA:  CALL   5F66
099BE:  MOVLW  2C
099C0:  MOVLB  6
099C2:  MOVWF  xC1
099C4:  MOVLB  0
099C6:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
099CA:  MOVLW  04
099CC:  MOVLB  6
099CE:  MOVWF  xB3
099D0:  MOVLW  A7
099D2:  MOVWF  xB2
099D4:  MOVLB  0
099D6:  CALL   59AA
099DA:  MOVF   01,W
099DC:  ADDLW  A7
099DE:  MOVLB  6
099E0:  MOVWF  xA1
099E2:  MOVLW  04
099E4:  ADDWFC 02,W
099E6:  MOVWF  xA2
099E8:  MOVLW  01
099EA:  SUBWF  x7C,W
099EC:  MULLW  21
099EE:  MOVF   FF3,W
099F0:  CLRF   xA4
099F2:  MOVWF  xA3
099F4:  MOVLW  18
099F6:  ADDWF  xA3,W
099F8:  MOVWF  01
099FA:  MOVLW  00
099FC:  ADDWFC xA4,W
099FE:  MOVWF  03
09A00:  MOVF   01,W
09A02:  ADDLW  07
09A04:  MOVWF  FE9
09A06:  MOVLW  01
09A08:  ADDWFC 03,W
09A0A:  MOVWF  FEA
09A0C:  MOVFF  FEF,6B4
09A10:  MOVFF  FEC,6B5
09A14:  MOVFF  FEC,6B6
09A18:  MOVFF  FEC,6B7
09A1C:  MOVFF  6A2,54B
09A20:  MOVFF  6A1,54A
09A24:  MOVLW  89
09A26:  MOVWF  FE9
09A28:  MOVLW  02
09A2A:  MOVWF  xB8
09A2C:  MOVLB  0
09A2E:  CALL   6782
09A32:  MOVLW  2C
09A34:  MOVLB  6
09A36:  MOVWF  xC1
09A38:  MOVLB  0
09A3A:  CALL   5A5A
....................    }
09A3E:  BRA    9BDA
....................    else if (0 == strcmp(s_poles, arg2)) {
09A40:  MOVFF  693,6B3
09A44:  MOVFF  692,6B2
09A48:  MOVFF  67E,6B5
09A4C:  MOVFF  67D,6B4
09A50:  CALL   59E2
09A54:  MOVF   01,F
09A56:  BNZ   9B02
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A58:  MOVLW  04
09A5A:  MOVLB  6
09A5C:  MOVWF  xB3
09A5E:  MOVLW  A7
09A60:  MOVWF  xB2
09A62:  MOVLB  0
09A64:  CALL   59AA
09A68:  MOVFF  02,03
09A6C:  MOVF   01,W
09A6E:  ADDLW  A7
09A70:  MOVLB  6
09A72:  MOVWF  xA1
09A74:  MOVLW  04
09A76:  ADDWFC 02,W
09A78:  MOVWF  xA2
09A7A:  MOVFF  FE8,54B
09A7E:  MOVFF  6A1,54A
09A82:  MOVFF  67C,6A5
09A86:  MOVLW  18
09A88:  MOVWF  xA6
09A8A:  MOVLB  0
09A8C:  CALL   5F66
09A90:  MOVLW  2C
09A92:  MOVLB  6
09A94:  MOVWF  xC1
09A96:  MOVLB  0
09A98:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09A9C:  MOVLW  04
09A9E:  MOVLB  6
09AA0:  MOVWF  xB3
09AA2:  MOVLW  A7
09AA4:  MOVWF  xB2
09AA6:  MOVLB  0
09AA8:  CALL   59AA
09AAC:  MOVF   01,W
09AAE:  ADDLW  A7
09AB0:  MOVLB  6
09AB2:  MOVWF  xA1
09AB4:  MOVLW  04
09AB6:  ADDWFC 02,W
09AB8:  MOVWF  xA2
09ABA:  MOVLW  01
09ABC:  SUBWF  x7C,W
09ABE:  MULLW  21
09AC0:  MOVF   FF3,W
09AC2:  CLRF   xA4
09AC4:  MOVWF  xA3
09AC6:  MOVLW  1C
09AC8:  ADDWF  xA3,W
09ACA:  MOVWF  01
09ACC:  MOVLW  00
09ACE:  ADDWFC xA4,W
09AD0:  MOVWF  03
09AD2:  MOVF   01,W
09AD4:  ADDLW  07
09AD6:  MOVWF  FE9
09AD8:  MOVLW  01
09ADA:  ADDWFC 03,W
09ADC:  MOVWF  FEA
09ADE:  MOVFF  FEF,6A5
09AE2:  MOVFF  6A2,54B
09AE6:  MOVFF  6A1,54A
09AEA:  MOVLW  18
09AEC:  MOVWF  xA6
09AEE:  MOVLB  0
09AF0:  CALL   5F66
09AF4:  MOVLW  2C
09AF6:  MOVLB  6
09AF8:  MOVWF  xC1
09AFA:  MOVLB  0
09AFC:  CALL   5A5A
....................    }
09B00:  BRA    9BDA
....................    else if (0 == strcmp(s_real, arg2)) {
09B02:  MOVFF  69B,6B3
09B06:  MOVFF  69A,6B2
09B0A:  MOVFF  67E,6B5
09B0E:  MOVFF  67D,6B4
09B12:  CALL   59E2
09B16:  MOVF   01,F
09B18:  BNZ   9BD4
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09B1A:  MOVLW  04
09B1C:  MOVLB  6
09B1E:  MOVWF  xB3
09B20:  MOVLW  A7
09B22:  MOVWF  xB2
09B24:  MOVLB  0
09B26:  CALL   59AA
09B2A:  MOVFF  02,03
09B2E:  MOVF   01,W
09B30:  ADDLW  A7
09B32:  MOVLB  6
09B34:  MOVWF  xA1
09B36:  MOVLW  04
09B38:  ADDWFC 02,W
09B3A:  MOVWF  xA2
09B3C:  MOVFF  FE8,54B
09B40:  MOVFF  6A1,54A
09B44:  MOVFF  67C,6A5
09B48:  MOVLW  18
09B4A:  MOVWF  xA6
09B4C:  MOVLB  0
09B4E:  CALL   5F66
09B52:  MOVLW  2C
09B54:  MOVLB  6
09B56:  MOVWF  xC1
09B58:  MOVLB  0
09B5A:  CALL   5A5A
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09B5E:  MOVLW  04
09B60:  MOVLB  6
09B62:  MOVWF  xB3
09B64:  MOVLW  A7
09B66:  MOVWF  xB2
09B68:  MOVLB  0
09B6A:  CALL   59AA
09B6E:  MOVF   01,W
09B70:  ADDLW  A7
09B72:  MOVLB  6
09B74:  MOVWF  xA1
09B76:  MOVLW  04
09B78:  ADDWFC 02,W
09B7A:  MOVWF  xA2
09B7C:  MOVLW  01
09B7E:  SUBWF  x7C,W
09B80:  MULLW  21
09B82:  MOVF   FF3,W
09B84:  CLRF   xA4
09B86:  MOVWF  xA3
09B88:  MOVLW  1D
09B8A:  ADDWF  xA3,W
09B8C:  MOVWF  01
09B8E:  MOVLW  00
09B90:  ADDWFC xA4,W
09B92:  MOVWF  03
09B94:  MOVF   01,W
09B96:  ADDLW  07
09B98:  MOVWF  FE9
09B9A:  MOVLW  01
09B9C:  ADDWFC 03,W
09B9E:  MOVWF  FEA
09BA0:  MOVFF  FEF,6B4
09BA4:  MOVFF  FEC,6B5
09BA8:  MOVFF  FEC,6B6
09BAC:  MOVFF  FEC,6B7
09BB0:  MOVFF  6A2,54B
09BB4:  MOVFF  6A1,54A
09BB8:  MOVLW  89
09BBA:  MOVWF  FE9
09BBC:  MOVLW  02
09BBE:  MOVWF  xB8
09BC0:  MOVLB  0
09BC2:  CALL   6782
09BC6:  MOVLW  2C
09BC8:  MOVLB  6
09BCA:  MOVWF  xC1
09BCC:  MOVLB  0
09BCE:  CALL   5A5A
....................    }
09BD2:  BRA    9BDA
....................    else return INV_PARAM;
09BD4:  MOVLW  02
09BD6:  MOVWF  01
09BD8:  BRA    9BDE
....................    
....................    return SUCCESS;
09BDA:  MOVLW  00
09BDC:  MOVWF  01
09BDE:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09BE0:  MOVLB  6
09BE2:  CLRF   xB3
09BE4:  MOVFF  66C,6B2
09BE8:  CLRF   xB5
09BEA:  MOVLW  B5
09BEC:  MOVWF  xB4
09BEE:  MOVLB  0
09BF0:  CALL   0876
09BF4:  MOVFF  02,67E
09BF8:  MOVFF  01,67D
09BFC:  MOVLW  06
09BFE:  MOVLB  6
09C00:  ADDWF  x7D,F
09C02:  MOVLW  00
09C04:  ADDWFC x7E,F
09C06:  MOVLW  32
09C08:  ADDWF  x7D,W
09C0A:  MOVWF  01
09C0C:  MOVLW  00
09C0E:  ADDWFC x7E,W
09C10:  MOVWF  03
09C12:  MOVF   01,W
09C14:  ADDLW  D1
09C16:  MOVWF  01
09C18:  MOVLW  01
09C1A:  ADDWFC 03,F
09C1C:  MOVFF  01,67D
09C20:  MOVFF  03,67E
09C24:  MOVFF  03,6A5
09C28:  MOVFF  01,6A4
09C2C:  MOVLB  0
09C2E:  CALL   5B22
09C32:  MOVF   01,F
09C34:  BNZ   9C3E
09C36:  MOVLW  02
09C38:  MOVWF  01
09C3A:  BRA    9D30
09C3C:  BRA    9C9C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09C3E:  MOVLB  6
09C40:  CLRF   xB3
09C42:  MOVFF  66C,6B2
09C46:  CLRF   xB5
09C48:  MOVLW  B5
09C4A:  MOVWF  xB4
09C4C:  MOVLB  0
09C4E:  CALL   0876
09C52:  MOVFF  02,67E
09C56:  MOVFF  01,67D
09C5A:  MOVLW  06
09C5C:  MOVLB  6
09C5E:  ADDWF  x7D,F
09C60:  MOVLW  00
09C62:  ADDWFC x7E,F
09C64:  MOVLW  32
09C66:  ADDWF  x7D,W
09C68:  MOVWF  01
09C6A:  MOVLW  00
09C6C:  ADDWFC x7E,W
09C6E:  MOVWF  03
09C70:  MOVF   01,W
09C72:  ADDLW  D1
09C74:  MOVWF  01
09C76:  MOVLW  01
09C78:  ADDWFC 03,F
09C7A:  MOVFF  01,67D
09C7E:  MOVFF  03,67E
09C82:  MOVFF  03,6A5
09C86:  MOVFF  01,6A4
09C8A:  CLRF   xA7
09C8C:  CLRF   xA6
09C8E:  MOVLW  0A
09C90:  MOVWF  xA8
09C92:  MOVLB  0
09C94:  CALL   5C12
09C98:  MOVFF  01,67C
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
09C9C:  MOVLW  04
09C9E:  MOVLB  6
09CA0:  MOVWF  xB3
09CA2:  MOVLW  A7
09CA4:  MOVWF  xB2
09CA6:  MOVLB  0
09CA8:  CALL   59AA
09CAC:  MOVF   01,W
09CAE:  ADDLW  A7
09CB0:  MOVLB  6
09CB2:  MOVWF  x7D
09CB4:  MOVLW  04
09CB6:  ADDWFC 02,W
09CB8:  MOVWF  x7E
09CBA:  MOVLW  01
09CBC:  SUBWF  x7C,W
09CBE:  MULLW  04
09CC0:  MOVF   FF3,W
09CC2:  CLRF   03
09CC4:  ADDLW  50
09CC6:  MOVWF  FE9
09CC8:  MOVLW  01
09CCA:  ADDWFC 03,W
09CCC:  MOVWF  FEA
09CCE:  MOVFF  FEF,67F
09CD2:  MOVFF  FEC,680
09CD6:  MOVFF  FEC,681
09CDA:  MOVFF  FEC,682
09CDE:  MOVFF  67E,54B
09CE2:  MOVFF  67D,54A
09CE6:  MOVFF  67C,6A5
09CEA:  MOVLW  18
09CEC:  MOVWF  xA6
09CEE:  MOVLB  0
09CF0:  CALL   5F66
09CF4:  MOVLW  2C
09CF6:  MOVLB  6
09CF8:  MOVWF  xC1
09CFA:  MOVLB  0
09CFC:  CALL   5A5A
09D00:  MOVLW  89
09D02:  MOVWF  FE9
09D04:  MOVFF  682,6B7
09D08:  MOVFF  681,6B6
09D0C:  MOVFF  680,6B5
09D10:  MOVFF  67F,6B4
09D14:  MOVLW  02
09D16:  MOVLB  6
09D18:  MOVWF  xB8
09D1A:  MOVLB  0
09D1C:  CALL   6782
09D20:  MOVLW  2C
09D22:  MOVLB  6
09D24:  MOVWF  xC1
09D26:  MOVLB  0
09D28:  CALL   5A5A
....................    
....................    return SUCCESS;
09D2C:  MOVLW  00
09D2E:  MOVWF  01
09D30:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09D32:  MOVLB  6
09D34:  CLRF   xB3
09D36:  MOVFF  66C,6B2
09D3A:  CLRF   xB5
09D3C:  MOVLW  B5
09D3E:  MOVWF  xB4
09D40:  MOVLB  0
09D42:  CALL   0876
09D46:  MOVFF  02,682
09D4A:  MOVFF  01,681
09D4E:  MOVLW  06
09D50:  MOVLB  6
09D52:  ADDWF  x81,F
09D54:  MOVLW  00
09D56:  ADDWFC x82,F
09D58:  MOVLW  32
09D5A:  ADDWF  x81,W
09D5C:  MOVWF  01
09D5E:  MOVLW  00
09D60:  ADDWFC x82,W
09D62:  MOVWF  03
09D64:  MOVF   01,W
09D66:  ADDLW  D1
09D68:  MOVWF  01
09D6A:  MOVLW  01
09D6C:  ADDWFC 03,F
09D6E:  MOVFF  01,681
09D72:  MOVFF  03,682
09D76:  MOVFF  03,6A5
09D7A:  MOVFF  01,6A4
09D7E:  MOVLB  0
09D80:  CALL   5B22
09D84:  MOVF   01,F
09D86:  BNZ   9D90
09D88:  MOVLW  02
09D8A:  MOVWF  01
09D8C:  BRA    9F72
09D8E:  BRA    9DEE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09D90:  MOVLB  6
09D92:  CLRF   xB3
09D94:  MOVFF  66C,6B2
09D98:  CLRF   xB5
09D9A:  MOVLW  B5
09D9C:  MOVWF  xB4
09D9E:  MOVLB  0
09DA0:  CALL   0876
09DA4:  MOVFF  02,682
09DA8:  MOVFF  01,681
09DAC:  MOVLW  06
09DAE:  MOVLB  6
09DB0:  ADDWF  x81,F
09DB2:  MOVLW  00
09DB4:  ADDWFC x82,F
09DB6:  MOVLW  32
09DB8:  ADDWF  x81,W
09DBA:  MOVWF  01
09DBC:  MOVLW  00
09DBE:  ADDWFC x82,W
09DC0:  MOVWF  03
09DC2:  MOVF   01,W
09DC4:  ADDLW  D1
09DC6:  MOVWF  01
09DC8:  MOVLW  01
09DCA:  ADDWFC 03,F
09DCC:  MOVFF  01,681
09DD0:  MOVFF  03,682
09DD4:  MOVFF  03,6A5
09DD8:  MOVFF  01,6A4
09DDC:  CLRF   xA7
09DDE:  CLRF   xA6
09DE0:  MOVLW  0A
09DE2:  MOVWF  xA8
09DE4:  MOVLB  0
09DE6:  CALL   5C12
09DEA:  MOVFF  01,67C
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09DEE:  MOVLB  6
09DF0:  CLRF   xB3
09DF2:  MOVFF  66C,6B2
09DF6:  CLRF   xB5
09DF8:  MOVLW  B5
09DFA:  MOVWF  xB4
09DFC:  MOVLB  0
09DFE:  CALL   0876
09E02:  MOVFF  02,682
09E06:  MOVFF  01,681
09E0A:  MOVLW  06
09E0C:  MOVLB  6
09E0E:  ADDWF  x81,F
09E10:  MOVLW  00
09E12:  ADDWFC x82,F
09E14:  MOVLW  4B
09E16:  ADDWF  x81,W
09E18:  MOVWF  01
09E1A:  MOVLW  00
09E1C:  ADDWFC x82,W
09E1E:  MOVWF  03
09E20:  MOVF   01,W
09E22:  ADDLW  D1
09E24:  MOVWF  01
09E26:  MOVLW  01
09E28:  ADDWFC 03,F
09E2A:  MOVFF  01,681
09E2E:  MOVFF  03,682
09E32:  MOVFF  03,686
09E36:  MOVFF  01,685
09E3A:  MOVLB  0
09E3C:  CALL   6DEE
09E40:  MOVF   01,F
09E42:  BNZ   9E4C
09E44:  MOVLW  02
09E46:  MOVWF  01
09E48:  BRA    9F72
09E4A:  BRA    9EB2
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09E4C:  MOVLB  6
09E4E:  CLRF   xB3
09E50:  MOVFF  66C,6B2
09E54:  CLRF   xB5
09E56:  MOVLW  B5
09E58:  MOVWF  xB4
09E5A:  MOVLB  0
09E5C:  CALL   0876
09E60:  MOVFF  02,682
09E64:  MOVFF  01,681
09E68:  MOVLW  06
09E6A:  MOVLB  6
09E6C:  ADDWF  x81,F
09E6E:  MOVLW  00
09E70:  ADDWFC x82,F
09E72:  MOVLW  4B
09E74:  ADDWF  x81,W
09E76:  MOVWF  01
09E78:  MOVLW  00
09E7A:  ADDWFC x82,W
09E7C:  MOVWF  03
09E7E:  MOVF   01,W
09E80:  ADDLW  D1
09E82:  MOVWF  01
09E84:  MOVLW  01
09E86:  ADDWFC 03,F
09E88:  MOVFF  01,681
09E8C:  MOVFF  03,682
09E90:  MOVFF  03,686
09E94:  MOVFF  01,685
09E98:  CLRF   x88
09E9A:  CLRF   x87
09E9C:  MOVLB  0
09E9E:  CALL   6EB0
09EA2:  MOVFF  03,680
09EA6:  MOVFF  02,67F
09EAA:  MOVFF  01,67E
09EAE:  MOVFF  00,67D
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09EB2:  MOVLB  6
09EB4:  CLRF   xBF
09EB6:  CLRF   xBE
09EB8:  MOVLW  7C
09EBA:  MOVWF  xBD
09EBC:  MOVLW  84
09EBE:  MOVWF  xBC
09EC0:  MOVFF  680,6C3
09EC4:  MOVFF  67F,6C2
09EC8:  MOVFF  67E,6C1
09ECC:  MOVFF  67D,6C0
09ED0:  MOVLB  0
09ED2:  CALL   1CEA
09ED6:  BNC   9EFC
09ED8:  MOVLW  01
09EDA:  MOVLB  6
09EDC:  SUBWF  x7C,W
09EDE:  MULLW  04
09EE0:  MOVF   FF3,W
09EE2:  CLRF   03
09EE4:  ADDLW  50
09EE6:  MOVWF  FE9
09EE8:  MOVLW  01
09EEA:  ADDWFC 03,W
09EEC:  MOVWF  FEA
09EEE:  MOVLW  84
09EF0:  MOVWF  FEF
09EF2:  MOVLW  7C
09EF4:  MOVWF  FEC
09EF6:  CLRF   FEC
09EF8:  CLRF   FEC
09EFA:  BRA    9F6C
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
09EFC:  MOVFF  680,6BF
09F00:  MOVFF  67F,6BE
09F04:  MOVFF  67E,6BD
09F08:  MOVFF  67D,6BC
09F0C:  MOVLB  6
09F0E:  CLRF   xC3
09F10:  CLRF   xC2
09F12:  MOVLW  FC
09F14:  MOVWF  xC1
09F16:  MOVLW  84
09F18:  MOVWF  xC0
09F1A:  MOVLB  0
09F1C:  CALL   1CEA
09F20:  BNC   9F46
09F22:  MOVLW  01
09F24:  MOVLB  6
09F26:  SUBWF  x7C,W
09F28:  MULLW  04
09F2A:  MOVF   FF3,W
09F2C:  CLRF   03
09F2E:  ADDLW  50
09F30:  MOVWF  FE9
09F32:  MOVLW  01
09F34:  ADDWFC 03,W
09F36:  MOVWF  FEA
09F38:  MOVLW  84
09F3A:  MOVWF  FEF
09F3C:  MOVLW  FC
09F3E:  MOVWF  FEC
09F40:  CLRF   FEC
09F42:  CLRF   FEC
09F44:  BRA    9F6C
....................    else manualOutputValues[arg1-1] = arg2;
09F46:  MOVLW  01
09F48:  MOVLB  6
09F4A:  SUBWF  x7C,W
09F4C:  MULLW  04
09F4E:  MOVF   FF3,W
09F50:  CLRF   03
09F52:  ADDLW  50
09F54:  MOVWF  FE9
09F56:  MOVLW  01
09F58:  ADDWFC 03,W
09F5A:  MOVWF  FEA
09F5C:  MOVFF  67D,FEF
09F60:  MOVFF  67E,FEC
09F64:  MOVFF  67F,FEC
09F68:  MOVFF  680,FEC
....................    
....................    return SUCCESS;
09F6C:  MOVLW  00
09F6E:  MOVWF  01
09F70:  MOVLB  0
09F72:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09F74:  MOVLB  1
09F76:  BSF    x49.0
....................    return SUCCESS;
09F78:  MOVLW  00
09F7A:  MOVWF  01
09F7C:  MOVLB  0
09F7E:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09F80:  MOVLB  1
09F82:  BCF    x49.0
....................    return SUCCESS;
09F84:  MOVLW  00
09F86:  MOVWF  01
09F88:  MOVLB  0
09F8A:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09F8C:  MOVLW  01
09F8E:  MOVWF  01
09F90:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06DEE:  MOVLB  6
06DF0:  BCF    x87.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06DF2:  CLRF   x88
06DF4:  MOVFF  686,6B3
06DF8:  MOVFF  685,6B2
06DFC:  MOVLB  0
06DFE:  CALL   59AA
06E02:  MOVFF  02,03
06E06:  MOVF   01,W
06E08:  MOVF   03,F
06E0A:  BNZ   6E16
06E0C:  MOVF   01,W
06E0E:  MOVLB  6
06E10:  SUBWF  x88,W
06E12:  BC    6EA8
06E14:  MOVLB  0
....................       if (!isdigit(arg[i])){
06E16:  MOVLB  6
06E18:  MOVF   x88,W
06E1A:  ADDWF  x85,W
06E1C:  MOVWF  FE9
06E1E:  MOVLW  00
06E20:  ADDWFC x86,W
06E22:  MOVWF  FEA
06E24:  MOVFF  FEF,689
06E28:  MOVF   x89,W
06E2A:  SUBLW  2F
06E2C:  BC    6E34
06E2E:  MOVF   x89,W
06E30:  SUBLW  39
06E32:  BC    6EA0
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06E34:  MOVF   x88,W
06E36:  ADDWF  x85,W
06E38:  MOVWF  FE9
06E3A:  MOVLW  00
06E3C:  ADDWFC x86,W
06E3E:  MOVWF  FEA
06E40:  MOVF   FEF,W
06E42:  SUBLW  2D
06E44:  BZ    6E70
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06E46:  MOVF   x88,W
06E48:  ADDWF  x85,W
06E4A:  MOVWF  FE9
06E4C:  MOVLW  00
06E4E:  ADDWFC x86,W
06E50:  MOVWF  FEA
06E52:  MOVF   FEF,W
06E54:  SUBLW  2E
06E56:  BZ    6E60
06E58:  MOVLW  00
06E5A:  MOVWF  01
06E5C:  BRA    6EAC
06E5E:  BRA    6E6E
....................             else if  (decimal) return FALSE;
06E60:  BTFSS  x87.0
06E62:  BRA    6E6C
06E64:  MOVLW  00
06E66:  MOVWF  01
06E68:  BRA    6EAC
06E6A:  BRA    6E6E
....................             else decimal = TRUE;
06E6C:  BSF    x87.0
....................          }
06E6E:  BRA    6EA0
....................          else if (0 != i) return FALSE;
06E70:  MOVF   x88,F
06E72:  BZ    6E7C
06E74:  MOVLW  00
06E76:  MOVWF  01
06E78:  BRA    6EAC
06E7A:  BRA    6EA0
....................          else if (1 == strlen(arg)) return FALSE;
06E7C:  MOVFF  686,6B3
06E80:  MOVFF  685,6B2
06E84:  MOVLB  0
06E86:  CALL   59AA
06E8A:  MOVFF  02,03
06E8E:  MOVF   01,W
06E90:  SUBLW  01
06E92:  BNZ   6EA2
06E94:  MOVF   03,F
06E96:  BNZ   6EA2
06E98:  MOVLW  00
06E9A:  MOVWF  01
06E9C:  MOVLB  6
06E9E:  BRA    6EAC
06EA0:  MOVLB  0
....................       }
06EA2:  MOVLB  6
06EA4:  INCF   x88,F
06EA6:  BRA    6DF4
....................    }
....................    return TRUE;
06EA8:  MOVLW  01
06EAA:  MOVWF  01
06EAC:  MOVLB  0
06EAE:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05B22:  MOVFF  6A5,6B3
05B26:  MOVFF  6A4,6B2
05B2A:  RCALL  59AA
05B2C:  MOVFF  02,03
05B30:  MOVF   01,W
05B32:  SUBLW  01
05B34:  BNZ   5B3A
05B36:  MOVF   03,F
05B38:  BZ    5B42
05B3A:  MOVLW  00
05B3C:  MOVWF  01
05B3E:  BRA    5B70
05B40:  BRA    5B68
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05B42:  MOVLB  6
05B44:  MOVFF  6A4,FE9
05B48:  MOVFF  6A5,FEA
05B4C:  MOVF   FEF,W
05B4E:  SUBLW  31
05B50:  BZ    5B6A
05B52:  MOVFF  6A4,FE9
05B56:  MOVFF  6A5,FEA
05B5A:  MOVF   FEF,W
05B5C:  SUBLW  32
05B5E:  BZ    5B6A
05B60:  MOVLW  00
05B62:  MOVWF  01
05B64:  MOVLB  0
05B66:  BRA    5B70
05B68:  MOVLB  6
....................     return TRUE;
05B6A:  MOVLW  01
05B6C:  MOVWF  01
05B6E:  MOVLB  0
05B70:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05970:  MOVLB  6
05972:  MOVF   x7B,W
05974:  SUBLW  2F
05976:  BC    5988
05978:  MOVF   x7B,W
0597A:  SUBLW  39
0597C:  BNC   5988
0597E:  MOVLW  30
05980:  SUBWF  x7B,W
05982:  MOVWF  01
05984:  BRA    59A4
05986:  BRA    59A4
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05988:  MOVF   x7B,W
0598A:  SUBLW  40
0598C:  BC    59A0
0598E:  MOVF   x7B,W
05990:  SUBLW  46
05992:  BNC   59A0
05994:  MOVLW  41
05996:  SUBWF  x7B,W
05998:  ADDLW  0A
0599A:  MOVWF  01
0599C:  BRA    59A4
0599E:  BRA    59A4
....................    else return 0xFF;
059A0:  MOVLW  FF
059A2:  MOVWF  01
059A4:  MOVLB  0
059A6:  GOTO   A036 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09F92:  MOVLB  6
09F94:  CLRF   xB3
09F96:  MOVFF  672,6B2
09F9A:  CLRF   xB5
09F9C:  MOVLW  B5
09F9E:  MOVWF  xB4
09FA0:  MOVLB  0
09FA2:  CALL   0876
09FA6:  MOVFF  02,67B
09FAA:  MOVFF  01,67A
09FAE:  MOVLW  06
09FB0:  MOVLB  6
09FB2:  ADDWF  x7A,F
09FB4:  MOVLW  00
09FB6:  ADDWFC x7B,F
09FB8:  MOVLW  D1
09FBA:  ADDWF  x7A,W
09FBC:  MOVWF  01
09FBE:  MOVLW  01
09FC0:  ADDWFC x7B,W
09FC2:  MOVWF  03
09FC4:  MOVFF  01,673
09FC8:  MOVWF  x74
09FCA:  CLRF   xB3
09FCC:  MOVFF  672,6B2
09FD0:  CLRF   xB5
09FD2:  MOVLW  B5
09FD4:  MOVWF  xB4
09FD6:  MOVLB  0
09FD8:  CALL   0876
09FDC:  MOVFF  02,67D
09FE0:  MOVFF  01,67C
09FE4:  MOVLW  06
09FE6:  MOVLB  6
09FE8:  ADDWF  x7C,F
09FEA:  MOVLW  00
09FEC:  ADDWFC x7D,F
09FEE:  MOVLW  19
09FF0:  ADDWF  x7C,W
09FF2:  MOVWF  01
09FF4:  MOVLW  00
09FF6:  ADDWFC x7D,W
09FF8:  MOVWF  03
09FFA:  MOVF   01,W
09FFC:  ADDLW  D1
09FFE:  MOVWF  01
0A000:  MOVLW  01
0A002:  ADDWFC 03,F
0A004:  MOVFF  01,675
0A008:  MOVFF  03,676
0A00C:  CLRF   x77
0A00E:  CLRF   x78
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A010:  MOVFF  673,FE9
0A014:  MOVFF  674,FEA
0A018:  MOVF   FEF,W
0A01A:  SUBLW  44
0A01C:  BTFSS  FD8.2
0A01E:  BRA    A10E
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A020:  MOVLW  01
0A022:  ADDWF  x73,W
0A024:  MOVWF  FE9
0A026:  MOVLW  00
0A028:  ADDWFC x74,W
0A02A:  MOVWF  FEA
0A02C:  MOVFF  FEF,67B
0A030:  MOVLB  0
0A032:  GOTO   5970
0A036:  MOVFF  01,67A
0A03A:  MOVLB  6
0A03C:  MOVF   x77,W
0A03E:  ANDLW  0F
0A040:  SUBWF  01,W
0A042:  BNZ   A106
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A044:  MOVF   x78,W
0A046:  MULLW  04
0A048:  MOVF   FF3,W
0A04A:  CLRF   x7B
0A04C:  MOVWF  x7A
0A04E:  MOVLW  50
0A050:  ADDWF  x7A,W
0A052:  MOVWF  FE9
0A054:  MOVLW  05
0A056:  ADDWFC x7B,W
0A058:  MOVWF  FEA
0A05A:  MOVFF  FEC,6B3
0A05E:  MOVF   FED,F
0A060:  MOVFF  FEF,6B2
0A064:  MOVLB  0
0A066:  CALL   59AA
0A06A:  MOVFF  02,03
0A06E:  MOVF   01,W
0A070:  BNZ   A076
0A072:  MOVF   03,F
0A074:  BZ    A0FC
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A076:  MOVLB  6
0A078:  MOVF   x78,W
0A07A:  MULLW  04
0A07C:  MOVF   FF3,W
0A07E:  CLRF   x7B
0A080:  MOVWF  x7A
0A082:  MOVLW  50
0A084:  ADDWF  x7A,W
0A086:  MOVWF  FE9
0A088:  MOVLW  05
0A08A:  ADDWFC x7B,W
0A08C:  MOVWF  FEA
0A08E:  MOVFF  FEC,6B5
0A092:  MOVF   FED,F
0A094:  MOVFF  FEF,6B4
0A098:  MOVFF  676,6B3
0A09C:  MOVFF  675,6B2
0A0A0:  MOVLB  0
0A0A2:  CALL   59E2
0A0A6:  MOVF   01,F
0A0A8:  BNZ   A0F4
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A0AA:  MOVLB  6
0A0AC:  MOVF   x78,W
0A0AE:  MULLW  04
0A0B0:  MOVF   FF3,W
0A0B2:  CLRF   x7B
0A0B4:  MOVWF  x7A
0A0B6:  MOVLW  02
0A0B8:  ADDWF  x7A,W
0A0BA:  MOVWF  01
0A0BC:  MOVLW  00
0A0BE:  ADDWFC x7B,W
0A0C0:  MOVWF  03
0A0C2:  MOVF   01,W
0A0C4:  ADDLW  50
0A0C6:  MOVWF  01
0A0C8:  MOVLW  05
0A0CA:  ADDWFC 03,F
0A0CC:  MOVFF  01,67A
0A0D0:  MOVFF  03,67B
0A0D4:  MOVFF  03,FEA
0A0D8:  MOVFF  01,FE9
0A0DC:  MOVFF  672,66C
0A0E0:  MOVLB  0
0A0E2:  CALL   00BC
0A0E6:  MOVFF  01,679
....................                return return_code;
0A0EA:  MOVLB  6
0A0EC:  MOVFF  679,01
0A0F0:  BRA    A112
0A0F2:  MOVLB  0
....................             }
....................             i++;
0A0F4:  MOVLB  6
0A0F6:  INCF   x78,F
0A0F8:  BRA    A044
0A0FA:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A0FC:  MOVLW  01
0A0FE:  MOVWF  01
0A100:  MOVLB  6
0A102:  BRA    A112
....................       } else return 254; // NOT THIS ADDRESS
0A104:  BRA    A10C
0A106:  MOVLW  FE
0A108:  MOVWF  01
0A10A:  BRA    A112
....................    } else return 255; // NOT THIS DEVICE TYPE
0A10C:  BRA    A112
0A10E:  MOVLW  FF
0A110:  MOVWF  01
0A112:  MOVLB  0
0A114:  GOTO   A14E (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A140:  GOTO   5916
0A144:  MOVF   01,F
0A146:  BZ    A236
....................    {
....................       int8 return_code = command_parser(SRI);
0A148:  MOVFF  4A5,672
0A14C:  BRA    9F92
0A14E:  MOVFF  01,671
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A152:  MOVLW  04
0A154:  MOVLB  6
0A156:  MOVWF  xB3
0A158:  MOVLW  A7
0A15A:  MOVWF  xB2
0A15C:  MOVLB  0
0A15E:  CALL   59AA
0A162:  MOVF   01,W
0A164:  ADDLW  A7
0A166:  MOVLB  6
0A168:  MOVWF  x72
0A16A:  MOVLW  04
0A16C:  ADDWFC 02,W
0A16E:  MOVWF  x73
0A170:  MOVF   x71,W
0A172:  MULLW  03
0A174:  MOVF   FF3,W
0A176:  CLRF   x75
0A178:  MOVWF  x74
0A17A:  MOVLW  01
0A17C:  ADDWF  x74,W
0A17E:  MOVWF  01
0A180:  MOVLW  00
0A182:  ADDWFC x75,W
0A184:  MOVWF  03
0A186:  MOVF   01,W
0A188:  ADDLW  38
0A18A:  MOVWF  FE9
0A18C:  MOVLW  06
0A18E:  ADDWFC 03,W
0A190:  MOVWF  FEA
0A192:  MOVFF  FEC,675
0A196:  MOVF   FED,F
0A198:  MOVFF  FEF,674
0A19C:  MOVFF  673,54B
0A1A0:  MOVFF  672,54A
0A1A4:  MOVFF  54B,FEA
0A1A8:  MOVFF  54A,FE9
0A1AC:  CLRF   FEF
0A1AE:  MOVFF  675,FEA
0A1B2:  MOVFF  674,FE9
0A1B6:  MOVLB  0
0A1B8:  BRA    A118
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
0A1BA:  MOVLB  6
0A1BC:  CLRF   xB3
0A1BE:  MOVFF  4A5,6B2
0A1C2:  CLRF   xB5
0A1C4:  MOVLW  B5
0A1C6:  MOVWF  xB4
0A1C8:  MOVLB  0
0A1CA:  CALL   0876
0A1CE:  MOVFF  02,673
0A1D2:  MOVFF  01,672
0A1D6:  MOVLW  06
0A1D8:  MOVLB  6
0A1DA:  ADDWF  x72,F
0A1DC:  MOVLW  00
0A1DE:  ADDWFC x73,F
0A1E0:  MOVLW  D1
0A1E2:  ADDWF  x72,W
0A1E4:  MOVWF  01
0A1E6:  MOVLW  01
0A1E8:  ADDWFC x73,W
0A1EA:  MOVWF  03
0A1EC:  MOVFF  01,674
0A1F0:  MOVWF  x75
0A1F2:  MOVLW  24
0A1F4:  MOVWF  x87
0A1F6:  MOVLB  0
0A1F8:  CALL   4FE0
0A1FC:  MOVFF  675,FEA
0A200:  MOVFF  674,FE9
0A204:  CALL   5008
0A208:  MOVLW  2C
0A20A:  MOVLB  6
0A20C:  MOVWF  x87
0A20E:  MOVLB  0
0A210:  CALL   4FE0
0A214:  MOVLW  04
0A216:  MOVWF  FEA
0A218:  MOVLW  A7
0A21A:  MOVWF  FE9
0A21C:  CALL   5008
0A220:  MOVLW  0A
0A222:  MOVLB  6
0A224:  MOVWF  x87
0A226:  MOVLB  0
0A228:  CALL   4FE0
....................       
....................       resetSERcmd(SRI);
0A22C:  MOVFF  4A5,672
0A230:  CALL   0B58
0A234:  BRA    A140
....................    }
0A236:  GOTO   A92A (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
0A23A:  CLRF   FF8
0A23C:  BCF    FF2.5
0A23E:  BSF    07.7
0A240:  MOVLB  E
0A242:  MOVLW  55
0A244:  MOVWF  x9B
0A246:  MOVLW  AA
0A248:  MOVWF  x9B
0A24A:  BCF    x9B.0
0A24C:  MOVLW  17
0A24E:  MOVWF  xB0
0A250:  MOVLW  13
0A252:  MOVWF  xB2
0A254:  MOVLW  09
0A256:  MOVWF  x8A
0A258:  MOVLW  0A
0A25A:  MOVWF  x8B
0A25C:  MOVLW  11
0A25E:  MOVWF  xEB
0A260:  MOVLW  12
0A262:  MOVWF  xED
0A264:  MOVLW  10
0A266:  MOVWF  xF4
0A268:  MOVLW  0F
0A26A:  MOVWF  xF5
0A26C:  MOVLW  09
0A26E:  MOVWF  xF8
0A270:  MOVLW  55
0A272:  MOVWF  x9B
0A274:  MOVLW  AA
0A276:  MOVWF  x9B
0A278:  BSF    x9B.0
0A27A:  CLRF   xD8
0A27C:  CLRF   xD5
0A27E:  CLRF   xD7
0A280:  MOVLW  08
0A282:  MOVWF  xD9
0A284:  MOVLW  60
0A286:  MOVWF  xD3
0A288:  MOVLW  AA
0A28A:  MOVLB  0
0A28C:  MOVWF  xEA
0A28E:  MOVLB  1
0A290:  BSF    x49.0
0A292:  CLRF   x5B
0A294:  CLRF   x5A
0A296:  CLRF   x59
0A298:  CLRF   x58
0A29A:  CLRF   x5F
0A29C:  CLRF   x5E
0A29E:  CLRF   x5D
0A2A0:  CLRF   x5C
0A2A2:  CLRF   x63
0A2A4:  CLRF   x62
0A2A6:  CLRF   x61
0A2A8:  CLRF   x60
0A2AA:  CLRF   x65
0A2AC:  CLRF   x64
0A2AE:  MOVLB  E
0A2B0:  BCF    x91.5
0A2B2:  MOVLW  00
0A2B4:  MOVWF  x90
0A2B6:  MOVLW  03
0A2B8:  MOVWF  x8E
0A2BA:  MOVLW  2A
0A2BC:  MOVWF  x91
0A2BE:  MOVLW  C4
0A2C0:  MOVWF  F88
0A2C2:  MOVWF  F88
0A2C4:  MOVWF  F88
0A2C6:  MOVLB  1
0A2C8:  CLRF   xB6
0A2CA:  CLRF   xB7
0A2CC:  CLRF   xB8
0A2CE:  CLRF   xB9
0A2D0:  BCF    F95.5
0A2D2:  MOVLW  40
0A2D4:  MOVWF  F94
0A2D6:  MOVLW  9F
0A2D8:  MOVWF  F92
0A2DA:  MOVLW  3A
0A2DC:  MOVWF  F95
0A2DE:  MOVLW  93
0A2E0:  MOVWF  F89
0A2E2:  MOVWF  F89
0A2E4:  MOVLB  4
0A2E6:  CLRF   xA5
0A2E8:  CLRF   xA6
0A2EA:  MOVLB  5
0A2EC:  CLRF   x47
0A2EE:  CLRF   x48
0A2F0:  MOVLB  1
0A2F2:  BCF    x49.1
0A2F4:  MOVLB  5
0A2F6:  CLRF   x49
0A2F8:  BSF    F9E.3
0A2FA:  MOVLW  7C
0A2FC:  MOVWF  F9A
0A2FE:  MOVLW  00
0A300:  MOVWF  F9B
0A302:  MOVLW  A6
0A304:  MOVWF  F9D
0A306:  MOVLW  90
0A308:  MOVWF  F9C
0A30A:  MOVLW  93
0A30C:  MOVWF  F89
0A30E:  BCF    F84.5
0A310:  CLRF   x4B
0A312:  CLRF   x4A
0A314:  CLRF   x4F
0A316:  CLRF   x4E
0A318:  CLRF   x4D
0A31A:  CLRF   x4C
0A31C:  MOVLB  F
0A31E:  CLRF   x0C
0A320:  CLRF   x14
0A322:  CLRF   x1C
0A324:  CLRF   x21
0A326:  CLRF   x29
0A328:  CLRF   x35
0A32A:  CLRF   x36
0A32C:  CLRF   x37
0A32E:  CLRF   x34
0A330:  CLRF   x31
0A332:  CLRF   x32
0A334:  CLRF   x33
0A336:  CLRF   x30
0A338:  MOVLW  5A
0A33A:  MOVLB  5
0A33C:  MOVWF  x53
0A33E:  MOVLW  9A
0A340:  MOVWF  x52
0A342:  MOVLW  5A
0A344:  MOVWF  x57
0A346:  MOVLW  DE
0A348:  MOVWF  x56
0A34A:  MOVLW  60
0A34C:  MOVWF  x5B
0A34E:  MOVLW  26
0A350:  MOVWF  x5A
0A352:  MOVLW  62
0A354:  MOVWF  x5F
0A356:  MOVLW  04
0A358:  MOVWF  x5E
0A35A:  MOVLW  63
0A35C:  MOVWF  x63
0A35E:  MOVLW  DC
0A360:  MOVWF  x62
0A362:  MOVLW  65
0A364:  MOVWF  x67
0A366:  MOVLW  68
0A368:  MOVWF  x66
0A36A:  MOVLW  69
0A36C:  MOVWF  x6B
0A36E:  MOVLW  38
0A370:  MOVWF  x6A
0A372:  MOVLW  71
0A374:  MOVWF  x6F
0A376:  MOVLW  0A
0A378:  MOVWF  x6E
0A37A:  MOVLW  73
0A37C:  MOVWF  x73
0A37E:  MOVLW  EA
0A380:  MOVWF  x72
0A382:  MOVLW  75
0A384:  MOVWF  x77
0A386:  MOVLW  4C
0A388:  MOVWF  x76
0A38A:  MOVLW  77
0A38C:  MOVWF  x7B
0A38E:  MOVLW  0A
0A390:  MOVWF  x7A
0A392:  MOVLW  7A
0A394:  MOVWF  x7F
0A396:  MOVLW  C0
0A398:  MOVWF  x7E
0A39A:  MOVLW  80
0A39C:  MOVWF  x83
0A39E:  MOVLW  1C
0A3A0:  MOVWF  x82
0A3A2:  MOVLW  83
0A3A4:  MOVWF  x87
0A3A6:  MOVLW  B4
0A3A8:  MOVWF  x86
0A3AA:  MOVLW  88
0A3AC:  MOVWF  x8B
0A3AE:  MOVLW  E0
0A3B0:  MOVWF  x8A
0A3B2:  MOVLW  88
0A3B4:  MOVWF  x8F
0A3B6:  MOVLW  E6
0A3B8:  MOVWF  x8E
0A3BA:  MOVLW  8F
0A3BC:  MOVWF  x93
0A3BE:  MOVLW  5A
0A3C0:  MOVWF  x92
0A3C2:  MOVLW  94
0A3C4:  MOVWF  x97
0A3C6:  MOVLW  BE
0A3C8:  MOVWF  x96
0A3CA:  MOVLW  9B
0A3CC:  MOVWF  x9B
0A3CE:  MOVLW  E0
0A3D0:  MOVWF  x9A
0A3D2:  MOVLW  9D
0A3D4:  MOVWF  x9F
0A3D6:  MOVLW  32
0A3D8:  MOVWF  x9E
0A3DA:  MOVLW  9F
0A3DC:  MOVWF  xA3
0A3DE:  MOVLW  74
0A3E0:  MOVWF  xA2
0A3E2:  MOVLW  9F
0A3E4:  MOVWF  xA7
0A3E6:  MOVLW  80
0A3E8:  MOVWF  xA6
0A3EA:  MOVLW  9F
0A3EC:  MOVWF  xAB
0A3EE:  MOVLW  8C
0A3F0:  MOVWF  xAA
0A3F2:  BRA    A5C6
0A3F4:  DATA 02,00
0A3F6:  DATA 1A,00
0A3F8:  DATA 00,0C
0A3FA:  DATA 00,20
0A3FC:  DATA 78,23
0A3FE:  DATA D7,0A
0A400:  DATA 7D,19
0A402:  DATA 99,9A
0A404:  DATA 7B,4C
0A406:  DATA CC,CD
0A408:  DATA 14,C0
0A40A:  DATA 00,0C
0A40C:  DATA 80,78
0A40E:  DATA 23,D7
0A410:  DATA 0A,7D
0A412:  DATA 19,99
0A414:  DATA 9A,7B
0A416:  DATA 4C,CC
0A418:  DATA CD,14
0A41A:  DATA C0,00
0A41C:  DATA 01,80
0A41E:  DATA 02,09
0A420:  DATA C0,00
0A422:  DATA 05,80
0A424:  DATA 7F,00
0A426:  DATA 00,00
0A428:  DATA 7F,0B
0A42A:  DATA C0,00
0A42C:  DATA 05,80
0A42E:  DATA 7F,00
0A430:  DATA 00,00
0A432:  DATA 7F,07
0A434:  DATA C0,00
0A436:  DATA 01,80
0A438:  DATA 7F,17
0A43A:  DATA C0,00
0A43C:  DATA 01,80
0A43E:  DATA 7F,17
0A440:  DATA C0,00
0A442:  DATA 04,80
0A444:  DATA 79,B7
0A446:  DATA F3,BD
0A448:  DATA 04,C0
0A44A:  DATA 00,04
0A44C:  DATA 80,7C
0A44E:  DATA 59,DF
0A450:  DATA 4E,04
0A452:  DATA C0,00
0A454:  DATA 04,80
0A456:  DATA 78,0A
0A458:  DATA 28,88
0A45A:  DATA 04,C0
0A45C:  DATA 00,04
0A45E:  DATA 80,78
0A460:  DATA 05,EA
0A462:  DATA 16,04
0A464:  DATA C0,00
0A466:  DATA 04,80
0A468:  DATA 78,1E
0A46A:  DATA 33,D7
0A46C:  DATA 04,C0
0A46E:  DATA 00,04
0A470:  DATA 80,77
0A472:  DATA 68,7B
0A474:  DATA BB,04
0A476:  DATA C0,00
0A478:  DATA 04,80
0A47A:  DATA 77,68
0A47C:  DATA 0D,C6
0A47E:  DATA 5E,40
0A480:  DATA EB,00
0A482:  DATA 0E,41
0A484:  DATA 4A,00
0A486:  DATA 17,41
0A488:  DATA BA,00
0A48A:  DATA 3C,45
0A48C:  DATA 0B,00
0A48E:  DATA 02,05
0A490:  DATA 50,AC
0A492:  DATA 05,02
0A494:  DATA 05,54
0A496:  DATA AF,05
0A498:  DATA 02,05
0A49A:  DATA 58,B2
0A49C:  DATA 05,02
0A49E:  DATA 05,5C
0A4A0:  DATA B9,05
0A4A2:  DATA 02,05
0A4A4:  DATA 60,C0
0A4A6:  DATA 05,02
0A4A8:  DATA 05,64
0A4AA:  DATA C8,05
0A4AC:  DATA 02,05
0A4AE:  DATA 68,D0
0A4B0:  DATA 05,02
0A4B2:  DATA 05,6C
0A4B4:  DATA D5,05
0A4B6:  DATA 02,05
0A4B8:  DATA 70,DA
0A4BA:  DATA 05,02
0A4BC:  DATA 05,74
0A4BE:  DATA DE,05
0A4C0:  DATA 02,05
0A4C2:  DATA 78,E2
0A4C4:  DATA 05,02
0A4C6:  DATA 05,7C
0A4C8:  DATA E9,05
0A4CA:  DATA 02,05
0A4CC:  DATA 80,EF
0A4CE:  DATA 05,02
0A4D0:  DATA 05,84
0A4D2:  DATA F5,05
0A4D4:  DATA 02,05
0A4D6:  DATA 88,FB
0A4D8:  DATA 05,02
0A4DA:  DATA 05,8C
0A4DC:  DATA 01,06
0A4DE:  DATA 02,05
0A4E0:  DATA 90,06
0A4E2:  DATA 06,02
0A4E4:  DATA 05,94
0A4E6:  DATA 0F,06
0A4E8:  DATA 02,05
0A4EA:  DATA 98,17
0A4EC:  DATA 06,02
0A4EE:  DATA 05,9C
0A4F0:  DATA 1E,06
0A4F2:  DATA 02,05
0A4F4:  DATA A0,25
0A4F6:  DATA 06,02
0A4F8:  DATA 05,A4
0A4FA:  DATA 2D,06
0A4FC:  DATA 02,05
0A4FE:  DATA A8,36
0A500:  DATA 06,89
0A502:  DATA 05,AC
0A504:  DATA 67,72
0A506:  DATA 00,67
0A508:  DATA 73,00
0A50A:  DATA 67,43
0A50C:  DATA 68,4D
0A50E:  DATA 61,70
0A510:  DATA 00,73
0A512:  DATA 43,68
0A514:  DATA 4D,61
0A516:  DATA 70,00
0A518:  DATA 67,43
0A51A:  DATA 68,4D
0A51C:  DATA 6F,64
0A51E:  DATA 65,00
0A520:  DATA 73,43
0A522:  DATA 68,4D
0A524:  DATA 6F,64
0A526:  DATA 65,00
0A528:  DATA 67,50
0A52A:  DATA 49,44
0A52C:  DATA 00,73
0A52E:  DATA 50,49
0A530:  DATA 44,00
0A532:  DATA 67,53
0A534:  DATA 50,00
0A536:  DATA 73,53
0A538:  DATA 50,00
0A53A:  DATA 67,53
0A53C:  DATA 43,61
0A53E:  DATA 6C,73
0A540:  DATA 00,67
0A542:  DATA 53,43
0A544:  DATA 61,6C
0A546:  DATA 00,73
0A548:  DATA 53,43
0A54A:  DATA 61,6C
0A54C:  DATA 00,67
0A54E:  DATA 4D,43
0A550:  DATA 61,6C
0A552:  DATA 00,73
0A554:  DATA 4D,43
0A556:  DATA 61,6C
0A558:  DATA 00,67
0A55A:  DATA 4D,6F
0A55C:  DATA 6E,00
0A55E:  DATA 67,50
0A560:  DATA 49,44
0A562:  DATA 64,61
0A564:  DATA 74,61
0A566:  DATA 00,67
0A568:  DATA 49,50
0A56A:  DATA 64,61
0A56C:  DATA 74,61
0A56E:  DATA 00,67
0A570:  DATA 4D,61
0A572:  DATA 6E,4F
0A574:  DATA 50,00
0A576:  DATA 73,4D
0A578:  DATA 61,6E
0A57A:  DATA 4F,50
0A57C:  DATA 00,73
0A57E:  DATA 46,69
0A580:  DATA 6C,74
0A582:  DATA 4F,6E
0A584:  DATA 00,73
0A586:  DATA 46,69
0A588:  DATA 6C,74
0A58A:  DATA 4F,66
0A58C:  DATA 66,04
0A58E:  DATA C0,00
0A590:  DATA 33,80
0A592:  DATA 41,06
0A594:  DATA 01,49
0A596:  DATA 06,02
0A598:  DATA 59,06
0A59A:  DATA 53,55
0A59C:  DATA 43,43
0A59E:  DATA 45,53
0A5A0:  DATA 53,00
0A5A2:  DATA 49,4E
0A5A4:  DATA 56,41
0A5A6:  DATA 4C,49
0A5A8:  DATA 44,20
0A5AA:  DATA 43,4F
0A5AC:  DATA 4D,4D
0A5AE:  DATA 41,4E
0A5B0:  DATA 44,00
0A5B2:  DATA 49,4E
0A5B4:  DATA 56,41
0A5B6:  DATA 4C,49
0A5B8:  DATA 44,20
0A5BA:  DATA 50,41
0A5BC:  DATA 52,41
0A5BE:  DATA 4D,45
0A5C0:  DATA 54,45
0A5C2:  DATA 52,00
0A5C4:  DATA 00,00
0A5C6:  MOVLW  00
0A5C8:  MOVWF  FF8
0A5CA:  MOVLW  A3
0A5CC:  MOVWF  FF7
0A5CE:  MOVLW  F4
0A5D0:  MOVWF  FF6
0A5D2:  TBLRD*+
0A5D4:  MOVF   FF5,W
0A5D6:  MOVWF  00
0A5D8:  XORLW  00
0A5DA:  BZ    A602
0A5DC:  TBLRD*+
0A5DE:  MOVF   FF5,W
0A5E0:  MOVWF  01
0A5E2:  BTFSC  FE8.7
0A5E4:  BRA    A5F0
0A5E6:  ANDLW  3F
0A5E8:  MOVWF  FEA
0A5EA:  TBLRD*+
0A5EC:  MOVFF  FF5,FE9
0A5F0:  BTFSC  01.6
0A5F2:  TBLRD*+
0A5F4:  BTFSS  01.6
0A5F6:  TBLRD*+
0A5F8:  MOVFF  FF5,FEE
0A5FC:  DCFSNZ 00,F
0A5FE:  BRA    A5D2
0A600:  BRA    A5F4
0A602:  CLRF   FF8
0A604:  MOVLB  6
0A606:  CLRF   x6E
0A608:  MOVLW  64
0A60A:  MOVWF  x6D
0A60C:  CLRF   x70
0A60E:  CLRF   x6F
.................... {
....................    int16 loopDelay = 100;
....................    int16 loopCounter = 0;
....................    
....................    IO_init();                    // set up IO 
0A610:  MOVLB  0
0A612:  GOTO   03A4
....................    params_init();                // load parameters
0A616:  GOTO   064C
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0A61A:  GOTO   0A9C
....................    control_init();               // initialize the output control DACs
0A61E:  GOTO   0B34
....................    serial_init();                // setup the serial port
0A622:  GOTO   0CD2
....................    event_timer_init();
0A626:  GOTO   0CF4
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0A62A:  MOVLW  C0
0A62C:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A62E:  GOTO   10CC
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A632:  GOTO   441C
....................       control_task();            //output control
0A636:  GOTO   4F60
....................       serial_task();             //serial port 
0A63A:  GOTO   502C
....................       
....................       #ifdef DEBUG_1
....................       if (loopCounter*loopDelay >= 500){
0A63E:  MOVFF  670,6B3
0A642:  MOVFF  66F,6B2
0A646:  MOVFF  66E,6B5
0A64A:  MOVFF  66D,6B4
0A64E:  CALL   0876
0A652:  MOVFF  02,672
0A656:  MOVFF  01,671
0A65A:  MOVLB  6
0A65C:  MOVF   02,W
0A65E:  SUBLW  00
0A660:  BTFSC  FD8.0
0A662:  BRA    A920
0A664:  XORLW  FF
0A666:  BNZ   A670
0A668:  MOVF   x71,W
0A66A:  SUBLW  F3
0A66C:  BTFSC  FD8.0
0A66E:  BRA    A920
....................          static int8 ch = 0;
....................          fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A670:  MOVLW  01
0A672:  ADDWF  x6B,W
0A674:  MOVWF  x71
0A676:  MOVF   x6B,W
0A678:  MULLW  21
0A67A:  MOVF   FF3,W
0A67C:  CLRF   x73
0A67E:  MOVWF  x72
0A680:  MOVLW  08
0A682:  ADDWF  x72,W
0A684:  MOVWF  01
0A686:  MOVLW  00
0A688:  ADDWFC x73,W
0A68A:  MOVWF  03
0A68C:  MOVF   01,W
0A68E:  ADDLW  07
0A690:  MOVWF  FE9
0A692:  MOVLW  01
0A694:  ADDWFC 03,W
0A696:  MOVWF  FEA
0A698:  MOVFF  FEF,672
0A69C:  MOVFF  FEC,673
0A6A0:  MOVFF  FEC,674
0A6A4:  MOVFF  FEC,675
0A6A8:  MOVF   x6B,W
0A6AA:  MULLW  21
0A6AC:  MOVF   FF3,W
0A6AE:  CLRF   x77
0A6B0:  MOVWF  x76
0A6B2:  MOVLW  0C
0A6B4:  ADDWF  x76,W
0A6B6:  MOVWF  01
0A6B8:  MOVLW  00
0A6BA:  ADDWFC x77,W
0A6BC:  MOVWF  03
0A6BE:  MOVF   01,W
0A6C0:  ADDLW  07
0A6C2:  MOVWF  FE9
0A6C4:  MOVLW  01
0A6C6:  ADDWFC 03,W
0A6C8:  MOVWF  FEA
0A6CA:  MOVFF  FEF,676
0A6CE:  MOVFF  FEC,677
0A6D2:  MOVFF  FEC,678
0A6D6:  MOVFF  FEC,679
0A6DA:  MOVLW  58
0A6DC:  MOVWF  FF6
0A6DE:  MOVLW  03
0A6E0:  MOVWF  FF7
0A6E2:  MOVLW  08
0A6E4:  MOVWF  x7A
0A6E6:  MOVLB  0
0A6E8:  CALL   5524
0A6EC:  MOVFF  671,67A
0A6F0:  MOVLW  1B
0A6F2:  MOVLB  6
0A6F4:  MOVWF  x7B
0A6F6:  MOVLB  0
0A6F8:  CALL   554C
0A6FC:  MOVLW  2C
0A6FE:  MOVLB  6
0A700:  MOVWF  x87
0A702:  MOVLB  0
0A704:  CALL   4FE0
0A708:  MOVLW  89
0A70A:  MOVWF  FE9
0A70C:  MOVFF  675,67D
0A710:  MOVFF  674,67C
0A714:  MOVFF  673,67B
0A718:  MOVFF  672,67A
0A71C:  MOVLB  6
0A71E:  CLRF   x7E
0A720:  MOVLB  0
0A722:  CALL   56A2
0A726:  MOVLW  2C
0A728:  MOVLB  6
0A72A:  MOVWF  x87
0A72C:  MOVLB  0
0A72E:  CALL   4FE0
0A732:  MOVLW  89
0A734:  MOVWF  FE9
0A736:  MOVFF  679,67D
0A73A:  MOVFF  678,67C
0A73E:  MOVFF  677,67B
0A742:  MOVFF  676,67A
0A746:  MOVLB  6
0A748:  CLRF   x7E
0A74A:  MOVLB  0
0A74C:  CALL   56A2
0A750:  MOVLW  0A
0A752:  MOVLB  6
0A754:  MOVWF  x87
0A756:  MOVLB  0
0A758:  CALL   4FE0
....................          fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0A75C:  MOVLW  01
0A75E:  MOVLB  6
0A760:  ADDWF  x6B,W
0A762:  MOVWF  x71
0A764:  MOVF   x6B,W
0A766:  MULLW  21
0A768:  MOVF   FF3,W
0A76A:  CLRF   x73
0A76C:  MOVWF  x72
0A76E:  MOVLW  1D
0A770:  ADDWF  x72,W
0A772:  MOVWF  01
0A774:  MOVLW  00
0A776:  ADDWFC x73,W
0A778:  MOVWF  03
0A77A:  MOVF   01,W
0A77C:  ADDLW  07
0A77E:  MOVWF  FE9
0A780:  MOVLW  01
0A782:  ADDWFC 03,W
0A784:  MOVWF  FEA
0A786:  MOVFF  FEF,672
0A78A:  MOVFF  FEC,673
0A78E:  MOVFF  FEC,674
0A792:  MOVFF  FEC,675
0A796:  MOVLW  6E
0A798:  MOVWF  FF6
0A79A:  MOVLW  03
0A79C:  MOVWF  FF7
0A79E:  MOVLW  08
0A7A0:  MOVWF  x7A
0A7A2:  MOVLB  0
0A7A4:  CALL   5524
0A7A8:  MOVFF  671,67A
0A7AC:  MOVLW  1B
0A7AE:  MOVLB  6
0A7B0:  MOVWF  x7B
0A7B2:  MOVLB  0
0A7B4:  CALL   554C
0A7B8:  MOVLW  2C
0A7BA:  MOVLB  6
0A7BC:  MOVWF  x87
0A7BE:  MOVLB  0
0A7C0:  CALL   4FE0
0A7C4:  MOVLW  89
0A7C6:  MOVWF  FE9
0A7C8:  MOVFF  675,67D
0A7CC:  MOVFF  674,67C
0A7D0:  MOVFF  673,67B
0A7D4:  MOVFF  672,67A
0A7D8:  MOVLW  03
0A7DA:  MOVLB  6
0A7DC:  MOVWF  x7E
0A7DE:  MOVLB  0
0A7E0:  CALL   56A2
0A7E4:  MOVLW  0A
0A7E6:  MOVLB  6
0A7E8:  MOVWF  x87
0A7EA:  MOVLB  0
0A7EC:  CALL   4FE0
....................          if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0A7F0:  MOVLB  6
0A7F2:  MOVF   x6B,W
0A7F4:  MULLW  03
0A7F6:  MOVF   FF3,W
0A7F8:  CLRF   x72
0A7FA:  MOVWF  x71
0A7FC:  MOVLW  02
0A7FE:  ADDWF  x71,W
0A800:  MOVWF  01
0A802:  MOVLW  00
0A804:  ADDWFC x72,W
0A806:  MOVWF  03
0A808:  MOVF   01,W
0A80A:  ADDLW  4A
0A80C:  MOVWF  FE9
0A80E:  MOVLW  01
0A810:  ADDWFC 03,W
0A812:  MOVWF  FEA
0A814:  BTFSS  FEF.0
0A816:  BRA    A894
0A818:  MOVLW  01
0A81A:  ADDWF  x6B,W
0A81C:  MOVWF  x71
0A81E:  MOVF   x6B,W
0A820:  MULLW  03
0A822:  MOVF   FF3,W
0A824:  CLRF   x73
0A826:  MOVWF  x72
0A828:  MOVLW  4A
0A82A:  ADDWF  x72,W
0A82C:  MOVWF  FE9
0A82E:  MOVLW  01
0A830:  ADDWFC x73,W
0A832:  MOVWF  FEA
0A834:  MOVFF  FEC,675
0A838:  MOVF   FED,F
0A83A:  MOVFF  FEF,674
0A83E:  MOVLW  80
0A840:  MOVWF  FF6
0A842:  MOVLW  03
0A844:  MOVWF  FF7
0A846:  MOVLW  08
0A848:  MOVWF  x7A
0A84A:  MOVLB  0
0A84C:  CALL   5524
0A850:  MOVFF  671,67A
0A854:  MOVLW  1B
0A856:  MOVLB  6
0A858:  MOVWF  x7B
0A85A:  MOVLB  0
0A85C:  CALL   554C
0A860:  MOVLW  8A
0A862:  MOVWF  FF6
0A864:  MOVLW  03
0A866:  MOVWF  FF7
0A868:  MOVLW  03
0A86A:  MOVLB  6
0A86C:  MOVWF  x7A
0A86E:  MOVLB  0
0A870:  CALL   5524
0A874:  MOVLW  10
0A876:  MOVWF  FE9
0A878:  MOVFF  675,677
0A87C:  MOVFF  674,676
0A880:  CALL   584E
0A884:  MOVLW  0A
0A886:  MOVLB  6
0A888:  MOVWF  x87
0A88A:  MOVLB  0
0A88C:  CALL   4FE0
0A890:  BRA    A90C
0A892:  MOVLB  6
....................          else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0A894:  MOVLW  01
0A896:  ADDWF  x6B,W
0A898:  MOVWF  x71
0A89A:  MOVF   x6B,W
0A89C:  MULLW  03
0A89E:  MOVF   FF3,W
0A8A0:  CLRF   x73
0A8A2:  MOVWF  x72
0A8A4:  MOVLW  4A
0A8A6:  ADDWF  x72,W
0A8A8:  MOVWF  FE9
0A8AA:  MOVLW  01
0A8AC:  ADDWFC x73,W
0A8AE:  MOVWF  FEA
0A8B0:  MOVFF  FEC,675
0A8B4:  MOVF   FED,F
0A8B6:  MOVFF  FEF,674
0A8BA:  MOVLW  92
0A8BC:  MOVWF  FF6
0A8BE:  MOVLW  03
0A8C0:  MOVWF  FF7
0A8C2:  MOVLW  08
0A8C4:  MOVWF  x7A
0A8C6:  MOVLB  0
0A8C8:  CALL   5524
0A8CC:  MOVFF  671,67A
0A8D0:  MOVLW  1B
0A8D2:  MOVLB  6
0A8D4:  MOVWF  x7B
0A8D6:  MOVLB  0
0A8D8:  CALL   554C
0A8DC:  MOVLW  9C
0A8DE:  MOVWF  FF6
0A8E0:  MOVLW  03
0A8E2:  MOVWF  FF7
0A8E4:  MOVLW  03
0A8E6:  MOVLB  6
0A8E8:  MOVWF  x7A
0A8EA:  MOVLB  0
0A8EC:  CALL   5524
0A8F0:  MOVLW  10
0A8F2:  MOVWF  FE9
0A8F4:  MOVFF  675,677
0A8F8:  MOVFF  674,676
0A8FC:  CALL   584E
0A900:  MOVLW  0A
0A902:  MOVLB  6
0A904:  MOVWF  x87
0A906:  MOVLB  0
0A908:  CALL   4FE0
....................          ch = !ch;
0A90C:  MOVLB  6
0A90E:  MOVF   x6B,F
0A910:  BZ    A916
0A912:  MOVLW  00
0A914:  BRA    A918
0A916:  MOVLW  01
0A918:  MOVWF  x6B
....................          loopCounter = 0;
0A91A:  CLRF   x70
0A91C:  CLRF   x6F
....................       } else loopCounter++;
0A91E:  BRA    A926
0A920:  INCF   x6F,F
0A922:  BTFSC  FD8.2
0A924:  INCF   x70,F
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0A926:  MOVLB  0
0A928:  BRA    A140
....................       
....................       delay_ms(loopDelay);
0A92A:  MOVFF  66E,671
0A92E:  MOVLB  6
0A930:  INCF   x71,F
0A932:  DECF   x71,F
0A934:  BTFSC  FD8.2
0A936:  BRA    A944
0A938:  SETF   x77
0A93A:  MOVLB  0
0A93C:  CALL   043A
0A940:  MOVLB  6
0A942:  BRA    A932
0A944:  MOVFF  66D,677
0A948:  MOVLB  0
0A94A:  CALL   043A
0A94E:  BRA    A62E
....................    }
.................... }
0A950:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
