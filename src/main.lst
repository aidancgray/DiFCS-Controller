CCS PCH C Compiler, Version 5.109, 62303               10-Dec-25 10:11

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43814 bytes (67%)
                           Largest free fragment is 21720
               RAM used:   1786 (49%) at main() level
                           1896 (52%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A35E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,32
00336:  DATA 30,38
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
00358:  DATA 23,44
0035A:  DATA 30,2C
0035C:  DATA 43,4E
0035E:  DATA 54,2C
00360:  DATA 25,75
00362:  DATA 2C,25
00364:  DATA 2E,30
00366:  DATA 66,2C
00368:  DATA 25,2E
0036A:  DATA 30,66
0036C:  DATA 0A,00
0036E:  DATA 23,44
00370:  DATA 30,2C
00372:  DATA 50,4F
00374:  DATA 53,2C
00376:  DATA 25,75
00378:  DATA 2C,25
0037A:  DATA 33,2E
0037C:  DATA 33,66
0037E:  DATA 0A,00
00380:  DATA 23,44
00382:  DATA 30,2C
00384:  DATA 4F,55
00386:  DATA 54,2C
00388:  DATA 25,75
0038A:  DATA 2C,2D
0038C:  DATA 2C,25
0038E:  DATA 4C,75
00390:  DATA 0A,00
00392:  DATA 23,44
00394:  DATA 30,2C
00396:  DATA 4F,55
00398:  DATA 54,2C
0039A:  DATA 25,75
0039C:  DATA 2C,2B
0039E:  DATA 2C,25
003A0:  DATA 4C,75
003A2:  DATA 0A,00
*
006CA:  ADDWF  FE8,W
006CC:  CLRF   FF7
006CE:  RLCF   FF7,F
006D0:  ADDLW  E5
006D2:  MOVWF  FF6
006D4:  MOVLW  06
006D6:  ADDWFC FF7,F
006D8:  TBLRD*-
006DA:  MOVF   FF5,W
006DC:  MOVWF  FFA
006DE:  TBLRD*
006E0:  MOVF   FF5,W
006E2:  MOVWF  FF9
006E4:  DATA 94,06
006E6:  DATA 9E,06
006E8:  DATA A8,06
006EA:  DATA B2,06
*
00874:  MOVLB  7
00876:  MOVF   x30,W
00878:  MULWF  x32
0087A:  MOVFF  FF3,01
0087E:  MOVFF  FF4,00
00882:  MULWF  x33
00884:  MOVF   FF3,W
00886:  ADDWF  00,F
00888:  MOVF   x31,W
0088A:  MULWF  x32
0088C:  MOVF   FF3,W
0088E:  ADDWFC 00,W
00890:  MOVWF  02
00892:  MOVLB  0
00894:  RETURN 0
00896:  MOVLB  7
00898:  MOVF   x30,W
0089A:  CLRF   01
0089C:  SUBWF  x2F,W
0089E:  BC    08A6
008A0:  MOVFF  72F,00
008A4:  BRA    08BE
008A6:  CLRF   00
008A8:  MOVLW  08
008AA:  MOVWF  x31
008AC:  RLCF   x2F,F
008AE:  RLCF   00,F
008B0:  MOVF   x30,W
008B2:  SUBWF  00,W
008B4:  BTFSC  FD8.0
008B6:  MOVWF  00
008B8:  RLCF   01,F
008BA:  DECFSZ x31,F
008BC:  BRA    08AC
008BE:  MOVLB  0
008C0:  RETURN 0
*
00D36:  MOVLW  8E
00D38:  MOVWF  00
00D3A:  MOVFF  748,01
00D3E:  MOVFF  747,02
00D42:  CLRF   03
00D44:  MOVF   01,F
00D46:  BNZ   0D5A
00D48:  MOVFF  02,01
00D4C:  CLRF   02
00D4E:  MOVLW  08
00D50:  SUBWF  00,F
00D52:  MOVF   01,F
00D54:  BNZ   0D5A
00D56:  CLRF   00
00D58:  BRA    0D6A
00D5A:  BCF    FD8.0
00D5C:  BTFSC  01.7
00D5E:  BRA    0D68
00D60:  RLCF   02,F
00D62:  RLCF   01,F
00D64:  DECF   00,F
00D66:  BRA    0D5A
00D68:  BCF    01.7
00D6A:  RETURN 0
00D6C:  MOVLB  7
00D6E:  MOVF   x43,W
00D70:  BTFSC  FD8.2
00D72:  BRA    0E56
00D74:  MOVWF  00
00D76:  MOVF   x47,W
00D78:  BTFSC  FD8.2
00D7A:  BRA    0E56
00D7C:  ADDWF  00,F
00D7E:  BNC   0D88
00D80:  MOVLW  81
00D82:  ADDWF  00,F
00D84:  BC    0E56
00D86:  BRA    0D90
00D88:  MOVLW  7F
00D8A:  SUBWF  00,F
00D8C:  BNC   0E56
00D8E:  BZ    0E56
00D90:  MOVFF  744,74B
00D94:  MOVF   x48,W
00D96:  XORWF  x4B,F
00D98:  BSF    x44.7
00D9A:  BSF    x48.7
00D9C:  MOVF   x46,W
00D9E:  MULWF  x4A
00DA0:  MOVFF  FF4,74D
00DA4:  MOVF   x45,W
00DA6:  MULWF  x49
00DA8:  MOVFF  FF4,03
00DAC:  MOVFF  FF3,74C
00DB0:  MULWF  x4A
00DB2:  MOVF   FF3,W
00DB4:  ADDWF  x4D,F
00DB6:  MOVF   FF4,W
00DB8:  ADDWFC x4C,F
00DBA:  MOVLW  00
00DBC:  ADDWFC 03,F
00DBE:  MOVF   x46,W
00DC0:  MULWF  x49
00DC2:  MOVF   FF3,W
00DC4:  ADDWF  x4D,F
00DC6:  MOVF   FF4,W
00DC8:  ADDWFC x4C,F
00DCA:  MOVLW  00
00DCC:  CLRF   02
00DCE:  ADDWFC 03,F
00DD0:  ADDWFC 02,F
00DD2:  MOVF   x44,W
00DD4:  MULWF  x4A
00DD6:  MOVF   FF3,W
00DD8:  ADDWF  x4C,F
00DDA:  MOVF   FF4,W
00DDC:  ADDWFC 03,F
00DDE:  MOVLW  00
00DE0:  ADDWFC 02,F
00DE2:  MOVF   x44,W
00DE4:  MULWF  x49
00DE6:  MOVF   FF3,W
00DE8:  ADDWF  03,F
00DEA:  MOVF   FF4,W
00DEC:  ADDWFC 02,F
00DEE:  MOVLW  00
00DF0:  CLRF   01
00DF2:  ADDWFC 01,F
00DF4:  MOVF   x46,W
00DF6:  MULWF  x48
00DF8:  MOVF   FF3,W
00DFA:  ADDWF  x4C,F
00DFC:  MOVF   FF4,W
00DFE:  ADDWFC 03,F
00E00:  MOVLW  00
00E02:  ADDWFC 02,F
00E04:  ADDWFC 01,F
00E06:  MOVF   x45,W
00E08:  MULWF  x48
00E0A:  MOVF   FF3,W
00E0C:  ADDWF  03,F
00E0E:  MOVF   FF4,W
00E10:  ADDWFC 02,F
00E12:  MOVLW  00
00E14:  ADDWFC 01,F
00E16:  MOVF   x44,W
00E18:  MULWF  x48
00E1A:  MOVF   FF3,W
00E1C:  ADDWF  02,F
00E1E:  MOVF   FF4,W
00E20:  ADDWFC 01,F
00E22:  INCF   00,F
00E24:  BTFSC  01.7
00E26:  BRA    0E32
00E28:  RLCF   x4C,F
00E2A:  RLCF   03,F
00E2C:  RLCF   02,F
00E2E:  RLCF   01,F
00E30:  DECF   00,F
00E32:  MOVLW  00
00E34:  BTFSS  x4C.7
00E36:  BRA    0E4C
00E38:  INCF   03,F
00E3A:  ADDWFC 02,F
00E3C:  ADDWFC 01,F
00E3E:  MOVF   01,W
00E40:  BNZ   0E4C
00E42:  MOVF   02,W
00E44:  BNZ   0E4C
00E46:  MOVF   03,W
00E48:  BNZ   0E4C
00E4A:  INCF   00,F
00E4C:  BTFSC  x4B.7
00E4E:  BSF    01.7
00E50:  BTFSS  x4B.7
00E52:  BCF    01.7
00E54:  BRA    0E5E
00E56:  CLRF   00
00E58:  CLRF   01
00E5A:  CLRF   02
00E5C:  CLRF   03
00E5E:  MOVLB  0
00E60:  RETURN 0
00E62:  MOVLW  80
00E64:  BTFSS  FD8.1
00E66:  BRA    0E6C
00E68:  MOVLB  7
00E6A:  XORWF  x4C,F
00E6C:  MOVLB  7
00E6E:  CLRF   x51
00E70:  CLRF   x52
00E72:  MOVFF  748,750
00E76:  MOVF   x4C,W
00E78:  XORWF  x50,F
00E7A:  MOVF   x47,W
00E7C:  BTFSC  FD8.2
00E7E:  BRA    103E
00E80:  MOVWF  x4F
00E82:  MOVWF  00
00E84:  MOVF   x4B,W
00E86:  BTFSC  FD8.2
00E88:  BRA    1050
00E8A:  SUBWF  x4F,F
00E8C:  BTFSC  FD8.2
00E8E:  BRA    0F96
00E90:  BNC   0F0E
00E92:  MOVFF  74C,755
00E96:  BSF    x55.7
00E98:  MOVFF  74D,754
00E9C:  MOVFF  74E,753
00EA0:  CLRF   x52
00EA2:  BCF    FD8.0
00EA4:  RRCF   x55,F
00EA6:  RRCF   x54,F
00EA8:  RRCF   x53,F
00EAA:  RRCF   x52,F
00EAC:  DECFSZ x4F,F
00EAE:  BRA    0EA0
00EB0:  BTFSS  x50.7
00EB2:  BRA    0EBA
00EB4:  BSF    x51.0
00EB6:  BRA    1078
00EB8:  BCF    x51.0
00EBA:  BCF    x4F.0
00EBC:  BSF    x51.4
00EBE:  MOVLW  07
00EC0:  MOVWF  FEA
00EC2:  MOVLW  4A
00EC4:  MOVWF  FE9
00EC6:  BRA    109E
00EC8:  BCF    x51.4
00ECA:  BTFSC  x50.7
00ECC:  BRA    0EE2
00ECE:  BTFSS  x4F.0
00ED0:  BRA    0EF8
00ED2:  RRCF   x55,F
00ED4:  RRCF   x54,F
00ED6:  RRCF   x53,F
00ED8:  RRCF   x52,F
00EDA:  INCF   00,F
00EDC:  BTFSC  FD8.2
00EDE:  BRA    106E
00EE0:  BRA    0EF8
00EE2:  BTFSC  x55.7
00EE4:  BRA    0EFE
00EE6:  BCF    FD8.0
00EE8:  RLCF   x52,F
00EEA:  RLCF   x53,F
00EEC:  RLCF   x54,F
00EEE:  RLCF   x55,F
00EF0:  DECF   00,F
00EF2:  BTFSC  FD8.2
00EF4:  BRA    106E
00EF6:  BRA    0EE2
00EF8:  BSF    x51.6
00EFA:  BRA    0FD6
00EFC:  BCF    x51.6
00EFE:  MOVFF  748,750
00F02:  BTFSS  x48.7
00F04:  BRA    0F0A
00F06:  BSF    x55.7
00F08:  BRA    1060
00F0A:  BCF    x55.7
00F0C:  BRA    1060
00F0E:  MOVFF  74B,74F
00F12:  MOVFF  74B,00
00F16:  MOVF   x47,W
00F18:  SUBWF  x4F,F
00F1A:  MOVFF  748,755
00F1E:  BSF    x55.7
00F20:  MOVFF  749,754
00F24:  MOVFF  74A,753
00F28:  CLRF   x52
00F2A:  BCF    FD8.0
00F2C:  RRCF   x55,F
00F2E:  RRCF   x54,F
00F30:  RRCF   x53,F
00F32:  RRCF   x52,F
00F34:  DECFSZ x4F,F
00F36:  BRA    0F28
00F38:  BTFSS  x50.7
00F3A:  BRA    0F42
00F3C:  BSF    x51.1
00F3E:  BRA    1078
00F40:  BCF    x51.1
00F42:  BCF    x4F.0
00F44:  BSF    x51.5
00F46:  MOVLW  07
00F48:  MOVWF  FEA
00F4A:  MOVLW  4E
00F4C:  MOVWF  FE9
00F4E:  BRA    109E
00F50:  BCF    x51.5
00F52:  BTFSC  x50.7
00F54:  BRA    0F6A
00F56:  BTFSS  x4F.0
00F58:  BRA    0F80
00F5A:  RRCF   x55,F
00F5C:  RRCF   x54,F
00F5E:  RRCF   x53,F
00F60:  RRCF   x52,F
00F62:  INCF   00,F
00F64:  BTFSC  FD8.2
00F66:  BRA    106E
00F68:  BRA    0F80
00F6A:  BTFSC  x55.7
00F6C:  BRA    0F86
00F6E:  BCF    FD8.0
00F70:  RLCF   x52,F
00F72:  RLCF   x53,F
00F74:  RLCF   x54,F
00F76:  RLCF   x55,F
00F78:  DECF   00,F
00F7A:  BTFSC  FD8.2
00F7C:  BRA    106E
00F7E:  BRA    0F6A
00F80:  BSF    x51.7
00F82:  BRA    0FD6
00F84:  BCF    x51.7
00F86:  MOVFF  74C,750
00F8A:  BTFSS  x4C.7
00F8C:  BRA    0F92
00F8E:  BSF    x55.7
00F90:  BRA    1060
00F92:  BCF    x55.7
00F94:  BRA    1060
00F96:  MOVFF  74C,755
00F9A:  BSF    x55.7
00F9C:  MOVFF  74D,754
00FA0:  MOVFF  74E,753
00FA4:  BTFSS  x50.7
00FA6:  BRA    0FB0
00FA8:  BCF    x55.7
00FAA:  BSF    x51.2
00FAC:  BRA    1078
00FAE:  BCF    x51.2
00FB0:  CLRF   x52
00FB2:  BCF    x4F.0
00FB4:  MOVLW  07
00FB6:  MOVWF  FEA
00FB8:  MOVLW  4A
00FBA:  MOVWF  FE9
00FBC:  BRA    109E
00FBE:  BTFSC  x50.7
00FC0:  BRA    0FFA
00FC2:  MOVFF  748,750
00FC6:  BTFSS  x4F.0
00FC8:  BRA    0FD6
00FCA:  RRCF   x55,F
00FCC:  RRCF   x54,F
00FCE:  RRCF   x53,F
00FD0:  RRCF   x52,F
00FD2:  INCF   00,F
00FD4:  BZ    106E
00FD6:  BTFSS  x52.7
00FD8:  BRA    0FF0
00FDA:  INCF   x53,F
00FDC:  BNZ   0FF0
00FDE:  INCF   x54,F
00FE0:  BNZ   0FF0
00FE2:  INCF   x55,F
00FE4:  BNZ   0FF0
00FE6:  RRCF   x55,F
00FE8:  RRCF   x54,F
00FEA:  RRCF   x53,F
00FEC:  INCF   00,F
00FEE:  BZ    106E
00FF0:  BTFSC  x51.6
00FF2:  BRA    0EFC
00FF4:  BTFSC  x51.7
00FF6:  BRA    0F84
00FF8:  BRA    1032
00FFA:  MOVLW  80
00FFC:  XORWF  x55,F
00FFE:  BTFSS  x55.7
01000:  BRA    100A
01002:  BRA    1078
01004:  MOVFF  74C,750
01008:  BRA    101E
0100A:  MOVFF  748,750
0100E:  MOVF   x55,F
01010:  BNZ   101E
01012:  MOVF   x54,F
01014:  BNZ   101E
01016:  MOVF   x53,F
01018:  BNZ   101E
0101A:  CLRF   00
0101C:  BRA    1060
0101E:  BTFSC  x55.7
01020:  BRA    1032
01022:  BCF    FD8.0
01024:  RLCF   x52,F
01026:  RLCF   x53,F
01028:  RLCF   x54,F
0102A:  RLCF   x55,F
0102C:  DECFSZ 00,F
0102E:  BRA    101E
01030:  BRA    106E
01032:  BTFSS  x50.7
01034:  BRA    103A
01036:  BSF    x55.7
01038:  BRA    1060
0103A:  BCF    x55.7
0103C:  BRA    1060
0103E:  MOVFF  74B,00
01042:  MOVFF  74C,755
01046:  MOVFF  74D,754
0104A:  MOVFF  74E,753
0104E:  BRA    1060
01050:  MOVFF  747,00
01054:  MOVFF  748,755
01058:  MOVFF  749,754
0105C:  MOVFF  74A,753
01060:  MOVFF  755,01
01064:  MOVFF  754,02
01068:  MOVFF  753,03
0106C:  BRA    10D6
0106E:  CLRF   00
01070:  CLRF   01
01072:  CLRF   02
01074:  CLRF   03
01076:  BRA    10D6
01078:  CLRF   x52
0107A:  COMF   x53,F
0107C:  COMF   x54,F
0107E:  COMF   x55,F
01080:  COMF   x52,F
01082:  INCF   x52,F
01084:  BNZ   1090
01086:  INCF   x53,F
01088:  BNZ   1090
0108A:  INCF   x54,F
0108C:  BNZ   1090
0108E:  INCF   x55,F
01090:  BTFSC  x51.0
01092:  BRA    0EB8
01094:  BTFSC  x51.1
01096:  BRA    0F40
01098:  BTFSC  x51.2
0109A:  BRA    0FAE
0109C:  BRA    1004
0109E:  MOVF   FEF,W
010A0:  ADDWF  x53,F
010A2:  BNC   10AE
010A4:  INCF   x54,F
010A6:  BNZ   10AE
010A8:  INCF   x55,F
010AA:  BTFSC  FD8.2
010AC:  BSF    x4F.0
010AE:  MOVF   FED,F
010B0:  MOVF   FEF,W
010B2:  ADDWF  x54,F
010B4:  BNC   10BC
010B6:  INCF   x55,F
010B8:  BTFSC  FD8.2
010BA:  BSF    x4F.0
010BC:  MOVF   FED,F
010BE:  MOVF   FEF,W
010C0:  BTFSC  FEF.7
010C2:  BRA    10C6
010C4:  XORLW  80
010C6:  ADDWF  x55,F
010C8:  BTFSC  FD8.0
010CA:  BSF    x4F.0
010CC:  BTFSC  x51.4
010CE:  BRA    0EC8
010D0:  BTFSC  x51.5
010D2:  BRA    0F50
010D4:  BRA    0FBE
010D6:  MOVLB  0
010D8:  RETURN 0
*
01630:  ADDWF  FE8,W
01632:  CLRF   FF7
01634:  RLCF   FF7,F
01636:  ADDLW  4B
01638:  MOVWF  FF6
0163A:  MOVLW  16
0163C:  ADDWFC FF7,F
0163E:  TBLRD*-
01640:  MOVF   FF5,W
01642:  MOVWF  FFA
01644:  TBLRD*
01646:  MOVF   FF5,W
01648:  MOVWF  FF9
0164A:  DATA F2,10
0164C:  DATA B2,11
0164E:  DATA 72,12
01650:  DATA 32,13
01652:  DATA F2,13
01654:  DATA B2,14
01656:  DATA 72,15
01658:  BTFSC  FD8.1
0165A:  BRA    1664
0165C:  MOVLW  07
0165E:  MOVWF  FEA
01660:  MOVLW  2D
01662:  MOVWF  FE9
01664:  MOVLB  7
01666:  MOVF   x28,W
01668:  XORWF  x2C,W
0166A:  ANDLW  80
0166C:  MOVWF  x32
0166E:  BTFSS  x28.7
01670:  BRA    1688
01672:  COMF   x25,F
01674:  COMF   x26,F
01676:  COMF   x27,F
01678:  COMF   x28,F
0167A:  INCF   x25,F
0167C:  BTFSC  FD8.2
0167E:  INCF   x26,F
01680:  BTFSC  FD8.2
01682:  INCF   x27,F
01684:  BTFSC  FD8.2
01686:  INCF   x28,F
01688:  BTFSS  x2C.7
0168A:  BRA    16A2
0168C:  COMF   x29,F
0168E:  COMF   x2A,F
01690:  COMF   x2B,F
01692:  COMF   x2C,F
01694:  INCF   x29,F
01696:  BTFSC  FD8.2
01698:  INCF   x2A,F
0169A:  BTFSC  FD8.2
0169C:  INCF   x2B,F
0169E:  BTFSC  FD8.2
016A0:  INCF   x2C,F
016A2:  CLRF   00
016A4:  CLRF   01
016A6:  CLRF   02
016A8:  CLRF   03
016AA:  CLRF   x2D
016AC:  CLRF   x2E
016AE:  CLRF   x2F
016B0:  CLRF   x30
016B2:  MOVF   x2C,W
016B4:  IORWF  x2B,W
016B6:  IORWF  x2A,W
016B8:  IORWF  x29,W
016BA:  BZ    1714
016BC:  MOVLW  20
016BE:  MOVWF  x31
016C0:  BCF    FD8.0
016C2:  RLCF   x25,F
016C4:  RLCF   x26,F
016C6:  RLCF   x27,F
016C8:  RLCF   x28,F
016CA:  RLCF   x2D,F
016CC:  RLCF   x2E,F
016CE:  RLCF   x2F,F
016D0:  RLCF   x30,F
016D2:  MOVF   x2C,W
016D4:  SUBWF  x30,W
016D6:  BNZ   16E8
016D8:  MOVF   x2B,W
016DA:  SUBWF  x2F,W
016DC:  BNZ   16E8
016DE:  MOVF   x2A,W
016E0:  SUBWF  x2E,W
016E2:  BNZ   16E8
016E4:  MOVF   x29,W
016E6:  SUBWF  x2D,W
016E8:  BNC   1708
016EA:  MOVF   x29,W
016EC:  SUBWF  x2D,F
016EE:  MOVF   x2A,W
016F0:  BTFSS  FD8.0
016F2:  INCFSZ x2A,W
016F4:  SUBWF  x2E,F
016F6:  MOVF   x2B,W
016F8:  BTFSS  FD8.0
016FA:  INCFSZ x2B,W
016FC:  SUBWF  x2F,F
016FE:  MOVF   x2C,W
01700:  BTFSS  FD8.0
01702:  INCFSZ x2C,W
01704:  SUBWF  x30,F
01706:  BSF    FD8.0
01708:  RLCF   00,F
0170A:  RLCF   01,F
0170C:  RLCF   02,F
0170E:  RLCF   03,F
01710:  DECFSZ x31,F
01712:  BRA    16C0
01714:  BTFSS  x32.7
01716:  BRA    172E
01718:  COMF   00,F
0171A:  COMF   01,F
0171C:  COMF   02,F
0171E:  COMF   03,F
01720:  INCF   00,F
01722:  BTFSC  FD8.2
01724:  INCF   01,F
01726:  BTFSC  FD8.2
01728:  INCF   02,F
0172A:  BTFSC  FD8.2
0172C:  INCF   03,F
0172E:  MOVFF  72D,FEF
01732:  MOVFF  72E,FEC
01736:  MOVFF  72F,FEC
0173A:  MOVFF  730,FEC
0173E:  MOVLB  0
01740:  RETURN 0
*
01CAE:  MOVLW  B6
01CB0:  MOVWF  00
01CB2:  CLRF   03
01CB4:  CLRF   02
01CB6:  CLRF   01
01CB8:  MOVLB  7
01CBA:  BCF    x11.0
01CBC:  BTFSS  x10.7
01CBE:  BRA    1CD8
01CC0:  BSF    x11.0
01CC2:  COMF   x0D,F
01CC4:  COMF   x0E,F
01CC6:  COMF   x0F,F
01CC8:  COMF   x10,F
01CCA:  INCF   x0D,F
01CCC:  BNZ   1CD8
01CCE:  INCF   x0E,F
01CD0:  BNZ   1CD8
01CD2:  INCF   x0F,F
01CD4:  BTFSC  FD8.2
01CD6:  INCF   x10,F
01CD8:  MOVF   x0D,W
01CDA:  IORWF  x0E,W
01CDC:  IORWF  x0F,W
01CDE:  IORWF  x10,W
01CE0:  BNZ   1CE6
01CE2:  CLRF   00
01CE4:  BRA    1D04
01CE6:  BCF    FD8.0
01CE8:  BTFSC  01.7
01CEA:  BRA    1CFE
01CEC:  RLCF   x0D,F
01CEE:  RLCF   x0E,F
01CF0:  RLCF   x0F,F
01CF2:  RLCF   x10,F
01CF4:  RLCF   03,F
01CF6:  RLCF   02,F
01CF8:  RLCF   01,F
01CFA:  DECFSZ 00,F
01CFC:  BRA    1CE6
01CFE:  BCF    01.7
01D00:  BTFSC  x11.0
01D02:  BSF    01.7
01D04:  MOVLB  0
01D06:  RETURN 0
01D08:  MOVFF  744,74B
01D0C:  MOVLB  7
01D0E:  MOVF   x48,W
01D10:  XORWF  x4B,F
01D12:  BTFSS  x4B.7
01D14:  BRA    1D20
01D16:  BCF    FD8.2
01D18:  BCF    FD8.0
01D1A:  BTFSC  x44.7
01D1C:  BSF    FD8.0
01D1E:  BRA    1D7E
01D20:  MOVFF  744,74B
01D24:  MOVFF  747,74C
01D28:  MOVF   x43,W
01D2A:  SUBWF  x4C,F
01D2C:  BZ    1D3A
01D2E:  BTFSS  x4B.7
01D30:  BRA    1D7E
01D32:  MOVF   FD8,W
01D34:  XORLW  01
01D36:  MOVWF  FD8
01D38:  BRA    1D7E
01D3A:  MOVFF  748,74C
01D3E:  MOVF   x44,W
01D40:  SUBWF  x4C,F
01D42:  BZ    1D50
01D44:  BTFSS  x4B.7
01D46:  BRA    1D7E
01D48:  MOVF   FD8,W
01D4A:  XORLW  01
01D4C:  MOVWF  FD8
01D4E:  BRA    1D7E
01D50:  MOVFF  749,74C
01D54:  MOVF   x45,W
01D56:  SUBWF  x4C,F
01D58:  BZ    1D66
01D5A:  BTFSS  x4B.7
01D5C:  BRA    1D7E
01D5E:  MOVF   FD8,W
01D60:  XORLW  01
01D62:  MOVWF  FD8
01D64:  BRA    1D7E
01D66:  MOVFF  74A,74C
01D6A:  MOVF   x46,W
01D6C:  SUBWF  x4C,F
01D6E:  BZ    1D7C
01D70:  BTFSS  x4B.7
01D72:  BRA    1D7E
01D74:  MOVF   FD8,W
01D76:  XORLW  01
01D78:  MOVWF  FD8
01D7A:  BRA    1D7E
01D7C:  BCF    FD8.0
01D7E:  MOVLB  0
01D80:  RETURN 0
01D82:  MOVLB  7
01D84:  MOVF   x3C,W
01D86:  BTFSC  FD8.2
01D88:  BRA    1ED4
01D8A:  MOVWF  x48
01D8C:  MOVF   x40,W
01D8E:  BTFSC  FD8.2
01D90:  BRA    1ED4
01D92:  SUBWF  x48,F
01D94:  BNC   1DA0
01D96:  MOVLW  7F
01D98:  ADDWF  x48,F
01D9A:  BTFSC  FD8.0
01D9C:  BRA    1ED4
01D9E:  BRA    1DAC
01DA0:  MOVLW  81
01DA2:  SUBWF  x48,F
01DA4:  BTFSS  FD8.0
01DA6:  BRA    1ED4
01DA8:  BTFSC  FD8.2
01DAA:  BRA    1ED4
01DAC:  MOVFF  748,00
01DB0:  CLRF   01
01DB2:  CLRF   02
01DB4:  CLRF   03
01DB6:  CLRF   x47
01DB8:  MOVFF  73D,746
01DBC:  BSF    x46.7
01DBE:  MOVFF  73E,745
01DC2:  MOVFF  73F,744
01DC6:  MOVLW  19
01DC8:  MOVWF  x48
01DCA:  MOVF   x43,W
01DCC:  SUBWF  x44,F
01DCE:  BC    1DEA
01DD0:  MOVLW  01
01DD2:  SUBWF  x45,F
01DD4:  BC    1DEA
01DD6:  SUBWF  x46,F
01DD8:  BC    1DEA
01DDA:  SUBWF  x47,F
01DDC:  BC    1DEA
01DDE:  INCF   x47,F
01DE0:  INCF   x46,F
01DE2:  INCF   x45,F
01DE4:  MOVF   x43,W
01DE6:  ADDWF  x44,F
01DE8:  BRA    1E3A
01DEA:  MOVF   x42,W
01DEC:  SUBWF  x45,F
01DEE:  BC    1E14
01DF0:  MOVLW  01
01DF2:  SUBWF  x46,F
01DF4:  BC    1E14
01DF6:  SUBWF  x47,F
01DF8:  BC    1E14
01DFA:  INCF   x47,F
01DFC:  INCF   x46,F
01DFE:  MOVF   x42,W
01E00:  ADDWF  x45,F
01E02:  MOVF   x43,W
01E04:  ADDWF  x44,F
01E06:  BNC   1E3A
01E08:  INCF   x45,F
01E0A:  BNZ   1E3A
01E0C:  INCF   x46,F
01E0E:  BNZ   1E3A
01E10:  INCF   x47,F
01E12:  BRA    1E3A
01E14:  MOVF   x41,W
01E16:  IORLW  80
01E18:  SUBWF  x46,F
01E1A:  BC    1E38
01E1C:  MOVLW  01
01E1E:  SUBWF  x47,F
01E20:  BC    1E38
01E22:  INCF   x47,F
01E24:  MOVF   x41,W
01E26:  IORLW  80
01E28:  ADDWF  x46,F
01E2A:  MOVF   x42,W
01E2C:  ADDWF  x45,F
01E2E:  BNC   1E02
01E30:  INCF   x46,F
01E32:  BNZ   1E02
01E34:  INCF   x47,F
01E36:  BRA    1E02
01E38:  BSF    03.0
01E3A:  DECFSZ x48,F
01E3C:  BRA    1E40
01E3E:  BRA    1E56
01E40:  BCF    FD8.0
01E42:  RLCF   x44,F
01E44:  RLCF   x45,F
01E46:  RLCF   x46,F
01E48:  RLCF   x47,F
01E4A:  BCF    FD8.0
01E4C:  RLCF   03,F
01E4E:  RLCF   02,F
01E50:  RLCF   01,F
01E52:  RLCF   x49,F
01E54:  BRA    1DCA
01E56:  BTFSS  x49.0
01E58:  BRA    1E66
01E5A:  BCF    FD8.0
01E5C:  RRCF   01,F
01E5E:  RRCF   02,F
01E60:  RRCF   03,F
01E62:  RRCF   x49,F
01E64:  BRA    1E6A
01E66:  DECF   00,F
01E68:  BZ    1ED4
01E6A:  BTFSC  x49.7
01E6C:  BRA    1EAA
01E6E:  BCF    FD8.0
01E70:  RLCF   x44,F
01E72:  RLCF   x45,F
01E74:  RLCF   x46,F
01E76:  RLCF   x47,F
01E78:  MOVF   x43,W
01E7A:  SUBWF  x44,F
01E7C:  BC    1E8C
01E7E:  MOVLW  01
01E80:  SUBWF  x45,F
01E82:  BC    1E8C
01E84:  SUBWF  x46,F
01E86:  BC    1E8C
01E88:  SUBWF  x47,F
01E8A:  BNC   1EC0
01E8C:  MOVF   x42,W
01E8E:  SUBWF  x45,F
01E90:  BC    1E9C
01E92:  MOVLW  01
01E94:  SUBWF  x46,F
01E96:  BC    1E9C
01E98:  SUBWF  x47,F
01E9A:  BNC   1EC0
01E9C:  MOVF   x41,W
01E9E:  IORLW  80
01EA0:  SUBWF  x46,F
01EA2:  BC    1EAA
01EA4:  MOVLW  01
01EA6:  SUBWF  x47,F
01EA8:  BNC   1EC0
01EAA:  INCF   03,F
01EAC:  BNZ   1EC0
01EAE:  INCF   02,F
01EB0:  BNZ   1EC0
01EB2:  INCF   01,F
01EB4:  BNZ   1EC0
01EB6:  INCF   00,F
01EB8:  BZ    1ED4
01EBA:  RRCF   01,F
01EBC:  RRCF   02,F
01EBE:  RRCF   03,F
01EC0:  MOVFF  73D,748
01EC4:  MOVF   x41,W
01EC6:  XORWF  x48,F
01EC8:  BTFSS  x48.7
01ECA:  BRA    1ED0
01ECC:  BSF    01.7
01ECE:  BRA    1EDC
01ED0:  BCF    01.7
01ED2:  BRA    1EDC
01ED4:  CLRF   00
01ED6:  CLRF   01
01ED8:  CLRF   02
01EDA:  CLRF   03
01EDC:  MOVLB  0
01EDE:  RETURN 0
*
0268A:  ADDWF  FE8,W
0268C:  CLRF   FF7
0268E:  RLCF   FF7,F
02690:  ADDLW  A5
02692:  MOVWF  FF6
02694:  MOVLW  26
02696:  ADDWFC FF7,F
02698:  TBLRD*-
0269A:  MOVF   FF5,W
0269C:  MOVWF  FFA
0269E:  TBLRD*
026A0:  MOVF   FF5,W
026A2:  MOVWF  FF9
026A4:  DATA 92,25
026A6:  DATA AC,25
026A8:  DATA 00,26
026AA:  DATA 64,26
026AC:  MOVLW  8E
026AE:  MOVWF  00
026B0:  MOVFF  73A,01
026B4:  MOVFF  739,02
026B8:  CLRF   03
026BA:  BTFSS  01.7
026BC:  BRA    26C8
026BE:  COMF   01,F
026C0:  COMF   02,F
026C2:  INCF   02,F
026C4:  BNZ   26C8
026C6:  INCF   01,F
026C8:  MOVF   01,F
026CA:  BNZ   26DE
026CC:  MOVFF  02,01
026D0:  CLRF   02
026D2:  MOVLW  08
026D4:  SUBWF  00,F
026D6:  MOVF   01,F
026D8:  BNZ   26DE
026DA:  CLRF   00
026DC:  BRA    26FA
026DE:  BCF    FD8.0
026E0:  BTFSC  01.7
026E2:  BRA    26EC
026E4:  RLCF   02,F
026E6:  RLCF   01,F
026E8:  DECF   00,F
026EA:  BRA    26DE
026EC:  MOVLB  7
026EE:  BTFSS  x3A.7
026F0:  BRA    26F6
026F2:  MOVLB  0
026F4:  BRA    26FA
026F6:  BCF    01.7
026F8:  MOVLB  0
026FA:  RETURN 0
026FC:  MOVLW  8E
026FE:  MOVWF  00
02700:  MOVLB  7
02702:  MOVF   x43,W
02704:  SUBWF  00,F
02706:  MOVFF  744,02
0270A:  MOVFF  745,01
0270E:  BSF    02.7
02710:  MOVF   00,F
02712:  BZ    2726
02714:  BCF    FD8.0
02716:  MOVF   02,F
02718:  BNZ   271E
0271A:  MOVF   01,F
0271C:  BZ    2726
0271E:  RRCF   02,F
02720:  RRCF   01,F
02722:  DECFSZ 00,F
02724:  BRA    2714
02726:  BTFSS  x44.7
02728:  BRA    2734
0272A:  COMF   01,F
0272C:  COMF   02,F
0272E:  INCF   01,F
02730:  BTFSC  FD8.2
02732:  INCF   02,F
02734:  MOVLB  0
02736:  RETURN 0
*
0465A:  MOVLB  6
0465C:  MOVF   xFC,W
0465E:  ANDLW  07
04660:  MOVWF  00
04662:  RRCF   xFC,W
04664:  MOVWF  01
04666:  RRCF   01,F
04668:  RRCF   01,F
0466A:  MOVLW  1F
0466C:  ANDWF  01,F
0466E:  MOVF   01,W
04670:  ADDWF  xFD,W
04672:  MOVWF  FE9
04674:  MOVLW  00
04676:  ADDWFC xFE,W
04678:  MOVWF  FEA
0467A:  MOVFF  FEF,01
0467E:  INCF   00,F
04680:  BRA    4684
04682:  RRCF   01,F
04684:  DECFSZ 00,F
04686:  BRA    4682
04688:  MOVLW  01
0468A:  ANDWF  01,F
0468C:  MOVLB  0
0468E:  RETURN 0
*
050A4:  MOVF   FEF,F
050A6:  BZ    50CC
050A8:  MOVFF  FEA,6F3
050AC:  MOVFF  FE9,6F2
050B0:  MOVF   FEF,W
050B2:  MOVLB  E
050B4:  BTFSS  xC8.4
050B6:  BRA    50B4
050B8:  MOVWF  F99
050BA:  MOVFF  6F3,FEA
050BE:  MOVFF  6F2,FE9
050C2:  INCF   FE9,F
050C4:  BTFSC  FD8.2
050C6:  INCF   FEA,F
050C8:  MOVLB  0
050CA:  BRA    50A4
050CC:  RETURN 0
*
0561E:  MOVFF  563,FEA
05622:  MOVFF  562,FE9
05626:  MOVFF  73F,FEF
0562A:  INCF   FE9,F
0562C:  BTFSC  FD8.2
0562E:  INCF   FEA,F
05630:  CLRF   FEF
05632:  MOVLB  5
05634:  INCF   x62,F
05636:  BTFSC  FD8.2
05638:  INCF   x63,F
0563A:  MOVLB  0
0563C:  RETURN 0
0563E:  TBLRD*+
05640:  MOVFF  FF6,6FF
05644:  MOVFF  FF7,700
05648:  MOVFF  FF5,73F
0564C:  RCALL  561E
0564E:  MOVFF  6FF,FF6
05652:  MOVFF  700,FF7
05656:  MOVLB  6
05658:  DECFSZ xFE,F
0565A:  BRA    565E
0565C:  BRA    5662
0565E:  MOVLB  0
05660:  BRA    563E
05662:  MOVLB  0
05664:  RETURN 0
05666:  MOVF   01,W
05668:  MOVFF  6FA,72F
0566C:  MOVLW  64
0566E:  MOVLB  7
05670:  MOVWF  x30
05672:  MOVLB  0
05674:  CALL   0896
05678:  MOVFF  00,6FA
0567C:  MOVF   01,W
0567E:  MOVLW  30
05680:  BNZ   5692
05682:  MOVLB  6
05684:  BTFSS  xFB.1
05686:  BRA    56A4
05688:  BTFSC  xFB.3
0568A:  BRA    56A4
0568C:  BTFSC  xFB.4
0568E:  MOVLW  20
05690:  BRA    569A
05692:  MOVLB  6
05694:  BCF    xFB.3
05696:  BCF    xFB.4
05698:  BSF    xFB.0
0569A:  ADDWF  01,F
0569C:  MOVFF  01,73F
056A0:  MOVLB  0
056A2:  RCALL  561E
056A4:  MOVFF  6FA,72F
056A8:  MOVLW  0A
056AA:  MOVLB  7
056AC:  MOVWF  x30
056AE:  MOVLB  0
056B0:  CALL   0896
056B4:  MOVFF  00,6FA
056B8:  MOVF   01,W
056BA:  MOVLW  30
056BC:  BNZ   56CE
056BE:  MOVLB  6
056C0:  BTFSC  xFB.3
056C2:  BRA    56D8
056C4:  BTFSS  xFB.0
056C6:  BRA    56D8
056C8:  BTFSC  xFB.4
056CA:  MOVLW  20
056CC:  MOVLB  0
056CE:  ADDWF  01,F
056D0:  MOVFF  01,73F
056D4:  RCALL  561E
056D6:  MOVLB  6
056D8:  MOVLW  30
056DA:  ADDWF  xFA,F
056DC:  MOVFF  6FA,73F
056E0:  MOVLB  0
056E2:  RCALL  561E
056E4:  RETURN 0
056E6:  MOVLB  7
056E8:  MOVF   x3F,W
056EA:  SUBLW  B6
056EC:  MOVWF  x3F
056EE:  CLRF   03
056F0:  MOVFF  740,743
056F4:  BSF    x40.7
056F6:  BCF    FD8.0
056F8:  RRCF   x40,F
056FA:  RRCF   x41,F
056FC:  RRCF   x42,F
056FE:  RRCF   03,F
05700:  RRCF   02,F
05702:  RRCF   01,F
05704:  RRCF   00,F
05706:  DECFSZ x3F,F
05708:  BRA    56F6
0570A:  BTFSS  x43.7
0570C:  BRA    5724
0570E:  COMF   00,F
05710:  COMF   01,F
05712:  COMF   02,F
05714:  COMF   03,F
05716:  INCF   00,F
05718:  BTFSC  FD8.2
0571A:  INCF   01,F
0571C:  BTFSC  FD8.2
0571E:  INCF   02,F
05720:  BTFSC  FD8.2
05722:  INCF   03,F
05724:  MOVLB  0
05726:  RETURN 0
05728:  BTFSC  FD8.1
0572A:  BRA    5734
0572C:  MOVLW  07
0572E:  MOVWF  FEA
05730:  MOVLW  47
05732:  MOVWF  FE9
05734:  CLRF   00
05736:  CLRF   01
05738:  CLRF   02
0573A:  CLRF   03
0573C:  MOVLB  7
0573E:  CLRF   x47
05740:  CLRF   x48
05742:  CLRF   x49
05744:  CLRF   x4A
05746:  MOVF   x46,W
05748:  IORWF  x45,W
0574A:  IORWF  x44,W
0574C:  IORWF  x43,W
0574E:  BZ    57A8
05750:  MOVLW  20
05752:  MOVWF  x4B
05754:  BCF    FD8.0
05756:  RLCF   x3F,F
05758:  RLCF   x40,F
0575A:  RLCF   x41,F
0575C:  RLCF   x42,F
0575E:  RLCF   x47,F
05760:  RLCF   x48,F
05762:  RLCF   x49,F
05764:  RLCF   x4A,F
05766:  MOVF   x46,W
05768:  SUBWF  x4A,W
0576A:  BNZ   577C
0576C:  MOVF   x45,W
0576E:  SUBWF  x49,W
05770:  BNZ   577C
05772:  MOVF   x44,W
05774:  SUBWF  x48,W
05776:  BNZ   577C
05778:  MOVF   x43,W
0577A:  SUBWF  x47,W
0577C:  BNC   579C
0577E:  MOVF   x43,W
05780:  SUBWF  x47,F
05782:  MOVF   x44,W
05784:  BTFSS  FD8.0
05786:  INCFSZ x44,W
05788:  SUBWF  x48,F
0578A:  MOVF   x45,W
0578C:  BTFSS  FD8.0
0578E:  INCFSZ x45,W
05790:  SUBWF  x49,F
05792:  MOVF   x46,W
05794:  BTFSS  FD8.0
05796:  INCFSZ x46,W
05798:  SUBWF  x4A,F
0579A:  BSF    FD8.0
0579C:  RLCF   00,F
0579E:  RLCF   01,F
057A0:  RLCF   02,F
057A2:  RLCF   03,F
057A4:  DECFSZ x4B,F
057A6:  BRA    5754
057A8:  MOVFF  747,FEF
057AC:  MOVFF  748,FEC
057B0:  MOVFF  749,FEC
057B4:  MOVFF  74A,FEC
057B8:  MOVLB  0
057BA:  RETURN 0
057BC:  MOVF   FE9,W
057BE:  MOVLB  7
057C0:  MOVWF  x37
057C2:  MOVF   x36,W
057C4:  MOVWF  x39
057C6:  BZ    5800
057C8:  MOVFF  735,746
057CC:  MOVFF  734,745
057D0:  MOVFF  733,744
057D4:  MOVFF  732,743
057D8:  CLRF   x4A
057DA:  CLRF   x49
057DC:  MOVLW  20
057DE:  MOVWF  x48
057E0:  MOVLW  82
057E2:  MOVWF  x47
057E4:  MOVLB  0
057E6:  CALL   0D6C
057EA:  MOVFF  03,735
057EE:  MOVFF  02,734
057F2:  MOVFF  01,733
057F6:  MOVFF  00,732
057FA:  MOVLB  7
057FC:  DECFSZ x39,F
057FE:  BRA    57C8
05800:  MOVFF  735,742
05804:  MOVFF  734,741
05808:  MOVFF  733,740
0580C:  MOVFF  732,73F
05810:  MOVLB  0
05812:  RCALL  56E6
05814:  MOVFF  03,735
05818:  MOVFF  02,734
0581C:  MOVFF  01,733
05820:  MOVFF  00,732
05824:  MOVLB  7
05826:  BTFSS  x35.7
05828:  BRA    5844
0582A:  DECF   x37,F
0582C:  BSF    x37.5
0582E:  COMF   x32,F
05830:  COMF   x33,F
05832:  COMF   x34,F
05834:  COMF   x35,F
05836:  INCF   x32,F
05838:  BTFSC  FD8.2
0583A:  INCF   x33,F
0583C:  BTFSC  FD8.2
0583E:  INCF   x34,F
05840:  BTFSC  FD8.2
05842:  INCF   x35,F
05844:  MOVLW  3B
05846:  MOVWF  x3E
05848:  MOVLW  9A
0584A:  MOVWF  x3D
0584C:  MOVLW  CA
0584E:  MOVWF  x3C
05850:  CLRF   x3B
05852:  MOVLW  0A
05854:  MOVWF  x39
05856:  MOVF   x36,W
05858:  BTFSC  FD8.2
0585A:  INCF   x37,F
0585C:  BSF    FD8.1
0585E:  MOVLW  07
05860:  MOVWF  FEA
05862:  MOVLW  32
05864:  MOVWF  FE9
05866:  MOVFF  735,742
0586A:  MOVFF  734,741
0586E:  MOVFF  733,740
05872:  MOVFF  732,73F
05876:  MOVFF  73E,746
0587A:  MOVFF  73D,745
0587E:  MOVFF  73C,744
05882:  MOVFF  73B,743
05886:  MOVLB  0
05888:  RCALL  5728
0588A:  MOVF   01,W
0588C:  MOVF   00,F
0588E:  BNZ   58B6
05890:  MOVLB  7
05892:  INCF   x36,W
05894:  SUBWF  x39,W
05896:  BTFSS  FD8.2
05898:  BRA    589E
0589A:  MOVLB  0
0589C:  BRA    58B6
0589E:  MOVF   x37,W
058A0:  BZ    58BC
058A2:  ANDLW  0F
058A4:  SUBWF  x39,W
058A6:  BZ    58AA
058A8:  BC    592A
058AA:  BTFSC  x37.7
058AC:  BRA    592A
058AE:  BTFSC  x37.6
058B0:  BRA    58BC
058B2:  MOVLW  20
058B4:  BRA    591E
058B6:  MOVLW  20
058B8:  MOVLB  7
058BA:  ANDWF  x37,F
058BC:  BTFSS  x37.5
058BE:  BRA    58DC
058C0:  BCF    x37.5
058C2:  MOVF   x36,W
058C4:  BTFSS  FD8.2
058C6:  DECF   x37,F
058C8:  MOVF   00,W
058CA:  MOVWF  x37
058CC:  MOVLW  2D
058CE:  MOVWF  x3F
058D0:  MOVLB  0
058D2:  RCALL  561E
058D4:  MOVLB  7
058D6:  MOVF   x37,W
058D8:  MOVWF  00
058DA:  CLRF   x37
058DC:  MOVF   x36,W
058DE:  SUBWF  x39,W
058E0:  BNZ   58FA
058E2:  MOVF   00,W
058E4:  MOVWF  x37
058E6:  MOVLW  2E
058E8:  MOVWF  x3F
058EA:  MOVLB  0
058EC:  RCALL  561E
058EE:  MOVLB  7
058F0:  MOVF   x37,W
058F2:  MOVWF  00
058F4:  MOVLW  20
058F6:  ANDWF  x37,F
058F8:  MOVLW  00
058FA:  MOVLW  30
058FC:  BTFSS  x37.5
058FE:  BRA    591E
05900:  BCF    x37.5
05902:  MOVF   x36,W
05904:  BTFSS  FD8.2
05906:  DECF   x37,F
05908:  MOVF   00,W
0590A:  MOVWF  x37
0590C:  MOVLW  2D
0590E:  MOVWF  x3F
05910:  MOVLB  0
05912:  RCALL  561E
05914:  MOVLB  7
05916:  MOVF   x37,W
05918:  MOVWF  00
0591A:  CLRF   x37
0591C:  MOVLW  30
0591E:  ADDWF  00,F
05920:  MOVFF  00,73F
05924:  MOVLB  0
05926:  RCALL  561E
05928:  MOVLB  7
0592A:  BCF    FD8.1
0592C:  MOVFF  73E,742
05930:  MOVFF  73D,741
05934:  MOVFF  73C,740
05938:  MOVFF  73B,73F
0593C:  CLRF   x46
0593E:  CLRF   x45
05940:  CLRF   x44
05942:  MOVLW  0A
05944:  MOVWF  x43
05946:  MOVLB  0
05948:  RCALL  5728
0594A:  MOVFF  03,73E
0594E:  MOVFF  02,73D
05952:  MOVFF  01,73C
05956:  MOVFF  00,73B
0595A:  MOVLB  7
0595C:  DECFSZ x39,F
0595E:  BRA    585C
05960:  MOVLB  0
05962:  RETURN 0
05964:  MOVFF  FEA,6FE
05968:  MOVFF  FE9,6FD
0596C:  MOVLB  6
0596E:  SWAPF  xF7,W
05970:  IORLW  F0
05972:  MOVWF  xF9
05974:  ADDWF  xF9,F
05976:  ADDLW  E2
05978:  MOVWF  xFA
0597A:  ADDLW  32
0597C:  MOVWF  xFC
0597E:  MOVF   xF7,W
05980:  ANDLW  0F
05982:  ADDWF  xFA,F
05984:  ADDWF  xFA,F
05986:  ADDWF  xFC,F
05988:  ADDLW  E9
0598A:  MOVWF  xFB
0598C:  ADDWF  xFB,F
0598E:  ADDWF  xFB,F
05990:  SWAPF  xF6,W
05992:  ANDLW  0F
05994:  ADDWF  xFB,F
05996:  ADDWF  xFC,F
05998:  RLCF   xFB,F
0599A:  RLCF   xFC,F
0599C:  COMF   xFC,F
0599E:  RLCF   xFC,F
059A0:  MOVF   xF6,W
059A2:  ANDLW  0F
059A4:  ADDWF  xFC,F
059A6:  RLCF   xF9,F
059A8:  MOVLW  07
059AA:  MOVWF  xF8
059AC:  MOVLW  0A
059AE:  DECF   xFB,F
059B0:  ADDWF  xFC,F
059B2:  BNC   59AE
059B4:  DECF   xFA,F
059B6:  ADDWF  xFB,F
059B8:  BNC   59B4
059BA:  DECF   xF9,F
059BC:  ADDWF  xFA,F
059BE:  BNC   59BA
059C0:  DECF   xF8,F
059C2:  ADDWF  xF9,F
059C4:  BNC   59C0
059C6:  MOVLW  06
059C8:  MOVWF  FEA
059CA:  MOVLW  F8
059CC:  MOVWF  FE9
059CE:  MOVLW  07
059D0:  ANDWF  xFD,W
059D2:  BCF    xFD.6
059D4:  ADDWF  FE9,F
059D6:  MOVLW  00
059D8:  ADDWFC FEA,F
059DA:  MOVF   FE9,W
059DC:  SUBLW  FC
059DE:  BNZ   59E8
059E0:  MOVF   FEA,W
059E2:  SUBLW  06
059E4:  BNZ   59E8
059E6:  BSF    xFD.6
059E8:  MOVF   FEF,W
059EA:  MOVWF  00
059EC:  BNZ   59FE
059EE:  BTFSC  xFD.6
059F0:  BRA    59FE
059F2:  BTFSC  xFD.4
059F4:  BRA    5A20
059F6:  BTFSC  xFD.3
059F8:  BRA    59FE
059FA:  MOVLW  20
059FC:  BRA    5A04
059FE:  BSF    xFD.3
05A00:  BCF    xFD.4
05A02:  MOVLW  30
05A04:  ADDWF  00,F
05A06:  MOVFF  FEA,6F7
05A0A:  MOVFF  FE9,6F6
05A0E:  MOVFF  00,73F
05A12:  MOVLB  0
05A14:  RCALL  561E
05A16:  MOVFF  6F7,FEA
05A1A:  MOVFF  6F6,FE9
05A1E:  MOVLB  6
05A20:  MOVF   FEE,W
05A22:  BTFSS  xFD.6
05A24:  BRA    59DA
05A26:  MOVLB  0
05A28:  RETURN 0
*
05A7E:  MOVF   FEF,F
05A80:  BZ    5AA0
05A82:  MOVFF  FEA,6F0
05A86:  MOVFF  FE9,6EF
05A8A:  MOVFF  FEF,6F1
05A8E:  BRA    5A2A
05A90:  MOVFF  6F0,FEA
05A94:  MOVFF  6EF,FE9
05A98:  INCF   FE9,F
05A9A:  BTFSC  FD8.2
05A9C:  INCF   FEA,F
05A9E:  BRA    5A7E
05AA0:  GOTO   AAFC (RETURN)
*
05AFE:  MOVF   FEF,F
05B00:  BZ    5B20
05B02:  MOVFF  FEA,6F7
05B06:  MOVFF  FE9,6F6
05B0A:  MOVFF  FEF,73F
05B0E:  RCALL  561E
05B10:  MOVFF  6F7,FEA
05B14:  MOVFF  6F6,FE9
05B18:  INCF   FE9,F
05B1A:  BTFSC  FD8.2
05B1C:  INCF   FEA,F
05B1E:  BRA    5AFE
05B20:  RETURN 0
*
05BD4:  TBLRD*+
05BD6:  MOVF   FF5,F
05BD8:  BZ    5BF2
05BDA:  MOVFF  FF6,6FD
05BDE:  MOVFF  FF7,6FE
05BE2:  MOVFF  FF5,73F
05BE6:  RCALL  561E
05BE8:  MOVFF  6FD,FF6
05BEC:  MOVFF  6FE,FF7
05BF0:  BRA    5BD4
05BF2:  RETURN 0
*
05D16:  MOVLB  7
05D18:  MOVF   x5D,W
05D1A:  XORWF  x5F,W
05D1C:  ANDLW  80
05D1E:  MOVWF  x61
05D20:  BTFSS  x5D.7
05D22:  BRA    5D2E
05D24:  COMF   x5C,F
05D26:  COMF   x5D,F
05D28:  INCF   x5C,F
05D2A:  BTFSC  FD8.2
05D2C:  INCF   x5D,F
05D2E:  BTFSS  x5F.7
05D30:  BRA    5D3C
05D32:  COMF   x5E,F
05D34:  COMF   x5F,F
05D36:  INCF   x5E,F
05D38:  BTFSC  FD8.2
05D3A:  INCF   x5F,F
05D3C:  MOVF   x5C,W
05D3E:  MULWF  x5E
05D40:  MOVFF  FF3,01
05D44:  MOVFF  FF4,00
05D48:  MULWF  x5F
05D4A:  MOVF   FF3,W
05D4C:  ADDWF  00,F
05D4E:  MOVF   x5D,W
05D50:  MULWF  x5E
05D52:  MOVF   FF3,W
05D54:  ADDWFC 00,W
05D56:  MOVWF  02
05D58:  BTFSS  x61.7
05D5A:  BRA    5D66
05D5C:  COMF   01,F
05D5E:  COMF   02,F
05D60:  INCF   01,F
05D62:  BTFSC  FD8.2
05D64:  INCF   02,F
05D66:  MOVLB  0
05D68:  GOTO   5FFC (RETURN)
*
060C0:  MOVLW  20
060C2:  MOVLB  7
060C4:  BTFSS  x2A.4
060C6:  MOVLW  30
060C8:  MOVWF  x2B
060CA:  MOVFF  729,00
060CE:  BTFSS  00.7
060D0:  BRA    60E2
060D2:  COMF   00,F
060D4:  INCF   00,F
060D6:  MOVFF  00,729
060DA:  MOVLW  2D
060DC:  MOVWF  x2B
060DE:  BSF    x2A.7
060E0:  BSF    x2A.0
060E2:  MOVF   01,W
060E4:  MOVFF  729,72F
060E8:  MOVLW  64
060EA:  MOVWF  x30
060EC:  MOVLB  0
060EE:  CALL   0896
060F2:  MOVFF  00,729
060F6:  MOVLW  30
060F8:  ADDWF  01,W
060FA:  MOVLB  7
060FC:  MOVWF  x2C
060FE:  MOVFF  729,72F
06102:  MOVLW  0A
06104:  MOVWF  x30
06106:  MOVLB  0
06108:  CALL   0896
0610C:  MOVLW  30
0610E:  ADDWF  00,W
06110:  MOVLB  7
06112:  MOVWF  x2E
06114:  MOVLW  30
06116:  ADDWF  01,W
06118:  MOVWF  x2D
0611A:  MOVFF  72B,00
0611E:  MOVLW  30
06120:  SUBWF  x2C,W
06122:  BZ    612C
06124:  BSF    x2A.1
06126:  BTFSC  x2A.7
06128:  BSF    x2A.2
0612A:  BRA    6150
0612C:  MOVFF  72B,72C
06130:  MOVLW  20
06132:  MOVWF  x2B
06134:  MOVLW  30
06136:  SUBWF  x2D,W
06138:  BZ    6142
0613A:  BSF    x2A.0
0613C:  BTFSC  x2A.7
0613E:  BSF    x2A.1
06140:  BRA    6150
06142:  BTFSS  FD8.2
06144:  BSF    x2A.0
06146:  BNZ   6150
06148:  MOVFF  72C,72D
0614C:  MOVLW  20
0614E:  MOVWF  x2C
06150:  BTFSC  x2A.2
06152:  BRA    615E
06154:  BTFSC  x2A.1
06156:  BRA    6168
06158:  BTFSC  x2A.0
0615A:  BRA    6172
0615C:  BRA    617C
0615E:  MOVFF  72B,73F
06162:  MOVLB  0
06164:  CALL   561E
06168:  MOVFF  72C,73F
0616C:  MOVLB  0
0616E:  CALL   561E
06172:  MOVFF  72D,73F
06176:  MOVLB  0
06178:  CALL   561E
0617C:  MOVFF  72E,73F
06180:  MOVLB  0
06182:  CALL   561E
06186:  RETURN 0
*
0633A:  MOVLB  7
0633C:  MOVF   x11,W
0633E:  ANDLW  07
06340:  MOVWF  00
06342:  RRCF   x11,W
06344:  MOVWF  01
06346:  RRCF   01,F
06348:  RRCF   01,F
0634A:  MOVLW  1F
0634C:  ANDWF  01,F
0634E:  MOVF   01,W
06350:  ADDWF  x13,W
06352:  MOVWF  FE9
06354:  MOVLW  00
06356:  ADDWFC x14,W
06358:  MOVWF  FEA
0635A:  CLRF   01
0635C:  INCF   01,F
0635E:  INCF   00,F
06360:  BRA    6364
06362:  RLCF   01,F
06364:  DECFSZ 00,F
06366:  BRA    6362
06368:  MOVF   x12,F
0636A:  BZ    6372
0636C:  MOVF   01,W
0636E:  IORWF  FEF,F
06370:  BRA    6378
06372:  COMF   01,F
06374:  MOVF   01,W
06376:  ANDWF  FEF,F
06378:  MOVLB  0
0637A:  RETURN 0
*
0942C:  MOVF   FE9,W
0942E:  MOVLB  7
09430:  MOVWF  x32
09432:  BTFSS  x31.7
09434:  BRA    9450
09436:  DECF   x32,F
09438:  BSF    x32.5
0943A:  COMF   x2E,F
0943C:  COMF   x2F,F
0943E:  COMF   x30,F
09440:  COMF   x31,F
09442:  INCF   x2E,F
09444:  BTFSC  FD8.2
09446:  INCF   x2F,F
09448:  BTFSC  FD8.2
0944A:  INCF   x30,F
0944C:  BTFSC  FD8.2
0944E:  INCF   x31,F
09450:  MOVLW  3B
09452:  MOVWF  x39
09454:  MOVLW  9A
09456:  MOVWF  x38
09458:  MOVLW  CA
0945A:  MOVWF  x37
0945C:  CLRF   x36
0945E:  MOVLW  0A
09460:  MOVWF  x34
09462:  BSF    FD8.1
09464:  MOVLW  07
09466:  MOVWF  FEA
09468:  MOVLW  2E
0946A:  MOVWF  FE9
0946C:  MOVFF  731,742
09470:  MOVFF  730,741
09474:  MOVFF  72F,740
09478:  MOVFF  72E,73F
0947C:  MOVFF  739,746
09480:  MOVFF  738,745
09484:  MOVFF  737,744
09488:  MOVFF  736,743
0948C:  MOVLB  0
0948E:  CALL   5728
09492:  MOVF   01,W
09494:  MOVF   00,F
09496:  BNZ   94BE
09498:  MOVLB  7
0949A:  MOVF   x34,W
0949C:  XORLW  01
0949E:  BTFSS  FD8.2
094A0:  BRA    94A6
094A2:  MOVLB  0
094A4:  BRA    94BE
094A6:  MOVF   x32,W
094A8:  BZ    94C4
094AA:  ANDLW  0F
094AC:  SUBWF  x34,W
094AE:  BZ    94B2
094B0:  BC    950E
094B2:  BTFSC  x32.7
094B4:  BRA    950E
094B6:  BTFSC  x32.6
094B8:  BRA    94C4
094BA:  MOVLW  20
094BC:  BRA    9500
094BE:  MOVLW  20
094C0:  MOVLB  7
094C2:  ANDWF  x32,F
094C4:  BTFSS  x32.5
094C6:  BRA    94E0
094C8:  BCF    x32.5
094CA:  MOVFF  00,732
094CE:  MOVLW  2D
094D0:  MOVWF  x3F
094D2:  MOVLB  0
094D4:  CALL   561E
094D8:  MOVLB  7
094DA:  MOVFF  732,00
094DE:  CLRF   x32
094E0:  MOVLW  30
094E2:  BTFSS  x32.5
094E4:  BRA    9500
094E6:  BCF    x32.5
094E8:  MOVFF  00,732
094EC:  MOVLW  2D
094EE:  MOVWF  x3F
094F0:  MOVLB  0
094F2:  CALL   561E
094F6:  MOVLB  7
094F8:  MOVFF  732,00
094FC:  CLRF   x32
094FE:  MOVLW  30
09500:  ADDWF  00,F
09502:  MOVFF  00,73F
09506:  MOVLB  0
09508:  CALL   561E
0950C:  MOVLB  7
0950E:  BCF    FD8.1
09510:  MOVFF  739,742
09514:  MOVFF  738,741
09518:  MOVFF  737,740
0951C:  MOVFF  736,73F
09520:  CLRF   x46
09522:  CLRF   x45
09524:  CLRF   x44
09526:  MOVLW  0A
09528:  MOVWF  x43
0952A:  MOVLB  0
0952C:  CALL   5728
09530:  MOVFF  03,739
09534:  MOVFF  02,738
09538:  MOVFF  01,737
0953C:  MOVFF  00,736
09540:  MOVLB  7
09542:  DECFSZ x34,F
09544:  BRA    9462
09546:  MOVLB  0
09548:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003A4:  MOVLW  06
003A6:  MOVWF  FEA
003A8:  MOVLW  F5
003AA:  MOVWF  FE9
003AC:  MOVF   FEF,W
003AE:  BZ    03CC
003B0:  MOVLW  14
003B2:  MOVWF  01
003B4:  CLRF   00
003B6:  DECFSZ 00,F
003B8:  BRA    03B6
003BA:  DECFSZ 01,F
003BC:  BRA    03B4
003BE:  MOVLW  BF
003C0:  MOVWF  00
003C2:  DECFSZ 00,F
003C4:  BRA    03C2
003C6:  BRA    03C8
003C8:  DECFSZ FEF,F
003CA:  BRA    03B0
003CC:  RETURN 0
*
00702:  MOVLW  01
00704:  MOVLB  6
00706:  SUBWF  xFB,F
00708:  BNC   0722
0070A:  MOVLW  06
0070C:  MOVWF  FEA
0070E:  MOVLW  FB
00710:  MOVWF  FE9
00712:  MOVF   FEF,W
00714:  BZ    0722
00716:  MOVLW  04
00718:  MOVWF  00
0071A:  DECFSZ 00,F
0071C:  BRA    071A
0071E:  DECFSZ FEF,F
00720:  BRA    0716
00722:  MOVLB  0
00724:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003CE:  MOVLW  CF
003D0:  MOVWF  F87
003D2:  CLRF   F82
....................    output_b(portB_reset);
003D4:  MOVLW  C4
003D6:  MOVWF  F88
003D8:  CLRF   F83
....................    output_c(portC_reset);
003DA:  MOVLW  93
003DC:  MOVWF  F89
003DE:  CLRF   F84
....................    output_d(portD_reset);
003E0:  MOVLW  1F
003E2:  MOVWF  F8A
003E4:  CLRF   F85
....................    output_e(portE_reset);
003E6:  BCF    F8B.0
003E8:  BCF    F8B.1
003EA:  BCF    F8B.2
003EC:  BCF    F8B.3
003EE:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003F0:  MOVLB  F
003F2:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003F4:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003F6:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003F8:  SETF   x20
....................    port_e_pullups(portE_pullups);
003FA:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003FC:  MOVLW  40
003FE:  MOVWF  x0C
00400:  CLRF   x14
00402:  MOVLW  03
00404:  MOVWF  x1C
00406:  MOVLW  0F
00408:  MOVWF  x21
0040A:  CLRF   x29
0040C:  MOVLB  0
0040E:  GOTO   A758 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05B5C:  MOVFF  731,FEA
05B60:  MOVLB  7
05B62:  MOVFF  730,FE9
05B66:  MOVFF  FEF,734
05B6A:  MOVFF  733,FEA
05B6E:  MOVFF  732,FE9
05B72:  MOVF   FEF,W
05B74:  SUBWF  x34,W
05B76:  BNZ   5BA6
....................       if (*s1 == '\0')
05B78:  MOVFF  731,03
05B7C:  MOVFF  730,FE9
05B80:  MOVFF  03,FEA
05B84:  MOVF   FEF,F
05B86:  BNZ   5B8E
....................          return(0);
05B88:  MOVLW  00
05B8A:  MOVWF  01
05B8C:  BRA    5BD0
05B8E:  MOVFF  731,03
05B92:  MOVF   x30,W
05B94:  INCF   x30,F
05B96:  BTFSC  FD8.2
05B98:  INCF   x31,F
05B9A:  INCF   x32,F
05B9C:  BTFSC  FD8.2
05B9E:  INCF   x33,F
05BA0:  MOVLB  0
05BA2:  BRA    5B5C
05BA4:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05BA6:  MOVFF  731,03
05BAA:  MOVFF  730,FE9
05BAE:  MOVFF  03,FEA
05BB2:  MOVFF  FEF,734
05BB6:  MOVFF  733,03
05BBA:  MOVFF  732,FE9
05BBE:  MOVFF  03,FEA
05BC2:  MOVF   FEF,W
05BC4:  SUBWF  x34,W
05BC6:  BC    5BCC
05BC8:  MOVLW  FF
05BCA:  BRA    5BCE
05BCC:  MOVLW  01
05BCE:  MOVWF  01
05BD0:  MOVLB  0
05BD2:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05CCC:  MOVFF  75D,760
....................    for(su=s;0<n;++su,--n)
05CD0:  MOVFF  75C,762
05CD4:  MOVFF  75B,761
05CD8:  MOVLB  7
05CDA:  MOVF   x5F,F
05CDC:  BNZ   5CE4
05CDE:  MOVF   x5E,W
05CE0:  SUBLW  00
05CE2:  BC    5D0C
....................       if(*su==uc)
05CE4:  MOVFF  762,FEA
05CE8:  MOVFF  761,FE9
05CEC:  MOVF   x60,W
05CEE:  SUBWF  FEF,W
05CF0:  BNZ   5CFC
....................       return su;
05CF2:  MOVFF  761,01
05CF6:  MOVFF  762,02
05CFA:  BRA    5D12
05CFC:  INCF   x61,F
05CFE:  BTFSC  FD8.2
05D00:  INCF   x62,F
05D02:  MOVF   x5E,W
05D04:  BTFSC  FD8.2
05D06:  DECF   x5F,F
05D08:  DECF   x5E,F
05D0A:  BRA    5CDA
....................    return NULL;
05D0C:  MOVLW  00
05D0E:  MOVWF  01
05D10:  MOVWF  02
05D12:  MOVLB  0
05D14:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
055E6:  MOVFF  731,733
055EA:  MOVFF  730,732
055EE:  MOVFF  733,FEA
055F2:  MOVLB  7
055F4:  MOVFF  732,FE9
055F8:  MOVF   FEF,F
055FA:  BZ    5608
055FC:  INCF   x32,F
055FE:  BTFSC  FD8.2
05600:  INCF   x33,F
05602:  MOVLB  0
05604:  BRA    55EE
05606:  MOVLB  7
....................    return(sc - s);
05608:  MOVF   x30,W
0560A:  SUBWF  x32,W
0560C:  MOVWF  00
0560E:  MOVF   x31,W
05610:  SUBWFB x33,W
05612:  MOVWF  03
05614:  MOVFF  00,01
05618:  MOVWF  02
0561A:  MOVLB  0
0561C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06E90:  MOVLB  7
06E92:  CLRF   x0A
06E94:  CLRF   x09
06E96:  CLRF   x08
06E98:  MOVLW  7F
06E9A:  MOVWF  x07
06E9C:  CLRF   x0E
06E9E:  CLRF   x0D
06EA0:  CLRF   x0C
06EA2:  CLRF   x0B
06EA4:  BSF    x0F.0
06EA6:  BCF    x0F.1
06EA8:  BCF    x0F.2
06EAA:  CLRF   x11
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06EAC:  MOVF   x03,W
06EAE:  IORWF  x04,W
06EB0:  BNZ   6EBC
....................       return 0;
06EB2:  CLRF   00
06EB4:  CLRF   01
06EB6:  CLRF   02
06EB8:  CLRF   03
06EBA:  BRA    70E6
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06EBC:  MOVF   x11,W
06EBE:  INCF   x11,F
06EC0:  ADDWF  x03,W
06EC2:  MOVWF  FE9
06EC4:  MOVLW  00
06EC6:  ADDWFC x04,W
06EC8:  MOVWF  FEA
06ECA:  MOVFF  FEF,710
06ECE:  MOVF   x10,F
06ED0:  BTFSC  FD8.2
06ED2:  BRA    706A
....................    {
....................       if (skip && !isspace(c))
06ED4:  BTFSS  x0F.0
06ED6:  BRA    6EF6
06ED8:  MOVF   x10,W
06EDA:  SUBLW  20
06EDC:  BZ    6EF6
....................       {
....................          skip = 0;
06EDE:  BCF    x0F.0
....................          if (c == '+')
06EE0:  MOVF   x10,W
06EE2:  SUBLW  2B
06EE4:  BNZ   6EEC
....................          {
....................             sign = 0;
06EE6:  BCF    x0F.1
....................             continue;
06EE8:  BRA    7052
....................          }            
06EEA:  BRA    6EF6
....................          else if (c == '-')
06EEC:  MOVF   x10,W
06EEE:  SUBLW  2D
06EF0:  BNZ   6EF6
....................          {
....................             sign = 1;
06EF2:  BSF    x0F.1
....................             continue;
06EF4:  BRA    7052
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06EF6:  BTFSC  x0F.0
06EF8:  BRA    6F08
06EFA:  MOVF   x10,W
06EFC:  SUBLW  2E
06EFE:  BNZ   6F08
06F00:  BTFSC  x0F.2
06F02:  BRA    6F08
....................          point = 1;
06F04:  BSF    x0F.2
06F06:  BRA    7052
....................       else if (!skip && isdigit(c))
06F08:  BTFSC  x0F.0
06F0A:  BRA    704C
06F0C:  MOVF   x10,W
06F0E:  SUBLW  2F
06F10:  BTFSC  FD8.0
06F12:  BRA    704C
06F14:  MOVF   x10,W
06F16:  SUBLW  39
06F18:  BTFSS  FD8.0
06F1A:  BRA    704C
....................       {
....................          c -= '0';
06F1C:  MOVLW  30
06F1E:  SUBWF  x10,F
....................          if (point)
06F20:  BTFSS  x0F.2
06F22:  BRA    6FD2
....................          {
....................             pow10 = pow10 * 10.0;
06F24:  MOVFF  70A,746
06F28:  MOVFF  709,745
06F2C:  MOVFF  708,744
06F30:  MOVFF  707,743
06F34:  CLRF   x4A
06F36:  CLRF   x49
06F38:  MOVLW  20
06F3A:  MOVWF  x48
06F3C:  MOVLW  82
06F3E:  MOVWF  x47
06F40:  MOVLB  0
06F42:  CALL   0D6C
06F46:  MOVFF  03,70A
06F4A:  MOVFF  02,709
06F4E:  MOVFF  01,708
06F52:  MOVFF  00,707
....................             result += (float)c / pow10;   
06F56:  MOVLB  7
06F58:  CLRF   x48
06F5A:  MOVFF  710,747
06F5E:  MOVLB  0
06F60:  CALL   0D36
06F64:  MOVFF  03,715
06F68:  MOVFF  02,714
06F6C:  MOVFF  01,713
06F70:  MOVFF  00,712
06F74:  MOVFF  03,73F
06F78:  MOVFF  02,73E
06F7C:  MOVFF  01,73D
06F80:  MOVFF  00,73C
06F84:  MOVFF  70A,743
06F88:  MOVFF  709,742
06F8C:  MOVFF  708,741
06F90:  MOVFF  707,740
06F94:  CALL   1D82
06F98:  BCF    FD8.1
06F9A:  MOVFF  70E,74A
06F9E:  MOVFF  70D,749
06FA2:  MOVFF  70C,748
06FA6:  MOVFF  70B,747
06FAA:  MOVFF  03,74E
06FAE:  MOVFF  02,74D
06FB2:  MOVFF  01,74C
06FB6:  MOVFF  00,74B
06FBA:  CALL   0E62
06FBE:  MOVFF  03,70E
06FC2:  MOVFF  02,70D
06FC6:  MOVFF  01,70C
06FCA:  MOVFF  00,70B
....................          }
06FCE:  BRA    7048
06FD0:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06FD2:  CLRF   x46
06FD4:  CLRF   x45
06FD6:  MOVLW  20
06FD8:  MOVWF  x44
06FDA:  MOVLW  82
06FDC:  MOVWF  x43
06FDE:  MOVFF  70E,74A
06FE2:  MOVFF  70D,749
06FE6:  MOVFF  70C,748
06FEA:  MOVFF  70B,747
06FEE:  MOVLB  0
06FF0:  CALL   0D6C
06FF4:  MOVFF  03,715
06FF8:  MOVFF  02,714
06FFC:  MOVFF  01,713
07000:  MOVFF  00,712
07004:  MOVLB  7
07006:  CLRF   x48
07008:  MOVFF  710,747
0700C:  MOVLB  0
0700E:  CALL   0D36
07012:  BCF    FD8.1
07014:  MOVFF  715,74A
07018:  MOVFF  714,749
0701C:  MOVFF  713,748
07020:  MOVFF  712,747
07024:  MOVFF  03,74E
07028:  MOVFF  02,74D
0702C:  MOVFF  01,74C
07030:  MOVFF  00,74B
07034:  CALL   0E62
07038:  MOVFF  03,70E
0703C:  MOVFF  02,70D
07040:  MOVFF  01,70C
07044:  MOVFF  00,70B
....................          }
....................       }
07048:  BRA    7054
0704A:  MOVLB  7
....................       else if (!skip)
0704C:  BTFSC  x0F.0
0704E:  BRA    7052
....................          break;
07050:  BRA    706A
07052:  MOVLB  0
07054:  MOVLB  7
07056:  MOVF   x11,W
07058:  INCF   x11,F
0705A:  ADDWF  x03,W
0705C:  MOVWF  FE9
0705E:  MOVLW  00
07060:  ADDWFC x04,W
07062:  MOVWF  FEA
07064:  MOVFF  FEF,710
07068:  BRA    6ECE
....................    }
.................... 
....................    if (sign)
0706A:  BTFSS  x0F.1
0706C:  BRA    70A2
....................       result = -1*result;
0706E:  CLRF   x46
07070:  CLRF   x45
07072:  MOVLW  80
07074:  MOVWF  x44
07076:  MOVLW  7F
07078:  MOVWF  x43
0707A:  MOVFF  70E,74A
0707E:  MOVFF  70D,749
07082:  MOVFF  70C,748
07086:  MOVFF  70B,747
0708A:  MOVLB  0
0708C:  CALL   0D6C
07090:  MOVFF  03,70E
07094:  MOVFF  02,70D
07098:  MOVFF  01,70C
0709C:  MOVFF  00,70B
070A0:  MOVLB  7
....................       
....................    if(endptr)
070A2:  MOVF   x05,W
070A4:  IORWF  x06,W
070A6:  BZ    70D6
....................    {
....................       if (ptr) {
070A8:  MOVF   x11,F
070AA:  BZ    70C4
....................          ptr--;
070AC:  DECF   x11,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
070AE:  MOVFF  706,FEA
070B2:  MOVFF  705,FE9
070B6:  MOVF   x11,W
070B8:  ADDWF  x03,W
070BA:  MOVWF  FEF
070BC:  MOVLW  00
070BE:  ADDWFC x04,W
070C0:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
070C2:  BRA    70D6
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
070C4:  MOVFF  706,FEA
070C8:  MOVFF  705,FE9
070CC:  MOVFF  704,FEC
070D0:  MOVF   FED,F
070D2:  MOVFF  703,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
070D6:  MOVFF  70B,00
070DA:  MOVFF  70C,01
070DE:  MOVFF  70D,02
070E2:  MOVFF  70E,03
070E6:  MOVLB  0
070E8:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05D6C:  MOVLB  7
05D6E:  CLRF   x34
05D70:  CLRF   x33
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
05D72:  MOVLW  30
05D74:  MOVWF  x36
05D76:  MOVLW  31
05D78:  MOVWF  x37
05D7A:  MOVLW  32
05D7C:  MOVWF  x38
05D7E:  MOVLW  33
05D80:  MOVWF  x39
05D82:  MOVLW  34
05D84:  MOVWF  x3A
05D86:  MOVLW  35
05D88:  MOVWF  x3B
05D8A:  MOVLW  36
05D8C:  MOVWF  x3C
05D8E:  MOVLW  37
05D90:  MOVWF  x3D
05D92:  MOVLW  38
05D94:  MOVWF  x3E
05D96:  MOVLW  39
05D98:  MOVWF  x3F
05D9A:  MOVLW  61
05D9C:  MOVWF  x40
05D9E:  MOVLW  62
05DA0:  MOVWF  x41
05DA2:  MOVLW  63
05DA4:  MOVWF  x42
05DA6:  MOVLW  64
05DA8:  MOVWF  x43
05DAA:  MOVLW  65
05DAC:  MOVWF  x44
05DAE:  MOVLW  66
05DB0:  MOVWF  x45
05DB2:  MOVLW  67
05DB4:  MOVWF  x46
05DB6:  MOVLW  68
05DB8:  MOVWF  x47
05DBA:  MOVLW  69
05DBC:  MOVWF  x48
05DBE:  MOVLW  6A
05DC0:  MOVWF  x49
05DC2:  MOVLW  6B
05DC4:  MOVWF  x4A
05DC6:  MOVLW  6C
05DC8:  MOVWF  x4B
05DCA:  MOVLW  6D
05DCC:  MOVWF  x4C
05DCE:  MOVLW  6E
05DD0:  MOVWF  x4D
05DD2:  MOVLW  6F
05DD4:  MOVWF  x4E
05DD6:  MOVLW  70
05DD8:  MOVWF  x4F
05DDA:  MOVLW  71
05DDC:  MOVWF  x50
05DDE:  MOVLW  73
05DE0:  MOVWF  x51
05DE2:  MOVLW  74
05DE4:  MOVWF  x52
05DE6:  MOVLW  75
05DE8:  MOVWF  x53
05DEA:  MOVLW  76
05DEC:  MOVWF  x54
05DEE:  MOVLW  77
05DF0:  MOVWF  x55
05DF2:  MOVLW  78
05DF4:  MOVWF  x56
05DF6:  MOVLW  79
05DF8:  MOVWF  x57
05DFA:  MOVLW  7A
05DFC:  MOVWF  x58
05DFE:  CLRF   x59
....................    for(sc=s;isspace(*sc);++sc);
05E00:  MOVFF  729,72E
05E04:  MOVFF  728,72D
05E08:  MOVFF  72E,FEA
05E0C:  MOVFF  72D,FE9
05E10:  MOVF   FEF,W
05E12:  SUBLW  20
05E14:  BNZ   5E1E
05E16:  INCF   x2D,F
05E18:  BTFSC  FD8.2
05E1A:  INCF   x2E,F
05E1C:  BRA    5E08
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05E1E:  MOVFF  72E,03
05E22:  MOVFF  72D,FE9
05E26:  MOVFF  03,FEA
05E2A:  MOVF   FEF,W
05E2C:  SUBLW  2D
05E2E:  BZ    5E3E
05E30:  MOVFF  72E,FEA
05E34:  MOVFF  72D,FE9
05E38:  MOVF   FEF,W
05E3A:  SUBLW  2B
05E3C:  BNZ   5E50
05E3E:  MOVFF  72E,FEA
05E42:  MOVF   x2D,W
05E44:  INCF   x2D,F
05E46:  BTFSC  FD8.2
05E48:  INCF   x2E,F
05E4A:  MOVWF  FE9
05E4C:  MOVF   FEF,W
05E4E:  BRA    5E52
05E50:  MOVLW  2B
05E52:  MOVWF  x35
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05E54:  MOVF   x35,W
05E56:  SUBLW  2D
05E58:  BZ    5E6E
05E5A:  BTFSC  x2C.7
05E5C:  BRA    5E6E
05E5E:  DECFSZ x2C,W
05E60:  BRA    5E64
05E62:  BRA    5E6E
05E64:  BTFSC  x2C.7
05E66:  BRA    5E72
05E68:  MOVF   x2C,W
05E6A:  SUBLW  24
05E6C:  BC    5E72
....................    goto StrtoulGO;
05E6E:  BRA    607A
05E70:  BRA    5F6A
.................... 
....................    else if (base)
05E72:  MOVF   x2C,F
05E74:  BZ    5F02
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05E76:  MOVF   x2C,W
05E78:  SUBLW  10
05E7A:  BNZ   5EB6
05E7C:  MOVFF  72E,FEA
05E80:  MOVFF  72D,FE9
05E84:  MOVF   FEF,W
05E86:  SUBLW  30
05E88:  BNZ   5EB6
05E8A:  MOVLW  01
05E8C:  ADDWF  x2D,W
05E8E:  MOVWF  FE9
05E90:  MOVLW  00
05E92:  ADDWFC x2E,W
05E94:  MOVWF  FEA
05E96:  MOVF   FEF,W
05E98:  SUBLW  78
05E9A:  BZ    5EAE
05E9C:  MOVLW  01
05E9E:  ADDWF  x2D,W
05EA0:  MOVWF  FE9
05EA2:  MOVLW  00
05EA4:  ADDWFC x2E,W
05EA6:  MOVWF  FEA
05EA8:  MOVF   FEF,W
05EAA:  SUBLW  58
05EAC:  BNZ   5EB6
....................          sc+=2;
05EAE:  MOVLW  02
05EB0:  ADDWF  x2D,F
05EB2:  MOVLW  00
05EB4:  ADDWFC x2E,F
....................       if(base==8 && *sc =='0')
05EB6:  MOVF   x2C,W
05EB8:  SUBLW  08
05EBA:  BNZ   5ED2
05EBC:  MOVFF  72E,FEA
05EC0:  MOVFF  72D,FE9
05EC4:  MOVF   FEF,W
05EC6:  SUBLW  30
05EC8:  BNZ   5ED2
....................          sc+=1;
05ECA:  MOVLW  01
05ECC:  ADDWF  x2D,F
05ECE:  MOVLW  00
05ED0:  ADDWFC x2E,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05ED2:  MOVF   x2C,W
05ED4:  SUBLW  02
05ED6:  BNZ   5F00
05ED8:  MOVFF  72E,FEA
05EDC:  MOVFF  72D,FE9
05EE0:  MOVF   FEF,W
05EE2:  SUBLW  30
05EE4:  BNZ   5F00
05EE6:  MOVLW  01
05EE8:  ADDWF  x2D,W
05EEA:  MOVWF  FE9
05EEC:  MOVLW  00
05EEE:  ADDWFC x2E,W
05EF0:  MOVWF  FEA
05EF2:  MOVF   FEF,W
05EF4:  SUBLW  62
05EF6:  BNZ   5F00
....................          sc+=2;
05EF8:  MOVLW  02
05EFA:  ADDWF  x2D,F
05EFC:  MOVLW  00
05EFE:  ADDWFC x2E,F
.................... 
....................    }
05F00:  BRA    5F6A
....................    else if(*sc!='0') // base is 0, find base
05F02:  MOVFF  72E,FEA
05F06:  MOVFF  72D,FE9
05F0A:  MOVF   FEF,W
05F0C:  SUBLW  30
05F0E:  BZ    5F16
....................       base=10;
05F10:  MOVLW  0A
05F12:  MOVWF  x2C
05F14:  BRA    5F6A
....................    else if (sc[1]=='x' || sc[1]=='X')
05F16:  MOVLW  01
05F18:  ADDWF  x2D,W
05F1A:  MOVWF  FE9
05F1C:  MOVLW  00
05F1E:  ADDWFC x2E,W
05F20:  MOVWF  FEA
05F22:  MOVF   FEF,W
05F24:  SUBLW  78
05F26:  BZ    5F3A
05F28:  MOVLW  01
05F2A:  ADDWF  x2D,W
05F2C:  MOVWF  FE9
05F2E:  MOVLW  00
05F30:  ADDWFC x2E,W
05F32:  MOVWF  FEA
05F34:  MOVF   FEF,W
05F36:  SUBLW  58
05F38:  BNZ   5F48
....................       base =16,sc+=2;
05F3A:  MOVLW  10
05F3C:  MOVWF  x2C
05F3E:  MOVLW  02
05F40:  ADDWF  x2D,F
05F42:  MOVLW  00
05F44:  ADDWFC x2E,F
05F46:  BRA    5F6A
....................    else if(sc[1]=='b')
05F48:  MOVLW  01
05F4A:  ADDWF  x2D,W
05F4C:  MOVWF  FE9
05F4E:  MOVLW  00
05F50:  ADDWFC x2E,W
05F52:  MOVWF  FEA
05F54:  MOVF   FEF,W
05F56:  SUBLW  62
05F58:  BNZ   5F66
....................       base=2,sc+=2;
05F5A:  MOVLW  02
05F5C:  MOVWF  x2C
05F5E:  ADDWF  x2D,F
05F60:  MOVLW  00
05F62:  ADDWFC x2E,F
05F64:  BRA    5F6A
....................    else
....................       base=8;
05F66:  MOVLW  08
05F68:  MOVWF  x2C
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05F6A:  MOVFF  72E,730
05F6E:  MOVFF  72D,72F
05F72:  MOVFF  72E,FEA
05F76:  MOVFF  72D,FE9
05F7A:  MOVF   FEF,W
05F7C:  SUBLW  30
05F7E:  BNZ   5F88
05F80:  INCF   x2D,F
05F82:  BTFSC  FD8.2
05F84:  INCF   x2E,F
05F86:  BRA    5F72
....................    sd=memchr(digits,tolower(*sc),base);
05F88:  MOVFF  72E,03
05F8C:  MOVFF  72D,FE9
05F90:  MOVFF  03,FEA
05F94:  MOVFF  FEF,75A
05F98:  MOVF   x5A,W
05F9A:  SUBLW  40
05F9C:  BC    5FAA
05F9E:  MOVF   x5A,W
05FA0:  SUBLW  5A
05FA2:  BNC   5FAA
05FA4:  MOVF   x5A,W
05FA6:  IORLW  20
05FA8:  BRA    5FAC
05FAA:  MOVF   x5A,W
05FAC:  MOVWF  x5A
05FAE:  MOVLW  07
05FB0:  MOVWF  x5C
05FB2:  MOVLW  36
05FB4:  MOVWF  x5B
05FB6:  MOVFF  75A,75D
05FBA:  CLRF   x5F
05FBC:  MOVFF  72C,75E
05FC0:  BTFSC  x5E.7
05FC2:  DECF   x5F,F
05FC4:  MOVLB  0
05FC6:  RCALL  5CCC
05FC8:  MOVFF  02,732
05FCC:  MOVFF  01,731
....................    for(; sd!=0; )
05FD0:  MOVLB  7
05FD2:  MOVF   x31,F
05FD4:  BNZ   5FDA
05FD6:  MOVF   x32,F
05FD8:  BZ    606E
....................    {
....................       x=x*base+(int16)(sd-digits);
05FDA:  CLRF   03
05FDC:  MOVF   x2C,W
05FDE:  MOVWF  00
05FE0:  BTFSC  FE8.7
05FE2:  DECF   03,F
05FE4:  MOVWF  x5A
05FE6:  MOVFF  03,75B
05FEA:  MOVFF  734,75D
05FEE:  MOVFF  733,75C
05FF2:  MOVFF  03,75F
05FF6:  MOVWF  x5E
05FF8:  MOVLB  0
05FFA:  BRA    5D16
05FFC:  MOVFF  01,75A
06000:  MOVLW  36
06002:  MOVLB  7
06004:  SUBWF  x31,W
06006:  MOVWF  00
06008:  MOVLW  07
0600A:  SUBWFB x32,W
0600C:  MOVWF  03
0600E:  MOVF   00,W
06010:  ADDWF  01,W
06012:  MOVWF  01
06014:  MOVF   02,W
06016:  ADDWFC 03,F
06018:  MOVFF  01,733
0601C:  MOVFF  03,734
....................       ++sc;
06020:  INCF   x2D,F
06022:  BTFSC  FD8.2
06024:  INCF   x2E,F
....................       sd=memchr(digits,tolower(*sc),base);
06026:  MOVFF  72E,FEA
0602A:  MOVFF  72D,FE9
0602E:  MOVFF  FEF,75A
06032:  MOVF   x5A,W
06034:  SUBLW  40
06036:  BC    6044
06038:  MOVF   x5A,W
0603A:  SUBLW  5A
0603C:  BNC   6044
0603E:  MOVF   x5A,W
06040:  IORLW  20
06042:  BRA    6046
06044:  MOVF   x5A,W
06046:  MOVWF  x5A
06048:  MOVLW  07
0604A:  MOVWF  x5C
0604C:  MOVLW  36
0604E:  MOVWF  x5B
06050:  MOVFF  75A,75D
06054:  CLRF   x5F
06056:  MOVFF  72C,75E
0605A:  BTFSC  x5E.7
0605C:  DECF   x5F,F
0605E:  MOVLB  0
06060:  RCALL  5CCC
06062:  MOVFF  02,732
06066:  MOVFF  01,731
0606A:  BRA    5FD0
0606C:  MOVLB  7
....................    }
....................    if(s1==sc)
0606E:  MOVF   x2D,W
06070:  SUBWF  x2F,W
06072:  BNZ   609C
06074:  MOVF   x2E,W
06076:  SUBWF  x30,W
06078:  BNZ   609C
....................    {
....................    StrtoulGO:
....................       if (endptr)
0607A:  MOVLB  7
0607C:  MOVF   x2A,W
0607E:  IORWF  x2B,W
06080:  BZ    6094
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
06082:  MOVFF  72B,FEA
06086:  MOVFF  72A,FE9
0608A:  MOVFF  729,FEC
0608E:  MOVF   FED,F
06090:  MOVFF  728,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
06094:  MOVLW  00
06096:  MOVWF  01
06098:  MOVWF  02
0609A:  BRA    60BC
....................    }
....................    if (endptr)
0609C:  MOVF   x2A,W
0609E:  IORWF  x2B,W
060A0:  BZ    60B4
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
060A2:  MOVFF  72B,FEA
060A6:  MOVFF  72A,FE9
060AA:  MOVFF  72E,FEC
060AE:  MOVF   FED,F
060B0:  MOVFF  72D,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
060B4:  MOVFF  733,01
060B8:  MOVFF  734,02
060BC:  MOVLB  0
060BE:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00464:  MOVLB  6
00466:  CLRF   xF4
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00468:  CLRF   xF4
0046A:  MOVF   xF3,W
0046C:  SUBWF  xF4,W
0046E:  BC    04C6
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00470:  MOVF   xF4,W
00472:  ADDWF  xF1,W
00474:  MOVWF  xF5
00476:  MOVLW  00
00478:  ADDWFC xF2,W
0047A:  MOVWF  xF6
0047C:  MOVF   xF4,W
0047E:  ADDWF  xEF,W
00480:  MOVWF  01
00482:  MOVLW  00
00484:  ADDWFC xF0,W
00486:  MOVWF  03
00488:  MOVF   01,W
0048A:  MOVWF  FE9
0048C:  MOVFF  03,FEA
00490:  MOVFF  FEF,6F7
00494:  BSF    F7F.7
00496:  MOVF   FF2,W
00498:  MOVWF  00
0049A:  BCF    FF2.7
0049C:  MOVFF  6F6,F7A
004A0:  MOVFF  6F5,F79
004A4:  MOVLW  31
004A6:  MOVWF  F7B
004A8:  MOVFF  6F7,F7C
004AC:  MOVLB  F
004AE:  MOVLW  55
004B0:  MOVWF  F81
004B2:  MOVLW  AA
004B4:  MOVWF  F81
004B6:  BSF    F80.4
004B8:  BTFSC  F80.4
004BA:  BRA    04B8
004BC:  MOVF   00,W
004BE:  IORWF  FF2,F
004C0:  MOVLB  6
004C2:  INCF   xF4,F
004C4:  BRA    046A
....................    }
004C6:  MOVLB  0
004C8:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00412:  MOVLB  6
00414:  CLRF   xF4
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00416:  CLRF   xF4
00418:  MOVF   xF3,W
0041A:  SUBWF  xF4,W
0041C:  BC    0460
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
0041E:  MOVF   xF4,W
00420:  ADDWF  xEF,W
00422:  MOVWF  01
00424:  MOVLW  00
00426:  ADDWFC xF0,W
00428:  MOVWF  03
0042A:  MOVF   01,W
0042C:  MOVWF  FE9
0042E:  MOVFF  03,FEA
00432:  MOVF   xF4,W
00434:  ADDWF  xF1,W
00436:  MOVWF  xF7
00438:  MOVLW  00
0043A:  ADDWFC xF2,W
0043C:  MOVWF  xF8
0043E:  BSF    F7F.7
00440:  MOVFF  FF2,6F9
00444:  BCF    FF2.7
00446:  MOVFF  6F8,F7A
0044A:  MOVFF  6F7,F79
0044E:  MOVLW  31
00450:  MOVWF  F7B
00452:  BSF    F80.0
00454:  MOVF   F7C,W
00456:  BTFSC  xF9.7
00458:  BSF    FF2.7
0045A:  MOVWF  FEF
0045C:  INCF   xF4,F
0045E:  BRA    0418
....................    }
00460:  MOVLB  0
00462:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004CA:  MOVLB  6
004CC:  CLRF   xF0
004CE:  MOVLW  20
004D0:  MOVWF  xEF
004D2:  CLRF   xF2
004D4:  CLRF   xF1
004D6:  MOVLW  80
004D8:  MOVWF  xF3
004DA:  MOVLB  0
004DC:  RCALL  0464
....................    delay_ms(1);
004DE:  MOVLW  01
004E0:  MOVLB  6
004E2:  MOVWF  xF5
004E4:  MOVLB  0
004E6:  RCALL  03A4
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004E8:  MOVLB  6
004EA:  CLRF   xF0
004EC:  MOVLW  60
004EE:  MOVWF  xEF
004F0:  CLRF   xF2
004F2:  MOVLW  80
004F4:  MOVWF  xF1
004F6:  MOVLW  02
004F8:  MOVWF  xF3
004FA:  MOVLB  0
004FC:  RCALL  0464
....................    delay_ms(1);
004FE:  MOVLW  01
00500:  MOVLB  6
00502:  MOVWF  xF5
00504:  MOVLB  0
00506:  RCALL  03A4
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00508:  MOVLB  6
0050A:  CLRF   xF0
0050C:  MOVLW  61
0050E:  MOVWF  xEF
00510:  CLRF   xF2
00512:  MOVLW  90
00514:  MOVWF  xF1
00516:  MOVLW  02
00518:  MOVWF  xF3
0051A:  MOVLB  0
0051C:  RCALL  0464
....................    delay_ms(1);
0051E:  MOVLW  01
00520:  MOVLB  6
00522:  MOVWF  xF5
00524:  MOVLB  0
00526:  RCALL  03A4
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00528:  MOVLB  6
0052A:  CLRF   xF0
0052C:  MOVLW  62
0052E:  MOVWF  xEF
00530:  CLRF   xF2
00532:  MOVLW  A0
00534:  MOVWF  xF1
00536:  MOVLW  20
00538:  MOVWF  xF3
0053A:  MOVLB  0
0053C:  RCALL  0464
....................    delay_ms(1);
0053E:  MOVLW  01
00540:  MOVLB  6
00542:  MOVWF  xF5
00544:  MOVLB  0
00546:  RCALL  03A4
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00548:  MOVLB  6
0054A:  CLRF   xF0
0054C:  MOVLW  82
0054E:  MOVWF  xEF
00550:  CLRF   xF2
00552:  MOVLW  C0
00554:  MOVWF  xF1
00556:  MOVLW  30
00558:  MOVWF  xF3
0055A:  MOVLB  0
0055C:  RCALL  0464
....................    delay_ms(1);
0055E:  MOVLW  01
00560:  MOVLB  6
00562:  MOVWF  xF5
00564:  MOVLB  0
00566:  RCALL  03A4
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00568:  MOVLB  6
0056A:  CLRF   xF0
0056C:  MOVLW  B2
0056E:  MOVWF  xEF
00570:  CLRF   xF2
00572:  MOVLW  F0
00574:  MOVWF  xF1
00576:  MOVLW  38
00578:  MOVWF  xF3
0057A:  MOVLB  0
0057C:  RCALL  0464
....................    delay_ms(1);
0057E:  MOVLW  01
00580:  MOVLB  6
00582:  MOVWF  xF5
00584:  MOVLB  0
00586:  RCALL  03A4
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00588:  MOVLB  6
0058A:  CLRF   xF0
0058C:  MOVLW  EA
0058E:  MOVWF  xEF
00590:  MOVLW  01
00592:  MOVWF  xF2
00594:  MOVLW  40
00596:  MOVWF  xF1
00598:  MOVLW  01
0059A:  MOVWF  xF3
0059C:  MOVLB  0
0059E:  RCALL  0464
....................    delay_ms(1);
005A0:  MOVLW  01
005A2:  MOVLB  6
005A4:  MOVWF  xF5
005A6:  MOVLB  0
005A8:  RCALL  03A4
005AA:  GOTO   067A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005AE:  MOVLB  6
005B0:  CLRF   xF0
005B2:  MOVLW  20
005B4:  MOVWF  xEF
005B6:  CLRF   xF2
005B8:  CLRF   xF1
005BA:  MOVLW  80
005BC:  MOVWF  xF3
005BE:  MOVLB  0
005C0:  RCALL  0412
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005C2:  MOVLB  6
005C4:  CLRF   xF0
005C6:  MOVLW  60
005C8:  MOVWF  xEF
005CA:  CLRF   xF2
005CC:  MOVLW  80
005CE:  MOVWF  xF1
005D0:  MOVLW  02
005D2:  MOVWF  xF3
005D4:  MOVLB  0
005D6:  RCALL  0412
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005D8:  MOVLB  6
005DA:  CLRF   xF0
005DC:  MOVLW  61
005DE:  MOVWF  xEF
005E0:  CLRF   xF2
005E2:  MOVLW  90
005E4:  MOVWF  xF1
005E6:  MOVLW  02
005E8:  MOVWF  xF3
005EA:  MOVLB  0
005EC:  RCALL  0412
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005EE:  MOVLB  6
005F0:  CLRF   xF0
005F2:  MOVLW  62
005F4:  MOVWF  xEF
005F6:  CLRF   xF2
005F8:  MOVLW  A0
005FA:  MOVWF  xF1
005FC:  MOVLW  20
005FE:  MOVWF  xF3
00600:  MOVLB  0
00602:  RCALL  0412
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00604:  MOVLB  6
00606:  CLRF   xF0
00608:  MOVLW  82
0060A:  MOVWF  xEF
0060C:  CLRF   xF2
0060E:  MOVLW  C0
00610:  MOVWF  xF1
00612:  MOVLW  30
00614:  MOVWF  xF3
00616:  MOVLB  0
00618:  RCALL  0412
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0061A:  MOVLB  6
0061C:  CLRF   xF0
0061E:  MOVLW  B2
00620:  MOVWF  xEF
00622:  CLRF   xF2
00624:  MOVLW  F0
00626:  MOVWF  xF1
00628:  MOVLW  38
0062A:  MOVWF  xF3
0062C:  MOVLB  0
0062E:  RCALL  0412
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00630:  MOVLB  6
00632:  CLRF   xF0
00634:  MOVLW  EA
00636:  MOVWF  xEF
00638:  MOVLW  01
0063A:  MOVWF  xF2
0063C:  MOVLW  40
0063E:  MOVWF  xF1
00640:  MOVLW  01
00642:  MOVWF  xF3
00644:  MOVLB  0
00646:  RCALL  0412
00648:  GOTO   067E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0064C:  MOVLB  6
0064E:  CLRF   xF0
00650:  MOVLW  EA
00652:  MOVWF  xEF
00654:  MOVLW  01
00656:  MOVWF  xF2
00658:  MOVLW  40
0065A:  MOVWF  xF1
0065C:  MOVLW  01
0065E:  MOVWF  xF3
00660:  MOVLB  0
00662:  RCALL  0412
....................    delay_ms(1);
00664:  MOVLW  01
00666:  MOVLB  6
00668:  MOVWF  xF5
0066A:  MOVLB  0
0066C:  RCALL  03A4
....................    if (paramsValid != isValid)
0066E:  MOVF   xEA,W
00670:  SUBLW  AA
00672:  BZ    067C
....................    {
....................       paramsValid = isValid;
00674:  MOVLW  AA
00676:  MOVWF  xEA
....................       params_save_to_ee(); // saves the base parameters on first boot
00678:  BRA    04CA
....................    }
0067A:  BRA    067E
....................    else
....................    {
....................       params_load_from_ee();
0067C:  BRA    05AE
....................    }
0067E:  GOTO   A75C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  C4
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00682:  RCALL  0138
....................    switch(ch)
00684:  MOVLB  7
00686:  MOVF   x00,W
00688:  ADDLW  FC
0068A:  BC    06BE
0068C:  ADDLW  04
0068E:  MOVLB  0
00690:  GOTO   06CA
....................    {
....................       case 0:
....................          output_low(_CS0);
00694:  MOVLW  1F
00696:  MOVWF  F8A
00698:  BCF    F85.5
....................       break; 
0069A:  MOVLB  7
0069C:  BRA    06BE
....................       case 1:
....................          output_low(_CS1);
0069E:  MOVLW  1F
006A0:  MOVWF  F8A
006A2:  BCF    F85.6
....................       break;   
006A4:  MOVLB  7
006A6:  BRA    06BE
....................       case 2:
....................          output_low(_CS2);
006A8:  MOVLW  1F
006AA:  MOVWF  F8A
006AC:  BCF    F85.7
....................       break;
006AE:  MOVLB  7
006B0:  BRA    06BE
....................       case 3:
....................          output_low(_CS3);
006B2:  MOVLW  C4
006B4:  MOVWF  F88
006B6:  BCF    F83.0
....................       break;              
006B8:  MOVLB  7
006BA:  BRA    06BE
006BC:  MOVLB  7
....................    }
....................    delay_us(10);
006BE:  MOVLW  35
006C0:  MOVWF  00
006C2:  DECFSZ 00,F
006C4:  BRA    06C2
006C6:  MOVLB  0
006C8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  7
0015A:  MOVF   x67,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  C4
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007B6:  MOVLW  1F
007B8:  MOVWF  F8A
007BA:  BCF    F85.5
....................    output_low(_CS1);
007BC:  MOVWF  F8A
007BE:  BCF    F85.6
....................    output_low(_CS2);
007C0:  MOVWF  F8A
007C2:  BCF    F85.7
....................    output_low(_CS3);
007C4:  MOVLW  C4
007C6:  MOVWF  F88
007C8:  BCF    F83.0
....................    delay_us(10);
007CA:  MOVLW  35
007CC:  MOVWF  00
007CE:  DECFSZ 00,F
007D0:  BRA    07CE
007D2:  GOTO   07D8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006EC:  MOVFF  6FE,700
006F0:  RCALL  0682
....................    spi_write2(command);
006F2:  MOVLB  E
006F4:  MOVF   x8D,W
006F6:  MOVFF  6FF,E8D
006FA:  RRCF   x90,W
006FC:  BNC   06FA
006FE:  MOVLB  0
00700:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  765,767
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  766,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007D6:  BRA    07B6
....................    spi_write2(command);
007D8:  MOVLB  E
007DA:  MOVF   x8D,W
007DC:  MOVFF  6F5,E8D
007E0:  RRCF   x90,W
007E2:  BNC   07E0
007E4:  MOVLB  0
007E6:  GOTO   07F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00802:  MOVFF  6FD,700
00806:  RCALL  0682
....................    spi_read2(command);
00808:  MOVLB  E
0080A:  MOVF   x8D,W
0080C:  MOVFF  6FE,E8D
00810:  RRCF   x90,W
00812:  BNC   0810
00814:  MOVLB  0
00816:  GOTO   0828 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00726:  MOVLB  6
00728:  MOVF   xFB,W
0072A:  IORLW  40
0072C:  MOVWF  xFD
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0072E:  MOVFF  6FA,6FE
00732:  MOVFF  6FD,6FF
00736:  MOVLB  0
00738:  RCALL  06EC
....................    spi_write2(data);
0073A:  MOVLB  E
0073C:  MOVF   x8D,W
0073E:  MOVFF  6FC,E8D
00742:  RRCF   x90,W
00744:  BNC   0742
....................    ads_deselect_all();
00746:  MOVLB  0
00748:  RCALL  0138
0074A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  764,765
001A8:  MOVLW  08
001AA:  MOVLB  7
001AC:  MOVWF  x66
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007EA:  MOVLW  08
007EC:  MOVLB  6
007EE:  MOVWF  xF5
007F0:  MOVLB  0
007F2:  BRA    07D6
....................    delay_us(10);
007F4:  MOVLW  35
007F6:  MOVWF  00
007F8:  DECFSZ 00,F
007FA:  BRA    07F8
....................    ads_deselect_all();
007FC:  RCALL  0138
007FE:  GOTO   0984 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
0081A:  MOVFF  6F8,6FD
0081E:  MOVLW  10
00820:  MOVLB  6
00822:  MOVWF  xFE
00824:  MOVLB  0
00826:  BRA    0802
....................    data.dBytes[3] = 0;
00828:  MOVLB  6
0082A:  CLRF   xFC
....................    data.dBytes[2] = spi_read2(0);
0082C:  MOVLB  E
0082E:  MOVF   x8D,W
00830:  CLRF   x8D
00832:  RRCF   x90,W
00834:  BNC   0832
00836:  MOVFF  E8D,6FB
....................    data.dBytes[1] = spi_read2(0);
0083A:  MOVF   x8D,W
0083C:  CLRF   x8D
0083E:  RRCF   x90,W
00840:  BNC   083E
00842:  MOVFF  E8D,6FA
....................    data.dBytes[0] = spi_read2(0);
00846:  MOVF   x8D,W
00848:  CLRF   x8D
0084A:  RRCF   x90,W
0084C:  BNC   084A
0084E:  MOVFF  E8D,6F9
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00852:  MOVLB  6
00854:  MOVF   xFB,W
00856:  ANDLW  80
00858:  BZ    085E
0085A:  MOVLW  FF
0085C:  IORWF  xFC,F
....................    
....................    ads_deselect_all();
0085E:  MOVLB  0
00860:  RCALL  0138
....................    return data.dWord;
00862:  MOVFF  6F9,00
00866:  MOVFF  6FA,01
0086A:  MOVFF  6FB,02
0086E:  MOVFF  6FC,03
00872:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
0074C:  MOVFF  6F5,6FE
00750:  MOVLW  06
00752:  MOVLB  6
00754:  MOVWF  xFF
00756:  MOVLB  0
00758:  RCALL  06EC
....................    delay_us(300);                    
0075A:  MOVLW  02
0075C:  MOVLB  6
0075E:  MOVWF  xFA
00760:  MOVLW  96
00762:  MOVWF  xFB
00764:  MOVLB  0
00766:  RCALL  0702
00768:  MOVLB  6
0076A:  DECFSZ xFA,F
0076C:  BRA    0760
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0076E:  MOVFF  6F5,6FA
00772:  CLRF   xFB
00774:  MOVFF  6F6,6FC
00778:  MOVLB  0
0077A:  RCALL  0726
....................    ads_write_reg(ch, reg1, rc1);
0077C:  MOVFF  6F5,6FA
00780:  MOVLW  04
00782:  MOVLB  6
00784:  MOVWF  xFB
00786:  MOVFF  6F7,6FC
0078A:  MOVLB  0
0078C:  RCALL  0726
....................    ads_write_reg(ch, reg2, rc2);
0078E:  MOVFF  6F5,6FA
00792:  MOVLW  08
00794:  MOVLB  6
00796:  MOVWF  xFB
00798:  MOVFF  6F8,6FC
0079C:  MOVLB  0
0079E:  RCALL  0726
....................    ads_write_reg(ch, reg3, rc3);  
007A0:  MOVFF  6F5,6FA
007A4:  MOVLW  0C
007A6:  MOVLB  6
007A8:  MOVWF  xFB
007AA:  MOVFF  6F9,6FC
007AE:  MOVLB  0
007B0:  RCALL  0726
007B2:  GOTO   095E (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02738:  MOVLB  7
0273A:  BCF    x42.0
....................    y = x;
0273C:  MOVFF  736,73B
02740:  MOVFF  735,73A
02744:  MOVFF  734,739
02748:  MOVFF  733,738
.................... 
....................    if (x < 0)
0274C:  MOVFF  736,746
02750:  MOVFF  735,745
02754:  MOVFF  734,744
02758:  MOVFF  733,743
0275C:  CLRF   x4A
0275E:  CLRF   x49
02760:  CLRF   x48
02762:  CLRF   x47
02764:  MOVLB  0
02766:  CALL   1D08
0276A:  BNC   2778
....................    {
....................       s = 1;
0276C:  MOVLB  7
0276E:  BSF    x42.0
....................       y = -y;
02770:  MOVF   x39,W
02772:  XORLW  80
02774:  MOVWF  x39
02776:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02778:  MOVFF  73B,746
0277C:  MOVFF  73A,745
02780:  MOVFF  739,744
02784:  MOVFF  738,743
02788:  MOVLB  7
0278A:  CLRF   x4A
0278C:  CLRF   x49
0278E:  CLRF   x48
02790:  MOVLW  8E
02792:  MOVWF  x47
02794:  MOVLB  0
02796:  CALL   1D08
0279A:  BC    279E
0279C:  BNZ   27CE
....................       res = (float32)(unsigned int16)y;
0279E:  MOVFF  73B,746
027A2:  MOVFF  73A,745
027A6:  MOVFF  739,744
027AA:  MOVFF  738,743
027AE:  RCALL  26FC
027B0:  MOVFF  02,748
027B4:  MOVFF  01,747
027B8:  CALL   0D36
027BC:  MOVFF  03,73F
027C0:  MOVFF  02,73E
027C4:  MOVFF  01,73D
027C8:  MOVFF  00,73C
027CC:  BRA    2970
.................... 
....................  else if (y < 10000000.0)
027CE:  MOVFF  73B,746
027D2:  MOVFF  73A,745
027D6:  MOVFF  739,744
027DA:  MOVFF  738,743
027DE:  MOVLW  80
027E0:  MOVLB  7
027E2:  MOVWF  x4A
027E4:  MOVLW  96
027E6:  MOVWF  x49
027E8:  MOVLW  18
027EA:  MOVWF  x48
027EC:  MOVLW  96
027EE:  MOVWF  x47
027F0:  MOVLB  0
027F2:  CALL   1D08
027F6:  BTFSS  FD8.0
027F8:  BRA    2960
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
027FA:  MOVFF  73B,746
027FE:  MOVFF  73A,745
02802:  MOVFF  739,744
02806:  MOVFF  738,743
0280A:  MOVLB  7
0280C:  CLRF   x4A
0280E:  CLRF   x49
02810:  CLRF   x48
02812:  MOVLW  70
02814:  MOVWF  x47
02816:  MOVLB  0
02818:  CALL   0D6C
0281C:  MOVFF  03,746
02820:  MOVFF  02,745
02824:  MOVFF  01,744
02828:  MOVFF  00,743
0282C:  RCALL  26FC
0282E:  MOVFF  02,741
02832:  MOVFF  01,740
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02836:  MOVFF  73B,746
0283A:  MOVFF  73A,745
0283E:  MOVFF  739,744
02842:  MOVFF  738,743
02846:  MOVLB  7
02848:  CLRF   x4A
0284A:  CLRF   x49
0284C:  CLRF   x48
0284E:  MOVLW  70
02850:  MOVWF  x47
02852:  MOVLB  0
02854:  CALL   0D6C
02858:  MOVFF  03,746
0285C:  MOVFF  02,745
02860:  MOVFF  01,744
02864:  MOVFF  00,743
02868:  MOVFF  741,748
0286C:  MOVFF  740,747
02870:  CALL   0D36
02874:  BSF    FD8.1
02876:  MOVFF  746,74A
0287A:  MOVFF  745,749
0287E:  MOVFF  744,748
02882:  MOVFF  743,747
02886:  MOVFF  03,74E
0288A:  MOVFF  02,74D
0288E:  MOVFF  01,74C
02892:  MOVFF  00,74B
02896:  CALL   0E62
0289A:  MOVLB  7
0289C:  CLRF   x46
0289E:  CLRF   x45
028A0:  CLRF   x44
028A2:  MOVLW  8E
028A4:  MOVWF  x43
028A6:  MOVFF  03,74A
028AA:  MOVFF  02,749
028AE:  MOVFF  01,748
028B2:  MOVFF  00,747
028B6:  MOVLB  0
028B8:  CALL   0D6C
028BC:  MOVFF  03,73B
028C0:  MOVFF  02,73A
028C4:  MOVFF  01,739
028C8:  MOVFF  00,738
....................       res = 32768.0*(float32)l;
028CC:  MOVFF  741,748
028D0:  MOVFF  740,747
028D4:  CALL   0D36
028D8:  MOVLB  7
028DA:  CLRF   x46
028DC:  CLRF   x45
028DE:  CLRF   x44
028E0:  MOVLW  8E
028E2:  MOVWF  x43
028E4:  MOVFF  03,74A
028E8:  MOVFF  02,749
028EC:  MOVFF  01,748
028F0:  MOVFF  00,747
028F4:  MOVLB  0
028F6:  CALL   0D6C
028FA:  MOVFF  03,73F
028FE:  MOVFF  02,73E
02902:  MOVFF  01,73D
02906:  MOVFF  00,73C
....................       res += (float32)(unsigned int16)y;
0290A:  MOVFF  73B,746
0290E:  MOVFF  73A,745
02912:  MOVFF  739,744
02916:  MOVFF  738,743
0291A:  RCALL  26FC
0291C:  MOVFF  02,748
02920:  MOVFF  01,747
02924:  CALL   0D36
02928:  BCF    FD8.1
0292A:  MOVFF  73F,74A
0292E:  MOVFF  73E,749
02932:  MOVFF  73D,748
02936:  MOVFF  73C,747
0293A:  MOVFF  03,74E
0293E:  MOVFF  02,74D
02942:  MOVFF  01,74C
02946:  MOVFF  00,74B
0294A:  CALL   0E62
0294E:  MOVFF  03,73F
02952:  MOVFF  02,73E
02956:  MOVFF  01,73D
0295A:  MOVFF  00,73C
....................    }
0295E:  BRA    2970
.................... 
....................  else
....................   res = y;
02960:  MOVFF  73B,73F
02964:  MOVFF  73A,73E
02968:  MOVFF  739,73D
0296C:  MOVFF  738,73C
.................... 
....................  y = y - (float32)(unsigned int16)y;
02970:  MOVFF  73B,746
02974:  MOVFF  73A,745
02978:  MOVFF  739,744
0297C:  MOVFF  738,743
02980:  RCALL  26FC
02982:  MOVFF  02,748
02986:  MOVFF  01,747
0298A:  CALL   0D36
0298E:  BSF    FD8.1
02990:  MOVFF  73B,74A
02994:  MOVFF  73A,749
02998:  MOVFF  739,748
0299C:  MOVFF  738,747
029A0:  MOVFF  03,74E
029A4:  MOVFF  02,74D
029A8:  MOVFF  01,74C
029AC:  MOVFF  00,74B
029B0:  CALL   0E62
029B4:  MOVFF  03,73B
029B8:  MOVFF  02,73A
029BC:  MOVFF  01,739
029C0:  MOVFF  00,738
.................... 
....................  if (s)
029C4:  MOVLB  7
029C6:  BTFSS  x42.0
029C8:  BRA    29D0
....................   res = -res;
029CA:  MOVF   x3D,W
029CC:  XORLW  80
029CE:  MOVWF  x3D
.................... 
....................  if (y != 0)
029D0:  MOVFF  73B,746
029D4:  MOVFF  73A,745
029D8:  MOVFF  739,744
029DC:  MOVFF  738,743
029E0:  CLRF   x4A
029E2:  CLRF   x49
029E4:  CLRF   x48
029E6:  CLRF   x47
029E8:  MOVLB  0
029EA:  CALL   1D08
029EE:  BZ    2A68
....................  {
....................   if (s == 1 && n == 0)
029F0:  MOVLB  7
029F2:  BTFSS  x42.0
029F4:  BRA    2A2E
029F6:  MOVF   x37,F
029F8:  BNZ   2A2E
....................    res -= 1.0;
029FA:  BSF    FD8.1
029FC:  MOVFF  73F,74A
02A00:  MOVFF  73E,749
02A04:  MOVFF  73D,748
02A08:  MOVFF  73C,747
02A0C:  CLRF   x4E
02A0E:  CLRF   x4D
02A10:  CLRF   x4C
02A12:  MOVLW  7F
02A14:  MOVWF  x4B
02A16:  MOVLB  0
02A18:  CALL   0E62
02A1C:  MOVFF  03,73F
02A20:  MOVFF  02,73E
02A24:  MOVFF  01,73D
02A28:  MOVFF  00,73C
02A2C:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A2E:  BTFSC  x42.0
02A30:  BRA    2A6A
02A32:  DECFSZ x37,W
02A34:  BRA    2A6A
....................    res += 1.0;
02A36:  BCF    FD8.1
02A38:  MOVFF  73F,74A
02A3C:  MOVFF  73E,749
02A40:  MOVFF  73D,748
02A44:  MOVFF  73C,747
02A48:  CLRF   x4E
02A4A:  CLRF   x4D
02A4C:  CLRF   x4C
02A4E:  MOVLW  7F
02A50:  MOVWF  x4B
02A52:  MOVLB  0
02A54:  CALL   0E62
02A58:  MOVFF  03,73F
02A5C:  MOVFF  02,73E
02A60:  MOVFF  01,73D
02A64:  MOVFF  00,73C
02A68:  MOVLB  7
....................  }
....................  if (x == 0)
02A6A:  MOVFF  736,746
02A6E:  MOVFF  735,745
02A72:  MOVFF  734,744
02A76:  MOVFF  733,743
02A7A:  CLRF   x4A
02A7C:  CLRF   x49
02A7E:  CLRF   x48
02A80:  CLRF   x47
02A82:  MOVLB  0
02A84:  CALL   1D08
02A88:  BNZ   2A96
....................     res = 0;
02A8A:  MOVLB  7
02A8C:  CLRF   x3F
02A8E:  CLRF   x3E
02A90:  CLRF   x3D
02A92:  CLRF   x3C
02A94:  MOVLB  0
.................... 
....................  return (res);
02A96:  MOVFF  73C,00
02A9A:  MOVFF  73D,01
02A9E:  MOVFF  73E,02
02AA2:  MOVFF  73F,03
02AA6:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AC6:  MOVFF  732,736
02ACA:  MOVFF  731,735
02ACE:  MOVFF  730,734
02AD2:  MOVFF  72F,733
02AD6:  MOVLB  7
02AD8:  CLRF   x37
02ADA:  MOVLB  0
02ADC:  RCALL  2738
02ADE:  GOTO   2BEA (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02AA8:  MOVFF  732,736
02AAC:  MOVFF  731,735
02AB0:  MOVFF  730,734
02AB4:  MOVFF  72F,733
02AB8:  MOVLW  01
02ABA:  MOVLB  7
02ABC:  MOVWF  x37
02ABE:  MOVLB  0
02AC0:  RCALL  2738
02AC2:  GOTO   2BA2 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AE2:  MOVFF  726,746
02AE6:  MOVFF  725,745
02AEA:  MOVFF  724,744
02AEE:  MOVFF  723,743
02AF2:  MOVLB  7
02AF4:  CLRF   x4A
02AF6:  CLRF   x49
02AF8:  CLRF   x48
02AFA:  CLRF   x47
02AFC:  MOVLB  0
02AFE:  CALL   1D08
02B02:  BTFSC  FD8.2
02B04:  BRA    2C46
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02B06:  MOVFF  722,73F
02B0A:  MOVFF  721,73E
02B0E:  MOVFF  720,73D
02B12:  MOVFF  71F,73C
02B16:  MOVFF  726,743
02B1A:  MOVFF  725,742
02B1E:  MOVFF  724,741
02B22:  MOVFF  723,740
02B26:  CALL   1D82
02B2A:  MOVFF  03,72E
02B2E:  MOVFF  02,72D
02B32:  MOVFF  01,72C
02B36:  MOVFF  00,72B
02B3A:  MOVFF  03,746
02B3E:  MOVFF  02,745
02B42:  MOVFF  01,744
02B46:  MOVFF  00,743
02B4A:  MOVLB  7
02B4C:  CLRF   x4A
02B4E:  CLRF   x49
02B50:  CLRF   x48
02B52:  CLRF   x47
02B54:  MOVLB  0
02B56:  CALL   1D08
02B5A:  BNC   2BA4
02B5C:  MOVFF  722,73F
02B60:  MOVFF  721,73E
02B64:  MOVFF  720,73D
02B68:  MOVFF  71F,73C
02B6C:  MOVFF  726,743
02B70:  MOVFF  725,742
02B74:  MOVFF  724,741
02B78:  MOVFF  723,740
02B7C:  CALL   1D82
02B80:  MOVFF  03,72E
02B84:  MOVFF  02,72D
02B88:  MOVFF  01,72C
02B8C:  MOVFF  00,72B
02B90:  MOVFF  03,732
02B94:  MOVFF  02,731
02B98:  MOVFF  01,730
02B9C:  MOVFF  00,72F
02BA0:  BRA    2AA8
02BA2:  BRA    2BEA
02BA4:  MOVFF  722,73F
02BA8:  MOVFF  721,73E
02BAC:  MOVFF  720,73D
02BB0:  MOVFF  71F,73C
02BB4:  MOVFF  726,743
02BB8:  MOVFF  725,742
02BBC:  MOVFF  724,741
02BC0:  MOVFF  723,740
02BC4:  CALL   1D82
02BC8:  MOVFF  03,72E
02BCC:  MOVFF  02,72D
02BD0:  MOVFF  01,72C
02BD4:  MOVFF  00,72B
02BD8:  MOVFF  03,732
02BDC:  MOVFF  02,731
02BE0:  MOVFF  01,730
02BE4:  MOVFF  00,72F
02BE8:  BRA    2AC6
02BEA:  MOVFF  03,72A
02BEE:  MOVFF  02,729
02BF2:  MOVFF  01,728
02BF6:  MOVFF  00,727
....................       return(x-(i*y));
02BFA:  MOVFF  72A,746
02BFE:  MOVFF  729,745
02C02:  MOVFF  728,744
02C06:  MOVFF  727,743
02C0A:  MOVFF  726,74A
02C0E:  MOVFF  725,749
02C12:  MOVFF  724,748
02C16:  MOVFF  723,747
02C1A:  CALL   0D6C
02C1E:  BSF    FD8.1
02C20:  MOVFF  722,74A
02C24:  MOVFF  721,749
02C28:  MOVFF  720,748
02C2C:  MOVFF  71F,747
02C30:  MOVFF  03,74E
02C34:  MOVFF  02,74D
02C38:  MOVFF  01,74C
02C3C:  MOVFF  00,74B
02C40:  CALL   0E62
02C44:  BRA    2C46
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C46:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FDC:  MOVFF  726,746
02FE0:  MOVFF  725,745
02FE4:  MOVFF  724,744
02FE8:  MOVFF  723,743
02FEC:  MOVLW  3B
02FEE:  MOVLB  7
02FF0:  MOVWF  x4A
02FF2:  MOVLW  AA
02FF4:  MOVWF  x49
02FF6:  MOVLW  38
02FF8:  MOVWF  x48
02FFA:  MOVLW  7F
02FFC:  MOVWF  x47
02FFE:  MOVLB  0
03000:  CALL   0D6C
03004:  MOVFF  03,746
03008:  MOVFF  02,745
0300C:  MOVFF  01,744
03010:  MOVFF  00,743
03014:  CALL   26FC
03018:  MOVFF  01,733
....................    s = 0;
0301C:  MOVLB  7
0301E:  BCF    x34.0
....................    y = x;
03020:  MOVFF  726,72A
03024:  MOVFF  725,729
03028:  MOVFF  724,728
0302C:  MOVFF  723,727
.................... 
....................    if (x < 0)
03030:  MOVFF  726,746
03034:  MOVFF  725,745
03038:  MOVFF  724,744
0303C:  MOVFF  723,743
03040:  CLRF   x4A
03042:  CLRF   x49
03044:  CLRF   x48
03046:  CLRF   x47
03048:  MOVLB  0
0304A:  CALL   1D08
0304E:  BNC   305E
....................    {
....................       s = 1;
03050:  MOVLB  7
03052:  BSF    x34.0
....................       n = -n;
03054:  NEGF   x33
....................       y = -y;
03056:  MOVF   x28,W
03058:  XORLW  80
0305A:  MOVWF  x28
0305C:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0305E:  MOVLB  7
03060:  CLRF   x2E
03062:  CLRF   x2D
03064:  CLRF   x2C
03066:  CLRF   x2B
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03068:  MOVLW  07
0306A:  MOVWF  x36
0306C:  MOVLW  2B
0306E:  MOVFF  736,FEA
03072:  MOVWF  FE9
03074:  MOVLW  7F
03076:  ADDWF  x33,W
03078:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0307A:  MOVFF  72A,746
0307E:  MOVFF  729,745
03082:  MOVFF  728,744
03086:  MOVFF  727,743
0308A:  MOVLW  3B
0308C:  MOVWF  x4A
0308E:  MOVLW  AA
03090:  MOVWF  x49
03092:  MOVLW  38
03094:  MOVWF  x48
03096:  MOVLW  7F
03098:  MOVWF  x47
0309A:  MOVLB  0
0309C:  CALL   0D6C
030A0:  MOVFF  03,738
030A4:  MOVFF  02,737
030A8:  MOVFF  01,736
030AC:  MOVFF  00,735
030B0:  MOVLB  7
030B2:  CLRF   x3A
030B4:  MOVFF  733,739
030B8:  BTFSC  x39.7
030BA:  DECF   x3A,F
030BC:  MOVLB  0
030BE:  CALL   26AC
030C2:  BSF    FD8.1
030C4:  MOVFF  738,74A
030C8:  MOVFF  737,749
030CC:  MOVFF  736,748
030D0:  MOVFF  735,747
030D4:  MOVFF  03,74E
030D8:  MOVFF  02,74D
030DC:  MOVFF  01,74C
030E0:  MOVFF  00,74B
030E4:  CALL   0E62
030E8:  MOVFF  03,72A
030EC:  MOVFF  02,729
030F0:  MOVFF  01,728
030F4:  MOVFF  00,727
.................... 
....................    r = pe[0]*y + pe[1];
030F8:  MOVLW  7C
030FA:  MOVLB  7
030FC:  MOVWF  x46
030FE:  MOVLW  88
03100:  MOVWF  x45
03102:  MOVLW  59
03104:  MOVWF  x44
03106:  MOVLW  72
03108:  MOVWF  x43
0310A:  MOVFF  72A,74A
0310E:  MOVFF  729,749
03112:  MOVFF  728,748
03116:  MOVFF  727,747
0311A:  MOVLB  0
0311C:  CALL   0D6C
03120:  MOVFF  03,738
03124:  MOVFF  02,737
03128:  MOVFF  01,736
0312C:  MOVFF  00,735
03130:  BCF    FD8.1
03132:  MOVFF  03,74A
03136:  MOVFF  02,749
0313A:  MOVFF  01,748
0313E:  MOVFF  00,747
03142:  MOVLW  E0
03144:  MOVLB  7
03146:  MOVWF  x4E
03148:  MOVLW  97
0314A:  MOVWF  x4D
0314C:  MOVLW  26
0314E:  MOVWF  x4C
03150:  MOVLW  75
03152:  MOVWF  x4B
03154:  MOVLB  0
03156:  CALL   0E62
0315A:  MOVFF  03,732
0315E:  MOVFF  02,731
03162:  MOVFF  01,730
03166:  MOVFF  00,72F
....................    r = r*y + pe[2];
0316A:  MOVFF  732,746
0316E:  MOVFF  731,745
03172:  MOVFF  730,744
03176:  MOVFF  72F,743
0317A:  MOVFF  72A,74A
0317E:  MOVFF  729,749
03182:  MOVFF  728,748
03186:  MOVFF  727,747
0318A:  CALL   0D6C
0318E:  MOVFF  03,738
03192:  MOVFF  02,737
03196:  MOVFF  01,736
0319A:  MOVFF  00,735
0319E:  BCF    FD8.1
031A0:  MOVFF  03,74A
031A4:  MOVFF  02,749
031A8:  MOVFF  01,748
031AC:  MOVFF  00,747
031B0:  MOVLW  C4
031B2:  MOVLB  7
031B4:  MOVWF  x4E
031B6:  MOVLW  1D
031B8:  MOVWF  x4D
031BA:  MOVLW  1E
031BC:  MOVWF  x4C
031BE:  MOVLW  78
031C0:  MOVWF  x4B
031C2:  MOVLB  0
031C4:  CALL   0E62
031C8:  MOVFF  03,732
031CC:  MOVFF  02,731
031D0:  MOVFF  01,730
031D4:  MOVFF  00,72F
....................    r = r*y + pe[3];
031D8:  MOVFF  732,746
031DC:  MOVFF  731,745
031E0:  MOVFF  730,744
031E4:  MOVFF  72F,743
031E8:  MOVFF  72A,74A
031EC:  MOVFF  729,749
031F0:  MOVFF  728,748
031F4:  MOVFF  727,747
031F8:  CALL   0D6C
031FC:  MOVFF  03,738
03200:  MOVFF  02,737
03204:  MOVFF  01,736
03208:  MOVFF  00,735
0320C:  BCF    FD8.1
0320E:  MOVFF  03,74A
03212:  MOVFF  02,749
03216:  MOVFF  01,748
0321A:  MOVFF  00,747
0321E:  MOVLW  5E
03220:  MOVLB  7
03222:  MOVWF  x4E
03224:  MOVLW  50
03226:  MOVWF  x4D
03228:  MOVLW  63
0322A:  MOVWF  x4C
0322C:  MOVLW  7A
0322E:  MOVWF  x4B
03230:  MOVLB  0
03232:  CALL   0E62
03236:  MOVFF  03,732
0323A:  MOVFF  02,731
0323E:  MOVFF  01,730
03242:  MOVFF  00,72F
....................    r = r*y + pe[4];
03246:  MOVFF  732,746
0324A:  MOVFF  731,745
0324E:  MOVFF  730,744
03252:  MOVFF  72F,743
03256:  MOVFF  72A,74A
0325A:  MOVFF  729,749
0325E:  MOVFF  728,748
03262:  MOVFF  727,747
03266:  CALL   0D6C
0326A:  MOVFF  03,738
0326E:  MOVFF  02,737
03272:  MOVFF  01,736
03276:  MOVFF  00,735
0327A:  BCF    FD8.1
0327C:  MOVFF  03,74A
03280:  MOVFF  02,749
03284:  MOVFF  01,748
03288:  MOVFF  00,747
0328C:  MOVLW  1A
0328E:  MOVLB  7
03290:  MOVWF  x4E
03292:  MOVLW  FE
03294:  MOVWF  x4D
03296:  MOVLW  75
03298:  MOVWF  x4C
0329A:  MOVLW  7C
0329C:  MOVWF  x4B
0329E:  MOVLB  0
032A0:  CALL   0E62
032A4:  MOVFF  03,732
032A8:  MOVFF  02,731
032AC:  MOVFF  01,730
032B0:  MOVFF  00,72F
....................    r = r*y + pe[5];
032B4:  MOVFF  732,746
032B8:  MOVFF  731,745
032BC:  MOVFF  730,744
032C0:  MOVFF  72F,743
032C4:  MOVFF  72A,74A
032C8:  MOVFF  729,749
032CC:  MOVFF  728,748
032D0:  MOVFF  727,747
032D4:  CALL   0D6C
032D8:  MOVFF  03,738
032DC:  MOVFF  02,737
032E0:  MOVFF  01,736
032E4:  MOVFF  00,735
032E8:  BCF    FD8.1
032EA:  MOVFF  03,74A
032EE:  MOVFF  02,749
032F2:  MOVFF  01,748
032F6:  MOVFF  00,747
032FA:  MOVLW  18
032FC:  MOVLB  7
032FE:  MOVWF  x4E
03300:  MOVLW  72
03302:  MOVWF  x4D
03304:  MOVLW  31
03306:  MOVWF  x4C
03308:  MOVLW  7E
0330A:  MOVWF  x4B
0330C:  MOVLB  0
0330E:  CALL   0E62
03312:  MOVFF  03,732
03316:  MOVFF  02,731
0331A:  MOVFF  01,730
0331E:  MOVFF  00,72F
.................... 
....................    res = res*(1.0 + y*r);
03322:  MOVFF  72A,746
03326:  MOVFF  729,745
0332A:  MOVFF  728,744
0332E:  MOVFF  727,743
03332:  MOVFF  732,74A
03336:  MOVFF  731,749
0333A:  MOVFF  730,748
0333E:  MOVFF  72F,747
03342:  CALL   0D6C
03346:  BCF    FD8.1
03348:  MOVLB  7
0334A:  CLRF   x4A
0334C:  CLRF   x49
0334E:  CLRF   x48
03350:  MOVLW  7F
03352:  MOVWF  x47
03354:  MOVFF  03,74E
03358:  MOVFF  02,74D
0335C:  MOVFF  01,74C
03360:  MOVFF  00,74B
03364:  MOVLB  0
03366:  CALL   0E62
0336A:  MOVFF  72E,746
0336E:  MOVFF  72D,745
03372:  MOVFF  72C,744
03376:  MOVFF  72B,743
0337A:  MOVFF  03,74A
0337E:  MOVFF  02,749
03382:  MOVFF  01,748
03386:  MOVFF  00,747
0338A:  CALL   0D6C
0338E:  MOVFF  03,72E
03392:  MOVFF  02,72D
03396:  MOVFF  01,72C
0339A:  MOVFF  00,72B
.................... 
....................    if (s)
0339E:  MOVLB  7
033A0:  BTFSS  x34.0
033A2:  BRA    33D6
....................       res = 1.0/res;
033A4:  CLRF   x3F
033A6:  CLRF   x3E
033A8:  CLRF   x3D
033AA:  MOVLW  7F
033AC:  MOVWF  x3C
033AE:  MOVFF  72E,743
033B2:  MOVFF  72D,742
033B6:  MOVFF  72C,741
033BA:  MOVFF  72B,740
033BE:  MOVLB  0
033C0:  CALL   1D82
033C4:  MOVFF  03,72E
033C8:  MOVFF  02,72D
033CC:  MOVFF  01,72C
033D0:  MOVFF  00,72B
033D4:  MOVLB  7
....................    return(res);
033D6:  MOVFF  72B,00
033DA:  MOVFF  72C,01
033DE:  MOVFF  72D,02
033E2:  MOVFF  72E,03
033E6:  MOVLB  0
033E8:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C48:  MOVFF  726,72A
02C4C:  MOVFF  725,729
02C50:  MOVFF  724,728
02C54:  MOVFF  723,727
.................... 
....................    if (y != 1.0)
02C58:  MOVFF  72A,746
02C5C:  MOVFF  729,745
02C60:  MOVFF  728,744
02C64:  MOVFF  727,743
02C68:  MOVLB  7
02C6A:  CLRF   x4A
02C6C:  CLRF   x49
02C6E:  CLRF   x48
02C70:  MOVLW  7F
02C72:  MOVWF  x47
02C74:  MOVLB  0
02C76:  CALL   1D08
02C7A:  BTFSC  FD8.2
02C7C:  BRA    2FBE
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C7E:  MOVLW  07
02C80:  MOVLB  7
02C82:  MOVWF  x39
02C84:  MOVLW  27
02C86:  MOVFF  739,FEA
02C8A:  MOVWF  FE9
02C8C:  MOVLW  7E
02C8E:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02C90:  BSF    FD8.1
02C92:  MOVFF  72A,74A
02C96:  MOVFF  729,749
02C9A:  MOVFF  728,748
02C9E:  MOVFF  727,747
02CA2:  CLRF   x4E
02CA4:  CLRF   x4D
02CA6:  CLRF   x4C
02CA8:  MOVLW  7F
02CAA:  MOVWF  x4B
02CAC:  MOVLB  0
02CAE:  CALL   0E62
02CB2:  MOVFF  03,73B
02CB6:  MOVFF  02,73A
02CBA:  MOVFF  01,739
02CBE:  MOVFF  00,738
02CC2:  BCF    FD8.1
02CC4:  MOVFF  72A,74A
02CC8:  MOVFF  729,749
02CCC:  MOVFF  728,748
02CD0:  MOVFF  727,747
02CD4:  MOVLB  7
02CD6:  CLRF   x4E
02CD8:  CLRF   x4D
02CDA:  CLRF   x4C
02CDC:  MOVLW  7F
02CDE:  MOVWF  x4B
02CE0:  MOVLB  0
02CE2:  CALL   0E62
02CE6:  MOVFF  73B,73F
02CEA:  MOVFF  73A,73E
02CEE:  MOVFF  739,73D
02CF2:  MOVFF  738,73C
02CF6:  MOVFF  03,743
02CFA:  MOVFF  02,742
02CFE:  MOVFF  01,741
02D02:  MOVFF  00,740
02D06:  CALL   1D82
02D0A:  MOVFF  03,72A
02D0E:  MOVFF  02,729
02D12:  MOVFF  01,728
02D16:  MOVFF  00,727
.................... 
....................       y2=y*y;
02D1A:  MOVFF  72A,746
02D1E:  MOVFF  729,745
02D22:  MOVFF  728,744
02D26:  MOVFF  727,743
02D2A:  MOVFF  72A,74A
02D2E:  MOVFF  729,749
02D32:  MOVFF  728,748
02D36:  MOVFF  727,747
02D3A:  CALL   0D6C
02D3E:  MOVFF  03,736
02D42:  MOVFF  02,735
02D46:  MOVFF  01,734
02D4A:  MOVFF  00,733
.................... 
....................       res = pl[0]*y2 + pl[1];
02D4E:  MOVLW  99
02D50:  MOVLB  7
02D52:  MOVWF  x46
02D54:  MOVLW  47
02D56:  MOVWF  x45
02D58:  MOVLW  8A
02D5A:  MOVWF  x44
02D5C:  MOVLW  7F
02D5E:  MOVWF  x43
02D60:  MOVFF  736,74A
02D64:  MOVFF  735,749
02D68:  MOVFF  734,748
02D6C:  MOVFF  733,747
02D70:  MOVLB  0
02D72:  CALL   0D6C
02D76:  MOVFF  03,73B
02D7A:  MOVFF  02,73A
02D7E:  MOVFF  01,739
02D82:  MOVFF  00,738
02D86:  BCF    FD8.1
02D88:  MOVFF  03,74A
02D8C:  MOVFF  02,749
02D90:  MOVFF  01,748
02D94:  MOVFF  00,747
02D98:  MOVLB  7
02D9A:  CLRF   x4E
02D9C:  CLRF   x4D
02D9E:  CLRF   x4C
02DA0:  MOVLW  80
02DA2:  MOVWF  x4B
02DA4:  MOVLB  0
02DA6:  CALL   0E62
02DAA:  MOVFF  03,72E
02DAE:  MOVFF  02,72D
02DB2:  MOVFF  01,72C
02DB6:  MOVFF  00,72B
.................... 
....................       r = ql[0]*y2 + ql[1];
02DBA:  MOVLW  4C
02DBC:  MOVLB  7
02DBE:  MOVWF  x46
02DC0:  MOVLW  F3
02DC2:  MOVWF  x45
02DC4:  MOVLW  3A
02DC6:  MOVWF  x44
02DC8:  MOVLW  7B
02DCA:  MOVWF  x43
02DCC:  MOVFF  736,74A
02DD0:  MOVFF  735,749
02DD4:  MOVFF  734,748
02DD8:  MOVFF  733,747
02DDC:  MOVLB  0
02DDE:  CALL   0D6C
02DE2:  MOVFF  03,73B
02DE6:  MOVFF  02,73A
02DEA:  MOVFF  01,739
02DEE:  MOVFF  00,738
02DF2:  BCF    FD8.1
02DF4:  MOVFF  03,74A
02DF8:  MOVFF  02,749
02DFC:  MOVFF  01,748
02E00:  MOVFF  00,747
02E04:  MOVLW  2B
02E06:  MOVLB  7
02E08:  MOVWF  x4E
02E0A:  MOVLW  9D
02E0C:  MOVWF  x4D
02E0E:  MOVLW  DF
02E10:  MOVWF  x4C
02E12:  MOVLW  7E
02E14:  MOVWF  x4B
02E16:  MOVLB  0
02E18:  CALL   0E62
02E1C:  MOVFF  03,732
02E20:  MOVFF  02,731
02E24:  MOVFF  01,730
02E28:  MOVFF  00,72F
....................       r = r*y2 + 1.0;
02E2C:  MOVFF  732,746
02E30:  MOVFF  731,745
02E34:  MOVFF  730,744
02E38:  MOVFF  72F,743
02E3C:  MOVFF  736,74A
02E40:  MOVFF  735,749
02E44:  MOVFF  734,748
02E48:  MOVFF  733,747
02E4C:  CALL   0D6C
02E50:  MOVFF  03,73B
02E54:  MOVFF  02,73A
02E58:  MOVFF  01,739
02E5C:  MOVFF  00,738
02E60:  BCF    FD8.1
02E62:  MOVFF  03,74A
02E66:  MOVFF  02,749
02E6A:  MOVFF  01,748
02E6E:  MOVFF  00,747
02E72:  MOVLB  7
02E74:  CLRF   x4E
02E76:  CLRF   x4D
02E78:  CLRF   x4C
02E7A:  MOVLW  7F
02E7C:  MOVWF  x4B
02E7E:  MOVLB  0
02E80:  CALL   0E62
02E84:  MOVFF  03,732
02E88:  MOVFF  02,731
02E8C:  MOVFF  01,730
02E90:  MOVFF  00,72F
.................... 
....................       res = y*res/r;
02E94:  MOVFF  72A,746
02E98:  MOVFF  729,745
02E9C:  MOVFF  728,744
02EA0:  MOVFF  727,743
02EA4:  MOVFF  72E,74A
02EA8:  MOVFF  72D,749
02EAC:  MOVFF  72C,748
02EB0:  MOVFF  72B,747
02EB4:  CALL   0D6C
02EB8:  MOVFF  03,73B
02EBC:  MOVFF  02,73A
02EC0:  MOVFF  01,739
02EC4:  MOVFF  00,738
02EC8:  MOVFF  03,73F
02ECC:  MOVFF  02,73E
02ED0:  MOVFF  01,73D
02ED4:  MOVFF  00,73C
02ED8:  MOVFF  732,743
02EDC:  MOVFF  731,742
02EE0:  MOVFF  730,741
02EE4:  MOVFF  72F,740
02EE8:  CALL   1D82
02EEC:  MOVFF  03,72E
02EF0:  MOVFF  02,72D
02EF4:  MOVFF  01,72C
02EF8:  MOVFF  00,72B
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02EFC:  MOVLW  07
02EFE:  MOVLB  7
02F00:  MOVWF  x39
02F02:  MOVLW  23
02F04:  MOVFF  739,FEA
02F08:  MOVWF  FE9
02F0A:  MOVLW  7E
02F0C:  SUBWF  FEF,W
02F0E:  MOVWF  x37
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02F10:  BTFSS  x37.7
02F12:  BRA    2F3E
....................          r = -(float32)-n;
02F14:  MOVLW  00
02F16:  BSF    FD8.0
02F18:  SUBFWB x37,W
02F1A:  CLRF   x3A
02F1C:  MOVWF  x39
02F1E:  BTFSC  x39.7
02F20:  DECF   x3A,F
02F22:  MOVLB  0
02F24:  CALL   26AC
02F28:  MOVFF  00,72F
02F2C:  MOVF   01,W
02F2E:  XORLW  80
02F30:  MOVLB  7
02F32:  MOVWF  x30
02F34:  MOVFF  02,731
02F38:  MOVFF  03,732
02F3C:  BRA    2F60
....................       else
....................          r = (float32)n;
02F3E:  CLRF   x3A
02F40:  MOVFF  737,739
02F44:  BTFSC  x39.7
02F46:  DECF   x3A,F
02F48:  MOVLB  0
02F4A:  CALL   26AC
02F4E:  MOVFF  03,732
02F52:  MOVFF  02,731
02F56:  MOVFF  01,730
02F5A:  MOVFF  00,72F
02F5E:  MOVLB  7
.................... 
....................       res += r*LN2;
02F60:  MOVFF  732,746
02F64:  MOVFF  731,745
02F68:  MOVFF  730,744
02F6C:  MOVFF  72F,743
02F70:  MOVLW  18
02F72:  MOVWF  x4A
02F74:  MOVLW  72
02F76:  MOVWF  x49
02F78:  MOVLW  31
02F7A:  MOVWF  x48
02F7C:  MOVLW  7E
02F7E:  MOVWF  x47
02F80:  MOVLB  0
02F82:  CALL   0D6C
02F86:  BCF    FD8.1
02F88:  MOVFF  72E,74A
02F8C:  MOVFF  72D,749
02F90:  MOVFF  72C,748
02F94:  MOVFF  72B,747
02F98:  MOVFF  03,74E
02F9C:  MOVFF  02,74D
02FA0:  MOVFF  01,74C
02FA4:  MOVFF  00,74B
02FA8:  CALL   0E62
02FAC:  MOVFF  03,72E
02FB0:  MOVFF  02,72D
02FB4:  MOVFF  01,72C
02FB8:  MOVFF  00,72B
....................    }
02FBC:  BRA    2FCA
.................... 
....................    else
....................       res = 0.0;
02FBE:  MOVLB  7
02FC0:  CLRF   x2E
02FC2:  CLRF   x2D
02FC4:  CLRF   x2C
02FC6:  CLRF   x2B
02FC8:  MOVLB  0
.................... 
....................    return(res);
02FCA:  MOVFF  72B,00
02FCE:  MOVFF  72C,01
02FD2:  MOVFF  72D,02
02FD6:  MOVFF  72E,03
02FDA:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
033EA:  MOVFF  71A,746
033EE:  MOVFF  719,745
033F2:  MOVFF  718,744
033F6:  MOVFF  717,743
033FA:  MOVLB  7
033FC:  CLRF   x4A
033FE:  CLRF   x49
03400:  CLRF   x48
03402:  CLRF   x47
03404:  MOVLB  0
03406:  CALL   1D08
0340A:  BTFSS  FD8.0
0340C:  BRA    35A8
0340E:  MOVFF  71E,722
03412:  MOVFF  71D,721
03416:  MOVFF  71C,720
0341A:  MOVFF  71B,71F
0341E:  MOVLB  7
03420:  CLRF   x26
03422:  CLRF   x25
03424:  CLRF   x24
03426:  MOVLW  7F
03428:  MOVWF  x23
0342A:  MOVLB  0
0342C:  CALL   2AE2
03430:  MOVFF  03,722
03434:  MOVFF  02,721
03438:  MOVFF  01,720
0343C:  MOVFF  00,71F
03440:  MOVFF  03,746
03444:  MOVFF  02,745
03448:  MOVFF  01,744
0344C:  MOVFF  00,743
03450:  MOVLB  7
03452:  CLRF   x4A
03454:  CLRF   x49
03456:  CLRF   x48
03458:  CLRF   x47
0345A:  MOVLB  0
0345C:  CALL   1D08
03460:  BTFSS  FD8.2
03462:  BRA    35A8
....................       if(fmod(y, 2) == 0) {
03464:  MOVFF  71E,722
03468:  MOVFF  71D,721
0346C:  MOVFF  71C,720
03470:  MOVFF  71B,71F
03474:  MOVLB  7
03476:  CLRF   x26
03478:  CLRF   x25
0347A:  CLRF   x24
0347C:  MOVLW  80
0347E:  MOVWF  x23
03480:  MOVLB  0
03482:  CALL   2AE2
03486:  MOVFF  03,722
0348A:  MOVFF  02,721
0348E:  MOVFF  01,720
03492:  MOVFF  00,71F
03496:  MOVFF  03,746
0349A:  MOVFF  02,745
0349E:  MOVFF  01,744
034A2:  MOVFF  00,743
034A6:  MOVLB  7
034A8:  CLRF   x4A
034AA:  CLRF   x49
034AC:  CLRF   x48
034AE:  CLRF   x47
034B0:  MOVLB  0
034B2:  CALL   1D08
034B6:  BNZ   352E
....................          return (exp(log(-x) * y));
034B8:  MOVLB  7
034BA:  MOVF   x18,W
034BC:  XORLW  80
034BE:  MOVWF  x20
034C0:  MOVFF  71A,726
034C4:  MOVFF  719,725
034C8:  MOVWF  x24
034CA:  MOVFF  717,723
034CE:  MOVLB  0
034D0:  CALL   2C48
034D4:  MOVFF  03,722
034D8:  MOVFF  02,721
034DC:  MOVFF  01,720
034E0:  MOVFF  00,71F
034E4:  MOVFF  03,746
034E8:  MOVFF  02,745
034EC:  MOVFF  01,744
034F0:  MOVFF  00,743
034F4:  MOVFF  71E,74A
034F8:  MOVFF  71D,749
034FC:  MOVFF  71C,748
03500:  MOVFF  71B,747
03504:  CALL   0D6C
03508:  MOVFF  03,722
0350C:  MOVFF  02,721
03510:  MOVFF  01,720
03514:  MOVFF  00,71F
03518:  MOVFF  03,726
0351C:  MOVFF  02,725
03520:  MOVFF  01,724
03524:  MOVFF  00,723
03528:  RCALL  2FDC
0352A:  BRA    36E6
....................       } else {
0352C:  BRA    35A6
....................          return (-exp(log(-x) * y));
0352E:  MOVLB  7
03530:  MOVF   x18,W
03532:  XORLW  80
03534:  MOVWF  x20
03536:  MOVFF  71A,726
0353A:  MOVFF  719,725
0353E:  MOVWF  x24
03540:  MOVFF  717,723
03544:  MOVLB  0
03546:  CALL   2C48
0354A:  MOVFF  03,722
0354E:  MOVFF  02,721
03552:  MOVFF  01,720
03556:  MOVFF  00,71F
0355A:  MOVFF  03,746
0355E:  MOVFF  02,745
03562:  MOVFF  01,744
03566:  MOVFF  00,743
0356A:  MOVFF  71E,74A
0356E:  MOVFF  71D,749
03572:  MOVFF  71C,748
03576:  MOVFF  71B,747
0357A:  CALL   0D6C
0357E:  MOVFF  03,722
03582:  MOVFF  02,721
03586:  MOVFF  01,720
0358A:  MOVFF  00,71F
0358E:  MOVFF  03,726
03592:  MOVFF  02,725
03596:  MOVFF  01,724
0359A:  MOVFF  00,723
0359E:  RCALL  2FDC
035A0:  MOVLW  80
035A2:  XORWF  01,F
035A4:  BRA    36E6
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
035A6:  BRA    36E6
035A8:  MOVFF  71A,746
035AC:  MOVFF  719,745
035B0:  MOVFF  718,744
035B4:  MOVFF  717,743
035B8:  MOVLB  7
035BA:  CLRF   x4A
035BC:  CLRF   x49
035BE:  CLRF   x48
035C0:  CLRF   x47
035C2:  MOVLB  0
035C4:  CALL   1D08
035C8:  BNC   362A
035CA:  MOVFF  71E,722
035CE:  MOVFF  71D,721
035D2:  MOVFF  71C,720
035D6:  MOVFF  71B,71F
035DA:  MOVLB  7
035DC:  CLRF   x26
035DE:  CLRF   x25
035E0:  CLRF   x24
035E2:  MOVLW  7F
035E4:  MOVWF  x23
035E6:  MOVLB  0
035E8:  CALL   2AE2
035EC:  MOVFF  03,722
035F0:  MOVFF  02,721
035F4:  MOVFF  01,720
035F8:  MOVFF  00,71F
035FC:  MOVFF  03,746
03600:  MOVFF  02,745
03604:  MOVFF  01,744
03608:  MOVFF  00,743
0360C:  MOVLB  7
0360E:  CLRF   x4A
03610:  CLRF   x49
03612:  CLRF   x48
03614:  CLRF   x47
03616:  MOVLB  0
03618:  CALL   1D08
0361C:  BZ    362A
....................       return 0;
0361E:  CLRF   00
03620:  CLRF   01
03622:  CLRF   02
03624:  CLRF   03
03626:  BRA    36E6
....................    } else {
03628:  BRA    36E6
....................       if(x != 0 || 0 >= y) {
0362A:  MOVFF  71A,746
0362E:  MOVFF  719,745
03632:  MOVFF  718,744
03636:  MOVFF  717,743
0363A:  MOVLB  7
0363C:  CLRF   x4A
0363E:  CLRF   x49
03640:  CLRF   x48
03642:  CLRF   x47
03644:  MOVLB  0
03646:  CALL   1D08
0364A:  BNZ   3670
0364C:  MOVFF  71E,746
03650:  MOVFF  71D,745
03654:  MOVFF  71C,744
03658:  MOVFF  71B,743
0365C:  MOVLB  7
0365E:  CLRF   x4A
03660:  CLRF   x49
03662:  CLRF   x48
03664:  CLRF   x47
03666:  MOVLB  0
03668:  CALL   1D08
0366C:  BC    3670
0366E:  BNZ   36DE
....................          return (exp(log(x) * y));
03670:  MOVFF  71A,726
03674:  MOVFF  719,725
03678:  MOVFF  718,724
0367C:  MOVFF  717,723
03680:  CALL   2C48
03684:  MOVFF  03,722
03688:  MOVFF  02,721
0368C:  MOVFF  01,720
03690:  MOVFF  00,71F
03694:  MOVFF  03,746
03698:  MOVFF  02,745
0369C:  MOVFF  01,744
036A0:  MOVFF  00,743
036A4:  MOVFF  71E,74A
036A8:  MOVFF  71D,749
036AC:  MOVFF  71C,748
036B0:  MOVFF  71B,747
036B4:  CALL   0D6C
036B8:  MOVFF  03,722
036BC:  MOVFF  02,721
036C0:  MOVFF  01,720
036C4:  MOVFF  00,71F
036C8:  MOVFF  03,726
036CC:  MOVFF  02,725
036D0:  MOVFF  01,724
036D4:  MOVFF  00,723
036D8:  RCALL  2FDC
036DA:  BRA    36E6
....................       } else return 0;
036DC:  BRA    36E6
036DE:  CLRF   00
036E0:  CLRF   01
036E2:  CLRF   02
036E4:  CLRF   03
....................    }
036E6:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01EE0:  MOVLB  7
01EE2:  BCF    x35.0
....................    flag = 0;
01EE4:  BCF    x35.1
....................    y = x;
01EE6:  MOVFF  728,72C
01EEA:  MOVFF  727,72B
01EEE:  MOVFF  726,72A
01EF2:  MOVFF  725,729
.................... 
....................    if (x < 0)
01EF6:  MOVFF  728,746
01EFA:  MOVFF  727,745
01EFE:  MOVFF  726,744
01F02:  MOVFF  725,743
01F06:  CLRF   x4A
01F08:  CLRF   x49
01F0A:  CLRF   x48
01F0C:  CLRF   x47
01F0E:  MOVLB  0
01F10:  RCALL  1D08
01F12:  BNC   1F20
....................    {
....................       s = 1;
01F14:  MOVLB  7
01F16:  BSF    x35.0
....................       y = -y;
01F18:  MOVF   x2A,W
01F1A:  XORLW  80
01F1C:  MOVWF  x2A
01F1E:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F20:  MOVLB  7
01F22:  CLRF   x46
01F24:  CLRF   x45
01F26:  CLRF   x44
01F28:  MOVLW  7F
01F2A:  MOVWF  x43
01F2C:  MOVFF  72C,74A
01F30:  MOVFF  72B,749
01F34:  MOVFF  72A,748
01F38:  MOVFF  729,747
01F3C:  MOVLB  0
01F3E:  RCALL  1D08
01F40:  BNC   1F78
....................    {
....................       y = 1.0/y;
01F42:  MOVLB  7
01F44:  CLRF   x3F
01F46:  CLRF   x3E
01F48:  CLRF   x3D
01F4A:  MOVLW  7F
01F4C:  MOVWF  x3C
01F4E:  MOVFF  72C,743
01F52:  MOVFF  72B,742
01F56:  MOVFF  72A,741
01F5A:  MOVFF  729,740
01F5E:  MOVLB  0
01F60:  RCALL  1D82
01F62:  MOVFF  03,72C
01F66:  MOVFF  02,72B
01F6A:  MOVFF  01,72A
01F6E:  MOVFF  00,729
....................       flag = 1;
01F72:  MOVLB  7
01F74:  BSF    x35.1
01F76:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F78:  MOVLW  0A
01F7A:  MOVLB  7
01F7C:  MOVWF  x46
01F7E:  MOVLW  89
01F80:  MOVWF  x45
01F82:  MOVLW  34
01F84:  MOVWF  x44
01F86:  MOVLW  7C
01F88:  MOVWF  x43
01F8A:  MOVFF  72C,74A
01F8E:  MOVFF  72B,749
01F92:  MOVFF  72A,748
01F96:  MOVFF  729,747
01F9A:  MOVLB  0
01F9C:  CALL   0D6C
01FA0:  MOVFF  03,739
01FA4:  MOVFF  02,738
01FA8:  MOVFF  01,737
01FAC:  MOVFF  00,736
01FB0:  MOVFF  03,746
01FB4:  MOVFF  02,745
01FB8:  MOVFF  01,744
01FBC:  MOVFF  00,743
01FC0:  MOVFF  72C,74A
01FC4:  MOVFF  72B,749
01FC8:  MOVFF  72A,748
01FCC:  MOVFF  729,747
01FD0:  CALL   0D6C
01FD4:  MOVFF  03,739
01FD8:  MOVFF  02,738
01FDC:  MOVFF  01,737
01FE0:  MOVFF  00,736
01FE4:  BCF    FD8.1
01FE6:  MOVFF  03,74A
01FEA:  MOVFF  02,749
01FEE:  MOVFF  01,748
01FF2:  MOVFF  00,747
01FF6:  MOVLW  7C
01FF8:  MOVLB  7
01FFA:  MOVWF  x4E
01FFC:  MOVLW  79
01FFE:  MOVWF  x4D
02000:  MOVLW  35
02002:  MOVWF  x4C
02004:  MOVLW  81
02006:  MOVWF  x4B
02008:  MOVLB  0
0200A:  CALL   0E62
0200E:  MOVFF  03,730
02012:  MOVFF  02,72F
02016:  MOVFF  01,72E
0201A:  MOVFF  00,72D
....................    res = res*y*y + pat[2];
0201E:  MOVFF  730,746
02022:  MOVFF  72F,745
02026:  MOVFF  72E,744
0202A:  MOVFF  72D,743
0202E:  MOVFF  72C,74A
02032:  MOVFF  72B,749
02036:  MOVFF  72A,748
0203A:  MOVFF  729,747
0203E:  CALL   0D6C
02042:  MOVFF  03,739
02046:  MOVFF  02,738
0204A:  MOVFF  01,737
0204E:  MOVFF  00,736
02052:  MOVFF  03,746
02056:  MOVFF  02,745
0205A:  MOVFF  01,744
0205E:  MOVFF  00,743
02062:  MOVFF  72C,74A
02066:  MOVFF  72B,749
0206A:  MOVFF  72A,748
0206E:  MOVFF  729,747
02072:  CALL   0D6C
02076:  MOVFF  03,739
0207A:  MOVFF  02,738
0207E:  MOVFF  01,737
02082:  MOVFF  00,736
02086:  BCF    FD8.1
02088:  MOVFF  03,74A
0208C:  MOVFF  02,749
02090:  MOVFF  01,748
02094:  MOVFF  00,747
02098:  MOVLW  3F
0209A:  MOVLB  7
0209C:  MOVWF  x4E
0209E:  MOVLW  02
020A0:  MOVWF  x4D
020A2:  MOVLW  33
020A4:  MOVWF  x4C
020A6:  MOVLW  83
020A8:  MOVWF  x4B
020AA:  MOVLB  0
020AC:  CALL   0E62
020B0:  MOVFF  03,730
020B4:  MOVFF  02,72F
020B8:  MOVFF  01,72E
020BC:  MOVFF  00,72D
....................    res = res*y*y + pat[3];
020C0:  MOVFF  730,746
020C4:  MOVFF  72F,745
020C8:  MOVFF  72E,744
020CC:  MOVFF  72D,743
020D0:  MOVFF  72C,74A
020D4:  MOVFF  72B,749
020D8:  MOVFF  72A,748
020DC:  MOVFF  729,747
020E0:  CALL   0D6C
020E4:  MOVFF  03,739
020E8:  MOVFF  02,738
020EC:  MOVFF  01,737
020F0:  MOVFF  00,736
020F4:  MOVFF  03,746
020F8:  MOVFF  02,745
020FC:  MOVFF  01,744
02100:  MOVFF  00,743
02104:  MOVFF  72C,74A
02108:  MOVFF  72B,749
0210C:  MOVFF  72A,748
02110:  MOVFF  729,747
02114:  CALL   0D6C
02118:  MOVFF  03,739
0211C:  MOVFF  02,738
02120:  MOVFF  01,737
02124:  MOVFF  00,736
02128:  BCF    FD8.1
0212A:  MOVFF  03,74A
0212E:  MOVFF  02,749
02132:  MOVFF  01,748
02136:  MOVFF  00,747
0213A:  MOVLW  33
0213C:  MOVLB  7
0213E:  MOVWF  x4E
02140:  MOVLW  8C
02142:  MOVWF  x4D
02144:  MOVLW  1E
02146:  MOVWF  x4C
02148:  MOVLW  83
0214A:  MOVWF  x4B
0214C:  MOVLB  0
0214E:  CALL   0E62
02152:  MOVFF  03,730
02156:  MOVFF  02,72F
0215A:  MOVFF  01,72E
0215E:  MOVFF  00,72D
.................... 
....................    r = qat[0]*y*y + qat[1];
02162:  MOVLB  7
02164:  CLRF   x46
02166:  CLRF   x45
02168:  CLRF   x44
0216A:  MOVLW  7F
0216C:  MOVWF  x43
0216E:  MOVFF  72C,74A
02172:  MOVFF  72B,749
02176:  MOVFF  72A,748
0217A:  MOVFF  729,747
0217E:  MOVLB  0
02180:  CALL   0D6C
02184:  MOVFF  03,739
02188:  MOVFF  02,738
0218C:  MOVFF  01,737
02190:  MOVFF  00,736
02194:  MOVFF  03,746
02198:  MOVFF  02,745
0219C:  MOVFF  01,744
021A0:  MOVFF  00,743
021A4:  MOVFF  72C,74A
021A8:  MOVFF  72B,749
021AC:  MOVFF  72A,748
021B0:  MOVFF  729,747
021B4:  CALL   0D6C
021B8:  MOVFF  03,739
021BC:  MOVFF  02,738
021C0:  MOVFF  01,737
021C4:  MOVFF  00,736
021C8:  BCF    FD8.1
021CA:  MOVFF  03,74A
021CE:  MOVFF  02,749
021D2:  MOVFF  01,748
021D6:  MOVFF  00,747
021DA:  MOVLW  1B
021DC:  MOVLB  7
021DE:  MOVWF  x4E
021E0:  MOVLW  E4
021E2:  MOVWF  x4D
021E4:  MOVLW  35
021E6:  MOVWF  x4C
021E8:  MOVLW  82
021EA:  MOVWF  x4B
021EC:  MOVLB  0
021EE:  CALL   0E62
021F2:  MOVFF  03,734
021F6:  MOVFF  02,733
021FA:  MOVFF  01,732
021FE:  MOVFF  00,731
....................    r = r*y*y + qat[2];
02202:  MOVFF  734,746
02206:  MOVFF  733,745
0220A:  MOVFF  732,744
0220E:  MOVFF  731,743
02212:  MOVFF  72C,74A
02216:  MOVFF  72B,749
0221A:  MOVFF  72A,748
0221E:  MOVFF  729,747
02222:  CALL   0D6C
02226:  MOVFF  03,739
0222A:  MOVFF  02,738
0222E:  MOVFF  01,737
02232:  MOVFF  00,736
02236:  MOVFF  03,746
0223A:  MOVFF  02,745
0223E:  MOVFF  01,744
02242:  MOVFF  00,743
02246:  MOVFF  72C,74A
0224A:  MOVFF  72B,749
0224E:  MOVFF  72A,748
02252:  MOVFF  729,747
02256:  CALL   0D6C
0225A:  MOVFF  03,739
0225E:  MOVFF  02,738
02262:  MOVFF  01,737
02266:  MOVFF  00,736
0226A:  BCF    FD8.1
0226C:  MOVFF  03,74A
02270:  MOVFF  02,749
02274:  MOVFF  01,748
02278:  MOVFF  00,747
0227C:  MOVLW  A4
0227E:  MOVLB  7
02280:  MOVWF  x4E
02282:  MOVLW  DB
02284:  MOVWF  x4D
02286:  MOVLW  67
02288:  MOVWF  x4C
0228A:  MOVLW  83
0228C:  MOVWF  x4B
0228E:  MOVLB  0
02290:  CALL   0E62
02294:  MOVFF  03,734
02298:  MOVFF  02,733
0229C:  MOVFF  01,732
022A0:  MOVFF  00,731
....................    r = r*y*y + qat[3];
022A4:  MOVFF  734,746
022A8:  MOVFF  733,745
022AC:  MOVFF  732,744
022B0:  MOVFF  731,743
022B4:  MOVFF  72C,74A
022B8:  MOVFF  72B,749
022BC:  MOVFF  72A,748
022C0:  MOVFF  729,747
022C4:  CALL   0D6C
022C8:  MOVFF  03,739
022CC:  MOVFF  02,738
022D0:  MOVFF  01,737
022D4:  MOVFF  00,736
022D8:  MOVFF  03,746
022DC:  MOVFF  02,745
022E0:  MOVFF  01,744
022E4:  MOVFF  00,743
022E8:  MOVFF  72C,74A
022EC:  MOVFF  72B,749
022F0:  MOVFF  72A,748
022F4:  MOVFF  729,747
022F8:  CALL   0D6C
022FC:  MOVFF  03,739
02300:  MOVFF  02,738
02304:  MOVFF  01,737
02308:  MOVFF  00,736
0230C:  BCF    FD8.1
0230E:  MOVFF  03,74A
02312:  MOVFF  02,749
02316:  MOVFF  01,748
0231A:  MOVFF  00,747
0231E:  MOVLW  33
02320:  MOVLB  7
02322:  MOVWF  x4E
02324:  MOVLW  8C
02326:  MOVWF  x4D
02328:  MOVLW  1E
0232A:  MOVWF  x4C
0232C:  MOVLW  83
0232E:  MOVWF  x4B
02330:  MOVLB  0
02332:  CALL   0E62
02336:  MOVFF  03,734
0233A:  MOVFF  02,733
0233E:  MOVFF  01,732
02342:  MOVFF  00,731
.................... 
....................    res = y*res/r;
02346:  MOVFF  72C,746
0234A:  MOVFF  72B,745
0234E:  MOVFF  72A,744
02352:  MOVFF  729,743
02356:  MOVFF  730,74A
0235A:  MOVFF  72F,749
0235E:  MOVFF  72E,748
02362:  MOVFF  72D,747
02366:  CALL   0D6C
0236A:  MOVFF  03,739
0236E:  MOVFF  02,738
02372:  MOVFF  01,737
02376:  MOVFF  00,736
0237A:  MOVFF  03,73F
0237E:  MOVFF  02,73E
02382:  MOVFF  01,73D
02386:  MOVFF  00,73C
0238A:  MOVFF  734,743
0238E:  MOVFF  733,742
02392:  MOVFF  732,741
02396:  MOVFF  731,740
0239A:  RCALL  1D82
0239C:  MOVFF  03,730
023A0:  MOVFF  02,72F
023A4:  MOVFF  01,72E
023A8:  MOVFF  00,72D
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
023AC:  MOVLB  7
023AE:  BTFSS  x35.1
023B0:  BRA    23EC
....................       res = PI_DIV_BY_TWO - res;
023B2:  BSF    FD8.1
023B4:  MOVLW  DB
023B6:  MOVWF  x4A
023B8:  MOVLW  0F
023BA:  MOVWF  x49
023BC:  MOVLW  49
023BE:  MOVWF  x48
023C0:  MOVLW  7F
023C2:  MOVWF  x47
023C4:  MOVFF  730,74E
023C8:  MOVFF  72F,74D
023CC:  MOVFF  72E,74C
023D0:  MOVFF  72D,74B
023D4:  MOVLB  0
023D6:  CALL   0E62
023DA:  MOVFF  03,730
023DE:  MOVFF  02,72F
023E2:  MOVFF  01,72E
023E6:  MOVFF  00,72D
023EA:  MOVLB  7
....................    if (s)
023EC:  BTFSS  x35.0
023EE:  BRA    23F6
....................       res = -res;
023F0:  MOVF   x2E,W
023F2:  XORLW  80
023F4:  MOVWF  x2E
.................... 
....................    return(res);
023F6:  MOVFF  72D,00
023FA:  MOVFF  72E,01
023FE:  MOVFF  72F,02
02402:  MOVFF  730,03
02406:  MOVLB  0
02408:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
0240A:  MOVLB  7
0240C:  BCF    x23.0
....................    quad=0; //quadrant
0240E:  CLRF   x24
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02410:  MOVFF  71A,746
02414:  MOVFF  719,745
02418:  MOVFF  718,744
0241C:  MOVFF  717,743
02420:  CLRF   x4A
02422:  CLRF   x49
02424:  CLRF   x48
02426:  CLRF   x47
02428:  MOVLB  0
0242A:  RCALL  1D08
0242C:  BC    2430
0242E:  BNZ   245A
02430:  MOVFF  71E,746
02434:  MOVFF  71D,745
02438:  MOVFF  71C,744
0243C:  MOVFF  71B,743
02440:  MOVLB  7
02442:  CLRF   x4A
02444:  CLRF   x49
02446:  CLRF   x48
02448:  CLRF   x47
0244A:  MOVLB  0
0244C:  RCALL  1D08
0244E:  BC    2452
02450:  BNZ   2456
02452:  MOVLW  03
02454:  BRA    2458
02456:  MOVLW  04
02458:  BRA    2480
0245A:  MOVFF  71E,746
0245E:  MOVFF  71D,745
02462:  MOVFF  71C,744
02466:  MOVFF  71B,743
0246A:  MOVLB  7
0246C:  CLRF   x4A
0246E:  CLRF   x49
02470:  CLRF   x48
02472:  CLRF   x47
02474:  MOVLB  0
02476:  RCALL  1D08
02478:  BNC   247E
0247A:  MOVLW  02
0247C:  BRA    2480
0247E:  MOVLW  01
02480:  MOVLB  7
02482:  MOVWF  x24
....................    if(y<0.0)
02484:  MOVFF  71A,746
02488:  MOVFF  719,745
0248C:  MOVFF  718,744
02490:  MOVFF  717,743
02494:  CLRF   x4A
02496:  CLRF   x49
02498:  CLRF   x48
0249A:  CLRF   x47
0249C:  MOVLB  0
0249E:  RCALL  1D08
024A0:  BNC   24AE
....................    {
....................       sign=1;
024A2:  MOVLB  7
024A4:  BSF    x23.0
....................       y=-y;
024A6:  MOVF   x18,W
024A8:  XORLW  80
024AA:  MOVWF  x18
024AC:  MOVLB  0
....................    }
....................    if(x<0.0)
024AE:  MOVFF  71E,746
024B2:  MOVFF  71D,745
024B6:  MOVFF  71C,744
024BA:  MOVFF  71B,743
024BE:  MOVLB  7
024C0:  CLRF   x4A
024C2:  CLRF   x49
024C4:  CLRF   x48
024C6:  CLRF   x47
024C8:  MOVLB  0
024CA:  RCALL  1D08
024CC:  BNC   24D8
....................    {
....................       x=-x;
024CE:  MOVLB  7
024D0:  MOVF   x1C,W
024D2:  XORLW  80
024D4:  MOVWF  x1C
024D6:  MOVLB  0
....................    }
....................    if (x==0.0)
024D8:  MOVFF  71E,746
024DC:  MOVFF  71D,745
024E0:  MOVFF  71C,744
024E4:  MOVFF  71B,743
024E8:  MOVLB  7
024EA:  CLRF   x4A
024EC:  CLRF   x49
024EE:  CLRF   x48
024F0:  CLRF   x47
024F2:  MOVLB  0
024F4:  RCALL  1D08
024F6:  BNZ   254C
....................    {
....................       if(y==0.0)
024F8:  MOVFF  71A,746
024FC:  MOVFF  719,745
02500:  MOVFF  718,744
02504:  MOVFF  717,743
02508:  MOVLB  7
0250A:  CLRF   x4A
0250C:  CLRF   x49
0250E:  CLRF   x48
02510:  CLRF   x47
02512:  MOVLB  0
02514:  CALL   1D08
02518:  BNZ   251C
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
0251A:  BRA    254A
....................       else
....................       {
....................          if(sign)
0251C:  MOVLB  7
0251E:  BTFSS  x23.0
02520:  BRA    2536
....................          {
....................          return (-(PI_DIV_BY_TWO));
02522:  MOVLW  7F
02524:  MOVWF  00
02526:  MOVLW  C9
02528:  MOVWF  01
0252A:  MOVLW  0F
0252C:  MOVWF  02
0252E:  MOVLW  DB
02530:  MOVWF  03
02532:  BRA    2684
....................          }
02534:  BRA    2548
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02536:  MOVLW  7F
02538:  MOVWF  00
0253A:  MOVLW  49
0253C:  MOVWF  01
0253E:  MOVLW  0F
02540:  MOVWF  02
02542:  MOVLW  DB
02544:  MOVWF  03
02546:  BRA    2684
02548:  MOVLB  0
....................          }
....................       }
....................    }
0254A:  BRA    2682
....................    else
....................    {
....................       z=y/x;
0254C:  MOVFF  71A,73F
02550:  MOVFF  719,73E
02554:  MOVFF  718,73D
02558:  MOVFF  717,73C
0255C:  MOVFF  71E,743
02560:  MOVFF  71D,742
02564:  MOVFF  71C,741
02568:  MOVFF  71B,740
0256C:  RCALL  1D82
0256E:  MOVFF  03,722
02572:  MOVFF  02,721
02576:  MOVFF  01,720
0257A:  MOVFF  00,71F
....................       switch(quad)
0257E:  MOVLW  01
02580:  MOVLB  7
02582:  SUBWF  x24,W
02584:  ADDLW  FC
02586:  BTFSC  FD8.0
02588:  BRA    2684
0258A:  ADDLW  04
0258C:  MOVLB  0
0258E:  GOTO   268A
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02592:  MOVFF  722,728
02596:  MOVFF  721,727
0259A:  MOVFF  720,726
0259E:  MOVFF  71F,725
025A2:  RCALL  1EE0
025A4:  MOVLB  7
025A6:  BRA    2684
....................             break;
025A8:  BRA    2684
025AA:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
025AC:  MOVFF  722,728
025B0:  MOVFF  721,727
025B4:  MOVFF  720,726
025B8:  MOVFF  71F,725
025BC:  RCALL  1EE0
025BE:  MOVFF  FEA,726
025C2:  MOVFF  FE9,725
025C6:  BSF    FD8.1
025C8:  MOVLW  DB
025CA:  MOVLB  7
025CC:  MOVWF  x4A
025CE:  MOVLW  0F
025D0:  MOVWF  x49
025D2:  MOVLW  49
025D4:  MOVWF  x48
025D6:  MOVLW  80
025D8:  MOVWF  x47
025DA:  MOVFF  03,74E
025DE:  MOVFF  02,74D
025E2:  MOVFF  01,74C
025E6:  MOVFF  00,74B
025EA:  MOVLB  0
025EC:  CALL   0E62
025F0:  MOVFF  726,FEA
025F4:  MOVFF  725,FE9
025F8:  MOVLB  7
025FA:  BRA    2684
....................             break;
025FC:  BRA    2684
025FE:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02600:  MOVFF  722,728
02604:  MOVFF  721,727
02608:  MOVFF  720,726
0260C:  MOVFF  71F,725
02610:  RCALL  1EE0
02612:  MOVFF  03,728
02616:  MOVFF  02,727
0261A:  MOVFF  01,726
0261E:  MOVFF  00,725
02622:  MOVFF  FEA,72A
02626:  MOVFF  FE9,729
0262A:  BSF    FD8.1
0262C:  MOVFF  03,74A
02630:  MOVFF  02,749
02634:  MOVFF  01,748
02638:  MOVFF  00,747
0263C:  MOVLW  DB
0263E:  MOVLB  7
02640:  MOVWF  x4E
02642:  MOVLW  0F
02644:  MOVWF  x4D
02646:  MOVLW  49
02648:  MOVWF  x4C
0264A:  MOVLW  80
0264C:  MOVWF  x4B
0264E:  MOVLB  0
02650:  CALL   0E62
02654:  MOVFF  72A,FEA
02658:  MOVFF  729,FE9
0265C:  MOVLB  7
0265E:  BRA    2684
....................             break;
02660:  BRA    2684
02662:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02664:  MOVFF  722,728
02668:  MOVFF  721,727
0266C:  MOVFF  720,726
02670:  MOVFF  71F,725
02674:  RCALL  1EE0
02676:  MOVLW  80
02678:  XORWF  01,F
0267A:  MOVLB  7
0267C:  BRA    2684
....................             break;
0267E:  BRA    2684
02680:  MOVLB  0
02682:  MOVLB  7
....................          }
....................       }
....................    }
02684:  MOVLB  0
02686:  GOTO   3DDA (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008C2:  MOVFF  724,FEA
008C6:  MOVLB  7
008C8:  MOVFF  723,FE9
008CC:  CLRF   x31
008CE:  MOVFF  FEF,730
008D2:  CLRF   x33
008D4:  MOVLW  04
008D6:  MOVWF  x32
008D8:  MOVLB  0
008DA:  RCALL  0874
008DC:  MOVF   01,W
008DE:  MOVLB  7
008E0:  ADDWF  x21,W
008E2:  MOVWF  FE9
008E4:  MOVF   x22,W
008E6:  ADDWFC 02,W
008E8:  MOVWF  FEA
008EA:  MOVFF  725,FEF
008EE:  MOVFF  726,FEC
008F2:  MOVFF  727,FEC
008F6:  MOVFF  728,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
008FA:  MOVFF  724,72A
008FE:  MOVFF  724,FEA
00902:  MOVFF  723,FE9
00906:  MOVLW  01
00908:  ADDWF  FEF,W
0090A:  MOVWF  x2C
0090C:  MOVWF  x2F
0090E:  MOVLW  05
00910:  MOVWF  x30
00912:  MOVLB  0
00914:  RCALL  0896
00916:  MOVLB  7
00918:  MOVFF  72A,FEA
0091C:  MOVFF  723,FE9
00920:  MOVFF  00,FEF
00924:  MOVLB  0
00926:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
010DA:  MOVLB  F
010DC:  BTFSC  x5B.0
010DE:  BRA    162A
....................       switch (state)
010E0:  MOVLB  1
010E2:  MOVF   xE4,W
010E4:  ADDLW  F9
010E6:  BTFSC  FD8.0
010E8:  BRA    1628
010EA:  ADDLW  07
010EC:  MOVLB  0
010EE:  GOTO   1630
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
010F2:  MOVLB  F
010F4:  BTFSC  x5B.0
010F6:  BRA    10F4
010F8:  MOVFF  F5F,02
010FC:  MOVFF  F5E,01
01100:  MOVFF  02,6F0
01104:  MOVFF  01,6EF
01108:  MOVFF  02,748
0110C:  MOVFF  01,747
01110:  MOVLB  0
01112:  RCALL  0D36
01114:  MOVFF  03,746
01118:  MOVFF  02,745
0111C:  MOVFF  01,744
01120:  MOVFF  00,743
01124:  MOVFF  B9,74A
01128:  MOVFF  B8,749
0112C:  MOVFF  B7,748
01130:  MOVFF  B6,747
01134:  RCALL  0D6C
01136:  MOVFF  03,6F2
0113A:  MOVFF  02,6F1
0113E:  MOVFF  01,6F0
01142:  MOVFF  00,6EF
01146:  BCF    FD8.1
01148:  MOVFF  03,74A
0114C:  MOVFF  02,749
01150:  MOVFF  01,748
01154:  MOVFF  00,747
01158:  MOVFF  B5,74E
0115C:  MOVFF  B4,74D
01160:  MOVFF  B3,74C
01164:  MOVFF  B2,74B
01168:  RCALL  0E62
0116A:  MOVFF  03,EE
0116E:  MOVFF  02,ED
01172:  MOVFF  01,EC
01176:  MOVFF  00,EB
....................             set_adc_channel(vMon200);
0117A:  MOVLB  F
0117C:  MOVF   x5A,W
0117E:  ANDLW  3F
01180:  MOVWF  01
01182:  MOVLW  10
01184:  MOVWF  x5A
01186:  BTFSS  x5B.7
01188:  BRA    1198
0118A:  MOVF   01,W
0118C:  SUBLW  10
0118E:  BZ    1198
01190:  BSF    x5B.0
01192:  NOP   
01194:  BTFSC  x5B.0
01196:  BRA    1194
....................             delay_ms(10);
01198:  MOVLW  0A
0119A:  MOVLB  6
0119C:  MOVWF  xF5
0119E:  MOVLB  0
011A0:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
011A4:  MOVLB  F
011A6:  BSF    x5B.0
011A8:  NOP   
....................             state = 1;
011AA:  MOVLW  01
011AC:  MOVLB  1
011AE:  MOVWF  xE4
....................          break;
011B0:  BRA    1628
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011B2:  MOVLB  F
011B4:  BTFSC  x5B.0
011B6:  BRA    11B4
011B8:  MOVFF  F5F,02
011BC:  MOVFF  F5E,01
011C0:  MOVFF  02,6F0
011C4:  MOVFF  01,6EF
011C8:  MOVFF  02,748
011CC:  MOVFF  01,747
011D0:  MOVLB  0
011D2:  RCALL  0D36
011D4:  MOVFF  03,746
011D8:  MOVFF  02,745
011DC:  MOVFF  01,744
011E0:  MOVFF  00,743
011E4:  MOVFF  C1,74A
011E8:  MOVFF  C0,749
011EC:  MOVFF  BF,748
011F0:  MOVFF  BE,747
011F4:  RCALL  0D6C
011F6:  MOVFF  03,6F2
011FA:  MOVFF  02,6F1
011FE:  MOVFF  01,6F0
01202:  MOVFF  00,6EF
01206:  BCF    FD8.1
01208:  MOVFF  03,74A
0120C:  MOVFF  02,749
01210:  MOVFF  01,748
01214:  MOVFF  00,747
01218:  MOVFF  BD,74E
0121C:  MOVFF  BC,74D
01220:  MOVFF  BB,74C
01224:  MOVFF  BA,74B
01228:  RCALL  0E62
0122A:  MOVFF  03,F2
0122E:  MOVFF  02,F1
01232:  MOVFF  01,F0
01236:  MOVFF  00,EF
....................             set_adc_channel(vMon5V6);
0123A:  MOVLB  F
0123C:  MOVF   x5A,W
0123E:  ANDLW  3F
01240:  MOVWF  01
01242:  MOVLW  18
01244:  MOVWF  x5A
01246:  BTFSS  x5B.7
01248:  BRA    1258
0124A:  MOVF   01,W
0124C:  SUBLW  18
0124E:  BZ    1258
01250:  BSF    x5B.0
01252:  NOP   
01254:  BTFSC  x5B.0
01256:  BRA    1254
....................             delay_ms(10);
01258:  MOVLW  0A
0125A:  MOVLB  6
0125C:  MOVWF  xF5
0125E:  MOVLB  0
01260:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
01264:  MOVLB  F
01266:  BSF    x5B.0
01268:  NOP   
....................             state = 2;
0126A:  MOVLW  02
0126C:  MOVLB  1
0126E:  MOVWF  xE4
....................          break;
01270:  BRA    1628
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01272:  MOVLB  F
01274:  BTFSC  x5B.0
01276:  BRA    1274
01278:  MOVFF  F5F,02
0127C:  MOVFF  F5E,01
01280:  MOVFF  02,6F0
01284:  MOVFF  01,6EF
01288:  MOVFF  02,748
0128C:  MOVFF  01,747
01290:  MOVLB  0
01292:  RCALL  0D36
01294:  MOVFF  03,746
01298:  MOVFF  02,745
0129C:  MOVFF  01,744
012A0:  MOVFF  00,743
012A4:  MOVFF  C9,74A
012A8:  MOVFF  C8,749
012AC:  MOVFF  C7,748
012B0:  MOVFF  C6,747
012B4:  RCALL  0D6C
012B6:  MOVFF  03,6F2
012BA:  MOVFF  02,6F1
012BE:  MOVFF  01,6F0
012C2:  MOVFF  00,6EF
012C6:  BCF    FD8.1
012C8:  MOVFF  03,74A
012CC:  MOVFF  02,749
012D0:  MOVFF  01,748
012D4:  MOVFF  00,747
012D8:  MOVFF  C5,74E
012DC:  MOVFF  C4,74D
012E0:  MOVFF  C3,74C
012E4:  MOVFF  C2,74B
012E8:  RCALL  0E62
012EA:  MOVFF  03,F6
012EE:  MOVFF  02,F5
012F2:  MOVFF  01,F4
012F6:  MOVFF  00,F3
....................             set_adc_channel(vMon5VA);
012FA:  MOVLB  F
012FC:  MOVF   x5A,W
012FE:  ANDLW  3F
01300:  MOVWF  01
01302:  MOVLW  19
01304:  MOVWF  x5A
01306:  BTFSS  x5B.7
01308:  BRA    1318
0130A:  MOVF   01,W
0130C:  SUBLW  19
0130E:  BZ    1318
01310:  BSF    x5B.0
01312:  NOP   
01314:  BTFSC  x5B.0
01316:  BRA    1314
....................             delay_ms(10);
01318:  MOVLW  0A
0131A:  MOVLB  6
0131C:  MOVWF  xF5
0131E:  MOVLB  0
01320:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
01324:  MOVLB  F
01326:  BSF    x5B.0
01328:  NOP   
....................             state = 3;
0132A:  MOVLW  03
0132C:  MOVLB  1
0132E:  MOVWF  xE4
....................          break;
01330:  BRA    1628
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01332:  MOVLB  F
01334:  BTFSC  x5B.0
01336:  BRA    1334
01338:  MOVFF  F5F,02
0133C:  MOVFF  F5E,01
01340:  MOVFF  02,6F0
01344:  MOVFF  01,6EF
01348:  MOVFF  02,748
0134C:  MOVFF  01,747
01350:  MOVLB  0
01352:  RCALL  0D36
01354:  MOVFF  03,746
01358:  MOVFF  02,745
0135C:  MOVFF  01,744
01360:  MOVFF  00,743
01364:  MOVFF  D1,74A
01368:  MOVFF  D0,749
0136C:  MOVFF  CF,748
01370:  MOVFF  CE,747
01374:  RCALL  0D6C
01376:  MOVFF  03,6F2
0137A:  MOVFF  02,6F1
0137E:  MOVFF  01,6F0
01382:  MOVFF  00,6EF
01386:  BCF    FD8.1
01388:  MOVFF  03,74A
0138C:  MOVFF  02,749
01390:  MOVFF  01,748
01394:  MOVFF  00,747
01398:  MOVFF  CD,74E
0139C:  MOVFF  CC,74D
013A0:  MOVFF  CB,74C
013A4:  MOVFF  CA,74B
013A8:  RCALL  0E62
013AA:  MOVFF  03,FA
013AE:  MOVFF  02,F9
013B2:  MOVFF  01,F8
013B6:  MOVFF  00,F7
....................             set_adc_channel(vMon3V6X);
013BA:  MOVLB  F
013BC:  MOVF   x5A,W
013BE:  ANDLW  3F
013C0:  MOVWF  01
013C2:  MOVLW  11
013C4:  MOVWF  x5A
013C6:  BTFSS  x5B.7
013C8:  BRA    13D8
013CA:  MOVF   01,W
013CC:  SUBLW  11
013CE:  BZ    13D8
013D0:  BSF    x5B.0
013D2:  NOP   
013D4:  BTFSC  x5B.0
013D6:  BRA    13D4
....................             delay_ms(10);
013D8:  MOVLW  0A
013DA:  MOVLB  6
013DC:  MOVWF  xF5
013DE:  MOVLB  0
013E0:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
013E4:  MOVLB  F
013E6:  BSF    x5B.0
013E8:  NOP   
....................             state = 4;
013EA:  MOVLW  04
013EC:  MOVLB  1
013EE:  MOVWF  xE4
....................          break;
013F0:  BRA    1628
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
013F2:  MOVLB  F
013F4:  BTFSC  x5B.0
013F6:  BRA    13F4
013F8:  MOVFF  F5F,02
013FC:  MOVFF  F5E,01
01400:  MOVFF  02,6F0
01404:  MOVFF  01,6EF
01408:  MOVFF  02,748
0140C:  MOVFF  01,747
01410:  MOVLB  0
01412:  RCALL  0D36
01414:  MOVFF  03,746
01418:  MOVFF  02,745
0141C:  MOVFF  01,744
01420:  MOVFF  00,743
01424:  MOVFF  D9,74A
01428:  MOVFF  D8,749
0142C:  MOVFF  D7,748
01430:  MOVFF  D6,747
01434:  RCALL  0D6C
01436:  MOVFF  03,6F2
0143A:  MOVFF  02,6F1
0143E:  MOVFF  01,6F0
01442:  MOVFF  00,6EF
01446:  BCF    FD8.1
01448:  MOVFF  03,74A
0144C:  MOVFF  02,749
01450:  MOVFF  01,748
01454:  MOVFF  00,747
01458:  MOVFF  D5,74E
0145C:  MOVFF  D4,74D
01460:  MOVFF  D3,74C
01464:  MOVFF  D2,74B
01468:  RCALL  0E62
0146A:  MOVFF  03,FE
0146E:  MOVFF  02,FD
01472:  MOVFF  01,FC
01476:  MOVFF  00,FB
....................             set_adc_channel(vMon3V3A);
0147A:  MOVLB  F
0147C:  MOVF   x5A,W
0147E:  ANDLW  3F
01480:  MOVWF  01
01482:  MOVLW  1B
01484:  MOVWF  x5A
01486:  BTFSS  x5B.7
01488:  BRA    1498
0148A:  MOVF   01,W
0148C:  SUBLW  1B
0148E:  BZ    1498
01490:  BSF    x5B.0
01492:  NOP   
01494:  BTFSC  x5B.0
01496:  BRA    1494
....................             delay_ms(10);
01498:  MOVLW  0A
0149A:  MOVLB  6
0149C:  MOVWF  xF5
0149E:  MOVLB  0
014A0:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
014A4:  MOVLB  F
014A6:  BSF    x5B.0
014A8:  NOP   
....................             state = 5;
014AA:  MOVLW  05
014AC:  MOVLB  1
014AE:  MOVWF  xE4
....................          break;
014B0:  BRA    1628
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014B2:  MOVLB  F
014B4:  BTFSC  x5B.0
014B6:  BRA    14B4
014B8:  MOVFF  F5F,02
014BC:  MOVFF  F5E,01
014C0:  MOVFF  02,6F0
014C4:  MOVFF  01,6EF
014C8:  MOVFF  02,748
014CC:  MOVFF  01,747
014D0:  MOVLB  0
014D2:  RCALL  0D36
014D4:  MOVFF  03,746
014D8:  MOVFF  02,745
014DC:  MOVFF  01,744
014E0:  MOVFF  00,743
014E4:  MOVFF  E1,74A
014E8:  MOVFF  E0,749
014EC:  MOVFF  DF,748
014F0:  MOVFF  DE,747
014F4:  RCALL  0D6C
014F6:  MOVFF  03,6F2
014FA:  MOVFF  02,6F1
014FE:  MOVFF  01,6F0
01502:  MOVFF  00,6EF
01506:  BCF    FD8.1
01508:  MOVFF  03,74A
0150C:  MOVFF  02,749
01510:  MOVFF  01,748
01514:  MOVFF  00,747
01518:  MOVFF  DD,74E
0151C:  MOVFF  DC,74D
01520:  MOVFF  DB,74C
01524:  MOVFF  DA,74B
01528:  RCALL  0E62
0152A:  MOVFF  03,102
0152E:  MOVFF  02,101
01532:  MOVFF  01,100
01536:  MOVFF  00,FF
....................             set_adc_channel(vMon3V3D);
0153A:  MOVLB  F
0153C:  MOVF   x5A,W
0153E:  ANDLW  3F
01540:  MOVWF  01
01542:  MOVLW  1A
01544:  MOVWF  x5A
01546:  BTFSS  x5B.7
01548:  BRA    1558
0154A:  MOVF   01,W
0154C:  SUBLW  1A
0154E:  BZ    1558
01550:  BSF    x5B.0
01552:  NOP   
01554:  BTFSC  x5B.0
01556:  BRA    1554
....................             delay_ms(10);
01558:  MOVLW  0A
0155A:  MOVLB  6
0155C:  MOVWF  xF5
0155E:  MOVLB  0
01560:  CALL   03A4
....................             read_adc(ADC_START_ONLY);
01564:  MOVLB  F
01566:  BSF    x5B.0
01568:  NOP   
....................             state = 6;
0156A:  MOVLW  06
0156C:  MOVLB  1
0156E:  MOVWF  xE4
....................          break;
01570:  BRA    1628
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01572:  MOVLB  F
01574:  BTFSC  x5B.0
01576:  BRA    1574
01578:  MOVFF  F5F,02
0157C:  MOVFF  F5E,01
01580:  MOVFF  02,6F0
01584:  MOVFF  01,6EF
01588:  MOVFF  02,748
0158C:  MOVFF  01,747
01590:  MOVLB  0
01592:  CALL   0D36
01596:  MOVFF  03,746
0159A:  MOVFF  02,745
0159E:  MOVFF  01,744
015A2:  MOVFF  00,743
015A6:  MOVFF  E9,74A
015AA:  MOVFF  E8,749
015AE:  MOVFF  E7,748
015B2:  MOVFF  E6,747
015B6:  CALL   0D6C
015BA:  MOVFF  03,6F2
015BE:  MOVFF  02,6F1
015C2:  MOVFF  01,6F0
015C6:  MOVFF  00,6EF
015CA:  BCF    FD8.1
015CC:  MOVFF  03,74A
015D0:  MOVFF  02,749
015D4:  MOVFF  01,748
015D8:  MOVFF  00,747
015DC:  MOVFF  E5,74E
015E0:  MOVFF  E4,74D
015E4:  MOVFF  E3,74C
015E8:  MOVFF  E2,74B
015EC:  RCALL  0E62
015EE:  MOVFF  03,106
015F2:  MOVFF  02,105
015F6:  MOVFF  01,104
015FA:  MOVFF  00,103
....................             set_adc_channel(vMonN15);
015FE:  MOVLB  F
01600:  MOVF   x5A,W
01602:  ANDLW  3F
01604:  MOVWF  01
01606:  MOVLW  06
01608:  MOVWF  x5A
0160A:  BTFSS  x5B.7
0160C:  BRA    161C
0160E:  MOVF   01,W
01610:  SUBLW  06
01612:  BZ    161C
01614:  BSF    x5B.0
01616:  NOP   
01618:  BTFSC  x5B.0
0161A:  BRA    1618
....................             read_adc(ADC_START_ONLY);
0161C:  BSF    x5B.0
0161E:  NOP   
....................             state = 0;
01620:  MOVLB  1
01622:  CLRF   xE4
....................          break;   
01624:  BRA    1628
01626:  MOVLB  1
01628:  MOVLB  F
....................       }
....................    }
0162A:  MOVLB  0
0162C:  GOTO   A77A (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
036E8:  MOVLB  6
036EA:  MOVF   xF7,W
036EC:  MULLW  2D
036EE:  MOVF   FF3,W
036F0:  MOVLB  7
036F2:  CLRF   x01
036F4:  MOVWF  x00
036F6:  MOVLW  10
036F8:  ADDWF  x00,W
036FA:  MOVWF  01
036FC:  MOVLW  00
036FE:  ADDWFC x01,W
03700:  MOVWF  03
03702:  MOVF   01,W
03704:  ADDLW  07
03706:  MOVWF  01
03708:  MOVLW  01
0370A:  ADDWFC 03,F
0370C:  MOVFF  01,700
03710:  MOVFF  03,701
03714:  MOVLB  6
03716:  MOVF   xF7,W
03718:  MULLW  2D
0371A:  MOVF   FF3,W
0371C:  MOVLB  7
0371E:  CLRF   x03
03720:  MOVWF  x02
03722:  MOVLW  08
03724:  ADDWF  x02,W
03726:  MOVWF  01
03728:  MOVLW  00
0372A:  ADDWFC x03,W
0372C:  MOVWF  03
0372E:  MOVF   01,W
03730:  ADDLW  07
03732:  MOVWF  FE9
03734:  MOVLW  01
03736:  ADDWFC 03,W
03738:  MOVWF  FEA
0373A:  MOVFF  FEF,00
0373E:  MOVFF  FEC,01
03742:  MOVFF  FEC,02
03746:  MOVFF  FEC,03
0374A:  MOVFF  701,FEA
0374E:  MOVFF  700,FE9
03752:  MOVFF  00,FEF
03756:  MOVFF  01,FEC
0375A:  MOVFF  02,FEC
0375E:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03762:  MOVLB  6
03764:  MOVF   xF7,W
03766:  MULLW  2D
03768:  MOVF   FF3,W
0376A:  MOVLB  7
0376C:  CLRF   x01
0376E:  MOVWF  x00
03770:  MOVLW  14
03772:  ADDWF  x00,W
03774:  MOVWF  01
03776:  MOVLW  00
03778:  ADDWFC x01,W
0377A:  MOVWF  03
0377C:  MOVF   01,W
0377E:  ADDLW  07
03780:  MOVWF  01
03782:  MOVLW  01
03784:  ADDWFC 03,F
03786:  MOVFF  01,700
0378A:  MOVFF  03,701
0378E:  MOVLB  6
03790:  MOVF   xF7,W
03792:  MULLW  2D
03794:  MOVF   FF3,W
03796:  MOVLB  7
03798:  CLRF   x03
0379A:  MOVWF  x02
0379C:  MOVLW  0C
0379E:  ADDWF  x02,W
037A0:  MOVWF  01
037A2:  MOVLW  00
037A4:  ADDWFC x03,W
037A6:  MOVWF  03
037A8:  MOVF   01,W
037AA:  ADDLW  07
037AC:  MOVWF  FE9
037AE:  MOVLW  01
037B0:  ADDWFC 03,W
037B2:  MOVWF  FEA
037B4:  MOVFF  FEF,00
037B8:  MOVFF  FEC,01
037BC:  MOVFF  FEC,02
037C0:  MOVFF  FEC,03
037C4:  MOVFF  701,FEA
037C8:  MOVFF  700,FE9
037CC:  MOVFF  00,FEF
037D0:  MOVFF  01,FEC
037D4:  MOVFF  02,FEC
037D8:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037DC:  MOVLB  6
037DE:  MOVF   xF7,W
037E0:  MULLW  2D
037E2:  MOVF   FF3,W
037E4:  MOVLB  7
037E6:  CLRF   x01
037E8:  MOVWF  x00
037EA:  MOVLW  07
037EC:  ADDWF  x00,W
037EE:  MOVWF  01
037F0:  MOVLW  01
037F2:  ADDWFC x01,W
037F4:  MOVWF  03
037F6:  MOVFF  01,702
037FA:  MOVWF  x03
037FC:  MOVLB  6
037FE:  MOVF   xF7,W
03800:  MULLW  09
03802:  MOVF   FF3,W
03804:  MOVLB  7
03806:  CLRF   x05
03808:  MOVWF  x04
0380A:  MOVLW  01
0380C:  ADDWF  x04,W
0380E:  MOVWF  01
03810:  MOVLW  00
03812:  ADDWFC x05,W
03814:  MOVWF  03
03816:  MOVF   01,W
03818:  ADDLW  D2
0381A:  MOVWF  FE9
0381C:  MOVLW  01
0381E:  ADDWFC 03,W
03820:  MOVWF  FEA
03822:  MOVFF  FEF,70D
03826:  MOVFF  FEC,01
0382A:  MOVFF  FEC,02
0382E:  MOVFF  FEC,03
03832:  MOVFF  03,710
03836:  MOVFF  02,70F
0383A:  MOVFF  01,70E
0383E:  MOVLB  0
03840:  CALL   1CAE
03844:  MOVFF  703,FEA
03848:  MOVFF  702,FE9
0384C:  MOVFF  00,FEF
03850:  MOVFF  01,FEC
03854:  MOVFF  02,FEC
03858:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
0385C:  MOVLB  6
0385E:  MOVF   xF7,W
03860:  MULLW  2D
03862:  MOVF   FF3,W
03864:  MOVLB  7
03866:  CLRF   x01
03868:  MOVWF  x00
0386A:  MOVLW  04
0386C:  ADDWF  x00,W
0386E:  MOVWF  01
03870:  MOVLW  00
03872:  ADDWFC x01,W
03874:  MOVWF  03
03876:  MOVF   01,W
03878:  ADDLW  07
0387A:  MOVWF  01
0387C:  MOVLW  01
0387E:  ADDWFC 03,F
03880:  MOVFF  01,700
03884:  MOVFF  03,701
03888:  MOVLB  6
0388A:  MOVF   xF7,W
0388C:  MULLW  09
0388E:  MOVF   FF3,W
03890:  MOVLB  7
03892:  CLRF   x03
03894:  MOVWF  x02
03896:  MOVLW  05
03898:  ADDWF  x02,W
0389A:  MOVWF  01
0389C:  MOVLW  00
0389E:  ADDWFC x03,W
038A0:  MOVWF  03
038A2:  MOVF   01,W
038A4:  ADDLW  D2
038A6:  MOVWF  FE9
038A8:  MOVLW  01
038AA:  ADDWFC 03,W
038AC:  MOVWF  FEA
038AE:  MOVFF  FEF,70D
038B2:  MOVFF  FEC,01
038B6:  MOVFF  FEC,02
038BA:  MOVFF  FEC,03
038BE:  MOVFF  03,710
038C2:  MOVFF  02,70F
038C6:  MOVFF  01,70E
038CA:  MOVLB  0
038CC:  CALL   1CAE
038D0:  MOVFF  701,FEA
038D4:  MOVFF  700,FE9
038D8:  MOVFF  00,FEF
038DC:  MOVFF  01,FEC
038E0:  MOVFF  02,FEC
038E4:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038E8:  MOVLB  6
038EA:  MOVF   xF7,W
038EC:  MULLW  2D
038EE:  MOVF   FF3,W
038F0:  MOVLB  7
038F2:  CLRF   x01
038F4:  MOVWF  x00
038F6:  MOVLW  08
038F8:  ADDWF  x00,W
038FA:  MOVWF  01
038FC:  MOVLW  00
038FE:  ADDWFC x01,W
03900:  MOVWF  03
03902:  MOVF   01,W
03904:  ADDLW  07
03906:  MOVWF  01
03908:  MOVLW  01
0390A:  ADDWFC 03,F
0390C:  MOVFF  01,700
03910:  MOVFF  03,701
03914:  MOVLB  6
03916:  MOVF   xF7,W
03918:  MULLW  2D
0391A:  MOVF   FF3,W
0391C:  MOVLB  7
0391E:  CLRF   x03
03920:  MOVWF  x02
03922:  MOVLW  07
03924:  ADDWF  x02,W
03926:  MOVWF  FE9
03928:  MOVLW  01
0392A:  ADDWFC x03,W
0392C:  MOVWF  FEA
0392E:  MOVFF  FEF,743
03932:  MOVFF  FEC,744
03936:  MOVFF  FEC,745
0393A:  MOVFF  FEC,746
0393E:  MOVLB  6
03940:  MOVF   xF7,W
03942:  MULLW  10
03944:  MOVF   FF3,W
03946:  MOVLB  7
03948:  CLRF   x09
0394A:  MOVWF  x08
0394C:  MOVLW  08
0394E:  ADDWF  x08,W
03950:  MOVWF  01
03952:  MOVLW  00
03954:  ADDWFC x09,W
03956:  MOVWF  03
03958:  MOVF   01,W
0395A:  ADDLW  62
0395C:  MOVWF  FE9
0395E:  MOVLW  00
03960:  ADDWFC 03,W
03962:  MOVWF  FEA
03964:  MOVFF  FEF,747
03968:  MOVFF  FEC,01
0396C:  MOVFF  FEC,02
03970:  MOVFF  FEC,03
03974:  MOVFF  03,74A
03978:  MOVFF  02,749
0397C:  MOVFF  01,748
03980:  MOVLB  0
03982:  CALL   0D6C
03986:  MOVFF  03,74A
0398A:  MOVFF  02,749
0398E:  MOVFF  01,748
03992:  MOVFF  00,747
03996:  MOVLB  6
03998:  MOVF   xF7,W
0399A:  MULLW  10
0399C:  MOVF   FF3,W
0399E:  MOVLB  7
039A0:  CLRF   x09
039A2:  MOVWF  x08
039A4:  MOVLW  62
039A6:  ADDWF  x08,W
039A8:  MOVWF  FE9
039AA:  MOVLW  00
039AC:  ADDWFC x09,W
039AE:  MOVWF  FEA
039B0:  MOVFF  FEF,74B
039B4:  MOVFF  FEC,01
039B8:  MOVFF  FEC,02
039BC:  MOVFF  FEC,03
039C0:  BCF    FD8.1
039C2:  MOVFF  03,74E
039C6:  MOVFF  02,74D
039CA:  MOVFF  01,74C
039CE:  MOVLB  0
039D0:  CALL   0E62
039D4:  MOVFF  701,FEA
039D8:  MOVFF  700,FE9
039DC:  MOVFF  00,FEF
039E0:  MOVFF  01,FEC
039E4:  MOVFF  02,FEC
039E8:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039EC:  MOVLB  6
039EE:  MOVF   xF7,W
039F0:  MULLW  2D
039F2:  MOVF   FF3,W
039F4:  MOVLB  7
039F6:  CLRF   x01
039F8:  MOVWF  x00
039FA:  MOVLW  0C
039FC:  ADDWF  x00,W
039FE:  MOVWF  01
03A00:  MOVLW  00
03A02:  ADDWFC x01,W
03A04:  MOVWF  03
03A06:  MOVF   01,W
03A08:  ADDLW  07
03A0A:  MOVWF  01
03A0C:  MOVLW  01
03A0E:  ADDWFC 03,F
03A10:  MOVFF  01,700
03A14:  MOVFF  03,701
03A18:  MOVLB  6
03A1A:  MOVF   xF7,W
03A1C:  MULLW  2D
03A1E:  MOVF   FF3,W
03A20:  MOVLB  7
03A22:  CLRF   x03
03A24:  MOVWF  x02
03A26:  MOVLW  04
03A28:  ADDWF  x02,W
03A2A:  MOVWF  01
03A2C:  MOVLW  00
03A2E:  ADDWFC x03,W
03A30:  MOVWF  03
03A32:  MOVF   01,W
03A34:  ADDLW  07
03A36:  MOVWF  FE9
03A38:  MOVLW  01
03A3A:  ADDWFC 03,W
03A3C:  MOVWF  FEA
03A3E:  MOVFF  FEF,743
03A42:  MOVFF  FEC,744
03A46:  MOVFF  FEC,745
03A4A:  MOVFF  FEC,746
03A4E:  MOVLB  6
03A50:  MOVF   xF7,W
03A52:  MULLW  10
03A54:  MOVF   FF3,W
03A56:  MOVLB  7
03A58:  CLRF   x07
03A5A:  MOVWF  x06
03A5C:  MOVLW  0C
03A5E:  ADDWF  x06,W
03A60:  MOVWF  01
03A62:  MOVLW  00
03A64:  ADDWFC x07,W
03A66:  MOVWF  03
03A68:  MOVF   01,W
03A6A:  ADDLW  62
03A6C:  MOVWF  FE9
03A6E:  MOVLW  00
03A70:  ADDWFC 03,W
03A72:  MOVWF  FEA
03A74:  MOVFF  FEF,747
03A78:  MOVFF  FEC,01
03A7C:  MOVFF  FEC,02
03A80:  MOVFF  FEC,03
03A84:  MOVFF  03,74A
03A88:  MOVFF  02,749
03A8C:  MOVFF  01,748
03A90:  MOVLB  0
03A92:  CALL   0D6C
03A96:  MOVFF  03,74A
03A9A:  MOVFF  02,749
03A9E:  MOVFF  01,748
03AA2:  MOVFF  00,747
03AA6:  MOVLB  6
03AA8:  MOVF   xF7,W
03AAA:  MULLW  10
03AAC:  MOVF   FF3,W
03AAE:  MOVLB  7
03AB0:  CLRF   x07
03AB2:  MOVWF  x06
03AB4:  MOVLW  04
03AB6:  ADDWF  x06,W
03AB8:  MOVWF  01
03ABA:  MOVLW  00
03ABC:  ADDWFC x07,W
03ABE:  MOVWF  03
03AC0:  MOVF   01,W
03AC2:  ADDLW  62
03AC4:  MOVWF  FE9
03AC6:  MOVLW  00
03AC8:  ADDWFC 03,W
03ACA:  MOVWF  FEA
03ACC:  MOVFF  FEF,74B
03AD0:  MOVFF  FEC,01
03AD4:  MOVFF  FEC,02
03AD8:  MOVFF  FEC,03
03ADC:  BCF    FD8.1
03ADE:  MOVFF  03,74E
03AE2:  MOVFF  02,74D
03AE6:  MOVFF  01,74C
03AEA:  MOVLB  0
03AEC:  CALL   0E62
03AF0:  MOVFF  701,FEA
03AF4:  MOVFF  700,FE9
03AF8:  MOVFF  00,FEF
03AFC:  MOVFF  01,FEC
03B00:  MOVFF  02,FEC
03B04:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03B08:  MOVLB  6
03B0A:  CLRF   xFB
03B0C:  CLRF   xFA
03B0E:  CLRF   xF9
03B10:  CLRF   xF8
03B12:  CLRF   xFF
03B14:  CLRF   xFE
03B16:  CLRF   xFD
03B18:  MOVLW  7F
03B1A:  MOVWF  xFC
....................    
....................    if (adcVals[ch].cosCounts < 0){
03B1C:  MOVF   xF7,W
03B1E:  MULLW  2D
03B20:  MOVF   FF3,W
03B22:  MOVLB  7
03B24:  CLRF   x01
03B26:  MOVWF  x00
03B28:  MOVLW  0C
03B2A:  ADDWF  x00,W
03B2C:  MOVWF  01
03B2E:  MOVLW  00
03B30:  ADDWFC x01,W
03B32:  MOVWF  03
03B34:  MOVF   01,W
03B36:  ADDLW  07
03B38:  MOVWF  FE9
03B3A:  MOVLW  01
03B3C:  ADDWFC 03,W
03B3E:  MOVWF  FEA
03B40:  MOVFF  FEF,743
03B44:  MOVFF  FEC,744
03B48:  MOVFF  FEC,745
03B4C:  MOVFF  FEC,746
03B50:  CLRF   x4A
03B52:  CLRF   x49
03B54:  CLRF   x48
03B56:  CLRF   x47
03B58:  MOVLB  0
03B5A:  CALL   1D08
03B5E:  BTFSS  FD8.0
03B60:  BRA    3CD6
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B62:  MOVLB  6
03B64:  MOVF   xF7,W
03B66:  MULLW  2D
03B68:  MOVF   FF3,W
03B6A:  MOVLB  7
03B6C:  CLRF   x01
03B6E:  MOVWF  x00
03B70:  MOVLW  08
03B72:  ADDWF  x00,W
03B74:  MOVWF  01
03B76:  MOVLW  00
03B78:  ADDWFC x01,W
03B7A:  MOVWF  03
03B7C:  MOVF   01,W
03B7E:  ADDLW  07
03B80:  MOVWF  FE9
03B82:  MOVLW  01
03B84:  ADDWFC 03,W
03B86:  MOVWF  FEA
03B88:  MOVFF  FEF,747
03B8C:  MOVFF  FEC,701
03B90:  MOVFF  FEC,749
03B94:  MOVFF  FEC,74A
03B98:  CLRF   x46
03B9A:  CLRF   x45
03B9C:  CLRF   x44
03B9E:  CLRF   x43
03BA0:  MOVFF  701,748
03BA4:  MOVLB  0
03BA6:  CALL   1D08
03BAA:  BNC   3C1C
03BAC:  MOVLB  6
03BAE:  MOVF   xF7,W
03BB0:  MULLW  2D
03BB2:  MOVF   FF3,W
03BB4:  MOVLB  7
03BB6:  CLRF   x01
03BB8:  MOVWF  x00
03BBA:  MOVLW  10
03BBC:  ADDWF  x00,W
03BBE:  MOVWF  01
03BC0:  MOVLW  00
03BC2:  ADDWFC x01,W
03BC4:  MOVWF  03
03BC6:  MOVF   01,W
03BC8:  ADDLW  07
03BCA:  MOVWF  FE9
03BCC:  MOVLW  01
03BCE:  ADDWFC 03,W
03BD0:  MOVWF  FEA
03BD2:  MOVFF  FEF,743
03BD6:  MOVFF  FEC,744
03BDA:  MOVFF  FEC,745
03BDE:  MOVFF  FEC,746
03BE2:  CLRF   x4A
03BE4:  CLRF   x49
03BE6:  CLRF   x48
03BE8:  CLRF   x47
03BEA:  MOVLB  0
03BEC:  CALL   1D08
03BF0:  BNC   3C1C
....................          adcVals[ch].npoles--;
03BF2:  MOVLB  6
03BF4:  MOVF   xF7,W
03BF6:  MULLW  2D
03BF8:  MOVF   FF3,W
03BFA:  MOVLB  7
03BFC:  CLRF   x01
03BFE:  MOVWF  x00
03C00:  MOVLW  1C
03C02:  ADDWF  x00,W
03C04:  MOVWF  01
03C06:  MOVLW  00
03C08:  ADDWFC x01,W
03C0A:  MOVWF  03
03C0C:  MOVF   01,W
03C0E:  ADDLW  07
03C10:  MOVWF  FE9
03C12:  MOVLW  01
03C14:  ADDWFC 03,W
03C16:  MOVWF  FEA
03C18:  DECF   FEF,F
....................       }
03C1A:  BRA    3CD4
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03C1C:  MOVLB  6
03C1E:  MOVF   xF7,W
03C20:  MULLW  2D
03C22:  MOVF   FF3,W
03C24:  MOVLB  7
03C26:  CLRF   x01
03C28:  MOVWF  x00
03C2A:  MOVLW  08
03C2C:  ADDWF  x00,W
03C2E:  MOVWF  01
03C30:  MOVLW  00
03C32:  ADDWFC x01,W
03C34:  MOVWF  03
03C36:  MOVF   01,W
03C38:  ADDLW  07
03C3A:  MOVWF  FE9
03C3C:  MOVLW  01
03C3E:  ADDWFC 03,W
03C40:  MOVWF  FEA
03C42:  MOVFF  FEF,743
03C46:  MOVFF  FEC,701
03C4A:  MOVFF  FEC,745
03C4E:  MOVFF  FEC,746
03C52:  MOVFF  701,744
03C56:  CLRF   x4A
03C58:  CLRF   x49
03C5A:  CLRF   x48
03C5C:  CLRF   x47
03C5E:  MOVLB  0
03C60:  CALL   1D08
03C64:  BNC   3CD6
03C66:  MOVLB  6
03C68:  MOVF   xF7,W
03C6A:  MULLW  2D
03C6C:  MOVF   FF3,W
03C6E:  MOVLB  7
03C70:  CLRF   x01
03C72:  MOVWF  x00
03C74:  MOVLW  10
03C76:  ADDWF  x00,W
03C78:  MOVWF  01
03C7A:  MOVLW  00
03C7C:  ADDWFC x01,W
03C7E:  MOVWF  03
03C80:  MOVF   01,W
03C82:  ADDLW  07
03C84:  MOVWF  FE9
03C86:  MOVLW  01
03C88:  ADDWFC 03,W
03C8A:  MOVWF  FEA
03C8C:  MOVFF  FEF,747
03C90:  MOVFF  FEC,748
03C94:  MOVFF  FEC,749
03C98:  MOVFF  FEC,74A
03C9C:  CLRF   x46
03C9E:  CLRF   x45
03CA0:  CLRF   x44
03CA2:  CLRF   x43
03CA4:  MOVLB  0
03CA6:  CALL   1D08
03CAA:  BNC   3CD6
....................          adcVals[ch].npoles++;
03CAC:  MOVLB  6
03CAE:  MOVF   xF7,W
03CB0:  MULLW  2D
03CB2:  MOVF   FF3,W
03CB4:  MOVLB  7
03CB6:  CLRF   x01
03CB8:  MOVWF  x00
03CBA:  MOVLW  1C
03CBC:  ADDWF  x00,W
03CBE:  MOVWF  01
03CC0:  MOVLW  00
03CC2:  ADDWFC x01,W
03CC4:  MOVWF  03
03CC6:  MOVF   01,W
03CC8:  ADDLW  07
03CCA:  MOVWF  FE9
03CCC:  MOVLW  01
03CCE:  ADDWFC 03,W
03CD0:  MOVWF  FEA
03CD2:  INCF   FEF,F
03CD4:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03CD6:  MOVLB  6
03CD8:  MOVF   xF7,W
03CDA:  MULLW  2D
03CDC:  MOVF   FF3,W
03CDE:  MOVLB  7
03CE0:  CLRF   x01
03CE2:  MOVWF  x00
03CE4:  MOVLW  18
03CE6:  ADDWF  x00,W
03CE8:  MOVWF  01
03CEA:  MOVLW  00
03CEC:  ADDWFC x01,W
03CEE:  MOVWF  03
03CF0:  MOVF   01,W
03CF2:  ADDLW  07
03CF4:  MOVWF  01
03CF6:  MOVLW  01
03CF8:  ADDWFC 03,F
03CFA:  MOVFF  01,700
03CFE:  MOVFF  03,701
03D02:  MOVFF  6FF,746
03D06:  MOVFF  6FE,745
03D0A:  MOVFF  6FD,744
03D0E:  MOVFF  6FC,743
03D12:  MOVLW  AA
03D14:  MOVWF  x4A
03D16:  MOVLW  27
03D18:  MOVWF  x49
03D1A:  MOVLW  1F
03D1C:  MOVWF  x48
03D1E:  MOVLW  86
03D20:  MOVWF  x47
03D22:  MOVLB  0
03D24:  CALL   0D6C
03D28:  MOVFF  03,705
03D2C:  MOVFF  02,704
03D30:  MOVFF  01,703
03D34:  MOVFF  00,702
03D38:  MOVLB  6
03D3A:  MOVF   xF7,W
03D3C:  MULLW  2D
03D3E:  MOVF   FF3,W
03D40:  MOVLB  7
03D42:  CLRF   x07
03D44:  MOVWF  x06
03D46:  MOVLW  08
03D48:  ADDWF  x06,W
03D4A:  MOVWF  01
03D4C:  MOVLW  00
03D4E:  ADDWFC x07,W
03D50:  MOVWF  03
03D52:  MOVF   01,W
03D54:  ADDLW  07
03D56:  MOVWF  FE9
03D58:  MOVLW  01
03D5A:  ADDWFC 03,W
03D5C:  MOVWF  FEA
03D5E:  MOVFF  FEF,706
03D62:  MOVFF  FEC,707
03D66:  MOVFF  FEC,708
03D6A:  MOVFF  FEC,709
03D6E:  MOVLB  6
03D70:  MOVF   xF7,W
03D72:  MULLW  2D
03D74:  MOVF   FF3,W
03D76:  MOVLB  7
03D78:  CLRF   x0B
03D7A:  MOVWF  x0A
03D7C:  MOVLW  0C
03D7E:  ADDWF  x0A,W
03D80:  MOVWF  01
03D82:  MOVLW  00
03D84:  ADDWFC x0B,W
03D86:  MOVWF  03
03D88:  MOVF   01,W
03D8A:  ADDLW  07
03D8C:  MOVWF  FE9
03D8E:  MOVLW  01
03D90:  ADDWFC 03,W
03D92:  MOVWF  FEA
03D94:  MOVFF  FEF,00
03D98:  MOVFF  FEC,01
03D9C:  MOVFF  FEC,02
03DA0:  MOVFF  FEC,03
03DA4:  MOVFF  03,70D
03DA8:  MOVFF  02,70C
03DAC:  MOVFF  01,70B
03DB0:  MOVFF  00,70A
03DB4:  MOVFF  709,71A
03DB8:  MOVFF  708,719
03DBC:  MOVFF  707,718
03DC0:  MOVFF  706,717
03DC4:  MOVFF  03,71E
03DC8:  MOVFF  02,71D
03DCC:  MOVFF  01,71C
03DD0:  MOVFF  00,71B
03DD4:  MOVLB  0
03DD6:  GOTO   240A
03DDA:  MOVFF  705,746
03DDE:  MOVFF  704,745
03DE2:  MOVFF  703,744
03DE6:  MOVFF  702,743
03DEA:  MOVFF  03,74A
03DEE:  MOVFF  02,749
03DF2:  MOVFF  01,748
03DF6:  MOVFF  00,747
03DFA:  CALL   0D6C
03DFE:  MOVFF  701,FEA
03E02:  MOVFF  700,FE9
03E06:  MOVFF  00,FEF
03E0A:  MOVFF  01,FEC
03E0E:  MOVFF  02,FEC
03E12:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03E16:  MOVLB  6
03E18:  MOVF   xF7,W
03E1A:  MULLW  2D
03E1C:  MOVF   FF3,W
03E1E:  MOVLB  7
03E20:  CLRF   x01
03E22:  MOVWF  x00
03E24:  MOVLW  18
03E26:  ADDWF  x00,W
03E28:  MOVWF  01
03E2A:  MOVLW  00
03E2C:  ADDWFC x01,W
03E2E:  MOVWF  03
03E30:  MOVF   01,W
03E32:  ADDLW  07
03E34:  MOVWF  FE9
03E36:  MOVLW  01
03E38:  ADDWFC 03,W
03E3A:  MOVWF  FEA
03E3C:  MOVFF  FEF,700
03E40:  MOVFF  FEC,701
03E44:  MOVFF  FEC,702
03E48:  MOVFF  FEC,703
03E4C:  CLRF   x46
03E4E:  CLRF   x45
03E50:  MOVLW  7A
03E52:  MOVWF  x44
03E54:  MOVLW  88
03E56:  MOVWF  x43
03E58:  MOVFF  6FF,74A
03E5C:  MOVFF  6FE,749
03E60:  MOVFF  6FD,748
03E64:  MOVFF  6FC,747
03E68:  MOVLB  0
03E6A:  CALL   0D6C
03E6E:  MOVFF  03,707
03E72:  MOVFF  02,706
03E76:  MOVFF  01,705
03E7A:  MOVFF  00,704
03E7E:  MOVLB  6
03E80:  MOVF   xF7,W
03E82:  MULLW  2D
03E84:  MOVF   FF3,W
03E86:  MOVLB  7
03E88:  CLRF   x09
03E8A:  MOVWF  x08
03E8C:  MOVLW  1C
03E8E:  ADDWF  x08,W
03E90:  MOVWF  01
03E92:  MOVLW  00
03E94:  ADDWFC x09,W
03E96:  MOVWF  03
03E98:  MOVF   01,W
03E9A:  ADDLW  07
03E9C:  MOVWF  FE9
03E9E:  MOVLW  01
03EA0:  ADDWFC 03,W
03EA2:  MOVWF  FEA
03EA4:  MOVF   FEF,W
03EA6:  CLRF   x3A
03EA8:  MOVWF  x39
03EAA:  BTFSC  x39.7
03EAC:  DECF   x3A,F
03EAE:  MOVLB  0
03EB0:  CALL   26AC
03EB4:  MOVFF  707,746
03EB8:  MOVFF  706,745
03EBC:  MOVFF  705,744
03EC0:  MOVFF  704,743
03EC4:  MOVFF  03,74A
03EC8:  MOVFF  02,749
03ECC:  MOVFF  01,748
03ED0:  MOVFF  00,747
03ED4:  CALL   0D6C
03ED8:  MOVFF  FEA,705
03EDC:  MOVFF  FE9,704
03EE0:  BCF    FD8.1
03EE2:  MOVFF  703,74A
03EE6:  MOVFF  702,749
03EEA:  MOVFF  701,748
03EEE:  MOVFF  700,747
03EF2:  MOVFF  03,74E
03EF6:  MOVFF  02,74D
03EFA:  MOVFF  01,74C
03EFE:  MOVFF  00,74B
03F02:  CALL   0E62
03F06:  MOVFF  705,FEA
03F0A:  MOVFF  704,FE9
03F0E:  MOVFF  03,6FB
03F12:  MOVFF  02,6FA
03F16:  MOVFF  01,6F9
03F1A:  MOVFF  00,6F8
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03F1E:  MOVLB  6
03F20:  MOVF   xF7,W
03F22:  MULLW  2D
03F24:  MOVF   FF3,W
03F26:  MOVLB  7
03F28:  CLRF   x01
03F2A:  MOVWF  x00
03F2C:  MOVLW  1D
03F2E:  ADDWF  x00,W
03F30:  MOVWF  01
03F32:  MOVLW  00
03F34:  ADDWFC x01,W
03F36:  MOVWF  03
03F38:  MOVF   01,W
03F3A:  ADDLW  07
03F3C:  MOVWF  01
03F3E:  MOVLW  01
03F40:  ADDWFC 03,F
03F42:  MOVFF  01,700
03F46:  MOVFF  03,701
03F4A:  MOVLB  6
03F4C:  MOVF   xF7,W
03F4E:  MULLW  18
03F50:  MOVF   FF3,W
03F52:  MOVLB  7
03F54:  CLRF   x03
03F56:  MOVWF  x02
03F58:  MOVLW  14
03F5A:  ADDWF  x02,W
03F5C:  MOVWF  01
03F5E:  MOVLW  00
03F60:  ADDWFC x03,W
03F62:  MOVWF  03
03F64:  MOVF   01,W
03F66:  ADDLW  82
03F68:  MOVWF  FE9
03F6A:  MOVLW  00
03F6C:  ADDWFC 03,W
03F6E:  MOVWF  FEA
03F70:  MOVFF  FEF,747
03F74:  MOVFF  FEC,01
03F78:  MOVFF  FEC,02
03F7C:  MOVFF  FEC,03
03F80:  MOVFF  6FB,746
03F84:  MOVFF  6FA,745
03F88:  MOVFF  6F9,744
03F8C:  MOVFF  6F8,743
03F90:  MOVFF  03,74A
03F94:  MOVFF  02,749
03F98:  MOVFF  01,748
03F9C:  MOVLB  0
03F9E:  CALL   0D6C
03FA2:  MOVFF  03,705
03FA6:  MOVFF  02,704
03FAA:  MOVFF  01,703
03FAE:  MOVFF  00,702
03FB2:  MOVFF  03,71A
03FB6:  MOVFF  02,719
03FBA:  MOVFF  01,718
03FBE:  MOVFF  00,717
03FC2:  MOVLB  7
03FC4:  CLRF   x1E
03FC6:  CLRF   x1D
03FC8:  MOVLW  20
03FCA:  MOVWF  x1C
03FCC:  MOVLW  81
03FCE:  MOVWF  x1B
03FD0:  MOVLB  0
03FD2:  CALL   33EA
03FD6:  MOVFF  03,705
03FDA:  MOVFF  02,704
03FDE:  MOVFF  01,703
03FE2:  MOVFF  00,702
03FE6:  MOVLB  6
03FE8:  MOVF   xF7,W
03FEA:  MULLW  18
03FEC:  MOVF   FF3,W
03FEE:  MOVLB  7
03FF0:  CLRF   x07
03FF2:  MOVWF  x06
03FF4:  MOVLW  10
03FF6:  ADDWF  x06,W
03FF8:  MOVWF  01
03FFA:  MOVLW  00
03FFC:  ADDWFC x07,W
03FFE:  MOVWF  03
04000:  MOVF   01,W
04002:  ADDLW  82
04004:  MOVWF  FE9
04006:  MOVLW  00
04008:  ADDWFC 03,W
0400A:  MOVWF  FEA
0400C:  MOVFF  FEF,747
04010:  MOVFF  FEC,01
04014:  MOVFF  FEC,02
04018:  MOVFF  FEC,03
0401C:  MOVFF  6FB,746
04020:  MOVFF  6FA,745
04024:  MOVFF  6F9,744
04028:  MOVFF  6F8,743
0402C:  MOVFF  03,74A
04030:  MOVFF  02,749
04034:  MOVFF  01,748
04038:  MOVLB  0
0403A:  CALL   0D6C
0403E:  MOVFF  03,709
04042:  MOVFF  02,708
04046:  MOVFF  01,707
0404A:  MOVFF  00,706
0404E:  MOVFF  03,71A
04052:  MOVFF  02,719
04056:  MOVFF  01,718
0405A:  MOVFF  00,717
0405E:  MOVLB  7
04060:  CLRF   x1E
04062:  CLRF   x1D
04064:  CLRF   x1C
04066:  MOVLW  81
04068:  MOVWF  x1B
0406A:  MOVLB  0
0406C:  CALL   33EA
04070:  MOVFF  FEA,707
04074:  MOVFF  FE9,706
04078:  BCF    FD8.1
0407A:  MOVFF  705,74A
0407E:  MOVFF  704,749
04082:  MOVFF  703,748
04086:  MOVFF  702,747
0408A:  MOVFF  03,74E
0408E:  MOVFF  02,74D
04092:  MOVFF  01,74C
04096:  MOVFF  00,74B
0409A:  CALL   0E62
0409E:  MOVFF  707,FEA
040A2:  MOVFF  706,FE9
040A6:  MOVFF  03,705
040AA:  MOVFF  02,704
040AE:  MOVFF  01,703
040B2:  MOVFF  00,702
040B6:  MOVLB  6
040B8:  MOVF   xF7,W
040BA:  MULLW  18
040BC:  MOVF   FF3,W
040BE:  MOVLB  7
040C0:  CLRF   x09
040C2:  MOVWF  x08
040C4:  MOVLW  0C
040C6:  ADDWF  x08,W
040C8:  MOVWF  01
040CA:  MOVLW  00
040CC:  ADDWFC x09,W
040CE:  MOVWF  03
040D0:  MOVF   01,W
040D2:  ADDLW  82
040D4:  MOVWF  FE9
040D6:  MOVLW  00
040D8:  ADDWFC 03,W
040DA:  MOVWF  FEA
040DC:  MOVFF  FEF,747
040E0:  MOVFF  FEC,01
040E4:  MOVFF  FEC,02
040E8:  MOVFF  FEC,03
040EC:  MOVFF  6FB,746
040F0:  MOVFF  6FA,745
040F4:  MOVFF  6F9,744
040F8:  MOVFF  6F8,743
040FC:  MOVFF  03,74A
04100:  MOVFF  02,749
04104:  MOVFF  01,748
04108:  MOVLB  0
0410A:  CALL   0D6C
0410E:  MOVFF  03,70B
04112:  MOVFF  02,70A
04116:  MOVFF  01,709
0411A:  MOVFF  00,708
0411E:  MOVFF  03,71A
04122:  MOVFF  02,719
04126:  MOVFF  01,718
0412A:  MOVFF  00,717
0412E:  MOVLB  7
04130:  CLRF   x1E
04132:  CLRF   x1D
04134:  MOVLW  40
04136:  MOVWF  x1C
04138:  MOVLW  80
0413A:  MOVWF  x1B
0413C:  MOVLB  0
0413E:  CALL   33EA
04142:  MOVFF  FEA,709
04146:  MOVFF  FE9,708
0414A:  BCF    FD8.1
0414C:  MOVFF  705,74A
04150:  MOVFF  704,749
04154:  MOVFF  703,748
04158:  MOVFF  702,747
0415C:  MOVFF  03,74E
04160:  MOVFF  02,74D
04164:  MOVFF  01,74C
04168:  MOVFF  00,74B
0416C:  CALL   0E62
04170:  MOVFF  709,FEA
04174:  MOVFF  708,FE9
04178:  MOVFF  03,705
0417C:  MOVFF  02,704
04180:  MOVFF  01,703
04184:  MOVFF  00,702
04188:  MOVLB  6
0418A:  MOVF   xF7,W
0418C:  MULLW  18
0418E:  MOVF   FF3,W
04190:  MOVLB  7
04192:  CLRF   x0B
04194:  MOVWF  x0A
04196:  MOVLW  08
04198:  ADDWF  x0A,W
0419A:  MOVWF  01
0419C:  MOVLW  00
0419E:  ADDWFC x0B,W
041A0:  MOVWF  03
041A2:  MOVF   01,W
041A4:  ADDLW  82
041A6:  MOVWF  FE9
041A8:  MOVLW  00
041AA:  ADDWFC 03,W
041AC:  MOVWF  FEA
041AE:  MOVFF  FEF,747
041B2:  MOVFF  FEC,01
041B6:  MOVFF  FEC,02
041BA:  MOVFF  FEC,03
041BE:  MOVFF  6FB,746
041C2:  MOVFF  6FA,745
041C6:  MOVFF  6F9,744
041CA:  MOVFF  6F8,743
041CE:  MOVFF  03,74A
041D2:  MOVFF  02,749
041D6:  MOVFF  01,748
041DA:  MOVLB  0
041DC:  CALL   0D6C
041E0:  MOVFF  03,70D
041E4:  MOVFF  02,70C
041E8:  MOVFF  01,70B
041EC:  MOVFF  00,70A
041F0:  MOVFF  03,71A
041F4:  MOVFF  02,719
041F8:  MOVFF  01,718
041FC:  MOVFF  00,717
04200:  MOVLB  7
04202:  CLRF   x1E
04204:  CLRF   x1D
04206:  CLRF   x1C
04208:  MOVLW  80
0420A:  MOVWF  x1B
0420C:  MOVLB  0
0420E:  CALL   33EA
04212:  MOVFF  FEA,70B
04216:  MOVFF  FE9,70A
0421A:  BCF    FD8.1
0421C:  MOVFF  705,74A
04220:  MOVFF  704,749
04224:  MOVFF  703,748
04228:  MOVFF  702,747
0422C:  MOVFF  03,74E
04230:  MOVFF  02,74D
04234:  MOVFF  01,74C
04238:  MOVFF  00,74B
0423C:  CALL   0E62
04240:  MOVFF  70B,FEA
04244:  MOVFF  70A,FE9
04248:  MOVFF  03,705
0424C:  MOVFF  02,704
04250:  MOVFF  01,703
04254:  MOVFF  00,702
04258:  MOVLB  6
0425A:  MOVF   xF7,W
0425C:  MULLW  18
0425E:  MOVF   FF3,W
04260:  MOVLB  7
04262:  CLRF   x0D
04264:  MOVWF  x0C
04266:  MOVLW  04
04268:  ADDWF  x0C,W
0426A:  MOVWF  01
0426C:  MOVLW  00
0426E:  ADDWFC x0D,W
04270:  MOVWF  03
04272:  MOVF   01,W
04274:  ADDLW  82
04276:  MOVWF  FE9
04278:  MOVLW  00
0427A:  ADDWFC 03,W
0427C:  MOVWF  FEA
0427E:  MOVFF  FEF,747
04282:  MOVFF  FEC,01
04286:  MOVFF  FEC,02
0428A:  MOVFF  FEC,03
0428E:  MOVFF  6FB,746
04292:  MOVFF  6FA,745
04296:  MOVFF  6F9,744
0429A:  MOVFF  6F8,743
0429E:  MOVFF  03,74A
042A2:  MOVFF  02,749
042A6:  MOVFF  01,748
042AA:  MOVLB  0
042AC:  CALL   0D6C
042B0:  MOVFF  FEA,70D
042B4:  MOVFF  FE9,70C
042B8:  BCF    FD8.1
042BA:  MOVFF  705,74A
042BE:  MOVFF  704,749
042C2:  MOVFF  703,748
042C6:  MOVFF  702,747
042CA:  MOVFF  03,74E
042CE:  MOVFF  02,74D
042D2:  MOVFF  01,74C
042D6:  MOVFF  00,74B
042DA:  CALL   0E62
042DE:  MOVFF  70D,FEA
042E2:  MOVFF  70C,FE9
042E6:  MOVFF  03,74A
042EA:  MOVFF  02,749
042EE:  MOVFF  01,748
042F2:  MOVFF  00,747
042F6:  MOVLB  6
042F8:  MOVF   xF7,W
042FA:  MULLW  18
042FC:  MOVF   FF3,W
042FE:  MOVLB  7
04300:  CLRF   x0F
04302:  MOVWF  x0E
04304:  MOVLW  82
04306:  ADDWF  x0E,W
04308:  MOVWF  FE9
0430A:  MOVLW  00
0430C:  ADDWFC x0F,W
0430E:  MOVWF  FEA
04310:  MOVFF  FEF,74B
04314:  MOVFF  FEC,01
04318:  MOVFF  FEC,02
0431C:  MOVFF  FEC,03
04320:  BCF    FD8.1
04322:  MOVFF  03,74E
04326:  MOVFF  02,74D
0432A:  MOVFF  01,74C
0432E:  MOVLB  0
04330:  CALL   0E62
04334:  MOVFF  701,FEA
04338:  MOVFF  700,FE9
0433C:  MOVFF  00,FEF
04340:  MOVFF  01,FEC
04344:  MOVFF  02,FEC
04348:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
0434C:  MOVLB  6
0434E:  MOVF   xF7,F
04350:  BNZ   43B0
04352:  MOVF   xF7,W
04354:  MULLW  2D
04356:  MOVF   FF3,W
04358:  MOVLB  7
0435A:  CLRF   x01
0435C:  MOVWF  x00
0435E:  MOVLW  1D
04360:  ADDWF  x00,W
04362:  MOVWF  01
04364:  MOVLW  00
04366:  ADDWFC x01,W
04368:  MOVWF  03
0436A:  MOVF   01,W
0436C:  ADDLW  07
0436E:  MOVWF  FE9
04370:  MOVLW  01
04372:  ADDWFC 03,W
04374:  MOVWF  FEA
04376:  MOVFF  FEF,743
0437A:  MOVFF  FEC,744
0437E:  MOVFF  FEC,745
04382:  MOVFF  FEC,746
04386:  MOVF   FED,F
04388:  MOVF   FED,F
0438A:  MOVF   FED,F
0438C:  CLRF   x4A
0438E:  CLRF   x49
04390:  MOVLW  80
04392:  MOVWF  x48
04394:  MOVLW  7F
04396:  MOVWF  x47
04398:  MOVLB  0
0439A:  CALL   0D6C
0439E:  MOVFF  00,FEF
043A2:  MOVFF  01,FEC
043A6:  MOVFF  02,FEC
043AA:  MOVFF  03,FEC
043AE:  MOVLB  6
....................    PID[ch].PVold = PID[ch].PV;
043B0:  MOVF   xF7,W
043B2:  MULLW  20
043B4:  MOVF   FF3,W
043B6:  MOVLB  7
043B8:  CLRF   x01
043BA:  MOVWF  x00
043BC:  MOVLW  14
043BE:  ADDWF  x00,W
043C0:  MOVWF  01
043C2:  MOVLW  00
043C4:  ADDWFC x01,W
043C6:  MOVWF  03
043C8:  MOVF   01,W
043CA:  ADDLW  20
043CC:  MOVWF  01
043CE:  MOVLW  00
043D0:  ADDWFC 03,F
043D2:  MOVFF  01,700
043D6:  MOVFF  03,701
043DA:  MOVLB  6
043DC:  MOVF   xF7,W
043DE:  MULLW  20
043E0:  MOVF   FF3,W
043E2:  MOVLB  7
043E4:  CLRF   x03
043E6:  MOVWF  x02
043E8:  MOVLW  10
043EA:  ADDWF  x02,W
043EC:  MOVWF  01
043EE:  MOVLW  00
043F0:  ADDWFC x03,W
043F2:  MOVWF  03
043F4:  MOVF   01,W
043F6:  ADDLW  20
043F8:  MOVWF  FE9
043FA:  MOVLW  00
043FC:  ADDWFC 03,W
043FE:  MOVWF  FEA
04400:  MOVFF  FEF,00
04404:  MOVFF  FEC,01
04408:  MOVFF  FEC,02
0440C:  MOVFF  FEC,03
04410:  MOVFF  701,FEA
04414:  MOVFF  700,FE9
04418:  MOVFF  00,FEF
0441C:  MOVFF  01,FEC
04420:  MOVFF  02,FEC
04424:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
04428:  MOVLB  6
0442A:  MOVF   xF7,W
0442C:  MULLW  20
0442E:  MOVF   FF3,W
04430:  MOVLB  7
04432:  CLRF   x01
04434:  MOVWF  x00
04436:  MOVLW  10
04438:  ADDWF  x00,W
0443A:  MOVWF  01
0443C:  MOVLW  00
0443E:  ADDWFC x01,W
04440:  MOVWF  03
04442:  MOVF   01,W
04444:  ADDLW  20
04446:  MOVWF  01
04448:  MOVLW  00
0444A:  ADDWFC 03,F
0444C:  MOVFF  01,700
04450:  MOVFF  03,701
04454:  MOVLB  6
04456:  MOVF   xF7,W
04458:  MULLW  2D
0445A:  MOVF   FF3,W
0445C:  MOVLB  7
0445E:  CLRF   x03
04460:  MOVWF  x02
04462:  MOVLW  1D
04464:  ADDWF  x02,W
04466:  MOVWF  01
04468:  MOVLW  00
0446A:  ADDWFC x03,W
0446C:  MOVWF  03
0446E:  MOVF   01,W
04470:  ADDLW  07
04472:  MOVWF  FE9
04474:  MOVLW  01
04476:  ADDWFC 03,W
04478:  MOVWF  FEA
0447A:  MOVFF  FEF,00
0447E:  MOVFF  FEC,01
04482:  MOVFF  FEC,02
04486:  MOVFF  FEC,03
0448A:  MOVFF  701,FEA
0448E:  MOVFF  700,FE9
04492:  MOVFF  00,FEF
04496:  MOVFF  01,FEC
0449A:  MOVFF  02,FEC
0449E:  MOVFF  03,FEC
044A2:  MOVLB  0
044A4:  GOTO   4600 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xE5,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  7
001CA:  CLRF   x65
001CC:  MOVWF  x64
001CE:  MOVLW  D2
001D0:  ADDWF  x64,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC x65,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xE5,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  7
001E8:  CLRF   x65
001EA:  MOVWF  x64
001EC:  MOVLW  D2
001EE:  ADDWF  x64,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC x65,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1E5,764
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xE5,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xE5
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xE5,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x65
00222:  MOVWF  x64
00224:  MOVLW  D2
00226:  ADDWF  x64,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x65,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xE5,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  7
00244:  CLRF   x65
00246:  MOVWF  x64
00248:  MOVLW  D2
0024A:  ADDWF  x64,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC x65,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01742:  MOVLB  7
01744:  CLRF   x0B
01746:  CLRF   x0A
01748:  CLRF   x09
0174A:  CLRF   x08
0174C:  CLRF   x0F
0174E:  CLRF   x0E
01750:  CLRF   x0D
01752:  CLRF   x0C
01754:  CLRF   x13
01756:  CLRF   x12
01758:  CLRF   x11
0175A:  CLRF   x10
0175C:  CLRF   x17
0175E:  CLRF   x16
01760:  CLRF   x15
01762:  CLRF   x14
01764:  CLRF   x1B
01766:  CLRF   x1A
01768:  CLRF   x19
0176A:  CLRF   x18
0176C:  CLRF   x1F
0176E:  CLRF   x1E
01770:  CLRF   x1D
01772:  CLRF   x1C
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01774:  MOVLB  6
01776:  MOVF   xF7,F
01778:  BNZ   17A0
....................       sQ_ch = sQ_x;
0177A:  MOVLW  01
0177C:  MOVLB  7
0177E:  MOVWF  x01
01780:  MOVLW  7E
01782:  MOVWF  x00
....................       cQ_ch = cQ_x;
01784:  MOVLW  01
01786:  MOVWF  x03
01788:  MOVLW  92
0178A:  MOVWF  x02
....................       sIn_ch = &sIn_x;
0178C:  MOVLW  01
0178E:  MOVWF  x05
01790:  MOVLW  CE
01792:  MOVWF  x04
....................       cIn_ch = &cIn_x;
01794:  MOVLW  01
01796:  MOVWF  x07
01798:  MOVLW  CF
0179A:  MOVWF  x06
....................    }
0179C:  BRA    17C6
0179E:  MOVLB  6
....................    else if (ch==1){
017A0:  DECFSZ xF7,W
017A2:  BRA    17C8
....................       sQ_ch = sQ_y;
017A4:  MOVLW  01
017A6:  MOVLB  7
017A8:  MOVWF  x01
017AA:  MOVLW  A6
017AC:  MOVWF  x00
....................       cQ_ch = cQ_y;
017AE:  MOVLW  01
017B0:  MOVWF  x03
017B2:  MOVLW  BA
017B4:  MOVWF  x02
....................       sIn_ch = &sIn_y;
017B6:  MOVLW  01
017B8:  MOVWF  x05
017BA:  MOVLW  D0
017BC:  MOVWF  x04
....................       cIn_ch = &cIn_y;
017BE:  MOVLW  01
017C0:  MOVWF  x07
017C2:  MOVLW  D1
017C4:  MOVWF  x06
017C6:  MOVLB  6
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017C8:  MOVFF  701,722
017CC:  MOVFF  700,721
017D0:  MOVFF  705,724
017D4:  MOVFF  704,723
017D8:  MOVFF  6FB,728
017DC:  MOVFF  6FA,727
017E0:  MOVFF  6F9,726
017E4:  MOVFF  6F8,725
017E8:  MOVLB  0
017EA:  CALL   08C2
....................    push(cQ_ch, cIn_ch, cosCnts);
017EE:  MOVFF  703,722
017F2:  MOVFF  702,721
017F6:  MOVFF  707,724
017FA:  MOVFF  706,723
017FE:  MOVFF  6FF,728
01802:  MOVFF  6FE,727
01806:  MOVFF  6FD,726
0180A:  MOVFF  6FC,725
0180E:  CALL   08C2
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01812:  MOVLB  7
01814:  MOVFF  700,FE9
01818:  MOVFF  701,FEA
0181C:  MOVFF  FEF,710
01820:  MOVFF  FEC,711
01824:  MOVFF  FEC,712
01828:  MOVFF  FEC,713
....................    sinMin=sQ_ch[0];
0182C:  MOVFF  700,FE9
01830:  MOVFF  701,FEA
01834:  MOVFF  FEF,714
01838:  MOVFF  FEC,715
0183C:  MOVFF  FEC,716
01840:  MOVFF  FEC,717
....................    cosMax=cQ_ch[0];
01844:  MOVFF  702,FE9
01848:  MOVFF  703,FEA
0184C:  MOVFF  FEF,718
01850:  MOVFF  FEC,719
01854:  MOVFF  FEC,71A
01858:  MOVFF  FEC,71B
....................    cosMin=cQ_ch[0];
0185C:  MOVFF  702,FE9
01860:  MOVFF  703,FEA
01864:  MOVFF  FEF,71C
01868:  MOVFF  FEC,71D
0186C:  MOVFF  FEC,71E
01870:  MOVFF  FEC,71F
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01874:  MOVLW  01
01876:  MOVWF  x20
01878:  MOVF   x20,W
0187A:  SUBLW  04
0187C:  BTFSS  FD8.0
0187E:  BRA    1B8E
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
01880:  CLRF   x31
01882:  MOVFF  720,730
01886:  CLRF   x33
01888:  MOVLW  04
0188A:  MOVWF  x32
0188C:  MOVLB  0
0188E:  CALL   0874
01892:  MOVFF  02,03
01896:  MOVF   01,W
01898:  MOVLB  7
0189A:  ADDWF  x00,W
0189C:  MOVWF  FE9
0189E:  MOVF   x01,W
018A0:  ADDWFC 02,W
018A2:  MOVWF  FEA
018A4:  MOVFF  FEF,00
018A8:  MOVFF  FEC,01
018AC:  MOVFF  FEC,02
018B0:  MOVFF  FEC,03
018B4:  BTFSS  x13.7
018B6:  BRA    18BE
018B8:  BTFSS  03.7
018BA:  BRA    18E0
018BC:  BRA    18C2
018BE:  BTFSC  03.7
018C0:  BRA    1916
018C2:  MOVF   x13,W
018C4:  SUBWF  03,W
018C6:  BNC   1916
018C8:  BNZ   18E0
018CA:  MOVF   x12,W
018CC:  SUBWF  02,W
018CE:  BNC   1916
018D0:  BNZ   18E0
018D2:  MOVF   x11,W
018D4:  SUBWF  01,W
018D6:  BNC   1916
018D8:  BNZ   18E0
018DA:  MOVF   00,W
018DC:  SUBWF  x10,W
018DE:  BC    1916
018E0:  CLRF   x31
018E2:  MOVFF  720,730
018E6:  CLRF   x33
018E8:  MOVLW  04
018EA:  MOVWF  x32
018EC:  MOVLB  0
018EE:  CALL   0874
018F2:  MOVFF  02,03
018F6:  MOVF   01,W
018F8:  MOVLB  7
018FA:  ADDWF  x00,W
018FC:  MOVWF  FE9
018FE:  MOVF   x01,W
01900:  ADDWFC 02,W
01902:  MOVWF  FEA
01904:  MOVFF  FEF,710
01908:  MOVFF  FEC,711
0190C:  MOVFF  FEC,712
01910:  MOVFF  FEC,713
01914:  MOVF   x10,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
01916:  CLRF   x31
01918:  MOVFF  720,730
0191C:  CLRF   x33
0191E:  MOVLW  04
01920:  MOVWF  x32
01922:  MOVLB  0
01924:  CALL   0874
01928:  MOVFF  02,03
0192C:  MOVF   01,W
0192E:  MOVLB  7
01930:  ADDWF  x00,W
01932:  MOVWF  FE9
01934:  MOVF   x01,W
01936:  ADDWFC 02,W
01938:  MOVWF  FEA
0193A:  MOVFF  FEF,00
0193E:  MOVFF  FEC,01
01942:  MOVFF  FEC,02
01946:  MOVFF  FEC,03
0194A:  BTFSS  03.7
0194C:  BRA    1954
0194E:  BTFSS  x17.7
01950:  BRA    1976
01952:  BRA    1958
01954:  BTFSC  x17.7
01956:  BRA    19BA
01958:  MOVF   03,W
0195A:  SUBWF  x17,W
0195C:  BNC   19BA
0195E:  BNZ   1976
01960:  MOVF   02,W
01962:  SUBWF  x16,W
01964:  BNC   19BA
01966:  BNZ   1976
01968:  MOVF   01,W
0196A:  SUBWF  x15,W
0196C:  BNC   19BA
0196E:  BNZ   1976
01970:  MOVF   x14,W
01972:  SUBWF  00,W
01974:  BC    19BA
01976:  CLRF   x31
01978:  MOVFF  720,730
0197C:  CLRF   x33
0197E:  MOVLW  04
01980:  MOVWF  x32
01982:  MOVLB  0
01984:  CALL   0874
01988:  MOVFF  02,03
0198C:  MOVF   01,W
0198E:  MOVLB  7
01990:  ADDWF  x00,W
01992:  MOVWF  FE9
01994:  MOVF   x01,W
01996:  ADDWFC 02,W
01998:  MOVWF  FEA
0199A:  MOVFF  FEF,714
0199E:  MOVFF  FEC,715
019A2:  MOVFF  FEC,716
019A6:  MOVFF  FEC,717
019AA:  MOVFF  714,00
019AE:  MOVFF  715,01
019B2:  MOVFF  716,02
019B6:  MOVFF  717,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019BA:  CLRF   x31
019BC:  MOVFF  720,730
019C0:  CLRF   x33
019C2:  MOVLW  04
019C4:  MOVWF  x32
019C6:  MOVLB  0
019C8:  CALL   0874
019CC:  MOVFF  02,03
019D0:  MOVF   01,W
019D2:  MOVLB  7
019D4:  ADDWF  x02,W
019D6:  MOVWF  FE9
019D8:  MOVF   x03,W
019DA:  ADDWFC 02,W
019DC:  MOVWF  FEA
019DE:  MOVFF  FEF,00
019E2:  MOVFF  FEC,01
019E6:  MOVFF  FEC,02
019EA:  MOVFF  FEC,03
019EE:  BTFSS  x1B.7
019F0:  BRA    19F8
019F2:  BTFSS  03.7
019F4:  BRA    1A1A
019F6:  BRA    19FC
019F8:  BTFSC  03.7
019FA:  BRA    1A5E
019FC:  MOVF   x1B,W
019FE:  SUBWF  03,W
01A00:  BNC   1A5E
01A02:  BNZ   1A1A
01A04:  MOVF   x1A,W
01A06:  SUBWF  02,W
01A08:  BNC   1A5E
01A0A:  BNZ   1A1A
01A0C:  MOVF   x19,W
01A0E:  SUBWF  01,W
01A10:  BNC   1A5E
01A12:  BNZ   1A1A
01A14:  MOVF   00,W
01A16:  SUBWF  x18,W
01A18:  BC    1A5E
01A1A:  CLRF   x31
01A1C:  MOVFF  720,730
01A20:  CLRF   x33
01A22:  MOVLW  04
01A24:  MOVWF  x32
01A26:  MOVLB  0
01A28:  CALL   0874
01A2C:  MOVFF  02,03
01A30:  MOVF   01,W
01A32:  MOVLB  7
01A34:  ADDWF  x02,W
01A36:  MOVWF  FE9
01A38:  MOVF   x03,W
01A3A:  ADDWFC 02,W
01A3C:  MOVWF  FEA
01A3E:  MOVFF  FEF,718
01A42:  MOVFF  FEC,719
01A46:  MOVFF  FEC,71A
01A4A:  MOVFF  FEC,71B
01A4E:  MOVFF  718,00
01A52:  MOVFF  719,01
01A56:  MOVFF  71A,02
01A5A:  MOVFF  71B,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A5E:  CLRF   x31
01A60:  MOVFF  720,730
01A64:  CLRF   x33
01A66:  MOVLW  04
01A68:  MOVWF  x32
01A6A:  MOVLB  0
01A6C:  CALL   0874
01A70:  MOVFF  02,03
01A74:  MOVF   01,W
01A76:  MOVLB  7
01A78:  ADDWF  x02,W
01A7A:  MOVWF  FE9
01A7C:  MOVF   x03,W
01A7E:  ADDWFC 02,W
01A80:  MOVWF  FEA
01A82:  MOVFF  FEF,00
01A86:  MOVFF  FEC,01
01A8A:  MOVFF  FEC,02
01A8E:  MOVFF  FEC,03
01A92:  BTFSS  03.7
01A94:  BRA    1A9C
01A96:  BTFSS  x1F.7
01A98:  BRA    1ABE
01A9A:  BRA    1AA0
01A9C:  BTFSC  x1F.7
01A9E:  BRA    1B02
01AA0:  MOVF   03,W
01AA2:  SUBWF  x1F,W
01AA4:  BNC   1B02
01AA6:  BNZ   1ABE
01AA8:  MOVF   02,W
01AAA:  SUBWF  x1E,W
01AAC:  BNC   1B02
01AAE:  BNZ   1ABE
01AB0:  MOVF   01,W
01AB2:  SUBWF  x1D,W
01AB4:  BNC   1B02
01AB6:  BNZ   1ABE
01AB8:  MOVF   x1C,W
01ABA:  SUBWF  00,W
01ABC:  BC    1B02
01ABE:  CLRF   x31
01AC0:  MOVFF  720,730
01AC4:  CLRF   x33
01AC6:  MOVLW  04
01AC8:  MOVWF  x32
01ACA:  MOVLB  0
01ACC:  CALL   0874
01AD0:  MOVFF  02,03
01AD4:  MOVF   01,W
01AD6:  MOVLB  7
01AD8:  ADDWF  x02,W
01ADA:  MOVWF  FE9
01ADC:  MOVF   x03,W
01ADE:  ADDWFC 02,W
01AE0:  MOVWF  FEA
01AE2:  MOVFF  FEF,71C
01AE6:  MOVFF  FEC,71D
01AEA:  MOVFF  FEC,71E
01AEE:  MOVFF  FEC,71F
01AF2:  MOVFF  71C,00
01AF6:  MOVFF  71D,01
01AFA:  MOVFF  71E,02
01AFE:  MOVFF  71F,03
....................       sumSin+=sQ_ch[i];
01B02:  CLRF   x31
01B04:  MOVFF  720,730
01B08:  CLRF   x33
01B0A:  MOVLW  04
01B0C:  MOVWF  x32
01B0E:  MOVLB  0
01B10:  CALL   0874
01B14:  MOVFF  02,03
01B18:  MOVF   01,W
01B1A:  MOVLB  7
01B1C:  ADDWF  x00,W
01B1E:  MOVWF  FE9
01B20:  MOVF   x01,W
01B22:  ADDWFC 02,W
01B24:  MOVWF  FEA
01B26:  MOVFF  FEF,00
01B2A:  MOVFF  FEC,01
01B2E:  MOVFF  FEC,02
01B32:  MOVFF  FEC,03
01B36:  MOVF   00,W
01B38:  ADDWF  x08,F
01B3A:  MOVF   01,W
01B3C:  ADDWFC x09,F
01B3E:  MOVF   02,W
01B40:  ADDWFC x0A,F
01B42:  MOVF   03,W
01B44:  ADDWFC x0B,F
....................       sumCos+=cQ_ch[i];
01B46:  CLRF   x31
01B48:  MOVFF  720,730
01B4C:  CLRF   x33
01B4E:  MOVLW  04
01B50:  MOVWF  x32
01B52:  MOVLB  0
01B54:  CALL   0874
01B58:  MOVFF  02,03
01B5C:  MOVF   01,W
01B5E:  MOVLB  7
01B60:  ADDWF  x02,W
01B62:  MOVWF  FE9
01B64:  MOVF   x03,W
01B66:  ADDWFC 02,W
01B68:  MOVWF  FEA
01B6A:  MOVFF  FEF,00
01B6E:  MOVFF  FEC,01
01B72:  MOVFF  FEC,02
01B76:  MOVFF  FEC,03
01B7A:  MOVF   00,W
01B7C:  ADDWF  x0C,F
01B7E:  MOVF   01,W
01B80:  ADDWFC x0D,F
01B82:  MOVF   02,W
01B84:  ADDWFC x0E,F
01B86:  MOVF   03,W
01B88:  ADDWFC x0F,F
01B8A:  INCF   x20,F
01B8C:  BRA    1878
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01B8E:  MOVF   x14,W
01B90:  ADDWF  x10,W
01B92:  MOVWF  00
01B94:  MOVF   x15,W
01B96:  ADDWFC x11,W
01B98:  MOVWF  01
01B9A:  MOVF   x16,W
01B9C:  ADDWFC x12,W
01B9E:  MOVWF  02
01BA0:  MOVF   x17,W
01BA2:  ADDWFC x13,W
01BA4:  MOVWF  03
01BA6:  MOVF   00,W
01BA8:  SUBWF  x08,F
01BAA:  MOVF   01,W
01BAC:  SUBWFB x09,F
01BAE:  MOVF   02,W
01BB0:  SUBWFB x0A,F
01BB2:  MOVF   03,W
01BB4:  SUBWFB x0B,F
....................    sumCos-=(cosMax+cosMin);
01BB6:  MOVF   x1C,W
01BB8:  ADDWF  x18,W
01BBA:  MOVWF  00
01BBC:  MOVF   x1D,W
01BBE:  ADDWFC x19,W
01BC0:  MOVWF  01
01BC2:  MOVF   x1E,W
01BC4:  ADDWFC x1A,W
01BC6:  MOVWF  02
01BC8:  MOVF   x1F,W
01BCA:  ADDWFC x1B,W
01BCC:  MOVWF  03
01BCE:  MOVF   00,W
01BD0:  SUBWF  x0C,F
01BD2:  MOVF   01,W
01BD4:  SUBWFB x0D,F
01BD6:  MOVF   02,W
01BD8:  SUBWFB x0E,F
01BDA:  MOVF   03,W
01BDC:  SUBWFB x0F,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BDE:  MOVLB  6
01BE0:  MOVF   xF7,W
01BE2:  MULLW  09
01BE4:  MOVF   FF3,W
01BE6:  MOVLB  7
01BE8:  CLRF   x22
01BEA:  MOVWF  x21
01BEC:  MOVLW  01
01BEE:  ADDWF  x21,W
01BF0:  MOVWF  01
01BF2:  MOVLW  00
01BF4:  ADDWFC x22,W
01BF6:  MOVWF  03
01BF8:  MOVF   01,W
01BFA:  ADDLW  D2
01BFC:  MOVWF  FE9
01BFE:  MOVLW  01
01C00:  ADDWFC 03,W
01C02:  MOVWF  FEA
01C04:  MOVFF  FEA,724
01C08:  MOVFF  FE9,723
01C0C:  BCF    FD8.1
01C0E:  MOVFF  70B,728
01C12:  MOVFF  70A,727
01C16:  MOVFF  709,726
01C1A:  MOVFF  708,725
01C1E:  CLRF   x2C
01C20:  CLRF   x2B
01C22:  CLRF   x2A
01C24:  MOVLW  03
01C26:  MOVWF  x29
01C28:  MOVLB  0
01C2A:  RCALL  1658
01C2C:  MOVFF  724,FEA
01C30:  MOVFF  723,FE9
01C34:  MOVFF  00,FEF
01C38:  MOVFF  01,FEC
01C3C:  MOVFF  02,FEC
01C40:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C44:  MOVLB  6
01C46:  MOVF   xF7,W
01C48:  MULLW  09
01C4A:  MOVF   FF3,W
01C4C:  MOVLB  7
01C4E:  CLRF   x22
01C50:  MOVWF  x21
01C52:  MOVLW  05
01C54:  ADDWF  x21,W
01C56:  MOVWF  01
01C58:  MOVLW  00
01C5A:  ADDWFC x22,W
01C5C:  MOVWF  03
01C5E:  MOVF   01,W
01C60:  ADDLW  D2
01C62:  MOVWF  FE9
01C64:  MOVLW  01
01C66:  ADDWFC 03,W
01C68:  MOVWF  FEA
01C6A:  MOVFF  FEA,724
01C6E:  MOVFF  FE9,723
01C72:  BCF    FD8.1
01C74:  MOVFF  70F,728
01C78:  MOVFF  70E,727
01C7C:  MOVFF  70D,726
01C80:  MOVFF  70C,725
01C84:  CLRF   x2C
01C86:  CLRF   x2B
01C88:  CLRF   x2A
01C8A:  MOVLW  03
01C8C:  MOVWF  x29
01C8E:  MOVLB  0
01C90:  RCALL  1658
01C92:  MOVFF  724,FEA
01C96:  MOVFF  723,FE9
01C9A:  MOVFF  00,FEF
01C9E:  MOVFF  01,FEC
01CA2:  MOVFF  02,FEC
01CA6:  MOVFF  03,FEC
01CAA:  GOTO   4588 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
044A8:  MOVLB  6
044AA:  CLRF   xF2
044AC:  CLRF   xF1
044AE:  CLRF   xF0
044B0:  CLRF   xEF
044B2:  CLRF   xF6
044B4:  CLRF   xF5
044B6:  CLRF   xF4
044B8:  CLRF   xF3
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
044BA:  MOVLB  1
044BC:  MOVF   xE6,W
044BE:  MULLW  09
044C0:  MOVF   FF3,W
044C2:  MOVLB  6
044C4:  CLRF   xF8
044C6:  MOVWF  xF7
044C8:  MOVLW  D2
044CA:  ADDWF  xF7,W
044CC:  MOVWF  FE9
044CE:  MOVLW  01
044D0:  ADDWFC xF8,W
044D2:  MOVWF  FEA
044D4:  BTFSC  FEF.1
044D6:  BRA    4654
044D8:  MOVLB  1
044DA:  MOVF   xE6,W
044DC:  MULLW  09
044DE:  MOVF   FF3,W
044E0:  MOVLB  6
044E2:  CLRF   xFA
044E4:  MOVWF  xF9
044E6:  MOVLW  D2
044E8:  ADDWF  xF9,W
044EA:  MOVWF  FE9
044EC:  MOVLW  01
044EE:  ADDWFC xFA,W
044F0:  MOVWF  FEA
044F2:  BTFSS  FEF.0
044F4:  BRA    4654
....................       smData[ch].adcBusy = true;
044F6:  MOVLB  1
044F8:  MOVF   xE6,W
044FA:  MULLW  09
044FC:  MOVF   FF3,W
044FE:  MOVLB  6
04500:  CLRF   xF8
04502:  MOVWF  xF7
04504:  MOVLW  D2
04506:  ADDWF  xF7,W
04508:  MOVWF  FE9
0450A:  MOVLW  01
0450C:  ADDWFC xF8,W
0450E:  MOVWF  FEA
04510:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04512:  BCF    FD8.0
04514:  MOVLB  1
04516:  RLCF   xE6,W
04518:  MOVLB  6
0451A:  MOVWF  xF7
0451C:  MOVWF  xF8
0451E:  MOVLB  0
04520:  CALL   081A
04524:  MOVFF  03,6F2
04528:  MOVFF  02,6F1
0452C:  MOVFF  01,6F0
04530:  MOVFF  00,6EF
....................       cosNew = ads_read_data(ch*2+1);      
04534:  BCF    FD8.0
04536:  MOVLB  1
04538:  RLCF   xE6,W
0453A:  ADDLW  01
0453C:  MOVLB  6
0453E:  MOVWF  xF7
04540:  MOVWF  xF8
04542:  MOVLB  0
04544:  CALL   081A
04548:  MOVFF  03,6F6
0454C:  MOVFF  02,6F5
04550:  MOVFF  01,6F4
04554:  MOVFF  00,6F3
....................       
....................       if (adcFilter){
04558:  MOVLB  1
0455A:  BTFSS  x61.0
0455C:  BRA    458C
....................          iqm_ring_buffer(ch, sinNew, cosNew);
0455E:  MOVFF  1E6,6F7
04562:  MOVFF  6F2,6FB
04566:  MOVFF  6F1,6FA
0456A:  MOVFF  6F0,6F9
0456E:  MOVFF  6EF,6F8
04572:  MOVFF  6F6,6FF
04576:  MOVFF  6F5,6FE
0457A:  MOVFF  6F4,6FD
0457E:  MOVFF  6F3,6FC
04582:  MOVLB  0
04584:  GOTO   1742
....................       }
04588:  BRA    45F8
0458A:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
0458C:  MOVF   xE6,W
0458E:  MULLW  09
04590:  MOVF   FF3,W
04592:  MOVLB  6
04594:  CLRF   xF8
04596:  MOVWF  xF7
04598:  MOVLW  01
0459A:  ADDWF  xF7,W
0459C:  MOVWF  01
0459E:  MOVLW  00
045A0:  ADDWFC xF8,W
045A2:  MOVWF  03
045A4:  MOVF   01,W
045A6:  ADDLW  D2
045A8:  MOVWF  FE9
045AA:  MOVLW  01
045AC:  ADDWFC 03,W
045AE:  MOVWF  FEA
045B0:  MOVFF  6EF,FEF
045B4:  MOVFF  6F0,FEC
045B8:  MOVFF  6F1,FEC
045BC:  MOVFF  6F2,FEC
....................          smData[ch].avgCos = cosNew;
045C0:  MOVLB  1
045C2:  MOVF   xE6,W
045C4:  MULLW  09
045C6:  MOVF   FF3,W
045C8:  MOVLB  6
045CA:  CLRF   xF8
045CC:  MOVWF  xF7
045CE:  MOVLW  05
045D0:  ADDWF  xF7,W
045D2:  MOVWF  01
045D4:  MOVLW  00
045D6:  ADDWFC xF8,W
045D8:  MOVWF  03
045DA:  MOVF   01,W
045DC:  ADDLW  D2
045DE:  MOVWF  FE9
045E0:  MOVLW  01
045E2:  ADDWFC 03,W
045E4:  MOVWF  FEA
045E6:  MOVFF  6F3,FEF
045EA:  MOVFF  6F4,FEC
045EE:  MOVFF  6F5,FEC
045F2:  MOVFF  6F6,FEC
045F6:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045F8:  MOVFF  1E6,6F7
045FC:  GOTO   36E8
....................       ch = !ch;
04600:  MOVLB  1
04602:  MOVF   xE6,F
04604:  BZ    460A
04606:  MOVLW  00
04608:  BRA    460C
0460A:  MOVLW  01
0460C:  MOVWF  xE6
....................       
....................       smData[!ch].dataReady = false;
0460E:  MOVF   xE6,F
04610:  BZ    4616
04612:  MOVLW  00
04614:  BRA    4618
04616:  MOVLW  01
04618:  MULLW  09
0461A:  MOVF   FF3,W
0461C:  MOVLB  6
0461E:  CLRF   xF8
04620:  MOVWF  xF7
04622:  MOVLW  D2
04624:  ADDWF  xF7,W
04626:  MOVWF  FE9
04628:  MOVLW  01
0462A:  ADDWFC xF8,W
0462C:  MOVWF  FEA
0462E:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
04630:  MOVLB  1
04632:  MOVF   xE6,F
04634:  BZ    463A
04636:  MOVLW  00
04638:  BRA    463C
0463A:  MOVLW  01
0463C:  MULLW  09
0463E:  MOVF   FF3,W
04640:  MOVLB  6
04642:  CLRF   xF8
04644:  MOVWF  xF7
04646:  MOVLW  D2
04648:  ADDWF  xF7,W
0464A:  MOVWF  FE9
0464C:  MOVLW  01
0464E:  ADDWFC xF8,W
04650:  MOVWF  FEA
04652:  BCF    FEF.1
....................    }
04654:  MOVLB  0
04656:  GOTO   A77E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00928:  MOVLB  6
0092A:  CLRF   xEF
0092C:  CLRF   xF0
0092E:  CLRF   xF1
00930:  CLRF   xF2
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00932:  CLRF   xF3
00934:  MOVF   xF3,W
00936:  SUBLW  03
00938:  BNC   096E
....................       rc0=reg0config;
0093A:  MOVLW  30
0093C:  MOVWF  xEF
....................       rc1=reg1config;
0093E:  MOVLW  10
00940:  MOVWF  xF0
....................       rc2=reg2config;
00942:  CLRF   xF1
....................       rc3=reg3config;
00944:  CLRF   xF2
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00946:  MOVFF  6F3,6F5
0094A:  MOVFF  6EF,6F6
0094E:  MOVFF  6F0,6F7
00952:  MOVFF  6F1,6F8
00956:  MOVFF  6F2,6F9
0095A:  MOVLB  0
0095C:  BRA    074C
....................       delay_ms(100);
0095E:  MOVLW  64
00960:  MOVLB  6
00962:  MOVWF  xF5
00964:  MOVLB  0
00966:  RCALL  03A4
00968:  MOVLB  6
0096A:  INCF   xF3,F
0096C:  BRA    0934
....................    }
....................    
....................    if (adcFilter){
0096E:  MOVLB  1
00970:  BTFSS  x61.0
00972:  BRA    0A94
....................       for (int i = 0; i < BUFFER_SIZE; i++){
00974:  MOVLB  6
00976:  CLRF   xF4
00978:  MOVF   xF4,W
0097A:  SUBLW  04
0097C:  BTFSS  FD8.0
0097E:  BRA    0A92
....................          ads_start_conv_all();
00980:  MOVLB  0
00982:  BRA    07EA
....................          delay_ms(50);
00984:  MOVLW  32
00986:  MOVLB  6
00988:  MOVWF  xF5
0098A:  MOVLB  0
0098C:  RCALL  03A4
....................          push(sQ_x, &sIn_x, ads_read_data(0));
0098E:  MOVLB  6
00990:  CLRF   xF8
00992:  MOVLB  0
00994:  RCALL  081A
00996:  MOVFF  03,6F8
0099A:  MOVFF  02,6F7
0099E:  MOVFF  01,6F6
009A2:  MOVFF  00,6F5
009A6:  MOVLW  01
009A8:  MOVLB  7
009AA:  MOVWF  x22
009AC:  MOVLW  7E
009AE:  MOVWF  x21
009B0:  MOVLW  01
009B2:  MOVWF  x24
009B4:  MOVLW  CE
009B6:  MOVWF  x23
009B8:  MOVFF  03,728
009BC:  MOVFF  02,727
009C0:  MOVFF  01,726
009C4:  MOVFF  00,725
009C8:  MOVLB  0
009CA:  RCALL  08C2
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009CC:  MOVLW  01
009CE:  MOVLB  6
009D0:  MOVWF  xF8
009D2:  MOVLB  0
009D4:  RCALL  081A
009D6:  MOVFF  03,6F8
009DA:  MOVFF  02,6F7
009DE:  MOVFF  01,6F6
009E2:  MOVFF  00,6F5
009E6:  MOVLW  01
009E8:  MOVLB  7
009EA:  MOVWF  x22
009EC:  MOVLW  92
009EE:  MOVWF  x21
009F0:  MOVLW  01
009F2:  MOVWF  x24
009F4:  MOVLW  CF
009F6:  MOVWF  x23
009F8:  MOVFF  03,728
009FC:  MOVFF  02,727
00A00:  MOVFF  01,726
00A04:  MOVFF  00,725
00A08:  MOVLB  0
00A0A:  RCALL  08C2
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A0C:  MOVLW  02
00A0E:  MOVLB  6
00A10:  MOVWF  xF8
00A12:  MOVLB  0
00A14:  RCALL  081A
00A16:  MOVFF  03,6F8
00A1A:  MOVFF  02,6F7
00A1E:  MOVFF  01,6F6
00A22:  MOVFF  00,6F5
00A26:  MOVLW  01
00A28:  MOVLB  7
00A2A:  MOVWF  x22
00A2C:  MOVLW  A6
00A2E:  MOVWF  x21
00A30:  MOVLW  01
00A32:  MOVWF  x24
00A34:  MOVLW  D0
00A36:  MOVWF  x23
00A38:  MOVFF  03,728
00A3C:  MOVFF  02,727
00A40:  MOVFF  01,726
00A44:  MOVFF  00,725
00A48:  MOVLB  0
00A4A:  RCALL  08C2
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A4C:  MOVLW  03
00A4E:  MOVLB  6
00A50:  MOVWF  xF8
00A52:  MOVLB  0
00A54:  RCALL  081A
00A56:  MOVFF  03,6F8
00A5A:  MOVFF  02,6F7
00A5E:  MOVFF  01,6F6
00A62:  MOVFF  00,6F5
00A66:  MOVLW  01
00A68:  MOVLB  7
00A6A:  MOVWF  x22
00A6C:  MOVLW  BA
00A6E:  MOVWF  x21
00A70:  MOVLW  01
00A72:  MOVWF  x24
00A74:  MOVLW  D1
00A76:  MOVWF  x23
00A78:  MOVFF  03,728
00A7C:  MOVFF  02,727
00A80:  MOVFF  01,726
00A84:  MOVFF  00,725
00A88:  MOVLB  0
00A8A:  RCALL  08C2
00A8C:  MOVLB  6
00A8E:  INCF   xF4,F
00A90:  BRA    0978
00A92:  MOVLB  1
....................       }
....................    }
00A94:  MOVLB  0
00A96:  GOTO   0AFA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00A9A:  MOVLW  00
00A9C:  MOVLB  F
00A9E:  MOVWF  x53
00AA0:  MOVLW  40
00AA2:  MOVWF  x0C
00AA4:  MOVLW  00
00AA6:  MOVWF  x14
00AA8:  MOVLW  03
00AAA:  MOVWF  x1C
00AAC:  MOVLW  0F
00AAE:  MOVWF  x21
00AB0:  MOVLW  00
00AB2:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AB4:  MOVLW  08
00AB6:  MOVWF  x55
00AB8:  CLRF   x56
00ABA:  CLRF   x52
00ABC:  SETF   x57
00ABE:  CLRF   F61
00AC0:  MOVLW  94
00AC2:  MOVWF  x5B
....................    output_high(EN_EXC);
00AC4:  MOVLW  E8
00AC6:  MOVWF  F8B
00AC8:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00ACA:  MOVF   x5A,W
00ACC:  ANDLW  3F
00ACE:  MOVWF  01
00AD0:  MOVLW  06
00AD2:  MOVWF  x5A
00AD4:  BTFSS  x5B.7
00AD6:  BRA    0AE6
00AD8:  MOVF   01,W
00ADA:  SUBLW  06
00ADC:  BZ    0AE6
00ADE:  BSF    x5B.0
00AE0:  NOP   
00AE2:  BTFSC  x5B.0
00AE4:  BRA    0AE2
....................    delay_ms(10);
00AE6:  MOVLW  0A
00AE8:  MOVLB  6
00AEA:  MOVWF  xF5
00AEC:  MOVLB  0
00AEE:  RCALL  03A4
....................    read_adc(ADC_START_ONLY);
00AF0:  MOVLB  F
00AF2:  BSF    x5B.0
00AF4:  NOP   
....................    setup_external_ADCs();
00AF6:  MOVLB  0
00AF8:  BRA    0928
....................    intTimeoutReg = sensorSampleRate;
00AFA:  MOVLB  1
00AFC:  CLRF   x7D
00AFE:  MOVLW  32
00B00:  MOVWF  x7C
00B02:  MOVLB  0
00B04:  GOTO   A760 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
04734:  MOVLB  6
04736:  MOVF   xF3,W
04738:  MULLW  20
0473A:  MOVF   FF3,W
0473C:  MOVLB  7
0473E:  CLRF   x01
04740:  MOVWF  x00
04742:  MOVLW  0C
04744:  ADDWF  x00,W
04746:  MOVWF  01
04748:  MOVLW  00
0474A:  ADDWFC x01,W
0474C:  MOVWF  03
0474E:  MOVF   01,W
04750:  ADDLW  20
04752:  MOVWF  FE9
04754:  MOVLW  00
04756:  ADDWFC 03,W
04758:  MOVWF  FEA
0475A:  MOVFF  FEF,747
0475E:  MOVFF  FEC,748
04762:  MOVFF  FEC,749
04766:  MOVFF  FEC,74A
0476A:  MOVLB  6
0476C:  MOVF   xF3,W
0476E:  MULLW  20
04770:  MOVF   FF3,W
04772:  MOVLB  7
04774:  CLRF   x05
04776:  MOVWF  x04
04778:  MOVLW  10
0477A:  ADDWF  x04,W
0477C:  MOVWF  01
0477E:  MOVLW  00
04780:  ADDWFC x05,W
04782:  MOVWF  03
04784:  MOVF   01,W
04786:  ADDLW  20
04788:  MOVWF  FE9
0478A:  MOVLW  00
0478C:  ADDWFC 03,W
0478E:  MOVWF  FEA
04790:  MOVFF  FEF,74B
04794:  MOVFF  FEC,01
04798:  MOVFF  FEC,02
0479C:  MOVFF  FEC,03
047A0:  MOVFF  FEA,705
047A4:  MOVFF  FE9,704
047A8:  BSF    FD8.1
047AA:  MOVFF  03,74E
047AE:  MOVFF  02,74D
047B2:  MOVFF  01,74C
047B6:  MOVLB  0
047B8:  CALL   0E62
047BC:  MOVFF  705,FEA
047C0:  MOVFF  704,FE9
047C4:  MOVFF  03,6F7
047C8:  MOVFF  02,6F6
047CC:  MOVFF  01,6F5
047D0:  MOVFF  00,6F4
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
047D4:  MOVLB  6
047D6:  MOVF   xF3,W
047D8:  MULLW  20
047DA:  MOVF   FF3,W
047DC:  MOVLB  7
047DE:  CLRF   x01
047E0:  MOVWF  x00
047E2:  MOVLW  1C
047E4:  ADDWF  x00,W
047E6:  MOVWF  01
047E8:  MOVLW  00
047EA:  ADDWFC x01,W
047EC:  MOVWF  03
047EE:  MOVF   01,W
047F0:  ADDLW  20
047F2:  MOVWF  01
047F4:  MOVLW  00
047F6:  ADDWFC 03,F
047F8:  MOVFF  01,700
047FC:  MOVFF  03,701
04800:  MOVFF  03,FEA
04804:  MOVFF  01,FE9
04808:  MOVFF  FEF,702
0480C:  MOVFF  FEC,703
04810:  MOVFF  FEC,704
04814:  MOVFF  FEC,705
04818:  MOVLB  6
0481A:  MOVF   xF3,W
0481C:  MULLW  20
0481E:  MOVF   FF3,W
04820:  MOVLB  7
04822:  CLRF   x07
04824:  MOVWF  x06
04826:  MOVLW  04
04828:  ADDWF  x06,W
0482A:  MOVWF  01
0482C:  MOVLW  00
0482E:  ADDWFC x07,W
04830:  MOVWF  03
04832:  MOVF   01,W
04834:  ADDLW  20
04836:  MOVWF  FE9
04838:  MOVLW  00
0483A:  ADDWFC 03,W
0483C:  MOVWF  FEA
0483E:  MOVFF  FEF,747
04842:  MOVFF  FEC,01
04846:  MOVFF  FEC,02
0484A:  MOVFF  FEC,03
0484E:  MOVFF  6F7,746
04852:  MOVFF  6F6,745
04856:  MOVFF  6F5,744
0485A:  MOVFF  6F4,743
0485E:  MOVFF  03,74A
04862:  MOVFF  02,749
04866:  MOVFF  01,748
0486A:  MOVLB  0
0486C:  CALL   0D6C
04870:  BCF    FD8.1
04872:  MOVFF  705,74A
04876:  MOVFF  704,749
0487A:  MOVFF  703,748
0487E:  MOVFF  702,747
04882:  MOVFF  03,74E
04886:  MOVFF  02,74D
0488A:  MOVFF  01,74C
0488E:  MOVFF  00,74B
04892:  CALL   0E62
04896:  MOVFF  701,FEA
0489A:  MOVFF  700,FE9
0489E:  MOVFF  00,FEF
048A2:  MOVFF  01,FEC
048A6:  MOVFF  02,FEC
048AA:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
048AE:  MOVLB  6
048B0:  MOVF   xF3,W
048B2:  MULLW  20
048B4:  MOVF   FF3,W
048B6:  MOVLB  7
048B8:  CLRF   x01
048BA:  MOVWF  x00
048BC:  MOVLW  1C
048BE:  ADDWF  x00,W
048C0:  MOVWF  01
048C2:  MOVLW  00
048C4:  ADDWFC x01,W
048C6:  MOVWF  03
048C8:  MOVF   01,W
048CA:  ADDLW  20
048CC:  MOVWF  FE9
048CE:  MOVLW  00
048D0:  ADDWFC 03,W
048D2:  MOVWF  FEA
048D4:  MOVFF  FEF,747
048D8:  MOVFF  FEC,701
048DC:  MOVFF  FEC,749
048E0:  MOVFF  FEC,74A
048E4:  CLRF   x46
048E6:  CLRF   x45
048E8:  MOVLW  7C
048EA:  MOVWF  x44
048EC:  MOVLW  84
048EE:  MOVWF  x43
048F0:  MOVFF  701,748
048F4:  MOVLB  0
048F6:  CALL   1D08
048FA:  BNC   4930
048FC:  MOVLB  6
048FE:  MOVF   xF3,W
04900:  MULLW  20
04902:  MOVF   FF3,W
04904:  MOVLB  7
04906:  CLRF   x01
04908:  MOVWF  x00
0490A:  MOVLW  1C
0490C:  ADDWF  x00,W
0490E:  MOVWF  01
04910:  MOVLW  00
04912:  ADDWFC x01,W
04914:  MOVWF  03
04916:  MOVF   01,W
04918:  ADDLW  20
0491A:  MOVWF  FE9
0491C:  MOVLW  00
0491E:  ADDWFC 03,W
04920:  MOVWF  FEA
04922:  MOVLW  84
04924:  MOVWF  FEF
04926:  MOVLW  7C
04928:  MOVWF  FEC
0492A:  CLRF   FEC
0492C:  CLRF   FEC
0492E:  BRA    49B0
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
04930:  MOVLB  6
04932:  MOVF   xF3,W
04934:  MULLW  20
04936:  MOVF   FF3,W
04938:  MOVLB  7
0493A:  CLRF   x01
0493C:  MOVWF  x00
0493E:  MOVLW  1C
04940:  ADDWF  x00,W
04942:  MOVWF  01
04944:  MOVLW  00
04946:  ADDWFC x01,W
04948:  MOVWF  03
0494A:  MOVF   01,W
0494C:  ADDLW  20
0494E:  MOVWF  FE9
04950:  MOVLW  00
04952:  ADDWFC 03,W
04954:  MOVWF  FEA
04956:  MOVFF  FEF,743
0495A:  MOVFF  FEC,701
0495E:  MOVFF  FEC,745
04962:  MOVFF  FEC,746
04966:  MOVFF  701,744
0496A:  CLRF   x4A
0496C:  CLRF   x49
0496E:  MOVLW  C0
04970:  MOVWF  x48
04972:  MOVLW  82
04974:  MOVWF  x47
04976:  MOVLB  0
04978:  CALL   1D08
0497C:  BNC   49B2
0497E:  MOVLB  6
04980:  MOVF   xF3,W
04982:  MULLW  20
04984:  MOVF   FF3,W
04986:  MOVLB  7
04988:  CLRF   x01
0498A:  MOVWF  x00
0498C:  MOVLW  1C
0498E:  ADDWF  x00,W
04990:  MOVWF  01
04992:  MOVLW  00
04994:  ADDWFC x01,W
04996:  MOVWF  03
04998:  MOVF   01,W
0499A:  ADDLW  20
0499C:  MOVWF  FE9
0499E:  MOVLW  00
049A0:  ADDWFC 03,W
049A2:  MOVWF  FEA
049A4:  MOVLW  82
049A6:  MOVWF  FEF
049A8:  MOVLW  C0
049AA:  MOVWF  FEC
049AC:  CLRF   FEC
049AE:  CLRF   FEC
049B0:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
049B2:  MOVLB  6
049B4:  MOVF   xF3,W
049B6:  MULLW  20
049B8:  MOVF   FF3,W
049BA:  MOVLB  7
049BC:  CLRF   x01
049BE:  MOVWF  x00
049C0:  MOVLW  20
049C2:  ADDWF  x00,W
049C4:  MOVWF  FE9
049C6:  MOVLW  00
049C8:  ADDWFC x01,W
049CA:  MOVWF  FEA
049CC:  MOVFF  FEF,747
049D0:  MOVFF  FEC,01
049D4:  MOVFF  FEC,02
049D8:  MOVFF  FEC,03
049DC:  MOVFF  6F7,746
049E0:  MOVFF  6F6,745
049E4:  MOVFF  6F5,744
049E8:  MOVFF  6F4,743
049EC:  MOVFF  03,74A
049F0:  MOVFF  02,749
049F4:  MOVFF  01,748
049F8:  MOVLB  0
049FA:  CALL   0D6C
049FE:  MOVFF  03,6FB
04A02:  MOVFF  02,6FA
04A06:  MOVFF  01,6F9
04A0A:  MOVFF  00,6F8
04A0E:  MOVLB  6
04A10:  MOVF   xF3,W
04A12:  MULLW  20
04A14:  MOVF   FF3,W
04A16:  MOVLB  7
04A18:  CLRF   x03
04A1A:  MOVWF  x02
04A1C:  MOVLW  08
04A1E:  ADDWF  x02,W
04A20:  MOVWF  01
04A22:  MOVLW  00
04A24:  ADDWFC x03,W
04A26:  MOVWF  03
04A28:  MOVF   01,W
04A2A:  ADDLW  20
04A2C:  MOVWF  FE9
04A2E:  MOVLW  00
04A30:  ADDWFC 03,W
04A32:  MOVWF  FEA
04A34:  MOVFF  FEF,702
04A38:  MOVFF  FEC,703
04A3C:  MOVFF  FEC,704
04A40:  MOVFF  FEC,705
04A44:  MOVLB  6
04A46:  MOVF   xF3,W
04A48:  MULLW  20
04A4A:  MOVF   FF3,W
04A4C:  MOVLB  7
04A4E:  CLRF   x07
04A50:  MOVWF  x06
04A52:  MOVLW  10
04A54:  ADDWF  x06,W
04A56:  MOVWF  01
04A58:  MOVLW  00
04A5A:  ADDWFC x07,W
04A5C:  MOVWF  03
04A5E:  MOVF   01,W
04A60:  ADDLW  20
04A62:  MOVWF  FE9
04A64:  MOVLW  00
04A66:  ADDWFC 03,W
04A68:  MOVWF  FEA
04A6A:  MOVFF  FEF,747
04A6E:  MOVFF  FEC,748
04A72:  MOVFF  FEC,749
04A76:  MOVFF  FEC,74A
04A7A:  MOVLB  6
04A7C:  MOVF   xF3,W
04A7E:  MULLW  20
04A80:  MOVF   FF3,W
04A82:  MOVLB  7
04A84:  CLRF   x0B
04A86:  MOVWF  x0A
04A88:  MOVLW  14
04A8A:  ADDWF  x0A,W
04A8C:  MOVWF  01
04A8E:  MOVLW  00
04A90:  ADDWFC x0B,W
04A92:  MOVWF  03
04A94:  MOVF   01,W
04A96:  ADDLW  20
04A98:  MOVWF  FE9
04A9A:  MOVLW  00
04A9C:  ADDWFC 03,W
04A9E:  MOVWF  FEA
04AA0:  MOVFF  FEF,74B
04AA4:  MOVFF  FEC,01
04AA8:  MOVFF  FEC,02
04AAC:  MOVFF  FEC,03
04AB0:  MOVFF  FEA,70B
04AB4:  MOVFF  FE9,70A
04AB8:  BSF    FD8.1
04ABA:  MOVFF  03,74E
04ABE:  MOVFF  02,74D
04AC2:  MOVFF  01,74C
04AC6:  MOVLB  0
04AC8:  CALL   0E62
04ACC:  MOVFF  70B,FEA
04AD0:  MOVFF  70A,FE9
04AD4:  MOVFF  705,746
04AD8:  MOVFF  704,745
04ADC:  MOVFF  703,744
04AE0:  MOVFF  702,743
04AE4:  MOVFF  03,74A
04AE8:  MOVFF  02,749
04AEC:  MOVFF  01,748
04AF0:  MOVFF  00,747
04AF4:  CALL   0D6C
04AF8:  MOVFF  03,6FF
04AFC:  MOVFF  02,6FE
04B00:  MOVFF  01,6FD
04B04:  MOVFF  00,6FC
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04B08:  MOVLB  6
04B0A:  MOVF   xF3,W
04B0C:  MULLW  20
04B0E:  MOVF   FF3,W
04B10:  MOVLB  7
04B12:  CLRF   x01
04B14:  MOVWF  x00
04B16:  MOVLW  18
04B18:  ADDWF  x00,W
04B1A:  MOVWF  01
04B1C:  MOVLW  00
04B1E:  ADDWFC x01,W
04B20:  MOVWF  03
04B22:  MOVF   01,W
04B24:  ADDLW  20
04B26:  MOVWF  01
04B28:  MOVLW  00
04B2A:  ADDWFC 03,F
04B2C:  MOVFF  01,700
04B30:  MOVFF  03,701
04B34:  MOVLB  6
04B36:  MOVF   xF3,W
04B38:  MULLW  20
04B3A:  MOVF   FF3,W
04B3C:  MOVLB  7
04B3E:  CLRF   x03
04B40:  MOVWF  x02
04B42:  MOVLW  1C
04B44:  ADDWF  x02,W
04B46:  MOVWF  01
04B48:  MOVLW  00
04B4A:  ADDWFC x03,W
04B4C:  MOVWF  03
04B4E:  MOVF   01,W
04B50:  ADDLW  20
04B52:  MOVWF  FE9
04B54:  MOVLW  00
04B56:  ADDWFC 03,W
04B58:  MOVWF  FEA
04B5A:  MOVFF  FEF,74B
04B5E:  MOVFF  FEC,01
04B62:  MOVFF  FEC,02
04B66:  MOVFF  FEC,03
04B6A:  MOVFF  FEA,703
04B6E:  MOVFF  FE9,702
04B72:  BCF    FD8.1
04B74:  MOVFF  6FB,74A
04B78:  MOVFF  6FA,749
04B7C:  MOVFF  6F9,748
04B80:  MOVFF  6F8,747
04B84:  MOVFF  03,74E
04B88:  MOVFF  02,74D
04B8C:  MOVFF  01,74C
04B90:  MOVLB  0
04B92:  CALL   0E62
04B96:  MOVFF  703,FEA
04B9A:  MOVFF  702,FE9
04B9E:  MOVFF  03,707
04BA2:  MOVFF  02,706
04BA6:  MOVFF  01,705
04BAA:  MOVFF  00,704
04BAE:  BCF    FD8.1
04BB0:  MOVFF  03,74A
04BB4:  MOVFF  02,749
04BB8:  MOVFF  01,748
04BBC:  MOVFF  00,747
04BC0:  MOVFF  6FF,74E
04BC4:  MOVFF  6FE,74D
04BC8:  MOVFF  6FD,74C
04BCC:  MOVFF  6FC,74B
04BD0:  CALL   0E62
04BD4:  MOVFF  701,FEA
04BD8:  MOVFF  700,FE9
04BDC:  MOVFF  00,FEF
04BE0:  MOVFF  01,FEC
04BE4:  MOVFF  02,FEC
04BE8:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04BEC:  MOVLB  6
04BEE:  MOVF   xF3,W
04BF0:  MULLW  20
04BF2:  MOVF   FF3,W
04BF4:  MOVLB  7
04BF6:  CLRF   x01
04BF8:  MOVWF  x00
04BFA:  MOVLW  18
04BFC:  ADDWF  x00,W
04BFE:  MOVWF  01
04C00:  MOVLW  00
04C02:  ADDWFC x01,W
04C04:  MOVWF  03
04C06:  MOVF   01,W
04C08:  ADDLW  20
04C0A:  MOVWF  FE9
04C0C:  MOVLW  00
04C0E:  ADDWFC 03,W
04C10:  MOVWF  FEA
04C12:  MOVFF  FEF,747
04C16:  MOVFF  FEC,701
04C1A:  MOVFF  FEC,749
04C1E:  MOVFF  FEC,74A
04C22:  CLRF   x46
04C24:  CLRF   x45
04C26:  MOVLW  7C
04C28:  MOVWF  x44
04C2A:  MOVLW  84
04C2C:  MOVWF  x43
04C2E:  MOVFF  701,748
04C32:  MOVLB  0
04C34:  CALL   1D08
04C38:  BNC   4C6E
04C3A:  MOVLB  6
04C3C:  MOVF   xF3,W
04C3E:  MULLW  20
04C40:  MOVF   FF3,W
04C42:  MOVLB  7
04C44:  CLRF   x01
04C46:  MOVWF  x00
04C48:  MOVLW  18
04C4A:  ADDWF  x00,W
04C4C:  MOVWF  01
04C4E:  MOVLW  00
04C50:  ADDWFC x01,W
04C52:  MOVWF  03
04C54:  MOVF   01,W
04C56:  ADDLW  20
04C58:  MOVWF  FE9
04C5A:  MOVLW  00
04C5C:  ADDWFC 03,W
04C5E:  MOVWF  FEA
04C60:  MOVLW  84
04C62:  MOVWF  FEF
04C64:  MOVLW  7C
04C66:  MOVWF  FEC
04C68:  CLRF   FEC
04C6A:  CLRF   FEC
04C6C:  BRA    4CEE
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04C6E:  MOVLB  6
04C70:  MOVF   xF3,W
04C72:  MULLW  20
04C74:  MOVF   FF3,W
04C76:  MOVLB  7
04C78:  CLRF   x01
04C7A:  MOVWF  x00
04C7C:  MOVLW  18
04C7E:  ADDWF  x00,W
04C80:  MOVWF  01
04C82:  MOVLW  00
04C84:  ADDWFC x01,W
04C86:  MOVWF  03
04C88:  MOVF   01,W
04C8A:  ADDLW  20
04C8C:  MOVWF  FE9
04C8E:  MOVLW  00
04C90:  ADDWFC 03,W
04C92:  MOVWF  FEA
04C94:  MOVFF  FEF,743
04C98:  MOVFF  FEC,701
04C9C:  MOVFF  FEC,745
04CA0:  MOVFF  FEC,746
04CA4:  MOVFF  701,744
04CA8:  CLRF   x4A
04CAA:  CLRF   x49
04CAC:  MOVLW  C0
04CAE:  MOVWF  x48
04CB0:  MOVLW  82
04CB2:  MOVWF  x47
04CB4:  MOVLB  0
04CB6:  CALL   1D08
04CBA:  BNC   4CEE
04CBC:  MOVLB  6
04CBE:  MOVF   xF3,W
04CC0:  MULLW  20
04CC2:  MOVF   FF3,W
04CC4:  MOVLB  7
04CC6:  CLRF   x01
04CC8:  MOVWF  x00
04CCA:  MOVLW  18
04CCC:  ADDWF  x00,W
04CCE:  MOVWF  01
04CD0:  MOVLW  00
04CD2:  ADDWFC x01,W
04CD4:  MOVWF  03
04CD6:  MOVF   01,W
04CD8:  ADDLW  20
04CDA:  MOVWF  FE9
04CDC:  MOVLW  00
04CDE:  ADDWFC 03,W
04CE0:  MOVWF  FEA
04CE2:  MOVLW  82
04CE4:  MOVWF  FEF
04CE6:  MOVLW  C0
04CE8:  MOVWF  FEC
04CEA:  CLRF   FEC
04CEC:  CLRF   FEC
04CEE:  MOVLB  0
04CF0:  GOTO   4D68 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04CF4:  MOVLB  6
04CF6:  MOVF   xF2,W
04CF8:  MULLW  20
04CFA:  MOVF   FF3,W
04CFC:  CLRF   xF4
04CFE:  MOVWF  xF3
04D00:  MOVLW  0C
04D02:  ADDWF  xF3,W
04D04:  MOVWF  01
04D06:  MOVLW  00
04D08:  ADDWFC xF4,W
04D0A:  MOVWF  03
04D0C:  MOVF   01,W
04D0E:  ADDLW  20
04D10:  MOVWF  FE9
04D12:  MOVLW  00
04D14:  ADDWFC 03,W
04D16:  MOVWF  FEA
04D18:  MOVFF  FEF,743
04D1C:  MOVFF  FEC,744
04D20:  MOVFF  FEC,745
04D24:  MOVFF  FEC,746
04D28:  MOVF   xF2,W
04D2A:  MULLW  20
04D2C:  MOVF   FF3,W
04D2E:  CLRF   xF8
04D30:  MOVWF  xF7
04D32:  MOVLW  10
04D34:  ADDWF  xF7,W
04D36:  MOVWF  01
04D38:  MOVLW  00
04D3A:  ADDWFC xF8,W
04D3C:  MOVWF  03
04D3E:  MOVF   01,W
04D40:  ADDLW  20
04D42:  MOVWF  FE9
04D44:  MOVLW  00
04D46:  ADDWFC 03,W
04D48:  MOVWF  FEA
04D4A:  MOVFF  FEF,747
04D4E:  MOVFF  FEC,748
04D52:  MOVFF  FEC,749
04D56:  MOVFF  FEC,74A
04D5A:  MOVLB  0
04D5C:  CALL   1D08
04D60:  BZ    4D68
04D62:  MOVFF  6F2,6F3
04D66:  BRA    4734
....................    if ((index++) >= numChannels) index = 0;
04D68:  MOVLB  1
04D6A:  MOVF   xE7,W
04D6C:  INCF   xE7,F
04D6E:  SUBLW  01
04D70:  BC    4D74
04D72:  CLRF   xE7
04D74:  MOVLB  0
04D76:  GOTO   4E66 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B08:  CLRF   03
00B0A:  MOVF   F91,W
00B0C:  MOVFF  6F4,F91
00B10:  RRCF   F94,W
00B12:  BNC   0B10
00B14:  MOVF   F91,W
00B16:  MOVWF  02
00B18:  MOVFF  6F3,F91
00B1C:  RRCF   F94,W
00B1E:  BNC   0B1C
00B20:  MOVF   F91,W
00B22:  MOVWF  01
00B24:  MOVFF  6F2,F91
00B28:  RRCF   F94,W
00B2A:  BNC   0B28
00B2C:  MOVFF  F91,00
00B30:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04690:  MOVLB  6
04692:  MOVF   xF3,F
04694:  BZ    46E4
....................       if (chMap[0] == ch) output_low(INV_HVX);
04696:  MOVLW  00
04698:  MOVLB  0
0469A:  BTFSC  x60.0
0469C:  MOVLW  01
0469E:  MOVLB  6
046A0:  SUBWF  xF2,W
046A2:  BNZ   46AA
046A4:  MOVLW  C4
046A6:  MOVWF  F88
046A8:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
046AA:  MOVLW  00
046AC:  MOVLB  0
046AE:  BTFSC  x60.1
046B0:  MOVLW  01
046B2:  MOVLB  6
046B4:  SUBWF  xF2,W
046B6:  BNZ   46BE
046B8:  MOVLW  C4
046BA:  MOVWF  F88
046BC:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
046BE:  MOVF   xF2,W
046C0:  MULLW  03
046C2:  MOVF   FF3,W
046C4:  CLRF   xF5
046C6:  MOVWF  xF4
046C8:  MOVLW  02
046CA:  ADDWF  xF4,W
046CC:  MOVWF  01
046CE:  MOVLW  00
046D0:  ADDWFC xF5,W
046D2:  MOVWF  03
046D4:  MOVF   01,W
046D6:  ADDLW  62
046D8:  MOVWF  FE9
046DA:  MOVLW  01
046DC:  ADDWFC 03,W
046DE:  MOVWF  FEA
046E0:  BSF    FEF.0
....................    }
046E2:  BRA    4730
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
046E4:  MOVLW  00
046E6:  MOVLB  0
046E8:  BTFSC  x60.0
046EA:  MOVLW  01
046EC:  MOVLB  6
046EE:  SUBWF  xF2,W
046F0:  BNZ   46F8
046F2:  MOVLW  C4
046F4:  MOVWF  F88
046F6:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
046F8:  MOVLW  00
046FA:  MOVLB  0
046FC:  BTFSC  x60.1
046FE:  MOVLW  01
04700:  MOVLB  6
04702:  SUBWF  xF2,W
04704:  BNZ   470C
04706:  MOVLW  C4
04708:  MOVWF  F88
0470A:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
0470C:  MOVF   xF2,W
0470E:  MULLW  03
04710:  MOVF   FF3,W
04712:  CLRF   xF5
04714:  MOVWF  xF4
04716:  MOVLW  02
04718:  ADDWF  xF4,W
0471A:  MOVWF  01
0471C:  MOVLW  00
0471E:  ADDWFC xF5,W
04720:  MOVWF  03
04722:  MOVF   01,W
04724:  ADDLW  62
04726:  MOVWF  FE9
04728:  MOVLW  01
0472A:  ADDWFC 03,W
0472C:  MOVWF  FEA
0472E:  BCF    FEF.0
....................    }
04730:  MOVLB  0
04732:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04D7A:  MOVLB  6
04D7C:  CLRF   xF1
04D7E:  CLRF   xF0
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
04D80:  MOVFF  6EF,6FC
04D84:  CLRF   xFE
04D86:  MOVLW  61
04D88:  MOVWF  xFD
04D8A:  MOVLB  0
04D8C:  RCALL  465A
04D8E:  MOVF   01,F
04D90:  BNZ   4E60
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04D92:  MOVLB  6
04D94:  MOVF   xEF,W
04D96:  MULLW  04
04D98:  MOVF   FF3,W
04D9A:  CLRF   03
04D9C:  ADDLW  68
04D9E:  MOVWF  FE9
04DA0:  MOVLW  01
04DA2:  ADDWFC 03,W
04DA4:  MOVWF  FEA
04DA6:  MOVFF  FEF,743
04DAA:  MOVFF  FEC,744
04DAE:  MOVFF  FEC,745
04DB2:  MOVFF  FEC,746
04DB6:  MOVLB  7
04DB8:  CLRF   x4A
04DBA:  CLRF   x49
04DBC:  CLRF   x48
04DBE:  CLRF   x47
04DC0:  MOVLB  0
04DC2:  CALL   1D08
04DC6:  BNC   4DD8
04DC8:  MOVFF  6EF,6F2
04DCC:  MOVLW  01
04DCE:  MOVLB  6
04DD0:  MOVWF  xF3
04DD2:  MOVLB  0
04DD4:  RCALL  4690
04DD6:  BRA    4DE4
....................       else                             invert_voltage(ch, FALSE);
04DD8:  MOVFF  6EF,6F2
04DDC:  MOVLB  6
04DDE:  CLRF   xF3
04DE0:  MOVLB  0
04DE2:  RCALL  4690
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04DE4:  MOVLB  6
04DE6:  MOVF   xEF,W
04DE8:  MULLW  04
04DEA:  MOVF   FF3,W
04DEC:  CLRF   03
04DEE:  ADDLW  68
04DF0:  MOVWF  FE9
04DF2:  MOVLW  01
04DF4:  ADDWFC 03,W
04DF6:  MOVWF  FEA
04DF8:  MOVFF  FEF,00
04DFC:  MOVFF  FEC,01
04E00:  MOVFF  FEC,02
04E04:  MOVFF  FEC,03
04E08:  BCF    01.7
04E0A:  MOVFF  03,6F5
04E0E:  MOVFF  02,6F4
04E12:  MOVFF  01,6F3
04E16:  MOVFF  00,6F2
04E1A:  MOVFF  03,746
04E1E:  MOVFF  02,745
04E22:  MOVFF  01,744
04E26:  MOVFF  00,743
04E2A:  MOVLW  66
04E2C:  MOVLB  7
04E2E:  MOVWF  x4A
04E30:  MOVLW  D6
04E32:  MOVWF  x49
04E34:  MOVLW  23
04E36:  MOVWF  x48
04E38:  MOVLW  88
04E3A:  MOVWF  x47
04E3C:  MOVLB  0
04E3E:  CALL   0D6C
04E42:  MOVFF  03,746
04E46:  MOVFF  02,745
04E4A:  MOVFF  01,744
04E4E:  MOVFF  00,743
04E52:  CALL   26FC
04E56:  MOVFF  02,6F1
04E5A:  MOVFF  01,6F0
....................    }
04E5E:  BRA    4F56
....................    else {
....................       pid_task(ch);
04E60:  MOVFF  6EF,6F2
04E64:  BRA    4CF4
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04E66:  MOVLB  6
04E68:  MOVF   xEF,W
04E6A:  MULLW  20
04E6C:  MOVF   FF3,W
04E6E:  CLRF   xF3
04E70:  MOVWF  xF2
04E72:  MOVLW  18
04E74:  ADDWF  xF2,W
04E76:  MOVWF  01
04E78:  MOVLW  00
04E7A:  ADDWFC xF3,W
04E7C:  MOVWF  03
04E7E:  MOVF   01,W
04E80:  ADDLW  20
04E82:  MOVWF  FE9
04E84:  MOVLW  00
04E86:  ADDWFC 03,W
04E88:  MOVWF  FEA
04E8A:  MOVFF  FEF,743
04E8E:  MOVFF  FEC,744
04E92:  MOVFF  FEC,745
04E96:  MOVFF  FEC,746
04E9A:  MOVLB  7
04E9C:  CLRF   x4A
04E9E:  CLRF   x49
04EA0:  CLRF   x48
04EA2:  CLRF   x47
04EA4:  MOVLB  0
04EA6:  CALL   1D08
04EAA:  BNC   4EBE
04EAC:  MOVFF  6EF,6F2
04EB0:  MOVLW  01
04EB2:  MOVLB  6
04EB4:  MOVWF  xF3
04EB6:  MOVLB  0
04EB8:  CALL   4690
04EBC:  BRA    4ECC
....................       else                       invert_voltage(ch, FALSE);
04EBE:  MOVFF  6EF,6F2
04EC2:  MOVLB  6
04EC4:  CLRF   xF3
04EC6:  MOVLB  0
04EC8:  CALL   4690
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04ECC:  MOVLB  6
04ECE:  MOVF   xEF,W
04ED0:  MULLW  20
04ED2:  MOVF   FF3,W
04ED4:  CLRF   xF3
04ED6:  MOVWF  xF2
04ED8:  MOVLW  18
04EDA:  ADDWF  xF2,W
04EDC:  MOVWF  01
04EDE:  MOVLW  00
04EE0:  ADDWFC xF3,W
04EE2:  MOVWF  03
04EE4:  MOVF   01,W
04EE6:  ADDLW  20
04EE8:  MOVWF  FE9
04EEA:  MOVLW  00
04EEC:  ADDWFC 03,W
04EEE:  MOVWF  FEA
04EF0:  MOVFF  FEF,00
04EF4:  MOVFF  FEC,01
04EF8:  MOVFF  FEC,02
04EFC:  MOVFF  FEC,03
04F00:  BCF    01.7
04F02:  MOVFF  03,6F5
04F06:  MOVFF  02,6F4
04F0A:  MOVFF  01,6F3
04F0E:  MOVFF  00,6F2
04F12:  MOVFF  03,746
04F16:  MOVFF  02,745
04F1A:  MOVFF  01,744
04F1E:  MOVFF  00,743
04F22:  MOVLW  66
04F24:  MOVLB  7
04F26:  MOVWF  x4A
04F28:  MOVLW  D6
04F2A:  MOVWF  x49
04F2C:  MOVLW  23
04F2E:  MOVWF  x48
04F30:  MOVLW  88
04F32:  MOVWF  x47
04F34:  MOVLB  0
04F36:  CALL   0D6C
04F3A:  MOVFF  03,746
04F3E:  MOVFF  02,745
04F42:  MOVFF  01,744
04F46:  MOVFF  00,743
04F4A:  CALL   26FC
04F4E:  MOVFF  02,6F1
04F52:  MOVFF  01,6F0
....................    }
....................    
....................    dacVals[ch].val = txData;
04F56:  MOVLB  6
04F58:  MOVF   xEF,W
04F5A:  MULLW  03
04F5C:  MOVF   FF3,W
04F5E:  CLRF   xF3
04F60:  MOVWF  xF2
04F62:  MOVLW  62
04F64:  ADDWF  xF2,W
04F66:  MOVWF  FE9
04F68:  MOVLW  01
04F6A:  ADDWFC xF3,W
04F6C:  MOVWF  FEA
04F6E:  MOVFF  6F1,FEC
04F72:  MOVF   FED,F
04F74:  MOVFF  6F0,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04F78:  MOVLW  00
04F7A:  MOVLB  0
04F7C:  BTFSC  x60.0
04F7E:  MOVLW  01
04F80:  MOVLB  6
04F82:  SUBWF  xEF,W
04F84:  BNZ   4F8C
04F86:  MOVLW  E8
04F88:  MOVWF  F8B
04F8A:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04F8C:  MOVLW  00
04F8E:  MOVLB  0
04F90:  BTFSC  x60.1
04F92:  MOVLW  01
04F94:  MOVLB  6
04F96:  SUBWF  xEF,W
04F98:  BNZ   4FA0
04F9A:  MOVLW  E8
04F9C:  MOVWF  F8B
04F9E:  BSF    F86.1
....................    
....................    delay_ms(1);
04FA0:  MOVLW  01
04FA2:  MOVWF  xF5
04FA4:  MOVLB  0
04FA6:  CALL   03A4
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
04FAA:  MOVLW  00
04FAC:  BTFSC  x60.0
04FAE:  MOVLW  01
04FB0:  MOVLB  6
04FB2:  SUBWF  xEF,W
04FB4:  BNZ   4FBC
04FB6:  MOVLW  E8
04FB8:  MOVWF  F8B
04FBA:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04FBC:  MOVLW  00
04FBE:  MOVLB  0
04FC0:  BTFSC  x60.1
04FC2:  MOVLW  01
04FC4:  MOVLB  6
04FC6:  SUBWF  xEF,W
04FC8:  BNZ   4FD0
04FCA:  MOVLW  E8
04FCC:  MOVWF  F8B
04FCE:  BCF    F86.1
....................    delay_ms(1);
04FD0:  MOVLW  01
04FD2:  MOVWF  xF5
04FD4:  MOVLB  0
04FD6:  CALL   03A4
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
04FDA:  MOVLB  6
04FDC:  CLRF   xF5
04FDE:  CLRF   xF4
04FE0:  MOVFF  6F1,6F3
04FE4:  MOVFF  6F0,6F2
04FE8:  MOVLB  0
04FEA:  CALL   0B08
....................    delay_ms(1);
04FEE:  MOVLW  01
04FF0:  MOVLB  6
04FF2:  MOVWF  xF5
04FF4:  MOVLB  0
04FF6:  CALL   03A4
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
04FFA:  MOVLW  00
04FFC:  BTFSC  x60.0
04FFE:  MOVLW  01
05000:  MOVLB  6
05002:  SUBWF  xEF,W
05004:  BNZ   500C
05006:  MOVLW  E8
05008:  MOVWF  F8B
0500A:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
0500C:  MOVLW  00
0500E:  MOVLB  0
05010:  BTFSC  x60.1
05012:  MOVLW  01
05014:  MOVLB  6
05016:  SUBWF  xEF,W
05018:  BNZ   5020
0501A:  MOVLW  E8
0501C:  MOVWF  F8B
0501E:  BSF    F86.1
05020:  MOVLB  0
05022:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  zero a stage axis by finding the midpoint                                */ 
.................... /*****************************************************************************/
.................... void zero_stage(channelMap ch){
....................    float maxSP = 0;
....................    float minSP = 0;
....................    
....................    chMode[ch] = MANUAL;          // set channel to manual
....................    manualOutputValues[ch] = 0;   // set channel output to 0%
....................    set_nanoDAC_outputs(ch);
....................    
....................    for (int i=0; i<3; i++){
....................       manualOutputValues[ch] = op_upper_bound;
....................       set_nanoDAC_outputs(ch);
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
05024:  MOVLB  1
05026:  MOVF   xE8,W
05028:  XORLW  00
0502A:  MOVLB  0
0502C:  BZ    5034
0502E:  XORLW  01
05030:  BZ    5046
05032:  BRA    5056
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
05034:  MOVLB  6
05036:  CLRF   xEF
05038:  MOVLB  0
0503A:  RCALL  4D7A
....................          state = 1;
0503C:  MOVLW  01
0503E:  MOVLB  1
05040:  MOVWF  xE8
....................       break;
05042:  MOVLB  0
05044:  BRA    5056
....................       case 1:
....................          set_nanoDAC_outputs(chY);
05046:  MOVLW  01
05048:  MOVLB  6
0504A:  MOVWF  xEF
0504C:  MOVLB  0
0504E:  RCALL  4D7A
....................          state = 0;
05050:  MOVLB  1
05052:  CLRF   xE8
....................       break;
05054:  MOVLB  0
....................    }
05056:  GOTO   A790 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B32:  MOVLB  6
00B34:  CLRF   xF5
00B36:  CLRF   xF4
00B38:  CLRF   xF3
00B3A:  CLRF   xF2
00B3C:  MOVLB  0
00B3E:  RCALL  0B08
....................    output_low(_SYNC_X);
00B40:  MOVLW  E8
00B42:  MOVWF  F8B
00B44:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B46:  MOVWF  F8B
00B48:  BCF    F86.1
....................    output_high(_SYNC_X);
00B4A:  MOVWF  F8B
00B4C:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B4E:  MOVWF  F8B
00B50:  BSF    F86.1
00B52:  GOTO   A764 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B56:  MOVLB  6
00B58:  MOVF   xF0,W
00B5A:  SUBLW  03
00B5C:  BTFSS  FD8.0
00B5E:  BRA    0CDC
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B60:  CLRF   xF1
00B62:  MOVF   xF1,W
00B64:  SUBLW  06
00B66:  BNC   0BBA
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B68:  MOVLB  7
00B6A:  CLRF   x31
00B6C:  MOVFF  6F0,730
00B70:  CLRF   x33
00B72:  MOVLW  B5
00B74:  MOVWF  x32
00B76:  MOVLB  0
00B78:  RCALL  0874
00B7A:  MOVFF  02,6F3
00B7E:  MOVFF  01,6F2
00B82:  MOVLW  06
00B84:  MOVLB  6
00B86:  ADDWF  xF2,F
00B88:  MOVLW  00
00B8A:  ADDWFC xF3,F
00B8C:  MOVLB  7
00B8E:  CLRF   x31
00B90:  MOVFF  6F1,730
00B94:  CLRF   x33
00B96:  MOVLW  19
00B98:  MOVWF  x32
00B9A:  MOVLB  0
00B9C:  RCALL  0874
00B9E:  MOVF   01,W
00BA0:  MOVLB  6
00BA2:  ADDWF  xF2,F
00BA4:  MOVF   02,W
00BA6:  ADDWFC xF3,F
00BA8:  MOVLW  E9
00BAA:  ADDWF  xF2,W
00BAC:  MOVWF  FE9
00BAE:  MOVLW  01
00BB0:  ADDWFC xF3,W
00BB2:  MOVWF  FEA
00BB4:  CLRF   FEF
00BB6:  INCF   xF1,F
00BB8:  BRA    0B62
....................       }
....................       SERcmd[recNum].t = 0;
00BBA:  MOVLB  7
00BBC:  CLRF   x31
00BBE:  MOVFF  6F0,730
00BC2:  CLRF   x33
00BC4:  MOVLW  B5
00BC6:  MOVWF  x32
00BC8:  MOVLB  0
00BCA:  RCALL  0874
00BCC:  MOVFF  01,6F2
00BD0:  MOVLW  05
00BD2:  MOVLB  6
00BD4:  ADDWF  01,W
00BD6:  MOVWF  01
00BD8:  MOVLW  00
00BDA:  ADDWFC 02,W
00BDC:  MOVWF  03
00BDE:  MOVF   01,W
00BE0:  ADDLW  E9
00BE2:  MOVWF  FE9
00BE4:  MOVLW  01
00BE6:  ADDWFC 03,W
00BE8:  MOVWF  FEA
00BEA:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00BEC:  MOVLB  7
00BEE:  CLRF   x31
00BF0:  MOVFF  6F0,730
00BF4:  CLRF   x33
00BF6:  MOVLW  B5
00BF8:  MOVWF  x32
00BFA:  MOVLB  0
00BFC:  RCALL  0874
00BFE:  MOVFF  01,6F2
00C02:  MOVLW  01
00C04:  MOVLB  6
00C06:  ADDWF  01,W
00C08:  MOVWF  01
00C0A:  MOVLW  00
00C0C:  ADDWFC 02,W
00C0E:  MOVWF  03
00C10:  MOVF   01,W
00C12:  ADDLW  E9
00C14:  MOVWF  FE9
00C16:  MOVLW  01
00C18:  ADDWFC 03,W
00C1A:  MOVWF  FEA
00C1C:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C1E:  MOVLB  7
00C20:  CLRF   x31
00C22:  MOVFF  6F0,730
00C26:  CLRF   x33
00C28:  MOVLW  B5
00C2A:  MOVWF  x32
00C2C:  MOVLB  0
00C2E:  RCALL  0874
00C30:  MOVFF  01,6F2
00C34:  MOVLW  02
00C36:  MOVLB  6
00C38:  ADDWF  01,W
00C3A:  MOVWF  01
00C3C:  MOVLW  00
00C3E:  ADDWFC 02,W
00C40:  MOVWF  03
00C42:  MOVF   01,W
00C44:  ADDLW  E9
00C46:  MOVWF  FE9
00C48:  MOVLW  01
00C4A:  ADDWFC 03,W
00C4C:  MOVWF  FEA
00C4E:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C50:  MOVLB  7
00C52:  CLRF   x31
00C54:  MOVFF  6F0,730
00C58:  CLRF   x33
00C5A:  MOVLW  B5
00C5C:  MOVWF  x32
00C5E:  MOVLB  0
00C60:  RCALL  0874
00C62:  MOVFF  01,6F2
00C66:  MOVLW  03
00C68:  MOVLB  6
00C6A:  ADDWF  01,W
00C6C:  MOVWF  01
00C6E:  MOVLW  00
00C70:  ADDWFC 02,W
00C72:  MOVWF  03
00C74:  MOVF   01,W
00C76:  ADDLW  E9
00C78:  MOVWF  FE9
00C7A:  MOVLW  01
00C7C:  ADDWFC 03,W
00C7E:  MOVWF  FEA
00C80:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C82:  MOVLB  7
00C84:  CLRF   x31
00C86:  MOVFF  6F0,730
00C8A:  CLRF   x33
00C8C:  MOVLW  B5
00C8E:  MOVWF  x32
00C90:  MOVLB  0
00C92:  RCALL  0874
00C94:  MOVFF  01,6F2
00C98:  MOVLW  04
00C9A:  MOVLB  6
00C9C:  ADDWF  01,W
00C9E:  MOVWF  01
00CA0:  MOVLW  00
00CA2:  ADDWFC 02,W
00CA4:  MOVWF  03
00CA6:  MOVF   01,W
00CA8:  ADDLW  E9
00CAA:  MOVWF  FE9
00CAC:  MOVLW  01
00CAE:  ADDWFC 03,W
00CB0:  MOVWF  FEA
00CB2:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CB4:  MOVLB  7
00CB6:  CLRF   x31
00CB8:  MOVFF  6F0,730
00CBC:  CLRF   x33
00CBE:  MOVLW  B5
00CC0:  MOVWF  x32
00CC2:  MOVLB  0
00CC4:  RCALL  0874
00CC6:  MOVLW  E9
00CC8:  MOVLB  6
00CCA:  ADDWF  01,W
00CCC:  MOVWF  FE9
00CCE:  MOVLW  01
00CD0:  ADDWFC 02,W
00CD2:  MOVWF  FEA
00CD4:  BCF    FEF.0
....................       retData[0] = '\0';
00CD6:  MOVLB  4
00CD8:  CLRF   xBF
00CDA:  MOVLB  6
....................    }
00CDC:  MOVLB  0
00CDE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05AA4:  MOVLB  7
05AA6:  CLRF   x31
05AA8:  MOVFF  4BD,730
05AAC:  CLRF   x33
05AAE:  MOVLW  B5
05AB0:  MOVWF  x32
05AB2:  MOVLB  0
05AB4:  CALL   0874
05AB8:  MOVFF  02,6F1
05ABC:  MOVFF  01,6F0
05AC0:  MOVLW  E9
05AC2:  MOVLB  6
05AC4:  ADDWF  01,W
05AC6:  MOVWF  FE9
05AC8:  MOVLW  01
05ACA:  ADDWFC 02,W
05ACC:  MOVWF  FEA
05ACE:  BTFSC  FEF.0
05AD0:  BRA    5AF2
....................    {
....................       if (SRI == SWI) return FALSE;
05AD2:  MOVLB  4
05AD4:  MOVF   xBE,W
05AD6:  SUBWF  xBD,W
05AD8:  BNZ   5AE0
05ADA:  MOVLW  00
05ADC:  MOVWF  01
05ADE:  BRA    5AF8
....................       SRI +=1;
05AE0:  MOVLW  01
05AE2:  ADDWF  xBD,F
....................       if (SRI >= numRecords) SRI=0;
05AE4:  MOVF   xBD,W
05AE6:  SUBLW  03
05AE8:  BC    5AEC
05AEA:  CLRF   xBD
05AEC:  MOVLB  0
05AEE:  BRA    5AA4
05AF0:  MOVLB  6
....................    }
....................    return TRUE;
05AF2:  MOVLW  01
05AF4:  MOVWF  01
05AF6:  MOVLB  4
05AF8:  MOVLB  0
05AFA:  GOTO   A238 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05092:  MOVLW  01
05094:  MOVLB  4
05096:  ADDWF  xBE,F
....................    if (SWI >= numRecords) SWI=0;
05098:  MOVF   xBE,W
0509A:  SUBLW  03
0509C:  BC    50A0
0509E:  CLRF   xBE
050A0:  MOVLB  0
050A2:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,561
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x61.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* pBuff){
....................     output_high(TX_ENABLE);
*
0A1E8:  MOVLW  93
0A1EA:  MOVWF  F89
0A1EC:  BSF    F84.5
....................     delay_us(500);
0A1EE:  MOVLW  02
0A1F0:  MOVLB  6
0A1F2:  MOVWF  xF2
0A1F4:  MOVLW  FA
0A1F6:  MOVWF  xFB
0A1F8:  MOVLB  0
0A1FA:  CALL   0702
0A1FE:  MOVLB  6
0A200:  DECFSZ xF2,F
0A202:  BRA    A1F4
....................     
....................     fprintf(SERIAL, "%s", pBuff);
0A204:  MOVFF  6F1,FEA
0A208:  MOVFF  6F0,FE9
0A20C:  MOVLB  0
0A20E:  CALL   50A4
....................     delay_us(500);
0A212:  MOVLW  02
0A214:  MOVLB  6
0A216:  MOVWF  xF2
0A218:  MOVLW  FA
0A21A:  MOVWF  xFB
0A21C:  MOVLB  0
0A21E:  CALL   0702
0A222:  MOVLB  6
0A224:  DECFSZ xF2,F
0A226:  BRA    A218
....................     
....................     output_low(TX_ENABLE);
0A228:  MOVLW  93
0A22A:  MOVWF  F89
0A22C:  BCF    F84.5
0A22E:  MOVLB  0
0A230:  GOTO   A350 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x5F,W
000F6:  ADDLW  23
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,767
00104:  MOVFF  FE9,766
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  767,FEA
00110:  MOVFF  766,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x5F,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x5F,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x5F
....................       BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x61.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................    }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
0505A:  CLRF   03
0505C:  MOVLB  5
0505E:  MOVF   x60,W
05060:  ADDLW  23
05062:  MOVWF  FE9
05064:  MOVLW  05
05066:  ADDWFC 03,W
05068:  MOVWF  FEA
0506A:  MOVFF  FEF,6F0
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
0506E:  MOVLW  01
05070:  ADDWF  x60,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05072:  MOVF   x60,W
05074:  SUBLW  3B
05076:  BC    507A
05078:  CLRF   x60
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
0507A:  MOVF   x5F,W
0507C:  SUBWF  x60,W
0507E:  BNZ   5086
05080:  MOVLB  1
05082:  BCF    x61.1
05084:  MOVLB  5
....................    return data;
05086:  MOVLB  6
05088:  MOVFF  6F0,01
0508C:  MOVLB  0
0508E:  GOTO   5110 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
050CE:  MOVLB  1
050D0:  BTFSS  x61.1
050D2:  BRA    55E0
050D4:  MOVLB  7
050D6:  CLRF   x31
050D8:  MOVFF  4BE,730
050DC:  CLRF   x33
050DE:  MOVLW  B5
050E0:  MOVWF  x32
050E2:  MOVLB  0
050E4:  CALL   0874
050E8:  MOVFF  02,6F1
050EC:  MOVFF  01,6F0
050F0:  MOVLW  E9
050F2:  MOVLB  6
050F4:  ADDWF  01,W
050F6:  MOVWF  01
050F8:  MOVLW  01
050FA:  ADDWFC 02,W
050FC:  MOVWF  03
050FE:  MOVFF  01,FE9
05102:  MOVWF  FEA
05104:  BTFSS  FEF.0
05106:  BRA    510C
05108:  MOVLB  1
0510A:  BRA    55E0
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
0510C:  MOVLB  0
0510E:  BRA    505A
05110:  MOVFF  01,6EF
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05114:  MOVLB  6
05116:  MOVF   xEF,W
05118:  SUBLW  0D
0511A:  BZ    5122
0511C:  MOVF   xEF,W
0511E:  SUBLW  20
05120:  BNZ   5124
....................       {
....................       }
05122:  BRA    55DA
....................       else if (rxChar == UART_SOT_CHAR)
05124:  MOVF   xEF,W
05126:  SUBLW  7E
05128:  BNZ   516C
....................       {
....................          resetSERcmd(SWI);
0512A:  MOVFF  4BE,6F0
0512E:  MOVLB  0
05130:  CALL   0B56
....................          SERcmd[SWI].t = rxChar;
05134:  MOVLB  7
05136:  CLRF   x31
05138:  MOVFF  4BE,730
0513C:  CLRF   x33
0513E:  MOVLW  B5
05140:  MOVWF  x32
05142:  MOVLB  0
05144:  CALL   0874
05148:  MOVFF  01,6F0
0514C:  MOVLW  05
0514E:  MOVLB  6
05150:  ADDWF  01,W
05152:  MOVWF  01
05154:  MOVLW  00
05156:  ADDWFC 02,W
05158:  MOVWF  03
0515A:  MOVF   01,W
0515C:  ADDLW  E9
0515E:  MOVWF  FE9
05160:  MOVLW  01
05162:  ADDWFC 03,W
05164:  MOVWF  FEA
05166:  MOVFF  6EF,FEF
....................       }
0516A:  BRA    55DA
....................       else if (rxChar >= oneByteCmdTestValue)
0516C:  MOVF   xEF,W
0516E:  SUBLW  7F
05170:  BC    51DE
....................       {
....................          resetSERcmd(SWI);
05172:  MOVFF  4BE,6F0
05176:  MOVLB  0
05178:  CALL   0B56
....................          SERcmd[SWI].t = rxChar;
0517C:  MOVLB  7
0517E:  CLRF   x31
05180:  MOVFF  4BE,730
05184:  CLRF   x33
05186:  MOVLW  B5
05188:  MOVWF  x32
0518A:  MOVLB  0
0518C:  CALL   0874
05190:  MOVFF  01,6F0
05194:  MOVLW  05
05196:  MOVLB  6
05198:  ADDWF  01,W
0519A:  MOVWF  01
0519C:  MOVLW  00
0519E:  ADDWFC 02,W
051A0:  MOVWF  03
051A2:  MOVF   01,W
051A4:  ADDLW  E9
051A6:  MOVWF  FE9
051A8:  MOVLW  01
051AA:  ADDWFC 03,W
051AC:  MOVWF  FEA
051AE:  MOVFF  6EF,FEF
....................          SERcmd[SWI].full = TRUE;
051B2:  MOVLB  7
051B4:  CLRF   x31
051B6:  MOVFF  4BE,730
051BA:  CLRF   x33
051BC:  MOVLW  B5
051BE:  MOVWF  x32
051C0:  MOVLB  0
051C2:  CALL   0874
051C6:  MOVLW  E9
051C8:  MOVLB  6
051CA:  ADDWF  01,W
051CC:  MOVWF  FE9
051CE:  MOVLW  01
051D0:  ADDWFC 02,W
051D2:  MOVWF  FEA
051D4:  BSF    FEF.0
....................          setNextSERWriteIndex();
051D6:  MOVLB  0
051D8:  RCALL  5092
....................       }
051DA:  BRA    55D8
051DC:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
051DE:  MOVF   xEF,W
051E0:  SUBLW  0A
051E2:  BTFSS  FD8.2
051E4:  BRA    52F2
....................       {
....................          SERcmd[SWI].full = TRUE;
051E6:  MOVLB  7
051E8:  CLRF   x31
051EA:  MOVFF  4BE,730
051EE:  CLRF   x33
051F0:  MOVLW  B5
051F2:  MOVWF  x32
051F4:  MOVLB  0
051F6:  CALL   0874
051FA:  MOVLW  E9
051FC:  MOVLB  6
051FE:  ADDWF  01,W
05200:  MOVWF  FE9
05202:  MOVLW  01
05204:  ADDWFC 02,W
05206:  MOVWF  FEA
05208:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
0520A:  MOVLB  7
0520C:  CLRF   x31
0520E:  MOVFF  4BE,730
05212:  CLRF   x33
05214:  MOVLW  B5
05216:  MOVWF  x32
05218:  MOVLB  0
0521A:  CALL   0874
0521E:  MOVFF  01,6F0
05222:  MOVLW  04
05224:  ADDWF  01,W
05226:  MOVWF  01
05228:  MOVLW  00
0522A:  ADDWFC 02,W
0522C:  MOVWF  03
0522E:  MOVF   01,W
05230:  ADDLW  E9
05232:  MOVWF  01
05234:  MOVLW  01
05236:  ADDWFC 03,F
05238:  MOVFF  01,6F0
0523C:  MOVFF  03,6F1
05240:  MOVLB  7
05242:  CLRF   x31
05244:  MOVFF  4BE,730
05248:  CLRF   x33
0524A:  MOVLW  B5
0524C:  MOVWF  x32
0524E:  MOVLB  0
05250:  CALL   0874
05254:  MOVFF  01,6F2
05258:  MOVLW  02
0525A:  MOVLB  6
0525C:  ADDWF  01,W
0525E:  MOVWF  01
05260:  MOVLW  00
05262:  ADDWFC 02,W
05264:  MOVWF  03
05266:  MOVF   01,W
05268:  ADDLW  E9
0526A:  MOVWF  FE9
0526C:  MOVLW  01
0526E:  ADDWFC 03,W
05270:  MOVWF  FEA
05272:  MOVFF  FEF,6F2
05276:  MOVFF  6F1,FEA
0527A:  MOVFF  6F0,FE9
0527E:  MOVFF  6F2,FEF
....................          SERcmd[SWI].chrIndex = 0;
05282:  MOVLB  7
05284:  CLRF   x31
05286:  MOVFF  4BE,730
0528A:  CLRF   x33
0528C:  MOVLW  B5
0528E:  MOVWF  x32
05290:  MOVLB  0
05292:  CALL   0874
05296:  MOVFF  01,6F0
0529A:  MOVLW  01
0529C:  MOVLB  6
0529E:  ADDWF  01,W
052A0:  MOVWF  01
052A2:  MOVLW  00
052A4:  ADDWFC 02,W
052A6:  MOVWF  03
052A8:  MOVF   01,W
052AA:  ADDLW  E9
052AC:  MOVWF  FE9
052AE:  MOVLW  01
052B0:  ADDWFC 03,W
052B2:  MOVWF  FEA
052B4:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
052B6:  MOVLB  7
052B8:  CLRF   x31
052BA:  MOVFF  4BE,730
052BE:  CLRF   x33
052C0:  MOVLW  B5
052C2:  MOVWF  x32
052C4:  MOVLB  0
052C6:  CALL   0874
052CA:  MOVFF  01,6F0
052CE:  MOVLW  02
052D0:  MOVLB  6
052D2:  ADDWF  01,W
052D4:  MOVWF  01
052D6:  MOVLW  00
052D8:  ADDWFC 02,W
052DA:  MOVWF  03
052DC:  MOVF   01,W
052DE:  ADDLW  E9
052E0:  MOVWF  FE9
052E2:  MOVLW  01
052E4:  ADDWFC 03,W
052E6:  MOVWF  FEA
052E8:  CLRF   FEF
....................          setNextSERWriteIndex();
052EA:  MOVLB  0
052EC:  RCALL  5092
....................       }
052EE:  BRA    55D8
052F0:  MOVLB  6
....................       else if (rxChar == delimiter)
052F2:  MOVF   xEF,W
052F4:  SUBLW  2C
052F6:  BNZ   53BA
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052F8:  MOVLB  7
052FA:  CLRF   x31
052FC:  MOVFF  4BE,730
05300:  CLRF   x33
05302:  MOVLW  B5
05304:  MOVWF  x32
05306:  MOVLB  0
05308:  CALL   0874
0530C:  MOVFF  02,6F1
05310:  MOVFF  01,6F0
05314:  MOVLW  02
05316:  MOVLB  6
05318:  ADDWF  01,W
0531A:  MOVWF  01
0531C:  MOVLW  00
0531E:  ADDWFC 02,W
05320:  MOVWF  03
05322:  MOVF   01,W
05324:  ADDLW  E9
05326:  MOVWF  FE9
05328:  MOVLW  01
0532A:  ADDWFC 03,W
0532C:  MOVWF  FEA
0532E:  MOVF   FEF,W
05330:  SUBLW  05
05332:  BNC   53A2
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05334:  MOVLB  7
05336:  CLRF   x31
05338:  MOVFF  4BE,730
0533C:  CLRF   x33
0533E:  MOVLW  B5
05340:  MOVWF  x32
05342:  MOVLB  0
05344:  CALL   0874
05348:  MOVFF  01,6F0
0534C:  MOVLW  02
0534E:  MOVLB  6
05350:  ADDWF  01,W
05352:  MOVWF  01
05354:  MOVLW  00
05356:  ADDWFC 02,W
05358:  MOVWF  03
0535A:  MOVF   01,W
0535C:  ADDLW  E9
0535E:  MOVWF  FE9
05360:  MOVLW  01
05362:  ADDWFC 03,W
05364:  MOVWF  FEA
05366:  MOVLW  01
05368:  ADDWF  FEF,W
0536A:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0536C:  MOVLB  7
0536E:  CLRF   x31
05370:  MOVFF  4BE,730
05374:  CLRF   x33
05376:  MOVLW  B5
05378:  MOVWF  x32
0537A:  MOVLB  0
0537C:  CALL   0874
05380:  MOVFF  01,6F0
05384:  MOVLW  01
05386:  MOVLB  6
05388:  ADDWF  01,W
0538A:  MOVWF  01
0538C:  MOVLW  00
0538E:  ADDWFC 02,W
05390:  MOVWF  03
05392:  MOVF   01,W
05394:  ADDLW  E9
05396:  MOVWF  FE9
05398:  MOVLW  01
0539A:  ADDWFC 03,W
0539C:  MOVWF  FEA
0539E:  CLRF   FEF
....................          }
053A0:  BRA    53B8
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
053A2:  MOVFF  4BE,6F0
053A6:  MOVLB  0
053A8:  CALL   0B56
....................             fprintf(SERIAL, retData);
053AC:  MOVLW  04
053AE:  MOVWF  FEA
053B0:  MOVLW  BF
053B2:  MOVWF  FE9
053B4:  RCALL  50A4
053B6:  MOVLB  6
....................          }
....................       }
053B8:  BRA    55DA
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
053BA:  MOVLB  7
053BC:  CLRF   x31
053BE:  MOVFF  4BE,730
053C2:  CLRF   x33
053C4:  MOVLW  B5
053C6:  MOVWF  x32
053C8:  MOVLB  0
053CA:  CALL   0874
053CE:  MOVFF  02,6F1
053D2:  MOVFF  01,6F0
053D6:  MOVLW  01
053D8:  MOVLB  6
053DA:  ADDWF  01,W
053DC:  MOVWF  01
053DE:  MOVLW  00
053E0:  ADDWFC 02,W
053E2:  MOVWF  03
053E4:  MOVF   01,W
053E6:  ADDLW  E9
053E8:  MOVWF  FE9
053EA:  MOVLW  01
053EC:  ADDWFC 03,W
053EE:  MOVWF  FEA
053F0:  MOVF   FEF,W
053F2:  SUBLW  18
053F4:  BTFSS  FD8.0
053F6:  BRA    55C4
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053F8:  MOVLB  7
053FA:  CLRF   x31
053FC:  MOVFF  4BE,730
05400:  CLRF   x33
05402:  MOVLW  B5
05404:  MOVWF  x32
05406:  MOVLB  0
05408:  CALL   0874
0540C:  MOVFF  02,6F1
05410:  MOVFF  01,6F0
05414:  MOVLW  06
05416:  MOVLB  6
05418:  ADDWF  xF0,F
0541A:  MOVLW  00
0541C:  ADDWFC xF1,F
0541E:  MOVLB  7
05420:  CLRF   x31
05422:  MOVFF  4BE,730
05426:  CLRF   x33
05428:  MOVLW  B5
0542A:  MOVWF  x32
0542C:  MOVLB  0
0542E:  CALL   0874
05432:  MOVFF  02,6F3
05436:  MOVFF  01,6F2
0543A:  MOVLW  02
0543C:  ADDWF  01,W
0543E:  MOVWF  01
05440:  MOVLW  00
05442:  ADDWFC 02,W
05444:  MOVWF  03
05446:  MOVF   01,W
05448:  ADDLW  E9
0544A:  MOVWF  FE9
0544C:  MOVLW  01
0544E:  ADDWFC 03,W
05450:  MOVWF  FEA
05452:  MOVLB  7
05454:  CLRF   x31
05456:  MOVFF  FEF,730
0545A:  CLRF   x33
0545C:  MOVLW  19
0545E:  MOVWF  x32
05460:  MOVLB  0
05462:  CALL   0874
05466:  MOVFF  02,03
0546A:  MOVF   01,W
0546C:  MOVLB  6
0546E:  ADDWF  xF0,F
05470:  MOVF   02,W
05472:  ADDWFC xF1,F
05474:  MOVLB  7
05476:  CLRF   x31
05478:  MOVFF  4BE,730
0547C:  CLRF   x33
0547E:  MOVLW  B5
05480:  MOVWF  x32
05482:  MOVLB  0
05484:  CALL   0874
05488:  MOVFF  01,6F2
0548C:  MOVLW  01
0548E:  MOVLB  6
05490:  ADDWF  01,W
05492:  MOVWF  01
05494:  MOVLW  00
05496:  ADDWFC 02,W
05498:  MOVWF  03
0549A:  MOVF   01,W
0549C:  ADDLW  E9
0549E:  MOVWF  FE9
054A0:  MOVLW  01
054A2:  ADDWFC 03,W
054A4:  MOVWF  FEA
054A6:  MOVF   FEF,W
054A8:  ADDWF  xF0,W
054AA:  MOVWF  01
054AC:  MOVLW  00
054AE:  ADDWFC xF1,W
054B0:  MOVWF  03
054B2:  MOVF   01,W
054B4:  ADDLW  E9
054B6:  MOVWF  FE9
054B8:  MOVLW  01
054BA:  ADDWFC 03,W
054BC:  MOVWF  FEA
054BE:  MOVFF  6EF,FEF
....................             SERcmd[SWI].chrIndex += 1;
054C2:  MOVLB  7
054C4:  CLRF   x31
054C6:  MOVFF  4BE,730
054CA:  CLRF   x33
054CC:  MOVLW  B5
054CE:  MOVWF  x32
054D0:  MOVLB  0
054D2:  CALL   0874
054D6:  MOVFF  01,6F0
054DA:  MOVLW  01
054DC:  MOVLB  6
054DE:  ADDWF  01,W
054E0:  MOVWF  01
054E2:  MOVLW  00
054E4:  ADDWFC 02,W
054E6:  MOVWF  03
054E8:  MOVF   01,W
054EA:  ADDLW  E9
054EC:  MOVWF  FE9
054EE:  MOVLW  01
054F0:  ADDWFC 03,W
054F2:  MOVWF  FEA
054F4:  MOVLW  01
054F6:  ADDWF  FEF,W
054F8:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054FA:  MOVLB  7
054FC:  CLRF   x31
054FE:  MOVFF  4BE,730
05502:  CLRF   x33
05504:  MOVLW  B5
05506:  MOVWF  x32
05508:  MOVLB  0
0550A:  CALL   0874
0550E:  MOVFF  02,6F1
05512:  MOVFF  01,6F0
05516:  MOVLW  06
05518:  MOVLB  6
0551A:  ADDWF  xF0,F
0551C:  MOVLW  00
0551E:  ADDWFC xF1,F
05520:  MOVLB  7
05522:  CLRF   x31
05524:  MOVFF  4BE,730
05528:  CLRF   x33
0552A:  MOVLW  B5
0552C:  MOVWF  x32
0552E:  MOVLB  0
05530:  CALL   0874
05534:  MOVFF  02,6F3
05538:  MOVFF  01,6F2
0553C:  MOVLW  02
0553E:  ADDWF  01,W
05540:  MOVWF  01
05542:  MOVLW  00
05544:  ADDWFC 02,W
05546:  MOVWF  03
05548:  MOVF   01,W
0554A:  ADDLW  E9
0554C:  MOVWF  FE9
0554E:  MOVLW  01
05550:  ADDWFC 03,W
05552:  MOVWF  FEA
05554:  MOVLB  7
05556:  CLRF   x31
05558:  MOVFF  FEF,730
0555C:  CLRF   x33
0555E:  MOVLW  19
05560:  MOVWF  x32
05562:  MOVLB  0
05564:  CALL   0874
05568:  MOVFF  02,03
0556C:  MOVF   01,W
0556E:  MOVLB  6
05570:  ADDWF  xF0,F
05572:  MOVF   02,W
05574:  ADDWFC xF1,F
05576:  MOVLB  7
05578:  CLRF   x31
0557A:  MOVFF  4BE,730
0557E:  CLRF   x33
05580:  MOVLW  B5
05582:  MOVWF  x32
05584:  MOVLB  0
05586:  CALL   0874
0558A:  MOVFF  01,6F2
0558E:  MOVLW  01
05590:  MOVLB  6
05592:  ADDWF  01,W
05594:  MOVWF  01
05596:  MOVLW  00
05598:  ADDWFC 02,W
0559A:  MOVWF  03
0559C:  MOVF   01,W
0559E:  ADDLW  E9
055A0:  MOVWF  FE9
055A2:  MOVLW  01
055A4:  ADDWFC 03,W
055A6:  MOVWF  FEA
055A8:  MOVF   FEF,W
055AA:  ADDWF  xF0,W
055AC:  MOVWF  01
055AE:  MOVLW  00
055B0:  ADDWFC xF1,W
055B2:  MOVWF  03
055B4:  MOVF   01,W
055B6:  ADDLW  E9
055B8:  MOVWF  FE9
055BA:  MOVLW  01
055BC:  ADDWFC 03,W
055BE:  MOVWF  FEA
055C0:  CLRF   FEF
....................          }
055C2:  BRA    55DA
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
055C4:  MOVFF  4BE,6F0
055C8:  MOVLB  0
055CA:  CALL   0B56
....................             fprintf(SERIAL, retData);
055CE:  MOVLW  04
055D0:  MOVWF  FEA
055D2:  MOVLW  BF
055D4:  MOVWF  FE9
055D6:  RCALL  50A4
055D8:  MOVLB  6
....................          }
....................       }
055DA:  MOVLB  0
055DC:  BRA    50CE
055DE:  MOVLB  1
....................    }          
055E0:  MOVLB  0
055E2:  GOTO   A7A4 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00CE0:  MOVLB  6
00CE2:  CLRF   xEF
00CE4:  MOVF   xEF,W
00CE6:  SUBLW  03
00CE8:  BNC   0CF8
....................    {
....................       resetSERcmd(i);
00CEA:  MOVFF  6EF,6F0
00CEE:  MOVLB  0
00CF0:  RCALL  0B56
00CF2:  MOVLB  6
00CF4:  INCF   xEF,F
00CF6:  BRA    0CE4
....................    }
....................    enable_interrupts(INT_RDA);
00CF8:  MOVLB  E
00CFA:  BSF    xC0.5
00CFC:  MOVLB  0
00CFE:  GOTO   A768 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D02:  MOVLB  E
00D04:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D06:  MOVLW  01
00D08:  MOVWF  FD1
00D0A:  MOVLW  07
00D0C:  MOVWF  FCE
00D0E:  CLRF   FCF
00D10:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D12:  MOVLB  1
00D14:  CLRF   x73
00D16:  CLRF   x72
00D18:  CLRF   x71
00D1A:  CLRF   x70
....................    timeoutReg1 = 0;
00D1C:  CLRF   x77
00D1E:  CLRF   x76
00D20:  CLRF   x75
00D22:  CLRF   x74
....................    timeoutReg2 = 0;
00D24:  CLRF   x7B
00D26:  CLRF   x7A
00D28:  CLRF   x79
00D2A:  CLRF   x78
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D2C:  MOVLB  E
00D2E:  BSF    xC1.0
00D30:  MOVLB  0
00D32:  GOTO   A76C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x73,F
0026C:  BNZ   027C
0026E:  MOVF   x72,F
00270:  BNZ   027C
00272:  MOVF   x71,F
00274:  BNZ   027C
00276:  MOVF   x70,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x70,F
00280:  MOVLW  00
00282:  SUBWFB x71,F
00284:  SUBWFB x72,F
00286:  SUBWFB x73,F
00288:  BRA    0292
0028A:  CLRF   x73
0028C:  CLRF   x72
0028E:  CLRF   x71
00290:  CLRF   x70
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x77,F
00294:  BNZ   02A4
00296:  MOVF   x76,F
00298:  BNZ   02A4
0029A:  MOVF   x75,F
0029C:  BNZ   02A4
0029E:  MOVF   x74,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x74,F
002A8:  MOVLW  00
002AA:  SUBWFB x75,F
002AC:  SUBWFB x76,F
002AE:  SUBWFB x77,F
002B0:  BRA    02BA
002B2:  CLRF   x77
002B4:  CLRF   x76
002B6:  CLRF   x75
002B8:  CLRF   x74
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x7B,F
002BC:  BNZ   02CC
002BE:  MOVF   x7A,F
002C0:  BNZ   02CC
002C2:  MOVF   x79,F
002C4:  BNZ   02CC
002C6:  MOVF   x78,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x78,F
002D0:  MOVLW  00
002D2:  SUBWFB x79,F
002D4:  SUBWFB x7A,F
002D6:  SUBWFB x7B,F
002D8:  BRA    02E2
002DA:  CLRF   x7B
002DC:  CLRF   x7A
002DE:  CLRF   x79
002E0:  CLRF   x78
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x7C,F
002E4:  BNZ   02EA
002E6:  MOVF   x7D,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x64,F
002F0:  MOVLW  00
002F2:  ADDWFC x65,F
002F4:  ADDWFC x66,F
002F6:  ADDWFC x67,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x67,F
002FA:  BNZ   0316
002FC:  MOVF   x66,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x7D,W
00304:  MOVLB  5
00306:  SUBWF  x65,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x7C,W
00310:  MOVLB  5
00312:  SUBWF  x64,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x67
0031E:  CLRF   x66
00320:  CLRF   x65
00322:  CLRF   x64
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................   //  P     I     D
....................   //0.01    0.3   0.1
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}, 
....................    {0.01,   0.3,  0.1, 0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    float pMax;             // Max setpoint in microns
....................    float pMin;             // Min setpoint in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);           // sFiltOn
.................... int8 setFilterOff(unsigned int8);          // sFiltOff
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"sFiltOn",  &setFilterOn},
....................    {"sFiltOff", &setFilterOff},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
05BF4:  MOVLW  04
05BF6:  MOVLB  7
05BF8:  MOVWF  x31
05BFA:  MOVLW  BF
05BFC:  MOVWF  x30
05BFE:  MOVLB  0
05C00:  RCALL  55E6
05C02:  MOVFF  02,03
05C06:  MOVF   01,W
05C08:  ADDLW  BF
05C0A:  MOVLB  6
05C0C:  MOVWF  xFA
05C0E:  MOVLW  04
05C10:  ADDWFC 02,W
05C12:  MOVWF  xFB
05C14:  MOVFF  FE8,563
05C18:  MOVFF  6FA,562
05C1C:  MOVLW  30
05C1E:  MOVWF  FF6
05C20:  MOVLW  03
05C22:  MOVWF  FF7
05C24:  MOVLB  0
05C26:  RCALL  5BD4
05C28:  MOVLW  2C
05C2A:  MOVLB  7
05C2C:  MOVWF  x3F
05C2E:  MOVLB  0
05C30:  RCALL  561E
....................    return SUCCESS;
05C32:  MOVLW  00
05C34:  MOVWF  01
05C36:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05C38:  MOVLW  04
05C3A:  MOVLB  7
05C3C:  MOVWF  x31
05C3E:  MOVLW  BF
05C40:  MOVWF  x30
05C42:  MOVLB  0
05C44:  RCALL  55E6
05C46:  MOVFF  02,03
05C4A:  MOVF   01,W
05C4C:  ADDLW  BF
05C4E:  MOVLB  6
05C50:  MOVWF  xFA
05C52:  MOVLW  04
05C54:  ADDWFC 02,W
05C56:  MOVWF  xFB
05C58:  MOVFF  FE8,563
05C5C:  MOVFF  6FA,562
05C60:  MOVLW  3A
05C62:  MOVWF  FF6
05C64:  MOVLW  03
05C66:  MOVWF  FF7
05C68:  MOVLB  0
05C6A:  RCALL  5BD4
05C6C:  MOVLW  2C
05C6E:  MOVLB  7
05C70:  MOVWF  x3F
05C72:  MOVLB  0
05C74:  RCALL  561E
....................    return SUCCESS;
05C76:  MOVLW  00
05C78:  MOVWF  01
05C7A:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06188:  MOVLB  7
0618A:  CLRF   x31
0618C:  MOVFF  684,730
06190:  CLRF   x33
06192:  MOVLW  B5
06194:  MOVWF  x32
06196:  MOVLB  0
06198:  CALL   0874
0619C:  MOVFF  02,6FC
061A0:  MOVFF  01,6FB
061A4:  MOVLW  06
061A6:  MOVLB  6
061A8:  ADDWF  xFB,F
061AA:  MOVLW  00
061AC:  ADDWFC xFC,F
061AE:  MOVLW  32
061B0:  ADDWF  xFB,W
061B2:  MOVWF  01
061B4:  MOVLW  00
061B6:  ADDWFC xFC,W
061B8:  MOVWF  03
061BA:  MOVF   01,W
061BC:  ADDLW  E9
061BE:  MOVWF  01
061C0:  MOVLW  01
061C2:  ADDWFC 03,F
061C4:  MOVFF  01,6FB
061C8:  MOVFF  03,6FC
061CC:  MOVFF  03,729
061D0:  MOVFF  01,728
061D4:  MOVLB  0
061D6:  RCALL  5C7C
061D8:  MOVF   01,F
061DA:  BNZ   61E4
061DC:  MOVLW  02
061DE:  MOVWF  01
061E0:  BRA    6338
061E2:  BRA    6242
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
061E4:  MOVLB  7
061E6:  CLRF   x31
061E8:  MOVFF  684,730
061EC:  CLRF   x33
061EE:  MOVLW  B5
061F0:  MOVWF  x32
061F2:  MOVLB  0
061F4:  CALL   0874
061F8:  MOVFF  02,6FC
061FC:  MOVFF  01,6FB
06200:  MOVLW  06
06202:  MOVLB  6
06204:  ADDWF  xFB,F
06206:  MOVLW  00
06208:  ADDWFC xFC,F
0620A:  MOVLW  32
0620C:  ADDWF  xFB,W
0620E:  MOVWF  01
06210:  MOVLW  00
06212:  ADDWFC xFC,W
06214:  MOVWF  03
06216:  MOVF   01,W
06218:  ADDLW  E9
0621A:  MOVWF  01
0621C:  MOVLW  01
0621E:  ADDWFC 03,F
06220:  MOVFF  01,6FB
06224:  MOVFF  03,6FC
06228:  MOVFF  03,729
0622C:  MOVFF  01,728
06230:  MOVLB  7
06232:  CLRF   x2B
06234:  CLRF   x2A
06236:  MOVLW  0A
06238:  MOVWF  x2C
0623A:  MOVLB  0
0623C:  RCALL  5D6C
0623E:  MOVFF  01,6FA
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
06242:  MOVLW  01
06244:  MOVLB  6
06246:  SUBWF  xFA,W
06248:  MOVWF  xFC
0624A:  CLRF   xFE
0624C:  MOVLW  60
0624E:  MOVWF  xFD
06250:  MOVLB  0
06252:  CALL   465A
06256:  BTFSC  01.0
06258:  BRA    62B8
0625A:  MOVLW  04
0625C:  MOVLB  7
0625E:  MOVWF  x31
06260:  MOVLW  BF
06262:  MOVWF  x30
06264:  MOVLB  0
06266:  CALL   55E6
0626A:  MOVFF  02,03
0626E:  MOVF   01,W
06270:  ADDLW  BF
06272:  MOVLB  6
06274:  MOVWF  xFB
06276:  MOVLW  04
06278:  ADDWFC 02,W
0627A:  MOVWF  xFC
0627C:  MOVFF  FE8,563
06280:  MOVFF  6FB,562
06284:  MOVFF  6FA,729
06288:  MOVLW  18
0628A:  MOVLB  7
0628C:  MOVWF  x2A
0628E:  MOVLB  0
06290:  RCALL  60C0
06292:  MOVLW  2C
06294:  MOVLB  7
06296:  MOVWF  x3F
06298:  MOVLB  0
0629A:  CALL   561E
0629E:  MOVLW  58
062A0:  MOVLB  7
062A2:  MOVWF  x3F
062A4:  MOVLB  0
062A6:  CALL   561E
062AA:  MOVLW  2C
062AC:  MOVLB  7
062AE:  MOVWF  x3F
062B0:  MOVLB  0
062B2:  CALL   561E
062B6:  BRA    6334
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
062B8:  MOVLW  01
062BA:  MOVLB  6
062BC:  SUBWF  xFA,W
062BE:  MOVWF  xFC
062C0:  CLRF   xFE
062C2:  MOVLW  60
062C4:  MOVWF  xFD
062C6:  MOVLB  0
062C8:  CALL   465A
062CC:  BTFSS  01.0
062CE:  BRA    632E
062D0:  MOVLW  04
062D2:  MOVLB  7
062D4:  MOVWF  x31
062D6:  MOVLW  BF
062D8:  MOVWF  x30
062DA:  MOVLB  0
062DC:  CALL   55E6
062E0:  MOVFF  02,03
062E4:  MOVF   01,W
062E6:  ADDLW  BF
062E8:  MOVLB  6
062EA:  MOVWF  xFB
062EC:  MOVLW  04
062EE:  ADDWFC 02,W
062F0:  MOVWF  xFC
062F2:  MOVFF  FE8,563
062F6:  MOVFF  6FB,562
062FA:  MOVFF  6FA,729
062FE:  MOVLW  18
06300:  MOVLB  7
06302:  MOVWF  x2A
06304:  MOVLB  0
06306:  RCALL  60C0
06308:  MOVLW  2C
0630A:  MOVLB  7
0630C:  MOVWF  x3F
0630E:  MOVLB  0
06310:  CALL   561E
06314:  MOVLW  59
06316:  MOVLB  7
06318:  MOVWF  x3F
0631A:  MOVLB  0
0631C:  CALL   561E
06320:  MOVLW  2C
06322:  MOVLB  7
06324:  MOVWF  x3F
06326:  MOVLB  0
06328:  CALL   561E
0632C:  BRA    6334
....................    else return INV_PARAM;
0632E:  MOVLW  02
06330:  MOVWF  01
06332:  BRA    6338
....................    
....................    return SUCCESS;
06334:  MOVLW  00
06336:  MOVWF  01
06338:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0637C:  MOVLB  7
0637E:  CLRF   x31
06380:  MOVFF  684,730
06384:  CLRF   x33
06386:  MOVLW  B5
06388:  MOVWF  x32
0638A:  MOVLB  0
0638C:  CALL   0874
06390:  MOVFF  02,6FD
06394:  MOVFF  01,6FC
06398:  MOVLW  06
0639A:  MOVLB  6
0639C:  ADDWF  xFC,F
0639E:  MOVLW  00
063A0:  ADDWFC xFD,F
063A2:  MOVLW  32
063A4:  ADDWF  xFC,W
063A6:  MOVWF  01
063A8:  MOVLW  00
063AA:  ADDWFC xFD,W
063AC:  MOVWF  03
063AE:  MOVF   01,W
063B0:  ADDLW  E9
063B2:  MOVWF  01
063B4:  MOVLW  01
063B6:  ADDWFC 03,F
063B8:  MOVFF  01,6FC
063BC:  MOVFF  03,6FD
063C0:  MOVFF  03,729
063C4:  MOVFF  01,728
063C8:  MOVLB  0
063CA:  RCALL  5C7C
063CC:  MOVF   01,F
063CE:  BNZ   63D8
063D0:  MOVLW  02
063D2:  MOVWF  01
063D4:  BRA    6532
063D6:  BRA    6436
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
063D8:  MOVLB  7
063DA:  CLRF   x31
063DC:  MOVFF  684,730
063E0:  CLRF   x33
063E2:  MOVLW  B5
063E4:  MOVWF  x32
063E6:  MOVLB  0
063E8:  CALL   0874
063EC:  MOVFF  02,6FD
063F0:  MOVFF  01,6FC
063F4:  MOVLW  06
063F6:  MOVLB  6
063F8:  ADDWF  xFC,F
063FA:  MOVLW  00
063FC:  ADDWFC xFD,F
063FE:  MOVLW  32
06400:  ADDWF  xFC,W
06402:  MOVWF  01
06404:  MOVLW  00
06406:  ADDWFC xFD,W
06408:  MOVWF  03
0640A:  MOVF   01,W
0640C:  ADDLW  E9
0640E:  MOVWF  01
06410:  MOVLW  01
06412:  ADDWFC 03,F
06414:  MOVFF  01,6FC
06418:  MOVFF  03,6FD
0641C:  MOVFF  03,729
06420:  MOVFF  01,728
06424:  MOVLB  7
06426:  CLRF   x2B
06428:  CLRF   x2A
0642A:  MOVLW  0A
0642C:  MOVWF  x2C
0642E:  MOVLB  0
06430:  RCALL  5D6C
06432:  MOVFF  01,6FA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06436:  MOVLB  7
06438:  CLRF   x31
0643A:  MOVFF  684,730
0643E:  CLRF   x33
06440:  MOVLW  B5
06442:  MOVWF  x32
06444:  MOVLB  0
06446:  CALL   0874
0644A:  MOVFF  02,6FD
0644E:  MOVFF  01,6FC
06452:  MOVLW  06
06454:  MOVLB  6
06456:  ADDWF  xFC,F
06458:  MOVLW  00
0645A:  ADDWFC xFD,F
0645C:  MOVLW  4B
0645E:  ADDWF  xFC,W
06460:  MOVWF  01
06462:  MOVLW  00
06464:  ADDWFC xFD,W
06466:  MOVWF  03
06468:  MOVF   01,W
0646A:  ADDLW  E9
0646C:  MOVWF  01
0646E:  MOVLW  01
06470:  ADDWFC 03,F
06472:  MOVFF  01,6FC
06476:  MOVFF  03,6FD
0647A:  MOVFF  03,731
0647E:  MOVFF  01,730
06482:  MOVLB  0
06484:  CALL   55E6
06488:  MOVFF  02,03
0648C:  MOVF   01,W
0648E:  SUBLW  01
06490:  BNZ   6496
06492:  MOVF   03,F
06494:  BZ    649E
06496:  MOVLW  02
06498:  MOVWF  01
0649A:  BRA    6532
0649C:  BRA    64DE
....................    else arg2 = SERcmd[rec].p[3][0];
0649E:  MOVLB  7
064A0:  CLRF   x31
064A2:  MOVFF  684,730
064A6:  CLRF   x33
064A8:  MOVLW  B5
064AA:  MOVWF  x32
064AC:  MOVLB  0
064AE:  CALL   0874
064B2:  MOVFF  02,6FD
064B6:  MOVFF  01,6FC
064BA:  MOVLW  06
064BC:  MOVLB  6
064BE:  ADDWF  xFC,F
064C0:  MOVLW  00
064C2:  ADDWFC xFD,F
064C4:  MOVLW  4B
064C6:  ADDWF  xFC,F
064C8:  MOVLW  00
064CA:  ADDWFC xFD,F
064CC:  MOVLW  E9
064CE:  ADDWF  xFC,W
064D0:  MOVWF  FE9
064D2:  MOVLW  01
064D4:  ADDWFC xFD,W
064D6:  MOVWF  FEA
064D8:  MOVFF  FEF,6FB
064DC:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
064DE:  MOVLB  6
064E0:  MOVF   xFB,W
064E2:  SUBLW  58
064E4:  BNZ   6502
064E6:  MOVLW  01
064E8:  SUBWF  xFA,W
064EA:  MOVWF  xFC
064EC:  MOVFF  FE8,711
064F0:  MOVLB  7
064F2:  CLRF   x12
064F4:  CLRF   x14
064F6:  MOVLW  60
064F8:  MOVWF  x13
064FA:  MOVLB  0
064FC:  RCALL  633A
064FE:  BRA    652E
06500:  MOVLB  6
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06502:  MOVF   xFB,W
06504:  SUBLW  59
06506:  BNZ   6526
06508:  MOVLW  01
0650A:  SUBWF  xFA,W
0650C:  MOVWF  xFC
0650E:  MOVFF  FE8,711
06512:  MOVLW  01
06514:  MOVLB  7
06516:  MOVWF  x12
06518:  CLRF   x14
0651A:  MOVLW  60
0651C:  MOVWF  x13
0651E:  MOVLB  0
06520:  RCALL  633A
06522:  BRA    652E
06524:  MOVLB  6
....................    else return INV_PARAM;
06526:  MOVLW  02
06528:  MOVWF  01
0652A:  MOVLB  0
0652C:  BRA    6532
....................    
....................    return SUCCESS;
0652E:  MOVLW  00
06530:  MOVWF  01
06532:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06534:  MOVLB  7
06536:  CLRF   x31
06538:  MOVFF  684,730
0653C:  CLRF   x33
0653E:  MOVLW  B5
06540:  MOVWF  x32
06542:  MOVLB  0
06544:  CALL   0874
06548:  MOVFF  02,6FC
0654C:  MOVFF  01,6FB
06550:  MOVLW  06
06552:  MOVLB  6
06554:  ADDWF  xFB,F
06556:  MOVLW  00
06558:  ADDWFC xFC,F
0655A:  MOVLW  32
0655C:  ADDWF  xFB,W
0655E:  MOVWF  01
06560:  MOVLW  00
06562:  ADDWFC xFC,W
06564:  MOVWF  03
06566:  MOVF   01,W
06568:  ADDLW  E9
0656A:  MOVWF  01
0656C:  MOVLW  01
0656E:  ADDWFC 03,F
06570:  MOVFF  01,6FB
06574:  MOVFF  03,6FC
06578:  MOVFF  03,729
0657C:  MOVFF  01,728
06580:  MOVLB  0
06582:  CALL   5C7C
06586:  MOVF   01,F
06588:  BNZ   6592
0658A:  MOVLW  02
0658C:  MOVWF  01
0658E:  BRA    66C8
06590:  BRA    65F2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06592:  MOVLB  7
06594:  CLRF   x31
06596:  MOVFF  684,730
0659A:  CLRF   x33
0659C:  MOVLW  B5
0659E:  MOVWF  x32
065A0:  MOVLB  0
065A2:  CALL   0874
065A6:  MOVFF  02,6FC
065AA:  MOVFF  01,6FB
065AE:  MOVLW  06
065B0:  MOVLB  6
065B2:  ADDWF  xFB,F
065B4:  MOVLW  00
065B6:  ADDWFC xFC,F
065B8:  MOVLW  32
065BA:  ADDWF  xFB,W
065BC:  MOVWF  01
065BE:  MOVLW  00
065C0:  ADDWFC xFC,W
065C2:  MOVWF  03
065C4:  MOVF   01,W
065C6:  ADDLW  E9
065C8:  MOVWF  01
065CA:  MOVLW  01
065CC:  ADDWFC 03,F
065CE:  MOVFF  01,6FB
065D2:  MOVFF  03,6FC
065D6:  MOVFF  03,729
065DA:  MOVFF  01,728
065DE:  MOVLB  7
065E0:  CLRF   x2B
065E2:  CLRF   x2A
065E4:  MOVLW  0A
065E6:  MOVWF  x2C
065E8:  MOVLB  0
065EA:  CALL   5D6C
065EE:  MOVFF  01,6FA
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
065F2:  MOVLW  01
065F4:  MOVLB  6
065F6:  SUBWF  xFA,W
065F8:  MOVWF  xFC
065FA:  CLRF   xFE
065FC:  MOVLW  61
065FE:  MOVWF  xFD
06600:  MOVLB  0
06602:  CALL   465A
06606:  BTFSC  01.0
06608:  BRA    6658
0660A:  MOVLW  04
0660C:  MOVLB  7
0660E:  MOVWF  x31
06610:  MOVLW  BF
06612:  MOVWF  x30
06614:  MOVLB  0
06616:  CALL   55E6
0661A:  MOVFF  02,03
0661E:  MOVF   01,W
06620:  ADDLW  BF
06622:  MOVLB  6
06624:  MOVWF  xFB
06626:  MOVLW  04
06628:  ADDWFC 02,W
0662A:  MOVWF  xFC
0662C:  MOVFF  FE8,563
06630:  MOVFF  6FB,562
06634:  MOVFF  6FA,729
06638:  MOVLW  18
0663A:  MOVLB  7
0663C:  MOVWF  x2A
0663E:  MOVLB  0
06640:  RCALL  60C0
06642:  MOVLW  42
06644:  MOVWF  FF6
06646:  MOVLW  03
06648:  MOVWF  FF7
0664A:  MOVLW  08
0664C:  MOVLB  6
0664E:  MOVWF  xFE
06650:  MOVLB  0
06652:  CALL   563E
06656:  BRA    66C4
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06658:  MOVLW  01
0665A:  MOVLB  6
0665C:  SUBWF  xFA,W
0665E:  MOVWF  xFC
06660:  CLRF   xFE
06662:  MOVLW  61
06664:  MOVWF  xFD
06666:  MOVLB  0
06668:  CALL   465A
0666C:  BTFSS  01.0
0666E:  BRA    66BE
06670:  MOVLW  04
06672:  MOVLB  7
06674:  MOVWF  x31
06676:  MOVLW  BF
06678:  MOVWF  x30
0667A:  MOVLB  0
0667C:  CALL   55E6
06680:  MOVFF  02,03
06684:  MOVF   01,W
06686:  ADDLW  BF
06688:  MOVLB  6
0668A:  MOVWF  xFB
0668C:  MOVLW  04
0668E:  ADDWFC 02,W
06690:  MOVWF  xFC
06692:  MOVFF  FE8,563
06696:  MOVFF  6FB,562
0669A:  MOVFF  6FA,729
0669E:  MOVLW  18
066A0:  MOVLB  7
066A2:  MOVWF  x2A
066A4:  MOVLB  0
066A6:  RCALL  60C0
066A8:  MOVLW  4E
066AA:  MOVWF  FF6
066AC:  MOVLW  03
066AE:  MOVWF  FF7
066B0:  MOVLW  08
066B2:  MOVLB  6
066B4:  MOVWF  xFE
066B6:  MOVLB  0
066B8:  CALL   563E
066BC:  BRA    66C4
....................    else return INV_PARAM;
066BE:  MOVLW  02
066C0:  MOVWF  01
066C2:  BRA    66C8
....................    
....................    return SUCCESS;
066C4:  MOVLW  00
066C6:  MOVWF  01
066C8:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
066CA:  MOVLW  4D
066CC:  MOVLB  6
066CE:  MOVWF  xFF
066D0:  MOVLW  41
066D2:  MOVLB  7
066D4:  MOVWF  x00
066D6:  MOVLW  4E
066D8:  MOVWF  x01
066DA:  MOVLW  55
066DC:  MOVWF  x02
066DE:  MOVLW  41
066E0:  MOVWF  x03
066E2:  MOVLW  4C
066E4:  MOVWF  x04
066E6:  CLRF   x05
066E8:  MOVLW  06
066EA:  MOVLB  6
066EC:  MOVWF  xFE
066EE:  SETF   xFD
....................    char *s_magsns = "MAGSNS";
066F0:  MOVLW  4D
066F2:  MOVLB  7
066F4:  MOVWF  x08
066F6:  MOVLW  41
066F8:  MOVWF  x09
066FA:  MOVLW  47
066FC:  MOVWF  x0A
066FE:  MOVLW  53
06700:  MOVWF  x0B
06702:  MOVLW  4E
06704:  MOVWF  x0C
06706:  MOVLW  53
06708:  MOVWF  x0D
0670A:  CLRF   x0E
0670C:  MOVLW  07
0670E:  MOVWF  x07
06710:  MOVLW  08
06712:  MOVWF  x06
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06714:  CLRF   x31
06716:  MOVFF  684,730
0671A:  CLRF   x33
0671C:  MOVLW  B5
0671E:  MOVWF  x32
06720:  MOVLB  0
06722:  CALL   0874
06726:  MOVFF  02,710
0672A:  MOVFF  01,70F
0672E:  MOVLW  06
06730:  MOVLB  7
06732:  ADDWF  x0F,F
06734:  MOVLW  00
06736:  ADDWFC x10,F
06738:  MOVLW  32
0673A:  ADDWF  x0F,W
0673C:  MOVWF  01
0673E:  MOVLW  00
06740:  ADDWFC x10,W
06742:  MOVWF  03
06744:  MOVF   01,W
06746:  ADDLW  E9
06748:  MOVWF  01
0674A:  MOVLW  01
0674C:  ADDWFC 03,F
0674E:  MOVFF  01,70F
06752:  MOVFF  03,710
06756:  MOVFF  03,729
0675A:  MOVFF  01,728
0675E:  MOVLB  0
06760:  CALL   5C7C
06764:  MOVF   01,F
06766:  BNZ   6770
06768:  MOVLW  02
0676A:  MOVWF  01
0676C:  BRA    68EA
0676E:  BRA    67CE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06770:  MOVLB  7
06772:  CLRF   x31
06774:  MOVFF  684,730
06778:  CLRF   x33
0677A:  MOVLW  B5
0677C:  MOVWF  x32
0677E:  MOVLB  0
06780:  CALL   0874
06784:  MOVFF  02,710
06788:  MOVFF  01,70F
0678C:  MOVLW  06
0678E:  MOVLB  7
06790:  ADDWF  x0F,F
06792:  MOVLW  00
06794:  ADDWFC x10,F
06796:  MOVLW  32
06798:  ADDWF  x0F,W
0679A:  MOVWF  01
0679C:  MOVLW  00
0679E:  ADDWFC x10,W
067A0:  MOVWF  03
067A2:  MOVF   01,W
067A4:  ADDLW  E9
067A6:  MOVWF  01
067A8:  MOVLW  01
067AA:  ADDWFC 03,F
067AC:  MOVFF  01,70F
067B0:  MOVFF  03,710
067B4:  MOVFF  03,729
067B8:  MOVFF  01,728
067BC:  CLRF   x2B
067BE:  CLRF   x2A
067C0:  MOVLW  0A
067C2:  MOVWF  x2C
067C4:  MOVLB  0
067C6:  CALL   5D6C
067CA:  MOVFF  01,6FA
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
067CE:  MOVLB  7
067D0:  CLRF   x31
067D2:  MOVFF  684,730
067D6:  CLRF   x33
067D8:  MOVLW  B5
067DA:  MOVWF  x32
067DC:  MOVLB  0
067DE:  CALL   0874
067E2:  MOVFF  02,710
067E6:  MOVFF  01,70F
067EA:  MOVLW  06
067EC:  MOVLB  7
067EE:  ADDWF  x0F,F
067F0:  MOVLW  00
067F2:  ADDWFC x10,F
067F4:  MOVLW  4B
067F6:  ADDWF  x0F,W
067F8:  MOVWF  01
067FA:  MOVLW  00
067FC:  ADDWFC x10,W
067FE:  MOVWF  03
06800:  MOVF   01,W
06802:  ADDLW  E9
06804:  MOVWF  01
06806:  MOVLW  01
06808:  ADDWFC 03,F
0680A:  MOVFF  01,70F
0680E:  MOVFF  03,710
06812:  MOVFF  03,731
06816:  MOVFF  01,730
0681A:  MOVLB  0
0681C:  CALL   55E6
06820:  MOVFF  02,03
06824:  MOVF   01,W
06826:  BNZ   6834
06828:  MOVF   03,F
0682A:  BNZ   6834
0682C:  MOVLW  02
0682E:  MOVWF  01
06830:  BRA    68EA
06832:  BRA    687A
....................    else arg2 = SERcmd[rec].p[3];
06834:  MOVLB  7
06836:  CLRF   x31
06838:  MOVFF  684,730
0683C:  CLRF   x33
0683E:  MOVLW  B5
06840:  MOVWF  x32
06842:  MOVLB  0
06844:  CALL   0874
06848:  MOVFF  02,710
0684C:  MOVFF  01,70F
06850:  MOVLW  06
06852:  MOVLB  7
06854:  ADDWF  x0F,F
06856:  MOVLW  00
06858:  ADDWFC x10,F
0685A:  MOVLW  4B
0685C:  ADDWF  x0F,W
0685E:  MOVWF  01
06860:  MOVLW  00
06862:  ADDWFC x10,W
06864:  MOVWF  03
06866:  MOVF   01,W
06868:  ADDLW  E9
0686A:  MOVWF  01
0686C:  MOVLW  01
0686E:  ADDWFC 03,F
06870:  MOVFF  01,6FB
06874:  MOVFF  03,6FC
06878:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
0687A:  MOVFF  6FE,731
0687E:  MOVFF  6FD,730
06882:  MOVFF  6FC,733
06886:  MOVFF  6FB,732
0688A:  CALL   5B5C
0688E:  MOVF   01,F
06890:  BNZ   68AC
06892:  MOVLW  01
06894:  MOVLB  6
06896:  SUBWF  xFA,W
06898:  MOVLB  7
0689A:  MOVWF  x0F
0689C:  MOVWF  x11
0689E:  CLRF   x12
068A0:  CLRF   x14
068A2:  MOVLW  61
068A4:  MOVWF  x13
068A6:  MOVLB  0
068A8:  RCALL  633A
068AA:  BRA    68E6
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
068AC:  MOVFF  707,731
068B0:  MOVFF  706,730
068B4:  MOVFF  6FC,733
068B8:  MOVFF  6FB,732
068BC:  CALL   5B5C
068C0:  MOVF   01,F
068C2:  BNZ   68E0
068C4:  MOVLW  01
068C6:  MOVLB  6
068C8:  SUBWF  xFA,W
068CA:  MOVLB  7
068CC:  MOVWF  x0F
068CE:  MOVWF  x11
068D0:  MOVLW  01
068D2:  MOVWF  x12
068D4:  CLRF   x14
068D6:  MOVLW  61
068D8:  MOVWF  x13
068DA:  MOVLB  0
068DC:  RCALL  633A
068DE:  BRA    68E6
....................    else return INV_PARAM;
068E0:  MOVLW  02
068E2:  MOVWF  01
068E4:  BRA    68EA
....................    
....................    return SUCCESS;
068E6:  MOVLW  00
068E8:  MOVWF  01
068EA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
068EC:  MOVLB  7
068EE:  CLRF   x31
068F0:  MOVFF  684,730
068F4:  CLRF   x33
068F6:  MOVLW  B5
068F8:  MOVWF  x32
068FA:  MOVLB  0
068FC:  CALL   0874
06900:  MOVFF  02,701
06904:  MOVFF  01,700
06908:  MOVLW  06
0690A:  MOVLB  7
0690C:  ADDWF  x00,F
0690E:  MOVLW  00
06910:  ADDWFC x01,F
06912:  MOVLW  32
06914:  ADDWF  x00,W
06916:  MOVWF  01
06918:  MOVLW  00
0691A:  ADDWFC x01,W
0691C:  MOVWF  03
0691E:  MOVF   01,W
06920:  ADDLW  E9
06922:  MOVWF  01
06924:  MOVLW  01
06926:  ADDWFC 03,F
06928:  MOVFF  01,700
0692C:  MOVFF  03,701
06930:  MOVFF  03,729
06934:  MOVFF  01,728
06938:  MOVLB  0
0693A:  CALL   5C7C
0693E:  MOVF   01,F
06940:  BNZ   694A
06942:  MOVLW  02
06944:  MOVWF  01
06946:  BRA    6DCC
06948:  BRA    69A8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0694A:  MOVLB  7
0694C:  CLRF   x31
0694E:  MOVFF  684,730
06952:  CLRF   x33
06954:  MOVLW  B5
06956:  MOVWF  x32
06958:  MOVLB  0
0695A:  CALL   0874
0695E:  MOVFF  02,701
06962:  MOVFF  01,700
06966:  MOVLW  06
06968:  MOVLB  7
0696A:  ADDWF  x00,F
0696C:  MOVLW  00
0696E:  ADDWFC x01,F
06970:  MOVLW  32
06972:  ADDWF  x00,W
06974:  MOVWF  01
06976:  MOVLW  00
06978:  ADDWFC x01,W
0697A:  MOVWF  03
0697C:  MOVF   01,W
0697E:  ADDLW  E9
06980:  MOVWF  01
06982:  MOVLW  01
06984:  ADDWFC 03,F
06986:  MOVFF  01,700
0698A:  MOVFF  03,701
0698E:  MOVFF  03,729
06992:  MOVFF  01,728
06996:  CLRF   x2B
06998:  CLRF   x2A
0699A:  MOVLW  0A
0699C:  MOVWF  x2C
0699E:  MOVLB  0
069A0:  CALL   5D6C
069A4:  MOVFF  01,6FA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
069A8:  MOVLB  7
069AA:  CLRF   x31
069AC:  MOVFF  684,730
069B0:  CLRF   x33
069B2:  MOVLW  B5
069B4:  MOVWF  x32
069B6:  MOVLB  0
069B8:  CALL   0874
069BC:  MOVFF  02,701
069C0:  MOVFF  01,700
069C4:  MOVLW  06
069C6:  MOVLB  7
069C8:  ADDWF  x00,F
069CA:  MOVLW  00
069CC:  ADDWFC x01,F
069CE:  MOVLW  4B
069D0:  ADDWF  x00,W
069D2:  MOVWF  01
069D4:  MOVLW  00
069D6:  ADDWFC x01,W
069D8:  MOVWF  03
069DA:  MOVF   01,W
069DC:  ADDLW  E9
069DE:  MOVWF  01
069E0:  MOVLW  01
069E2:  ADDWFC 03,F
069E4:  MOVFF  01,700
069E8:  MOVFF  03,701
069EC:  MOVFF  03,731
069F0:  MOVFF  01,730
069F4:  MOVLB  0
069F6:  CALL   55E6
069FA:  MOVFF  02,03
069FE:  MOVF   01,W
06A00:  SUBLW  01
06A02:  BNZ   6A08
06A04:  MOVF   03,F
06A06:  BZ    6A10
06A08:  MOVLW  02
06A0A:  MOVWF  01
06A0C:  BRA    6DCC
06A0E:  BRA    6A50
....................    else arg2 = SERcmd[rec].p[3][0];
06A10:  MOVLB  7
06A12:  CLRF   x31
06A14:  MOVFF  684,730
06A18:  CLRF   x33
06A1A:  MOVLW  B5
06A1C:  MOVWF  x32
06A1E:  MOVLB  0
06A20:  CALL   0874
06A24:  MOVFF  02,701
06A28:  MOVFF  01,700
06A2C:  MOVLW  06
06A2E:  MOVLB  7
06A30:  ADDWF  x00,F
06A32:  MOVLW  00
06A34:  ADDWFC x01,F
06A36:  MOVLW  4B
06A38:  ADDWF  x00,F
06A3A:  MOVLW  00
06A3C:  ADDWFC x01,F
06A3E:  MOVLW  E9
06A40:  ADDWF  x00,W
06A42:  MOVWF  FE9
06A44:  MOVLW  01
06A46:  ADDWFC x01,W
06A48:  MOVWF  FEA
06A4A:  MOVFF  FEF,6FB
06A4E:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06A50:  MOVLB  6
06A52:  MOVF   xFB,W
06A54:  SUBLW  50
06A56:  BNZ   6AF8
06A58:  MOVLW  04
06A5A:  MOVLB  7
06A5C:  MOVWF  x31
06A5E:  MOVLW  BF
06A60:  MOVWF  x30
06A62:  MOVLB  0
06A64:  CALL   55E6
06A68:  MOVFF  02,03
06A6C:  MOVF   01,W
06A6E:  ADDLW  BF
06A70:  MOVLB  7
06A72:  MOVWF  x00
06A74:  MOVLW  04
06A76:  ADDWFC 02,W
06A78:  MOVWF  x01
06A7A:  MOVLW  01
06A7C:  MOVLB  6
06A7E:  SUBWF  xFA,W
06A80:  MULLW  20
06A82:  MOVF   FF3,W
06A84:  MOVLB  7
06A86:  CLRF   x03
06A88:  MOVWF  x02
06A8A:  MOVLW  20
06A8C:  ADDWF  x02,W
06A8E:  MOVWF  FE9
06A90:  MOVLW  00
06A92:  ADDWFC x03,W
06A94:  MOVWF  FEA
06A96:  MOVFF  FEF,704
06A9A:  MOVFF  FEC,705
06A9E:  MOVFF  FEC,706
06AA2:  MOVFF  FEC,707
06AA6:  MOVFF  701,563
06AAA:  MOVFF  700,562
06AAE:  MOVFF  6FA,729
06AB2:  MOVLW  18
06AB4:  MOVWF  x2A
06AB6:  MOVLB  0
06AB8:  CALL   60C0
06ABC:  MOVLW  2C
06ABE:  MOVLB  7
06AC0:  MOVWF  x3F
06AC2:  MOVLB  0
06AC4:  CALL   561E
06AC8:  MOVLW  89
06ACA:  MOVWF  FE9
06ACC:  MOVFF  707,735
06AD0:  MOVFF  706,734
06AD4:  MOVFF  705,733
06AD8:  MOVFF  704,732
06ADC:  MOVLW  02
06ADE:  MOVLB  7
06AE0:  MOVWF  x36
06AE2:  MOVLB  0
06AE4:  CALL   57BC
06AE8:  MOVLW  2C
06AEA:  MOVLB  7
06AEC:  MOVWF  x3F
06AEE:  MOVLB  0
06AF0:  CALL   561E
06AF4:  BRA    6DC8
06AF6:  MOVLB  6
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06AF8:  MOVF   xFB,W
06AFA:  SUBLW  49
06AFC:  BNZ   6BA6
06AFE:  MOVLW  04
06B00:  MOVLB  7
06B02:  MOVWF  x31
06B04:  MOVLW  BF
06B06:  MOVWF  x30
06B08:  MOVLB  0
06B0A:  CALL   55E6
06B0E:  MOVF   01,W
06B10:  ADDLW  BF
06B12:  MOVLB  7
06B14:  MOVWF  x00
06B16:  MOVLW  04
06B18:  ADDWFC 02,W
06B1A:  MOVWF  x01
06B1C:  MOVLW  01
06B1E:  MOVLB  6
06B20:  SUBWF  xFA,W
06B22:  MULLW  20
06B24:  MOVF   FF3,W
06B26:  MOVLB  7
06B28:  CLRF   x03
06B2A:  MOVWF  x02
06B2C:  MOVLW  04
06B2E:  ADDWF  x02,W
06B30:  MOVWF  01
06B32:  MOVLW  00
06B34:  ADDWFC x03,W
06B36:  MOVWF  03
06B38:  MOVF   01,W
06B3A:  ADDLW  20
06B3C:  MOVWF  FE9
06B3E:  MOVLW  00
06B40:  ADDWFC 03,W
06B42:  MOVWF  FEA
06B44:  MOVFF  FEF,702
06B48:  MOVFF  FEC,703
06B4C:  MOVFF  FEC,704
06B50:  MOVFF  FEC,705
06B54:  MOVFF  701,563
06B58:  MOVFF  700,562
06B5C:  MOVFF  6FA,729
06B60:  MOVLW  18
06B62:  MOVWF  x2A
06B64:  MOVLB  0
06B66:  CALL   60C0
06B6A:  MOVLW  2C
06B6C:  MOVLB  7
06B6E:  MOVWF  x3F
06B70:  MOVLB  0
06B72:  CALL   561E
06B76:  MOVLW  89
06B78:  MOVWF  FE9
06B7A:  MOVFF  705,735
06B7E:  MOVFF  704,734
06B82:  MOVFF  703,733
06B86:  MOVFF  702,732
06B8A:  MOVLW  02
06B8C:  MOVLB  7
06B8E:  MOVWF  x36
06B90:  MOVLB  0
06B92:  CALL   57BC
06B96:  MOVLW  2C
06B98:  MOVLB  7
06B9A:  MOVWF  x3F
06B9C:  MOVLB  0
06B9E:  CALL   561E
06BA2:  BRA    6DC8
06BA4:  MOVLB  6
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06BA6:  MOVF   xFB,W
06BA8:  SUBLW  44
06BAA:  BNZ   6C54
06BAC:  MOVLW  04
06BAE:  MOVLB  7
06BB0:  MOVWF  x31
06BB2:  MOVLW  BF
06BB4:  MOVWF  x30
06BB6:  MOVLB  0
06BB8:  CALL   55E6
06BBC:  MOVF   01,W
06BBE:  ADDLW  BF
06BC0:  MOVLB  7
06BC2:  MOVWF  x00
06BC4:  MOVLW  04
06BC6:  ADDWFC 02,W
06BC8:  MOVWF  x01
06BCA:  MOVLW  01
06BCC:  MOVLB  6
06BCE:  SUBWF  xFA,W
06BD0:  MULLW  20
06BD2:  MOVF   FF3,W
06BD4:  MOVLB  7
06BD6:  CLRF   x03
06BD8:  MOVWF  x02
06BDA:  MOVLW  08
06BDC:  ADDWF  x02,W
06BDE:  MOVWF  01
06BE0:  MOVLW  00
06BE2:  ADDWFC x03,W
06BE4:  MOVWF  03
06BE6:  MOVF   01,W
06BE8:  ADDLW  20
06BEA:  MOVWF  FE9
06BEC:  MOVLW  00
06BEE:  ADDWFC 03,W
06BF0:  MOVWF  FEA
06BF2:  MOVFF  FEF,702
06BF6:  MOVFF  FEC,703
06BFA:  MOVFF  FEC,704
06BFE:  MOVFF  FEC,705
06C02:  MOVFF  701,563
06C06:  MOVFF  700,562
06C0A:  MOVFF  6FA,729
06C0E:  MOVLW  18
06C10:  MOVWF  x2A
06C12:  MOVLB  0
06C14:  CALL   60C0
06C18:  MOVLW  2C
06C1A:  MOVLB  7
06C1C:  MOVWF  x3F
06C1E:  MOVLB  0
06C20:  CALL   561E
06C24:  MOVLW  89
06C26:  MOVWF  FE9
06C28:  MOVFF  705,735
06C2C:  MOVFF  704,734
06C30:  MOVFF  703,733
06C34:  MOVFF  702,732
06C38:  MOVLW  02
06C3A:  MOVLB  7
06C3C:  MOVWF  x36
06C3E:  MOVLB  0
06C40:  CALL   57BC
06C44:  MOVLW  2C
06C46:  MOVLB  7
06C48:  MOVWF  x3F
06C4A:  MOVLB  0
06C4C:  CALL   561E
06C50:  BRA    6DC8
06C52:  MOVLB  6
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06C54:  MOVF   xFB,W
06C56:  SUBLW  41
06C58:  BTFSS  FD8.2
06C5A:  BRA    6DC0
06C5C:  MOVLW  04
06C5E:  MOVLB  7
06C60:  MOVWF  x31
06C62:  MOVLW  BF
06C64:  MOVWF  x30
06C66:  MOVLB  0
06C68:  CALL   55E6
06C6C:  MOVF   01,W
06C6E:  ADDLW  BF
06C70:  MOVLB  7
06C72:  MOVWF  x00
06C74:  MOVLW  04
06C76:  ADDWFC 02,W
06C78:  MOVWF  x01
06C7A:  MOVLW  01
06C7C:  MOVLB  6
06C7E:  SUBWF  xFA,W
06C80:  MULLW  20
06C82:  MOVF   FF3,W
06C84:  MOVLB  7
06C86:  CLRF   x03
06C88:  MOVWF  x02
06C8A:  MOVLW  20
06C8C:  ADDWF  x02,W
06C8E:  MOVWF  FE9
06C90:  MOVLW  00
06C92:  ADDWFC x03,W
06C94:  MOVWF  FEA
06C96:  MOVFF  FEF,704
06C9A:  MOVFF  FEC,705
06C9E:  MOVFF  FEC,706
06CA2:  MOVFF  FEC,707
06CA6:  MOVLW  01
06CA8:  MOVLB  6
06CAA:  SUBWF  xFA,W
06CAC:  MULLW  20
06CAE:  MOVF   FF3,W
06CB0:  MOVLB  7
06CB2:  CLRF   x09
06CB4:  MOVWF  x08
06CB6:  MOVLW  04
06CB8:  ADDWF  x08,W
06CBA:  MOVWF  01
06CBC:  MOVLW  00
06CBE:  ADDWFC x09,W
06CC0:  MOVWF  03
06CC2:  MOVF   01,W
06CC4:  ADDLW  20
06CC6:  MOVWF  FE9
06CC8:  MOVLW  00
06CCA:  ADDWFC 03,W
06CCC:  MOVWF  FEA
06CCE:  MOVFF  FEF,708
06CD2:  MOVFF  FEC,709
06CD6:  MOVFF  FEC,70A
06CDA:  MOVFF  FEC,70B
06CDE:  MOVLW  01
06CE0:  MOVLB  6
06CE2:  SUBWF  xFA,W
06CE4:  MULLW  20
06CE6:  MOVF   FF3,W
06CE8:  MOVLB  7
06CEA:  CLRF   x0D
06CEC:  MOVWF  x0C
06CEE:  MOVLW  08
06CF0:  ADDWF  x0C,W
06CF2:  MOVWF  01
06CF4:  MOVLW  00
06CF6:  ADDWFC x0D,W
06CF8:  MOVWF  03
06CFA:  MOVF   01,W
06CFC:  ADDLW  20
06CFE:  MOVWF  FE9
06D00:  MOVLW  00
06D02:  ADDWFC 03,W
06D04:  MOVWF  FEA
06D06:  MOVFF  FEF,70C
06D0A:  MOVFF  FEC,70D
06D0E:  MOVFF  FEC,70E
06D12:  MOVFF  FEC,70F
06D16:  MOVFF  701,563
06D1A:  MOVFF  700,562
06D1E:  MOVFF  6FA,729
06D22:  MOVLW  18
06D24:  MOVWF  x2A
06D26:  MOVLB  0
06D28:  CALL   60C0
06D2C:  MOVLW  2C
06D2E:  MOVLB  7
06D30:  MOVWF  x3F
06D32:  MOVLB  0
06D34:  CALL   561E
06D38:  MOVLW  89
06D3A:  MOVWF  FE9
06D3C:  MOVFF  707,735
06D40:  MOVFF  706,734
06D44:  MOVFF  705,733
06D48:  MOVFF  704,732
06D4C:  MOVLW  02
06D4E:  MOVLB  7
06D50:  MOVWF  x36
06D52:  MOVLB  0
06D54:  CALL   57BC
06D58:  MOVLW  2C
06D5A:  MOVLB  7
06D5C:  MOVWF  x3F
06D5E:  MOVLB  0
06D60:  CALL   561E
06D64:  MOVLW  89
06D66:  MOVWF  FE9
06D68:  MOVFF  70B,735
06D6C:  MOVFF  70A,734
06D70:  MOVFF  709,733
06D74:  MOVFF  708,732
06D78:  MOVLW  02
06D7A:  MOVLB  7
06D7C:  MOVWF  x36
06D7E:  MOVLB  0
06D80:  CALL   57BC
06D84:  MOVLW  2C
06D86:  MOVLB  7
06D88:  MOVWF  x3F
06D8A:  MOVLB  0
06D8C:  CALL   561E
06D90:  MOVLW  89
06D92:  MOVWF  FE9
06D94:  MOVFF  70F,735
06D98:  MOVFF  70E,734
06D9C:  MOVFF  70D,733
06DA0:  MOVFF  70C,732
06DA4:  MOVLW  02
06DA6:  MOVLB  7
06DA8:  MOVWF  x36
06DAA:  MOVLB  0
06DAC:  CALL   57BC
06DB0:  MOVLW  2C
06DB2:  MOVLB  7
06DB4:  MOVWF  x3F
06DB6:  MOVLB  0
06DB8:  CALL   561E
06DBC:  BRA    6DC8
06DBE:  MOVLB  6
....................    else return INV_PARAM;
06DC0:  MOVLW  02
06DC2:  MOVWF  01
06DC4:  MOVLB  0
06DC6:  BRA    6DCC
....................    
....................    return SUCCESS;
06DC8:  MOVLW  00
06DCA:  MOVWF  01
06DCC:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
070EA:  MOVLB  7
070EC:  CLRF   x31
070EE:  MOVFF  684,730
070F2:  CLRF   x33
070F4:  MOVLW  B5
070F6:  MOVWF  x32
070F8:  MOVLB  0
070FA:  CALL   0874
070FE:  MOVFF  02,701
07102:  MOVFF  01,700
07106:  MOVLW  06
07108:  MOVLB  7
0710A:  ADDWF  x00,F
0710C:  MOVLW  00
0710E:  ADDWFC x01,F
07110:  MOVLW  32
07112:  ADDWF  x00,W
07114:  MOVWF  01
07116:  MOVLW  00
07118:  ADDWFC x01,W
0711A:  MOVWF  03
0711C:  MOVF   01,W
0711E:  ADDLW  E9
07120:  MOVWF  01
07122:  MOVLW  01
07124:  ADDWFC 03,F
07126:  MOVFF  01,700
0712A:  MOVFF  03,701
0712E:  MOVFF  03,729
07132:  MOVFF  01,728
07136:  MOVLB  0
07138:  CALL   5C7C
0713C:  MOVF   01,F
0713E:  BNZ   7148
07140:  MOVLW  02
07142:  MOVWF  01
07144:  BRA    73D4
07146:  BRA    71A6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07148:  MOVLB  7
0714A:  CLRF   x31
0714C:  MOVFF  684,730
07150:  CLRF   x33
07152:  MOVLW  B5
07154:  MOVWF  x32
07156:  MOVLB  0
07158:  CALL   0874
0715C:  MOVFF  02,701
07160:  MOVFF  01,700
07164:  MOVLW  06
07166:  MOVLB  7
07168:  ADDWF  x00,F
0716A:  MOVLW  00
0716C:  ADDWFC x01,F
0716E:  MOVLW  32
07170:  ADDWF  x00,W
07172:  MOVWF  01
07174:  MOVLW  00
07176:  ADDWFC x01,W
07178:  MOVWF  03
0717A:  MOVF   01,W
0717C:  ADDLW  E9
0717E:  MOVWF  01
07180:  MOVLW  01
07182:  ADDWFC 03,F
07184:  MOVFF  01,700
07188:  MOVFF  03,701
0718C:  MOVFF  03,729
07190:  MOVFF  01,728
07194:  CLRF   x2B
07196:  CLRF   x2A
07198:  MOVLW  0A
0719A:  MOVWF  x2C
0719C:  MOVLB  0
0719E:  CALL   5D6C
071A2:  MOVFF  01,6FA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
071A6:  MOVLB  7
071A8:  CLRF   x31
071AA:  MOVFF  684,730
071AE:  CLRF   x33
071B0:  MOVLW  B5
071B2:  MOVWF  x32
071B4:  MOVLB  0
071B6:  CALL   0874
071BA:  MOVFF  02,701
071BE:  MOVFF  01,700
071C2:  MOVLW  06
071C4:  MOVLB  7
071C6:  ADDWF  x00,F
071C8:  MOVLW  00
071CA:  ADDWFC x01,F
071CC:  MOVLW  4B
071CE:  ADDWF  x00,W
071D0:  MOVWF  01
071D2:  MOVLW  00
071D4:  ADDWFC x01,W
071D6:  MOVWF  03
071D8:  MOVF   01,W
071DA:  ADDLW  E9
071DC:  MOVWF  01
071DE:  MOVLW  01
071E0:  ADDWFC 03,F
071E2:  MOVFF  01,700
071E6:  MOVFF  03,701
071EA:  MOVFF  03,731
071EE:  MOVFF  01,730
071F2:  MOVLB  0
071F4:  CALL   55E6
071F8:  MOVFF  02,03
071FC:  MOVF   01,W
071FE:  SUBLW  01
07200:  BNZ   7206
07202:  MOVF   03,F
07204:  BZ    720E
07206:  MOVLW  02
07208:  MOVWF  01
0720A:  BRA    73D4
0720C:  BRA    724E
....................    else arg2 = SERcmd[rec].p[3][0];
0720E:  MOVLB  7
07210:  CLRF   x31
07212:  MOVFF  684,730
07216:  CLRF   x33
07218:  MOVLW  B5
0721A:  MOVWF  x32
0721C:  MOVLB  0
0721E:  CALL   0874
07222:  MOVFF  02,701
07226:  MOVFF  01,700
0722A:  MOVLW  06
0722C:  MOVLB  7
0722E:  ADDWF  x00,F
07230:  MOVLW  00
07232:  ADDWFC x01,F
07234:  MOVLW  4B
07236:  ADDWF  x00,F
07238:  MOVLW  00
0723A:  ADDWFC x01,F
0723C:  MOVLW  E9
0723E:  ADDWF  x00,W
07240:  MOVWF  FE9
07242:  MOVLW  01
07244:  ADDWFC x01,W
07246:  MOVWF  FEA
07248:  MOVFF  FEF,6FB
0724C:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
0724E:  MOVLB  7
07250:  CLRF   x31
07252:  MOVFF  684,730
07256:  CLRF   x33
07258:  MOVLW  B5
0725A:  MOVWF  x32
0725C:  MOVLB  0
0725E:  CALL   0874
07262:  MOVFF  02,701
07266:  MOVFF  01,700
0726A:  MOVLW  06
0726C:  MOVLB  7
0726E:  ADDWF  x00,F
07270:  MOVLW  00
07272:  ADDWFC x01,F
07274:  MOVLW  64
07276:  ADDWF  x00,W
07278:  MOVWF  01
0727A:  MOVLW  00
0727C:  ADDWFC x01,W
0727E:  MOVWF  03
07280:  MOVF   01,W
07282:  ADDLW  E9
07284:  MOVWF  01
07286:  MOVLW  01
07288:  ADDWFC 03,F
0728A:  MOVFF  01,700
0728E:  MOVFF  03,701
07292:  MOVFF  03,704
07296:  MOVFF  01,703
0729A:  MOVLB  0
0729C:  RCALL  6DCE
0729E:  MOVF   01,F
072A0:  BNZ   72AA
072A2:  MOVLW  02
072A4:  MOVWF  01
072A6:  BRA    73D4
072A8:  BRA    730E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
072AA:  MOVLB  7
072AC:  CLRF   x31
072AE:  MOVFF  684,730
072B2:  CLRF   x33
072B4:  MOVLW  B5
072B6:  MOVWF  x32
072B8:  MOVLB  0
072BA:  CALL   0874
072BE:  MOVFF  02,701
072C2:  MOVFF  01,700
072C6:  MOVLW  06
072C8:  MOVLB  7
072CA:  ADDWF  x00,F
072CC:  MOVLW  00
072CE:  ADDWFC x01,F
072D0:  MOVLW  64
072D2:  ADDWF  x00,W
072D4:  MOVWF  01
072D6:  MOVLW  00
072D8:  ADDWFC x01,W
072DA:  MOVWF  03
072DC:  MOVF   01,W
072DE:  ADDLW  E9
072E0:  MOVWF  01
072E2:  MOVLW  01
072E4:  ADDWFC 03,F
072E6:  MOVFF  01,700
072EA:  MOVFF  03,701
072EE:  MOVFF  03,704
072F2:  MOVFF  01,703
072F6:  CLRF   x06
072F8:  CLRF   x05
072FA:  MOVLB  0
072FC:  RCALL  6E90
072FE:  MOVFF  03,6FF
07302:  MOVFF  02,6FE
07306:  MOVFF  01,6FD
0730A:  MOVFF  00,6FC
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
0730E:  MOVLB  6
07310:  MOVF   xFB,W
07312:  SUBLW  50
07314:  BNZ   7344
07316:  MOVLW  01
07318:  SUBWF  xFA,W
0731A:  MULLW  20
0731C:  MOVF   FF3,W
0731E:  MOVLB  7
07320:  CLRF   x01
07322:  MOVWF  x00
07324:  MOVLW  20
07326:  ADDWF  x00,W
07328:  MOVWF  FE9
0732A:  MOVLW  00
0732C:  ADDWFC x01,W
0732E:  MOVWF  FEA
07330:  MOVFF  6FC,FEF
07334:  MOVFF  6FD,FEC
07338:  MOVFF  6FE,FEC
0733C:  MOVFF  6FF,FEC
07340:  BRA    73CE
07342:  MOVLB  6
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
07344:  MOVF   xFB,W
07346:  SUBLW  49
07348:  BNZ   7384
0734A:  MOVLW  01
0734C:  SUBWF  xFA,W
0734E:  MULLW  20
07350:  MOVF   FF3,W
07352:  MOVLB  7
07354:  CLRF   x01
07356:  MOVWF  x00
07358:  MOVLW  04
0735A:  ADDWF  x00,W
0735C:  MOVWF  01
0735E:  MOVLW  00
07360:  ADDWFC x01,W
07362:  MOVWF  03
07364:  MOVF   01,W
07366:  ADDLW  20
07368:  MOVWF  FE9
0736A:  MOVLW  00
0736C:  ADDWFC 03,W
0736E:  MOVWF  FEA
07370:  MOVFF  6FC,FEF
07374:  MOVFF  6FD,FEC
07378:  MOVFF  6FE,FEC
0737C:  MOVFF  6FF,FEC
07380:  BRA    73CE
07382:  MOVLB  6
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07384:  MOVF   xFB,W
07386:  SUBLW  44
07388:  BNZ   73C4
0738A:  MOVLW  01
0738C:  SUBWF  xFA,W
0738E:  MULLW  20
07390:  MOVF   FF3,W
07392:  MOVLB  7
07394:  CLRF   x01
07396:  MOVWF  x00
07398:  MOVLW  08
0739A:  ADDWF  x00,W
0739C:  MOVWF  01
0739E:  MOVLW  00
073A0:  ADDWFC x01,W
073A2:  MOVWF  03
073A4:  MOVF   01,W
073A6:  ADDLW  20
073A8:  MOVWF  FE9
073AA:  MOVLW  00
073AC:  ADDWFC 03,W
073AE:  MOVWF  FEA
073B0:  MOVFF  6FC,FEF
073B4:  MOVFF  6FD,FEC
073B8:  MOVFF  6FE,FEC
073BC:  MOVFF  6FF,FEC
073C0:  BRA    73CE
073C2:  MOVLB  6
....................    else return INV_PARAM;
073C4:  MOVLW  02
073C6:  MOVWF  01
073C8:  MOVLB  0
073CA:  BRA    73D4
073CC:  MOVLB  7
....................    
....................    return SUCCESS;
073CE:  MOVLW  00
073D0:  MOVWF  01
073D2:  MOVLB  0
073D4:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
073D6:  MOVLB  7
073D8:  CLRF   x31
073DA:  MOVFF  684,730
073DE:  CLRF   x33
073E0:  MOVLW  B5
073E2:  MOVWF  x32
073E4:  MOVLB  0
073E6:  CALL   0874
073EA:  MOVFF  02,6FC
073EE:  MOVFF  01,6FB
073F2:  MOVLW  06
073F4:  MOVLB  6
073F6:  ADDWF  xFB,F
073F8:  MOVLW  00
073FA:  ADDWFC xFC,F
073FC:  MOVLW  32
073FE:  ADDWF  xFB,W
07400:  MOVWF  01
07402:  MOVLW  00
07404:  ADDWFC xFC,W
07406:  MOVWF  03
07408:  MOVF   01,W
0740A:  ADDLW  E9
0740C:  MOVWF  01
0740E:  MOVLW  01
07410:  ADDWFC 03,F
07412:  MOVFF  01,6FB
07416:  MOVFF  03,6FC
0741A:  MOVFF  03,729
0741E:  MOVFF  01,728
07422:  MOVLB  0
07424:  CALL   5C7C
07428:  MOVF   01,F
0742A:  BNZ   7434
0742C:  MOVLW  02
0742E:  MOVWF  01
07430:  BRA    753A
07432:  BRA    7494
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07434:  MOVLB  7
07436:  CLRF   x31
07438:  MOVFF  684,730
0743C:  CLRF   x33
0743E:  MOVLW  B5
07440:  MOVWF  x32
07442:  MOVLB  0
07444:  CALL   0874
07448:  MOVFF  02,6FC
0744C:  MOVFF  01,6FB
07450:  MOVLW  06
07452:  MOVLB  6
07454:  ADDWF  xFB,F
07456:  MOVLW  00
07458:  ADDWFC xFC,F
0745A:  MOVLW  32
0745C:  ADDWF  xFB,W
0745E:  MOVWF  01
07460:  MOVLW  00
07462:  ADDWFC xFC,W
07464:  MOVWF  03
07466:  MOVF   01,W
07468:  ADDLW  E9
0746A:  MOVWF  01
0746C:  MOVLW  01
0746E:  ADDWFC 03,F
07470:  MOVFF  01,6FB
07474:  MOVFF  03,6FC
07478:  MOVFF  03,729
0747C:  MOVFF  01,728
07480:  MOVLB  7
07482:  CLRF   x2B
07484:  CLRF   x2A
07486:  MOVLW  0A
07488:  MOVWF  x2C
0748A:  MOVLB  0
0748C:  CALL   5D6C
07490:  MOVFF  01,6FA
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07494:  MOVLW  04
07496:  MOVLB  7
07498:  MOVWF  x31
0749A:  MOVLW  BF
0749C:  MOVWF  x30
0749E:  MOVLB  0
074A0:  CALL   55E6
074A4:  MOVF   01,W
074A6:  ADDLW  BF
074A8:  MOVLB  6
074AA:  MOVWF  xFB
074AC:  MOVLW  04
074AE:  ADDWFC 02,W
074B0:  MOVWF  xFC
074B2:  MOVLW  01
074B4:  SUBWF  xFA,W
074B6:  MULLW  20
074B8:  MOVF   FF3,W
074BA:  CLRF   xFE
074BC:  MOVWF  xFD
074BE:  MOVLW  0C
074C0:  ADDWF  xFD,W
074C2:  MOVWF  01
074C4:  MOVLW  00
074C6:  ADDWFC xFE,W
074C8:  MOVWF  03
074CA:  MOVF   01,W
074CC:  ADDLW  20
074CE:  MOVWF  FE9
074D0:  MOVLW  00
074D2:  ADDWFC 03,W
074D4:  MOVWF  FEA
074D6:  MOVFF  FEF,6FD
074DA:  MOVFF  FEC,6FE
074DE:  MOVFF  FEC,6FF
074E2:  MOVFF  FEC,700
074E6:  MOVFF  6FC,563
074EA:  MOVFF  6FB,562
074EE:  MOVFF  6FA,729
074F2:  MOVLW  18
074F4:  MOVLB  7
074F6:  MOVWF  x2A
074F8:  MOVLB  0
074FA:  CALL   60C0
074FE:  MOVLW  2C
07500:  MOVLB  7
07502:  MOVWF  x3F
07504:  MOVLB  0
07506:  CALL   561E
0750A:  MOVLW  89
0750C:  MOVWF  FE9
0750E:  MOVFF  700,735
07512:  MOVFF  6FF,734
07516:  MOVFF  6FE,733
0751A:  MOVFF  6FD,732
0751E:  MOVLW  02
07520:  MOVLB  7
07522:  MOVWF  x36
07524:  MOVLB  0
07526:  CALL   57BC
0752A:  MOVLW  2C
0752C:  MOVLB  7
0752E:  MOVWF  x3F
07530:  MOVLB  0
07532:  CALL   561E
....................    return SUCCESS;
07536:  MOVLW  00
07538:  MOVWF  01
0753A:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0753C:  MOVLB  7
0753E:  CLRF   x31
07540:  MOVFF  684,730
07544:  CLRF   x33
07546:  MOVLW  B5
07548:  MOVWF  x32
0754A:  MOVLB  0
0754C:  CALL   0874
07550:  MOVFF  02,700
07554:  MOVFF  01,6FF
07558:  MOVLW  06
0755A:  MOVLB  6
0755C:  ADDWF  xFF,F
0755E:  MOVLW  00
07560:  MOVLB  7
07562:  ADDWFC x00,F
07564:  MOVLW  32
07566:  MOVLB  6
07568:  ADDWF  xFF,W
0756A:  MOVWF  01
0756C:  MOVLW  00
0756E:  MOVLB  7
07570:  ADDWFC x00,W
07572:  MOVWF  03
07574:  MOVF   01,W
07576:  ADDLW  E9
07578:  MOVWF  01
0757A:  MOVLW  01
0757C:  ADDWFC 03,F
0757E:  MOVFF  01,6FF
07582:  MOVFF  03,700
07586:  MOVFF  03,729
0758A:  MOVFF  01,728
0758E:  MOVLB  0
07590:  CALL   5C7C
07594:  MOVF   01,F
07596:  BNZ   75A0
07598:  MOVLW  02
0759A:  MOVWF  01
0759C:  BRA    771A
0759E:  BRA    7606
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
075A0:  MOVLB  7
075A2:  CLRF   x31
075A4:  MOVFF  684,730
075A8:  CLRF   x33
075AA:  MOVLW  B5
075AC:  MOVWF  x32
075AE:  MOVLB  0
075B0:  CALL   0874
075B4:  MOVFF  02,700
075B8:  MOVFF  01,6FF
075BC:  MOVLW  06
075BE:  MOVLB  6
075C0:  ADDWF  xFF,F
075C2:  MOVLW  00
075C4:  MOVLB  7
075C6:  ADDWFC x00,F
075C8:  MOVLW  32
075CA:  MOVLB  6
075CC:  ADDWF  xFF,W
075CE:  MOVWF  01
075D0:  MOVLW  00
075D2:  MOVLB  7
075D4:  ADDWFC x00,W
075D6:  MOVWF  03
075D8:  MOVF   01,W
075DA:  ADDLW  E9
075DC:  MOVWF  01
075DE:  MOVLW  01
075E0:  ADDWFC 03,F
075E2:  MOVFF  01,6FF
075E6:  MOVFF  03,700
075EA:  MOVFF  03,729
075EE:  MOVFF  01,728
075F2:  MOVLB  7
075F4:  CLRF   x2B
075F6:  CLRF   x2A
075F8:  MOVLW  0A
075FA:  MOVWF  x2C
075FC:  MOVLB  0
075FE:  CALL   5D6C
07602:  MOVFF  01,6FA
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07606:  MOVLB  7
07608:  CLRF   x31
0760A:  MOVFF  684,730
0760E:  CLRF   x33
07610:  MOVLW  B5
07612:  MOVWF  x32
07614:  MOVLB  0
07616:  CALL   0874
0761A:  MOVFF  02,700
0761E:  MOVFF  01,6FF
07622:  MOVLW  06
07624:  MOVLB  6
07626:  ADDWF  xFF,F
07628:  MOVLW  00
0762A:  MOVLB  7
0762C:  ADDWFC x00,F
0762E:  MOVLW  4B
07630:  MOVLB  6
07632:  ADDWF  xFF,W
07634:  MOVWF  01
07636:  MOVLW  00
07638:  MOVLB  7
0763A:  ADDWFC x00,W
0763C:  MOVWF  03
0763E:  MOVF   01,W
07640:  ADDLW  E9
07642:  MOVWF  01
07644:  MOVLW  01
07646:  ADDWFC 03,F
07648:  MOVFF  01,6FF
0764C:  MOVFF  03,700
07650:  MOVFF  03,704
07654:  MOVFF  01,703
07658:  MOVLB  0
0765A:  CALL   6DCE
0765E:  MOVF   01,F
07660:  BNZ   766A
07662:  MOVLW  02
07664:  MOVWF  01
07666:  BRA    771A
07668:  BRA    76D8
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
0766A:  MOVLB  7
0766C:  CLRF   x31
0766E:  MOVFF  684,730
07672:  CLRF   x33
07674:  MOVLW  B5
07676:  MOVWF  x32
07678:  MOVLB  0
0767A:  CALL   0874
0767E:  MOVFF  02,700
07682:  MOVFF  01,6FF
07686:  MOVLW  06
07688:  MOVLB  6
0768A:  ADDWF  xFF,F
0768C:  MOVLW  00
0768E:  MOVLB  7
07690:  ADDWFC x00,F
07692:  MOVLW  4B
07694:  MOVLB  6
07696:  ADDWF  xFF,W
07698:  MOVWF  01
0769A:  MOVLW  00
0769C:  MOVLB  7
0769E:  ADDWFC x00,W
076A0:  MOVWF  03
076A2:  MOVF   01,W
076A4:  ADDLW  E9
076A6:  MOVWF  01
076A8:  MOVLW  01
076AA:  ADDWFC 03,F
076AC:  MOVFF  01,6FF
076B0:  MOVFF  03,700
076B4:  MOVFF  03,704
076B8:  MOVFF  01,703
076BC:  MOVLB  7
076BE:  CLRF   x06
076C0:  CLRF   x05
076C2:  MOVLB  0
076C4:  CALL   6E90
076C8:  MOVFF  03,6FE
076CC:  MOVFF  02,6FD
076D0:  MOVFF  01,6FC
076D4:  MOVFF  00,6FB
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
076D8:  MOVLW  01
076DA:  MOVLB  6
076DC:  SUBWF  xFA,W
076DE:  MULLW  20
076E0:  MOVF   FF3,W
076E2:  MOVLB  7
076E4:  CLRF   x00
076E6:  MOVLB  6
076E8:  MOVWF  xFF
076EA:  MOVLW  0C
076EC:  ADDWF  xFF,W
076EE:  MOVWF  01
076F0:  MOVLW  00
076F2:  MOVLB  7
076F4:  ADDWFC x00,W
076F6:  MOVWF  03
076F8:  MOVF   01,W
076FA:  ADDLW  20
076FC:  MOVWF  FE9
076FE:  MOVLW  00
07700:  ADDWFC 03,W
07702:  MOVWF  FEA
07704:  MOVFF  6FB,FEF
07708:  MOVFF  6FC,FEC
0770C:  MOVFF  6FD,FEC
07710:  MOVFF  6FE,FEC
....................    
....................    return SUCCESS;
07714:  MOVLW  00
07716:  MOVWF  01
07718:  MOVLB  0
0771A:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0771C:  MOVLB  7
0771E:  CLRF   x31
07720:  MOVFF  684,730
07724:  CLRF   x33
07726:  MOVLW  B5
07728:  MOVWF  x32
0772A:  MOVLB  0
0772C:  CALL   0874
07730:  MOVFF  02,701
07734:  MOVFF  01,700
07738:  MOVLW  06
0773A:  MOVLB  7
0773C:  ADDWF  x00,F
0773E:  MOVLW  00
07740:  ADDWFC x01,F
07742:  MOVLW  32
07744:  ADDWF  x00,W
07746:  MOVWF  01
07748:  MOVLW  00
0774A:  ADDWFC x01,W
0774C:  MOVWF  03
0774E:  MOVF   01,W
07750:  ADDLW  E9
07752:  MOVWF  01
07754:  MOVLW  01
07756:  ADDWFC 03,F
07758:  MOVFF  01,700
0775C:  MOVFF  03,701
07760:  MOVFF  03,729
07764:  MOVFF  01,728
07768:  MOVLB  0
0776A:  CALL   5C7C
0776E:  MOVF   01,F
07770:  BNZ   777A
07772:  MOVLW  02
07774:  MOVWF  01
07776:  BRA    7AE8
07778:  BRA    77D8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0777A:  MOVLB  7
0777C:  CLRF   x31
0777E:  MOVFF  684,730
07782:  CLRF   x33
07784:  MOVLW  B5
07786:  MOVWF  x32
07788:  MOVLB  0
0778A:  CALL   0874
0778E:  MOVFF  02,701
07792:  MOVFF  01,700
07796:  MOVLW  06
07798:  MOVLB  7
0779A:  ADDWF  x00,F
0779C:  MOVLW  00
0779E:  ADDWFC x01,F
077A0:  MOVLW  32
077A2:  ADDWF  x00,W
077A4:  MOVWF  01
077A6:  MOVLW  00
077A8:  ADDWFC x01,W
077AA:  MOVWF  03
077AC:  MOVF   01,W
077AE:  ADDLW  E9
077B0:  MOVWF  01
077B2:  MOVLW  01
077B4:  ADDWFC 03,F
077B6:  MOVFF  01,700
077BA:  MOVFF  03,701
077BE:  MOVFF  03,729
077C2:  MOVFF  01,728
077C6:  CLRF   x2B
077C8:  CLRF   x2A
077CA:  MOVLW  0A
077CC:  MOVWF  x2C
077CE:  MOVLB  0
077D0:  CALL   5D6C
077D4:  MOVFF  01,6FA
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
077D8:  MOVLW  04
077DA:  MOVLB  7
077DC:  MOVWF  x31
077DE:  MOVLW  BF
077E0:  MOVWF  x30
077E2:  MOVLB  0
077E4:  CALL   55E6
077E8:  MOVFF  02,03
077EC:  MOVF   01,W
077EE:  ADDLW  BF
077F0:  MOVLB  7
077F2:  MOVWF  x00
077F4:  MOVLW  04
077F6:  ADDWFC 02,W
077F8:  MOVWF  x01
077FA:  MOVFF  FE8,563
077FE:  MOVFF  700,562
07802:  MOVFF  6FA,729
07806:  MOVLW  18
07808:  MOVWF  x2A
0780A:  MOVLB  0
0780C:  CALL   60C0
07810:  MOVLW  2C
07812:  MOVLB  7
07814:  MOVWF  x3F
07816:  MOVLB  0
07818:  CALL   561E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0781C:  MOVLW  04
0781E:  MOVLB  7
07820:  MOVWF  x31
07822:  MOVLW  BF
07824:  MOVWF  x30
07826:  MOVLB  0
07828:  CALL   55E6
0782C:  MOVFF  02,03
07830:  MOVF   01,W
07832:  ADDLW  BF
07834:  MOVLB  7
07836:  MOVWF  x00
07838:  MOVLW  04
0783A:  ADDWFC 02,W
0783C:  MOVWF  x01
0783E:  MOVLW  01
07840:  MOVLB  6
07842:  SUBWF  xFA,W
07844:  MULLW  18
07846:  MOVF   FF3,W
07848:  MOVLB  7
0784A:  CLRF   x03
0784C:  MOVWF  x02
0784E:  MOVLW  82
07850:  ADDWF  x02,W
07852:  MOVWF  FE9
07854:  MOVLW  00
07856:  ADDWFC x03,W
07858:  MOVWF  FEA
0785A:  MOVFF  FEF,732
0785E:  MOVFF  FEC,733
07862:  MOVFF  FEC,734
07866:  MOVFF  FEC,735
0786A:  MOVFF  701,563
0786E:  MOVFF  700,562
07872:  MOVLW  89
07874:  MOVWF  FE9
07876:  MOVLW  02
07878:  MOVWF  x36
0787A:  MOVLB  0
0787C:  CALL   57BC
07880:  MOVLW  2C
07882:  MOVLB  7
07884:  MOVWF  x3F
07886:  MOVLB  0
07888:  CALL   561E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0788C:  MOVLW  04
0788E:  MOVLB  7
07890:  MOVWF  x31
07892:  MOVLW  BF
07894:  MOVWF  x30
07896:  MOVLB  0
07898:  CALL   55E6
0789C:  MOVF   01,W
0789E:  ADDLW  BF
078A0:  MOVLB  7
078A2:  MOVWF  x00
078A4:  MOVLW  04
078A6:  ADDWFC 02,W
078A8:  MOVWF  x01
078AA:  MOVLW  01
078AC:  MOVLB  6
078AE:  SUBWF  xFA,W
078B0:  MULLW  18
078B2:  MOVF   FF3,W
078B4:  MOVLB  7
078B6:  CLRF   x03
078B8:  MOVWF  x02
078BA:  MOVLW  04
078BC:  ADDWF  x02,W
078BE:  MOVWF  01
078C0:  MOVLW  00
078C2:  ADDWFC x03,W
078C4:  MOVWF  03
078C6:  MOVF   01,W
078C8:  ADDLW  82
078CA:  MOVWF  FE9
078CC:  MOVLW  00
078CE:  ADDWFC 03,W
078D0:  MOVWF  FEA
078D2:  MOVFF  FEF,732
078D6:  MOVFF  FEC,733
078DA:  MOVFF  FEC,734
078DE:  MOVFF  FEC,735
078E2:  MOVFF  701,563
078E6:  MOVFF  700,562
078EA:  MOVLW  89
078EC:  MOVWF  FE9
078EE:  MOVLW  02
078F0:  MOVWF  x36
078F2:  MOVLB  0
078F4:  CALL   57BC
078F8:  MOVLW  2C
078FA:  MOVLB  7
078FC:  MOVWF  x3F
078FE:  MOVLB  0
07900:  CALL   561E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07904:  MOVLW  04
07906:  MOVLB  7
07908:  MOVWF  x31
0790A:  MOVLW  BF
0790C:  MOVWF  x30
0790E:  MOVLB  0
07910:  CALL   55E6
07914:  MOVF   01,W
07916:  ADDLW  BF
07918:  MOVLB  7
0791A:  MOVWF  x00
0791C:  MOVLW  04
0791E:  ADDWFC 02,W
07920:  MOVWF  x01
07922:  MOVLW  01
07924:  MOVLB  6
07926:  SUBWF  xFA,W
07928:  MULLW  18
0792A:  MOVF   FF3,W
0792C:  MOVLB  7
0792E:  CLRF   x03
07930:  MOVWF  x02
07932:  MOVLW  08
07934:  ADDWF  x02,W
07936:  MOVWF  01
07938:  MOVLW  00
0793A:  ADDWFC x03,W
0793C:  MOVWF  03
0793E:  MOVF   01,W
07940:  ADDLW  82
07942:  MOVWF  FE9
07944:  MOVLW  00
07946:  ADDWFC 03,W
07948:  MOVWF  FEA
0794A:  MOVFF  FEF,732
0794E:  MOVFF  FEC,733
07952:  MOVFF  FEC,734
07956:  MOVFF  FEC,735
0795A:  MOVFF  701,563
0795E:  MOVFF  700,562
07962:  MOVLW  89
07964:  MOVWF  FE9
07966:  MOVLW  02
07968:  MOVWF  x36
0796A:  MOVLB  0
0796C:  CALL   57BC
07970:  MOVLW  2C
07972:  MOVLB  7
07974:  MOVWF  x3F
07976:  MOVLB  0
07978:  CALL   561E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
0797C:  MOVLW  04
0797E:  MOVLB  7
07980:  MOVWF  x31
07982:  MOVLW  BF
07984:  MOVWF  x30
07986:  MOVLB  0
07988:  CALL   55E6
0798C:  MOVF   01,W
0798E:  ADDLW  BF
07990:  MOVLB  7
07992:  MOVWF  x00
07994:  MOVLW  04
07996:  ADDWFC 02,W
07998:  MOVWF  x01
0799A:  MOVLW  01
0799C:  MOVLB  6
0799E:  SUBWF  xFA,W
079A0:  MULLW  18
079A2:  MOVF   FF3,W
079A4:  MOVLB  7
079A6:  CLRF   x03
079A8:  MOVWF  x02
079AA:  MOVLW  0C
079AC:  ADDWF  x02,W
079AE:  MOVWF  01
079B0:  MOVLW  00
079B2:  ADDWFC x03,W
079B4:  MOVWF  03
079B6:  MOVF   01,W
079B8:  ADDLW  82
079BA:  MOVWF  FE9
079BC:  MOVLW  00
079BE:  ADDWFC 03,W
079C0:  MOVWF  FEA
079C2:  MOVFF  FEF,732
079C6:  MOVFF  FEC,733
079CA:  MOVFF  FEC,734
079CE:  MOVFF  FEC,735
079D2:  MOVFF  701,563
079D6:  MOVFF  700,562
079DA:  MOVLW  89
079DC:  MOVWF  FE9
079DE:  MOVLW  02
079E0:  MOVWF  x36
079E2:  MOVLB  0
079E4:  CALL   57BC
079E8:  MOVLW  2C
079EA:  MOVLB  7
079EC:  MOVWF  x3F
079EE:  MOVLB  0
079F0:  CALL   561E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
079F4:  MOVLW  04
079F6:  MOVLB  7
079F8:  MOVWF  x31
079FA:  MOVLW  BF
079FC:  MOVWF  x30
079FE:  MOVLB  0
07A00:  CALL   55E6
07A04:  MOVF   01,W
07A06:  ADDLW  BF
07A08:  MOVLB  7
07A0A:  MOVWF  x00
07A0C:  MOVLW  04
07A0E:  ADDWFC 02,W
07A10:  MOVWF  x01
07A12:  MOVLW  01
07A14:  MOVLB  6
07A16:  SUBWF  xFA,W
07A18:  MULLW  18
07A1A:  MOVF   FF3,W
07A1C:  MOVLB  7
07A1E:  CLRF   x03
07A20:  MOVWF  x02
07A22:  MOVLW  10
07A24:  ADDWF  x02,W
07A26:  MOVWF  01
07A28:  MOVLW  00
07A2A:  ADDWFC x03,W
07A2C:  MOVWF  03
07A2E:  MOVF   01,W
07A30:  ADDLW  82
07A32:  MOVWF  FE9
07A34:  MOVLW  00
07A36:  ADDWFC 03,W
07A38:  MOVWF  FEA
07A3A:  MOVFF  FEF,732
07A3E:  MOVFF  FEC,733
07A42:  MOVFF  FEC,734
07A46:  MOVFF  FEC,735
07A4A:  MOVFF  701,563
07A4E:  MOVFF  700,562
07A52:  MOVLW  89
07A54:  MOVWF  FE9
07A56:  MOVLW  02
07A58:  MOVWF  x36
07A5A:  MOVLB  0
07A5C:  CALL   57BC
07A60:  MOVLW  2C
07A62:  MOVLB  7
07A64:  MOVWF  x3F
07A66:  MOVLB  0
07A68:  CALL   561E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07A6C:  MOVLW  04
07A6E:  MOVLB  7
07A70:  MOVWF  x31
07A72:  MOVLW  BF
07A74:  MOVWF  x30
07A76:  MOVLB  0
07A78:  CALL   55E6
07A7C:  MOVF   01,W
07A7E:  ADDLW  BF
07A80:  MOVLB  7
07A82:  MOVWF  x00
07A84:  MOVLW  04
07A86:  ADDWFC 02,W
07A88:  MOVWF  x01
07A8A:  MOVLW  01
07A8C:  MOVLB  6
07A8E:  SUBWF  xFA,W
07A90:  MULLW  18
07A92:  MOVF   FF3,W
07A94:  MOVLB  7
07A96:  CLRF   x03
07A98:  MOVWF  x02
07A9A:  MOVLW  14
07A9C:  ADDWF  x02,W
07A9E:  MOVWF  01
07AA0:  MOVLW  00
07AA2:  ADDWFC x03,W
07AA4:  MOVWF  03
07AA6:  MOVF   01,W
07AA8:  ADDLW  82
07AAA:  MOVWF  FE9
07AAC:  MOVLW  00
07AAE:  ADDWFC 03,W
07AB0:  MOVWF  FEA
07AB2:  MOVFF  FEF,732
07AB6:  MOVFF  FEC,733
07ABA:  MOVFF  FEC,734
07ABE:  MOVFF  FEC,735
07AC2:  MOVFF  701,563
07AC6:  MOVFF  700,562
07ACA:  MOVLW  89
07ACC:  MOVWF  FE9
07ACE:  MOVLW  02
07AD0:  MOVWF  x36
07AD2:  MOVLB  0
07AD4:  CALL   57BC
07AD8:  MOVLW  2C
07ADA:  MOVLB  7
07ADC:  MOVWF  x3F
07ADE:  MOVLB  0
07AE0:  CALL   561E
....................    
....................    return SUCCESS;
07AE4:  MOVLW  00
07AE6:  MOVWF  01
07AE8:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07AEA:  MOVLB  7
07AEC:  CLRF   x31
07AEE:  MOVFF  684,730
07AF2:  CLRF   x33
07AF4:  MOVLW  B5
07AF6:  MOVWF  x32
07AF8:  MOVLB  0
07AFA:  CALL   0874
07AFE:  MOVFF  02,701
07B02:  MOVFF  01,700
07B06:  MOVLW  06
07B08:  MOVLB  7
07B0A:  ADDWF  x00,F
07B0C:  MOVLW  00
07B0E:  ADDWFC x01,F
07B10:  MOVLW  32
07B12:  ADDWF  x00,W
07B14:  MOVWF  01
07B16:  MOVLW  00
07B18:  ADDWFC x01,W
07B1A:  MOVWF  03
07B1C:  MOVF   01,W
07B1E:  ADDLW  E9
07B20:  MOVWF  01
07B22:  MOVLW  01
07B24:  ADDWFC 03,F
07B26:  MOVFF  01,700
07B2A:  MOVFF  03,701
07B2E:  MOVFF  03,729
07B32:  MOVFF  01,728
07B36:  MOVLB  0
07B38:  CALL   5C7C
07B3C:  MOVF   01,F
07B3E:  BNZ   7B48
07B40:  MOVLW  02
07B42:  MOVWF  01
07B44:  BRA    8068
07B46:  BRA    7BA6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07B48:  MOVLB  7
07B4A:  CLRF   x31
07B4C:  MOVFF  684,730
07B50:  CLRF   x33
07B52:  MOVLW  B5
07B54:  MOVWF  x32
07B56:  MOVLB  0
07B58:  CALL   0874
07B5C:  MOVFF  02,701
07B60:  MOVFF  01,700
07B64:  MOVLW  06
07B66:  MOVLB  7
07B68:  ADDWF  x00,F
07B6A:  MOVLW  00
07B6C:  ADDWFC x01,F
07B6E:  MOVLW  32
07B70:  ADDWF  x00,W
07B72:  MOVWF  01
07B74:  MOVLW  00
07B76:  ADDWFC x01,W
07B78:  MOVWF  03
07B7A:  MOVF   01,W
07B7C:  ADDLW  E9
07B7E:  MOVWF  01
07B80:  MOVLW  01
07B82:  ADDWFC 03,F
07B84:  MOVFF  01,700
07B88:  MOVFF  03,701
07B8C:  MOVFF  03,729
07B90:  MOVFF  01,728
07B94:  CLRF   x2B
07B96:  CLRF   x2A
07B98:  MOVLW  0A
07B9A:  MOVWF  x2C
07B9C:  MOVLB  0
07B9E:  CALL   5D6C
07BA2:  MOVFF  01,6FA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07BA6:  MOVLB  7
07BA8:  CLRF   x31
07BAA:  MOVFF  684,730
07BAE:  CLRF   x33
07BB0:  MOVLW  B5
07BB2:  MOVWF  x32
07BB4:  MOVLB  0
07BB6:  CALL   0874
07BBA:  MOVFF  02,701
07BBE:  MOVFF  01,700
07BC2:  MOVLW  06
07BC4:  MOVLB  7
07BC6:  ADDWF  x00,F
07BC8:  MOVLW  00
07BCA:  ADDWFC x01,F
07BCC:  MOVLW  4B
07BCE:  ADDWF  x00,W
07BD0:  MOVWF  01
07BD2:  MOVLW  00
07BD4:  ADDWFC x01,W
07BD6:  MOVWF  03
07BD8:  MOVF   01,W
07BDA:  ADDLW  E9
07BDC:  MOVWF  01
07BDE:  MOVLW  01
07BE0:  ADDWFC 03,F
07BE2:  MOVFF  01,700
07BE6:  MOVFF  03,701
07BEA:  MOVFF  03,731
07BEE:  MOVFF  01,730
07BF2:  MOVLB  0
07BF4:  CALL   55E6
07BF8:  MOVFF  02,03
07BFC:  MOVF   01,W
07BFE:  SUBLW  01
07C00:  BNZ   7C06
07C02:  MOVF   03,F
07C04:  BZ    7C0E
07C06:  MOVLW  02
07C08:  MOVWF  01
07C0A:  BRA    8068
07C0C:  BRA    7C4E
....................    else arg2 = SERcmd[rec].p[3][0];
07C0E:  MOVLB  7
07C10:  CLRF   x31
07C12:  MOVFF  684,730
07C16:  CLRF   x33
07C18:  MOVLW  B5
07C1A:  MOVWF  x32
07C1C:  MOVLB  0
07C1E:  CALL   0874
07C22:  MOVFF  02,701
07C26:  MOVFF  01,700
07C2A:  MOVLW  06
07C2C:  MOVLB  7
07C2E:  ADDWF  x00,F
07C30:  MOVLW  00
07C32:  ADDWFC x01,F
07C34:  MOVLW  4B
07C36:  ADDWF  x00,F
07C38:  MOVLW  00
07C3A:  ADDWFC x01,F
07C3C:  MOVLW  E9
07C3E:  ADDWF  x00,W
07C40:  MOVWF  FE9
07C42:  MOVLW  01
07C44:  ADDWFC x01,W
07C46:  MOVWF  FEA
07C48:  MOVFF  FEF,6FB
07C4C:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07C4E:  MOVLB  6
07C50:  MOVF   xFB,W
07C52:  SUBLW  30
07C54:  BNZ   7CF6
07C56:  MOVLW  04
07C58:  MOVLB  7
07C5A:  MOVWF  x31
07C5C:  MOVLW  BF
07C5E:  MOVWF  x30
07C60:  MOVLB  0
07C62:  CALL   55E6
07C66:  MOVFF  02,03
07C6A:  MOVF   01,W
07C6C:  ADDLW  BF
07C6E:  MOVLB  7
07C70:  MOVWF  x00
07C72:  MOVLW  04
07C74:  ADDWFC 02,W
07C76:  MOVWF  x01
07C78:  MOVLW  01
07C7A:  MOVLB  6
07C7C:  SUBWF  xFA,W
07C7E:  MULLW  18
07C80:  MOVF   FF3,W
07C82:  MOVLB  7
07C84:  CLRF   x03
07C86:  MOVWF  x02
07C88:  MOVLW  82
07C8A:  ADDWF  x02,W
07C8C:  MOVWF  FE9
07C8E:  MOVLW  00
07C90:  ADDWFC x03,W
07C92:  MOVWF  FEA
07C94:  MOVFF  FEF,704
07C98:  MOVFF  FEC,705
07C9C:  MOVFF  FEC,706
07CA0:  MOVFF  FEC,707
07CA4:  MOVFF  701,563
07CA8:  MOVFF  700,562
07CAC:  MOVFF  6FA,729
07CB0:  MOVLW  18
07CB2:  MOVWF  x2A
07CB4:  MOVLB  0
07CB6:  CALL   60C0
07CBA:  MOVLW  2C
07CBC:  MOVLB  7
07CBE:  MOVWF  x3F
07CC0:  MOVLB  0
07CC2:  CALL   561E
07CC6:  MOVLW  89
07CC8:  MOVWF  FE9
07CCA:  MOVFF  707,735
07CCE:  MOVFF  706,734
07CD2:  MOVFF  705,733
07CD6:  MOVFF  704,732
07CDA:  MOVLW  02
07CDC:  MOVLB  7
07CDE:  MOVWF  x36
07CE0:  MOVLB  0
07CE2:  CALL   57BC
07CE6:  MOVLW  2C
07CE8:  MOVLB  7
07CEA:  MOVWF  x3F
07CEC:  MOVLB  0
07CEE:  CALL   561E
07CF2:  BRA    8064
07CF4:  MOVLB  6
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07CF6:  MOVF   xFB,W
07CF8:  SUBLW  31
07CFA:  BNZ   7DA4
07CFC:  MOVLW  04
07CFE:  MOVLB  7
07D00:  MOVWF  x31
07D02:  MOVLW  BF
07D04:  MOVWF  x30
07D06:  MOVLB  0
07D08:  CALL   55E6
07D0C:  MOVF   01,W
07D0E:  ADDLW  BF
07D10:  MOVLB  7
07D12:  MOVWF  x00
07D14:  MOVLW  04
07D16:  ADDWFC 02,W
07D18:  MOVWF  x01
07D1A:  MOVLW  01
07D1C:  MOVLB  6
07D1E:  SUBWF  xFA,W
07D20:  MULLW  18
07D22:  MOVF   FF3,W
07D24:  MOVLB  7
07D26:  CLRF   x03
07D28:  MOVWF  x02
07D2A:  MOVLW  04
07D2C:  ADDWF  x02,W
07D2E:  MOVWF  01
07D30:  MOVLW  00
07D32:  ADDWFC x03,W
07D34:  MOVWF  03
07D36:  MOVF   01,W
07D38:  ADDLW  82
07D3A:  MOVWF  FE9
07D3C:  MOVLW  00
07D3E:  ADDWFC 03,W
07D40:  MOVWF  FEA
07D42:  MOVFF  FEF,702
07D46:  MOVFF  FEC,703
07D4A:  MOVFF  FEC,704
07D4E:  MOVFF  FEC,705
07D52:  MOVFF  701,563
07D56:  MOVFF  700,562
07D5A:  MOVFF  6FA,729
07D5E:  MOVLW  18
07D60:  MOVWF  x2A
07D62:  MOVLB  0
07D64:  CALL   60C0
07D68:  MOVLW  2C
07D6A:  MOVLB  7
07D6C:  MOVWF  x3F
07D6E:  MOVLB  0
07D70:  CALL   561E
07D74:  MOVLW  89
07D76:  MOVWF  FE9
07D78:  MOVFF  705,735
07D7C:  MOVFF  704,734
07D80:  MOVFF  703,733
07D84:  MOVFF  702,732
07D88:  MOVLW  02
07D8A:  MOVLB  7
07D8C:  MOVWF  x36
07D8E:  MOVLB  0
07D90:  CALL   57BC
07D94:  MOVLW  2C
07D96:  MOVLB  7
07D98:  MOVWF  x3F
07D9A:  MOVLB  0
07D9C:  CALL   561E
07DA0:  BRA    8064
07DA2:  MOVLB  6
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07DA4:  MOVF   xFB,W
07DA6:  SUBLW  32
07DA8:  BNZ   7E52
07DAA:  MOVLW  04
07DAC:  MOVLB  7
07DAE:  MOVWF  x31
07DB0:  MOVLW  BF
07DB2:  MOVWF  x30
07DB4:  MOVLB  0
07DB6:  CALL   55E6
07DBA:  MOVF   01,W
07DBC:  ADDLW  BF
07DBE:  MOVLB  7
07DC0:  MOVWF  x00
07DC2:  MOVLW  04
07DC4:  ADDWFC 02,W
07DC6:  MOVWF  x01
07DC8:  MOVLW  01
07DCA:  MOVLB  6
07DCC:  SUBWF  xFA,W
07DCE:  MULLW  18
07DD0:  MOVF   FF3,W
07DD2:  MOVLB  7
07DD4:  CLRF   x03
07DD6:  MOVWF  x02
07DD8:  MOVLW  08
07DDA:  ADDWF  x02,W
07DDC:  MOVWF  01
07DDE:  MOVLW  00
07DE0:  ADDWFC x03,W
07DE2:  MOVWF  03
07DE4:  MOVF   01,W
07DE6:  ADDLW  82
07DE8:  MOVWF  FE9
07DEA:  MOVLW  00
07DEC:  ADDWFC 03,W
07DEE:  MOVWF  FEA
07DF0:  MOVFF  FEF,702
07DF4:  MOVFF  FEC,703
07DF8:  MOVFF  FEC,704
07DFC:  MOVFF  FEC,705
07E00:  MOVFF  701,563
07E04:  MOVFF  700,562
07E08:  MOVFF  6FA,729
07E0C:  MOVLW  18
07E0E:  MOVWF  x2A
07E10:  MOVLB  0
07E12:  CALL   60C0
07E16:  MOVLW  2C
07E18:  MOVLB  7
07E1A:  MOVWF  x3F
07E1C:  MOVLB  0
07E1E:  CALL   561E
07E22:  MOVLW  89
07E24:  MOVWF  FE9
07E26:  MOVFF  705,735
07E2A:  MOVFF  704,734
07E2E:  MOVFF  703,733
07E32:  MOVFF  702,732
07E36:  MOVLW  02
07E38:  MOVLB  7
07E3A:  MOVWF  x36
07E3C:  MOVLB  0
07E3E:  CALL   57BC
07E42:  MOVLW  2C
07E44:  MOVLB  7
07E46:  MOVWF  x3F
07E48:  MOVLB  0
07E4A:  CALL   561E
07E4E:  BRA    8064
07E50:  MOVLB  6
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07E52:  MOVF   xFB,W
07E54:  SUBLW  33
07E56:  BNZ   7F00
07E58:  MOVLW  04
07E5A:  MOVLB  7
07E5C:  MOVWF  x31
07E5E:  MOVLW  BF
07E60:  MOVWF  x30
07E62:  MOVLB  0
07E64:  CALL   55E6
07E68:  MOVF   01,W
07E6A:  ADDLW  BF
07E6C:  MOVLB  7
07E6E:  MOVWF  x00
07E70:  MOVLW  04
07E72:  ADDWFC 02,W
07E74:  MOVWF  x01
07E76:  MOVLW  01
07E78:  MOVLB  6
07E7A:  SUBWF  xFA,W
07E7C:  MULLW  18
07E7E:  MOVF   FF3,W
07E80:  MOVLB  7
07E82:  CLRF   x03
07E84:  MOVWF  x02
07E86:  MOVLW  0C
07E88:  ADDWF  x02,W
07E8A:  MOVWF  01
07E8C:  MOVLW  00
07E8E:  ADDWFC x03,W
07E90:  MOVWF  03
07E92:  MOVF   01,W
07E94:  ADDLW  82
07E96:  MOVWF  FE9
07E98:  MOVLW  00
07E9A:  ADDWFC 03,W
07E9C:  MOVWF  FEA
07E9E:  MOVFF  FEF,702
07EA2:  MOVFF  FEC,703
07EA6:  MOVFF  FEC,704
07EAA:  MOVFF  FEC,705
07EAE:  MOVFF  701,563
07EB2:  MOVFF  700,562
07EB6:  MOVFF  6FA,729
07EBA:  MOVLW  18
07EBC:  MOVWF  x2A
07EBE:  MOVLB  0
07EC0:  CALL   60C0
07EC4:  MOVLW  2C
07EC6:  MOVLB  7
07EC8:  MOVWF  x3F
07ECA:  MOVLB  0
07ECC:  CALL   561E
07ED0:  MOVLW  89
07ED2:  MOVWF  FE9
07ED4:  MOVFF  705,735
07ED8:  MOVFF  704,734
07EDC:  MOVFF  703,733
07EE0:  MOVFF  702,732
07EE4:  MOVLW  02
07EE6:  MOVLB  7
07EE8:  MOVWF  x36
07EEA:  MOVLB  0
07EEC:  CALL   57BC
07EF0:  MOVLW  2C
07EF2:  MOVLB  7
07EF4:  MOVWF  x3F
07EF6:  MOVLB  0
07EF8:  CALL   561E
07EFC:  BRA    8064
07EFE:  MOVLB  6
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07F00:  MOVF   xFB,W
07F02:  SUBLW  34
07F04:  BNZ   7FAE
07F06:  MOVLW  04
07F08:  MOVLB  7
07F0A:  MOVWF  x31
07F0C:  MOVLW  BF
07F0E:  MOVWF  x30
07F10:  MOVLB  0
07F12:  CALL   55E6
07F16:  MOVF   01,W
07F18:  ADDLW  BF
07F1A:  MOVLB  7
07F1C:  MOVWF  x00
07F1E:  MOVLW  04
07F20:  ADDWFC 02,W
07F22:  MOVWF  x01
07F24:  MOVLW  01
07F26:  MOVLB  6
07F28:  SUBWF  xFA,W
07F2A:  MULLW  18
07F2C:  MOVF   FF3,W
07F2E:  MOVLB  7
07F30:  CLRF   x03
07F32:  MOVWF  x02
07F34:  MOVLW  10
07F36:  ADDWF  x02,W
07F38:  MOVWF  01
07F3A:  MOVLW  00
07F3C:  ADDWFC x03,W
07F3E:  MOVWF  03
07F40:  MOVF   01,W
07F42:  ADDLW  82
07F44:  MOVWF  FE9
07F46:  MOVLW  00
07F48:  ADDWFC 03,W
07F4A:  MOVWF  FEA
07F4C:  MOVFF  FEF,702
07F50:  MOVFF  FEC,703
07F54:  MOVFF  FEC,704
07F58:  MOVFF  FEC,705
07F5C:  MOVFF  701,563
07F60:  MOVFF  700,562
07F64:  MOVFF  6FA,729
07F68:  MOVLW  18
07F6A:  MOVWF  x2A
07F6C:  MOVLB  0
07F6E:  CALL   60C0
07F72:  MOVLW  2C
07F74:  MOVLB  7
07F76:  MOVWF  x3F
07F78:  MOVLB  0
07F7A:  CALL   561E
07F7E:  MOVLW  89
07F80:  MOVWF  FE9
07F82:  MOVFF  705,735
07F86:  MOVFF  704,734
07F8A:  MOVFF  703,733
07F8E:  MOVFF  702,732
07F92:  MOVLW  02
07F94:  MOVLB  7
07F96:  MOVWF  x36
07F98:  MOVLB  0
07F9A:  CALL   57BC
07F9E:  MOVLW  2C
07FA0:  MOVLB  7
07FA2:  MOVWF  x3F
07FA4:  MOVLB  0
07FA6:  CALL   561E
07FAA:  BRA    8064
07FAC:  MOVLB  6
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07FAE:  MOVF   xFB,W
07FB0:  SUBLW  35
07FB2:  BNZ   805C
07FB4:  MOVLW  04
07FB6:  MOVLB  7
07FB8:  MOVWF  x31
07FBA:  MOVLW  BF
07FBC:  MOVWF  x30
07FBE:  MOVLB  0
07FC0:  CALL   55E6
07FC4:  MOVF   01,W
07FC6:  ADDLW  BF
07FC8:  MOVLB  7
07FCA:  MOVWF  x00
07FCC:  MOVLW  04
07FCE:  ADDWFC 02,W
07FD0:  MOVWF  x01
07FD2:  MOVLW  01
07FD4:  MOVLB  6
07FD6:  SUBWF  xFA,W
07FD8:  MULLW  18
07FDA:  MOVF   FF3,W
07FDC:  MOVLB  7
07FDE:  CLRF   x03
07FE0:  MOVWF  x02
07FE2:  MOVLW  14
07FE4:  ADDWF  x02,W
07FE6:  MOVWF  01
07FE8:  MOVLW  00
07FEA:  ADDWFC x03,W
07FEC:  MOVWF  03
07FEE:  MOVF   01,W
07FF0:  ADDLW  82
07FF2:  MOVWF  FE9
07FF4:  MOVLW  00
07FF6:  ADDWFC 03,W
07FF8:  MOVWF  FEA
07FFA:  MOVFF  FEF,702
07FFE:  MOVFF  FEC,703
08002:  MOVFF  FEC,704
08006:  MOVFF  FEC,705
0800A:  MOVFF  701,563
0800E:  MOVFF  700,562
08012:  MOVFF  6FA,729
08016:  MOVLW  18
08018:  MOVWF  x2A
0801A:  MOVLB  0
0801C:  CALL   60C0
08020:  MOVLW  2C
08022:  MOVLB  7
08024:  MOVWF  x3F
08026:  MOVLB  0
08028:  CALL   561E
0802C:  MOVLW  89
0802E:  MOVWF  FE9
08030:  MOVFF  705,735
08034:  MOVFF  704,734
08038:  MOVFF  703,733
0803C:  MOVFF  702,732
08040:  MOVLW  02
08042:  MOVLB  7
08044:  MOVWF  x36
08046:  MOVLB  0
08048:  CALL   57BC
0804C:  MOVLW  2C
0804E:  MOVLB  7
08050:  MOVWF  x3F
08052:  MOVLB  0
08054:  CALL   561E
08058:  BRA    8064
0805A:  MOVLB  6
....................    else return INV_PARAM;
0805C:  MOVLW  02
0805E:  MOVWF  01
08060:  MOVLB  0
08062:  BRA    8068
....................    
....................    return SUCCESS;
08064:  MOVLW  00
08066:  MOVWF  01
08068:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0806A:  MOVLB  7
0806C:  CLRF   x31
0806E:  MOVFF  684,730
08072:  CLRF   x33
08074:  MOVLW  B5
08076:  MOVWF  x32
08078:  MOVLB  0
0807A:  CALL   0874
0807E:  MOVFF  02,701
08082:  MOVFF  01,700
08086:  MOVLW  06
08088:  MOVLB  7
0808A:  ADDWF  x00,F
0808C:  MOVLW  00
0808E:  ADDWFC x01,F
08090:  MOVLW  32
08092:  ADDWF  x00,W
08094:  MOVWF  01
08096:  MOVLW  00
08098:  ADDWFC x01,W
0809A:  MOVWF  03
0809C:  MOVF   01,W
0809E:  ADDLW  E9
080A0:  MOVWF  01
080A2:  MOVLW  01
080A4:  ADDWFC 03,F
080A6:  MOVFF  01,700
080AA:  MOVFF  03,701
080AE:  MOVFF  03,729
080B2:  MOVFF  01,728
080B6:  MOVLB  0
080B8:  CALL   5C7C
080BC:  MOVF   01,F
080BE:  BNZ   80C8
080C0:  MOVLW  02
080C2:  MOVWF  01
080C4:  BRA    8418
080C6:  BRA    8126
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
080C8:  MOVLB  7
080CA:  CLRF   x31
080CC:  MOVFF  684,730
080D0:  CLRF   x33
080D2:  MOVLW  B5
080D4:  MOVWF  x32
080D6:  MOVLB  0
080D8:  CALL   0874
080DC:  MOVFF  02,701
080E0:  MOVFF  01,700
080E4:  MOVLW  06
080E6:  MOVLB  7
080E8:  ADDWF  x00,F
080EA:  MOVLW  00
080EC:  ADDWFC x01,F
080EE:  MOVLW  32
080F0:  ADDWF  x00,W
080F2:  MOVWF  01
080F4:  MOVLW  00
080F6:  ADDWFC x01,W
080F8:  MOVWF  03
080FA:  MOVF   01,W
080FC:  ADDLW  E9
080FE:  MOVWF  01
08100:  MOVLW  01
08102:  ADDWFC 03,F
08104:  MOVFF  01,700
08108:  MOVFF  03,701
0810C:  MOVFF  03,729
08110:  MOVFF  01,728
08114:  CLRF   x2B
08116:  CLRF   x2A
08118:  MOVLW  0A
0811A:  MOVWF  x2C
0811C:  MOVLB  0
0811E:  CALL   5D6C
08122:  MOVFF  01,6FA
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
08126:  MOVLB  7
08128:  CLRF   x31
0812A:  MOVFF  684,730
0812E:  CLRF   x33
08130:  MOVLW  B5
08132:  MOVWF  x32
08134:  MOVLB  0
08136:  CALL   0874
0813A:  MOVFF  02,701
0813E:  MOVFF  01,700
08142:  MOVLW  06
08144:  MOVLB  7
08146:  ADDWF  x00,F
08148:  MOVLW  00
0814A:  ADDWFC x01,F
0814C:  MOVLW  4B
0814E:  ADDWF  x00,W
08150:  MOVWF  01
08152:  MOVLW  00
08154:  ADDWFC x01,W
08156:  MOVWF  03
08158:  MOVF   01,W
0815A:  ADDLW  E9
0815C:  MOVWF  01
0815E:  MOVLW  01
08160:  ADDWFC 03,F
08162:  MOVFF  01,700
08166:  MOVFF  03,701
0816A:  MOVFF  03,731
0816E:  MOVFF  01,730
08172:  MOVLB  0
08174:  CALL   55E6
08178:  MOVFF  02,03
0817C:  MOVF   01,W
0817E:  SUBLW  01
08180:  BNZ   8186
08182:  MOVF   03,F
08184:  BZ    818E
08186:  MOVLW  02
08188:  MOVWF  01
0818A:  BRA    8418
0818C:  BRA    81CE
....................    else arg2 = SERcmd[rec].p[3][0];
0818E:  MOVLB  7
08190:  CLRF   x31
08192:  MOVFF  684,730
08196:  CLRF   x33
08198:  MOVLW  B5
0819A:  MOVWF  x32
0819C:  MOVLB  0
0819E:  CALL   0874
081A2:  MOVFF  02,701
081A6:  MOVFF  01,700
081AA:  MOVLW  06
081AC:  MOVLB  7
081AE:  ADDWF  x00,F
081B0:  MOVLW  00
081B2:  ADDWFC x01,F
081B4:  MOVLW  4B
081B6:  ADDWF  x00,F
081B8:  MOVLW  00
081BA:  ADDWFC x01,F
081BC:  MOVLW  E9
081BE:  ADDWF  x00,W
081C0:  MOVWF  FE9
081C2:  MOVLW  01
081C4:  ADDWFC x01,W
081C6:  MOVWF  FEA
081C8:  MOVFF  FEF,6FB
081CC:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
081CE:  MOVLB  7
081D0:  CLRF   x31
081D2:  MOVFF  684,730
081D6:  CLRF   x33
081D8:  MOVLW  B5
081DA:  MOVWF  x32
081DC:  MOVLB  0
081DE:  CALL   0874
081E2:  MOVFF  02,701
081E6:  MOVFF  01,700
081EA:  MOVLW  06
081EC:  MOVLB  7
081EE:  ADDWF  x00,F
081F0:  MOVLW  00
081F2:  ADDWFC x01,F
081F4:  MOVLW  64
081F6:  ADDWF  x00,W
081F8:  MOVWF  01
081FA:  MOVLW  00
081FC:  ADDWFC x01,W
081FE:  MOVWF  03
08200:  MOVF   01,W
08202:  ADDLW  E9
08204:  MOVWF  01
08206:  MOVLW  01
08208:  ADDWFC 03,F
0820A:  MOVFF  01,700
0820E:  MOVFF  03,701
08212:  MOVFF  03,704
08216:  MOVFF  01,703
0821A:  MOVLB  0
0821C:  CALL   6DCE
08220:  MOVF   01,F
08222:  BNZ   822C
08224:  MOVLW  02
08226:  MOVWF  01
08228:  BRA    8418
0822A:  BRA    8292
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
0822C:  MOVLB  7
0822E:  CLRF   x31
08230:  MOVFF  684,730
08234:  CLRF   x33
08236:  MOVLW  B5
08238:  MOVWF  x32
0823A:  MOVLB  0
0823C:  CALL   0874
08240:  MOVFF  02,701
08244:  MOVFF  01,700
08248:  MOVLW  06
0824A:  MOVLB  7
0824C:  ADDWF  x00,F
0824E:  MOVLW  00
08250:  ADDWFC x01,F
08252:  MOVLW  64
08254:  ADDWF  x00,W
08256:  MOVWF  01
08258:  MOVLW  00
0825A:  ADDWFC x01,W
0825C:  MOVWF  03
0825E:  MOVF   01,W
08260:  ADDLW  E9
08262:  MOVWF  01
08264:  MOVLW  01
08266:  ADDWFC 03,F
08268:  MOVFF  01,700
0826C:  MOVFF  03,701
08270:  MOVFF  03,704
08274:  MOVFF  01,703
08278:  CLRF   x06
0827A:  CLRF   x05
0827C:  MOVLB  0
0827E:  CALL   6E90
08282:  MOVFF  03,6FF
08286:  MOVFF  02,6FE
0828A:  MOVFF  01,6FD
0828E:  MOVFF  00,6FC
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
08292:  MOVLB  6
08294:  MOVF   xFB,W
08296:  SUBLW  30
08298:  BNZ   82C8
0829A:  MOVLW  01
0829C:  SUBWF  xFA,W
0829E:  MULLW  18
082A0:  MOVF   FF3,W
082A2:  MOVLB  7
082A4:  CLRF   x01
082A6:  MOVWF  x00
082A8:  MOVLW  82
082AA:  ADDWF  x00,W
082AC:  MOVWF  FE9
082AE:  MOVLW  00
082B0:  ADDWFC x01,W
082B2:  MOVWF  FEA
082B4:  MOVFF  6FC,FEF
082B8:  MOVFF  6FD,FEC
082BC:  MOVFF  6FE,FEC
082C0:  MOVFF  6FF,FEC
082C4:  BRA    8412
082C6:  MOVLB  6
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
082C8:  MOVF   xFB,W
082CA:  SUBLW  31
082CC:  BNZ   8308
082CE:  MOVLW  01
082D0:  SUBWF  xFA,W
082D2:  MULLW  18
082D4:  MOVF   FF3,W
082D6:  MOVLB  7
082D8:  CLRF   x01
082DA:  MOVWF  x00
082DC:  MOVLW  04
082DE:  ADDWF  x00,W
082E0:  MOVWF  01
082E2:  MOVLW  00
082E4:  ADDWFC x01,W
082E6:  MOVWF  03
082E8:  MOVF   01,W
082EA:  ADDLW  82
082EC:  MOVWF  FE9
082EE:  MOVLW  00
082F0:  ADDWFC 03,W
082F2:  MOVWF  FEA
082F4:  MOVFF  6FC,FEF
082F8:  MOVFF  6FD,FEC
082FC:  MOVFF  6FE,FEC
08300:  MOVFF  6FF,FEC
08304:  BRA    8412
08306:  MOVLB  6
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08308:  MOVF   xFB,W
0830A:  SUBLW  32
0830C:  BNZ   8348
0830E:  MOVLW  01
08310:  SUBWF  xFA,W
08312:  MULLW  18
08314:  MOVF   FF3,W
08316:  MOVLB  7
08318:  CLRF   x01
0831A:  MOVWF  x00
0831C:  MOVLW  08
0831E:  ADDWF  x00,W
08320:  MOVWF  01
08322:  MOVLW  00
08324:  ADDWFC x01,W
08326:  MOVWF  03
08328:  MOVF   01,W
0832A:  ADDLW  82
0832C:  MOVWF  FE9
0832E:  MOVLW  00
08330:  ADDWFC 03,W
08332:  MOVWF  FEA
08334:  MOVFF  6FC,FEF
08338:  MOVFF  6FD,FEC
0833C:  MOVFF  6FE,FEC
08340:  MOVFF  6FF,FEC
08344:  BRA    8412
08346:  MOVLB  6
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
08348:  MOVF   xFB,W
0834A:  SUBLW  33
0834C:  BNZ   8388
0834E:  MOVLW  01
08350:  SUBWF  xFA,W
08352:  MULLW  18
08354:  MOVF   FF3,W
08356:  MOVLB  7
08358:  CLRF   x01
0835A:  MOVWF  x00
0835C:  MOVLW  0C
0835E:  ADDWF  x00,W
08360:  MOVWF  01
08362:  MOVLW  00
08364:  ADDWFC x01,W
08366:  MOVWF  03
08368:  MOVF   01,W
0836A:  ADDLW  82
0836C:  MOVWF  FE9
0836E:  MOVLW  00
08370:  ADDWFC 03,W
08372:  MOVWF  FEA
08374:  MOVFF  6FC,FEF
08378:  MOVFF  6FD,FEC
0837C:  MOVFF  6FE,FEC
08380:  MOVFF  6FF,FEC
08384:  BRA    8412
08386:  MOVLB  6
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08388:  MOVF   xFB,W
0838A:  SUBLW  34
0838C:  BNZ   83C8
0838E:  MOVLW  01
08390:  SUBWF  xFA,W
08392:  MULLW  18
08394:  MOVF   FF3,W
08396:  MOVLB  7
08398:  CLRF   x01
0839A:  MOVWF  x00
0839C:  MOVLW  10
0839E:  ADDWF  x00,W
083A0:  MOVWF  01
083A2:  MOVLW  00
083A4:  ADDWFC x01,W
083A6:  MOVWF  03
083A8:  MOVF   01,W
083AA:  ADDLW  82
083AC:  MOVWF  FE9
083AE:  MOVLW  00
083B0:  ADDWFC 03,W
083B2:  MOVWF  FEA
083B4:  MOVFF  6FC,FEF
083B8:  MOVFF  6FD,FEC
083BC:  MOVFF  6FE,FEC
083C0:  MOVFF  6FF,FEC
083C4:  BRA    8412
083C6:  MOVLB  6
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
083C8:  MOVF   xFB,W
083CA:  SUBLW  35
083CC:  BNZ   8408
083CE:  MOVLW  01
083D0:  SUBWF  xFA,W
083D2:  MULLW  18
083D4:  MOVF   FF3,W
083D6:  MOVLB  7
083D8:  CLRF   x01
083DA:  MOVWF  x00
083DC:  MOVLW  14
083DE:  ADDWF  x00,W
083E0:  MOVWF  01
083E2:  MOVLW  00
083E4:  ADDWFC x01,W
083E6:  MOVWF  03
083E8:  MOVF   01,W
083EA:  ADDLW  82
083EC:  MOVWF  FE9
083EE:  MOVLW  00
083F0:  ADDWFC 03,W
083F2:  MOVWF  FEA
083F4:  MOVFF  6FC,FEF
083F8:  MOVFF  6FD,FEC
083FC:  MOVFF  6FE,FEC
08400:  MOVFF  6FF,FEC
08404:  BRA    8412
08406:  MOVLB  6
....................    else return INV_PARAM;
08408:  MOVLW  02
0840A:  MOVWF  01
0840C:  MOVLB  0
0840E:  BRA    8418
08410:  MOVLB  7
....................    
....................    return SUCCESS;
08412:  MOVLW  00
08414:  MOVWF  01
08416:  MOVLB  0
08418:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
0841A:  MOVLW  4E
0841C:  MOVLB  6
0841E:  MOVWF  xFE
08420:  MOVLW  31
08422:  MOVWF  xFF
08424:  MOVLW  35
08426:  MOVLB  7
08428:  MOVWF  x00
0842A:  CLRF   x01
0842C:  MOVLW  06
0842E:  MOVLB  6
08430:  MOVWF  xFD
08432:  MOVLW  FE
08434:  MOVWF  xFC
....................    char *s_200 = "200";
08436:  MOVLW  32
08438:  MOVLB  7
0843A:  MOVWF  x04
0843C:  MOVLW  30
0843E:  MOVWF  x05
08440:  MOVWF  x06
08442:  CLRF   x07
08444:  MOVLW  07
08446:  MOVWF  x03
08448:  MOVLW  04
0844A:  MOVWF  x02
....................    char *s_5V6 = "5V6";
0844C:  MOVLW  35
0844E:  MOVWF  x0A
08450:  MOVLW  56
08452:  MOVWF  x0B
08454:  MOVLW  36
08456:  MOVWF  x0C
08458:  CLRF   x0D
0845A:  MOVLW  07
0845C:  MOVWF  x09
0845E:  MOVLW  0A
08460:  MOVWF  x08
....................    char *s_5VA = "5VA";
08462:  MOVLW  35
08464:  MOVWF  x10
08466:  MOVLW  56
08468:  MOVWF  x11
0846A:  MOVLW  41
0846C:  MOVWF  x12
0846E:  CLRF   x13
08470:  MOVLW  07
08472:  MOVWF  x0F
08474:  MOVLW  10
08476:  MOVWF  x0E
....................    char *s_3V6X = "3V6X";
08478:  MOVLW  33
0847A:  MOVWF  x16
0847C:  MOVLW  56
0847E:  MOVWF  x17
08480:  MOVLW  36
08482:  MOVWF  x18
08484:  MOVLW  58
08486:  MOVWF  x19
08488:  CLRF   x1A
0848A:  MOVLW  07
0848C:  MOVWF  x15
0848E:  MOVLW  16
08490:  MOVWF  x14
....................    char *s_3V3A = "3V3A";
08492:  MOVLW  33
08494:  MOVWF  x1D
08496:  MOVLW  56
08498:  MOVWF  x1E
0849A:  MOVLW  33
0849C:  MOVWF  x1F
0849E:  MOVLW  41
084A0:  MOVWF  x20
084A2:  CLRF   x21
084A4:  MOVLW  07
084A6:  MOVWF  x1C
084A8:  MOVLW  1D
084AA:  MOVWF  x1B
....................    char *s_3V3D = "3V3D";
084AC:  MOVLW  33
084AE:  MOVWF  x24
084B0:  MOVLW  56
084B2:  MOVWF  x25
084B4:  MOVLW  33
084B6:  MOVWF  x26
084B8:  MOVLW  44
084BA:  MOVWF  x27
084BC:  CLRF   x28
084BE:  MOVLW  07
084C0:  MOVWF  x23
084C2:  MOVLW  24
084C4:  MOVWF  x22
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
084C6:  CLRF   x31
084C8:  MOVFF  684,730
084CC:  CLRF   x33
084CE:  MOVLW  B5
084D0:  MOVWF  x32
084D2:  MOVLB  0
084D4:  CALL   0874
084D8:  MOVFF  02,72A
084DC:  MOVFF  01,729
084E0:  MOVLW  06
084E2:  MOVLB  7
084E4:  ADDWF  x29,F
084E6:  MOVLW  00
084E8:  ADDWFC x2A,F
084EA:  MOVLW  32
084EC:  ADDWF  x29,W
084EE:  MOVWF  01
084F0:  MOVLW  00
084F2:  ADDWFC x2A,W
084F4:  MOVWF  03
084F6:  MOVF   01,W
084F8:  ADDLW  E9
084FA:  MOVWF  01
084FC:  MOVLW  01
084FE:  ADDWFC 03,F
08500:  MOVFF  01,6FA
08504:  MOVLB  6
08506:  MOVFF  03,6FB
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0850A:  MOVFF  6FD,731
0850E:  MOVFF  6FC,730
08512:  MOVFF  6FB,733
08516:  MOVFF  6FA,732
0851A:  MOVLB  0
0851C:  CALL   5B5C
08520:  MOVF   01,F
08522:  BNZ   85A6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08524:  MOVLW  04
08526:  MOVLB  7
08528:  MOVWF  x31
0852A:  MOVLW  BF
0852C:  MOVWF  x30
0852E:  MOVLB  0
08530:  CALL   55E6
08534:  MOVFF  02,03
08538:  MOVF   01,W
0853A:  ADDLW  BF
0853C:  MOVLB  7
0853E:  MOVWF  x29
08540:  MOVLW  04
08542:  ADDWFC 02,W
08544:  MOVWF  x2A
08546:  MOVFF  FE8,563
0854A:  MOVFF  729,562
0854E:  MOVLW  89
08550:  MOVWF  FE9
08552:  MOVFF  B5,735
08556:  MOVFF  B4,734
0855A:  MOVFF  B3,733
0855E:  MOVFF  B2,732
08562:  MOVLW  02
08564:  MOVWF  x36
08566:  MOVLB  0
08568:  CALL   57BC
0856C:  MOVLW  2C
0856E:  MOVLB  7
08570:  MOVWF  x3F
08572:  MOVLB  0
08574:  CALL   561E
08578:  MOVLW  89
0857A:  MOVWF  FE9
0857C:  MOVFF  B9,735
08580:  MOVFF  B8,734
08584:  MOVFF  B7,733
08588:  MOVFF  B6,732
0858C:  MOVLW  02
0858E:  MOVLB  7
08590:  MOVWF  x36
08592:  MOVLB  0
08594:  CALL   57BC
08598:  MOVLW  2C
0859A:  MOVLB  7
0859C:  MOVWF  x3F
0859E:  MOVLB  0
085A0:  CALL   561E
....................    }
085A4:  BRA    8948
....................    else if (0 == strcmp(s_200, arg1)) {
085A6:  MOVFF  703,731
085AA:  MOVFF  702,730
085AE:  MOVFF  6FB,733
085B2:  MOVFF  6FA,732
085B6:  CALL   5B5C
085BA:  MOVF   01,F
085BC:  BNZ   8640
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
085BE:  MOVLW  04
085C0:  MOVLB  7
085C2:  MOVWF  x31
085C4:  MOVLW  BF
085C6:  MOVWF  x30
085C8:  MOVLB  0
085CA:  CALL   55E6
085CE:  MOVFF  02,03
085D2:  MOVF   01,W
085D4:  ADDLW  BF
085D6:  MOVLB  7
085D8:  MOVWF  x29
085DA:  MOVLW  04
085DC:  ADDWFC 02,W
085DE:  MOVWF  x2A
085E0:  MOVFF  FE8,563
085E4:  MOVFF  729,562
085E8:  MOVLW  89
085EA:  MOVWF  FE9
085EC:  MOVFF  BD,735
085F0:  MOVFF  BC,734
085F4:  MOVFF  BB,733
085F8:  MOVFF  BA,732
085FC:  MOVLW  02
085FE:  MOVWF  x36
08600:  MOVLB  0
08602:  CALL   57BC
08606:  MOVLW  2C
08608:  MOVLB  7
0860A:  MOVWF  x3F
0860C:  MOVLB  0
0860E:  CALL   561E
08612:  MOVLW  89
08614:  MOVWF  FE9
08616:  MOVFF  C1,735
0861A:  MOVFF  C0,734
0861E:  MOVFF  BF,733
08622:  MOVFF  BE,732
08626:  MOVLW  02
08628:  MOVLB  7
0862A:  MOVWF  x36
0862C:  MOVLB  0
0862E:  CALL   57BC
08632:  MOVLW  2C
08634:  MOVLB  7
08636:  MOVWF  x3F
08638:  MOVLB  0
0863A:  CALL   561E
....................    }
0863E:  BRA    8948
....................    else if (0 == strcmp(s_5V6, arg1)) {
08640:  MOVFF  709,731
08644:  MOVFF  708,730
08648:  MOVFF  6FB,733
0864C:  MOVFF  6FA,732
08650:  CALL   5B5C
08654:  MOVF   01,F
08656:  BNZ   86DA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08658:  MOVLW  04
0865A:  MOVLB  7
0865C:  MOVWF  x31
0865E:  MOVLW  BF
08660:  MOVWF  x30
08662:  MOVLB  0
08664:  CALL   55E6
08668:  MOVFF  02,03
0866C:  MOVF   01,W
0866E:  ADDLW  BF
08670:  MOVLB  7
08672:  MOVWF  x29
08674:  MOVLW  04
08676:  ADDWFC 02,W
08678:  MOVWF  x2A
0867A:  MOVFF  FE8,563
0867E:  MOVFF  729,562
08682:  MOVLW  89
08684:  MOVWF  FE9
08686:  MOVFF  C5,735
0868A:  MOVFF  C4,734
0868E:  MOVFF  C3,733
08692:  MOVFF  C2,732
08696:  MOVLW  02
08698:  MOVWF  x36
0869A:  MOVLB  0
0869C:  CALL   57BC
086A0:  MOVLW  2C
086A2:  MOVLB  7
086A4:  MOVWF  x3F
086A6:  MOVLB  0
086A8:  CALL   561E
086AC:  MOVLW  89
086AE:  MOVWF  FE9
086B0:  MOVFF  C9,735
086B4:  MOVFF  C8,734
086B8:  MOVFF  C7,733
086BC:  MOVFF  C6,732
086C0:  MOVLW  02
086C2:  MOVLB  7
086C4:  MOVWF  x36
086C6:  MOVLB  0
086C8:  CALL   57BC
086CC:  MOVLW  2C
086CE:  MOVLB  7
086D0:  MOVWF  x3F
086D2:  MOVLB  0
086D4:  CALL   561E
....................    }
086D8:  BRA    8948
....................    else if (0 == strcmp(s_5VA, arg1)) {
086DA:  MOVFF  70F,731
086DE:  MOVFF  70E,730
086E2:  MOVFF  6FB,733
086E6:  MOVFF  6FA,732
086EA:  CALL   5B5C
086EE:  MOVF   01,F
086F0:  BNZ   8774
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
086F2:  MOVLW  04
086F4:  MOVLB  7
086F6:  MOVWF  x31
086F8:  MOVLW  BF
086FA:  MOVWF  x30
086FC:  MOVLB  0
086FE:  CALL   55E6
08702:  MOVFF  02,03
08706:  MOVF   01,W
08708:  ADDLW  BF
0870A:  MOVLB  7
0870C:  MOVWF  x29
0870E:  MOVLW  04
08710:  ADDWFC 02,W
08712:  MOVWF  x2A
08714:  MOVFF  FE8,563
08718:  MOVFF  729,562
0871C:  MOVLW  89
0871E:  MOVWF  FE9
08720:  MOVFF  CD,735
08724:  MOVFF  CC,734
08728:  MOVFF  CB,733
0872C:  MOVFF  CA,732
08730:  MOVLW  02
08732:  MOVWF  x36
08734:  MOVLB  0
08736:  CALL   57BC
0873A:  MOVLW  2C
0873C:  MOVLB  7
0873E:  MOVWF  x3F
08740:  MOVLB  0
08742:  CALL   561E
08746:  MOVLW  89
08748:  MOVWF  FE9
0874A:  MOVFF  D1,735
0874E:  MOVFF  D0,734
08752:  MOVFF  CF,733
08756:  MOVFF  CE,732
0875A:  MOVLW  02
0875C:  MOVLB  7
0875E:  MOVWF  x36
08760:  MOVLB  0
08762:  CALL   57BC
08766:  MOVLW  2C
08768:  MOVLB  7
0876A:  MOVWF  x3F
0876C:  MOVLB  0
0876E:  CALL   561E
....................    }
08772:  BRA    8948
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08774:  MOVFF  715,731
08778:  MOVFF  714,730
0877C:  MOVFF  6FB,733
08780:  MOVFF  6FA,732
08784:  CALL   5B5C
08788:  MOVF   01,F
0878A:  BNZ   880E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
0878C:  MOVLW  04
0878E:  MOVLB  7
08790:  MOVWF  x31
08792:  MOVLW  BF
08794:  MOVWF  x30
08796:  MOVLB  0
08798:  CALL   55E6
0879C:  MOVFF  02,03
087A0:  MOVF   01,W
087A2:  ADDLW  BF
087A4:  MOVLB  7
087A6:  MOVWF  x29
087A8:  MOVLW  04
087AA:  ADDWFC 02,W
087AC:  MOVWF  x2A
087AE:  MOVFF  FE8,563
087B2:  MOVFF  729,562
087B6:  MOVLW  89
087B8:  MOVWF  FE9
087BA:  MOVFF  D5,735
087BE:  MOVFF  D4,734
087C2:  MOVFF  D3,733
087C6:  MOVFF  D2,732
087CA:  MOVLW  02
087CC:  MOVWF  x36
087CE:  MOVLB  0
087D0:  CALL   57BC
087D4:  MOVLW  2C
087D6:  MOVLB  7
087D8:  MOVWF  x3F
087DA:  MOVLB  0
087DC:  CALL   561E
087E0:  MOVLW  89
087E2:  MOVWF  FE9
087E4:  MOVFF  D9,735
087E8:  MOVFF  D8,734
087EC:  MOVFF  D7,733
087F0:  MOVFF  D6,732
087F4:  MOVLW  02
087F6:  MOVLB  7
087F8:  MOVWF  x36
087FA:  MOVLB  0
087FC:  CALL   57BC
08800:  MOVLW  2C
08802:  MOVLB  7
08804:  MOVWF  x3F
08806:  MOVLB  0
08808:  CALL   561E
....................    }
0880C:  BRA    8948
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0880E:  MOVFF  71C,731
08812:  MOVFF  71B,730
08816:  MOVFF  6FB,733
0881A:  MOVFF  6FA,732
0881E:  CALL   5B5C
08822:  MOVF   01,F
08824:  BNZ   88A8
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08826:  MOVLW  04
08828:  MOVLB  7
0882A:  MOVWF  x31
0882C:  MOVLW  BF
0882E:  MOVWF  x30
08830:  MOVLB  0
08832:  CALL   55E6
08836:  MOVFF  02,03
0883A:  MOVF   01,W
0883C:  ADDLW  BF
0883E:  MOVLB  7
08840:  MOVWF  x29
08842:  MOVLW  04
08844:  ADDWFC 02,W
08846:  MOVWF  x2A
08848:  MOVFF  FE8,563
0884C:  MOVFF  729,562
08850:  MOVLW  89
08852:  MOVWF  FE9
08854:  MOVFF  DD,735
08858:  MOVFF  DC,734
0885C:  MOVFF  DB,733
08860:  MOVFF  DA,732
08864:  MOVLW  02
08866:  MOVWF  x36
08868:  MOVLB  0
0886A:  CALL   57BC
0886E:  MOVLW  2C
08870:  MOVLB  7
08872:  MOVWF  x3F
08874:  MOVLB  0
08876:  CALL   561E
0887A:  MOVLW  89
0887C:  MOVWF  FE9
0887E:  MOVFF  E1,735
08882:  MOVFF  E0,734
08886:  MOVFF  DF,733
0888A:  MOVFF  DE,732
0888E:  MOVLW  02
08890:  MOVLB  7
08892:  MOVWF  x36
08894:  MOVLB  0
08896:  CALL   57BC
0889A:  MOVLW  2C
0889C:  MOVLB  7
0889E:  MOVWF  x3F
088A0:  MOVLB  0
088A2:  CALL   561E
....................    }
088A6:  BRA    8948
....................    else if (0 == strcmp(s_3V3D, arg1)) {
088A8:  MOVFF  723,731
088AC:  MOVFF  722,730
088B0:  MOVFF  6FB,733
088B4:  MOVFF  6FA,732
088B8:  CALL   5B5C
088BC:  MOVF   01,F
088BE:  BNZ   8942
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
088C0:  MOVLW  04
088C2:  MOVLB  7
088C4:  MOVWF  x31
088C6:  MOVLW  BF
088C8:  MOVWF  x30
088CA:  MOVLB  0
088CC:  CALL   55E6
088D0:  MOVFF  02,03
088D4:  MOVF   01,W
088D6:  ADDLW  BF
088D8:  MOVLB  7
088DA:  MOVWF  x29
088DC:  MOVLW  04
088DE:  ADDWFC 02,W
088E0:  MOVWF  x2A
088E2:  MOVFF  FE8,563
088E6:  MOVFF  729,562
088EA:  MOVLW  89
088EC:  MOVWF  FE9
088EE:  MOVFF  E5,735
088F2:  MOVFF  E4,734
088F6:  MOVFF  E3,733
088FA:  MOVFF  E2,732
088FE:  MOVLW  02
08900:  MOVWF  x36
08902:  MOVLB  0
08904:  CALL   57BC
08908:  MOVLW  2C
0890A:  MOVLB  7
0890C:  MOVWF  x3F
0890E:  MOVLB  0
08910:  CALL   561E
08914:  MOVLW  89
08916:  MOVWF  FE9
08918:  MOVFF  E9,735
0891C:  MOVFF  E8,734
08920:  MOVFF  E7,733
08924:  MOVFF  E6,732
08928:  MOVLW  02
0892A:  MOVLB  7
0892C:  MOVWF  x36
0892E:  MOVLB  0
08930:  CALL   57BC
08934:  MOVLW  2C
08936:  MOVLB  7
08938:  MOVWF  x3F
0893A:  MOVLB  0
0893C:  CALL   561E
....................    }
08940:  BRA    8948
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
08942:  MOVLW  02
08944:  MOVWF  01
08946:  BRA    894C
....................    
....................    return SUCCESS;
08948:  MOVLW  00
0894A:  MOVWF  01
0894C:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
0894E:  MOVLW  00
08950:  MOVWF  01
08952:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08954:  MOVLW  4E
08956:  MOVLB  6
08958:  MOVWF  xFE
0895A:  MOVLW  31
0895C:  MOVWF  xFF
0895E:  MOVLW  35
08960:  MOVLB  7
08962:  MOVWF  x00
08964:  CLRF   x01
08966:  MOVLW  06
08968:  MOVLB  6
0896A:  MOVWF  xFD
0896C:  MOVLW  FE
0896E:  MOVWF  xFC
....................    char *s_200 = "200";
08970:  MOVLW  32
08972:  MOVLB  7
08974:  MOVWF  x04
08976:  MOVLW  30
08978:  MOVWF  x05
0897A:  MOVWF  x06
0897C:  CLRF   x07
0897E:  MOVLW  07
08980:  MOVWF  x03
08982:  MOVLW  04
08984:  MOVWF  x02
....................    char *s_5V6 = "5V6";
08986:  MOVLW  35
08988:  MOVWF  x0A
0898A:  MOVLW  56
0898C:  MOVWF  x0B
0898E:  MOVLW  36
08990:  MOVWF  x0C
08992:  CLRF   x0D
08994:  MOVLW  07
08996:  MOVWF  x09
08998:  MOVLW  0A
0899A:  MOVWF  x08
....................    char *s_5VA = "5VA";
0899C:  MOVLW  35
0899E:  MOVWF  x10
089A0:  MOVLW  56
089A2:  MOVWF  x11
089A4:  MOVLW  41
089A6:  MOVWF  x12
089A8:  CLRF   x13
089AA:  MOVLW  07
089AC:  MOVWF  x0F
089AE:  MOVLW  10
089B0:  MOVWF  x0E
....................    char *s_3V6X = "3V6X";
089B2:  MOVLW  33
089B4:  MOVWF  x16
089B6:  MOVLW  56
089B8:  MOVWF  x17
089BA:  MOVLW  36
089BC:  MOVWF  x18
089BE:  MOVLW  58
089C0:  MOVWF  x19
089C2:  CLRF   x1A
089C4:  MOVLW  07
089C6:  MOVWF  x15
089C8:  MOVLW  16
089CA:  MOVWF  x14
....................    char *s_3V3A = "3V3A";
089CC:  MOVLW  33
089CE:  MOVWF  x1D
089D0:  MOVLW  56
089D2:  MOVWF  x1E
089D4:  MOVLW  33
089D6:  MOVWF  x1F
089D8:  MOVLW  41
089DA:  MOVWF  x20
089DC:  CLRF   x21
089DE:  MOVLW  07
089E0:  MOVWF  x1C
089E2:  MOVLW  1D
089E4:  MOVWF  x1B
....................    char *s_3V3D = "3V3D";
089E6:  MOVLW  33
089E8:  MOVWF  x24
089EA:  MOVLW  56
089EC:  MOVWF  x25
089EE:  MOVLW  33
089F0:  MOVWF  x26
089F2:  MOVLW  44
089F4:  MOVWF  x27
089F6:  CLRF   x28
089F8:  MOVLW  07
089FA:  MOVWF  x23
089FC:  MOVLW  24
089FE:  MOVWF  x22
....................    char *s_all = "all";
08A00:  MOVLW  61
08A02:  MOVWF  x2B
08A04:  MOVLW  6C
08A06:  MOVWF  x2C
08A08:  MOVWF  x2D
08A0A:  CLRF   x2E
08A0C:  MOVLW  07
08A0E:  MOVWF  x2A
08A10:  MOVLW  2B
08A12:  MOVWF  x29
....................    
....................    arg1 = SERcmd[rec].p[2];
08A14:  CLRF   x31
08A16:  MOVFF  684,730
08A1A:  CLRF   x33
08A1C:  MOVLW  B5
08A1E:  MOVWF  x32
08A20:  MOVLB  0
08A22:  CALL   0874
08A26:  MOVFF  02,730
08A2A:  MOVFF  01,72F
08A2E:  MOVLW  06
08A30:  MOVLB  7
08A32:  ADDWF  x2F,F
08A34:  MOVLW  00
08A36:  ADDWFC x30,F
08A38:  MOVLW  32
08A3A:  ADDWF  x2F,W
08A3C:  MOVWF  01
08A3E:  MOVLW  00
08A40:  ADDWFC x30,W
08A42:  MOVWF  03
08A44:  MOVF   01,W
08A46:  ADDLW  E9
08A48:  MOVWF  01
08A4A:  MOVLW  01
08A4C:  ADDWFC 03,F
08A4E:  MOVFF  01,6FA
08A52:  MOVLB  6
08A54:  MOVFF  03,6FB
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08A58:  MOVFF  6FD,731
08A5C:  MOVFF  6FC,730
08A60:  MOVFF  6FB,733
08A64:  MOVFF  6FA,732
08A68:  MOVLB  0
08A6A:  CALL   5B5C
08A6E:  MOVF   01,F
08A70:  BNZ   8AC8
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08A72:  MOVLW  04
08A74:  MOVLB  7
08A76:  MOVWF  x31
08A78:  MOVLW  BF
08A7A:  MOVWF  x30
08A7C:  MOVLB  0
08A7E:  CALL   55E6
08A82:  MOVFF  02,03
08A86:  MOVF   01,W
08A88:  ADDLW  BF
08A8A:  MOVLB  7
08A8C:  MOVWF  x2F
08A8E:  MOVLW  04
08A90:  ADDWFC 02,W
08A92:  MOVWF  x30
08A94:  MOVFF  FE8,563
08A98:  MOVFF  72F,562
08A9C:  MOVLW  89
08A9E:  MOVWF  FE9
08AA0:  MOVFF  EE,735
08AA4:  MOVFF  ED,734
08AA8:  MOVFF  EC,733
08AAC:  MOVFF  EB,732
08AB0:  MOVLW  02
08AB2:  MOVWF  x36
08AB4:  MOVLB  0
08AB6:  CALL   57BC
08ABA:  MOVLW  2C
08ABC:  MOVLB  7
08ABE:  MOVWF  x3F
08AC0:  MOVLB  0
08AC2:  CALL   561E
....................    }
08AC6:  BRA    8FCA
....................    else if (0 == strcmp(s_200, arg1)) {
08AC8:  MOVFF  703,731
08ACC:  MOVFF  702,730
08AD0:  MOVFF  6FB,733
08AD4:  MOVFF  6FA,732
08AD8:  CALL   5B5C
08ADC:  MOVF   01,F
08ADE:  BNZ   8B36
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08AE0:  MOVLW  04
08AE2:  MOVLB  7
08AE4:  MOVWF  x31
08AE6:  MOVLW  BF
08AE8:  MOVWF  x30
08AEA:  MOVLB  0
08AEC:  CALL   55E6
08AF0:  MOVFF  02,03
08AF4:  MOVF   01,W
08AF6:  ADDLW  BF
08AF8:  MOVLB  7
08AFA:  MOVWF  x2F
08AFC:  MOVLW  04
08AFE:  ADDWFC 02,W
08B00:  MOVWF  x30
08B02:  MOVFF  FE8,563
08B06:  MOVFF  72F,562
08B0A:  MOVLW  89
08B0C:  MOVWF  FE9
08B0E:  MOVFF  F2,735
08B12:  MOVFF  F1,734
08B16:  MOVFF  F0,733
08B1A:  MOVFF  EF,732
08B1E:  MOVLW  01
08B20:  MOVWF  x36
08B22:  MOVLB  0
08B24:  CALL   57BC
08B28:  MOVLW  2C
08B2A:  MOVLB  7
08B2C:  MOVWF  x3F
08B2E:  MOVLB  0
08B30:  CALL   561E
....................    }
08B34:  BRA    8FCA
....................    else if (0 == strcmp(s_5V6, arg1)) {
08B36:  MOVFF  709,731
08B3A:  MOVFF  708,730
08B3E:  MOVFF  6FB,733
08B42:  MOVFF  6FA,732
08B46:  CALL   5B5C
08B4A:  MOVF   01,F
08B4C:  BNZ   8BA4
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08B4E:  MOVLW  04
08B50:  MOVLB  7
08B52:  MOVWF  x31
08B54:  MOVLW  BF
08B56:  MOVWF  x30
08B58:  MOVLB  0
08B5A:  CALL   55E6
08B5E:  MOVFF  02,03
08B62:  MOVF   01,W
08B64:  ADDLW  BF
08B66:  MOVLB  7
08B68:  MOVWF  x2F
08B6A:  MOVLW  04
08B6C:  ADDWFC 02,W
08B6E:  MOVWF  x30
08B70:  MOVFF  FE8,563
08B74:  MOVFF  72F,562
08B78:  MOVLW  89
08B7A:  MOVWF  FE9
08B7C:  MOVFF  F6,735
08B80:  MOVFF  F5,734
08B84:  MOVFF  F4,733
08B88:  MOVFF  F3,732
08B8C:  MOVLW  03
08B8E:  MOVWF  x36
08B90:  MOVLB  0
08B92:  CALL   57BC
08B96:  MOVLW  2C
08B98:  MOVLB  7
08B9A:  MOVWF  x3F
08B9C:  MOVLB  0
08B9E:  CALL   561E
....................    }
08BA2:  BRA    8FCA
....................    else if (0 == strcmp(s_5VA, arg1)) {
08BA4:  MOVFF  70F,731
08BA8:  MOVFF  70E,730
08BAC:  MOVFF  6FB,733
08BB0:  MOVFF  6FA,732
08BB4:  CALL   5B5C
08BB8:  MOVF   01,F
08BBA:  BNZ   8C12
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08BBC:  MOVLW  04
08BBE:  MOVLB  7
08BC0:  MOVWF  x31
08BC2:  MOVLW  BF
08BC4:  MOVWF  x30
08BC6:  MOVLB  0
08BC8:  CALL   55E6
08BCC:  MOVFF  02,03
08BD0:  MOVF   01,W
08BD2:  ADDLW  BF
08BD4:  MOVLB  7
08BD6:  MOVWF  x2F
08BD8:  MOVLW  04
08BDA:  ADDWFC 02,W
08BDC:  MOVWF  x30
08BDE:  MOVFF  FE8,563
08BE2:  MOVFF  72F,562
08BE6:  MOVLW  89
08BE8:  MOVWF  FE9
08BEA:  MOVFF  FA,735
08BEE:  MOVFF  F9,734
08BF2:  MOVFF  F8,733
08BF6:  MOVFF  F7,732
08BFA:  MOVLW  03
08BFC:  MOVWF  x36
08BFE:  MOVLB  0
08C00:  CALL   57BC
08C04:  MOVLW  2C
08C06:  MOVLB  7
08C08:  MOVWF  x3F
08C0A:  MOVLB  0
08C0C:  CALL   561E
....................    }
08C10:  BRA    8FCA
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08C12:  MOVFF  715,731
08C16:  MOVFF  714,730
08C1A:  MOVFF  6FB,733
08C1E:  MOVFF  6FA,732
08C22:  CALL   5B5C
08C26:  MOVF   01,F
08C28:  BNZ   8C80
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08C2A:  MOVLW  04
08C2C:  MOVLB  7
08C2E:  MOVWF  x31
08C30:  MOVLW  BF
08C32:  MOVWF  x30
08C34:  MOVLB  0
08C36:  CALL   55E6
08C3A:  MOVFF  02,03
08C3E:  MOVF   01,W
08C40:  ADDLW  BF
08C42:  MOVLB  7
08C44:  MOVWF  x2F
08C46:  MOVLW  04
08C48:  ADDWFC 02,W
08C4A:  MOVWF  x30
08C4C:  MOVFF  FE8,563
08C50:  MOVFF  72F,562
08C54:  MOVLW  89
08C56:  MOVWF  FE9
08C58:  MOVFF  FE,735
08C5C:  MOVFF  FD,734
08C60:  MOVFF  FC,733
08C64:  MOVFF  FB,732
08C68:  MOVLW  03
08C6A:  MOVWF  x36
08C6C:  MOVLB  0
08C6E:  CALL   57BC
08C72:  MOVLW  2C
08C74:  MOVLB  7
08C76:  MOVWF  x3F
08C78:  MOVLB  0
08C7A:  CALL   561E
....................    }
08C7E:  BRA    8FCA
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08C80:  MOVFF  71C,731
08C84:  MOVFF  71B,730
08C88:  MOVFF  6FB,733
08C8C:  MOVFF  6FA,732
08C90:  CALL   5B5C
08C94:  MOVF   01,F
08C96:  BNZ   8CEE
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08C98:  MOVLW  04
08C9A:  MOVLB  7
08C9C:  MOVWF  x31
08C9E:  MOVLW  BF
08CA0:  MOVWF  x30
08CA2:  MOVLB  0
08CA4:  CALL   55E6
08CA8:  MOVFF  02,03
08CAC:  MOVF   01,W
08CAE:  ADDLW  BF
08CB0:  MOVLB  7
08CB2:  MOVWF  x2F
08CB4:  MOVLW  04
08CB6:  ADDWFC 02,W
08CB8:  MOVWF  x30
08CBA:  MOVFF  FE8,563
08CBE:  MOVFF  72F,562
08CC2:  MOVLW  89
08CC4:  MOVWF  FE9
08CC6:  MOVFF  102,735
08CCA:  MOVFF  101,734
08CCE:  MOVFF  100,733
08CD2:  MOVFF  FF,732
08CD6:  MOVLW  03
08CD8:  MOVWF  x36
08CDA:  MOVLB  0
08CDC:  CALL   57BC
08CE0:  MOVLW  2C
08CE2:  MOVLB  7
08CE4:  MOVWF  x3F
08CE6:  MOVLB  0
08CE8:  CALL   561E
....................    }
08CEC:  BRA    8FCA
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08CEE:  MOVFF  723,731
08CF2:  MOVFF  722,730
08CF6:  MOVFF  6FB,733
08CFA:  MOVFF  6FA,732
08CFE:  CALL   5B5C
08D02:  MOVF   01,F
08D04:  BNZ   8D5C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08D06:  MOVLW  04
08D08:  MOVLB  7
08D0A:  MOVWF  x31
08D0C:  MOVLW  BF
08D0E:  MOVWF  x30
08D10:  MOVLB  0
08D12:  CALL   55E6
08D16:  MOVFF  02,03
08D1A:  MOVF   01,W
08D1C:  ADDLW  BF
08D1E:  MOVLB  7
08D20:  MOVWF  x2F
08D22:  MOVLW  04
08D24:  ADDWFC 02,W
08D26:  MOVWF  x30
08D28:  MOVFF  FE8,563
08D2C:  MOVFF  72F,562
08D30:  MOVLW  89
08D32:  MOVWF  FE9
08D34:  MOVFF  106,735
08D38:  MOVFF  105,734
08D3C:  MOVFF  104,733
08D40:  MOVFF  103,732
08D44:  MOVLW  03
08D46:  MOVWF  x36
08D48:  MOVLB  0
08D4A:  CALL   57BC
08D4E:  MOVLW  2C
08D50:  MOVLB  7
08D52:  MOVWF  x3F
08D54:  MOVLB  0
08D56:  CALL   561E
....................    }
08D5A:  BRA    8FCA
....................    else if (0 == strcmp(s_all, arg1)) {
08D5C:  MOVFF  72A,731
08D60:  MOVFF  729,730
08D64:  MOVFF  6FB,733
08D68:  MOVFF  6FA,732
08D6C:  CALL   5B5C
08D70:  MOVF   01,F
08D72:  BTFSS  FD8.2
08D74:  BRA    8FC4
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08D76:  MOVLW  04
08D78:  MOVLB  7
08D7A:  MOVWF  x31
08D7C:  MOVLW  BF
08D7E:  MOVWF  x30
08D80:  MOVLB  0
08D82:  CALL   55E6
08D86:  MOVFF  02,03
08D8A:  MOVF   01,W
08D8C:  ADDLW  BF
08D8E:  MOVLB  7
08D90:  MOVWF  x2F
08D92:  MOVLW  04
08D94:  ADDWFC 02,W
08D96:  MOVWF  x30
08D98:  MOVFF  FE8,563
08D9C:  MOVFF  72F,562
08DA0:  MOVLW  89
08DA2:  MOVWF  FE9
08DA4:  MOVFF  EE,735
08DA8:  MOVFF  ED,734
08DAC:  MOVFF  EC,733
08DB0:  MOVFF  EB,732
08DB4:  MOVLW  02
08DB6:  MOVWF  x36
08DB8:  MOVLB  0
08DBA:  CALL   57BC
08DBE:  MOVLW  2C
08DC0:  MOVLB  7
08DC2:  MOVWF  x3F
08DC4:  MOVLB  0
08DC6:  CALL   561E
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08DCA:  MOVLW  04
08DCC:  MOVLB  7
08DCE:  MOVWF  x31
08DD0:  MOVLW  BF
08DD2:  MOVWF  x30
08DD4:  MOVLB  0
08DD6:  CALL   55E6
08DDA:  MOVFF  02,03
08DDE:  MOVF   01,W
08DE0:  ADDLW  BF
08DE2:  MOVLB  7
08DE4:  MOVWF  x2F
08DE6:  MOVLW  04
08DE8:  ADDWFC 02,W
08DEA:  MOVWF  x30
08DEC:  MOVFF  FE8,563
08DF0:  MOVFF  72F,562
08DF4:  MOVLW  89
08DF6:  MOVWF  FE9
08DF8:  MOVFF  F2,735
08DFC:  MOVFF  F1,734
08E00:  MOVFF  F0,733
08E04:  MOVFF  EF,732
08E08:  MOVLW  01
08E0A:  MOVWF  x36
08E0C:  MOVLB  0
08E0E:  CALL   57BC
08E12:  MOVLW  2C
08E14:  MOVLB  7
08E16:  MOVWF  x3F
08E18:  MOVLB  0
08E1A:  CALL   561E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08E1E:  MOVLW  04
08E20:  MOVLB  7
08E22:  MOVWF  x31
08E24:  MOVLW  BF
08E26:  MOVWF  x30
08E28:  MOVLB  0
08E2A:  CALL   55E6
08E2E:  MOVFF  02,03
08E32:  MOVF   01,W
08E34:  ADDLW  BF
08E36:  MOVLB  7
08E38:  MOVWF  x2F
08E3A:  MOVLW  04
08E3C:  ADDWFC 02,W
08E3E:  MOVWF  x30
08E40:  MOVFF  FE8,563
08E44:  MOVFF  72F,562
08E48:  MOVLW  89
08E4A:  MOVWF  FE9
08E4C:  MOVFF  F6,735
08E50:  MOVFF  F5,734
08E54:  MOVFF  F4,733
08E58:  MOVFF  F3,732
08E5C:  MOVLW  03
08E5E:  MOVWF  x36
08E60:  MOVLB  0
08E62:  CALL   57BC
08E66:  MOVLW  2C
08E68:  MOVLB  7
08E6A:  MOVWF  x3F
08E6C:  MOVLB  0
08E6E:  CALL   561E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08E72:  MOVLW  04
08E74:  MOVLB  7
08E76:  MOVWF  x31
08E78:  MOVLW  BF
08E7A:  MOVWF  x30
08E7C:  MOVLB  0
08E7E:  CALL   55E6
08E82:  MOVFF  02,03
08E86:  MOVF   01,W
08E88:  ADDLW  BF
08E8A:  MOVLB  7
08E8C:  MOVWF  x2F
08E8E:  MOVLW  04
08E90:  ADDWFC 02,W
08E92:  MOVWF  x30
08E94:  MOVFF  FE8,563
08E98:  MOVFF  72F,562
08E9C:  MOVLW  89
08E9E:  MOVWF  FE9
08EA0:  MOVFF  FA,735
08EA4:  MOVFF  F9,734
08EA8:  MOVFF  F8,733
08EAC:  MOVFF  F7,732
08EB0:  MOVLW  03
08EB2:  MOVWF  x36
08EB4:  MOVLB  0
08EB6:  CALL   57BC
08EBA:  MOVLW  2C
08EBC:  MOVLB  7
08EBE:  MOVWF  x3F
08EC0:  MOVLB  0
08EC2:  CALL   561E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08EC6:  MOVLW  04
08EC8:  MOVLB  7
08ECA:  MOVWF  x31
08ECC:  MOVLW  BF
08ECE:  MOVWF  x30
08ED0:  MOVLB  0
08ED2:  CALL   55E6
08ED6:  MOVFF  02,03
08EDA:  MOVF   01,W
08EDC:  ADDLW  BF
08EDE:  MOVLB  7
08EE0:  MOVWF  x2F
08EE2:  MOVLW  04
08EE4:  ADDWFC 02,W
08EE6:  MOVWF  x30
08EE8:  MOVFF  FE8,563
08EEC:  MOVFF  72F,562
08EF0:  MOVLW  89
08EF2:  MOVWF  FE9
08EF4:  MOVFF  FE,735
08EF8:  MOVFF  FD,734
08EFC:  MOVFF  FC,733
08F00:  MOVFF  FB,732
08F04:  MOVLW  03
08F06:  MOVWF  x36
08F08:  MOVLB  0
08F0A:  CALL   57BC
08F0E:  MOVLW  2C
08F10:  MOVLB  7
08F12:  MOVWF  x3F
08F14:  MOVLB  0
08F16:  CALL   561E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08F1A:  MOVLW  04
08F1C:  MOVLB  7
08F1E:  MOVWF  x31
08F20:  MOVLW  BF
08F22:  MOVWF  x30
08F24:  MOVLB  0
08F26:  CALL   55E6
08F2A:  MOVFF  02,03
08F2E:  MOVF   01,W
08F30:  ADDLW  BF
08F32:  MOVLB  7
08F34:  MOVWF  x2F
08F36:  MOVLW  04
08F38:  ADDWFC 02,W
08F3A:  MOVWF  x30
08F3C:  MOVFF  FE8,563
08F40:  MOVFF  72F,562
08F44:  MOVLW  89
08F46:  MOVWF  FE9
08F48:  MOVFF  102,735
08F4C:  MOVFF  101,734
08F50:  MOVFF  100,733
08F54:  MOVFF  FF,732
08F58:  MOVLW  03
08F5A:  MOVWF  x36
08F5C:  MOVLB  0
08F5E:  CALL   57BC
08F62:  MOVLW  2C
08F64:  MOVLB  7
08F66:  MOVWF  x3F
08F68:  MOVLB  0
08F6A:  CALL   561E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08F6E:  MOVLW  04
08F70:  MOVLB  7
08F72:  MOVWF  x31
08F74:  MOVLW  BF
08F76:  MOVWF  x30
08F78:  MOVLB  0
08F7A:  CALL   55E6
08F7E:  MOVFF  02,03
08F82:  MOVF   01,W
08F84:  ADDLW  BF
08F86:  MOVLB  7
08F88:  MOVWF  x2F
08F8A:  MOVLW  04
08F8C:  ADDWFC 02,W
08F8E:  MOVWF  x30
08F90:  MOVFF  FE8,563
08F94:  MOVFF  72F,562
08F98:  MOVLW  89
08F9A:  MOVWF  FE9
08F9C:  MOVFF  106,735
08FA0:  MOVFF  105,734
08FA4:  MOVFF  104,733
08FA8:  MOVFF  103,732
08FAC:  MOVLW  03
08FAE:  MOVWF  x36
08FB0:  MOVLB  0
08FB2:  CALL   57BC
08FB6:  MOVLW  2C
08FB8:  MOVLB  7
08FBA:  MOVWF  x3F
08FBC:  MOVLB  0
08FBE:  CALL   561E
....................    }
08FC2:  BRA    8FCA
....................    else return INV_PARAM;
08FC4:  MOVLW  02
08FC6:  MOVWF  01
08FC8:  BRA    8FCE
....................    
....................    return SUCCESS;
08FCA:  MOVLW  00
08FCC:  MOVWF  01
08FCE:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08FD0:  MOVLW  50
08FD2:  MOVLB  6
08FD4:  MOVWF  xFF
08FD6:  MOVLW  56
08FD8:  MOVLB  7
08FDA:  MOVWF  x00
08FDC:  CLRF   x01
08FDE:  MOVLW  06
08FE0:  MOVLB  6
08FE2:  MOVWF  xFE
08FE4:  SETF   xFD
....................    char *s_CV = "CV";
08FE6:  MOVLW  43
08FE8:  MOVLB  7
08FEA:  MOVWF  x04
08FEC:  MOVLW  56
08FEE:  MOVWF  x05
08FF0:  CLRF   x06
08FF2:  MOVLW  07
08FF4:  MOVWF  x03
08FF6:  MOVLW  04
08FF8:  MOVWF  x02
....................    char *s_PVold = "PVold";
08FFA:  MOVLW  50
08FFC:  MOVWF  x09
08FFE:  MOVLW  56
09000:  MOVWF  x0A
09002:  MOVLW  6F
09004:  MOVWF  x0B
09006:  MOVLW  6C
09008:  MOVWF  x0C
0900A:  MOVLW  64
0900C:  MOVWF  x0D
0900E:  CLRF   x0E
09010:  MOVLW  07
09012:  MOVWF  x08
09014:  MOVLW  09
09016:  MOVWF  x07
....................    char *s_I = "I";
09018:  MOVLW  49
0901A:  MOVWF  x11
0901C:  CLRF   x12
0901E:  MOVLW  07
09020:  MOVWF  x10
09022:  MOVLW  11
09024:  MOVWF  x0F
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09026:  CLRF   x31
09028:  MOVFF  684,730
0902C:  CLRF   x33
0902E:  MOVLW  B5
09030:  MOVWF  x32
09032:  MOVLB  0
09034:  CALL   0874
09038:  MOVFF  02,714
0903C:  MOVFF  01,713
09040:  MOVLW  06
09042:  MOVLB  7
09044:  ADDWF  x13,F
09046:  MOVLW  00
09048:  ADDWFC x14,F
0904A:  MOVLW  32
0904C:  ADDWF  x13,W
0904E:  MOVWF  01
09050:  MOVLW  00
09052:  ADDWFC x14,W
09054:  MOVWF  03
09056:  MOVF   01,W
09058:  ADDLW  E9
0905A:  MOVWF  01
0905C:  MOVLW  01
0905E:  ADDWFC 03,F
09060:  MOVFF  01,713
09064:  MOVFF  03,714
09068:  MOVFF  03,729
0906C:  MOVFF  01,728
09070:  MOVLB  0
09072:  CALL   5C7C
09076:  MOVF   01,F
09078:  BNZ   9082
0907A:  MOVLW  02
0907C:  MOVWF  01
0907E:  BRA    942A
09080:  BRA    90E0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09082:  MOVLB  7
09084:  CLRF   x31
09086:  MOVFF  684,730
0908A:  CLRF   x33
0908C:  MOVLW  B5
0908E:  MOVWF  x32
09090:  MOVLB  0
09092:  CALL   0874
09096:  MOVFF  02,714
0909A:  MOVFF  01,713
0909E:  MOVLW  06
090A0:  MOVLB  7
090A2:  ADDWF  x13,F
090A4:  MOVLW  00
090A6:  ADDWFC x14,F
090A8:  MOVLW  32
090AA:  ADDWF  x13,W
090AC:  MOVWF  01
090AE:  MOVLW  00
090B0:  ADDWFC x14,W
090B2:  MOVWF  03
090B4:  MOVF   01,W
090B6:  ADDLW  E9
090B8:  MOVWF  01
090BA:  MOVLW  01
090BC:  ADDWFC 03,F
090BE:  MOVFF  01,713
090C2:  MOVFF  03,714
090C6:  MOVFF  03,729
090CA:  MOVFF  01,728
090CE:  CLRF   x2B
090D0:  CLRF   x2A
090D2:  MOVLW  0A
090D4:  MOVWF  x2C
090D6:  MOVLB  0
090D8:  CALL   5D6C
090DC:  MOVFF  01,6FA
....................    
....................    arg2 = SERcmd[rec].p[3];
090E0:  MOVLB  7
090E2:  CLRF   x31
090E4:  MOVFF  684,730
090E8:  CLRF   x33
090EA:  MOVLW  B5
090EC:  MOVWF  x32
090EE:  MOVLB  0
090F0:  CALL   0874
090F4:  MOVFF  02,714
090F8:  MOVFF  01,713
090FC:  MOVLW  06
090FE:  MOVLB  7
09100:  ADDWF  x13,F
09102:  MOVLW  00
09104:  ADDWFC x14,F
09106:  MOVLW  4B
09108:  ADDWF  x13,W
0910A:  MOVWF  01
0910C:  MOVLW  00
0910E:  ADDWFC x14,W
09110:  MOVWF  03
09112:  MOVF   01,W
09114:  ADDLW  E9
09116:  MOVWF  01
09118:  MOVLW  01
0911A:  ADDWFC 03,F
0911C:  MOVFF  01,6FB
09120:  MOVLB  6
09122:  MOVFF  03,6FC
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
09126:  MOVFF  6FE,731
0912A:  MOVFF  6FD,730
0912E:  MOVFF  6FC,733
09132:  MOVFF  6FB,732
09136:  MOVLB  0
09138:  CALL   5B5C
0913C:  MOVF   01,F
0913E:  BNZ   91E6
09140:  MOVLW  04
09142:  MOVLB  7
09144:  MOVWF  x31
09146:  MOVLW  BF
09148:  MOVWF  x30
0914A:  MOVLB  0
0914C:  CALL   55E6
09150:  MOVF   01,W
09152:  ADDLW  BF
09154:  MOVLB  7
09156:  MOVWF  x13
09158:  MOVLW  04
0915A:  ADDWFC 02,W
0915C:  MOVWF  x14
0915E:  MOVLW  01
09160:  MOVLB  6
09162:  SUBWF  xFA,W
09164:  MULLW  20
09166:  MOVF   FF3,W
09168:  MOVLB  7
0916A:  CLRF   x16
0916C:  MOVWF  x15
0916E:  MOVLW  10
09170:  ADDWF  x15,W
09172:  MOVWF  01
09174:  MOVLW  00
09176:  ADDWFC x16,W
09178:  MOVWF  03
0917A:  MOVF   01,W
0917C:  ADDLW  20
0917E:  MOVWF  FE9
09180:  MOVLW  00
09182:  ADDWFC 03,W
09184:  MOVWF  FEA
09186:  MOVFF  FEF,715
0918A:  MOVFF  FEC,716
0918E:  MOVFF  FEC,717
09192:  MOVFF  FEC,718
09196:  MOVFF  714,563
0919A:  MOVFF  713,562
0919E:  MOVFF  6FA,729
091A2:  MOVLW  18
091A4:  MOVWF  x2A
091A6:  MOVLB  0
091A8:  CALL   60C0
091AC:  MOVLW  2C
091AE:  MOVLB  7
091B0:  MOVWF  x3F
091B2:  MOVLB  0
091B4:  CALL   561E
091B8:  MOVLW  89
091BA:  MOVWF  FE9
091BC:  MOVFF  718,735
091C0:  MOVFF  717,734
091C4:  MOVFF  716,733
091C8:  MOVFF  715,732
091CC:  MOVLW  02
091CE:  MOVLB  7
091D0:  MOVWF  x36
091D2:  MOVLB  0
091D4:  CALL   57BC
091D8:  MOVLW  2C
091DA:  MOVLB  7
091DC:  MOVWF  x3F
091DE:  MOVLB  0
091E0:  CALL   561E
091E4:  BRA    9426
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
091E6:  MOVFF  703,731
091EA:  MOVFF  702,730
091EE:  MOVFF  6FC,733
091F2:  MOVFF  6FB,732
091F6:  CALL   5B5C
091FA:  MOVF   01,F
091FC:  BNZ   92A4
091FE:  MOVLW  04
09200:  MOVLB  7
09202:  MOVWF  x31
09204:  MOVLW  BF
09206:  MOVWF  x30
09208:  MOVLB  0
0920A:  CALL   55E6
0920E:  MOVF   01,W
09210:  ADDLW  BF
09212:  MOVLB  7
09214:  MOVWF  x13
09216:  MOVLW  04
09218:  ADDWFC 02,W
0921A:  MOVWF  x14
0921C:  MOVLW  01
0921E:  MOVLB  6
09220:  SUBWF  xFA,W
09222:  MULLW  20
09224:  MOVF   FF3,W
09226:  MOVLB  7
09228:  CLRF   x16
0922A:  MOVWF  x15
0922C:  MOVLW  18
0922E:  ADDWF  x15,W
09230:  MOVWF  01
09232:  MOVLW  00
09234:  ADDWFC x16,W
09236:  MOVWF  03
09238:  MOVF   01,W
0923A:  ADDLW  20
0923C:  MOVWF  FE9
0923E:  MOVLW  00
09240:  ADDWFC 03,W
09242:  MOVWF  FEA
09244:  MOVFF  FEF,715
09248:  MOVFF  FEC,716
0924C:  MOVFF  FEC,717
09250:  MOVFF  FEC,718
09254:  MOVFF  714,563
09258:  MOVFF  713,562
0925C:  MOVFF  6FA,729
09260:  MOVLW  18
09262:  MOVWF  x2A
09264:  MOVLB  0
09266:  CALL   60C0
0926A:  MOVLW  2C
0926C:  MOVLB  7
0926E:  MOVWF  x3F
09270:  MOVLB  0
09272:  CALL   561E
09276:  MOVLW  89
09278:  MOVWF  FE9
0927A:  MOVFF  718,735
0927E:  MOVFF  717,734
09282:  MOVFF  716,733
09286:  MOVFF  715,732
0928A:  MOVLW  02
0928C:  MOVLB  7
0928E:  MOVWF  x36
09290:  MOVLB  0
09292:  CALL   57BC
09296:  MOVLW  2C
09298:  MOVLB  7
0929A:  MOVWF  x3F
0929C:  MOVLB  0
0929E:  CALL   561E
092A2:  BRA    9426
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
092A4:  MOVFF  708,731
092A8:  MOVFF  707,730
092AC:  MOVFF  6FC,733
092B0:  MOVFF  6FB,732
092B4:  CALL   5B5C
092B8:  MOVF   01,F
092BA:  BNZ   9362
092BC:  MOVLW  04
092BE:  MOVLB  7
092C0:  MOVWF  x31
092C2:  MOVLW  BF
092C4:  MOVWF  x30
092C6:  MOVLB  0
092C8:  CALL   55E6
092CC:  MOVF   01,W
092CE:  ADDLW  BF
092D0:  MOVLB  7
092D2:  MOVWF  x13
092D4:  MOVLW  04
092D6:  ADDWFC 02,W
092D8:  MOVWF  x14
092DA:  MOVLW  01
092DC:  MOVLB  6
092DE:  SUBWF  xFA,W
092E0:  MULLW  20
092E2:  MOVF   FF3,W
092E4:  MOVLB  7
092E6:  CLRF   x16
092E8:  MOVWF  x15
092EA:  MOVLW  14
092EC:  ADDWF  x15,W
092EE:  MOVWF  01
092F0:  MOVLW  00
092F2:  ADDWFC x16,W
092F4:  MOVWF  03
092F6:  MOVF   01,W
092F8:  ADDLW  20
092FA:  MOVWF  FE9
092FC:  MOVLW  00
092FE:  ADDWFC 03,W
09300:  MOVWF  FEA
09302:  MOVFF  FEF,715
09306:  MOVFF  FEC,716
0930A:  MOVFF  FEC,717
0930E:  MOVFF  FEC,718
09312:  MOVFF  714,563
09316:  MOVFF  713,562
0931A:  MOVFF  6FA,729
0931E:  MOVLW  18
09320:  MOVWF  x2A
09322:  MOVLB  0
09324:  CALL   60C0
09328:  MOVLW  2C
0932A:  MOVLB  7
0932C:  MOVWF  x3F
0932E:  MOVLB  0
09330:  CALL   561E
09334:  MOVLW  89
09336:  MOVWF  FE9
09338:  MOVFF  718,735
0933C:  MOVFF  717,734
09340:  MOVFF  716,733
09344:  MOVFF  715,732
09348:  MOVLW  02
0934A:  MOVLB  7
0934C:  MOVWF  x36
0934E:  MOVLB  0
09350:  CALL   57BC
09354:  MOVLW  2C
09356:  MOVLB  7
09358:  MOVWF  x3F
0935A:  MOVLB  0
0935C:  CALL   561E
09360:  BRA    9426
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09362:  MOVFF  710,731
09366:  MOVFF  70F,730
0936A:  MOVFF  6FC,733
0936E:  MOVFF  6FB,732
09372:  CALL   5B5C
09376:  MOVF   01,F
09378:  BNZ   9420
0937A:  MOVLW  04
0937C:  MOVLB  7
0937E:  MOVWF  x31
09380:  MOVLW  BF
09382:  MOVWF  x30
09384:  MOVLB  0
09386:  CALL   55E6
0938A:  MOVF   01,W
0938C:  ADDLW  BF
0938E:  MOVLB  7
09390:  MOVWF  x13
09392:  MOVLW  04
09394:  ADDWFC 02,W
09396:  MOVWF  x14
09398:  MOVLW  01
0939A:  MOVLB  6
0939C:  SUBWF  xFA,W
0939E:  MULLW  20
093A0:  MOVF   FF3,W
093A2:  MOVLB  7
093A4:  CLRF   x16
093A6:  MOVWF  x15
093A8:  MOVLW  1C
093AA:  ADDWF  x15,W
093AC:  MOVWF  01
093AE:  MOVLW  00
093B0:  ADDWFC x16,W
093B2:  MOVWF  03
093B4:  MOVF   01,W
093B6:  ADDLW  20
093B8:  MOVWF  FE9
093BA:  MOVLW  00
093BC:  ADDWFC 03,W
093BE:  MOVWF  FEA
093C0:  MOVFF  FEF,715
093C4:  MOVFF  FEC,716
093C8:  MOVFF  FEC,717
093CC:  MOVFF  FEC,718
093D0:  MOVFF  714,563
093D4:  MOVFF  713,562
093D8:  MOVFF  6FA,729
093DC:  MOVLW  18
093DE:  MOVWF  x2A
093E0:  MOVLB  0
093E2:  CALL   60C0
093E6:  MOVLW  2C
093E8:  MOVLB  7
093EA:  MOVWF  x3F
093EC:  MOVLB  0
093EE:  CALL   561E
093F2:  MOVLW  89
093F4:  MOVWF  FE9
093F6:  MOVFF  718,735
093FA:  MOVFF  717,734
093FE:  MOVFF  716,733
09402:  MOVFF  715,732
09406:  MOVLW  02
09408:  MOVLB  7
0940A:  MOVWF  x36
0940C:  MOVLB  0
0940E:  CALL   57BC
09412:  MOVLW  2C
09414:  MOVLB  7
09416:  MOVWF  x3F
09418:  MOVLB  0
0941A:  CALL   561E
0941E:  BRA    9426
....................    else return INV_PARAM;
09420:  MOVLW  02
09422:  MOVWF  01
09424:  BRA    942A
....................    
....................    return SUCCESS;
09426:  MOVLW  00
09428:  MOVWF  01
0942A:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
0954A:  MOVLW  72
0954C:  MOVLB  6
0954E:  MOVWF  xFF
09550:  MOVLW  61
09552:  MOVLB  7
09554:  MOVWF  x00
09556:  MOVLW  77
09558:  MOVWF  x01
0955A:  CLRF   x02
0955C:  MOVLW  06
0955E:  MOVLB  6
09560:  MOVWF  xFE
09562:  SETF   xFD
....................    char *s_calibrated = "calib";
09564:  MOVLW  63
09566:  MOVLB  7
09568:  MOVWF  x05
0956A:  MOVLW  61
0956C:  MOVWF  x06
0956E:  MOVLW  6C
09570:  MOVWF  x07
09572:  MOVLW  69
09574:  MOVWF  x08
09576:  MOVLW  62
09578:  MOVWF  x09
0957A:  CLRF   x0A
0957C:  MOVLW  07
0957E:  MOVWF  x04
09580:  MOVLW  05
09582:  MOVWF  x03
....................    char *s_p0 = "p0";
09584:  MOVLW  70
09586:  MOVWF  x0D
09588:  MOVLW  30
0958A:  MOVWF  x0E
0958C:  CLRF   x0F
0958E:  MOVLW  07
09590:  MOVWF  x0C
09592:  MOVLW  0D
09594:  MOVWF  x0B
....................    char *s_poles = "poles";
09596:  MOVLW  70
09598:  MOVWF  x12
0959A:  MOVLW  6F
0959C:  MOVWF  x13
0959E:  MOVLW  6C
095A0:  MOVWF  x14
095A2:  MOVLW  65
095A4:  MOVWF  x15
095A6:  MOVLW  73
095A8:  MOVWF  x16
095AA:  CLRF   x17
095AC:  MOVLW  07
095AE:  MOVWF  x11
095B0:  MOVLW  12
095B2:  MOVWF  x10
....................    char *s_real = "real";
095B4:  MOVLW  72
095B6:  MOVWF  x1A
095B8:  MOVLW  65
095BA:  MOVWF  x1B
095BC:  MOVLW  61
095BE:  MOVWF  x1C
095C0:  MOVLW  6C
095C2:  MOVWF  x1D
095C4:  CLRF   x1E
095C6:  MOVLW  07
095C8:  MOVWF  x19
095CA:  MOVLW  1A
095CC:  MOVWF  x18
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
095CE:  CLRF   x31
095D0:  MOVFF  684,730
095D4:  CLRF   x33
095D6:  MOVLW  B5
095D8:  MOVWF  x32
095DA:  MOVLB  0
095DC:  CALL   0874
095E0:  MOVFF  02,720
095E4:  MOVFF  01,71F
095E8:  MOVLW  06
095EA:  MOVLB  7
095EC:  ADDWF  x1F,F
095EE:  MOVLW  00
095F0:  ADDWFC x20,F
095F2:  MOVLW  32
095F4:  ADDWF  x1F,W
095F6:  MOVWF  01
095F8:  MOVLW  00
095FA:  ADDWFC x20,W
095FC:  MOVWF  03
095FE:  MOVF   01,W
09600:  ADDLW  E9
09602:  MOVWF  01
09604:  MOVLW  01
09606:  ADDWFC 03,F
09608:  MOVFF  01,71F
0960C:  MOVFF  03,720
09610:  MOVFF  03,729
09614:  MOVFF  01,728
09618:  MOVLB  0
0961A:  CALL   5C7C
0961E:  MOVF   01,F
09620:  BNZ   962A
09622:  MOVLW  02
09624:  MOVWF  01
09626:  BRA    9C8C
09628:  BRA    9688
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0962A:  MOVLB  7
0962C:  CLRF   x31
0962E:  MOVFF  684,730
09632:  CLRF   x33
09634:  MOVLW  B5
09636:  MOVWF  x32
09638:  MOVLB  0
0963A:  CALL   0874
0963E:  MOVFF  02,720
09642:  MOVFF  01,71F
09646:  MOVLW  06
09648:  MOVLB  7
0964A:  ADDWF  x1F,F
0964C:  MOVLW  00
0964E:  ADDWFC x20,F
09650:  MOVLW  32
09652:  ADDWF  x1F,W
09654:  MOVWF  01
09656:  MOVLW  00
09658:  ADDWFC x20,W
0965A:  MOVWF  03
0965C:  MOVF   01,W
0965E:  ADDLW  E9
09660:  MOVWF  01
09662:  MOVLW  01
09664:  ADDWFC 03,F
09666:  MOVFF  01,71F
0966A:  MOVFF  03,720
0966E:  MOVFF  03,729
09672:  MOVFF  01,728
09676:  CLRF   x2B
09678:  CLRF   x2A
0967A:  MOVLW  0A
0967C:  MOVWF  x2C
0967E:  MOVLB  0
09680:  CALL   5D6C
09684:  MOVFF  01,6FA
....................    
....................    arg2 = SERcmd[rec].p[3];
09688:  MOVLB  7
0968A:  CLRF   x31
0968C:  MOVFF  684,730
09690:  CLRF   x33
09692:  MOVLW  B5
09694:  MOVWF  x32
09696:  MOVLB  0
09698:  CALL   0874
0969C:  MOVFF  02,720
096A0:  MOVFF  01,71F
096A4:  MOVLW  06
096A6:  MOVLB  7
096A8:  ADDWF  x1F,F
096AA:  MOVLW  00
096AC:  ADDWFC x20,F
096AE:  MOVLW  4B
096B0:  ADDWF  x1F,W
096B2:  MOVWF  01
096B4:  MOVLW  00
096B6:  ADDWFC x20,W
096B8:  MOVWF  03
096BA:  MOVF   01,W
096BC:  ADDLW  E9
096BE:  MOVWF  01
096C0:  MOVLW  01
096C2:  ADDWFC 03,F
096C4:  MOVFF  01,6FB
096C8:  MOVLB  6
096CA:  MOVFF  03,6FC
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
096CE:  MOVFF  6FE,731
096D2:  MOVFF  6FD,730
096D6:  MOVFF  6FC,733
096DA:  MOVFF  6FB,732
096DE:  MOVLB  0
096E0:  CALL   5B5C
096E4:  MOVF   01,F
096E6:  BTFSS  FD8.2
096E8:  BRA    986C
....................       sprintf(retData+strlen(retData), "%d,", arg1);
096EA:  MOVLW  04
096EC:  MOVLB  7
096EE:  MOVWF  x31
096F0:  MOVLW  BF
096F2:  MOVWF  x30
096F4:  MOVLB  0
096F6:  CALL   55E6
096FA:  MOVFF  02,03
096FE:  MOVF   01,W
09700:  ADDLW  BF
09702:  MOVLB  7
09704:  MOVWF  x1F
09706:  MOVLW  04
09708:  ADDWFC 02,W
0970A:  MOVWF  x20
0970C:  MOVFF  FE8,563
09710:  MOVFF  71F,562
09714:  MOVFF  6FA,729
09718:  MOVLW  18
0971A:  MOVWF  x2A
0971C:  MOVLB  0
0971E:  CALL   60C0
09722:  MOVLW  2C
09724:  MOVLB  7
09726:  MOVWF  x3F
09728:  MOVLB  0
0972A:  CALL   561E
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0972E:  MOVLW  04
09730:  MOVLB  7
09732:  MOVWF  x31
09734:  MOVLW  BF
09736:  MOVWF  x30
09738:  MOVLB  0
0973A:  CALL   55E6
0973E:  MOVFF  02,03
09742:  MOVF   01,W
09744:  ADDLW  BF
09746:  MOVLB  7
09748:  MOVWF  x1F
0974A:  MOVLW  04
0974C:  ADDWFC 02,W
0974E:  MOVWF  x20
09750:  MOVLW  01
09752:  MOVLB  6
09754:  SUBWF  xFA,W
09756:  MULLW  2D
09758:  MOVF   FF3,W
0975A:  MOVLB  7
0975C:  CLRF   x22
0975E:  MOVWF  x21
09760:  MOVLW  07
09762:  ADDWF  x21,W
09764:  MOVWF  FE9
09766:  MOVLW  01
09768:  ADDWFC x22,W
0976A:  MOVWF  FEA
0976C:  MOVFF  FEF,73F
09770:  MOVFF  FEC,01
09774:  MOVFF  FEC,02
09778:  MOVFF  FEC,03
0977C:  MOVFF  03,742
09780:  MOVFF  02,741
09784:  MOVFF  01,740
09788:  MOVLB  0
0978A:  CALL   56E6
0978E:  MOVFF  03,726
09792:  MOVFF  02,725
09796:  MOVFF  01,724
0979A:  MOVFF  00,723
0979E:  MOVFF  720,563
097A2:  MOVFF  71F,562
097A6:  MOVLW  41
097A8:  MOVWF  FE9
097AA:  MOVFF  03,731
097AE:  MOVFF  02,730
097B2:  MOVFF  01,72F
097B6:  MOVFF  00,72E
097BA:  RCALL  942C
097BC:  MOVLW  2C
097BE:  MOVLB  7
097C0:  MOVWF  x3F
097C2:  MOVLB  0
097C4:  CALL   561E
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
097C8:  MOVLW  04
097CA:  MOVLB  7
097CC:  MOVWF  x31
097CE:  MOVLW  BF
097D0:  MOVWF  x30
097D2:  MOVLB  0
097D4:  CALL   55E6
097D8:  MOVF   01,W
097DA:  ADDLW  BF
097DC:  MOVLB  7
097DE:  MOVWF  x1F
097E0:  MOVLW  04
097E2:  ADDWFC 02,W
097E4:  MOVWF  x20
097E6:  MOVLW  01
097E8:  MOVLB  6
097EA:  SUBWF  xFA,W
097EC:  MULLW  2D
097EE:  MOVF   FF3,W
097F0:  MOVLB  7
097F2:  CLRF   x22
097F4:  MOVWF  x21
097F6:  MOVLW  04
097F8:  ADDWF  x21,W
097FA:  MOVWF  01
097FC:  MOVLW  00
097FE:  ADDWFC x22,W
09800:  MOVWF  03
09802:  MOVF   01,W
09804:  ADDLW  07
09806:  MOVWF  FE9
09808:  MOVLW  01
0980A:  ADDWFC 03,W
0980C:  MOVWF  FEA
0980E:  MOVFF  FEF,73F
09812:  MOVFF  FEC,01
09816:  MOVFF  FEC,02
0981A:  MOVFF  FEC,03
0981E:  MOVFF  03,742
09822:  MOVFF  02,741
09826:  MOVFF  01,740
0982A:  MOVLB  0
0982C:  CALL   56E6
09830:  MOVFF  03,724
09834:  MOVFF  02,723
09838:  MOVFF  01,722
0983C:  MOVFF  00,721
09840:  MOVFF  720,563
09844:  MOVFF  71F,562
09848:  MOVLW  41
0984A:  MOVWF  FE9
0984C:  MOVFF  03,731
09850:  MOVFF  02,730
09854:  MOVFF  01,72F
09858:  MOVFF  00,72E
0985C:  RCALL  942C
0985E:  MOVLW  2C
09860:  MOVLB  7
09862:  MOVWF  x3F
09864:  MOVLB  0
09866:  CALL   561E
....................    }
0986A:  BRA    9C88
....................    else if (0 == strcmp(s_calibrated, arg2)) {
0986C:  MOVFF  704,731
09870:  MOVFF  703,730
09874:  MOVFF  6FC,733
09878:  MOVFF  6FB,732
0987C:  CALL   5B5C
09880:  MOVF   01,F
09882:  BTFSS  FD8.2
09884:  BRA    9A10
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09886:  MOVLW  04
09888:  MOVLB  7
0988A:  MOVWF  x31
0988C:  MOVLW  BF
0988E:  MOVWF  x30
09890:  MOVLB  0
09892:  CALL   55E6
09896:  MOVFF  02,03
0989A:  MOVF   01,W
0989C:  ADDLW  BF
0989E:  MOVLB  7
098A0:  MOVWF  x1F
098A2:  MOVLW  04
098A4:  ADDWFC 02,W
098A6:  MOVWF  x20
098A8:  MOVFF  FE8,563
098AC:  MOVFF  71F,562
098B0:  MOVFF  6FA,729
098B4:  MOVLW  18
098B6:  MOVWF  x2A
098B8:  MOVLB  0
098BA:  CALL   60C0
098BE:  MOVLW  2C
098C0:  MOVLB  7
098C2:  MOVWF  x3F
098C4:  MOVLB  0
098C6:  CALL   561E
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
098CA:  MOVLW  04
098CC:  MOVLB  7
098CE:  MOVWF  x31
098D0:  MOVLW  BF
098D2:  MOVWF  x30
098D4:  MOVLB  0
098D6:  CALL   55E6
098DA:  MOVF   01,W
098DC:  ADDLW  BF
098DE:  MOVLB  7
098E0:  MOVWF  x1F
098E2:  MOVLW  04
098E4:  ADDWFC 02,W
098E6:  MOVWF  x20
098E8:  MOVLW  01
098EA:  MOVLB  6
098EC:  SUBWF  xFA,W
098EE:  MULLW  2D
098F0:  MOVF   FF3,W
098F2:  MOVLB  7
098F4:  CLRF   x22
098F6:  MOVWF  x21
098F8:  MOVLW  08
098FA:  ADDWF  x21,W
098FC:  MOVWF  01
098FE:  MOVLW  00
09900:  ADDWFC x22,W
09902:  MOVWF  03
09904:  MOVF   01,W
09906:  ADDLW  07
09908:  MOVWF  FE9
0990A:  MOVLW  01
0990C:  ADDWFC 03,W
0990E:  MOVWF  FEA
09910:  MOVFF  FEF,73F
09914:  MOVFF  FEC,01
09918:  MOVFF  FEC,02
0991C:  MOVFF  FEC,03
09920:  MOVFF  03,742
09924:  MOVFF  02,741
09928:  MOVFF  01,740
0992C:  MOVLB  0
0992E:  CALL   56E6
09932:  MOVFF  03,724
09936:  MOVFF  02,723
0993A:  MOVFF  01,722
0993E:  MOVFF  00,721
09942:  MOVFF  720,563
09946:  MOVFF  71F,562
0994A:  MOVLW  41
0994C:  MOVWF  FE9
0994E:  MOVFF  03,731
09952:  MOVFF  02,730
09956:  MOVFF  01,72F
0995A:  MOVFF  00,72E
0995E:  RCALL  942C
09960:  MOVLW  2C
09962:  MOVLB  7
09964:  MOVWF  x3F
09966:  MOVLB  0
09968:  CALL   561E
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
0996C:  MOVLW  04
0996E:  MOVLB  7
09970:  MOVWF  x31
09972:  MOVLW  BF
09974:  MOVWF  x30
09976:  MOVLB  0
09978:  CALL   55E6
0997C:  MOVF   01,W
0997E:  ADDLW  BF
09980:  MOVLB  7
09982:  MOVWF  x1F
09984:  MOVLW  04
09986:  ADDWFC 02,W
09988:  MOVWF  x20
0998A:  MOVLW  01
0998C:  MOVLB  6
0998E:  SUBWF  xFA,W
09990:  MULLW  2D
09992:  MOVF   FF3,W
09994:  MOVLB  7
09996:  CLRF   x22
09998:  MOVWF  x21
0999A:  MOVLW  0C
0999C:  ADDWF  x21,W
0999E:  MOVWF  01
099A0:  MOVLW  00
099A2:  ADDWFC x22,W
099A4:  MOVWF  03
099A6:  MOVF   01,W
099A8:  ADDLW  07
099AA:  MOVWF  FE9
099AC:  MOVLW  01
099AE:  ADDWFC 03,W
099B0:  MOVWF  FEA
099B2:  MOVFF  FEF,73F
099B6:  MOVFF  FEC,01
099BA:  MOVFF  FEC,02
099BE:  MOVFF  FEC,03
099C2:  MOVFF  03,742
099C6:  MOVFF  02,741
099CA:  MOVFF  01,740
099CE:  MOVLB  0
099D0:  CALL   56E6
099D4:  MOVFF  03,724
099D8:  MOVFF  02,723
099DC:  MOVFF  01,722
099E0:  MOVFF  00,721
099E4:  MOVFF  720,563
099E8:  MOVFF  71F,562
099EC:  MOVLW  41
099EE:  MOVWF  FE9
099F0:  MOVFF  03,731
099F4:  MOVFF  02,730
099F8:  MOVFF  01,72F
099FC:  MOVFF  00,72E
09A00:  RCALL  942C
09A02:  MOVLW  2C
09A04:  MOVLB  7
09A06:  MOVWF  x3F
09A08:  MOVLB  0
09A0A:  CALL   561E
....................    }
09A0E:  BRA    9C88
....................    else if (0 == strcmp(s_p0, arg2)) {
09A10:  MOVFF  70C,731
09A14:  MOVFF  70B,730
09A18:  MOVFF  6FC,733
09A1C:  MOVFF  6FB,732
09A20:  CALL   5B5C
09A24:  MOVF   01,F
09A26:  BNZ   9AE6
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09A28:  MOVLW  04
09A2A:  MOVLB  7
09A2C:  MOVWF  x31
09A2E:  MOVLW  BF
09A30:  MOVWF  x30
09A32:  MOVLB  0
09A34:  CALL   55E6
09A38:  MOVFF  02,03
09A3C:  MOVF   01,W
09A3E:  ADDLW  BF
09A40:  MOVLB  7
09A42:  MOVWF  x1F
09A44:  MOVLW  04
09A46:  ADDWFC 02,W
09A48:  MOVWF  x20
09A4A:  MOVFF  FE8,563
09A4E:  MOVFF  71F,562
09A52:  MOVFF  6FA,729
09A56:  MOVLW  18
09A58:  MOVWF  x2A
09A5A:  MOVLB  0
09A5C:  CALL   60C0
09A60:  MOVLW  2C
09A62:  MOVLB  7
09A64:  MOVWF  x3F
09A66:  MOVLB  0
09A68:  CALL   561E
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09A6C:  MOVLW  04
09A6E:  MOVLB  7
09A70:  MOVWF  x31
09A72:  MOVLW  BF
09A74:  MOVWF  x30
09A76:  MOVLB  0
09A78:  CALL   55E6
09A7C:  MOVF   01,W
09A7E:  ADDLW  BF
09A80:  MOVLB  7
09A82:  MOVWF  x1F
09A84:  MOVLW  04
09A86:  ADDWFC 02,W
09A88:  MOVWF  x20
09A8A:  MOVLW  01
09A8C:  MOVLB  6
09A8E:  SUBWF  xFA,W
09A90:  MULLW  2D
09A92:  MOVF   FF3,W
09A94:  MOVLB  7
09A96:  CLRF   x22
09A98:  MOVWF  x21
09A9A:  MOVLW  18
09A9C:  ADDWF  x21,W
09A9E:  MOVWF  01
09AA0:  MOVLW  00
09AA2:  ADDWFC x22,W
09AA4:  MOVWF  03
09AA6:  MOVF   01,W
09AA8:  ADDLW  07
09AAA:  MOVWF  FE9
09AAC:  MOVLW  01
09AAE:  ADDWFC 03,W
09AB0:  MOVWF  FEA
09AB2:  MOVFF  FEF,732
09AB6:  MOVFF  FEC,733
09ABA:  MOVFF  FEC,734
09ABE:  MOVFF  FEC,735
09AC2:  MOVFF  720,563
09AC6:  MOVFF  71F,562
09ACA:  MOVLW  89
09ACC:  MOVWF  FE9
09ACE:  MOVLW  02
09AD0:  MOVWF  x36
09AD2:  MOVLB  0
09AD4:  CALL   57BC
09AD8:  MOVLW  2C
09ADA:  MOVLB  7
09ADC:  MOVWF  x3F
09ADE:  MOVLB  0
09AE0:  CALL   561E
....................    }
09AE4:  BRA    9C88
....................    else if (0 == strcmp(s_poles, arg2)) {
09AE6:  MOVFF  711,731
09AEA:  MOVFF  710,730
09AEE:  MOVFF  6FC,733
09AF2:  MOVFF  6FB,732
09AF6:  CALL   5B5C
09AFA:  MOVF   01,F
09AFC:  BNZ   9BAC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09AFE:  MOVLW  04
09B00:  MOVLB  7
09B02:  MOVWF  x31
09B04:  MOVLW  BF
09B06:  MOVWF  x30
09B08:  MOVLB  0
09B0A:  CALL   55E6
09B0E:  MOVFF  02,03
09B12:  MOVF   01,W
09B14:  ADDLW  BF
09B16:  MOVLB  7
09B18:  MOVWF  x1F
09B1A:  MOVLW  04
09B1C:  ADDWFC 02,W
09B1E:  MOVWF  x20
09B20:  MOVFF  FE8,563
09B24:  MOVFF  71F,562
09B28:  MOVFF  6FA,729
09B2C:  MOVLW  18
09B2E:  MOVWF  x2A
09B30:  MOVLB  0
09B32:  CALL   60C0
09B36:  MOVLW  2C
09B38:  MOVLB  7
09B3A:  MOVWF  x3F
09B3C:  MOVLB  0
09B3E:  CALL   561E
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09B42:  MOVLW  04
09B44:  MOVLB  7
09B46:  MOVWF  x31
09B48:  MOVLW  BF
09B4A:  MOVWF  x30
09B4C:  MOVLB  0
09B4E:  CALL   55E6
09B52:  MOVF   01,W
09B54:  ADDLW  BF
09B56:  MOVLB  7
09B58:  MOVWF  x1F
09B5A:  MOVLW  04
09B5C:  ADDWFC 02,W
09B5E:  MOVWF  x20
09B60:  MOVLW  01
09B62:  MOVLB  6
09B64:  SUBWF  xFA,W
09B66:  MULLW  2D
09B68:  MOVF   FF3,W
09B6A:  MOVLB  7
09B6C:  CLRF   x22
09B6E:  MOVWF  x21
09B70:  MOVLW  1C
09B72:  ADDWF  x21,W
09B74:  MOVWF  01
09B76:  MOVLW  00
09B78:  ADDWFC x22,W
09B7A:  MOVWF  03
09B7C:  MOVF   01,W
09B7E:  ADDLW  07
09B80:  MOVWF  FE9
09B82:  MOVLW  01
09B84:  ADDWFC 03,W
09B86:  MOVWF  FEA
09B88:  MOVFF  FEF,729
09B8C:  MOVFF  720,563
09B90:  MOVFF  71F,562
09B94:  MOVLW  18
09B96:  MOVWF  x2A
09B98:  MOVLB  0
09B9A:  CALL   60C0
09B9E:  MOVLW  2C
09BA0:  MOVLB  7
09BA2:  MOVWF  x3F
09BA4:  MOVLB  0
09BA6:  CALL   561E
....................    }
09BAA:  BRA    9C88
....................    else if (0 == strcmp(s_real, arg2)) {
09BAC:  MOVFF  719,731
09BB0:  MOVFF  718,730
09BB4:  MOVFF  6FC,733
09BB8:  MOVFF  6FB,732
09BBC:  CALL   5B5C
09BC0:  MOVF   01,F
09BC2:  BNZ   9C82
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09BC4:  MOVLW  04
09BC6:  MOVLB  7
09BC8:  MOVWF  x31
09BCA:  MOVLW  BF
09BCC:  MOVWF  x30
09BCE:  MOVLB  0
09BD0:  CALL   55E6
09BD4:  MOVFF  02,03
09BD8:  MOVF   01,W
09BDA:  ADDLW  BF
09BDC:  MOVLB  7
09BDE:  MOVWF  x1F
09BE0:  MOVLW  04
09BE2:  ADDWFC 02,W
09BE4:  MOVWF  x20
09BE6:  MOVFF  FE8,563
09BEA:  MOVFF  71F,562
09BEE:  MOVFF  6FA,729
09BF2:  MOVLW  18
09BF4:  MOVWF  x2A
09BF6:  MOVLB  0
09BF8:  CALL   60C0
09BFC:  MOVLW  2C
09BFE:  MOVLB  7
09C00:  MOVWF  x3F
09C02:  MOVLB  0
09C04:  CALL   561E
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09C08:  MOVLW  04
09C0A:  MOVLB  7
09C0C:  MOVWF  x31
09C0E:  MOVLW  BF
09C10:  MOVWF  x30
09C12:  MOVLB  0
09C14:  CALL   55E6
09C18:  MOVF   01,W
09C1A:  ADDLW  BF
09C1C:  MOVLB  7
09C1E:  MOVWF  x1F
09C20:  MOVLW  04
09C22:  ADDWFC 02,W
09C24:  MOVWF  x20
09C26:  MOVLW  01
09C28:  MOVLB  6
09C2A:  SUBWF  xFA,W
09C2C:  MULLW  2D
09C2E:  MOVF   FF3,W
09C30:  MOVLB  7
09C32:  CLRF   x22
09C34:  MOVWF  x21
09C36:  MOVLW  1D
09C38:  ADDWF  x21,W
09C3A:  MOVWF  01
09C3C:  MOVLW  00
09C3E:  ADDWFC x22,W
09C40:  MOVWF  03
09C42:  MOVF   01,W
09C44:  ADDLW  07
09C46:  MOVWF  FE9
09C48:  MOVLW  01
09C4A:  ADDWFC 03,W
09C4C:  MOVWF  FEA
09C4E:  MOVFF  FEF,732
09C52:  MOVFF  FEC,733
09C56:  MOVFF  FEC,734
09C5A:  MOVFF  FEC,735
09C5E:  MOVFF  720,563
09C62:  MOVFF  71F,562
09C66:  MOVLW  89
09C68:  MOVWF  FE9
09C6A:  MOVLW  02
09C6C:  MOVWF  x36
09C6E:  MOVLB  0
09C70:  CALL   57BC
09C74:  MOVLW  2C
09C76:  MOVLB  7
09C78:  MOVWF  x3F
09C7A:  MOVLB  0
09C7C:  CALL   561E
....................    }
09C80:  BRA    9C88
....................    else return INV_PARAM;
09C82:  MOVLW  02
09C84:  MOVWF  01
09C86:  BRA    9C8C
....................    
....................    return SUCCESS;
09C88:  MOVLW  00
09C8A:  MOVWF  01
09C8C:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09C8E:  MOVLB  7
09C90:  CLRF   x31
09C92:  MOVFF  684,730
09C96:  CLRF   x33
09C98:  MOVLW  B5
09C9A:  MOVWF  x32
09C9C:  MOVLB  0
09C9E:  CALL   0874
09CA2:  MOVFF  02,6FC
09CA6:  MOVFF  01,6FB
09CAA:  MOVLW  06
09CAC:  MOVLB  6
09CAE:  ADDWF  xFB,F
09CB0:  MOVLW  00
09CB2:  ADDWFC xFC,F
09CB4:  MOVLW  32
09CB6:  ADDWF  xFB,W
09CB8:  MOVWF  01
09CBA:  MOVLW  00
09CBC:  ADDWFC xFC,W
09CBE:  MOVWF  03
09CC0:  MOVF   01,W
09CC2:  ADDLW  E9
09CC4:  MOVWF  01
09CC6:  MOVLW  01
09CC8:  ADDWFC 03,F
09CCA:  MOVFF  01,6FB
09CCE:  MOVFF  03,6FC
09CD2:  MOVFF  03,729
09CD6:  MOVFF  01,728
09CDA:  MOVLB  0
09CDC:  CALL   5C7C
09CE0:  MOVF   01,F
09CE2:  BNZ   9CEC
09CE4:  MOVLW  02
09CE6:  MOVWF  01
09CE8:  BRA    9DE2
09CEA:  BRA    9D4C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09CEC:  MOVLB  7
09CEE:  CLRF   x31
09CF0:  MOVFF  684,730
09CF4:  CLRF   x33
09CF6:  MOVLW  B5
09CF8:  MOVWF  x32
09CFA:  MOVLB  0
09CFC:  CALL   0874
09D00:  MOVFF  02,6FC
09D04:  MOVFF  01,6FB
09D08:  MOVLW  06
09D0A:  MOVLB  6
09D0C:  ADDWF  xFB,F
09D0E:  MOVLW  00
09D10:  ADDWFC xFC,F
09D12:  MOVLW  32
09D14:  ADDWF  xFB,W
09D16:  MOVWF  01
09D18:  MOVLW  00
09D1A:  ADDWFC xFC,W
09D1C:  MOVWF  03
09D1E:  MOVF   01,W
09D20:  ADDLW  E9
09D22:  MOVWF  01
09D24:  MOVLW  01
09D26:  ADDWFC 03,F
09D28:  MOVFF  01,6FB
09D2C:  MOVFF  03,6FC
09D30:  MOVFF  03,729
09D34:  MOVFF  01,728
09D38:  MOVLB  7
09D3A:  CLRF   x2B
09D3C:  CLRF   x2A
09D3E:  MOVLW  0A
09D40:  MOVWF  x2C
09D42:  MOVLB  0
09D44:  CALL   5D6C
09D48:  MOVFF  01,6FA
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
09D4C:  MOVLW  04
09D4E:  MOVLB  7
09D50:  MOVWF  x31
09D52:  MOVLW  BF
09D54:  MOVWF  x30
09D56:  MOVLB  0
09D58:  CALL   55E6
09D5C:  MOVF   01,W
09D5E:  ADDLW  BF
09D60:  MOVLB  6
09D62:  MOVWF  xFB
09D64:  MOVLW  04
09D66:  ADDWFC 02,W
09D68:  MOVWF  xFC
09D6A:  MOVLW  01
09D6C:  SUBWF  xFA,W
09D6E:  MULLW  04
09D70:  MOVF   FF3,W
09D72:  CLRF   03
09D74:  ADDLW  68
09D76:  MOVWF  FE9
09D78:  MOVLW  01
09D7A:  ADDWFC 03,W
09D7C:  MOVWF  FEA
09D7E:  MOVFF  FEF,6FD
09D82:  MOVFF  FEC,6FE
09D86:  MOVFF  FEC,6FF
09D8A:  MOVFF  FEC,700
09D8E:  MOVFF  6FC,563
09D92:  MOVFF  6FB,562
09D96:  MOVFF  6FA,729
09D9A:  MOVLW  18
09D9C:  MOVLB  7
09D9E:  MOVWF  x2A
09DA0:  MOVLB  0
09DA2:  CALL   60C0
09DA6:  MOVLW  2C
09DA8:  MOVLB  7
09DAA:  MOVWF  x3F
09DAC:  MOVLB  0
09DAE:  CALL   561E
09DB2:  MOVLW  89
09DB4:  MOVWF  FE9
09DB6:  MOVFF  700,735
09DBA:  MOVFF  6FF,734
09DBE:  MOVFF  6FE,733
09DC2:  MOVFF  6FD,732
09DC6:  MOVLW  02
09DC8:  MOVLB  7
09DCA:  MOVWF  x36
09DCC:  MOVLB  0
09DCE:  CALL   57BC
09DD2:  MOVLW  2C
09DD4:  MOVLB  7
09DD6:  MOVWF  x3F
09DD8:  MOVLB  0
09DDA:  CALL   561E
....................    
....................    return SUCCESS;
09DDE:  MOVLW  00
09DE0:  MOVWF  01
09DE2:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09DE4:  MOVLB  7
09DE6:  CLRF   x31
09DE8:  MOVFF  684,730
09DEC:  CLRF   x33
09DEE:  MOVLW  B5
09DF0:  MOVWF  x32
09DF2:  MOVLB  0
09DF4:  CALL   0874
09DF8:  MOVFF  02,700
09DFC:  MOVFF  01,6FF
09E00:  MOVLW  06
09E02:  MOVLB  6
09E04:  ADDWF  xFF,F
09E06:  MOVLW  00
09E08:  MOVLB  7
09E0A:  ADDWFC x00,F
09E0C:  MOVLW  32
09E0E:  MOVLB  6
09E10:  ADDWF  xFF,W
09E12:  MOVWF  01
09E14:  MOVLW  00
09E16:  MOVLB  7
09E18:  ADDWFC x00,W
09E1A:  MOVWF  03
09E1C:  MOVF   01,W
09E1E:  ADDLW  E9
09E20:  MOVWF  01
09E22:  MOVLW  01
09E24:  ADDWFC 03,F
09E26:  MOVFF  01,6FF
09E2A:  MOVFF  03,700
09E2E:  MOVFF  03,729
09E32:  MOVFF  01,728
09E36:  MOVLB  0
09E38:  CALL   5C7C
09E3C:  MOVF   01,F
09E3E:  BNZ   9E48
09E40:  MOVLW  02
09E42:  MOVWF  01
09E44:  BRA    A040
09E46:  BRA    9EAE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09E48:  MOVLB  7
09E4A:  CLRF   x31
09E4C:  MOVFF  684,730
09E50:  CLRF   x33
09E52:  MOVLW  B5
09E54:  MOVWF  x32
09E56:  MOVLB  0
09E58:  CALL   0874
09E5C:  MOVFF  02,700
09E60:  MOVFF  01,6FF
09E64:  MOVLW  06
09E66:  MOVLB  6
09E68:  ADDWF  xFF,F
09E6A:  MOVLW  00
09E6C:  MOVLB  7
09E6E:  ADDWFC x00,F
09E70:  MOVLW  32
09E72:  MOVLB  6
09E74:  ADDWF  xFF,W
09E76:  MOVWF  01
09E78:  MOVLW  00
09E7A:  MOVLB  7
09E7C:  ADDWFC x00,W
09E7E:  MOVWF  03
09E80:  MOVF   01,W
09E82:  ADDLW  E9
09E84:  MOVWF  01
09E86:  MOVLW  01
09E88:  ADDWFC 03,F
09E8A:  MOVFF  01,6FF
09E8E:  MOVFF  03,700
09E92:  MOVFF  03,729
09E96:  MOVFF  01,728
09E9A:  MOVLB  7
09E9C:  CLRF   x2B
09E9E:  CLRF   x2A
09EA0:  MOVLW  0A
09EA2:  MOVWF  x2C
09EA4:  MOVLB  0
09EA6:  CALL   5D6C
09EAA:  MOVFF  01,6FA
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09EAE:  MOVLB  7
09EB0:  CLRF   x31
09EB2:  MOVFF  684,730
09EB6:  CLRF   x33
09EB8:  MOVLW  B5
09EBA:  MOVWF  x32
09EBC:  MOVLB  0
09EBE:  CALL   0874
09EC2:  MOVFF  02,700
09EC6:  MOVFF  01,6FF
09ECA:  MOVLW  06
09ECC:  MOVLB  6
09ECE:  ADDWF  xFF,F
09ED0:  MOVLW  00
09ED2:  MOVLB  7
09ED4:  ADDWFC x00,F
09ED6:  MOVLW  4B
09ED8:  MOVLB  6
09EDA:  ADDWF  xFF,W
09EDC:  MOVWF  01
09EDE:  MOVLW  00
09EE0:  MOVLB  7
09EE2:  ADDWFC x00,W
09EE4:  MOVWF  03
09EE6:  MOVF   01,W
09EE8:  ADDLW  E9
09EEA:  MOVWF  01
09EEC:  MOVLW  01
09EEE:  ADDWFC 03,F
09EF0:  MOVFF  01,6FF
09EF4:  MOVFF  03,700
09EF8:  MOVFF  03,704
09EFC:  MOVFF  01,703
09F00:  MOVLB  0
09F02:  CALL   6DCE
09F06:  MOVF   01,F
09F08:  BNZ   9F12
09F0A:  MOVLW  02
09F0C:  MOVWF  01
09F0E:  BRA    A040
09F10:  BRA    9F80
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09F12:  MOVLB  7
09F14:  CLRF   x31
09F16:  MOVFF  684,730
09F1A:  CLRF   x33
09F1C:  MOVLW  B5
09F1E:  MOVWF  x32
09F20:  MOVLB  0
09F22:  CALL   0874
09F26:  MOVFF  02,700
09F2A:  MOVFF  01,6FF
09F2E:  MOVLW  06
09F30:  MOVLB  6
09F32:  ADDWF  xFF,F
09F34:  MOVLW  00
09F36:  MOVLB  7
09F38:  ADDWFC x00,F
09F3A:  MOVLW  4B
09F3C:  MOVLB  6
09F3E:  ADDWF  xFF,W
09F40:  MOVWF  01
09F42:  MOVLW  00
09F44:  MOVLB  7
09F46:  ADDWFC x00,W
09F48:  MOVWF  03
09F4A:  MOVF   01,W
09F4C:  ADDLW  E9
09F4E:  MOVWF  01
09F50:  MOVLW  01
09F52:  ADDWFC 03,F
09F54:  MOVFF  01,6FF
09F58:  MOVFF  03,700
09F5C:  MOVFF  03,704
09F60:  MOVFF  01,703
09F64:  MOVLB  7
09F66:  CLRF   x06
09F68:  CLRF   x05
09F6A:  MOVLB  0
09F6C:  CALL   6E90
09F70:  MOVFF  03,6FE
09F74:  MOVFF  02,6FD
09F78:  MOVFF  01,6FC
09F7C:  MOVFF  00,6FB
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09F80:  MOVLB  7
09F82:  CLRF   x46
09F84:  CLRF   x45
09F86:  MOVLW  7C
09F88:  MOVWF  x44
09F8A:  MOVLW  84
09F8C:  MOVWF  x43
09F8E:  MOVFF  6FE,74A
09F92:  MOVFF  6FD,749
09F96:  MOVFF  6FC,748
09F9A:  MOVFF  6FB,747
09F9E:  MOVLB  0
09FA0:  CALL   1D08
09FA4:  BNC   9FCA
09FA6:  MOVLW  01
09FA8:  MOVLB  6
09FAA:  SUBWF  xFA,W
09FAC:  MULLW  04
09FAE:  MOVF   FF3,W
09FB0:  CLRF   03
09FB2:  ADDLW  68
09FB4:  MOVWF  FE9
09FB6:  MOVLW  01
09FB8:  ADDWFC 03,W
09FBA:  MOVWF  FEA
09FBC:  MOVLW  84
09FBE:  MOVWF  FEF
09FC0:  MOVLW  7C
09FC2:  MOVWF  FEC
09FC4:  CLRF   FEC
09FC6:  CLRF   FEC
09FC8:  BRA    A03A
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
09FCA:  MOVFF  6FE,746
09FCE:  MOVFF  6FD,745
09FD2:  MOVFF  6FC,744
09FD6:  MOVFF  6FB,743
09FDA:  MOVLB  7
09FDC:  CLRF   x4A
09FDE:  CLRF   x49
09FE0:  MOVLW  C0
09FE2:  MOVWF  x48
09FE4:  MOVLW  82
09FE6:  MOVWF  x47
09FE8:  MOVLB  0
09FEA:  CALL   1D08
09FEE:  BNC   A014
09FF0:  MOVLW  01
09FF2:  MOVLB  6
09FF4:  SUBWF  xFA,W
09FF6:  MULLW  04
09FF8:  MOVF   FF3,W
09FFA:  CLRF   03
09FFC:  ADDLW  68
09FFE:  MOVWF  FE9
0A000:  MOVLW  01
0A002:  ADDWFC 03,W
0A004:  MOVWF  FEA
0A006:  MOVLW  82
0A008:  MOVWF  FEF
0A00A:  MOVLW  C0
0A00C:  MOVWF  FEC
0A00E:  CLRF   FEC
0A010:  CLRF   FEC
0A012:  BRA    A03A
....................    else manualOutputValues[arg1-1] = arg2;
0A014:  MOVLW  01
0A016:  MOVLB  6
0A018:  SUBWF  xFA,W
0A01A:  MULLW  04
0A01C:  MOVF   FF3,W
0A01E:  CLRF   03
0A020:  ADDLW  68
0A022:  MOVWF  FE9
0A024:  MOVLW  01
0A026:  ADDWFC 03,W
0A028:  MOVWF  FEA
0A02A:  MOVFF  6FB,FEF
0A02E:  MOVFF  6FC,FEC
0A032:  MOVFF  6FD,FEC
0A036:  MOVFF  6FE,FEC
....................    
....................    return SUCCESS;
0A03A:  MOVLW  00
0A03C:  MOVWF  01
0A03E:  MOVLB  0
0A040:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
0A042:  MOVLB  1
0A044:  BSF    x61.0
....................    return SUCCESS;
0A046:  MOVLW  00
0A048:  MOVWF  01
0A04A:  MOVLB  0
0A04C:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
0A04E:  MOVLB  1
0A050:  BCF    x61.0
....................    return SUCCESS;
0A052:  MOVLW  00
0A054:  MOVWF  01
0A056:  MOVLB  0
0A058:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0A05A:  MOVLW  01
0A05C:  MOVWF  01
0A05E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06DCE:  MOVLB  7
06DD0:  BCF    x05.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06DD2:  CLRF   x06
06DD4:  MOVFF  704,731
06DD8:  MOVFF  703,730
06DDC:  MOVLB  0
06DDE:  CALL   55E6
06DE2:  MOVFF  02,03
06DE6:  MOVF   01,W
06DE8:  MOVF   03,F
06DEA:  BNZ   6DF6
06DEC:  MOVF   01,W
06DEE:  MOVLB  7
06DF0:  SUBWF  x06,W
06DF2:  BC    6E88
06DF4:  MOVLB  0
....................       if (!isdigit(arg[i])){
06DF6:  MOVLB  7
06DF8:  MOVF   x06,W
06DFA:  ADDWF  x03,W
06DFC:  MOVWF  FE9
06DFE:  MOVLW  00
06E00:  ADDWFC x04,W
06E02:  MOVWF  FEA
06E04:  MOVFF  FEF,707
06E08:  MOVF   x07,W
06E0A:  SUBLW  2F
06E0C:  BC    6E14
06E0E:  MOVF   x07,W
06E10:  SUBLW  39
06E12:  BC    6E80
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06E14:  MOVF   x06,W
06E16:  ADDWF  x03,W
06E18:  MOVWF  FE9
06E1A:  MOVLW  00
06E1C:  ADDWFC x04,W
06E1E:  MOVWF  FEA
06E20:  MOVF   FEF,W
06E22:  SUBLW  2D
06E24:  BZ    6E50
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06E26:  MOVF   x06,W
06E28:  ADDWF  x03,W
06E2A:  MOVWF  FE9
06E2C:  MOVLW  00
06E2E:  ADDWFC x04,W
06E30:  MOVWF  FEA
06E32:  MOVF   FEF,W
06E34:  SUBLW  2E
06E36:  BZ    6E40
06E38:  MOVLW  00
06E3A:  MOVWF  01
06E3C:  BRA    6E8C
06E3E:  BRA    6E4E
....................             else if  (decimal) return FALSE;
06E40:  BTFSS  x05.0
06E42:  BRA    6E4C
06E44:  MOVLW  00
06E46:  MOVWF  01
06E48:  BRA    6E8C
06E4A:  BRA    6E4E
....................             else decimal = TRUE;
06E4C:  BSF    x05.0
....................          }
06E4E:  BRA    6E80
....................          else if (0 != i) return FALSE;
06E50:  MOVF   x06,F
06E52:  BZ    6E5C
06E54:  MOVLW  00
06E56:  MOVWF  01
06E58:  BRA    6E8C
06E5A:  BRA    6E80
....................          else if (1 == strlen(arg)) return FALSE;
06E5C:  MOVFF  704,731
06E60:  MOVFF  703,730
06E64:  MOVLB  0
06E66:  CALL   55E6
06E6A:  MOVFF  02,03
06E6E:  MOVF   01,W
06E70:  SUBLW  01
06E72:  BNZ   6E82
06E74:  MOVF   03,F
06E76:  BNZ   6E82
06E78:  MOVLW  00
06E7A:  MOVWF  01
06E7C:  MOVLB  7
06E7E:  BRA    6E8C
06E80:  MOVLB  0
....................       }
06E82:  MOVLB  7
06E84:  INCF   x06,F
06E86:  BRA    6DD4
....................    }
....................    return TRUE;
06E88:  MOVLW  01
06E8A:  MOVWF  01
06E8C:  MOVLB  0
06E8E:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05C7C:  MOVFF  729,731
05C80:  MOVFF  728,730
05C84:  RCALL  55E6
05C86:  MOVFF  02,03
05C8A:  MOVF   01,W
05C8C:  SUBLW  01
05C8E:  BNZ   5C94
05C90:  MOVF   03,F
05C92:  BZ    5C9C
05C94:  MOVLW  00
05C96:  MOVWF  01
05C98:  BRA    5CCA
05C9A:  BRA    5CC2
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05C9C:  MOVLB  7
05C9E:  MOVFF  728,FE9
05CA2:  MOVFF  729,FEA
05CA6:  MOVF   FEF,W
05CA8:  SUBLW  31
05CAA:  BZ    5CC4
05CAC:  MOVFF  728,FE9
05CB0:  MOVFF  729,FEA
05CB4:  MOVF   FEF,W
05CB6:  SUBLW  32
05CB8:  BZ    5CC4
05CBA:  MOVLW  00
05CBC:  MOVWF  01
05CBE:  MOVLB  0
05CC0:  BRA    5CCA
05CC2:  MOVLB  7
....................     return TRUE;
05CC4:  MOVLW  01
05CC6:  MOVWF  01
05CC8:  MOVLB  0
05CCA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05B22:  MOVLB  6
05B24:  MOVF   xF9,W
05B26:  SUBLW  2F
05B28:  BC    5B3A
05B2A:  MOVF   xF9,W
05B2C:  SUBLW  39
05B2E:  BNC   5B3A
05B30:  MOVLW  30
05B32:  SUBWF  xF9,W
05B34:  MOVWF  01
05B36:  BRA    5B56
05B38:  BRA    5B56
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05B3A:  MOVF   xF9,W
05B3C:  SUBLW  40
05B3E:  BC    5B52
05B40:  MOVF   xF9,W
05B42:  SUBLW  46
05B44:  BNC   5B52
05B46:  MOVLW  41
05B48:  SUBWF  xF9,W
05B4A:  ADDLW  0A
05B4C:  MOVWF  01
05B4E:  BRA    5B56
05B50:  BRA    5B56
....................    else return 0xFF;
05B52:  MOVLW  FF
05B54:  MOVWF  01
05B56:  MOVLB  0
05B58:  GOTO   A106 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
0A060:  MOVLB  7
0A062:  CLRF   x31
0A064:  MOVFF  6F0,730
0A068:  CLRF   x33
0A06A:  MOVLW  B5
0A06C:  MOVWF  x32
0A06E:  MOVLB  0
0A070:  CALL   0874
0A074:  MOVFF  02,6F9
0A078:  MOVFF  01,6F8
0A07C:  MOVLW  06
0A07E:  MOVLB  6
0A080:  ADDWF  xF8,F
0A082:  MOVLW  00
0A084:  ADDWFC xF9,F
0A086:  MOVLW  E9
0A088:  ADDWF  xF8,W
0A08A:  MOVWF  01
0A08C:  MOVLW  01
0A08E:  ADDWFC xF9,W
0A090:  MOVWF  03
0A092:  MOVFF  01,6F1
0A096:  MOVWF  xF2
0A098:  MOVLB  7
0A09A:  CLRF   x31
0A09C:  MOVFF  6F0,730
0A0A0:  CLRF   x33
0A0A2:  MOVLW  B5
0A0A4:  MOVWF  x32
0A0A6:  MOVLB  0
0A0A8:  CALL   0874
0A0AC:  MOVFF  02,6FB
0A0B0:  MOVFF  01,6FA
0A0B4:  MOVLW  06
0A0B6:  MOVLB  6
0A0B8:  ADDWF  xFA,F
0A0BA:  MOVLW  00
0A0BC:  ADDWFC xFB,F
0A0BE:  MOVLW  19
0A0C0:  ADDWF  xFA,W
0A0C2:  MOVWF  01
0A0C4:  MOVLW  00
0A0C6:  ADDWFC xFB,W
0A0C8:  MOVWF  03
0A0CA:  MOVF   01,W
0A0CC:  ADDLW  E9
0A0CE:  MOVWF  01
0A0D0:  MOVLW  01
0A0D2:  ADDWFC 03,F
0A0D4:  MOVFF  01,6F3
0A0D8:  MOVFF  03,6F4
0A0DC:  CLRF   xF5
0A0DE:  CLRF   xF6
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0A0E0:  MOVFF  6F1,FE9
0A0E4:  MOVFF  6F2,FEA
0A0E8:  MOVF   FEF,W
0A0EA:  SUBLW  44
0A0EC:  BTFSS  FD8.2
0A0EE:  BRA    A1DE
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0A0F0:  MOVLW  01
0A0F2:  ADDWF  xF1,W
0A0F4:  MOVWF  FE9
0A0F6:  MOVLW  00
0A0F8:  ADDWFC xF2,W
0A0FA:  MOVWF  FEA
0A0FC:  MOVFF  FEF,6F9
0A100:  MOVLB  0
0A102:  GOTO   5B22
0A106:  MOVFF  01,6F8
0A10A:  MOVLB  6
0A10C:  MOVF   xF5,W
0A10E:  ANDLW  0F
0A110:  SUBWF  01,W
0A112:  BNZ   A1D6
....................          while (0 != strlen(cmd_list[i].cmd_name)){
0A114:  MOVF   xF6,W
0A116:  MULLW  04
0A118:  MOVF   FF3,W
0A11A:  CLRF   xF9
0A11C:  MOVWF  xF8
0A11E:  MOVLW  68
0A120:  ADDWF  xF8,W
0A122:  MOVWF  FE9
0A124:  MOVLW  05
0A126:  ADDWFC xF9,W
0A128:  MOVWF  FEA
0A12A:  MOVFF  FEC,731
0A12E:  MOVF   FED,F
0A130:  MOVFF  FEF,730
0A134:  MOVLB  0
0A136:  CALL   55E6
0A13A:  MOVFF  02,03
0A13E:  MOVF   01,W
0A140:  BNZ   A146
0A142:  MOVF   03,F
0A144:  BZ    A1CC
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
0A146:  MOVLB  6
0A148:  MOVF   xF6,W
0A14A:  MULLW  04
0A14C:  MOVF   FF3,W
0A14E:  CLRF   xF9
0A150:  MOVWF  xF8
0A152:  MOVLW  68
0A154:  ADDWF  xF8,W
0A156:  MOVWF  FE9
0A158:  MOVLW  05
0A15A:  ADDWFC xF9,W
0A15C:  MOVWF  FEA
0A15E:  MOVFF  FEC,733
0A162:  MOVF   FED,F
0A164:  MOVFF  FEF,732
0A168:  MOVFF  6F4,731
0A16C:  MOVFF  6F3,730
0A170:  MOVLB  0
0A172:  CALL   5B5C
0A176:  MOVF   01,F
0A178:  BNZ   A1C4
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0A17A:  MOVLB  6
0A17C:  MOVF   xF6,W
0A17E:  MULLW  04
0A180:  MOVF   FF3,W
0A182:  CLRF   xF9
0A184:  MOVWF  xF8
0A186:  MOVLW  02
0A188:  ADDWF  xF8,W
0A18A:  MOVWF  01
0A18C:  MOVLW  00
0A18E:  ADDWFC xF9,W
0A190:  MOVWF  03
0A192:  MOVF   01,W
0A194:  ADDLW  68
0A196:  MOVWF  01
0A198:  MOVLW  05
0A19A:  ADDWFC 03,F
0A19C:  MOVFF  01,6F8
0A1A0:  MOVFF  03,6F9
0A1A4:  MOVFF  03,FEA
0A1A8:  MOVFF  01,FE9
0A1AC:  MOVFF  6F0,684
0A1B0:  MOVLB  0
0A1B2:  CALL   00BC
0A1B6:  MOVFF  01,6F7
....................                return return_code;
0A1BA:  MOVLB  6
0A1BC:  MOVFF  6F7,01
0A1C0:  BRA    A1E2
0A1C2:  MOVLB  0
....................             }
....................             i++;
0A1C4:  MOVLB  6
0A1C6:  INCF   xF6,F
0A1C8:  BRA    A114
0A1CA:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A1CC:  MOVLW  01
0A1CE:  MOVWF  01
0A1D0:  MOVLB  6
0A1D2:  BRA    A1E2
....................       } else return 254; // NOT THIS ADDRESS
0A1D4:  BRA    A1DC
0A1D6:  MOVLW  FE
0A1D8:  MOVWF  01
0A1DA:  BRA    A1E2
....................    } else return 255; // NOT THIS DEVICE TYPE
0A1DC:  BRA    A1E2
0A1DE:  MOVLW  FF
0A1E0:  MOVWF  01
0A1E2:  MOVLB  0
0A1E4:  GOTO   A2D4 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0A234:  GOTO   5AA4
0A238:  MOVF   01,F
0A23A:  BTFSC  FD8.2
0A23C:  BRA    A35A
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A23E:  MOVLW  04
0A240:  MOVLB  7
0A242:  MOVWF  x31
0A244:  MOVLW  BF
0A246:  MOVWF  x30
0A248:  MOVLB  0
0A24A:  CALL   55E6
0A24E:  MOVFF  02,03
0A252:  MOVF   01,W
0A254:  ADDLW  BF
0A256:  MOVLB  6
0A258:  MOVWF  xF0
0A25A:  MOVLW  04
0A25C:  ADDWFC 02,W
0A25E:  MOVWF  xF1
0A260:  MOVLB  7
0A262:  CLRF   x31
0A264:  MOVFF  4BD,730
0A268:  CLRF   x33
0A26A:  MOVLW  B5
0A26C:  MOVWF  x32
0A26E:  MOVLB  0
0A270:  CALL   0874
0A274:  MOVFF  02,6F3
0A278:  MOVFF  01,6F2
0A27C:  MOVLW  06
0A27E:  MOVLB  6
0A280:  ADDWF  xF2,F
0A282:  MOVLW  00
0A284:  ADDWFC xF3,F
0A286:  MOVLW  E9
0A288:  ADDWF  xF2,W
0A28A:  MOVWF  01
0A28C:  MOVLW  01
0A28E:  ADDWFC xF3,W
0A290:  MOVWF  03
0A292:  MOVFF  01,6F4
0A296:  MOVWF  xF5
0A298:  MOVFF  6F1,563
0A29C:  MOVFF  6F0,562
0A2A0:  MOVLW  24
0A2A2:  MOVLB  7
0A2A4:  MOVWF  x3F
0A2A6:  MOVLB  0
0A2A8:  CALL   561E
0A2AC:  MOVFF  563,FEA
0A2B0:  MOVFF  562,FE9
0A2B4:  CLRF   FEF
0A2B6:  MOVFF  6F5,FEA
0A2BA:  MOVFF  6F4,FE9
0A2BE:  CALL   5AFE
0A2C2:  MOVLW  2C
0A2C4:  MOVLB  7
0A2C6:  MOVWF  x3F
0A2C8:  MOVLB  0
0A2CA:  CALL   561E
....................       
....................       return_code = command_parser(SRI);
0A2CE:  MOVFF  4BD,6F0
0A2D2:  BRA    A060
0A2D4:  MOVFF  01,6EF
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A2D8:  MOVLW  04
0A2DA:  MOVLB  7
0A2DC:  MOVWF  x31
0A2DE:  MOVLW  BF
0A2E0:  MOVWF  x30
0A2E2:  MOVLB  0
0A2E4:  CALL   55E6
0A2E8:  MOVF   01,W
0A2EA:  ADDLW  BF
0A2EC:  MOVLB  6
0A2EE:  MOVWF  xF0
0A2F0:  MOVLW  04
0A2F2:  ADDWFC 02,W
0A2F4:  MOVWF  xF1
0A2F6:  MOVF   xEF,W
0A2F8:  MULLW  03
0A2FA:  MOVF   FF3,W
0A2FC:  CLRF   xF3
0A2FE:  MOVWF  xF2
0A300:  MOVLW  01
0A302:  ADDWF  xF2,W
0A304:  MOVWF  01
0A306:  MOVLW  00
0A308:  ADDWFC xF3,W
0A30A:  MOVWF  03
0A30C:  MOVF   01,W
0A30E:  ADDLW  50
0A310:  MOVWF  FE9
0A312:  MOVLW  06
0A314:  ADDWFC 03,W
0A316:  MOVWF  FEA
0A318:  MOVFF  FEC,6F3
0A31C:  MOVF   FED,F
0A31E:  MOVFF  FEF,6F2
0A322:  MOVFF  6F1,563
0A326:  MOVFF  6F0,562
0A32A:  MOVFF  563,FEA
0A32E:  MOVFF  562,FE9
0A332:  CLRF   FEF
0A334:  MOVFF  6F3,FEA
0A338:  MOVFF  6F2,FE9
0A33C:  MOVLB  0
0A33E:  CALL   5AFE
....................       serial_out(retData);
0A342:  MOVLW  04
0A344:  MOVLB  6
0A346:  MOVWF  xF1
0A348:  MOVLW  BF
0A34A:  MOVWF  xF0
0A34C:  MOVLB  0
0A34E:  BRA    A1E8
....................       resetSERcmd(SRI);
0A350:  MOVFF  4BD,6F0
0A354:  CALL   0B56
0A358:  BRA    A234
....................    }
0A35A:  GOTO   AB00 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... #ifdef DEBUG_1
.................... #use rs232(ICD, stream=ICD_STREAM)
*
05A2A:  MOVFF  FF2,03
05A2E:  BCF    FF2.7
05A30:  MOVLW  C4
05A32:  MOVWF  F88
05A34:  BCF    F83.7
05A36:  MOVLW  08
05A38:  MOVWF  01
05A3A:  BRA    5A3C
05A3C:  NOP   
05A3E:  BSF    01.7
05A40:  BRA    5A62
05A42:  BCF    01.7
05A44:  MOVLB  6
05A46:  RRCF   xF1,F
05A48:  MOVLB  0
05A4A:  BTFSC  FD8.0
05A4C:  BSF    F83.7
05A4E:  BTFSS  FD8.0
05A50:  BCF    F83.7
05A52:  BSF    01.6
05A54:  BRA    5A62
05A56:  BCF    01.6
05A58:  DECFSZ 01,F
05A5A:  BRA    5A44
05A5C:  BRA    5A5E
05A5E:  NOP   
05A60:  BSF    F83.7
05A62:  MOVLW  84
05A64:  MOVWF  FE9
05A66:  DECFSZ FE9,F
05A68:  BRA    5A66
05A6A:  BRA    5A6C
05A6C:  NOP   
05A6E:  BTFSC  01.7
05A70:  BRA    5A42
05A72:  BTFSC  01.6
05A74:  BRA    5A56
05A76:  BTFSC  03.7
05A78:  BSF    FF2.7
05A7A:  GOTO   5A90 (RETURN)
.................... #endif
.................... 
.................... void main()
*
0A35E:  CLRF   FF8
0A360:  BCF    FF2.5
0A362:  BSF    07.7
0A364:  MOVLB  E
0A366:  MOVLW  55
0A368:  MOVWF  x9B
0A36A:  MOVLW  AA
0A36C:  MOVWF  x9B
0A36E:  BCF    x9B.0
0A370:  MOVLW  17
0A372:  MOVWF  xB0
0A374:  MOVLW  13
0A376:  MOVWF  xB2
0A378:  MOVLW  09
0A37A:  MOVWF  x8A
0A37C:  MOVLW  0A
0A37E:  MOVWF  x8B
0A380:  MOVLW  11
0A382:  MOVWF  xEB
0A384:  MOVLW  12
0A386:  MOVWF  xED
0A388:  MOVLW  10
0A38A:  MOVWF  xF4
0A38C:  MOVLW  0F
0A38E:  MOVWF  xF5
0A390:  MOVLW  09
0A392:  MOVWF  xF8
0A394:  MOVLW  55
0A396:  MOVWF  x9B
0A398:  MOVLW  AA
0A39A:  MOVWF  x9B
0A39C:  BSF    x9B.0
0A39E:  CLRF   xD8
0A3A0:  CLRF   xD5
0A3A2:  CLRF   xD7
0A3A4:  MOVLW  08
0A3A6:  MOVWF  xD9
0A3A8:  MOVLW  60
0A3AA:  MOVWF  xD3
0A3AC:  MOVLW  AA
0A3AE:  MOVLB  0
0A3B0:  MOVWF  xEA
0A3B2:  MOVLB  1
0A3B4:  BCF    x61.0
0A3B6:  CLRF   x73
0A3B8:  CLRF   x72
0A3BA:  CLRF   x71
0A3BC:  CLRF   x70
0A3BE:  CLRF   x77
0A3C0:  CLRF   x76
0A3C2:  CLRF   x75
0A3C4:  CLRF   x74
0A3C6:  CLRF   x7B
0A3C8:  CLRF   x7A
0A3CA:  CLRF   x79
0A3CC:  CLRF   x78
0A3CE:  CLRF   x7D
0A3D0:  CLRF   x7C
0A3D2:  MOVLB  E
0A3D4:  BCF    x91.5
0A3D6:  MOVLW  00
0A3D8:  MOVWF  x90
0A3DA:  MOVLW  03
0A3DC:  MOVWF  x8E
0A3DE:  MOVLW  2A
0A3E0:  MOVWF  x91
0A3E2:  MOVLW  C4
0A3E4:  MOVWF  F88
0A3E6:  MOVWF  F88
0A3E8:  MOVWF  F88
0A3EA:  MOVLB  1
0A3EC:  CLRF   xCE
0A3EE:  CLRF   xCF
0A3F0:  CLRF   xD0
0A3F2:  CLRF   xD1
0A3F4:  BCF    F95.5
0A3F6:  MOVLW  40
0A3F8:  MOVWF  F94
0A3FA:  MOVLW  9F
0A3FC:  MOVWF  F92
0A3FE:  MOVLW  3A
0A400:  MOVWF  F95
0A402:  MOVLW  93
0A404:  MOVWF  F89
0A406:  MOVWF  F89
0A408:  MOVLB  4
0A40A:  CLRF   xBD
0A40C:  CLRF   xBE
0A40E:  MOVLB  5
0A410:  CLRF   x5F
0A412:  CLRF   x60
0A414:  MOVLB  1
0A416:  BCF    x61.1
0A418:  MOVLB  5
0A41A:  CLRF   x61
0A41C:  BSF    F9E.3
0A41E:  MOVLW  7C
0A420:  MOVWF  F9A
0A422:  MOVLW  00
0A424:  MOVWF  F9B
0A426:  MOVLW  A6
0A428:  MOVWF  F9D
0A42A:  MOVLW  90
0A42C:  MOVWF  F9C
0A42E:  CLRF   x63
0A430:  CLRF   x62
0A432:  CLRF   x67
0A434:  CLRF   x66
0A436:  CLRF   x65
0A438:  CLRF   x64
0A43A:  MOVLW  C4
0A43C:  MOVWF  F88
0A43E:  BSF    F83.7
0A440:  MOVLW  12
0A442:  MOVWF  03
0A444:  MOVLW  FA
0A446:  MOVLB  6
0A448:  MOVWF  xF5
0A44A:  MOVLB  0
0A44C:  CALL   03A4
0A450:  DECFSZ 03,F
0A452:  BRA    A456
0A454:  BRA    A45A
0A456:  MOVLB  5
0A458:  BRA    A444
0A45A:  MOVLB  F
0A45C:  CLRF   x0C
0A45E:  CLRF   x14
0A460:  CLRF   x1C
0A462:  CLRF   x21
0A464:  CLRF   x29
0A466:  CLRF   x35
0A468:  CLRF   x36
0A46A:  CLRF   x37
0A46C:  CLRF   x34
0A46E:  CLRF   x31
0A470:  CLRF   x32
0A472:  CLRF   x33
0A474:  CLRF   x30
0A476:  MOVLW  5B
0A478:  MOVLB  5
0A47A:  MOVWF  x6B
0A47C:  MOVLW  F4
0A47E:  MOVWF  x6A
0A480:  MOVLW  5C
0A482:  MOVWF  x6F
0A484:  MOVLW  38
0A486:  MOVWF  x6E
0A488:  MOVLW  61
0A48A:  MOVWF  x73
0A48C:  MOVLW  88
0A48E:  MOVWF  x72
0A490:  MOVLW  63
0A492:  MOVWF  x77
0A494:  MOVLW  7C
0A496:  MOVWF  x76
0A498:  MOVLW  65
0A49A:  MOVWF  x7B
0A49C:  MOVLW  34
0A49E:  MOVWF  x7A
0A4A0:  MOVLW  66
0A4A2:  MOVWF  x7F
0A4A4:  MOVLW  CA
0A4A6:  MOVWF  x7E
0A4A8:  MOVLW  68
0A4AA:  MOVWF  x83
0A4AC:  MOVLW  EC
0A4AE:  MOVWF  x82
0A4B0:  MOVLW  70
0A4B2:  MOVWF  x87
0A4B4:  MOVLW  EA
0A4B6:  MOVWF  x86
0A4B8:  MOVLW  73
0A4BA:  MOVWF  x8B
0A4BC:  MOVLW  D6
0A4BE:  MOVWF  x8A
0A4C0:  MOVLW  75
0A4C2:  MOVWF  x8F
0A4C4:  MOVLW  3C
0A4C6:  MOVWF  x8E
0A4C8:  MOVLW  77
0A4CA:  MOVWF  x93
0A4CC:  MOVLW  1C
0A4CE:  MOVWF  x92
0A4D0:  MOVLW  7A
0A4D2:  MOVWF  x97
0A4D4:  MOVLW  EA
0A4D6:  MOVWF  x96
0A4D8:  MOVLW  80
0A4DA:  MOVWF  x9B
0A4DC:  MOVLW  6A
0A4DE:  MOVWF  x9A
0A4E0:  MOVLW  84
0A4E2:  MOVWF  x9F
0A4E4:  MOVLW  1A
0A4E6:  MOVWF  x9E
0A4E8:  MOVLW  89
0A4EA:  MOVWF  xA3
0A4EC:  MOVLW  4E
0A4EE:  MOVWF  xA2
0A4F0:  MOVLW  89
0A4F2:  MOVWF  xA7
0A4F4:  MOVLW  54
0A4F6:  MOVWF  xA6
0A4F8:  MOVLW  8F
0A4FA:  MOVWF  xAB
0A4FC:  MOVLW  D0
0A4FE:  MOVWF  xAA
0A500:  MOVLW  95
0A502:  MOVWF  xAF
0A504:  MOVLW  4A
0A506:  MOVWF  xAE
0A508:  MOVLW  9C
0A50A:  MOVWF  xB3
0A50C:  MOVLW  8E
0A50E:  MOVWF  xB2
0A510:  MOVLW  9D
0A512:  MOVWF  xB7
0A514:  MOVLW  E4
0A516:  MOVWF  xB6
0A518:  MOVLW  A0
0A51A:  MOVWF  xBB
0A51C:  MOVLW  42
0A51E:  MOVWF  xBA
0A520:  MOVLW  A0
0A522:  MOVWF  xBF
0A524:  MOVLW  4E
0A526:  MOVWF  xBE
0A528:  MOVLW  A0
0A52A:  MOVWF  xC3
0A52C:  MOVLW  5A
0A52E:  MOVWF  xC2
0A530:  BRA    A704
0A532:  DATA 02,00
0A534:  DATA 1A,00
0A536:  DATA 00,0C
0A538:  DATA 00,20
0A53A:  DATA 78,23
0A53C:  DATA D7,0A
0A53E:  DATA 7D,19
0A540:  DATA 99,9A
0A542:  DATA 7B,4C
0A544:  DATA CC,CD
0A546:  DATA 14,C0
0A548:  DATA 00,0C
0A54A:  DATA 80,78
0A54C:  DATA 23,D7
0A54E:  DATA 0A,7D
0A550:  DATA 19,99
0A552:  DATA 9A,7B
0A554:  DATA 4C,CC
0A556:  DATA CD,14
0A558:  DATA C0,00
0A55A:  DATA 01,80
0A55C:  DATA 02,09
0A55E:  DATA C0,00
0A560:  DATA 05,80
0A562:  DATA 7F,00
0A564:  DATA 00,00
0A566:  DATA 7F,0B
0A568:  DATA C0,00
0A56A:  DATA 05,80
0A56C:  DATA 7F,00
0A56E:  DATA 00,00
0A570:  DATA 7F,07
0A572:  DATA C0,00
0A574:  DATA 01,80
0A576:  DATA 7F,17
0A578:  DATA C0,00
0A57A:  DATA 01,80
0A57C:  DATA 7F,17
0A57E:  DATA C0,00
0A580:  DATA 04,80
0A582:  DATA 79,B7
0A584:  DATA F3,BD
0A586:  DATA 04,C0
0A588:  DATA 00,04
0A58A:  DATA 80,7C
0A58C:  DATA 59,DF
0A58E:  DATA 4E,04
0A590:  DATA C0,00
0A592:  DATA 04,80
0A594:  DATA 78,0A
0A596:  DATA 28,88
0A598:  DATA 04,C0
0A59A:  DATA 00,04
0A59C:  DATA 80,78
0A59E:  DATA 05,EA
0A5A0:  DATA 16,04
0A5A2:  DATA C0,00
0A5A4:  DATA 04,80
0A5A6:  DATA 78,1E
0A5A8:  DATA 33,D7
0A5AA:  DATA 04,C0
0A5AC:  DATA 00,04
0A5AE:  DATA 80,77
0A5B0:  DATA 68,7B
0A5B2:  DATA BB,04
0A5B4:  DATA C0,00
0A5B6:  DATA 04,80
0A5B8:  DATA 77,68
0A5BA:  DATA 0D,C6
0A5BC:  DATA 76,40
0A5BE:  DATA EB,00
0A5C0:  DATA 0E,41
0A5C2:  DATA 62,00
0A5C4:  DATA 17,41
0A5C6:  DATA D2,00
0A5C8:  DATA 3C,45
0A5CA:  DATA 23,00
0A5CC:  DATA 02,05
0A5CE:  DATA 68,C4
0A5D0:  DATA 05,02
0A5D2:  DATA 05,6C
0A5D4:  DATA C7,05
0A5D6:  DATA 02,05
0A5D8:  DATA 70,CA
0A5DA:  DATA 05,02
0A5DC:  DATA 05,74
0A5DE:  DATA D1,05
0A5E0:  DATA 02,05
0A5E2:  DATA 78,D8
0A5E4:  DATA 05,02
0A5E6:  DATA 05,7C
0A5E8:  DATA E0,05
0A5EA:  DATA 02,05
0A5EC:  DATA 80,E8
0A5EE:  DATA 05,02
0A5F0:  DATA 05,84
0A5F2:  DATA ED,05
0A5F4:  DATA 02,05
0A5F6:  DATA 88,F2
0A5F8:  DATA 05,02
0A5FA:  DATA 05,8C
0A5FC:  DATA F6,05
0A5FE:  DATA 02,05
0A600:  DATA 90,FA
0A602:  DATA 05,02
0A604:  DATA 05,94
0A606:  DATA 01,06
0A608:  DATA 02,05
0A60A:  DATA 98,07
0A60C:  DATA 06,02
0A60E:  DATA 05,9C
0A610:  DATA 0D,06
0A612:  DATA 02,05
0A614:  DATA A0,13
0A616:  DATA 06,02
0A618:  DATA 05,A4
0A61A:  DATA 19,06
0A61C:  DATA 02,05
0A61E:  DATA A8,1E
0A620:  DATA 06,02
0A622:  DATA 05,AC
0A624:  DATA 27,06
0A626:  DATA 02,05
0A628:  DATA B0,2F
0A62A:  DATA 06,02
0A62C:  DATA 05,B4
0A62E:  DATA 36,06
0A630:  DATA 02,05
0A632:  DATA B8,3D
0A634:  DATA 06,02
0A636:  DATA 05,BC
0A638:  DATA 45,06
0A63A:  DATA 02,05
0A63C:  DATA C0,4E
0A63E:  DATA 06,89
0A640:  DATA 05,C4
0A642:  DATA 67,72
0A644:  DATA 00,67
0A646:  DATA 73,00
0A648:  DATA 67,43
0A64A:  DATA 68,4D
0A64C:  DATA 61,70
0A64E:  DATA 00,73
0A650:  DATA 43,68
0A652:  DATA 4D,61
0A654:  DATA 70,00
0A656:  DATA 67,43
0A658:  DATA 68,4D
0A65A:  DATA 6F,64
0A65C:  DATA 65,00
0A65E:  DATA 73,43
0A660:  DATA 68,4D
0A662:  DATA 6F,64
0A664:  DATA 65,00
0A666:  DATA 67,50
0A668:  DATA 49,44
0A66A:  DATA 00,73
0A66C:  DATA 50,49
0A66E:  DATA 44,00
0A670:  DATA 67,53
0A672:  DATA 50,00
0A674:  DATA 73,53
0A676:  DATA 50,00
0A678:  DATA 67,53
0A67A:  DATA 43,61
0A67C:  DATA 6C,73
0A67E:  DATA 00,67
0A680:  DATA 53,43
0A682:  DATA 61,6C
0A684:  DATA 00,73
0A686:  DATA 53,43
0A688:  DATA 61,6C
0A68A:  DATA 00,67
0A68C:  DATA 4D,43
0A68E:  DATA 61,6C
0A690:  DATA 00,73
0A692:  DATA 4D,43
0A694:  DATA 61,6C
0A696:  DATA 00,67
0A698:  DATA 4D,6F
0A69A:  DATA 6E,00
0A69C:  DATA 67,50
0A69E:  DATA 49,44
0A6A0:  DATA 64,61
0A6A2:  DATA 74,61
0A6A4:  DATA 00,67
0A6A6:  DATA 49,50
0A6A8:  DATA 64,61
0A6AA:  DATA 74,61
0A6AC:  DATA 00,67
0A6AE:  DATA 4D,61
0A6B0:  DATA 6E,4F
0A6B2:  DATA 50,00
0A6B4:  DATA 73,4D
0A6B6:  DATA 61,6E
0A6B8:  DATA 4F,50
0A6BA:  DATA 00,73
0A6BC:  DATA 46,69
0A6BE:  DATA 6C,74
0A6C0:  DATA 4F,6E
0A6C2:  DATA 00,73
0A6C4:  DATA 46,69
0A6C6:  DATA 6C,74
0A6C8:  DATA 4F,66
0A6CA:  DATA 66,04
0A6CC:  DATA C0,00
0A6CE:  DATA 33,80
0A6D0:  DATA 59,06
0A6D2:  DATA 01,61
0A6D4:  DATA 06,02
0A6D6:  DATA 71,06
0A6D8:  DATA 53,55
0A6DA:  DATA 43,43
0A6DC:  DATA 45,53
0A6DE:  DATA 53,00
0A6E0:  DATA 49,4E
0A6E2:  DATA 56,41
0A6E4:  DATA 4C,49
0A6E6:  DATA 44,20
0A6E8:  DATA 43,4F
0A6EA:  DATA 4D,4D
0A6EC:  DATA 41,4E
0A6EE:  DATA 44,00
0A6F0:  DATA 49,4E
0A6F2:  DATA 56,41
0A6F4:  DATA 4C,49
0A6F6:  DATA 44,20
0A6F8:  DATA 50,41
0A6FA:  DATA 52,41
0A6FC:  DATA 4D,45
0A6FE:  DATA 54,45
0A700:  DATA 52,00
0A702:  DATA 00,00
0A704:  MOVLW  00
0A706:  MOVWF  FF8
0A708:  MOVLW  A5
0A70A:  MOVWF  FF7
0A70C:  MOVLW  32
0A70E:  MOVWF  FF6
0A710:  TBLRD*+
0A712:  MOVF   FF5,W
0A714:  MOVWF  00
0A716:  XORLW  00
0A718:  BZ    A740
0A71A:  TBLRD*+
0A71C:  MOVF   FF5,W
0A71E:  MOVWF  01
0A720:  BTFSC  FE8.7
0A722:  BRA    A72E
0A724:  ANDLW  3F
0A726:  MOVWF  FEA
0A728:  TBLRD*+
0A72A:  MOVFF  FF5,FE9
0A72E:  BTFSC  01.6
0A730:  TBLRD*+
0A732:  BTFSS  01.6
0A734:  TBLRD*+
0A736:  MOVFF  FF5,FEE
0A73A:  DCFSNZ 00,F
0A73C:  BRA    A710
0A73E:  BRA    A732
0A740:  CLRF   FF8
0A742:  MOVLB  6
0A744:  CLRF   x86
0A746:  MOVLW  64
0A748:  MOVWF  x85
0A74A:  CLRF   x88
0A74C:  CLRF   x87
0A74E:  CLRF   x8A
0A750:  CLRF   x89
.................... {
....................    int16 loopDelay = 100;
....................    int16 controlCounter = 0;
....................    int16 debugCounter = 0;
....................    
....................    char pBuff[100];
....................    
....................    IO_init();                    // set up IO 
0A752:  MOVLB  0
0A754:  GOTO   03CE
....................    params_init();                // load parameters
0A758:  GOTO   064C
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0A75C:  GOTO   0A9A
....................    control_init();               // initialize the output control DACs
0A760:  GOTO   0B32
....................    serial_init();                // setup the serial port
0A764:  GOTO   0CE0
....................    event_timer_init();
0A768:  GOTO   0D02
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0A76C:  MOVLW  C0
0A76E:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
....................       pBuff[0] = '\0';
0A770:  MOVLB  6
0A772:  CLRF   x8B
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
0A774:  MOVLB  0
0A776:  GOTO   10DA
....................       sensor_monitor_task();     //get magnetoresistive sensor data
0A77A:  GOTO   44A8
....................       
....................       if (controlCounter >= 2){
0A77E:  MOVLB  6
0A780:  MOVF   x88,F
0A782:  BNZ   A78A
0A784:  MOVF   x87,W
0A786:  SUBLW  01
0A788:  BC    A798
....................          control_task();
0A78A:  MOVLB  0
0A78C:  GOTO   5024
....................          controlCounter = 0;
0A790:  MOVLB  6
0A792:  CLRF   x88
0A794:  CLRF   x87
....................       }else controlCounter++;
0A796:  BRA    A79E
0A798:  INCF   x87,F
0A79A:  BTFSC  FD8.2
0A79C:  INCF   x88,F
....................       
....................       serial_task();             //serial port
0A79E:  MOVLB  0
0A7A0:  GOTO   50CE
.................... 
....................       #ifdef DEBUG_1
....................       if (debugCounter >= 0){
....................          static int8 ch = 0;
....................          sprintf(pBuff+strlen(pBuff), "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A7A4:  MOVLW  06
0A7A6:  MOVLB  7
0A7A8:  MOVWF  x31
0A7AA:  MOVLW  8B
0A7AC:  MOVWF  x30
0A7AE:  MOVLB  0
0A7B0:  CALL   55E6
0A7B4:  MOVF   01,W
0A7B6:  ADDLW  8B
0A7B8:  MOVLB  6
0A7BA:  MOVWF  xEF
0A7BC:  MOVLW  06
0A7BE:  ADDWFC 02,W
0A7C0:  MOVWF  xF0
0A7C2:  MOVLW  01
0A7C4:  ADDWF  x83,W
0A7C6:  MOVWF  xF1
0A7C8:  MOVF   x83,W
0A7CA:  MULLW  2D
0A7CC:  MOVF   FF3,W
0A7CE:  CLRF   xF3
0A7D0:  MOVWF  xF2
0A7D2:  MOVLW  08
0A7D4:  ADDWF  xF2,W
0A7D6:  MOVWF  01
0A7D8:  MOVLW  00
0A7DA:  ADDWFC xF3,W
0A7DC:  MOVWF  03
0A7DE:  MOVF   01,W
0A7E0:  ADDLW  07
0A7E2:  MOVWF  FE9
0A7E4:  MOVLW  01
0A7E6:  ADDWFC 03,W
0A7E8:  MOVWF  FEA
0A7EA:  MOVFF  FEF,6F2
0A7EE:  MOVFF  FEC,6F3
0A7F2:  MOVFF  FEC,6F4
0A7F6:  MOVFF  FEC,6F5
0A7FA:  MOVF   x83,W
0A7FC:  MULLW  2D
0A7FE:  MOVF   FF3,W
0A800:  CLRF   xF7
0A802:  MOVWF  xF6
0A804:  MOVLW  0C
0A806:  ADDWF  xF6,W
0A808:  MOVWF  01
0A80A:  MOVLW  00
0A80C:  ADDWFC xF7,W
0A80E:  MOVWF  03
0A810:  MOVF   01,W
0A812:  ADDLW  07
0A814:  MOVWF  FE9
0A816:  MOVLW  01
0A818:  ADDWFC 03,W
0A81A:  MOVWF  FEA
0A81C:  MOVFF  FEF,6F6
0A820:  MOVFF  FEC,6F7
0A824:  MOVFF  FEC,6F8
0A828:  MOVFF  FEC,6F9
0A82C:  MOVFF  6F0,563
0A830:  MOVFF  6EF,562
0A834:  MOVLW  58
0A836:  MOVWF  FF6
0A838:  MOVLW  03
0A83A:  MOVWF  FF7
0A83C:  MOVLW  08
0A83E:  MOVWF  xFE
0A840:  MOVLB  0
0A842:  CALL   563E
0A846:  MOVFF  6F1,6FA
0A84A:  MOVLW  1B
0A84C:  MOVLB  6
0A84E:  MOVWF  xFB
0A850:  MOVLB  0
0A852:  CALL   5666
0A856:  MOVLW  2C
0A858:  MOVLB  7
0A85A:  MOVWF  x3F
0A85C:  MOVLB  0
0A85E:  CALL   561E
0A862:  MOVLW  89
0A864:  MOVWF  FE9
0A866:  MOVFF  6F5,735
0A86A:  MOVFF  6F4,734
0A86E:  MOVFF  6F3,733
0A872:  MOVFF  6F2,732
0A876:  MOVLB  7
0A878:  CLRF   x36
0A87A:  MOVLB  0
0A87C:  CALL   57BC
0A880:  MOVLW  2C
0A882:  MOVLB  7
0A884:  MOVWF  x3F
0A886:  MOVLB  0
0A888:  CALL   561E
0A88C:  MOVLW  89
0A88E:  MOVWF  FE9
0A890:  MOVFF  6F9,735
0A894:  MOVFF  6F8,734
0A898:  MOVFF  6F7,733
0A89C:  MOVFF  6F6,732
0A8A0:  MOVLB  7
0A8A2:  CLRF   x36
0A8A4:  MOVLB  0
0A8A6:  CALL   57BC
0A8AA:  MOVLW  0A
0A8AC:  MOVLB  7
0A8AE:  MOVWF  x3F
0A8B0:  MOVLB  0
0A8B2:  CALL   561E
....................          sprintf(pBuff+strlen(pBuff), "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
0A8B6:  MOVLW  06
0A8B8:  MOVLB  7
0A8BA:  MOVWF  x31
0A8BC:  MOVLW  8B
0A8BE:  MOVWF  x30
0A8C0:  MOVLB  0
0A8C2:  CALL   55E6
0A8C6:  MOVF   01,W
0A8C8:  ADDLW  8B
0A8CA:  MOVLB  6
0A8CC:  MOVWF  xEF
0A8CE:  MOVLW  06
0A8D0:  ADDWFC 02,W
0A8D2:  MOVWF  xF0
0A8D4:  MOVLW  01
0A8D6:  ADDWF  x83,W
0A8D8:  MOVWF  xF1
0A8DA:  MOVF   x83,W
0A8DC:  MULLW  2D
0A8DE:  MOVF   FF3,W
0A8E0:  CLRF   xF3
0A8E2:  MOVWF  xF2
0A8E4:  MOVLW  1D
0A8E6:  ADDWF  xF2,W
0A8E8:  MOVWF  01
0A8EA:  MOVLW  00
0A8EC:  ADDWFC xF3,W
0A8EE:  MOVWF  03
0A8F0:  MOVF   01,W
0A8F2:  ADDLW  07
0A8F4:  MOVWF  FE9
0A8F6:  MOVLW  01
0A8F8:  ADDWFC 03,W
0A8FA:  MOVWF  FEA
0A8FC:  MOVFF  FEF,6F2
0A900:  MOVFF  FEC,6F3
0A904:  MOVFF  FEC,6F4
0A908:  MOVFF  FEC,6F5
0A90C:  MOVFF  6F0,563
0A910:  MOVFF  6EF,562
0A914:  MOVLW  6E
0A916:  MOVWF  FF6
0A918:  MOVLW  03
0A91A:  MOVWF  FF7
0A91C:  MOVLW  08
0A91E:  MOVWF  xFE
0A920:  MOVLB  0
0A922:  CALL   563E
0A926:  MOVFF  6F1,6FA
0A92A:  MOVLW  1B
0A92C:  MOVLB  6
0A92E:  MOVWF  xFB
0A930:  MOVLB  0
0A932:  CALL   5666
0A936:  MOVLW  2C
0A938:  MOVLB  7
0A93A:  MOVWF  x3F
0A93C:  MOVLB  0
0A93E:  CALL   561E
0A942:  MOVLW  89
0A944:  MOVWF  FE9
0A946:  MOVFF  6F5,735
0A94A:  MOVFF  6F4,734
0A94E:  MOVFF  6F3,733
0A952:  MOVFF  6F2,732
0A956:  MOVLW  03
0A958:  MOVLB  7
0A95A:  MOVWF  x36
0A95C:  MOVLB  0
0A95E:  CALL   57BC
0A962:  MOVLW  0A
0A964:  MOVLB  7
0A966:  MOVWF  x3F
0A968:  MOVLB  0
0A96A:  CALL   561E
....................          if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
0A96E:  MOVLB  6
0A970:  MOVF   x83,W
0A972:  MULLW  03
0A974:  MOVF   FF3,W
0A976:  CLRF   xF0
0A978:  MOVWF  xEF
0A97A:  MOVLW  02
0A97C:  ADDWF  xEF,W
0A97E:  MOVWF  01
0A980:  MOVLW  00
0A982:  ADDWFC xF0,W
0A984:  MOVWF  03
0A986:  MOVF   01,W
0A988:  ADDLW  62
0A98A:  MOVWF  FE9
0A98C:  MOVLW  01
0A98E:  ADDWFC 03,W
0A990:  MOVWF  FEA
0A992:  BTFSS  FEF.0
0A994:  BRA    AA3A
0A996:  MOVLW  06
0A998:  MOVLB  7
0A99A:  MOVWF  x31
0A99C:  MOVLW  8B
0A99E:  MOVWF  x30
0A9A0:  MOVLB  0
0A9A2:  CALL   55E6
0A9A6:  MOVFF  02,03
0A9AA:  MOVF   01,W
0A9AC:  ADDLW  8B
0A9AE:  MOVLB  6
0A9B0:  MOVWF  xEF
0A9B2:  MOVLW  06
0A9B4:  ADDWFC 02,W
0A9B6:  MOVWF  xF0
0A9B8:  MOVLW  01
0A9BA:  ADDWF  x83,W
0A9BC:  MOVWF  xF1
0A9BE:  MOVF   x83,W
0A9C0:  MULLW  03
0A9C2:  MOVF   FF3,W
0A9C4:  CLRF   xF3
0A9C6:  MOVWF  xF2
0A9C8:  MOVLW  62
0A9CA:  ADDWF  xF2,W
0A9CC:  MOVWF  FE9
0A9CE:  MOVLW  01
0A9D0:  ADDWFC xF3,W
0A9D2:  MOVWF  FEA
0A9D4:  MOVFF  FEC,6F5
0A9D8:  MOVF   FED,F
0A9DA:  MOVFF  FEF,6F4
0A9DE:  MOVFF  6F0,563
0A9E2:  MOVFF  6EF,562
0A9E6:  MOVLW  80
0A9E8:  MOVWF  FF6
0A9EA:  MOVLW  03
0A9EC:  MOVWF  FF7
0A9EE:  MOVLW  08
0A9F0:  MOVWF  xFE
0A9F2:  MOVLB  0
0A9F4:  CALL   563E
0A9F8:  MOVFF  6F1,6FA
0A9FC:  MOVLW  1B
0A9FE:  MOVLB  6
0AA00:  MOVWF  xFB
0AA02:  MOVLB  0
0AA04:  CALL   5666
0AA08:  MOVLW  8A
0AA0A:  MOVWF  FF6
0AA0C:  MOVLW  03
0AA0E:  MOVWF  FF7
0AA10:  MOVLW  03
0AA12:  MOVLB  6
0AA14:  MOVWF  xFE
0AA16:  MOVLB  0
0AA18:  CALL   563E
0AA1C:  MOVLW  10
0AA1E:  MOVWF  FE9
0AA20:  MOVFF  6F5,6F7
0AA24:  MOVFF  6F4,6F6
0AA28:  CALL   5964
0AA2C:  MOVLW  0A
0AA2E:  MOVLB  7
0AA30:  MOVWF  x3F
0AA32:  MOVLB  0
0AA34:  CALL   561E
0AA38:  BRA    AADC
....................          else                    sprintf(pBuff+strlen(pBuff), "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0AA3A:  MOVLW  06
0AA3C:  MOVLB  7
0AA3E:  MOVWF  x31
0AA40:  MOVLW  8B
0AA42:  MOVWF  x30
0AA44:  MOVLB  0
0AA46:  CALL   55E6
0AA4A:  MOVFF  02,03
0AA4E:  MOVF   01,W
0AA50:  ADDLW  8B
0AA52:  MOVLB  6
0AA54:  MOVWF  xEF
0AA56:  MOVLW  06
0AA58:  ADDWFC 02,W
0AA5A:  MOVWF  xF0
0AA5C:  MOVLW  01
0AA5E:  ADDWF  x83,W
0AA60:  MOVWF  xF1
0AA62:  MOVF   x83,W
0AA64:  MULLW  03
0AA66:  MOVF   FF3,W
0AA68:  CLRF   xF3
0AA6A:  MOVWF  xF2
0AA6C:  MOVLW  62
0AA6E:  ADDWF  xF2,W
0AA70:  MOVWF  FE9
0AA72:  MOVLW  01
0AA74:  ADDWFC xF3,W
0AA76:  MOVWF  FEA
0AA78:  MOVFF  FEC,6F5
0AA7C:  MOVF   FED,F
0AA7E:  MOVFF  FEF,6F4
0AA82:  MOVFF  6F0,563
0AA86:  MOVFF  6EF,562
0AA8A:  MOVLW  92
0AA8C:  MOVWF  FF6
0AA8E:  MOVLW  03
0AA90:  MOVWF  FF7
0AA92:  MOVLW  08
0AA94:  MOVWF  xFE
0AA96:  MOVLB  0
0AA98:  CALL   563E
0AA9C:  MOVFF  6F1,6FA
0AAA0:  MOVLW  1B
0AAA2:  MOVLB  6
0AAA4:  MOVWF  xFB
0AAA6:  MOVLB  0
0AAA8:  CALL   5666
0AAAC:  MOVLW  9C
0AAAE:  MOVWF  FF6
0AAB0:  MOVLW  03
0AAB2:  MOVWF  FF7
0AAB4:  MOVLW  03
0AAB6:  MOVLB  6
0AAB8:  MOVWF  xFE
0AABA:  MOVLB  0
0AABC:  CALL   563E
0AAC0:  MOVLW  10
0AAC2:  MOVWF  FE9
0AAC4:  MOVFF  6F5,6F7
0AAC8:  MOVFF  6F4,6F6
0AACC:  CALL   5964
0AAD0:  MOVLW  0A
0AAD2:  MOVLB  7
0AAD4:  MOVWF  x3F
0AAD6:  MOVLB  0
0AAD8:  CALL   561E
....................          ch = !ch;
0AADC:  MOVLB  6
0AADE:  MOVF   x83,F
0AAE0:  BZ    AAE6
0AAE2:  MOVLW  00
0AAE4:  BRA    AAE8
0AAE6:  MOVLW  01
0AAE8:  MOVWF  x83
....................          debugCounter = 0;
0AAEA:  CLRF   x8A
0AAEC:  CLRF   x89
....................       } else debugCounter++;
.................... //!      serial_out(pBuff);
....................       fprintf(ICD_STREAM, "%s", pBuff);
0AAEE:  MOVLW  06
0AAF0:  MOVWF  FEA
0AAF2:  MOVLW  8B
0AAF4:  MOVWF  FE9
0AAF6:  MOVLB  0
0AAF8:  GOTO   5A7E
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0AAFC:  GOTO   A234
....................       
....................       delay_ms(loopDelay);
0AB00:  MOVFF  686,6EF
0AB04:  MOVLB  6
0AB06:  INCF   xEF,F
0AB08:  DECF   xEF,F
0AB0A:  BTFSC  FD8.2
0AB0C:  BRA    AB1A
0AB0E:  SETF   xF5
0AB10:  MOVLB  0
0AB12:  CALL   03A4
0AB16:  MOVLB  6
0AB18:  BRA    AB08
0AB1A:  MOVFF  685,6F5
0AB1E:  MOVLB  0
0AB20:  CALL   03A4
0AB24:  BRA    A770
....................    }
.................... }
0AB26:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
