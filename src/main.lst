CCS PCH C Compiler, Version 5.109, 62303               27-May-25 15:57

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   27314 bytes (42%)
                           Largest free fragment is 38220
               RAM used:   1466 (41%) at main() level
                           1578 (44%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   676E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   021E
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
002F2:  DATA 32,30
002F4:  DATA 32,35
002F6:  DATA 30,35
002F8:  DATA 32,32
002FA:  DATA 00,00
002FC:  DATA 30,30
002FE:  DATA 30,30
00300:  DATA 00,00
00302:  DATA 56,4F
00304:  DATA 4C,54
00306:  DATA 41,47
00308:  DATA 45,2C
0030A:  DATA 00,00
0030C:  DATA 4D,41
0030E:  DATA 47,53
00310:  DATA 45,4E
00312:  DATA 53,2C
00314:  DATA 00,00
*
007CC:  MOVLB  5
007CE:  MOVF   xDD,W
007D0:  MULWF  xDF
007D2:  MOVFF  FF3,01
007D6:  MOVFF  FF4,00
007DA:  MULWF  xE0
007DC:  MOVF   FF3,W
007DE:  ADDWF  00,F
007E0:  MOVF   xDE,W
007E2:  MULWF  xDF
007E4:  MOVF   FF3,W
007E6:  ADDWFC 00,W
007E8:  MOVWF  02
007EA:  MOVLB  0
007EC:  RETURN 0
*
009C4:  MOVLW  8E
009C6:  MOVWF  00
009C8:  MOVFF  615,01
009CC:  MOVFF  614,02
009D0:  CLRF   03
009D2:  MOVF   01,F
009D4:  BNZ   09E8
009D6:  MOVFF  02,01
009DA:  CLRF   02
009DC:  MOVLW  08
009DE:  SUBWF  00,F
009E0:  MOVF   01,F
009E2:  BNZ   09E8
009E4:  CLRF   00
009E6:  BRA    09F8
009E8:  BCF    FD8.0
009EA:  BTFSC  01.7
009EC:  BRA    09F6
009EE:  RLCF   02,F
009F0:  RLCF   01,F
009F2:  DECF   00,F
009F4:  BRA    09E8
009F6:  BCF    01.7
009F8:  RETURN 0
009FA:  MOVLB  6
009FC:  MOVF   x10,W
009FE:  BTFSC  FD8.2
00A00:  BRA    0AE4
00A02:  MOVWF  00
00A04:  MOVF   x14,W
00A06:  BTFSC  FD8.2
00A08:  BRA    0AE4
00A0A:  ADDWF  00,F
00A0C:  BNC   0A16
00A0E:  MOVLW  81
00A10:  ADDWF  00,F
00A12:  BC    0AE4
00A14:  BRA    0A1E
00A16:  MOVLW  7F
00A18:  SUBWF  00,F
00A1A:  BNC   0AE4
00A1C:  BZ    0AE4
00A1E:  MOVFF  611,618
00A22:  MOVF   x15,W
00A24:  XORWF  x18,F
00A26:  BSF    x11.7
00A28:  BSF    x15.7
00A2A:  MOVF   x13,W
00A2C:  MULWF  x17
00A2E:  MOVFF  FF4,61A
00A32:  MOVF   x12,W
00A34:  MULWF  x16
00A36:  MOVFF  FF4,03
00A3A:  MOVFF  FF3,619
00A3E:  MULWF  x17
00A40:  MOVF   FF3,W
00A42:  ADDWF  x1A,F
00A44:  MOVF   FF4,W
00A46:  ADDWFC x19,F
00A48:  MOVLW  00
00A4A:  ADDWFC 03,F
00A4C:  MOVF   x13,W
00A4E:  MULWF  x16
00A50:  MOVF   FF3,W
00A52:  ADDWF  x1A,F
00A54:  MOVF   FF4,W
00A56:  ADDWFC x19,F
00A58:  MOVLW  00
00A5A:  CLRF   02
00A5C:  ADDWFC 03,F
00A5E:  ADDWFC 02,F
00A60:  MOVF   x11,W
00A62:  MULWF  x17
00A64:  MOVF   FF3,W
00A66:  ADDWF  x19,F
00A68:  MOVF   FF4,W
00A6A:  ADDWFC 03,F
00A6C:  MOVLW  00
00A6E:  ADDWFC 02,F
00A70:  MOVF   x11,W
00A72:  MULWF  x16
00A74:  MOVF   FF3,W
00A76:  ADDWF  03,F
00A78:  MOVF   FF4,W
00A7A:  ADDWFC 02,F
00A7C:  MOVLW  00
00A7E:  CLRF   01
00A80:  ADDWFC 01,F
00A82:  MOVF   x13,W
00A84:  MULWF  x15
00A86:  MOVF   FF3,W
00A88:  ADDWF  x19,F
00A8A:  MOVF   FF4,W
00A8C:  ADDWFC 03,F
00A8E:  MOVLW  00
00A90:  ADDWFC 02,F
00A92:  ADDWFC 01,F
00A94:  MOVF   x12,W
00A96:  MULWF  x15
00A98:  MOVF   FF3,W
00A9A:  ADDWF  03,F
00A9C:  MOVF   FF4,W
00A9E:  ADDWFC 02,F
00AA0:  MOVLW  00
00AA2:  ADDWFC 01,F
00AA4:  MOVF   x11,W
00AA6:  MULWF  x15
00AA8:  MOVF   FF3,W
00AAA:  ADDWF  02,F
00AAC:  MOVF   FF4,W
00AAE:  ADDWFC 01,F
00AB0:  INCF   00,F
00AB2:  BTFSC  01.7
00AB4:  BRA    0AC0
00AB6:  RLCF   x19,F
00AB8:  RLCF   03,F
00ABA:  RLCF   02,F
00ABC:  RLCF   01,F
00ABE:  DECF   00,F
00AC0:  MOVLW  00
00AC2:  BTFSS  x19.7
00AC4:  BRA    0ADA
00AC6:  INCF   03,F
00AC8:  ADDWFC 02,F
00ACA:  ADDWFC 01,F
00ACC:  MOVF   01,W
00ACE:  BNZ   0ADA
00AD0:  MOVF   02,W
00AD2:  BNZ   0ADA
00AD4:  MOVF   03,W
00AD6:  BNZ   0ADA
00AD8:  INCF   00,F
00ADA:  BTFSC  x18.7
00ADC:  BSF    01.7
00ADE:  BTFSS  x18.7
00AE0:  BCF    01.7
00AE2:  BRA    0AEC
00AE4:  CLRF   00
00AE6:  CLRF   01
00AE8:  CLRF   02
00AEA:  CLRF   03
00AEC:  MOVLB  0
00AEE:  RETURN 0
00AF0:  MOVLW  80
00AF2:  BTFSS  FD8.1
00AF4:  BRA    0AFA
00AF6:  MOVLB  6
00AF8:  XORWF  x19,F
00AFA:  MOVLB  6
00AFC:  CLRF   x1E
00AFE:  CLRF   x1F
00B00:  MOVFF  615,61D
00B04:  MOVF   x19,W
00B06:  XORWF  x1D,F
00B08:  MOVF   x14,W
00B0A:  BTFSC  FD8.2
00B0C:  BRA    0CCC
00B0E:  MOVWF  x1C
00B10:  MOVWF  00
00B12:  MOVF   x18,W
00B14:  BTFSC  FD8.2
00B16:  BRA    0CDE
00B18:  SUBWF  x1C,F
00B1A:  BTFSC  FD8.2
00B1C:  BRA    0C24
00B1E:  BNC   0B9C
00B20:  MOVFF  619,622
00B24:  BSF    x22.7
00B26:  MOVFF  61A,621
00B2A:  MOVFF  61B,620
00B2E:  CLRF   x1F
00B30:  BCF    FD8.0
00B32:  RRCF   x22,F
00B34:  RRCF   x21,F
00B36:  RRCF   x20,F
00B38:  RRCF   x1F,F
00B3A:  DECFSZ x1C,F
00B3C:  BRA    0B2E
00B3E:  BTFSS  x1D.7
00B40:  BRA    0B48
00B42:  BSF    x1E.0
00B44:  BRA    0D06
00B46:  BCF    x1E.0
00B48:  BCF    x1C.0
00B4A:  BSF    x1E.4
00B4C:  MOVLW  06
00B4E:  MOVWF  FEA
00B50:  MOVLW  17
00B52:  MOVWF  FE9
00B54:  BRA    0D2C
00B56:  BCF    x1E.4
00B58:  BTFSC  x1D.7
00B5A:  BRA    0B70
00B5C:  BTFSS  x1C.0
00B5E:  BRA    0B86
00B60:  RRCF   x22,F
00B62:  RRCF   x21,F
00B64:  RRCF   x20,F
00B66:  RRCF   x1F,F
00B68:  INCF   00,F
00B6A:  BTFSC  FD8.2
00B6C:  BRA    0CFC
00B6E:  BRA    0B86
00B70:  BTFSC  x22.7
00B72:  BRA    0B8C
00B74:  BCF    FD8.0
00B76:  RLCF   x1F,F
00B78:  RLCF   x20,F
00B7A:  RLCF   x21,F
00B7C:  RLCF   x22,F
00B7E:  DECF   00,F
00B80:  BTFSC  FD8.2
00B82:  BRA    0CFC
00B84:  BRA    0B70
00B86:  BSF    x1E.6
00B88:  BRA    0C64
00B8A:  BCF    x1E.6
00B8C:  MOVFF  615,61D
00B90:  BTFSS  x15.7
00B92:  BRA    0B98
00B94:  BSF    x22.7
00B96:  BRA    0CEE
00B98:  BCF    x22.7
00B9A:  BRA    0CEE
00B9C:  MOVFF  618,61C
00BA0:  MOVFF  618,00
00BA4:  MOVF   x14,W
00BA6:  SUBWF  x1C,F
00BA8:  MOVFF  615,622
00BAC:  BSF    x22.7
00BAE:  MOVFF  616,621
00BB2:  MOVFF  617,620
00BB6:  CLRF   x1F
00BB8:  BCF    FD8.0
00BBA:  RRCF   x22,F
00BBC:  RRCF   x21,F
00BBE:  RRCF   x20,F
00BC0:  RRCF   x1F,F
00BC2:  DECFSZ x1C,F
00BC4:  BRA    0BB6
00BC6:  BTFSS  x1D.7
00BC8:  BRA    0BD0
00BCA:  BSF    x1E.1
00BCC:  BRA    0D06
00BCE:  BCF    x1E.1
00BD0:  BCF    x1C.0
00BD2:  BSF    x1E.5
00BD4:  MOVLW  06
00BD6:  MOVWF  FEA
00BD8:  MOVLW  1B
00BDA:  MOVWF  FE9
00BDC:  BRA    0D2C
00BDE:  BCF    x1E.5
00BE0:  BTFSC  x1D.7
00BE2:  BRA    0BF8
00BE4:  BTFSS  x1C.0
00BE6:  BRA    0C0E
00BE8:  RRCF   x22,F
00BEA:  RRCF   x21,F
00BEC:  RRCF   x20,F
00BEE:  RRCF   x1F,F
00BF0:  INCF   00,F
00BF2:  BTFSC  FD8.2
00BF4:  BRA    0CFC
00BF6:  BRA    0C0E
00BF8:  BTFSC  x22.7
00BFA:  BRA    0C14
00BFC:  BCF    FD8.0
00BFE:  RLCF   x1F,F
00C00:  RLCF   x20,F
00C02:  RLCF   x21,F
00C04:  RLCF   x22,F
00C06:  DECF   00,F
00C08:  BTFSC  FD8.2
00C0A:  BRA    0CFC
00C0C:  BRA    0BF8
00C0E:  BSF    x1E.7
00C10:  BRA    0C64
00C12:  BCF    x1E.7
00C14:  MOVFF  619,61D
00C18:  BTFSS  x19.7
00C1A:  BRA    0C20
00C1C:  BSF    x22.7
00C1E:  BRA    0CEE
00C20:  BCF    x22.7
00C22:  BRA    0CEE
00C24:  MOVFF  619,622
00C28:  BSF    x22.7
00C2A:  MOVFF  61A,621
00C2E:  MOVFF  61B,620
00C32:  BTFSS  x1D.7
00C34:  BRA    0C3E
00C36:  BCF    x22.7
00C38:  BSF    x1E.2
00C3A:  BRA    0D06
00C3C:  BCF    x1E.2
00C3E:  CLRF   x1F
00C40:  BCF    x1C.0
00C42:  MOVLW  06
00C44:  MOVWF  FEA
00C46:  MOVLW  17
00C48:  MOVWF  FE9
00C4A:  BRA    0D2C
00C4C:  BTFSC  x1D.7
00C4E:  BRA    0C88
00C50:  MOVFF  615,61D
00C54:  BTFSS  x1C.0
00C56:  BRA    0C64
00C58:  RRCF   x22,F
00C5A:  RRCF   x21,F
00C5C:  RRCF   x20,F
00C5E:  RRCF   x1F,F
00C60:  INCF   00,F
00C62:  BZ    0CFC
00C64:  BTFSS  x1F.7
00C66:  BRA    0C7E
00C68:  INCF   x20,F
00C6A:  BNZ   0C7E
00C6C:  INCF   x21,F
00C6E:  BNZ   0C7E
00C70:  INCF   x22,F
00C72:  BNZ   0C7E
00C74:  RRCF   x22,F
00C76:  RRCF   x21,F
00C78:  RRCF   x20,F
00C7A:  INCF   00,F
00C7C:  BZ    0CFC
00C7E:  BTFSC  x1E.6
00C80:  BRA    0B8A
00C82:  BTFSC  x1E.7
00C84:  BRA    0C12
00C86:  BRA    0CC0
00C88:  MOVLW  80
00C8A:  XORWF  x22,F
00C8C:  BTFSS  x22.7
00C8E:  BRA    0C98
00C90:  BRA    0D06
00C92:  MOVFF  619,61D
00C96:  BRA    0CAC
00C98:  MOVFF  615,61D
00C9C:  MOVF   x22,F
00C9E:  BNZ   0CAC
00CA0:  MOVF   x21,F
00CA2:  BNZ   0CAC
00CA4:  MOVF   x20,F
00CA6:  BNZ   0CAC
00CA8:  CLRF   00
00CAA:  BRA    0CEE
00CAC:  BTFSC  x22.7
00CAE:  BRA    0CC0
00CB0:  BCF    FD8.0
00CB2:  RLCF   x1F,F
00CB4:  RLCF   x20,F
00CB6:  RLCF   x21,F
00CB8:  RLCF   x22,F
00CBA:  DECFSZ 00,F
00CBC:  BRA    0CAC
00CBE:  BRA    0CFC
00CC0:  BTFSS  x1D.7
00CC2:  BRA    0CC8
00CC4:  BSF    x22.7
00CC6:  BRA    0CEE
00CC8:  BCF    x22.7
00CCA:  BRA    0CEE
00CCC:  MOVFF  618,00
00CD0:  MOVFF  619,622
00CD4:  MOVFF  61A,621
00CD8:  MOVFF  61B,620
00CDC:  BRA    0CEE
00CDE:  MOVFF  614,00
00CE2:  MOVFF  615,622
00CE6:  MOVFF  616,621
00CEA:  MOVFF  617,620
00CEE:  MOVFF  622,01
00CF2:  MOVFF  621,02
00CF6:  MOVFF  620,03
00CFA:  BRA    0D64
00CFC:  CLRF   00
00CFE:  CLRF   01
00D00:  CLRF   02
00D02:  CLRF   03
00D04:  BRA    0D64
00D06:  CLRF   x1F
00D08:  COMF   x20,F
00D0A:  COMF   x21,F
00D0C:  COMF   x22,F
00D0E:  COMF   x1F,F
00D10:  INCF   x1F,F
00D12:  BNZ   0D1E
00D14:  INCF   x20,F
00D16:  BNZ   0D1E
00D18:  INCF   x21,F
00D1A:  BNZ   0D1E
00D1C:  INCF   x22,F
00D1E:  BTFSC  x1E.0
00D20:  BRA    0B46
00D22:  BTFSC  x1E.1
00D24:  BRA    0BCE
00D26:  BTFSC  x1E.2
00D28:  BRA    0C3C
00D2A:  BRA    0C92
00D2C:  MOVF   FEF,W
00D2E:  ADDWF  x20,F
00D30:  BNC   0D3C
00D32:  INCF   x21,F
00D34:  BNZ   0D3C
00D36:  INCF   x22,F
00D38:  BTFSC  FD8.2
00D3A:  BSF    x1C.0
00D3C:  MOVF   FED,F
00D3E:  MOVF   FEF,W
00D40:  ADDWF  x21,F
00D42:  BNC   0D4A
00D44:  INCF   x22,F
00D46:  BTFSC  FD8.2
00D48:  BSF    x1C.0
00D4A:  MOVF   FED,F
00D4C:  MOVF   FEF,W
00D4E:  BTFSC  FEF.7
00D50:  BRA    0D54
00D52:  XORLW  80
00D54:  ADDWF  x22,F
00D56:  BTFSC  FD8.0
00D58:  BSF    x1C.0
00D5A:  BTFSC  x1E.4
00D5C:  BRA    0B56
00D5E:  BTFSC  x1E.5
00D60:  BRA    0BDE
00D62:  BRA    0C4C
00D64:  MOVLB  0
00D66:  RETURN 0
*
012F4:  MOVLW  B6
012F6:  MOVWF  00
012F8:  CLRF   03
012FA:  CLRF   02
012FC:  CLRF   01
012FE:  MOVLB  5
01300:  MOVF   xD7,W
01302:  IORWF  xD8,W
01304:  IORWF  xD9,W
01306:  IORWF  xDA,W
01308:  BNZ   130E
0130A:  CLRF   00
0130C:  BRA    1328
0130E:  BCF    FD8.0
01310:  BTFSC  01.7
01312:  BRA    1326
01314:  RLCF   xD7,F
01316:  RLCF   xD8,F
01318:  RLCF   xD9,F
0131A:  RLCF   xDA,F
0131C:  RLCF   03,F
0131E:  RLCF   02,F
01320:  RLCF   01,F
01322:  DECFSZ 00,F
01324:  BRA    130E
01326:  BCF    01.7
01328:  MOVLB  0
0132A:  RETURN 0
0132C:  MOVFF  611,618
01330:  MOVLB  6
01332:  MOVF   x15,W
01334:  XORWF  x18,F
01336:  BTFSS  x18.7
01338:  BRA    1344
0133A:  BCF    FD8.2
0133C:  BCF    FD8.0
0133E:  BTFSC  x11.7
01340:  BSF    FD8.0
01342:  BRA    13A2
01344:  MOVFF  611,618
01348:  MOVFF  614,619
0134C:  MOVF   x10,W
0134E:  SUBWF  x19,F
01350:  BZ    135E
01352:  BTFSS  x18.7
01354:  BRA    13A2
01356:  MOVF   FD8,W
01358:  XORLW  01
0135A:  MOVWF  FD8
0135C:  BRA    13A2
0135E:  MOVFF  615,619
01362:  MOVF   x11,W
01364:  SUBWF  x19,F
01366:  BZ    1374
01368:  BTFSS  x18.7
0136A:  BRA    13A2
0136C:  MOVF   FD8,W
0136E:  XORLW  01
01370:  MOVWF  FD8
01372:  BRA    13A2
01374:  MOVFF  616,619
01378:  MOVF   x12,W
0137A:  SUBWF  x19,F
0137C:  BZ    138A
0137E:  BTFSS  x18.7
01380:  BRA    13A2
01382:  MOVF   FD8,W
01384:  XORLW  01
01386:  MOVWF  FD8
01388:  BRA    13A2
0138A:  MOVFF  617,619
0138E:  MOVF   x13,W
01390:  SUBWF  x19,F
01392:  BZ    13A0
01394:  BTFSS  x18.7
01396:  BRA    13A2
01398:  MOVF   FD8,W
0139A:  XORLW  01
0139C:  MOVWF  FD8
0139E:  BRA    13A2
013A0:  BCF    FD8.0
013A2:  MOVLB  0
013A4:  RETURN 0
013A6:  MOVLB  6
013A8:  MOVF   x06,W
013AA:  BTFSC  FD8.2
013AC:  BRA    14F8
013AE:  MOVWF  x12
013B0:  MOVF   x0A,W
013B2:  BTFSC  FD8.2
013B4:  BRA    14F8
013B6:  SUBWF  x12,F
013B8:  BNC   13C4
013BA:  MOVLW  7F
013BC:  ADDWF  x12,F
013BE:  BTFSC  FD8.0
013C0:  BRA    14F8
013C2:  BRA    13D0
013C4:  MOVLW  81
013C6:  SUBWF  x12,F
013C8:  BTFSS  FD8.0
013CA:  BRA    14F8
013CC:  BTFSC  FD8.2
013CE:  BRA    14F8
013D0:  MOVFF  612,00
013D4:  CLRF   01
013D6:  CLRF   02
013D8:  CLRF   03
013DA:  CLRF   x11
013DC:  MOVFF  607,610
013E0:  BSF    x10.7
013E2:  MOVFF  608,60F
013E6:  MOVFF  609,60E
013EA:  MOVLW  19
013EC:  MOVWF  x12
013EE:  MOVF   x0D,W
013F0:  SUBWF  x0E,F
013F2:  BC    140E
013F4:  MOVLW  01
013F6:  SUBWF  x0F,F
013F8:  BC    140E
013FA:  SUBWF  x10,F
013FC:  BC    140E
013FE:  SUBWF  x11,F
01400:  BC    140E
01402:  INCF   x11,F
01404:  INCF   x10,F
01406:  INCF   x0F,F
01408:  MOVF   x0D,W
0140A:  ADDWF  x0E,F
0140C:  BRA    145E
0140E:  MOVF   x0C,W
01410:  SUBWF  x0F,F
01412:  BC    1438
01414:  MOVLW  01
01416:  SUBWF  x10,F
01418:  BC    1438
0141A:  SUBWF  x11,F
0141C:  BC    1438
0141E:  INCF   x11,F
01420:  INCF   x10,F
01422:  MOVF   x0C,W
01424:  ADDWF  x0F,F
01426:  MOVF   x0D,W
01428:  ADDWF  x0E,F
0142A:  BNC   145E
0142C:  INCF   x0F,F
0142E:  BNZ   145E
01430:  INCF   x10,F
01432:  BNZ   145E
01434:  INCF   x11,F
01436:  BRA    145E
01438:  MOVF   x0B,W
0143A:  IORLW  80
0143C:  SUBWF  x10,F
0143E:  BC    145C
01440:  MOVLW  01
01442:  SUBWF  x11,F
01444:  BC    145C
01446:  INCF   x11,F
01448:  MOVF   x0B,W
0144A:  IORLW  80
0144C:  ADDWF  x10,F
0144E:  MOVF   x0C,W
01450:  ADDWF  x0F,F
01452:  BNC   1426
01454:  INCF   x10,F
01456:  BNZ   1426
01458:  INCF   x11,F
0145A:  BRA    1426
0145C:  BSF    03.0
0145E:  DECFSZ x12,F
01460:  BRA    1464
01462:  BRA    147A
01464:  BCF    FD8.0
01466:  RLCF   x0E,F
01468:  RLCF   x0F,F
0146A:  RLCF   x10,F
0146C:  RLCF   x11,F
0146E:  BCF    FD8.0
01470:  RLCF   03,F
01472:  RLCF   02,F
01474:  RLCF   01,F
01476:  RLCF   x13,F
01478:  BRA    13EE
0147A:  BTFSS  x13.0
0147C:  BRA    148A
0147E:  BCF    FD8.0
01480:  RRCF   01,F
01482:  RRCF   02,F
01484:  RRCF   03,F
01486:  RRCF   x13,F
01488:  BRA    148E
0148A:  DECF   00,F
0148C:  BZ    14F8
0148E:  BTFSC  x13.7
01490:  BRA    14CE
01492:  BCF    FD8.0
01494:  RLCF   x0E,F
01496:  RLCF   x0F,F
01498:  RLCF   x10,F
0149A:  RLCF   x11,F
0149C:  MOVF   x0D,W
0149E:  SUBWF  x0E,F
014A0:  BC    14B0
014A2:  MOVLW  01
014A4:  SUBWF  x0F,F
014A6:  BC    14B0
014A8:  SUBWF  x10,F
014AA:  BC    14B0
014AC:  SUBWF  x11,F
014AE:  BNC   14E4
014B0:  MOVF   x0C,W
014B2:  SUBWF  x0F,F
014B4:  BC    14C0
014B6:  MOVLW  01
014B8:  SUBWF  x10,F
014BA:  BC    14C0
014BC:  SUBWF  x11,F
014BE:  BNC   14E4
014C0:  MOVF   x0B,W
014C2:  IORLW  80
014C4:  SUBWF  x10,F
014C6:  BC    14CE
014C8:  MOVLW  01
014CA:  SUBWF  x11,F
014CC:  BNC   14E4
014CE:  INCF   03,F
014D0:  BNZ   14E4
014D2:  INCF   02,F
014D4:  BNZ   14E4
014D6:  INCF   01,F
014D8:  BNZ   14E4
014DA:  INCF   00,F
014DC:  BZ    14F8
014DE:  RRCF   01,F
014E0:  RRCF   02,F
014E2:  RRCF   03,F
014E4:  MOVFF  607,612
014E8:  MOVF   x0B,W
014EA:  XORWF  x12,F
014EC:  BTFSS  x12.7
014EE:  BRA    14F4
014F0:  BSF    01.7
014F2:  BRA    1500
014F4:  BCF    01.7
014F6:  BRA    1500
014F8:  CLRF   00
014FA:  CLRF   01
014FC:  CLRF   02
014FE:  CLRF   03
01500:  MOVLB  0
01502:  RETURN 0
*
01CB6:  ADDWF  FE8,W
01CB8:  CLRF   FF7
01CBA:  RLCF   FF7,F
01CBC:  ADDLW  D1
01CBE:  MOVWF  FF6
01CC0:  MOVLW  1C
01CC2:  ADDWFC FF7,F
01CC4:  TBLRD*-
01CC6:  MOVF   FF5,W
01CC8:  MOVWF  FFA
01CCA:  TBLRD*
01CCC:  MOVF   FF5,W
01CCE:  MOVWF  FF9
01CD0:  DATA BE,1B
01CD2:  DATA D8,1B
01CD4:  DATA 2C,1C
01CD6:  DATA 90,1C
01CD8:  MOVLW  8E
01CDA:  MOVWF  00
01CDC:  MOVLB  6
01CDE:  MOVF   x10,W
01CE0:  SUBWF  00,F
01CE2:  MOVFF  611,02
01CE6:  MOVFF  612,01
01CEA:  BSF    02.7
01CEC:  MOVF   00,F
01CEE:  BZ    1D02
01CF0:  BCF    FD8.0
01CF2:  MOVF   02,F
01CF4:  BNZ   1CFA
01CF6:  MOVF   01,F
01CF8:  BZ    1D02
01CFA:  RRCF   02,F
01CFC:  RRCF   01,F
01CFE:  DECFSZ 00,F
01D00:  BRA    1CF0
01D02:  BTFSS  x11.7
01D04:  BRA    1D10
01D06:  COMF   01,F
01D08:  COMF   02,F
01D0A:  INCF   01,F
01D0C:  BTFSC  FD8.2
01D0E:  INCF   02,F
01D10:  MOVLB  0
01D12:  RETURN 0
*
02224:  MOVLW  8E
02226:  MOVWF  00
02228:  MOVFF  604,01
0222C:  MOVFF  603,02
02230:  CLRF   03
02232:  BTFSS  01.7
02234:  BRA    2240
02236:  COMF   01,F
02238:  COMF   02,F
0223A:  INCF   02,F
0223C:  BNZ   2240
0223E:  INCF   01,F
02240:  MOVF   01,F
02242:  BNZ   2256
02244:  MOVFF  02,01
02248:  CLRF   02
0224A:  MOVLW  08
0224C:  SUBWF  00,F
0224E:  MOVF   01,F
02250:  BNZ   2256
02252:  CLRF   00
02254:  BRA    2272
02256:  BCF    FD8.0
02258:  BTFSC  01.7
0225A:  BRA    2264
0225C:  RLCF   02,F
0225E:  RLCF   01,F
02260:  DECF   00,F
02262:  BRA    2256
02264:  MOVLB  6
02266:  BTFSS  x04.7
02268:  BRA    226E
0226A:  MOVLB  0
0226C:  BRA    2272
0226E:  BCF    01.7
02270:  MOVLB  0
02272:  RETURN 0
*
0381E:  MOVF   FEF,F
03820:  BZ    3840
03822:  MOVFF  FEA,5BF
03826:  MOVFF  FE9,5BE
0382A:  MOVFF  FEF,5C0
0382E:  RCALL  37F6
03830:  MOVFF  5BF,FEA
03834:  MOVFF  5BE,FE9
03838:  INCF   FE9,F
0383A:  BTFSC  FD8.2
0383C:  INCF   FEA,F
0383E:  BRA    381E
03840:  RETURN 0
*
03E7E:  MOVFF  4CD,FEA
03E82:  MOVFF  4CC,FE9
03E86:  MOVFF  5DD,FEF
03E8A:  INCF   FE9,F
03E8C:  BTFSC  FD8.2
03E8E:  INCF   FEA,F
03E90:  CLRF   FEF
03E92:  MOVLB  4
03E94:  INCF   xCC,F
03E96:  BTFSC  FD8.2
03E98:  INCF   xCD,F
03E9A:  MOVLB  0
03E9C:  RETURN 0
03E9E:  TBLRD*+
03EA0:  MOVF   FF5,F
03EA2:  BZ    3EBC
03EA4:  MOVFF  FF6,5C9
03EA8:  MOVFF  FF7,5CA
03EAC:  MOVFF  FF5,5DD
03EB0:  RCALL  3E7E
03EB2:  MOVFF  5C9,FF6
03EB6:  MOVFF  5CA,FF7
03EBA:  BRA    3E9E
03EBC:  RETURN 0
*
03FE0:  MOVLB  6
03FE2:  MOVF   x14,W
03FE4:  XORWF  x16,W
03FE6:  ANDLW  80
03FE8:  MOVWF  x18
03FEA:  BTFSS  x14.7
03FEC:  BRA    3FF8
03FEE:  COMF   x13,F
03FF0:  COMF   x14,F
03FF2:  INCF   x13,F
03FF4:  BTFSC  FD8.2
03FF6:  INCF   x14,F
03FF8:  BTFSS  x16.7
03FFA:  BRA    4006
03FFC:  COMF   x15,F
03FFE:  COMF   x16,F
04000:  INCF   x15,F
04002:  BTFSC  FD8.2
04004:  INCF   x16,F
04006:  MOVF   x13,W
04008:  MULWF  x15
0400A:  MOVFF  FF3,01
0400E:  MOVFF  FF4,00
04012:  MULWF  x16
04014:  MOVF   FF3,W
04016:  ADDWF  00,F
04018:  MOVF   x14,W
0401A:  MULWF  x15
0401C:  MOVF   FF3,W
0401E:  ADDWFC 00,W
04020:  MOVWF  02
04022:  BTFSS  x18.7
04024:  BRA    4030
04026:  COMF   01,F
04028:  COMF   02,F
0402A:  INCF   01,F
0402C:  BTFSC  FD8.2
0402E:  INCF   02,F
04030:  MOVLB  0
04032:  GOTO   42D2 (RETURN)
*
0439A:  MOVLB  5
0439C:  MOVF   xC7,W
0439E:  ANDLW  07
043A0:  MOVWF  00
043A2:  RRCF   xC7,W
043A4:  MOVWF  01
043A6:  RRCF   01,F
043A8:  RRCF   01,F
043AA:  MOVLW  1F
043AC:  ANDWF  01,F
043AE:  MOVF   01,W
043B0:  ADDWF  xC8,W
043B2:  MOVWF  FE9
043B4:  MOVLW  00
043B6:  ADDWFC xC9,W
043B8:  MOVWF  FEA
043BA:  MOVFF  FEF,01
043BE:  INCF   00,F
043C0:  BRA    43C4
043C2:  RRCF   01,F
043C4:  DECFSZ 00,F
043C6:  BRA    43C2
043C8:  MOVLW  01
043CA:  ANDWF  01,F
043CC:  MOVLB  0
043CE:  RETURN 0
*
04538:  MOVLB  5
0453A:  MOVF   xDE,W
0453C:  ANDLW  07
0453E:  MOVWF  00
04540:  RRCF   xDE,W
04542:  MOVWF  01
04544:  RRCF   01,F
04546:  RRCF   01,F
04548:  MOVLW  1F
0454A:  ANDWF  01,F
0454C:  MOVF   01,W
0454E:  ADDWF  xE0,W
04550:  MOVWF  FE9
04552:  MOVLW  00
04554:  ADDWFC xE1,W
04556:  MOVWF  FEA
04558:  CLRF   01
0455A:  INCF   01,F
0455C:  INCF   00,F
0455E:  BRA    4562
04560:  RLCF   01,F
04562:  DECFSZ 00,F
04564:  BRA    4560
04566:  MOVF   xDF,F
04568:  BZ    4570
0456A:  MOVF   01,W
0456C:  IORWF  FEF,F
0456E:  BRA    4576
04570:  COMF   01,F
04572:  MOVF   01,W
04574:  ANDWF  FEF,F
04576:  MOVLB  0
04578:  RETURN 0
*
04AB2:  MOVLB  5
04AB4:  MOVF   xDD,W
04AB6:  SUBLW  B6
04AB8:  MOVWF  xDD
04ABA:  CLRF   03
04ABC:  MOVFF  5DE,5E1
04AC0:  BSF    xDE.7
04AC2:  BCF    FD8.0
04AC4:  RRCF   xDE,F
04AC6:  RRCF   xDF,F
04AC8:  RRCF   xE0,F
04ACA:  RRCF   03,F
04ACC:  RRCF   02,F
04ACE:  RRCF   01,F
04AD0:  RRCF   00,F
04AD2:  DECFSZ xDD,F
04AD4:  BRA    4AC2
04AD6:  BTFSS  xE1.7
04AD8:  BRA    4AF0
04ADA:  COMF   00,F
04ADC:  COMF   01,F
04ADE:  COMF   02,F
04AE0:  COMF   03,F
04AE2:  INCF   00,F
04AE4:  BTFSC  FD8.2
04AE6:  INCF   01,F
04AE8:  BTFSC  FD8.2
04AEA:  INCF   02,F
04AEC:  BTFSC  FD8.2
04AEE:  INCF   03,F
04AF0:  MOVLB  0
04AF2:  GOTO   4BE4 (RETURN)
04AF6:  BTFSC  FD8.1
04AF8:  BRA    4B02
04AFA:  MOVLW  05
04AFC:  MOVWF  FEA
04AFE:  MOVLW  E5
04B00:  MOVWF  FE9
04B02:  CLRF   00
04B04:  CLRF   01
04B06:  CLRF   02
04B08:  CLRF   03
04B0A:  MOVLB  5
04B0C:  CLRF   xE5
04B0E:  CLRF   xE6
04B10:  CLRF   xE7
04B12:  CLRF   xE8
04B14:  MOVF   xE4,W
04B16:  IORWF  xE3,W
04B18:  IORWF  xE2,W
04B1A:  IORWF  xE1,W
04B1C:  BZ    4B76
04B1E:  MOVLW  20
04B20:  MOVWF  xE9
04B22:  BCF    FD8.0
04B24:  RLCF   xDD,F
04B26:  RLCF   xDE,F
04B28:  RLCF   xDF,F
04B2A:  RLCF   xE0,F
04B2C:  RLCF   xE5,F
04B2E:  RLCF   xE6,F
04B30:  RLCF   xE7,F
04B32:  RLCF   xE8,F
04B34:  MOVF   xE4,W
04B36:  SUBWF  xE8,W
04B38:  BNZ   4B4A
04B3A:  MOVF   xE3,W
04B3C:  SUBWF  xE7,W
04B3E:  BNZ   4B4A
04B40:  MOVF   xE2,W
04B42:  SUBWF  xE6,W
04B44:  BNZ   4B4A
04B46:  MOVF   xE1,W
04B48:  SUBWF  xE5,W
04B4A:  BNC   4B6A
04B4C:  MOVF   xE1,W
04B4E:  SUBWF  xE5,F
04B50:  MOVF   xE2,W
04B52:  BTFSS  FD8.0
04B54:  INCFSZ xE2,W
04B56:  SUBWF  xE6,F
04B58:  MOVF   xE3,W
04B5A:  BTFSS  FD8.0
04B5C:  INCFSZ xE3,W
04B5E:  SUBWF  xE7,F
04B60:  MOVF   xE4,W
04B62:  BTFSS  FD8.0
04B64:  INCFSZ xE4,W
04B66:  SUBWF  xE8,F
04B68:  BSF    FD8.0
04B6A:  RLCF   00,F
04B6C:  RLCF   01,F
04B6E:  RLCF   02,F
04B70:  RLCF   03,F
04B72:  DECFSZ xE9,F
04B74:  BRA    4B22
04B76:  MOVFF  5E5,FEF
04B7A:  MOVFF  5E6,FEC
04B7E:  MOVFF  5E7,FEC
04B82:  MOVFF  5E8,FEC
04B86:  MOVLB  0
04B88:  RETURN 0
04B8A:  MOVF   FE9,W
04B8C:  MOVLB  5
04B8E:  MOVWF  xD5
04B90:  MOVF   xD4,W
04B92:  MOVWF  xD7
04B94:  BZ    4BD0
04B96:  MOVFF  5D3,613
04B9A:  MOVFF  5D2,612
04B9E:  MOVFF  5D1,611
04BA2:  MOVFF  5D0,610
04BA6:  MOVLB  6
04BA8:  CLRF   x17
04BAA:  CLRF   x16
04BAC:  MOVLW  20
04BAE:  MOVWF  x15
04BB0:  MOVLW  82
04BB2:  MOVWF  x14
04BB4:  MOVLB  0
04BB6:  CALL   09FA
04BBA:  MOVFF  03,5D3
04BBE:  MOVFF  02,5D2
04BC2:  MOVFF  01,5D1
04BC6:  MOVFF  00,5D0
04BCA:  MOVLB  5
04BCC:  DECFSZ xD7,F
04BCE:  BRA    4B96
04BD0:  MOVFF  5D3,5E0
04BD4:  MOVFF  5D2,5DF
04BD8:  MOVFF  5D1,5DE
04BDC:  MOVFF  5D0,5DD
04BE0:  MOVLB  0
04BE2:  BRA    4AB2
04BE4:  MOVFF  03,5D3
04BE8:  MOVFF  02,5D2
04BEC:  MOVFF  01,5D1
04BF0:  MOVFF  00,5D0
04BF4:  MOVLB  5
04BF6:  BTFSS  xD3.7
04BF8:  BRA    4C14
04BFA:  DECF   xD5,F
04BFC:  BSF    xD5.5
04BFE:  COMF   xD0,F
04C00:  COMF   xD1,F
04C02:  COMF   xD2,F
04C04:  COMF   xD3,F
04C06:  INCF   xD0,F
04C08:  BTFSC  FD8.2
04C0A:  INCF   xD1,F
04C0C:  BTFSC  FD8.2
04C0E:  INCF   xD2,F
04C10:  BTFSC  FD8.2
04C12:  INCF   xD3,F
04C14:  MOVLW  3B
04C16:  MOVWF  xDC
04C18:  MOVLW  9A
04C1A:  MOVWF  xDB
04C1C:  MOVLW  CA
04C1E:  MOVWF  xDA
04C20:  CLRF   xD9
04C22:  MOVLW  0A
04C24:  MOVWF  xD7
04C26:  MOVF   xD4,W
04C28:  BTFSC  FD8.2
04C2A:  INCF   xD5,F
04C2C:  BSF    FD8.1
04C2E:  MOVLW  05
04C30:  MOVWF  FEA
04C32:  MOVLW  D0
04C34:  MOVWF  FE9
04C36:  MOVFF  5D3,5E0
04C3A:  MOVFF  5D2,5DF
04C3E:  MOVFF  5D1,5DE
04C42:  MOVFF  5D0,5DD
04C46:  MOVFF  5DC,5E4
04C4A:  MOVFF  5DB,5E3
04C4E:  MOVFF  5DA,5E2
04C52:  MOVFF  5D9,5E1
04C56:  MOVLB  0
04C58:  RCALL  4AF6
04C5A:  MOVF   01,W
04C5C:  MOVF   00,F
04C5E:  BNZ   4C86
04C60:  MOVLB  5
04C62:  INCF   xD4,W
04C64:  SUBWF  xD7,W
04C66:  BTFSS  FD8.2
04C68:  BRA    4C6E
04C6A:  MOVLB  0
04C6C:  BRA    4C86
04C6E:  MOVF   xD5,W
04C70:  BZ    4C8C
04C72:  ANDLW  0F
04C74:  SUBWF  xD7,W
04C76:  BZ    4C7A
04C78:  BC    4D02
04C7A:  BTFSC  xD5.7
04C7C:  BRA    4D02
04C7E:  BTFSC  xD5.6
04C80:  BRA    4C8C
04C82:  MOVLW  20
04C84:  BRA    4CF4
04C86:  MOVLW  20
04C88:  MOVLB  5
04C8A:  ANDWF  xD5,F
04C8C:  BTFSS  xD5.5
04C8E:  BRA    4CAE
04C90:  BCF    xD5.5
04C92:  MOVF   xD4,W
04C94:  BTFSS  FD8.2
04C96:  DECF   xD5,F
04C98:  MOVF   00,W
04C9A:  MOVWF  xD5
04C9C:  MOVLW  2D
04C9E:  MOVWF  xDD
04CA0:  MOVLB  0
04CA2:  CALL   3E7E
04CA6:  MOVLB  5
04CA8:  MOVF   xD5,W
04CAA:  MOVWF  00
04CAC:  CLRF   xD5
04CAE:  MOVF   xD4,W
04CB0:  SUBWF  xD7,W
04CB2:  BNZ   4CCE
04CB4:  MOVF   00,W
04CB6:  MOVWF  xD5
04CB8:  MOVLW  2E
04CBA:  MOVWF  xDD
04CBC:  MOVLB  0
04CBE:  CALL   3E7E
04CC2:  MOVLB  5
04CC4:  MOVF   xD5,W
04CC6:  MOVWF  00
04CC8:  MOVLW  20
04CCA:  ANDWF  xD5,F
04CCC:  MOVLW  00
04CCE:  MOVLW  30
04CD0:  BTFSS  xD5.5
04CD2:  BRA    4CF4
04CD4:  BCF    xD5.5
04CD6:  MOVF   xD4,W
04CD8:  BTFSS  FD8.2
04CDA:  DECF   xD5,F
04CDC:  MOVF   00,W
04CDE:  MOVWF  xD5
04CE0:  MOVLW  2D
04CE2:  MOVWF  xDD
04CE4:  MOVLB  0
04CE6:  CALL   3E7E
04CEA:  MOVLB  5
04CEC:  MOVF   xD5,W
04CEE:  MOVWF  00
04CF0:  CLRF   xD5
04CF2:  MOVLW  30
04CF4:  ADDWF  00,F
04CF6:  MOVFF  00,5DD
04CFA:  MOVLB  0
04CFC:  CALL   3E7E
04D00:  MOVLB  5
04D02:  BCF    FD8.1
04D04:  MOVFF  5DC,5E0
04D08:  MOVFF  5DB,5DF
04D0C:  MOVFF  5DA,5DE
04D10:  MOVFF  5D9,5DD
04D14:  CLRF   xE4
04D16:  CLRF   xE3
04D18:  CLRF   xE2
04D1A:  MOVLW  0A
04D1C:  MOVWF  xE1
04D1E:  MOVLB  0
04D20:  RCALL  4AF6
04D22:  MOVFF  03,5DC
04D26:  MOVFF  02,5DB
04D2A:  MOVFF  01,5DA
04D2E:  MOVFF  00,5D9
04D32:  MOVLB  5
04D34:  DECFSZ xD7,F
04D36:  BRA    4C2C
04D38:  MOVLB  0
04D3A:  RETURN 0
*
06662:  MOVF   FEF,F
06664:  BZ    6686
06666:  MOVFF  FEA,5BF
0666A:  MOVFF  FE9,5BE
0666E:  MOVFF  FEF,5DD
06672:  CALL   3E7E
06676:  MOVFF  5BF,FEA
0667A:  MOVFF  5BE,FE9
0667E:  INCF   FE9,F
06680:  BTFSC  FD8.2
06682:  INCF   FEA,F
06684:  BRA    6662
06686:  GOTO   6704 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003AC:  MOVLW  05
003AE:  MOVWF  FEA
003B0:  MOVLW  BA
003B2:  MOVWF  FE9
003B4:  MOVF   FEF,W
003B6:  BZ    03D4
003B8:  MOVLW  14
003BA:  MOVWF  01
003BC:  CLRF   00
003BE:  DECFSZ 00,F
003C0:  BRA    03BE
003C2:  DECFSZ 01,F
003C4:  BRA    03BC
003C6:  MOVLW  BF
003C8:  MOVWF  00
003CA:  DECFSZ 00,F
003CC:  BRA    03CA
003CE:  BRA    03D0
003D0:  DECFSZ FEF,F
003D2:  BRA    03B8
003D4:  RETURN 0
*
0065E:  MOVLW  01
00660:  MOVLB  5
00662:  SUBWF  xC3,F
00664:  BNC   067E
00666:  MOVLW  05
00668:  MOVWF  FEA
0066A:  MOVLW  C3
0066C:  MOVWF  FE9
0066E:  MOVF   FEF,W
00670:  BZ    067E
00672:  MOVLW  04
00674:  MOVWF  00
00676:  DECFSZ 00,F
00678:  BRA    0676
0067A:  DECFSZ FEF,F
0067C:  BRA    0672
0067E:  MOVLB  0
00680:  GOTO   06D0 (RETURN)
.................... #define baudRate 128000
.................... 
.................... #define version  "20250522" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm       
.................... 
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00316:  MOVLW  CF
00318:  MOVWF  F87
0031A:  CLRF   F82
....................    output_b(portB_reset);
0031C:  MOVLW  F4
0031E:  MOVWF  F88
00320:  CLRF   F83
....................    output_c(portC_reset);
00322:  MOVLW  93
00324:  MOVWF  F89
00326:  CLRF   F84
....................    output_d(portD_reset);
00328:  MOVLW  1F
0032A:  MOVWF  F8A
0032C:  CLRF   F85
....................    output_e(portE_reset);
0032E:  BCF    F8B.0
00330:  BCF    F8B.1
00332:  BCF    F8B.2
00334:  BCF    F8B.3
00336:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00338:  MOVLB  F
0033A:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0033C:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0033E:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00340:  SETF   x20
....................    port_e_pullups(portE_pullups);
00342:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00344:  MOVLW  40
00346:  MOVWF  x0C
00348:  CLRF   x14
0034A:  MOVLW  03
0034C:  MOVWF  x1C
0034E:  MOVLW  0F
00350:  MOVWF  x21
00352:  CLRF   x29
00354:  MOVLB  0
00356:  GOTO   6A76 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
03DCE:  MOVFF  5DE,FEA
03DD2:  MOVLB  5
03DD4:  MOVFF  5DD,FE9
03DD8:  MOVFF  FEF,5E1
03DDC:  MOVFF  5E0,FEA
03DE0:  MOVFF  5DF,FE9
03DE4:  MOVF   FEF,W
03DE6:  SUBWF  xE1,W
03DE8:  BNZ   3E18
....................       if (*s1 == '\0')
03DEA:  MOVFF  5DE,03
03DEE:  MOVFF  5DD,FE9
03DF2:  MOVFF  03,FEA
03DF6:  MOVF   FEF,F
03DF8:  BNZ   3E00
....................          return(0);
03DFA:  MOVLW  00
03DFC:  MOVWF  01
03DFE:  BRA    3E42
03E00:  MOVFF  5DE,03
03E04:  MOVF   xDD,W
03E06:  INCF   xDD,F
03E08:  BTFSC  FD8.2
03E0A:  INCF   xDE,F
03E0C:  INCF   xDF,F
03E0E:  BTFSC  FD8.2
03E10:  INCF   xE0,F
03E12:  MOVLB  0
03E14:  BRA    3DCE
03E16:  MOVLB  5
....................    return((*s1 < *s2) ? -1: 1);
03E18:  MOVFF  5DE,03
03E1C:  MOVFF  5DD,FE9
03E20:  MOVFF  03,FEA
03E24:  MOVFF  FEF,5E1
03E28:  MOVFF  5E0,03
03E2C:  MOVFF  5DF,FE9
03E30:  MOVFF  03,FEA
03E34:  MOVF   FEF,W
03E36:  SUBWF  xE1,W
03E38:  BC    3E3E
03E3A:  MOVLW  FF
03E3C:  BRA    3E40
03E3E:  MOVLW  01
03E40:  MOVWF  01
03E42:  MOVLB  0
03E44:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
03F96:  MOVFF  614,617
....................    for(su=s;0<n;++su,--n)
03F9A:  MOVFF  613,619
03F9E:  MOVFF  612,618
03FA2:  MOVLB  6
03FA4:  MOVF   x16,F
03FA6:  BNZ   3FAE
03FA8:  MOVF   x15,W
03FAA:  SUBLW  00
03FAC:  BC    3FD6
....................       if(*su==uc)
03FAE:  MOVFF  619,FEA
03FB2:  MOVFF  618,FE9
03FB6:  MOVF   x17,W
03FB8:  SUBWF  FEF,W
03FBA:  BNZ   3FC6
....................       return su;
03FBC:  MOVFF  618,01
03FC0:  MOVFF  619,02
03FC4:  BRA    3FDC
03FC6:  INCF   x18,F
03FC8:  BTFSC  FD8.2
03FCA:  INCF   x19,F
03FCC:  MOVF   x15,W
03FCE:  BTFSC  FD8.2
03FD0:  DECF   x16,F
03FD2:  DECF   x15,F
03FD4:  BRA    3FA4
....................    return NULL;
03FD6:  MOVLW  00
03FD8:  MOVWF  01
03FDA:  MOVWF  02
03FDC:  MOVLB  0
03FDE:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
03E46:  MOVFF  5E2,5E4
03E4A:  MOVFF  5E1,5E3
03E4E:  MOVFF  5E4,FEA
03E52:  MOVLB  5
03E54:  MOVFF  5E3,FE9
03E58:  MOVF   FEF,F
03E5A:  BZ    3E68
03E5C:  INCF   xE3,F
03E5E:  BTFSC  FD8.2
03E60:  INCF   xE4,F
03E62:  MOVLB  0
03E64:  BRA    3E4E
03E66:  MOVLB  5
....................    return(sc - s);
03E68:  MOVF   xE1,W
03E6A:  SUBWF  xE3,W
03E6C:  MOVWF  00
03E6E:  MOVF   xE2,W
03E70:  SUBWFB xE4,W
03E72:  MOVWF  03
03E74:  MOVFF  00,01
03E78:  MOVWF  02
03E7A:  MOVLB  0
03E7C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
05016:  MOVLB  5
05018:  CLRF   xD5
0501A:  CLRF   xD4
0501C:  CLRF   xD3
0501E:  MOVLW  7F
05020:  MOVWF  xD2
05022:  CLRF   xD9
05024:  CLRF   xD8
05026:  CLRF   xD7
05028:  CLRF   xD6
0502A:  BSF    xDA.0
0502C:  BCF    xDA.1
0502E:  BCF    xDA.2
05030:  CLRF   xDC
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
05032:  MOVF   xCE,W
05034:  IORWF  xCF,W
05036:  BNZ   5042
....................       return 0;
05038:  CLRF   00
0503A:  CLRF   01
0503C:  CLRF   02
0503E:  CLRF   03
05040:  BRA    5272
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
05042:  MOVF   xDC,W
05044:  INCF   xDC,F
05046:  ADDWF  xCE,W
05048:  MOVWF  FE9
0504A:  MOVLW  00
0504C:  ADDWFC xCF,W
0504E:  MOVWF  FEA
05050:  MOVFF  FEF,5DB
05054:  MOVF   xDB,F
05056:  BTFSC  FD8.2
05058:  BRA    51F4
....................    {
....................       if (skip && !isspace(c))
0505A:  BTFSS  xDA.0
0505C:  BRA    507C
0505E:  MOVF   xDB,W
05060:  SUBLW  20
05062:  BZ    507C
....................       {
....................          skip = 0;
05064:  BCF    xDA.0
....................          if (c == '+')
05066:  MOVF   xDB,W
05068:  SUBLW  2B
0506A:  BNZ   5072
....................          {
....................             sign = 0;
0506C:  BCF    xDA.1
....................             continue;
0506E:  BRA    51DC
....................          }            
05070:  BRA    507C
....................          else if (c == '-')
05072:  MOVF   xDB,W
05074:  SUBLW  2D
05076:  BNZ   507C
....................          {
....................             sign = 1;
05078:  BSF    xDA.1
....................             continue;
0507A:  BRA    51DC
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
0507C:  BTFSC  xDA.0
0507E:  BRA    508E
05080:  MOVF   xDB,W
05082:  SUBLW  2E
05084:  BNZ   508E
05086:  BTFSC  xDA.2
05088:  BRA    508E
....................          point = 1;
0508A:  BSF    xDA.2
0508C:  BRA    51DC
....................       else if (!skip && isdigit(c))
0508E:  BTFSC  xDA.0
05090:  BRA    51D6
05092:  MOVF   xDB,W
05094:  SUBLW  2F
05096:  BTFSC  FD8.0
05098:  BRA    51D6
0509A:  MOVF   xDB,W
0509C:  SUBLW  39
0509E:  BTFSS  FD8.0
050A0:  BRA    51D6
....................       {
....................          c -= '0';
050A2:  MOVLW  30
050A4:  SUBWF  xDB,F
....................          if (point)
050A6:  BTFSS  xDA.2
050A8:  BRA    515A
....................          {
....................             pow10 = pow10 * 10.0;
050AA:  MOVFF  5D5,613
050AE:  MOVFF  5D4,612
050B2:  MOVFF  5D3,611
050B6:  MOVFF  5D2,610
050BA:  MOVLB  6
050BC:  CLRF   x17
050BE:  CLRF   x16
050C0:  MOVLW  20
050C2:  MOVWF  x15
050C4:  MOVLW  82
050C6:  MOVWF  x14
050C8:  MOVLB  0
050CA:  CALL   09FA
050CE:  MOVFF  03,5D5
050D2:  MOVFF  02,5D4
050D6:  MOVFF  01,5D3
050DA:  MOVFF  00,5D2
....................             result += (float)c / pow10;   
050DE:  MOVLB  6
050E0:  CLRF   x15
050E2:  MOVFF  5DB,614
050E6:  MOVLB  0
050E8:  CALL   09C4
050EC:  MOVFF  03,5E0
050F0:  MOVFF  02,5DF
050F4:  MOVFF  01,5DE
050F8:  MOVFF  00,5DD
050FC:  MOVFF  03,609
05100:  MOVFF  02,608
05104:  MOVFF  01,607
05108:  MOVFF  00,606
0510C:  MOVFF  5D5,60D
05110:  MOVFF  5D4,60C
05114:  MOVFF  5D3,60B
05118:  MOVFF  5D2,60A
0511C:  CALL   13A6
05120:  BCF    FD8.1
05122:  MOVFF  5D9,617
05126:  MOVFF  5D8,616
0512A:  MOVFF  5D7,615
0512E:  MOVFF  5D6,614
05132:  MOVFF  03,61B
05136:  MOVFF  02,61A
0513A:  MOVFF  01,619
0513E:  MOVFF  00,618
05142:  CALL   0AF0
05146:  MOVFF  03,5D9
0514A:  MOVFF  02,5D8
0514E:  MOVFF  01,5D7
05152:  MOVFF  00,5D6
....................          }
05156:  BRA    51D2
05158:  MOVLB  5
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
0515A:  MOVLB  6
0515C:  CLRF   x13
0515E:  CLRF   x12
05160:  MOVLW  20
05162:  MOVWF  x11
05164:  MOVLW  82
05166:  MOVWF  x10
05168:  MOVFF  5D9,617
0516C:  MOVFF  5D8,616
05170:  MOVFF  5D7,615
05174:  MOVFF  5D6,614
05178:  MOVLB  0
0517A:  CALL   09FA
0517E:  MOVFF  03,5E0
05182:  MOVFF  02,5DF
05186:  MOVFF  01,5DE
0518A:  MOVFF  00,5DD
0518E:  MOVLB  6
05190:  CLRF   x15
05192:  MOVFF  5DB,614
05196:  MOVLB  0
05198:  CALL   09C4
0519C:  BCF    FD8.1
0519E:  MOVFF  5E0,617
051A2:  MOVFF  5DF,616
051A6:  MOVFF  5DE,615
051AA:  MOVFF  5DD,614
051AE:  MOVFF  03,61B
051B2:  MOVFF  02,61A
051B6:  MOVFF  01,619
051BA:  MOVFF  00,618
051BE:  CALL   0AF0
051C2:  MOVFF  03,5D9
051C6:  MOVFF  02,5D8
051CA:  MOVFF  01,5D7
051CE:  MOVFF  00,5D6
....................          }
....................       }
051D2:  BRA    51DE
051D4:  MOVLB  5
....................       else if (!skip)
051D6:  BTFSC  xDA.0
051D8:  BRA    51DC
....................          break;
051DA:  BRA    51F4
051DC:  MOVLB  0
051DE:  MOVLB  5
051E0:  MOVF   xDC,W
051E2:  INCF   xDC,F
051E4:  ADDWF  xCE,W
051E6:  MOVWF  FE9
051E8:  MOVLW  00
051EA:  ADDWFC xCF,W
051EC:  MOVWF  FEA
051EE:  MOVFF  FEF,5DB
051F2:  BRA    5054
....................    }
.................... 
....................    if (sign)
051F4:  BTFSS  xDA.1
051F6:  BRA    522E
....................       result = -1*result;
051F8:  MOVLB  6
051FA:  CLRF   x13
051FC:  CLRF   x12
051FE:  MOVLW  80
05200:  MOVWF  x11
05202:  MOVLW  7F
05204:  MOVWF  x10
05206:  MOVFF  5D9,617
0520A:  MOVFF  5D8,616
0520E:  MOVFF  5D7,615
05212:  MOVFF  5D6,614
05216:  MOVLB  0
05218:  CALL   09FA
0521C:  MOVFF  03,5D9
05220:  MOVFF  02,5D8
05224:  MOVFF  01,5D7
05228:  MOVFF  00,5D6
0522C:  MOVLB  5
....................       
....................    if(endptr)
0522E:  MOVF   xD0,W
05230:  IORWF  xD1,W
05232:  BZ    5262
....................    {
....................       if (ptr) {
05234:  MOVF   xDC,F
05236:  BZ    5250
....................          ptr--;
05238:  DECF   xDC,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
0523A:  MOVFF  5D1,FEA
0523E:  MOVFF  5D0,FE9
05242:  MOVF   xDC,W
05244:  ADDWF  xCE,W
05246:  MOVWF  FEF
05248:  MOVLW  00
0524A:  ADDWFC xCF,W
0524C:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0524E:  BRA    5262
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
05250:  MOVFF  5D1,FEA
05254:  MOVFF  5D0,FE9
05258:  MOVFF  5CF,FEC
0525C:  MOVF   FED,F
0525E:  MOVFF  5CE,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
05262:  MOVFF  5D6,00
05266:  MOVFF  5D7,01
0526A:  MOVFF  5D8,02
0526E:  MOVFF  5D9,03
05272:  MOVLB  0
05274:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
04036:  MOVLB  5
04038:  CLRF   xEB
0403A:  CLRF   xEA
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
0403C:  MOVLW  30
0403E:  MOVWF  xED
04040:  MOVLW  31
04042:  MOVWF  xEE
04044:  MOVLW  32
04046:  MOVWF  xEF
04048:  MOVLW  33
0404A:  MOVWF  xF0
0404C:  MOVLW  34
0404E:  MOVWF  xF1
04050:  MOVLW  35
04052:  MOVWF  xF2
04054:  MOVLW  36
04056:  MOVWF  xF3
04058:  MOVLW  37
0405A:  MOVWF  xF4
0405C:  MOVLW  38
0405E:  MOVWF  xF5
04060:  MOVLW  39
04062:  MOVWF  xF6
04064:  MOVLW  61
04066:  MOVWF  xF7
04068:  MOVLW  62
0406A:  MOVWF  xF8
0406C:  MOVLW  63
0406E:  MOVWF  xF9
04070:  MOVLW  64
04072:  MOVWF  xFA
04074:  MOVLW  65
04076:  MOVWF  xFB
04078:  MOVLW  66
0407A:  MOVWF  xFC
0407C:  MOVLW  67
0407E:  MOVWF  xFD
04080:  MOVLW  68
04082:  MOVWF  xFE
04084:  MOVLW  69
04086:  MOVWF  xFF
04088:  MOVLW  6A
0408A:  MOVLB  6
0408C:  MOVWF  x00
0408E:  MOVLW  6B
04090:  MOVWF  x01
04092:  MOVLW  6C
04094:  MOVWF  x02
04096:  MOVLW  6D
04098:  MOVWF  x03
0409A:  MOVLW  6E
0409C:  MOVWF  x04
0409E:  MOVLW  6F
040A0:  MOVWF  x05
040A2:  MOVLW  70
040A4:  MOVWF  x06
040A6:  MOVLW  71
040A8:  MOVWF  x07
040AA:  MOVLW  73
040AC:  MOVWF  x08
040AE:  MOVLW  74
040B0:  MOVWF  x09
040B2:  MOVLW  75
040B4:  MOVWF  x0A
040B6:  MOVLW  76
040B8:  MOVWF  x0B
040BA:  MOVLW  77
040BC:  MOVWF  x0C
040BE:  MOVLW  78
040C0:  MOVWF  x0D
040C2:  MOVLW  79
040C4:  MOVWF  x0E
040C6:  MOVLW  7A
040C8:  MOVWF  x0F
040CA:  CLRF   x10
....................    for(sc=s;isspace(*sc);++sc);
040CC:  MOVFF  5E0,5E5
040D0:  MOVFF  5DF,5E4
040D4:  MOVFF  5E5,FEA
040D8:  MOVLB  5
040DA:  MOVFF  5E4,FE9
040DE:  MOVF   FEF,W
040E0:  SUBLW  20
040E2:  BNZ   40F0
040E4:  INCF   xE4,F
040E6:  BTFSC  FD8.2
040E8:  INCF   xE5,F
040EA:  MOVLB  6
040EC:  BRA    40D4
040EE:  MOVLB  5
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
040F0:  MOVFF  5E5,03
040F4:  MOVFF  5E4,FE9
040F8:  MOVFF  03,FEA
040FC:  MOVF   FEF,W
040FE:  SUBLW  2D
04100:  BZ    4110
04102:  MOVFF  5E5,FEA
04106:  MOVFF  5E4,FE9
0410A:  MOVF   FEF,W
0410C:  SUBLW  2B
0410E:  BNZ   4122
04110:  MOVFF  5E5,FEA
04114:  MOVF   xE4,W
04116:  INCF   xE4,F
04118:  BTFSC  FD8.2
0411A:  INCF   xE5,F
0411C:  MOVWF  FE9
0411E:  MOVF   FEF,W
04120:  BRA    4124
04122:  MOVLW  2B
04124:  MOVWF  xEC
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
04126:  MOVF   xEC,W
04128:  SUBLW  2D
0412A:  BZ    4140
0412C:  BTFSC  xE3.7
0412E:  BRA    4140
04130:  DECFSZ xE3,W
04132:  BRA    4136
04134:  BRA    4140
04136:  BTFSC  xE3.7
04138:  BRA    4144
0413A:  MOVF   xE3,W
0413C:  SUBLW  24
0413E:  BC    4144
....................    goto StrtoulGO;
04140:  BRA    4354
04142:  BRA    423C
.................... 
....................    else if (base)
04144:  MOVF   xE3,F
04146:  BZ    41D4
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
04148:  MOVF   xE3,W
0414A:  SUBLW  10
0414C:  BNZ   4188
0414E:  MOVFF  5E5,FEA
04152:  MOVFF  5E4,FE9
04156:  MOVF   FEF,W
04158:  SUBLW  30
0415A:  BNZ   4188
0415C:  MOVLW  01
0415E:  ADDWF  xE4,W
04160:  MOVWF  FE9
04162:  MOVLW  00
04164:  ADDWFC xE5,W
04166:  MOVWF  FEA
04168:  MOVF   FEF,W
0416A:  SUBLW  78
0416C:  BZ    4180
0416E:  MOVLW  01
04170:  ADDWF  xE4,W
04172:  MOVWF  FE9
04174:  MOVLW  00
04176:  ADDWFC xE5,W
04178:  MOVWF  FEA
0417A:  MOVF   FEF,W
0417C:  SUBLW  58
0417E:  BNZ   4188
....................          sc+=2;
04180:  MOVLW  02
04182:  ADDWF  xE4,F
04184:  MOVLW  00
04186:  ADDWFC xE5,F
....................       if(base==8 && *sc =='0')
04188:  MOVF   xE3,W
0418A:  SUBLW  08
0418C:  BNZ   41A4
0418E:  MOVFF  5E5,FEA
04192:  MOVFF  5E4,FE9
04196:  MOVF   FEF,W
04198:  SUBLW  30
0419A:  BNZ   41A4
....................          sc+=1;
0419C:  MOVLW  01
0419E:  ADDWF  xE4,F
041A0:  MOVLW  00
041A2:  ADDWFC xE5,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
041A4:  MOVF   xE3,W
041A6:  SUBLW  02
041A8:  BNZ   41D2
041AA:  MOVFF  5E5,FEA
041AE:  MOVFF  5E4,FE9
041B2:  MOVF   FEF,W
041B4:  SUBLW  30
041B6:  BNZ   41D2
041B8:  MOVLW  01
041BA:  ADDWF  xE4,W
041BC:  MOVWF  FE9
041BE:  MOVLW  00
041C0:  ADDWFC xE5,W
041C2:  MOVWF  FEA
041C4:  MOVF   FEF,W
041C6:  SUBLW  62
041C8:  BNZ   41D2
....................          sc+=2;
041CA:  MOVLW  02
041CC:  ADDWF  xE4,F
041CE:  MOVLW  00
041D0:  ADDWFC xE5,F
.................... 
....................    }
041D2:  BRA    423C
....................    else if(*sc!='0') // base is 0, find base
041D4:  MOVFF  5E5,FEA
041D8:  MOVFF  5E4,FE9
041DC:  MOVF   FEF,W
041DE:  SUBLW  30
041E0:  BZ    41E8
....................       base=10;
041E2:  MOVLW  0A
041E4:  MOVWF  xE3
041E6:  BRA    423C
....................    else if (sc[1]=='x' || sc[1]=='X')
041E8:  MOVLW  01
041EA:  ADDWF  xE4,W
041EC:  MOVWF  FE9
041EE:  MOVLW  00
041F0:  ADDWFC xE5,W
041F2:  MOVWF  FEA
041F4:  MOVF   FEF,W
041F6:  SUBLW  78
041F8:  BZ    420C
041FA:  MOVLW  01
041FC:  ADDWF  xE4,W
041FE:  MOVWF  FE9
04200:  MOVLW  00
04202:  ADDWFC xE5,W
04204:  MOVWF  FEA
04206:  MOVF   FEF,W
04208:  SUBLW  58
0420A:  BNZ   421A
....................       base =16,sc+=2;
0420C:  MOVLW  10
0420E:  MOVWF  xE3
04210:  MOVLW  02
04212:  ADDWF  xE4,F
04214:  MOVLW  00
04216:  ADDWFC xE5,F
04218:  BRA    423C
....................    else if(sc[1]=='b')
0421A:  MOVLW  01
0421C:  ADDWF  xE4,W
0421E:  MOVWF  FE9
04220:  MOVLW  00
04222:  ADDWFC xE5,W
04224:  MOVWF  FEA
04226:  MOVF   FEF,W
04228:  SUBLW  62
0422A:  BNZ   4238
....................       base=2,sc+=2;
0422C:  MOVLW  02
0422E:  MOVWF  xE3
04230:  ADDWF  xE4,F
04232:  MOVLW  00
04234:  ADDWFC xE5,F
04236:  BRA    423C
....................    else
....................       base=8;
04238:  MOVLW  08
0423A:  MOVWF  xE3
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0423C:  MOVFF  5E5,5E7
04240:  MOVFF  5E4,5E6
04244:  MOVFF  5E5,FEA
04248:  MOVFF  5E4,FE9
0424C:  MOVF   FEF,W
0424E:  SUBLW  30
04250:  BNZ   425A
04252:  INCF   xE4,F
04254:  BTFSC  FD8.2
04256:  INCF   xE5,F
04258:  BRA    4244
....................    sd=memchr(digits,tolower(*sc),base);
0425A:  MOVFF  5E5,03
0425E:  MOVFF  5E4,FE9
04262:  MOVFF  03,FEA
04266:  MOVFF  FEF,611
0426A:  MOVLB  6
0426C:  MOVF   x11,W
0426E:  SUBLW  40
04270:  BC    427E
04272:  MOVF   x11,W
04274:  SUBLW  5A
04276:  BNC   427E
04278:  MOVF   x11,W
0427A:  IORLW  20
0427C:  BRA    4280
0427E:  MOVF   x11,W
04280:  MOVWF  x11
04282:  MOVLW  05
04284:  MOVWF  x13
04286:  MOVLW  ED
04288:  MOVWF  x12
0428A:  MOVFF  611,614
0428E:  CLRF   x16
04290:  MOVFF  5E3,615
04294:  BTFSC  x15.7
04296:  DECF   x16,F
04298:  MOVLB  0
0429A:  RCALL  3F96
0429C:  MOVFF  02,5E9
042A0:  MOVFF  01,5E8
....................    for(; sd!=0; )
042A4:  MOVLB  5
042A6:  MOVF   xE8,F
042A8:  BNZ   42AE
042AA:  MOVF   xE9,F
042AC:  BZ    4348
....................    {
....................       x=x*base+(int16)(sd-digits);
042AE:  CLRF   03
042B0:  MOVF   xE3,W
042B2:  MOVWF  00
042B4:  BTFSC  FE8.7
042B6:  DECF   03,F
042B8:  MOVLB  6
042BA:  MOVWF  x11
042BC:  MOVFF  03,612
042C0:  MOVFF  5EB,614
042C4:  MOVFF  5EA,613
042C8:  MOVFF  03,616
042CC:  MOVWF  x15
042CE:  MOVLB  0
042D0:  BRA    3FE0
042D2:  MOVFF  01,611
042D6:  MOVLW  ED
042D8:  MOVLB  5
042DA:  SUBWF  xE8,W
042DC:  MOVWF  00
042DE:  MOVLW  05
042E0:  SUBWFB xE9,W
042E2:  MOVWF  03
042E4:  MOVF   00,W
042E6:  ADDWF  01,W
042E8:  MOVWF  01
042EA:  MOVF   02,W
042EC:  ADDWFC 03,F
042EE:  MOVFF  01,5EA
042F2:  MOVLB  5
042F4:  MOVFF  03,5EB
....................       ++sc;
042F8:  INCF   xE4,F
042FA:  BTFSC  FD8.2
042FC:  INCF   xE5,F
....................       sd=memchr(digits,tolower(*sc),base);
042FE:  MOVFF  5E5,FEA
04302:  MOVFF  5E4,FE9
04306:  MOVFF  FEF,611
0430A:  MOVLB  6
0430C:  MOVF   x11,W
0430E:  SUBLW  40
04310:  BC    431E
04312:  MOVF   x11,W
04314:  SUBLW  5A
04316:  BNC   431E
04318:  MOVF   x11,W
0431A:  IORLW  20
0431C:  BRA    4320
0431E:  MOVF   x11,W
04320:  MOVWF  x11
04322:  MOVLW  05
04324:  MOVWF  x13
04326:  MOVLW  ED
04328:  MOVWF  x12
0432A:  MOVFF  611,614
0432E:  CLRF   x16
04330:  MOVFF  5E3,615
04334:  BTFSC  x15.7
04336:  DECF   x16,F
04338:  MOVLB  0
0433A:  RCALL  3F96
0433C:  MOVFF  02,5E9
04340:  MOVFF  01,5E8
04344:  BRA    42A4
04346:  MOVLB  5
....................    }
....................    if(s1==sc)
04348:  MOVF   xE4,W
0434A:  SUBWF  xE6,W
0434C:  BNZ   4376
0434E:  MOVF   xE5,W
04350:  SUBWF  xE7,W
04352:  BNZ   4376
....................    {
....................    StrtoulGO:
....................       if (endptr)
04354:  MOVLB  5
04356:  MOVF   xE1,W
04358:  IORWF  xE2,W
0435A:  BZ    436E
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
0435C:  MOVFF  5E2,FEA
04360:  MOVFF  5E1,FE9
04364:  MOVFF  5E0,FEC
04368:  MOVF   FED,F
0436A:  MOVFF  5DF,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
0436E:  MOVLW  00
04370:  MOVWF  01
04372:  MOVWF  02
04374:  BRA    4396
....................    }
....................    if (endptr)
04376:  MOVF   xE1,W
04378:  IORWF  xE2,W
0437A:  BZ    438E
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
0437C:  MOVFF  5E2,FEA
04380:  MOVFF  5E1,FE9
04384:  MOVFF  5E5,FEC
04388:  MOVF   FED,F
0438A:  MOVFF  5E4,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
0438E:  MOVFF  5EA,01
04392:  MOVFF  5EB,02
04396:  MOVLB  0
04398:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D6:  MOVLB  5
003D8:  CLRF   xBE
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003DA:  CLRF   xBE
003DC:  MOVF   xBD,W
003DE:  SUBWF  xBE,W
003E0:  BC    0438
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
003E2:  MOVF   xBE,W
003E4:  ADDWF  xBB,W
003E6:  MOVWF  xBF
003E8:  MOVLW  00
003EA:  ADDWFC xBC,W
003EC:  MOVWF  xC0
003EE:  MOVF   xBE,W
003F0:  ADDWF  xB9,W
003F2:  MOVWF  01
003F4:  MOVLW  00
003F6:  ADDWFC xBA,W
003F8:  MOVWF  03
003FA:  MOVF   01,W
003FC:  MOVWF  FE9
003FE:  MOVFF  03,FEA
00402:  MOVFF  FEF,5C1
00406:  BSF    F7F.7
00408:  MOVF   FF2,W
0040A:  MOVWF  00
0040C:  BCF    FF2.7
0040E:  MOVFF  5C0,F7A
00412:  MOVFF  5BF,F79
00416:  MOVLW  31
00418:  MOVWF  F7B
0041A:  MOVFF  5C1,F7C
0041E:  MOVLB  F
00420:  MOVLW  55
00422:  MOVWF  F81
00424:  MOVLW  AA
00426:  MOVWF  F81
00428:  BSF    F80.4
0042A:  BTFSC  F80.4
0042C:  BRA    042A
0042E:  MOVF   00,W
00430:  IORWF  FF2,F
00432:  MOVLB  5
00434:  INCF   xBE,F
00436:  BRA    03DC
....................    }
00438:  MOVLB  0
0043A:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0035A:  MOVLB  5
0035C:  CLRF   xBE
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0035E:  CLRF   xBE
00360:  MOVF   xBD,W
00362:  SUBWF  xBE,W
00364:  BC    03A8
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00366:  MOVF   xBE,W
00368:  ADDWF  xB9,W
0036A:  MOVWF  01
0036C:  MOVLW  00
0036E:  ADDWFC xBA,W
00370:  MOVWF  03
00372:  MOVF   01,W
00374:  MOVWF  FE9
00376:  MOVFF  03,FEA
0037A:  MOVF   xBE,W
0037C:  ADDWF  xBB,W
0037E:  MOVWF  xC1
00380:  MOVLW  00
00382:  ADDWFC xBC,W
00384:  MOVWF  xC2
00386:  BSF    F7F.7
00388:  MOVFF  FF2,5C3
0038C:  BCF    FF2.7
0038E:  MOVFF  5C2,F7A
00392:  MOVFF  5C1,F79
00396:  MOVLW  31
00398:  MOVWF  F7B
0039A:  BSF    F80.0
0039C:  MOVF   F7C,W
0039E:  BTFSC  xC3.7
003A0:  BSF    FF2.7
003A2:  MOVWF  FEF
003A4:  INCF   xBE,F
003A6:  BRA    0360
....................    }
003A8:  MOVLB  0
003AA:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0043C:  MOVLB  5
0043E:  CLRF   xBA
00440:  MOVLW  20
00442:  MOVWF  xB9
00444:  CLRF   xBC
00446:  CLRF   xBB
00448:  MOVLW  80
0044A:  MOVWF  xBD
0044C:  MOVLB  0
0044E:  RCALL  03D6
....................    delay_ms(1);
00450:  MOVLW  01
00452:  MOVLB  5
00454:  MOVWF  xBA
00456:  MOVLB  0
00458:  RCALL  03AC
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0045A:  MOVLB  5
0045C:  CLRF   xBA
0045E:  MOVLW  60
00460:  MOVWF  xB9
00462:  CLRF   xBC
00464:  MOVLW  80
00466:  MOVWF  xBB
00468:  MOVLW  02
0046A:  MOVWF  xBD
0046C:  MOVLB  0
0046E:  RCALL  03D6
....................    delay_ms(1);
00470:  MOVLW  01
00472:  MOVLB  5
00474:  MOVWF  xBA
00476:  MOVLB  0
00478:  RCALL  03AC
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0047A:  MOVLB  5
0047C:  CLRF   xBA
0047E:  MOVLW  61
00480:  MOVWF  xB9
00482:  CLRF   xBC
00484:  MOVLW  90
00486:  MOVWF  xBB
00488:  MOVLW  02
0048A:  MOVWF  xBD
0048C:  MOVLB  0
0048E:  RCALL  03D6
....................    delay_ms(1);
00490:  MOVLW  01
00492:  MOVLB  5
00494:  MOVWF  xBA
00496:  MOVLB  0
00498:  RCALL  03AC
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0049A:  MOVLB  5
0049C:  CLRF   xBA
0049E:  MOVLW  62
004A0:  MOVWF  xB9
004A2:  CLRF   xBC
004A4:  MOVLW  A0
004A6:  MOVWF  xBB
004A8:  MOVLW  20
004AA:  MOVWF  xBD
004AC:  MOVLB  0
004AE:  RCALL  03D6
....................    delay_ms(1);
004B0:  MOVLW  01
004B2:  MOVLB  5
004B4:  MOVWF  xBA
004B6:  MOVLB  0
004B8:  RCALL  03AC
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004BA:  MOVLB  5
004BC:  CLRF   xBA
004BE:  MOVLW  82
004C0:  MOVWF  xB9
004C2:  CLRF   xBC
004C4:  MOVLW  C0
004C6:  MOVWF  xBB
004C8:  MOVLW  30
004CA:  MOVWF  xBD
004CC:  MOVLB  0
004CE:  RCALL  03D6
....................    delay_ms(1);
004D0:  MOVLW  01
004D2:  MOVLB  5
004D4:  MOVWF  xBA
004D6:  MOVLB  0
004D8:  RCALL  03AC
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
004DA:  MOVLB  5
004DC:  CLRF   xBA
004DE:  MOVLW  B2
004E0:  MOVWF  xB9
004E2:  CLRF   xBC
004E4:  MOVLW  F0
004E6:  MOVWF  xBB
004E8:  MOVLW  38
004EA:  MOVWF  xBD
004EC:  MOVLB  0
004EE:  RCALL  03D6
....................    delay_ms(1);
004F0:  MOVLW  01
004F2:  MOVLB  5
004F4:  MOVWF  xBA
004F6:  MOVLB  0
004F8:  RCALL  03AC
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
004FA:  MOVLB  5
004FC:  CLRF   xBA
004FE:  MOVLW  F2
00500:  MOVWF  xB9
00502:  MOVLW  01
00504:  MOVWF  xBC
00506:  MOVLW  40
00508:  MOVWF  xBB
0050A:  MOVLW  01
0050C:  MOVWF  xBD
0050E:  MOVLB  0
00510:  RCALL  03D6
....................    delay_ms(1);
00512:  MOVLW  01
00514:  MOVLB  5
00516:  MOVWF  xBA
00518:  MOVLB  0
0051A:  RCALL  03AC
0051C:  GOTO   05EC (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00520:  MOVLB  5
00522:  CLRF   xBA
00524:  MOVLW  20
00526:  MOVWF  xB9
00528:  CLRF   xBC
0052A:  CLRF   xBB
0052C:  MOVLW  80
0052E:  MOVWF  xBD
00530:  MOVLB  0
00532:  RCALL  035A
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00534:  MOVLB  5
00536:  CLRF   xBA
00538:  MOVLW  60
0053A:  MOVWF  xB9
0053C:  CLRF   xBC
0053E:  MOVLW  80
00540:  MOVWF  xBB
00542:  MOVLW  02
00544:  MOVWF  xBD
00546:  MOVLB  0
00548:  RCALL  035A
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0054A:  MOVLB  5
0054C:  CLRF   xBA
0054E:  MOVLW  61
00550:  MOVWF  xB9
00552:  CLRF   xBC
00554:  MOVLW  90
00556:  MOVWF  xBB
00558:  MOVLW  02
0055A:  MOVWF  xBD
0055C:  MOVLB  0
0055E:  RCALL  035A
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00560:  MOVLB  5
00562:  CLRF   xBA
00564:  MOVLW  62
00566:  MOVWF  xB9
00568:  CLRF   xBC
0056A:  MOVLW  A0
0056C:  MOVWF  xBB
0056E:  MOVLW  20
00570:  MOVWF  xBD
00572:  MOVLB  0
00574:  RCALL  035A
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00576:  MOVLB  5
00578:  CLRF   xBA
0057A:  MOVLW  82
0057C:  MOVWF  xB9
0057E:  CLRF   xBC
00580:  MOVLW  C0
00582:  MOVWF  xBB
00584:  MOVLW  30
00586:  MOVWF  xBD
00588:  MOVLB  0
0058A:  RCALL  035A
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0058C:  MOVLB  5
0058E:  CLRF   xBA
00590:  MOVLW  B2
00592:  MOVWF  xB9
00594:  CLRF   xBC
00596:  MOVLW  F0
00598:  MOVWF  xBB
0059A:  MOVLW  38
0059C:  MOVWF  xBD
0059E:  MOVLB  0
005A0:  RCALL  035A
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005A2:  MOVLB  5
005A4:  CLRF   xBA
005A6:  MOVLW  F2
005A8:  MOVWF  xB9
005AA:  MOVLW  01
005AC:  MOVWF  xBC
005AE:  MOVLW  40
005B0:  MOVWF  xBB
005B2:  MOVLW  01
005B4:  MOVWF  xBD
005B6:  MOVLB  0
005B8:  RCALL  035A
005BA:  GOTO   05F0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005BE:  MOVLB  5
005C0:  CLRF   xBA
005C2:  MOVLW  F2
005C4:  MOVWF  xB9
005C6:  MOVLW  01
005C8:  MOVWF  xBC
005CA:  MOVLW  40
005CC:  MOVWF  xBB
005CE:  MOVLW  01
005D0:  MOVWF  xBD
005D2:  MOVLB  0
005D4:  RCALL  035A
....................    delay_ms(1);
005D6:  MOVLW  01
005D8:  MOVLB  5
005DA:  MOVWF  xBA
005DC:  MOVLB  0
005DE:  RCALL  03AC
....................    if (paramsValid != isValid)
005E0:  MOVF   xF2,W
005E2:  SUBLW  AA
005E4:  BZ    05EE
....................    {
....................       paramsValid = isValid;
005E6:  MOVLW  AA
005E8:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
005EA:  BRA    043C
....................    }
005EC:  BRA    05F0
....................    else
....................    {
....................       params_load_from_ee();
005EE:  BRA    0520
....................    }
005F0:  GOTO   6A7A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
*
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  629,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVF   x8D,W
0019E:  MOVWF  03
001A0:  MOVFF  628,E8D
001A4:  RRCF   x90,W
001A6:  BNC   01A4
001A8:  MOVF   x8D,W
001AA:  MOVWF  02
001AC:  MOVFF  627,E8D
001B0:  RRCF   x90,W
001B2:  BNC   01B0
001B4:  MOVF   x8D,W
001B6:  MOVWF  01
001B8:  MOVFF  626,E8D
001BC:  RRCF   x90,W
001BE:  BNC   01BC
001C0:  MOVFF  E8D,00
001C4:  MOVLB  0
001C6:  RETURN 0
*
0127E:  CLRF   03
01280:  MOVLB  E
01282:  MOVF   x8D,W
01284:  MOVFF  5C9,E8D
01288:  RRCF   x90,W
0128A:  BNC   1288
0128C:  MOVF   x8D,W
0128E:  MOVWF  02
01290:  MOVFF  5C8,E8D
01294:  RRCF   x90,W
01296:  BNC   1294
01298:  MOVF   x8D,W
0129A:  MOVWF  01
0129C:  MOVFF  5C7,E8D
012A0:  RRCF   x90,W
012A2:  BNC   12A0
012A4:  MOVFF  E8D,00
012A8:  MOVLB  0
012AA:  GOTO   12CC (RETURN)
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3);
00144:  MOVLW  F4
00146:  MOVWF  F88
00148:  BSF    F83.0
0014A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
005F4:  RCALL  0136
....................    switch(ch)
005F6:  MOVLB  5
005F8:  MOVF   xC9,W
005FA:  XORLW  00
005FC:  MOVLB  0
005FE:  BZ    060A
00600:  XORLW  01
00602:  BZ    0612
00604:  XORLW  03
00606:  BZ    061A
00608:  BRA    0622
....................    {
....................       case 0:
....................          output_low(_CS0);
0060A:  MOVLW  1F
0060C:  MOVWF  F8A
0060E:  BCF    F85.5
....................       break; 
00610:  BRA    0636
....................       case 1:
....................          output_low(_CS1);
00612:  MOVLW  1F
00614:  MOVWF  F8A
00616:  BCF    F85.6
....................       break;   
00618:  BRA    0636
....................       case 2:
....................          output_low(_CS2);
0061A:  MOVLW  1F
0061C:  MOVWF  F8A
0061E:  BCF    F85.7
....................       break;   
00620:  BRA    0636
....................       default: // select all
....................          output_low(_CS0);
00622:  MOVLW  1F
00624:  MOVWF  F8A
00626:  BCF    F85.5
....................          output_low(_CS1);
00628:  MOVWF  F8A
0062A:  BCF    F85.6
....................          output_low(_CS2);
0062C:  MOVWF  F8A
0062E:  BCF    F85.7
....................          output_low(_CS3);
00630:  MOVLW  F4
00632:  MOVWF  F88
00634:  BCF    F83.0
....................       break;             
....................    }
00636:  GOTO   0640 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0014C:  RCALL  0136
....................    switch(block)
0014E:  MOVLB  6
00150:  MOVF   x26,W
00152:  XORLW  00
00154:  MOVLB  0
00156:  BZ    015E
00158:  XORLW  01
0015A:  BZ    016A
0015C:  BRA    0178
....................    {
....................       case 0:
....................          output_low(_CS0);
0015E:  MOVLW  1F
00160:  MOVWF  F8A
00162:  BCF    F85.5
....................          output_low(_CS1);
00164:  MOVWF  F8A
00166:  BCF    F85.6
....................       break; 
00168:  BRA    018C
....................       case 1:
....................          output_low(_CS2);
0016A:  MOVLW  1F
0016C:  MOVWF  F8A
0016E:  BCF    F85.7
....................          output_low(_CS3);
00170:  MOVLW  F4
00172:  MOVWF  F88
00174:  BCF    F83.0
....................       break;   
00176:  BRA    018C
....................       default: // select all
....................          output_low(_CS0);
00178:  MOVLW  1F
0017A:  MOVWF  F8A
0017C:  BCF    F85.5
....................          output_low(_CS1);
0017E:  MOVWF  F8A
00180:  BCF    F85.6
....................          output_low(_CS2);
00182:  MOVWF  F8A
00184:  BCF    F85.7
....................          output_low(_CS3);
00186:  MOVLW  F4
00188:  MOVWF  F88
0018A:  BCF    F83.0
....................       break;             
....................    }
0018C:  GOTO   01CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE                                                    */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0063A:  MOVFF  5C7,5C9
0063E:  BRA    05F4
00640:  CLRF   19
00642:  BTFSC  FF2.7
00644:  BSF    19.7
00646:  BCF    FF2.7
....................    spi_xfer(SPI_mon, command);
00648:  MOVLB  6
0064A:  CLRF   x29
0064C:  CLRF   x28
0064E:  CLRF   x27
00650:  MOVFF  5C8,626
00654:  MOVLB  0
00656:  RCALL  0190
00658:  BTFSC  19.7
0065A:  BSF    FF2.7
0065C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C8:  MOVFF  624,626
001CC:  BRA    014C
....................    spi_xfer(SPI_mon, command);
001CE:  MOVLB  6
001D0:  CLRF   x29
001D2:  CLRF   x28
001D4:  CLRF   x27
001D6:  MOVFF  625,626
001DA:  MOVLB  0
001DC:  RCALL  0190
001DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE REGISTER DATA                                                       */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00684:  MOVLB  5
00686:  MOVF   xC4,W
00688:  IORLW  40
0068A:  MOVWF  xC6
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0068C:  MOVFF  5C3,5C7
00690:  MOVFF  5C6,5C8
00694:  MOVLB  0
00696:  RCALL  063A
00698:  CLRF   19
0069A:  BTFSC  FF2.7
0069C:  BSF    19.7
0069E:  BCF    FF2.7
....................    spi_xfer(SPI_mon, data);
006A0:  MOVLB  6
006A2:  CLRF   x29
006A4:  CLRF   x28
006A6:  CLRF   x27
006A8:  MOVFF  5C5,626
006AC:  MOVLB  0
006AE:  RCALL  0190
006B0:  BTFSC  19.7
006B2:  BSF    FF2.7
....................    ads_deselect_all();
006B4:  RCALL  0136
006B6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER REGISTER                                                    */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_write_command(ch, command);
....................    unsigned int8 data = spi_xfer(SPI_mon, 0, 8);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ DATA                                                                 */
.................... /*****************************************************************************/
.................... unsigned int32 ads_read_data(int8 ch)
.................... {
....................    ads_write_command(ch, ADSreadData);
*
012AE:  MOVFF  5C2,5C7
012B2:  MOVLW  10
012B4:  MOVLB  5
012B6:  MOVWF  xC8
012B8:  MOVLB  0
012BA:  CALL   063A
....................    unsigned int32 data = spi_xfer(SPI_mon, 0, 24);
012BE:  MOVLB  5
012C0:  CLRF   xCA
012C2:  CLRF   xC9
012C4:  CLRF   xC8
012C6:  CLRF   xC7
012C8:  MOVLB  0
012CA:  BRA    127E
012CC:  MOVF   01,W
012CE:  MOVFF  03,5C6
012D2:  MOVFF  02,5C5
012D6:  MOVFF  01,5C4
012DA:  MOVFF  00,5C3
....................    ads_deselect_all();
012DE:  CALL   0136
....................    return data;
012E2:  MOVFF  5C3,00
012E6:  MOVFF  5C4,01
012EA:  MOVFF  5C5,02
012EE:  MOVFF  5C6,03
012F2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
006B8:  MOVFF  5BE,5C7
006BC:  MOVLW  06
006BE:  MOVLB  5
006C0:  MOVWF  xC8
006C2:  MOVLB  0
006C4:  RCALL  063A
....................    delay_us(100);                    
006C6:  MOVLW  64
006C8:  MOVLB  5
006CA:  MOVWF  xC3
006CC:  MOVLB  0
006CE:  BRA    065E
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
006D0:  MOVFF  5BE,5C3
006D4:  MOVLB  5
006D6:  CLRF   xC4
006D8:  MOVFF  5BF,5C5
006DC:  MOVLB  0
006DE:  RCALL  0684
....................    ads_write_reg(ch, reg1, rc1);
006E0:  MOVFF  5BE,5C3
006E4:  MOVLW  04
006E6:  MOVLB  5
006E8:  MOVWF  xC4
006EA:  MOVFF  5C0,5C5
006EE:  MOVLB  0
006F0:  RCALL  0684
....................    ads_write_reg(ch, reg2, rc2);
006F2:  MOVFF  5BE,5C3
006F6:  MOVLW  08
006F8:  MOVLB  5
006FA:  MOVWF  xC4
006FC:  MOVFF  5C1,5C5
00700:  MOVLB  0
00702:  RCALL  0684
....................    ads_write_reg(ch, reg3, rc3);  
00704:  MOVFF  5BE,5C3
00708:  MOVLW  0C
0070A:  MOVLB  5
0070C:  MOVWF  xC4
0070E:  MOVFF  5C2,5C5
00712:  MOVLB  0
00714:  RCALL  0684
00716:  GOTO   0752 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01D14:  MOVLB  6
01D16:  BCF    x0C.0
....................    y = x;
01D18:  MOVFF  600,605
01D1C:  MOVFF  5FF,604
01D20:  MOVFF  5FE,603
01D24:  MOVFF  5FD,602
.................... 
....................    if (x < 0)
01D28:  MOVFF  600,613
01D2C:  MOVFF  5FF,612
01D30:  MOVFF  5FE,611
01D34:  MOVFF  5FD,610
01D38:  CLRF   x17
01D3A:  CLRF   x16
01D3C:  CLRF   x15
01D3E:  CLRF   x14
01D40:  MOVLB  0
01D42:  CALL   132C
01D46:  BNC   1D54
....................    {
....................       s = 1;
01D48:  MOVLB  6
01D4A:  BSF    x0C.0
....................       y = -y;
01D4C:  MOVF   x03,W
01D4E:  XORLW  80
01D50:  MOVWF  x03
01D52:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01D54:  MOVFF  605,613
01D58:  MOVFF  604,612
01D5C:  MOVFF  603,611
01D60:  MOVFF  602,610
01D64:  MOVLB  6
01D66:  CLRF   x17
01D68:  CLRF   x16
01D6A:  CLRF   x15
01D6C:  MOVLW  8E
01D6E:  MOVWF  x14
01D70:  MOVLB  0
01D72:  CALL   132C
01D76:  BC    1D7A
01D78:  BNZ   1DAA
....................       res = (float32)(unsigned int16)y;
01D7A:  MOVFF  605,613
01D7E:  MOVFF  604,612
01D82:  MOVFF  603,611
01D86:  MOVFF  602,610
01D8A:  RCALL  1CD8
01D8C:  MOVFF  02,615
01D90:  MOVFF  01,614
01D94:  CALL   09C4
01D98:  MOVFF  03,609
01D9C:  MOVFF  02,608
01DA0:  MOVFF  01,607
01DA4:  MOVFF  00,606
01DA8:  BRA    1F4C
.................... 
....................  else if (y < 10000000.0)
01DAA:  MOVFF  605,613
01DAE:  MOVFF  604,612
01DB2:  MOVFF  603,611
01DB6:  MOVFF  602,610
01DBA:  MOVLW  80
01DBC:  MOVLB  6
01DBE:  MOVWF  x17
01DC0:  MOVLW  96
01DC2:  MOVWF  x16
01DC4:  MOVLW  18
01DC6:  MOVWF  x15
01DC8:  MOVLW  96
01DCA:  MOVWF  x14
01DCC:  MOVLB  0
01DCE:  CALL   132C
01DD2:  BTFSS  FD8.0
01DD4:  BRA    1F3C
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01DD6:  MOVFF  605,613
01DDA:  MOVFF  604,612
01DDE:  MOVFF  603,611
01DE2:  MOVFF  602,610
01DE6:  MOVLB  6
01DE8:  CLRF   x17
01DEA:  CLRF   x16
01DEC:  CLRF   x15
01DEE:  MOVLW  70
01DF0:  MOVWF  x14
01DF2:  MOVLB  0
01DF4:  CALL   09FA
01DF8:  MOVFF  03,613
01DFC:  MOVFF  02,612
01E00:  MOVFF  01,611
01E04:  MOVFF  00,610
01E08:  RCALL  1CD8
01E0A:  MOVFF  02,60B
01E0E:  MOVFF  01,60A
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01E12:  MOVFF  605,613
01E16:  MOVFF  604,612
01E1A:  MOVFF  603,611
01E1E:  MOVFF  602,610
01E22:  MOVLB  6
01E24:  CLRF   x17
01E26:  CLRF   x16
01E28:  CLRF   x15
01E2A:  MOVLW  70
01E2C:  MOVWF  x14
01E2E:  MOVLB  0
01E30:  CALL   09FA
01E34:  MOVFF  03,610
01E38:  MOVFF  02,60F
01E3C:  MOVFF  01,60E
01E40:  MOVFF  00,60D
01E44:  MOVFF  60B,615
01E48:  MOVFF  60A,614
01E4C:  CALL   09C4
01E50:  BSF    FD8.1
01E52:  MOVFF  610,617
01E56:  MOVFF  60F,616
01E5A:  MOVFF  60E,615
01E5E:  MOVFF  60D,614
01E62:  MOVFF  03,61B
01E66:  MOVFF  02,61A
01E6A:  MOVFF  01,619
01E6E:  MOVFF  00,618
01E72:  CALL   0AF0
01E76:  MOVLB  6
01E78:  CLRF   x13
01E7A:  CLRF   x12
01E7C:  CLRF   x11
01E7E:  MOVLW  8E
01E80:  MOVWF  x10
01E82:  MOVFF  03,617
01E86:  MOVFF  02,616
01E8A:  MOVFF  01,615
01E8E:  MOVFF  00,614
01E92:  MOVLB  0
01E94:  CALL   09FA
01E98:  MOVFF  03,605
01E9C:  MOVFF  02,604
01EA0:  MOVFF  01,603
01EA4:  MOVFF  00,602
....................       res = 32768.0*(float32)l;
01EA8:  MOVFF  60B,615
01EAC:  MOVFF  60A,614
01EB0:  CALL   09C4
01EB4:  MOVLB  6
01EB6:  CLRF   x13
01EB8:  CLRF   x12
01EBA:  CLRF   x11
01EBC:  MOVLW  8E
01EBE:  MOVWF  x10
01EC0:  MOVFF  03,617
01EC4:  MOVFF  02,616
01EC8:  MOVFF  01,615
01ECC:  MOVFF  00,614
01ED0:  MOVLB  0
01ED2:  CALL   09FA
01ED6:  MOVFF  03,609
01EDA:  MOVFF  02,608
01EDE:  MOVFF  01,607
01EE2:  MOVFF  00,606
....................       res += (float32)(unsigned int16)y;
01EE6:  MOVFF  605,613
01EEA:  MOVFF  604,612
01EEE:  MOVFF  603,611
01EF2:  MOVFF  602,610
01EF6:  RCALL  1CD8
01EF8:  MOVFF  02,615
01EFC:  MOVFF  01,614
01F00:  CALL   09C4
01F04:  BCF    FD8.1
01F06:  MOVFF  609,617
01F0A:  MOVFF  608,616
01F0E:  MOVFF  607,615
01F12:  MOVFF  606,614
01F16:  MOVFF  03,61B
01F1A:  MOVFF  02,61A
01F1E:  MOVFF  01,619
01F22:  MOVFF  00,618
01F26:  CALL   0AF0
01F2A:  MOVFF  03,609
01F2E:  MOVFF  02,608
01F32:  MOVFF  01,607
01F36:  MOVFF  00,606
....................    }
01F3A:  BRA    1F4C
.................... 
....................  else
....................   res = y;
01F3C:  MOVFF  605,609
01F40:  MOVFF  604,608
01F44:  MOVFF  603,607
01F48:  MOVFF  602,606
.................... 
....................  y = y - (float32)(unsigned int16)y;
01F4C:  MOVFF  605,613
01F50:  MOVFF  604,612
01F54:  MOVFF  603,611
01F58:  MOVFF  602,610
01F5C:  RCALL  1CD8
01F5E:  MOVFF  02,615
01F62:  MOVFF  01,614
01F66:  CALL   09C4
01F6A:  BSF    FD8.1
01F6C:  MOVFF  605,617
01F70:  MOVFF  604,616
01F74:  MOVFF  603,615
01F78:  MOVFF  602,614
01F7C:  MOVFF  03,61B
01F80:  MOVFF  02,61A
01F84:  MOVFF  01,619
01F88:  MOVFF  00,618
01F8C:  CALL   0AF0
01F90:  MOVFF  03,605
01F94:  MOVFF  02,604
01F98:  MOVFF  01,603
01F9C:  MOVFF  00,602
.................... 
....................  if (s)
01FA0:  MOVLB  6
01FA2:  BTFSS  x0C.0
01FA4:  BRA    1FAC
....................   res = -res;
01FA6:  MOVF   x07,W
01FA8:  XORLW  80
01FAA:  MOVWF  x07
.................... 
....................  if (y != 0)
01FAC:  MOVFF  605,613
01FB0:  MOVFF  604,612
01FB4:  MOVFF  603,611
01FB8:  MOVFF  602,610
01FBC:  CLRF   x17
01FBE:  CLRF   x16
01FC0:  CLRF   x15
01FC2:  CLRF   x14
01FC4:  MOVLB  0
01FC6:  CALL   132C
01FCA:  BZ    2044
....................  {
....................   if (s == 1 && n == 0)
01FCC:  MOVLB  6
01FCE:  BTFSS  x0C.0
01FD0:  BRA    200A
01FD2:  MOVF   x01,F
01FD4:  BNZ   200A
....................    res -= 1.0;
01FD6:  BSF    FD8.1
01FD8:  MOVFF  609,617
01FDC:  MOVFF  608,616
01FE0:  MOVFF  607,615
01FE4:  MOVFF  606,614
01FE8:  CLRF   x1B
01FEA:  CLRF   x1A
01FEC:  CLRF   x19
01FEE:  MOVLW  7F
01FF0:  MOVWF  x18
01FF2:  MOVLB  0
01FF4:  CALL   0AF0
01FF8:  MOVFF  03,609
01FFC:  MOVFF  02,608
02000:  MOVFF  01,607
02004:  MOVFF  00,606
02008:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
0200A:  BTFSC  x0C.0
0200C:  BRA    2046
0200E:  DECFSZ x01,W
02010:  BRA    2046
....................    res += 1.0;
02012:  BCF    FD8.1
02014:  MOVFF  609,617
02018:  MOVFF  608,616
0201C:  MOVFF  607,615
02020:  MOVFF  606,614
02024:  CLRF   x1B
02026:  CLRF   x1A
02028:  CLRF   x19
0202A:  MOVLW  7F
0202C:  MOVWF  x18
0202E:  MOVLB  0
02030:  CALL   0AF0
02034:  MOVFF  03,609
02038:  MOVFF  02,608
0203C:  MOVFF  01,607
02040:  MOVFF  00,606
02044:  MOVLB  6
....................  }
....................  if (x == 0)
02046:  MOVFF  600,613
0204A:  MOVFF  5FF,612
0204E:  MOVFF  5FE,611
02052:  MOVFF  5FD,610
02056:  CLRF   x17
02058:  CLRF   x16
0205A:  CLRF   x15
0205C:  CLRF   x14
0205E:  MOVLB  0
02060:  CALL   132C
02064:  BNZ   2072
....................     res = 0;
02066:  MOVLB  6
02068:  CLRF   x09
0206A:  CLRF   x08
0206C:  CLRF   x07
0206E:  CLRF   x06
02070:  MOVLB  0
.................... 
....................  return (res);
02072:  MOVFF  606,00
02076:  MOVFF  607,01
0207A:  MOVFF  608,02
0207E:  MOVFF  609,03
02082:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
020A2:  MOVFF  5FC,600
020A6:  MOVFF  5FB,5FF
020AA:  MOVFF  5FA,5FE
020AE:  MOVFF  5F9,5FD
020B2:  MOVLB  6
020B4:  CLRF   x01
020B6:  MOVLB  0
020B8:  RCALL  1D14
020BA:  GOTO   21C6 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02084:  MOVFF  5FC,600
02088:  MOVFF  5FB,5FF
0208C:  MOVFF  5FA,5FE
02090:  MOVFF  5F9,5FD
02094:  MOVLW  01
02096:  MOVLB  6
02098:  MOVWF  x01
0209A:  MOVLB  0
0209C:  RCALL  1D14
0209E:  GOTO   217E (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
020BE:  MOVFF  5F0,613
020C2:  MOVFF  5EF,612
020C6:  MOVFF  5EE,611
020CA:  MOVFF  5ED,610
020CE:  MOVLB  6
020D0:  CLRF   x17
020D2:  CLRF   x16
020D4:  CLRF   x15
020D6:  CLRF   x14
020D8:  MOVLB  0
020DA:  CALL   132C
020DE:  BTFSC  FD8.2
020E0:  BRA    2222
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
020E2:  MOVFF  5EC,609
020E6:  MOVFF  5EB,608
020EA:  MOVFF  5EA,607
020EE:  MOVFF  5E9,606
020F2:  MOVFF  5F0,60D
020F6:  MOVFF  5EF,60C
020FA:  MOVFF  5EE,60B
020FE:  MOVFF  5ED,60A
02102:  CALL   13A6
02106:  MOVFF  03,5F8
0210A:  MOVFF  02,5F7
0210E:  MOVFF  01,5F6
02112:  MOVFF  00,5F5
02116:  MOVFF  03,613
0211A:  MOVFF  02,612
0211E:  MOVFF  01,611
02122:  MOVFF  00,610
02126:  MOVLB  6
02128:  CLRF   x17
0212A:  CLRF   x16
0212C:  CLRF   x15
0212E:  CLRF   x14
02130:  MOVLB  0
02132:  CALL   132C
02136:  BNC   2180
02138:  MOVFF  5EC,609
0213C:  MOVFF  5EB,608
02140:  MOVFF  5EA,607
02144:  MOVFF  5E9,606
02148:  MOVFF  5F0,60D
0214C:  MOVFF  5EF,60C
02150:  MOVFF  5EE,60B
02154:  MOVFF  5ED,60A
02158:  CALL   13A6
0215C:  MOVFF  03,5F8
02160:  MOVFF  02,5F7
02164:  MOVFF  01,5F6
02168:  MOVFF  00,5F5
0216C:  MOVFF  03,5FC
02170:  MOVFF  02,5FB
02174:  MOVFF  01,5FA
02178:  MOVFF  00,5F9
0217C:  BRA    2084
0217E:  BRA    21C6
02180:  MOVFF  5EC,609
02184:  MOVFF  5EB,608
02188:  MOVFF  5EA,607
0218C:  MOVFF  5E9,606
02190:  MOVFF  5F0,60D
02194:  MOVFF  5EF,60C
02198:  MOVFF  5EE,60B
0219C:  MOVFF  5ED,60A
021A0:  CALL   13A6
021A4:  MOVFF  03,5F8
021A8:  MOVFF  02,5F7
021AC:  MOVFF  01,5F6
021B0:  MOVFF  00,5F5
021B4:  MOVFF  03,5FC
021B8:  MOVFF  02,5FB
021BC:  MOVFF  01,5FA
021C0:  MOVFF  00,5F9
021C4:  BRA    20A2
021C6:  MOVFF  03,5F4
021CA:  MOVFF  02,5F3
021CE:  MOVFF  01,5F2
021D2:  MOVFF  00,5F1
....................       return(x-(i*y));
021D6:  MOVFF  5F4,613
021DA:  MOVFF  5F3,612
021DE:  MOVFF  5F2,611
021E2:  MOVFF  5F1,610
021E6:  MOVFF  5F0,617
021EA:  MOVFF  5EF,616
021EE:  MOVFF  5EE,615
021F2:  MOVFF  5ED,614
021F6:  CALL   09FA
021FA:  BSF    FD8.1
021FC:  MOVFF  5EC,617
02200:  MOVFF  5EB,616
02204:  MOVFF  5EA,615
02208:  MOVFF  5E9,614
0220C:  MOVFF  03,61B
02210:  MOVFF  02,61A
02214:  MOVFF  01,619
02218:  MOVFF  00,618
0221C:  CALL   0AF0
02220:  BRA    2222
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02222:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02608:  MOVFF  5F0,613
0260C:  MOVFF  5EF,612
02610:  MOVFF  5EE,611
02614:  MOVFF  5ED,610
02618:  MOVLW  3B
0261A:  MOVLB  6
0261C:  MOVWF  x17
0261E:  MOVLW  AA
02620:  MOVWF  x16
02622:  MOVLW  38
02624:  MOVWF  x15
02626:  MOVLW  7F
02628:  MOVWF  x14
0262A:  MOVLB  0
0262C:  CALL   09FA
02630:  MOVFF  03,613
02634:  MOVFF  02,612
02638:  MOVFF  01,611
0263C:  MOVFF  00,610
02640:  CALL   1CD8
02644:  MOVFF  01,5FD
....................    s = 0;
02648:  MOVLB  5
0264A:  BCF    xFE.0
....................    y = x;
0264C:  MOVFF  5F0,5F4
02650:  MOVFF  5EF,5F3
02654:  MOVFF  5EE,5F2
02658:  MOVFF  5ED,5F1
.................... 
....................    if (x < 0)
0265C:  MOVFF  5F0,613
02660:  MOVFF  5EF,612
02664:  MOVFF  5EE,611
02668:  MOVFF  5ED,610
0266C:  MOVLB  6
0266E:  CLRF   x17
02670:  CLRF   x16
02672:  CLRF   x15
02674:  CLRF   x14
02676:  MOVLB  0
02678:  CALL   132C
0267C:  BNC   268C
....................    {
....................       s = 1;
0267E:  MOVLB  5
02680:  BSF    xFE.0
....................       n = -n;
02682:  NEGF   xFD
....................       y = -y;
02684:  MOVF   xF2,W
02686:  XORLW  80
02688:  MOVWF  xF2
0268A:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0268C:  MOVLB  5
0268E:  CLRF   xF8
02690:  CLRF   xF7
02692:  CLRF   xF6
02694:  CLRF   xF5
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
02696:  MOVLW  05
02698:  MOVLB  6
0269A:  MOVWF  x00
0269C:  MOVLW  F5
0269E:  MOVLB  5
026A0:  MOVFF  600,FEA
026A4:  MOVWF  FE9
026A6:  MOVLW  7F
026A8:  ADDWF  xFD,W
026AA:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
026AC:  MOVFF  5F4,613
026B0:  MOVFF  5F3,612
026B4:  MOVFF  5F2,611
026B8:  MOVFF  5F1,610
026BC:  MOVLW  3B
026BE:  MOVLB  6
026C0:  MOVWF  x17
026C2:  MOVLW  AA
026C4:  MOVWF  x16
026C6:  MOVLW  38
026C8:  MOVWF  x15
026CA:  MOVLW  7F
026CC:  MOVWF  x14
026CE:  MOVLB  0
026D0:  CALL   09FA
026D4:  MOVFF  03,602
026D8:  MOVFF  02,601
026DC:  MOVFF  01,600
026E0:  MOVFF  00,5FF
026E4:  MOVLB  6
026E6:  CLRF   x04
026E8:  MOVFF  5FD,603
026EC:  BTFSC  x03.7
026EE:  DECF   x04,F
026F0:  MOVLB  0
026F2:  RCALL  2224
026F4:  BSF    FD8.1
026F6:  MOVFF  602,617
026FA:  MOVFF  601,616
026FE:  MOVFF  600,615
02702:  MOVFF  5FF,614
02706:  MOVFF  03,61B
0270A:  MOVFF  02,61A
0270E:  MOVFF  01,619
02712:  MOVFF  00,618
02716:  CALL   0AF0
0271A:  MOVFF  03,5F4
0271E:  MOVFF  02,5F3
02722:  MOVFF  01,5F2
02726:  MOVFF  00,5F1
.................... 
....................    r = pe[0]*y + pe[1];
0272A:  MOVLW  7C
0272C:  MOVLB  6
0272E:  MOVWF  x13
02730:  MOVLW  88
02732:  MOVWF  x12
02734:  MOVLW  59
02736:  MOVWF  x11
02738:  MOVLW  72
0273A:  MOVWF  x10
0273C:  MOVFF  5F4,617
02740:  MOVFF  5F3,616
02744:  MOVFF  5F2,615
02748:  MOVFF  5F1,614
0274C:  MOVLB  0
0274E:  CALL   09FA
02752:  MOVFF  03,602
02756:  MOVFF  02,601
0275A:  MOVFF  01,600
0275E:  MOVFF  00,5FF
02762:  BCF    FD8.1
02764:  MOVFF  03,617
02768:  MOVFF  02,616
0276C:  MOVFF  01,615
02770:  MOVFF  00,614
02774:  MOVLW  E0
02776:  MOVLB  6
02778:  MOVWF  x1B
0277A:  MOVLW  97
0277C:  MOVWF  x1A
0277E:  MOVLW  26
02780:  MOVWF  x19
02782:  MOVLW  75
02784:  MOVWF  x18
02786:  MOVLB  0
02788:  CALL   0AF0
0278C:  MOVFF  03,5FC
02790:  MOVFF  02,5FB
02794:  MOVFF  01,5FA
02798:  MOVFF  00,5F9
....................    r = r*y + pe[2];
0279C:  MOVFF  5FC,613
027A0:  MOVFF  5FB,612
027A4:  MOVFF  5FA,611
027A8:  MOVFF  5F9,610
027AC:  MOVFF  5F4,617
027B0:  MOVFF  5F3,616
027B4:  MOVFF  5F2,615
027B8:  MOVFF  5F1,614
027BC:  CALL   09FA
027C0:  MOVFF  03,602
027C4:  MOVFF  02,601
027C8:  MOVFF  01,600
027CC:  MOVFF  00,5FF
027D0:  BCF    FD8.1
027D2:  MOVFF  03,617
027D6:  MOVFF  02,616
027DA:  MOVFF  01,615
027DE:  MOVFF  00,614
027E2:  MOVLW  C4
027E4:  MOVLB  6
027E6:  MOVWF  x1B
027E8:  MOVLW  1D
027EA:  MOVWF  x1A
027EC:  MOVLW  1E
027EE:  MOVWF  x19
027F0:  MOVLW  78
027F2:  MOVWF  x18
027F4:  MOVLB  0
027F6:  CALL   0AF0
027FA:  MOVFF  03,5FC
027FE:  MOVFF  02,5FB
02802:  MOVFF  01,5FA
02806:  MOVFF  00,5F9
....................    r = r*y + pe[3];
0280A:  MOVFF  5FC,613
0280E:  MOVFF  5FB,612
02812:  MOVFF  5FA,611
02816:  MOVFF  5F9,610
0281A:  MOVFF  5F4,617
0281E:  MOVFF  5F3,616
02822:  MOVFF  5F2,615
02826:  MOVFF  5F1,614
0282A:  CALL   09FA
0282E:  MOVFF  03,602
02832:  MOVFF  02,601
02836:  MOVFF  01,600
0283A:  MOVFF  00,5FF
0283E:  BCF    FD8.1
02840:  MOVFF  03,617
02844:  MOVFF  02,616
02848:  MOVFF  01,615
0284C:  MOVFF  00,614
02850:  MOVLW  5E
02852:  MOVLB  6
02854:  MOVWF  x1B
02856:  MOVLW  50
02858:  MOVWF  x1A
0285A:  MOVLW  63
0285C:  MOVWF  x19
0285E:  MOVLW  7A
02860:  MOVWF  x18
02862:  MOVLB  0
02864:  CALL   0AF0
02868:  MOVFF  03,5FC
0286C:  MOVFF  02,5FB
02870:  MOVFF  01,5FA
02874:  MOVFF  00,5F9
....................    r = r*y + pe[4];
02878:  MOVFF  5FC,613
0287C:  MOVFF  5FB,612
02880:  MOVFF  5FA,611
02884:  MOVFF  5F9,610
02888:  MOVFF  5F4,617
0288C:  MOVFF  5F3,616
02890:  MOVFF  5F2,615
02894:  MOVFF  5F1,614
02898:  CALL   09FA
0289C:  MOVFF  03,602
028A0:  MOVFF  02,601
028A4:  MOVFF  01,600
028A8:  MOVFF  00,5FF
028AC:  BCF    FD8.1
028AE:  MOVFF  03,617
028B2:  MOVFF  02,616
028B6:  MOVFF  01,615
028BA:  MOVFF  00,614
028BE:  MOVLW  1A
028C0:  MOVLB  6
028C2:  MOVWF  x1B
028C4:  MOVLW  FE
028C6:  MOVWF  x1A
028C8:  MOVLW  75
028CA:  MOVWF  x19
028CC:  MOVLW  7C
028CE:  MOVWF  x18
028D0:  MOVLB  0
028D2:  CALL   0AF0
028D6:  MOVFF  03,5FC
028DA:  MOVFF  02,5FB
028DE:  MOVFF  01,5FA
028E2:  MOVFF  00,5F9
....................    r = r*y + pe[5];
028E6:  MOVFF  5FC,613
028EA:  MOVFF  5FB,612
028EE:  MOVFF  5FA,611
028F2:  MOVFF  5F9,610
028F6:  MOVFF  5F4,617
028FA:  MOVFF  5F3,616
028FE:  MOVFF  5F2,615
02902:  MOVFF  5F1,614
02906:  CALL   09FA
0290A:  MOVFF  03,602
0290E:  MOVFF  02,601
02912:  MOVFF  01,600
02916:  MOVFF  00,5FF
0291A:  BCF    FD8.1
0291C:  MOVFF  03,617
02920:  MOVFF  02,616
02924:  MOVFF  01,615
02928:  MOVFF  00,614
0292C:  MOVLW  18
0292E:  MOVLB  6
02930:  MOVWF  x1B
02932:  MOVLW  72
02934:  MOVWF  x1A
02936:  MOVLW  31
02938:  MOVWF  x19
0293A:  MOVLW  7E
0293C:  MOVWF  x18
0293E:  MOVLB  0
02940:  CALL   0AF0
02944:  MOVFF  03,5FC
02948:  MOVFF  02,5FB
0294C:  MOVFF  01,5FA
02950:  MOVFF  00,5F9
.................... 
....................    res = res*(1.0 + y*r);
02954:  MOVFF  5F4,613
02958:  MOVFF  5F3,612
0295C:  MOVFF  5F2,611
02960:  MOVFF  5F1,610
02964:  MOVFF  5FC,617
02968:  MOVFF  5FB,616
0296C:  MOVFF  5FA,615
02970:  MOVFF  5F9,614
02974:  CALL   09FA
02978:  BCF    FD8.1
0297A:  MOVLB  6
0297C:  CLRF   x17
0297E:  CLRF   x16
02980:  CLRF   x15
02982:  MOVLW  7F
02984:  MOVWF  x14
02986:  MOVFF  03,61B
0298A:  MOVFF  02,61A
0298E:  MOVFF  01,619
02992:  MOVFF  00,618
02996:  MOVLB  0
02998:  CALL   0AF0
0299C:  MOVFF  5F8,613
029A0:  MOVFF  5F7,612
029A4:  MOVFF  5F6,611
029A8:  MOVFF  5F5,610
029AC:  MOVFF  03,617
029B0:  MOVFF  02,616
029B4:  MOVFF  01,615
029B8:  MOVFF  00,614
029BC:  CALL   09FA
029C0:  MOVFF  03,5F8
029C4:  MOVFF  02,5F7
029C8:  MOVFF  01,5F6
029CC:  MOVFF  00,5F5
.................... 
....................    if (s)
029D0:  MOVLB  5
029D2:  BTFSS  xFE.0
029D4:  BRA    2A0A
....................       res = 1.0/res;
029D6:  MOVLB  6
029D8:  CLRF   x09
029DA:  CLRF   x08
029DC:  CLRF   x07
029DE:  MOVLW  7F
029E0:  MOVWF  x06
029E2:  MOVFF  5F8,60D
029E6:  MOVFF  5F7,60C
029EA:  MOVFF  5F6,60B
029EE:  MOVFF  5F5,60A
029F2:  MOVLB  0
029F4:  CALL   13A6
029F8:  MOVFF  03,5F8
029FC:  MOVFF  02,5F7
02A00:  MOVFF  01,5F6
02A04:  MOVFF  00,5F5
02A08:  MOVLB  5
....................    return(res);
02A0A:  MOVFF  5F5,00
02A0E:  MOVFF  5F6,01
02A12:  MOVFF  5F7,02
02A16:  MOVFF  5F8,03
02A1A:  MOVLB  0
02A1C:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02274:  MOVFF  5F0,5F4
02278:  MOVFF  5EF,5F3
0227C:  MOVFF  5EE,5F2
02280:  MOVFF  5ED,5F1
.................... 
....................    if (y != 1.0)
02284:  MOVFF  5F4,613
02288:  MOVFF  5F3,612
0228C:  MOVFF  5F2,611
02290:  MOVFF  5F1,610
02294:  MOVLB  6
02296:  CLRF   x17
02298:  CLRF   x16
0229A:  CLRF   x15
0229C:  MOVLW  7F
0229E:  MOVWF  x14
022A0:  MOVLB  0
022A2:  CALL   132C
022A6:  BTFSC  FD8.2
022A8:  BRA    25EA
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
022AA:  MOVLW  05
022AC:  MOVLB  6
022AE:  MOVWF  x03
022B0:  MOVLW  F1
022B2:  MOVFF  603,FEA
022B6:  MOVWF  FE9
022B8:  MOVLW  7E
022BA:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
022BC:  BSF    FD8.1
022BE:  MOVFF  5F4,617
022C2:  MOVFF  5F3,616
022C6:  MOVFF  5F2,615
022CA:  MOVFF  5F1,614
022CE:  CLRF   x1B
022D0:  CLRF   x1A
022D2:  CLRF   x19
022D4:  MOVLW  7F
022D6:  MOVWF  x18
022D8:  MOVLB  0
022DA:  CALL   0AF0
022DE:  MOVFF  03,605
022E2:  MOVFF  02,604
022E6:  MOVFF  01,603
022EA:  MOVFF  00,602
022EE:  BCF    FD8.1
022F0:  MOVFF  5F4,617
022F4:  MOVFF  5F3,616
022F8:  MOVFF  5F2,615
022FC:  MOVFF  5F1,614
02300:  MOVLB  6
02302:  CLRF   x1B
02304:  CLRF   x1A
02306:  CLRF   x19
02308:  MOVLW  7F
0230A:  MOVWF  x18
0230C:  MOVLB  0
0230E:  CALL   0AF0
02312:  MOVFF  605,609
02316:  MOVFF  604,608
0231A:  MOVFF  603,607
0231E:  MOVFF  602,606
02322:  MOVFF  03,60D
02326:  MOVFF  02,60C
0232A:  MOVFF  01,60B
0232E:  MOVFF  00,60A
02332:  CALL   13A6
02336:  MOVFF  03,5F4
0233A:  MOVFF  02,5F3
0233E:  MOVFF  01,5F2
02342:  MOVFF  00,5F1
.................... 
....................       y2=y*y;
02346:  MOVFF  5F4,613
0234A:  MOVFF  5F3,612
0234E:  MOVFF  5F2,611
02352:  MOVFF  5F1,610
02356:  MOVFF  5F4,617
0235A:  MOVFF  5F3,616
0235E:  MOVFF  5F2,615
02362:  MOVFF  5F1,614
02366:  CALL   09FA
0236A:  MOVFF  03,600
0236E:  MOVFF  02,5FF
02372:  MOVFF  01,5FE
02376:  MOVFF  00,5FD
.................... 
....................       res = pl[0]*y2 + pl[1];
0237A:  MOVLW  99
0237C:  MOVLB  6
0237E:  MOVWF  x13
02380:  MOVLW  47
02382:  MOVWF  x12
02384:  MOVLW  8A
02386:  MOVWF  x11
02388:  MOVLW  7F
0238A:  MOVWF  x10
0238C:  MOVFF  600,617
02390:  MOVFF  5FF,616
02394:  MOVFF  5FE,615
02398:  MOVFF  5FD,614
0239C:  MOVLB  0
0239E:  CALL   09FA
023A2:  MOVFF  03,605
023A6:  MOVFF  02,604
023AA:  MOVFF  01,603
023AE:  MOVFF  00,602
023B2:  BCF    FD8.1
023B4:  MOVFF  03,617
023B8:  MOVFF  02,616
023BC:  MOVFF  01,615
023C0:  MOVFF  00,614
023C4:  MOVLB  6
023C6:  CLRF   x1B
023C8:  CLRF   x1A
023CA:  CLRF   x19
023CC:  MOVLW  80
023CE:  MOVWF  x18
023D0:  MOVLB  0
023D2:  CALL   0AF0
023D6:  MOVFF  03,5F8
023DA:  MOVFF  02,5F7
023DE:  MOVFF  01,5F6
023E2:  MOVFF  00,5F5
.................... 
....................       r = ql[0]*y2 + ql[1];
023E6:  MOVLW  4C
023E8:  MOVLB  6
023EA:  MOVWF  x13
023EC:  MOVLW  F3
023EE:  MOVWF  x12
023F0:  MOVLW  3A
023F2:  MOVWF  x11
023F4:  MOVLW  7B
023F6:  MOVWF  x10
023F8:  MOVFF  600,617
023FC:  MOVFF  5FF,616
02400:  MOVFF  5FE,615
02404:  MOVFF  5FD,614
02408:  MOVLB  0
0240A:  CALL   09FA
0240E:  MOVFF  03,605
02412:  MOVFF  02,604
02416:  MOVFF  01,603
0241A:  MOVFF  00,602
0241E:  BCF    FD8.1
02420:  MOVFF  03,617
02424:  MOVFF  02,616
02428:  MOVFF  01,615
0242C:  MOVFF  00,614
02430:  MOVLW  2B
02432:  MOVLB  6
02434:  MOVWF  x1B
02436:  MOVLW  9D
02438:  MOVWF  x1A
0243A:  MOVLW  DF
0243C:  MOVWF  x19
0243E:  MOVLW  7E
02440:  MOVWF  x18
02442:  MOVLB  0
02444:  CALL   0AF0
02448:  MOVFF  03,5FC
0244C:  MOVFF  02,5FB
02450:  MOVFF  01,5FA
02454:  MOVFF  00,5F9
....................       r = r*y2 + 1.0;
02458:  MOVFF  5FC,613
0245C:  MOVFF  5FB,612
02460:  MOVFF  5FA,611
02464:  MOVFF  5F9,610
02468:  MOVFF  600,617
0246C:  MOVFF  5FF,616
02470:  MOVFF  5FE,615
02474:  MOVFF  5FD,614
02478:  CALL   09FA
0247C:  MOVFF  03,605
02480:  MOVFF  02,604
02484:  MOVFF  01,603
02488:  MOVFF  00,602
0248C:  BCF    FD8.1
0248E:  MOVFF  03,617
02492:  MOVFF  02,616
02496:  MOVFF  01,615
0249A:  MOVFF  00,614
0249E:  MOVLB  6
024A0:  CLRF   x1B
024A2:  CLRF   x1A
024A4:  CLRF   x19
024A6:  MOVLW  7F
024A8:  MOVWF  x18
024AA:  MOVLB  0
024AC:  CALL   0AF0
024B0:  MOVFF  03,5FC
024B4:  MOVFF  02,5FB
024B8:  MOVFF  01,5FA
024BC:  MOVFF  00,5F9
.................... 
....................       res = y*res/r;
024C0:  MOVFF  5F4,613
024C4:  MOVFF  5F3,612
024C8:  MOVFF  5F2,611
024CC:  MOVFF  5F1,610
024D0:  MOVFF  5F8,617
024D4:  MOVFF  5F7,616
024D8:  MOVFF  5F6,615
024DC:  MOVFF  5F5,614
024E0:  CALL   09FA
024E4:  MOVFF  03,605
024E8:  MOVFF  02,604
024EC:  MOVFF  01,603
024F0:  MOVFF  00,602
024F4:  MOVFF  03,609
024F8:  MOVFF  02,608
024FC:  MOVFF  01,607
02500:  MOVFF  00,606
02504:  MOVFF  5FC,60D
02508:  MOVFF  5FB,60C
0250C:  MOVFF  5FA,60B
02510:  MOVFF  5F9,60A
02514:  CALL   13A6
02518:  MOVFF  03,5F8
0251C:  MOVFF  02,5F7
02520:  MOVFF  01,5F6
02524:  MOVFF  00,5F5
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02528:  MOVLW  05
0252A:  MOVLB  6
0252C:  MOVWF  x03
0252E:  MOVLW  ED
02530:  MOVFF  603,FEA
02534:  MOVWF  FE9
02536:  MOVLW  7E
02538:  SUBWF  FEF,W
0253A:  MOVWF  x01
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
0253C:  BTFSS  x01.7
0253E:  BRA    256A
....................          r = -(float32)-n;
02540:  MOVLW  00
02542:  BSF    FD8.0
02544:  SUBFWB x01,W
02546:  CLRF   x04
02548:  MOVWF  x03
0254A:  BTFSC  x03.7
0254C:  DECF   x04,F
0254E:  MOVLB  0
02550:  RCALL  2224
02552:  MOVFF  00,5F9
02556:  MOVF   01,W
02558:  XORLW  80
0255A:  MOVLB  5
0255C:  MOVWF  xFA
0255E:  MOVFF  02,5FB
02562:  MOVFF  03,5FC
02566:  BRA    258A
02568:  MOVLB  6
....................       else
....................          r = (float32)n;
0256A:  CLRF   x04
0256C:  MOVFF  601,603
02570:  BTFSC  x03.7
02572:  DECF   x04,F
02574:  MOVLB  0
02576:  RCALL  2224
02578:  MOVFF  03,5FC
0257C:  MOVFF  02,5FB
02580:  MOVFF  01,5FA
02584:  MOVFF  00,5F9
02588:  MOVLB  5
.................... 
....................       res += r*LN2;
0258A:  MOVFF  5FC,613
0258E:  MOVFF  5FB,612
02592:  MOVFF  5FA,611
02596:  MOVFF  5F9,610
0259A:  MOVLW  18
0259C:  MOVLB  6
0259E:  MOVWF  x17
025A0:  MOVLW  72
025A2:  MOVWF  x16
025A4:  MOVLW  31
025A6:  MOVWF  x15
025A8:  MOVLW  7E
025AA:  MOVWF  x14
025AC:  MOVLB  0
025AE:  CALL   09FA
025B2:  BCF    FD8.1
025B4:  MOVFF  5F8,617
025B8:  MOVFF  5F7,616
025BC:  MOVFF  5F6,615
025C0:  MOVFF  5F5,614
025C4:  MOVFF  03,61B
025C8:  MOVFF  02,61A
025CC:  MOVFF  01,619
025D0:  MOVFF  00,618
025D4:  CALL   0AF0
025D8:  MOVFF  03,5F8
025DC:  MOVFF  02,5F7
025E0:  MOVFF  01,5F6
025E4:  MOVFF  00,5F5
....................    }
025E8:  BRA    25F6
.................... 
....................    else
....................       res = 0.0;
025EA:  MOVLB  5
025EC:  CLRF   xF8
025EE:  CLRF   xF7
025F0:  CLRF   xF6
025F2:  CLRF   xF5
025F4:  MOVLB  0
.................... 
....................    return(res);
025F6:  MOVFF  5F5,00
025FA:  MOVFF  5F6,01
025FE:  MOVFF  5F7,02
02602:  MOVFF  5F8,03
02606:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02A1E:  MOVFF  5E4,613
02A22:  MOVFF  5E3,612
02A26:  MOVFF  5E2,611
02A2A:  MOVFF  5E1,610
02A2E:  MOVLB  6
02A30:  CLRF   x17
02A32:  CLRF   x16
02A34:  CLRF   x15
02A36:  CLRF   x14
02A38:  MOVLB  0
02A3A:  CALL   132C
02A3E:  BTFSS  FD8.0
02A40:  BRA    2BDC
02A42:  MOVFF  5E8,5EC
02A46:  MOVFF  5E7,5EB
02A4A:  MOVFF  5E6,5EA
02A4E:  MOVFF  5E5,5E9
02A52:  MOVLB  5
02A54:  CLRF   xF0
02A56:  CLRF   xEF
02A58:  CLRF   xEE
02A5A:  MOVLW  7F
02A5C:  MOVWF  xED
02A5E:  MOVLB  0
02A60:  CALL   20BE
02A64:  MOVFF  03,5EC
02A68:  MOVFF  02,5EB
02A6C:  MOVFF  01,5EA
02A70:  MOVFF  00,5E9
02A74:  MOVFF  03,613
02A78:  MOVFF  02,612
02A7C:  MOVFF  01,611
02A80:  MOVFF  00,610
02A84:  MOVLB  6
02A86:  CLRF   x17
02A88:  CLRF   x16
02A8A:  CLRF   x15
02A8C:  CLRF   x14
02A8E:  MOVLB  0
02A90:  CALL   132C
02A94:  BTFSS  FD8.2
02A96:  BRA    2BDC
....................       if(fmod(y, 2) == 0) {
02A98:  MOVFF  5E8,5EC
02A9C:  MOVFF  5E7,5EB
02AA0:  MOVFF  5E6,5EA
02AA4:  MOVFF  5E5,5E9
02AA8:  MOVLB  5
02AAA:  CLRF   xF0
02AAC:  CLRF   xEF
02AAE:  CLRF   xEE
02AB0:  MOVLW  80
02AB2:  MOVWF  xED
02AB4:  MOVLB  0
02AB6:  CALL   20BE
02ABA:  MOVFF  03,5EC
02ABE:  MOVFF  02,5EB
02AC2:  MOVFF  01,5EA
02AC6:  MOVFF  00,5E9
02ACA:  MOVFF  03,613
02ACE:  MOVFF  02,612
02AD2:  MOVFF  01,611
02AD6:  MOVFF  00,610
02ADA:  MOVLB  6
02ADC:  CLRF   x17
02ADE:  CLRF   x16
02AE0:  CLRF   x15
02AE2:  CLRF   x14
02AE4:  MOVLB  0
02AE6:  CALL   132C
02AEA:  BNZ   2B62
....................          return (exp(log(-x) * y));
02AEC:  MOVLB  5
02AEE:  MOVF   xE2,W
02AF0:  XORLW  80
02AF2:  MOVWF  xEA
02AF4:  MOVFF  5E4,5F0
02AF8:  MOVFF  5E3,5EF
02AFC:  MOVWF  xEE
02AFE:  MOVFF  5E1,5ED
02B02:  MOVLB  0
02B04:  CALL   2274
02B08:  MOVFF  03,5EC
02B0C:  MOVFF  02,5EB
02B10:  MOVFF  01,5EA
02B14:  MOVFF  00,5E9
02B18:  MOVFF  03,613
02B1C:  MOVFF  02,612
02B20:  MOVFF  01,611
02B24:  MOVFF  00,610
02B28:  MOVFF  5E8,617
02B2C:  MOVFF  5E7,616
02B30:  MOVFF  5E6,615
02B34:  MOVFF  5E5,614
02B38:  CALL   09FA
02B3C:  MOVFF  03,5EC
02B40:  MOVFF  02,5EB
02B44:  MOVFF  01,5EA
02B48:  MOVFF  00,5E9
02B4C:  MOVFF  03,5F0
02B50:  MOVFF  02,5EF
02B54:  MOVFF  01,5EE
02B58:  MOVFF  00,5ED
02B5C:  RCALL  2608
02B5E:  BRA    2D1A
....................       } else {
02B60:  BRA    2BDA
....................          return (-exp(log(-x) * y));
02B62:  MOVLB  5
02B64:  MOVF   xE2,W
02B66:  XORLW  80
02B68:  MOVWF  xEA
02B6A:  MOVFF  5E4,5F0
02B6E:  MOVFF  5E3,5EF
02B72:  MOVWF  xEE
02B74:  MOVFF  5E1,5ED
02B78:  MOVLB  0
02B7A:  CALL   2274
02B7E:  MOVFF  03,5EC
02B82:  MOVFF  02,5EB
02B86:  MOVFF  01,5EA
02B8A:  MOVFF  00,5E9
02B8E:  MOVFF  03,613
02B92:  MOVFF  02,612
02B96:  MOVFF  01,611
02B9A:  MOVFF  00,610
02B9E:  MOVFF  5E8,617
02BA2:  MOVFF  5E7,616
02BA6:  MOVFF  5E6,615
02BAA:  MOVFF  5E5,614
02BAE:  CALL   09FA
02BB2:  MOVFF  03,5EC
02BB6:  MOVFF  02,5EB
02BBA:  MOVFF  01,5EA
02BBE:  MOVFF  00,5E9
02BC2:  MOVFF  03,5F0
02BC6:  MOVFF  02,5EF
02BCA:  MOVFF  01,5EE
02BCE:  MOVFF  00,5ED
02BD2:  RCALL  2608
02BD4:  MOVLW  80
02BD6:  XORWF  01,F
02BD8:  BRA    2D1A
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02BDA:  BRA    2D1A
02BDC:  MOVFF  5E4,613
02BE0:  MOVFF  5E3,612
02BE4:  MOVFF  5E2,611
02BE8:  MOVFF  5E1,610
02BEC:  MOVLB  6
02BEE:  CLRF   x17
02BF0:  CLRF   x16
02BF2:  CLRF   x15
02BF4:  CLRF   x14
02BF6:  MOVLB  0
02BF8:  CALL   132C
02BFC:  BNC   2C5E
02BFE:  MOVFF  5E8,5EC
02C02:  MOVFF  5E7,5EB
02C06:  MOVFF  5E6,5EA
02C0A:  MOVFF  5E5,5E9
02C0E:  MOVLB  5
02C10:  CLRF   xF0
02C12:  CLRF   xEF
02C14:  CLRF   xEE
02C16:  MOVLW  7F
02C18:  MOVWF  xED
02C1A:  MOVLB  0
02C1C:  CALL   20BE
02C20:  MOVFF  03,5EC
02C24:  MOVFF  02,5EB
02C28:  MOVFF  01,5EA
02C2C:  MOVFF  00,5E9
02C30:  MOVFF  03,613
02C34:  MOVFF  02,612
02C38:  MOVFF  01,611
02C3C:  MOVFF  00,610
02C40:  MOVLB  6
02C42:  CLRF   x17
02C44:  CLRF   x16
02C46:  CLRF   x15
02C48:  CLRF   x14
02C4A:  MOVLB  0
02C4C:  CALL   132C
02C50:  BZ    2C5E
....................       return 0;
02C52:  CLRF   00
02C54:  CLRF   01
02C56:  CLRF   02
02C58:  CLRF   03
02C5A:  BRA    2D1A
....................    } else {
02C5C:  BRA    2D1A
....................       if(x != 0 || 0 >= y) {
02C5E:  MOVFF  5E4,613
02C62:  MOVFF  5E3,612
02C66:  MOVFF  5E2,611
02C6A:  MOVFF  5E1,610
02C6E:  MOVLB  6
02C70:  CLRF   x17
02C72:  CLRF   x16
02C74:  CLRF   x15
02C76:  CLRF   x14
02C78:  MOVLB  0
02C7A:  CALL   132C
02C7E:  BNZ   2CA4
02C80:  MOVFF  5E8,613
02C84:  MOVFF  5E7,612
02C88:  MOVFF  5E6,611
02C8C:  MOVFF  5E5,610
02C90:  MOVLB  6
02C92:  CLRF   x17
02C94:  CLRF   x16
02C96:  CLRF   x15
02C98:  CLRF   x14
02C9A:  MOVLB  0
02C9C:  CALL   132C
02CA0:  BC    2CA4
02CA2:  BNZ   2D12
....................          return (exp(log(x) * y));
02CA4:  MOVFF  5E4,5F0
02CA8:  MOVFF  5E3,5EF
02CAC:  MOVFF  5E2,5EE
02CB0:  MOVFF  5E1,5ED
02CB4:  CALL   2274
02CB8:  MOVFF  03,5EC
02CBC:  MOVFF  02,5EB
02CC0:  MOVFF  01,5EA
02CC4:  MOVFF  00,5E9
02CC8:  MOVFF  03,613
02CCC:  MOVFF  02,612
02CD0:  MOVFF  01,611
02CD4:  MOVFF  00,610
02CD8:  MOVFF  5E8,617
02CDC:  MOVFF  5E7,616
02CE0:  MOVFF  5E6,615
02CE4:  MOVFF  5E5,614
02CE8:  CALL   09FA
02CEC:  MOVFF  03,5EC
02CF0:  MOVFF  02,5EB
02CF4:  MOVFF  01,5EA
02CF8:  MOVFF  00,5E9
02CFC:  MOVFF  03,5F0
02D00:  MOVFF  02,5EF
02D04:  MOVFF  01,5EE
02D08:  MOVFF  00,5ED
02D0C:  RCALL  2608
02D0E:  BRA    2D1A
....................       } else return 0;
02D10:  BRA    2D1A
02D12:  CLRF   00
02D14:  CLRF   01
02D16:  CLRF   02
02D18:  CLRF   03
....................    }
02D1A:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01504:  MOVLB  5
01506:  BCF    xFF.0
....................    flag = 0;
01508:  BCF    xFF.1
....................    y = x;
0150A:  MOVFF  5F2,5F6
0150E:  MOVFF  5F1,5F5
01512:  MOVFF  5F0,5F4
01516:  MOVFF  5EF,5F3
.................... 
....................    if (x < 0)
0151A:  MOVFF  5F2,613
0151E:  MOVFF  5F1,612
01522:  MOVFF  5F0,611
01526:  MOVFF  5EF,610
0152A:  MOVLB  6
0152C:  CLRF   x17
0152E:  CLRF   x16
01530:  CLRF   x15
01532:  CLRF   x14
01534:  MOVLB  0
01536:  RCALL  132C
01538:  BNC   1546
....................    {
....................       s = 1;
0153A:  MOVLB  5
0153C:  BSF    xFF.0
....................       y = -y;
0153E:  MOVF   xF4,W
01540:  XORLW  80
01542:  MOVWF  xF4
01544:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01546:  MOVLB  6
01548:  CLRF   x13
0154A:  CLRF   x12
0154C:  CLRF   x11
0154E:  MOVLW  7F
01550:  MOVWF  x10
01552:  MOVFF  5F6,617
01556:  MOVFF  5F5,616
0155A:  MOVFF  5F4,615
0155E:  MOVFF  5F3,614
01562:  MOVLB  0
01564:  RCALL  132C
01566:  BNC   159E
....................    {
....................       y = 1.0/y;
01568:  MOVLB  6
0156A:  CLRF   x09
0156C:  CLRF   x08
0156E:  CLRF   x07
01570:  MOVLW  7F
01572:  MOVWF  x06
01574:  MOVFF  5F6,60D
01578:  MOVFF  5F5,60C
0157C:  MOVFF  5F4,60B
01580:  MOVFF  5F3,60A
01584:  MOVLB  0
01586:  RCALL  13A6
01588:  MOVFF  03,5F6
0158C:  MOVFF  02,5F5
01590:  MOVFF  01,5F4
01594:  MOVFF  00,5F3
....................       flag = 1;
01598:  MOVLB  5
0159A:  BSF    xFF.1
0159C:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
0159E:  MOVLW  0A
015A0:  MOVLB  6
015A2:  MOVWF  x13
015A4:  MOVLW  89
015A6:  MOVWF  x12
015A8:  MOVLW  34
015AA:  MOVWF  x11
015AC:  MOVLW  7C
015AE:  MOVWF  x10
015B0:  MOVFF  5F6,617
015B4:  MOVFF  5F5,616
015B8:  MOVFF  5F4,615
015BC:  MOVFF  5F3,614
015C0:  MOVLB  0
015C2:  CALL   09FA
015C6:  MOVFF  03,603
015CA:  MOVFF  02,602
015CE:  MOVFF  01,601
015D2:  MOVFF  00,600
015D6:  MOVFF  03,613
015DA:  MOVFF  02,612
015DE:  MOVFF  01,611
015E2:  MOVFF  00,610
015E6:  MOVFF  5F6,617
015EA:  MOVFF  5F5,616
015EE:  MOVFF  5F4,615
015F2:  MOVFF  5F3,614
015F6:  CALL   09FA
015FA:  MOVFF  03,603
015FE:  MOVFF  02,602
01602:  MOVFF  01,601
01606:  MOVFF  00,600
0160A:  BCF    FD8.1
0160C:  MOVFF  03,617
01610:  MOVFF  02,616
01614:  MOVFF  01,615
01618:  MOVFF  00,614
0161C:  MOVLW  7C
0161E:  MOVLB  6
01620:  MOVWF  x1B
01622:  MOVLW  79
01624:  MOVWF  x1A
01626:  MOVLW  35
01628:  MOVWF  x19
0162A:  MOVLW  81
0162C:  MOVWF  x18
0162E:  MOVLB  0
01630:  CALL   0AF0
01634:  MOVFF  03,5FA
01638:  MOVFF  02,5F9
0163C:  MOVFF  01,5F8
01640:  MOVFF  00,5F7
....................    res = res*y*y + pat[2];
01644:  MOVFF  5FA,613
01648:  MOVFF  5F9,612
0164C:  MOVFF  5F8,611
01650:  MOVFF  5F7,610
01654:  MOVFF  5F6,617
01658:  MOVFF  5F5,616
0165C:  MOVFF  5F4,615
01660:  MOVFF  5F3,614
01664:  CALL   09FA
01668:  MOVFF  03,603
0166C:  MOVFF  02,602
01670:  MOVFF  01,601
01674:  MOVFF  00,600
01678:  MOVFF  03,613
0167C:  MOVFF  02,612
01680:  MOVFF  01,611
01684:  MOVFF  00,610
01688:  MOVFF  5F6,617
0168C:  MOVFF  5F5,616
01690:  MOVFF  5F4,615
01694:  MOVFF  5F3,614
01698:  CALL   09FA
0169C:  MOVFF  03,603
016A0:  MOVFF  02,602
016A4:  MOVFF  01,601
016A8:  MOVFF  00,600
016AC:  BCF    FD8.1
016AE:  MOVFF  03,617
016B2:  MOVFF  02,616
016B6:  MOVFF  01,615
016BA:  MOVFF  00,614
016BE:  MOVLW  3F
016C0:  MOVLB  6
016C2:  MOVWF  x1B
016C4:  MOVLW  02
016C6:  MOVWF  x1A
016C8:  MOVLW  33
016CA:  MOVWF  x19
016CC:  MOVLW  83
016CE:  MOVWF  x18
016D0:  MOVLB  0
016D2:  CALL   0AF0
016D6:  MOVFF  03,5FA
016DA:  MOVFF  02,5F9
016DE:  MOVFF  01,5F8
016E2:  MOVFF  00,5F7
....................    res = res*y*y + pat[3];
016E6:  MOVFF  5FA,613
016EA:  MOVFF  5F9,612
016EE:  MOVFF  5F8,611
016F2:  MOVFF  5F7,610
016F6:  MOVFF  5F6,617
016FA:  MOVFF  5F5,616
016FE:  MOVFF  5F4,615
01702:  MOVFF  5F3,614
01706:  CALL   09FA
0170A:  MOVFF  03,603
0170E:  MOVFF  02,602
01712:  MOVFF  01,601
01716:  MOVFF  00,600
0171A:  MOVFF  03,613
0171E:  MOVFF  02,612
01722:  MOVFF  01,611
01726:  MOVFF  00,610
0172A:  MOVFF  5F6,617
0172E:  MOVFF  5F5,616
01732:  MOVFF  5F4,615
01736:  MOVFF  5F3,614
0173A:  CALL   09FA
0173E:  MOVFF  03,603
01742:  MOVFF  02,602
01746:  MOVFF  01,601
0174A:  MOVFF  00,600
0174E:  BCF    FD8.1
01750:  MOVFF  03,617
01754:  MOVFF  02,616
01758:  MOVFF  01,615
0175C:  MOVFF  00,614
01760:  MOVLW  33
01762:  MOVLB  6
01764:  MOVWF  x1B
01766:  MOVLW  8C
01768:  MOVWF  x1A
0176A:  MOVLW  1E
0176C:  MOVWF  x19
0176E:  MOVLW  83
01770:  MOVWF  x18
01772:  MOVLB  0
01774:  CALL   0AF0
01778:  MOVFF  03,5FA
0177C:  MOVFF  02,5F9
01780:  MOVFF  01,5F8
01784:  MOVFF  00,5F7
.................... 
....................    r = qat[0]*y*y + qat[1];
01788:  MOVLB  6
0178A:  CLRF   x13
0178C:  CLRF   x12
0178E:  CLRF   x11
01790:  MOVLW  7F
01792:  MOVWF  x10
01794:  MOVFF  5F6,617
01798:  MOVFF  5F5,616
0179C:  MOVFF  5F4,615
017A0:  MOVFF  5F3,614
017A4:  MOVLB  0
017A6:  CALL   09FA
017AA:  MOVFF  03,603
017AE:  MOVFF  02,602
017B2:  MOVFF  01,601
017B6:  MOVFF  00,600
017BA:  MOVFF  03,613
017BE:  MOVFF  02,612
017C2:  MOVFF  01,611
017C6:  MOVFF  00,610
017CA:  MOVFF  5F6,617
017CE:  MOVFF  5F5,616
017D2:  MOVFF  5F4,615
017D6:  MOVFF  5F3,614
017DA:  CALL   09FA
017DE:  MOVFF  03,603
017E2:  MOVFF  02,602
017E6:  MOVFF  01,601
017EA:  MOVFF  00,600
017EE:  BCF    FD8.1
017F0:  MOVFF  03,617
017F4:  MOVFF  02,616
017F8:  MOVFF  01,615
017FC:  MOVFF  00,614
01800:  MOVLW  1B
01802:  MOVLB  6
01804:  MOVWF  x1B
01806:  MOVLW  E4
01808:  MOVWF  x1A
0180A:  MOVLW  35
0180C:  MOVWF  x19
0180E:  MOVLW  82
01810:  MOVWF  x18
01812:  MOVLB  0
01814:  CALL   0AF0
01818:  MOVFF  03,5FE
0181C:  MOVFF  02,5FD
01820:  MOVFF  01,5FC
01824:  MOVFF  00,5FB
....................    r = r*y*y + qat[2];
01828:  MOVFF  5FE,613
0182C:  MOVFF  5FD,612
01830:  MOVFF  5FC,611
01834:  MOVFF  5FB,610
01838:  MOVFF  5F6,617
0183C:  MOVFF  5F5,616
01840:  MOVFF  5F4,615
01844:  MOVFF  5F3,614
01848:  CALL   09FA
0184C:  MOVFF  03,603
01850:  MOVFF  02,602
01854:  MOVFF  01,601
01858:  MOVFF  00,600
0185C:  MOVFF  03,613
01860:  MOVFF  02,612
01864:  MOVFF  01,611
01868:  MOVFF  00,610
0186C:  MOVFF  5F6,617
01870:  MOVFF  5F5,616
01874:  MOVFF  5F4,615
01878:  MOVFF  5F3,614
0187C:  CALL   09FA
01880:  MOVFF  03,603
01884:  MOVFF  02,602
01888:  MOVFF  01,601
0188C:  MOVFF  00,600
01890:  BCF    FD8.1
01892:  MOVFF  03,617
01896:  MOVFF  02,616
0189A:  MOVFF  01,615
0189E:  MOVFF  00,614
018A2:  MOVLW  A4
018A4:  MOVLB  6
018A6:  MOVWF  x1B
018A8:  MOVLW  DB
018AA:  MOVWF  x1A
018AC:  MOVLW  67
018AE:  MOVWF  x19
018B0:  MOVLW  83
018B2:  MOVWF  x18
018B4:  MOVLB  0
018B6:  CALL   0AF0
018BA:  MOVFF  03,5FE
018BE:  MOVFF  02,5FD
018C2:  MOVFF  01,5FC
018C6:  MOVFF  00,5FB
....................    r = r*y*y + qat[3];
018CA:  MOVFF  5FE,613
018CE:  MOVFF  5FD,612
018D2:  MOVFF  5FC,611
018D6:  MOVFF  5FB,610
018DA:  MOVFF  5F6,617
018DE:  MOVFF  5F5,616
018E2:  MOVFF  5F4,615
018E6:  MOVFF  5F3,614
018EA:  CALL   09FA
018EE:  MOVFF  03,603
018F2:  MOVFF  02,602
018F6:  MOVFF  01,601
018FA:  MOVFF  00,600
018FE:  MOVFF  03,613
01902:  MOVFF  02,612
01906:  MOVFF  01,611
0190A:  MOVFF  00,610
0190E:  MOVFF  5F6,617
01912:  MOVFF  5F5,616
01916:  MOVFF  5F4,615
0191A:  MOVFF  5F3,614
0191E:  CALL   09FA
01922:  MOVFF  03,603
01926:  MOVFF  02,602
0192A:  MOVFF  01,601
0192E:  MOVFF  00,600
01932:  BCF    FD8.1
01934:  MOVFF  03,617
01938:  MOVFF  02,616
0193C:  MOVFF  01,615
01940:  MOVFF  00,614
01944:  MOVLW  33
01946:  MOVLB  6
01948:  MOVWF  x1B
0194A:  MOVLW  8C
0194C:  MOVWF  x1A
0194E:  MOVLW  1E
01950:  MOVWF  x19
01952:  MOVLW  83
01954:  MOVWF  x18
01956:  MOVLB  0
01958:  CALL   0AF0
0195C:  MOVFF  03,5FE
01960:  MOVFF  02,5FD
01964:  MOVFF  01,5FC
01968:  MOVFF  00,5FB
.................... 
....................    res = y*res/r;
0196C:  MOVFF  5F6,613
01970:  MOVFF  5F5,612
01974:  MOVFF  5F4,611
01978:  MOVFF  5F3,610
0197C:  MOVFF  5FA,617
01980:  MOVFF  5F9,616
01984:  MOVFF  5F8,615
01988:  MOVFF  5F7,614
0198C:  CALL   09FA
01990:  MOVFF  03,603
01994:  MOVFF  02,602
01998:  MOVFF  01,601
0199C:  MOVFF  00,600
019A0:  MOVFF  03,609
019A4:  MOVFF  02,608
019A8:  MOVFF  01,607
019AC:  MOVFF  00,606
019B0:  MOVFF  5FE,60D
019B4:  MOVFF  5FD,60C
019B8:  MOVFF  5FC,60B
019BC:  MOVFF  5FB,60A
019C0:  RCALL  13A6
019C2:  MOVFF  03,5FA
019C6:  MOVFF  02,5F9
019CA:  MOVFF  01,5F8
019CE:  MOVFF  00,5F7
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
019D2:  MOVLB  5
019D4:  BTFSS  xFF.1
019D6:  BRA    1A14
....................       res = PI_DIV_BY_TWO - res;
019D8:  BSF    FD8.1
019DA:  MOVLW  DB
019DC:  MOVLB  6
019DE:  MOVWF  x17
019E0:  MOVLW  0F
019E2:  MOVWF  x16
019E4:  MOVLW  49
019E6:  MOVWF  x15
019E8:  MOVLW  7F
019EA:  MOVWF  x14
019EC:  MOVFF  5FA,61B
019F0:  MOVFF  5F9,61A
019F4:  MOVFF  5F8,619
019F8:  MOVFF  5F7,618
019FC:  MOVLB  0
019FE:  CALL   0AF0
01A02:  MOVFF  03,5FA
01A06:  MOVFF  02,5F9
01A0A:  MOVFF  01,5F8
01A0E:  MOVFF  00,5F7
01A12:  MOVLB  5
....................    if (s)
01A14:  BTFSS  xFF.0
01A16:  BRA    1A1E
....................       res = -res;
01A18:  MOVF   xF8,W
01A1A:  XORLW  80
01A1C:  MOVWF  xF8
.................... 
....................    return(res);
01A1E:  MOVFF  5F7,00
01A22:  MOVFF  5F8,01
01A26:  MOVFF  5F9,02
01A2A:  MOVFF  5FA,03
01A2E:  MOVLB  0
01A30:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01A32:  MOVLB  5
01A34:  BCF    xED.0
....................    quad=0; //quadrant
01A36:  CLRF   xEE
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01A38:  MOVFF  5E4,613
01A3C:  MOVFF  5E3,612
01A40:  MOVFF  5E2,611
01A44:  MOVFF  5E1,610
01A48:  MOVLB  6
01A4A:  CLRF   x17
01A4C:  CLRF   x16
01A4E:  CLRF   x15
01A50:  CLRF   x14
01A52:  MOVLB  0
01A54:  RCALL  132C
01A56:  BC    1A5A
01A58:  BNZ   1A84
01A5A:  MOVFF  5E8,613
01A5E:  MOVFF  5E7,612
01A62:  MOVFF  5E6,611
01A66:  MOVFF  5E5,610
01A6A:  MOVLB  6
01A6C:  CLRF   x17
01A6E:  CLRF   x16
01A70:  CLRF   x15
01A72:  CLRF   x14
01A74:  MOVLB  0
01A76:  RCALL  132C
01A78:  BC    1A7C
01A7A:  BNZ   1A80
01A7C:  MOVLW  03
01A7E:  BRA    1A82
01A80:  MOVLW  04
01A82:  BRA    1AAA
01A84:  MOVFF  5E8,613
01A88:  MOVFF  5E7,612
01A8C:  MOVFF  5E6,611
01A90:  MOVFF  5E5,610
01A94:  MOVLB  6
01A96:  CLRF   x17
01A98:  CLRF   x16
01A9A:  CLRF   x15
01A9C:  CLRF   x14
01A9E:  MOVLB  0
01AA0:  RCALL  132C
01AA2:  BNC   1AA8
01AA4:  MOVLW  02
01AA6:  BRA    1AAA
01AA8:  MOVLW  01
01AAA:  MOVLB  5
01AAC:  MOVWF  xEE
....................    if(y<0.0)
01AAE:  MOVFF  5E4,613
01AB2:  MOVFF  5E3,612
01AB6:  MOVFF  5E2,611
01ABA:  MOVFF  5E1,610
01ABE:  MOVLB  6
01AC0:  CLRF   x17
01AC2:  CLRF   x16
01AC4:  CLRF   x15
01AC6:  CLRF   x14
01AC8:  MOVLB  0
01ACA:  RCALL  132C
01ACC:  BNC   1ADA
....................    {
....................       sign=1;
01ACE:  MOVLB  5
01AD0:  BSF    xED.0
....................       y=-y;
01AD2:  MOVF   xE2,W
01AD4:  XORLW  80
01AD6:  MOVWF  xE2
01AD8:  MOVLB  0
....................    }
....................    if(x<0.0)
01ADA:  MOVFF  5E8,613
01ADE:  MOVFF  5E7,612
01AE2:  MOVFF  5E6,611
01AE6:  MOVFF  5E5,610
01AEA:  MOVLB  6
01AEC:  CLRF   x17
01AEE:  CLRF   x16
01AF0:  CLRF   x15
01AF2:  CLRF   x14
01AF4:  MOVLB  0
01AF6:  RCALL  132C
01AF8:  BNC   1B04
....................    {
....................       x=-x;
01AFA:  MOVLB  5
01AFC:  MOVF   xE6,W
01AFE:  XORLW  80
01B00:  MOVWF  xE6
01B02:  MOVLB  0
....................    }
....................    if (x==0.0)
01B04:  MOVFF  5E8,613
01B08:  MOVFF  5E7,612
01B0C:  MOVFF  5E6,611
01B10:  MOVFF  5E5,610
01B14:  MOVLB  6
01B16:  CLRF   x17
01B18:  CLRF   x16
01B1A:  CLRF   x15
01B1C:  CLRF   x14
01B1E:  MOVLB  0
01B20:  RCALL  132C
01B22:  BNZ   1B78
....................    {
....................       if(y==0.0)
01B24:  MOVFF  5E4,613
01B28:  MOVFF  5E3,612
01B2C:  MOVFF  5E2,611
01B30:  MOVFF  5E1,610
01B34:  MOVLB  6
01B36:  CLRF   x17
01B38:  CLRF   x16
01B3A:  CLRF   x15
01B3C:  CLRF   x14
01B3E:  MOVLB  0
01B40:  CALL   132C
01B44:  BNZ   1B48
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01B46:  BRA    1B76
....................       else
....................       {
....................          if(sign)
01B48:  MOVLB  5
01B4A:  BTFSS  xED.0
01B4C:  BRA    1B62
....................          {
....................          return (-(PI_DIV_BY_TWO));
01B4E:  MOVLW  7F
01B50:  MOVWF  00
01B52:  MOVLW  C9
01B54:  MOVWF  01
01B56:  MOVLW  0F
01B58:  MOVWF  02
01B5A:  MOVLW  DB
01B5C:  MOVWF  03
01B5E:  BRA    1CB0
....................          }
01B60:  BRA    1B74
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01B62:  MOVLW  7F
01B64:  MOVWF  00
01B66:  MOVLW  49
01B68:  MOVWF  01
01B6A:  MOVLW  0F
01B6C:  MOVWF  02
01B6E:  MOVLW  DB
01B70:  MOVWF  03
01B72:  BRA    1CB0
01B74:  MOVLB  0
....................          }
....................       }
....................    }
01B76:  BRA    1CAE
....................    else
....................    {
....................       z=y/x;
01B78:  MOVFF  5E4,609
01B7C:  MOVFF  5E3,608
01B80:  MOVFF  5E2,607
01B84:  MOVFF  5E1,606
01B88:  MOVFF  5E8,60D
01B8C:  MOVFF  5E7,60C
01B90:  MOVFF  5E6,60B
01B94:  MOVFF  5E5,60A
01B98:  RCALL  13A6
01B9A:  MOVFF  03,5EC
01B9E:  MOVFF  02,5EB
01BA2:  MOVFF  01,5EA
01BA6:  MOVFF  00,5E9
....................       switch(quad)
01BAA:  MOVLW  01
01BAC:  MOVLB  5
01BAE:  SUBWF  xEE,W
01BB0:  ADDLW  FC
01BB2:  BTFSC  FD8.0
01BB4:  BRA    1CB0
01BB6:  ADDLW  04
01BB8:  MOVLB  0
01BBA:  GOTO   1CB6
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01BBE:  MOVFF  5EC,5F2
01BC2:  MOVFF  5EB,5F1
01BC6:  MOVFF  5EA,5F0
01BCA:  MOVFF  5E9,5EF
01BCE:  RCALL  1504
01BD0:  MOVLB  5
01BD2:  BRA    1CB0
....................             break;
01BD4:  BRA    1CB0
01BD6:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01BD8:  MOVFF  5EC,5F2
01BDC:  MOVFF  5EB,5F1
01BE0:  MOVFF  5EA,5F0
01BE4:  MOVFF  5E9,5EF
01BE8:  RCALL  1504
01BEA:  MOVFF  FEA,5F0
01BEE:  MOVFF  FE9,5EF
01BF2:  BSF    FD8.1
01BF4:  MOVLW  DB
01BF6:  MOVLB  6
01BF8:  MOVWF  x17
01BFA:  MOVLW  0F
01BFC:  MOVWF  x16
01BFE:  MOVLW  49
01C00:  MOVWF  x15
01C02:  MOVLW  80
01C04:  MOVWF  x14
01C06:  MOVFF  03,61B
01C0A:  MOVFF  02,61A
01C0E:  MOVFF  01,619
01C12:  MOVFF  00,618
01C16:  MOVLB  0
01C18:  CALL   0AF0
01C1C:  MOVFF  5F0,FEA
01C20:  MOVFF  5EF,FE9
01C24:  MOVLB  5
01C26:  BRA    1CB0
....................             break;
01C28:  BRA    1CB0
01C2A:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01C2C:  MOVFF  5EC,5F2
01C30:  MOVFF  5EB,5F1
01C34:  MOVFF  5EA,5F0
01C38:  MOVFF  5E9,5EF
01C3C:  RCALL  1504
01C3E:  MOVFF  03,5F2
01C42:  MOVFF  02,5F1
01C46:  MOVFF  01,5F0
01C4A:  MOVFF  00,5EF
01C4E:  MOVFF  FEA,5F4
01C52:  MOVFF  FE9,5F3
01C56:  BSF    FD8.1
01C58:  MOVFF  03,617
01C5C:  MOVFF  02,616
01C60:  MOVFF  01,615
01C64:  MOVFF  00,614
01C68:  MOVLW  DB
01C6A:  MOVLB  6
01C6C:  MOVWF  x1B
01C6E:  MOVLW  0F
01C70:  MOVWF  x1A
01C72:  MOVLW  49
01C74:  MOVWF  x19
01C76:  MOVLW  80
01C78:  MOVWF  x18
01C7A:  MOVLB  0
01C7C:  CALL   0AF0
01C80:  MOVFF  5F4,FEA
01C84:  MOVFF  5F3,FE9
01C88:  MOVLB  5
01C8A:  BRA    1CB0
....................             break;
01C8C:  BRA    1CB0
01C8E:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01C90:  MOVFF  5EC,5F2
01C94:  MOVFF  5EB,5F1
01C98:  MOVFF  5EA,5F0
01C9C:  MOVFF  5E9,5EF
01CA0:  RCALL  1504
01CA2:  MOVLW  80
01CA4:  XORWF  01,F
01CA6:  MOVLB  5
01CA8:  BRA    1CB0
....................             break;
01CAA:  BRA    1CB0
01CAC:  MOVLB  0
01CAE:  MOVLB  5
....................          }
....................       }
....................    }
01CB0:  MOVLB  0
01CB2:  GOTO   30BC (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... //!#define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... // adc settings for magnetoresistive sensors
.................... #define KMXP1000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP1000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP1000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP1000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define KMXP2000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP2000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP2000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP2000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    int8 channel; // DEFAULT: 0=chX | 1=chY
.................... } smData = {false, false, 0};
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00D68:  MOVLB  F
00D6A:  BTFSC  x5B.0
00D6C:  BRA    1278
....................    {
....................       switch (state)
00D6E:  MOVLB  1
00D70:  MOVF   x51,W
00D72:  XORLW  00
00D74:  MOVLB  0
00D76:  BZ    0D96
00D78:  XORLW  01
00D7A:  BZ    0E48
00D7C:  XORLW  03
00D7E:  BTFSC  FD8.2
00D80:  BRA    0EFA
00D82:  XORLW  01
00D84:  BTFSC  FD8.2
00D86:  BRA    0FAC
00D88:  XORLW  07
00D8A:  BTFSC  FD8.2
00D8C:  BRA    105E
00D8E:  XORLW  01
00D90:  BTFSC  FD8.2
00D92:  BRA    1110
00D94:  BRA    11C4
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00D96:  MOVLB  F
00D98:  BTFSC  x5B.0
00D9A:  BRA    0D98
00D9C:  MOVFF  F5F,02
00DA0:  MOVFF  F5E,01
00DA4:  MOVFF  02,5BA
00DA8:  MOVFF  01,5B9
00DAC:  MOVFF  02,615
00DB0:  MOVFF  01,614
00DB4:  MOVLB  0
00DB6:  RCALL  09C4
00DB8:  MOVFF  03,613
00DBC:  MOVFF  02,612
00DC0:  MOVFF  01,611
00DC4:  MOVFF  00,610
00DC8:  MOVFF  B9,617
00DCC:  MOVFF  B8,616
00DD0:  MOVFF  B7,615
00DD4:  MOVFF  B6,614
00DD8:  RCALL  09FA
00DDA:  MOVFF  03,5BC
00DDE:  MOVFF  02,5BB
00DE2:  MOVFF  01,5BA
00DE6:  MOVFF  00,5B9
00DEA:  BCF    FD8.1
00DEC:  MOVFF  03,617
00DF0:  MOVFF  02,616
00DF4:  MOVFF  01,615
00DF8:  MOVFF  00,614
00DFC:  MOVFF  B5,61B
00E00:  MOVFF  B4,61A
00E04:  MOVFF  B3,619
00E08:  MOVFF  B2,618
00E0C:  RCALL  0AF0
00E0E:  MOVFF  03,F6
00E12:  MOVFF  02,F5
00E16:  MOVFF  01,F4
00E1A:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00E1E:  MOVLB  F
00E20:  MOVF   x5A,W
00E22:  ANDLW  3F
00E24:  MOVWF  01
00E26:  MOVLW  10
00E28:  MOVWF  x5A
00E2A:  BTFSS  x5B.7
00E2C:  BRA    0E3C
00E2E:  MOVF   01,W
00E30:  SUBLW  10
00E32:  BZ    0E3C
00E34:  BSF    x5B.0
00E36:  NOP   
00E38:  BTFSC  x5B.0
00E3A:  BRA    0E38
....................             read_adc(ADC_START_ONLY);
00E3C:  BSF    x5B.0
00E3E:  NOP   
....................             state = 1;
00E40:  MOVLW  01
00E42:  MOVLB  1
00E44:  MOVWF  x51
....................          break;
00E46:  BRA    1276
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00E48:  MOVLB  F
00E4A:  BTFSC  x5B.0
00E4C:  BRA    0E4A
00E4E:  MOVFF  F5F,02
00E52:  MOVFF  F5E,01
00E56:  MOVFF  02,5BA
00E5A:  MOVFF  01,5B9
00E5E:  MOVFF  02,615
00E62:  MOVFF  01,614
00E66:  MOVLB  0
00E68:  RCALL  09C4
00E6A:  MOVFF  03,613
00E6E:  MOVFF  02,612
00E72:  MOVFF  01,611
00E76:  MOVFF  00,610
00E7A:  MOVFF  C1,617
00E7E:  MOVFF  C0,616
00E82:  MOVFF  BF,615
00E86:  MOVFF  BE,614
00E8A:  RCALL  09FA
00E8C:  MOVFF  03,5BC
00E90:  MOVFF  02,5BB
00E94:  MOVFF  01,5BA
00E98:  MOVFF  00,5B9
00E9C:  BCF    FD8.1
00E9E:  MOVFF  03,617
00EA2:  MOVFF  02,616
00EA6:  MOVFF  01,615
00EAA:  MOVFF  00,614
00EAE:  MOVFF  BD,61B
00EB2:  MOVFF  BC,61A
00EB6:  MOVFF  BB,619
00EBA:  MOVFF  BA,618
00EBE:  RCALL  0AF0
00EC0:  MOVFF  03,FA
00EC4:  MOVFF  02,F9
00EC8:  MOVFF  01,F8
00ECC:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00ED0:  MOVLB  F
00ED2:  MOVF   x5A,W
00ED4:  ANDLW  3F
00ED6:  MOVWF  01
00ED8:  MOVLW  18
00EDA:  MOVWF  x5A
00EDC:  BTFSS  x5B.7
00EDE:  BRA    0EEE
00EE0:  MOVF   01,W
00EE2:  SUBLW  18
00EE4:  BZ    0EEE
00EE6:  BSF    x5B.0
00EE8:  NOP   
00EEA:  BTFSC  x5B.0
00EEC:  BRA    0EEA
....................             read_adc(ADC_START_ONLY);
00EEE:  BSF    x5B.0
00EF0:  NOP   
....................             state = 2;
00EF2:  MOVLW  02
00EF4:  MOVLB  1
00EF6:  MOVWF  x51
....................          break;
00EF8:  BRA    1276
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00EFA:  MOVLB  F
00EFC:  BTFSC  x5B.0
00EFE:  BRA    0EFC
00F00:  MOVFF  F5F,02
00F04:  MOVFF  F5E,01
00F08:  MOVFF  02,5BA
00F0C:  MOVFF  01,5B9
00F10:  MOVFF  02,615
00F14:  MOVFF  01,614
00F18:  MOVLB  0
00F1A:  RCALL  09C4
00F1C:  MOVFF  03,613
00F20:  MOVFF  02,612
00F24:  MOVFF  01,611
00F28:  MOVFF  00,610
00F2C:  MOVFF  C9,617
00F30:  MOVFF  C8,616
00F34:  MOVFF  C7,615
00F38:  MOVFF  C6,614
00F3C:  RCALL  09FA
00F3E:  MOVFF  03,5BC
00F42:  MOVFF  02,5BB
00F46:  MOVFF  01,5BA
00F4A:  MOVFF  00,5B9
00F4E:  BCF    FD8.1
00F50:  MOVFF  03,617
00F54:  MOVFF  02,616
00F58:  MOVFF  01,615
00F5C:  MOVFF  00,614
00F60:  MOVFF  C5,61B
00F64:  MOVFF  C4,61A
00F68:  MOVFF  C3,619
00F6C:  MOVFF  C2,618
00F70:  RCALL  0AF0
00F72:  MOVFF  03,FE
00F76:  MOVFF  02,FD
00F7A:  MOVFF  01,FC
00F7E:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
00F82:  MOVLB  F
00F84:  MOVF   x5A,W
00F86:  ANDLW  3F
00F88:  MOVWF  01
00F8A:  MOVLW  19
00F8C:  MOVWF  x5A
00F8E:  BTFSS  x5B.7
00F90:  BRA    0FA0
00F92:  MOVF   01,W
00F94:  SUBLW  19
00F96:  BZ    0FA0
00F98:  BSF    x5B.0
00F9A:  NOP   
00F9C:  BTFSC  x5B.0
00F9E:  BRA    0F9C
....................             read_adc(ADC_START_ONLY);
00FA0:  BSF    x5B.0
00FA2:  NOP   
....................             state = 3;
00FA4:  MOVLW  03
00FA6:  MOVLB  1
00FA8:  MOVWF  x51
....................          break;
00FAA:  BRA    1276
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
00FAC:  MOVLB  F
00FAE:  BTFSC  x5B.0
00FB0:  BRA    0FAE
00FB2:  MOVFF  F5F,02
00FB6:  MOVFF  F5E,01
00FBA:  MOVFF  02,5BA
00FBE:  MOVFF  01,5B9
00FC2:  MOVFF  02,615
00FC6:  MOVFF  01,614
00FCA:  MOVLB  0
00FCC:  RCALL  09C4
00FCE:  MOVFF  03,613
00FD2:  MOVFF  02,612
00FD6:  MOVFF  01,611
00FDA:  MOVFF  00,610
00FDE:  MOVFF  D1,617
00FE2:  MOVFF  D0,616
00FE6:  MOVFF  CF,615
00FEA:  MOVFF  CE,614
00FEE:  RCALL  09FA
00FF0:  MOVFF  03,5BC
00FF4:  MOVFF  02,5BB
00FF8:  MOVFF  01,5BA
00FFC:  MOVFF  00,5B9
01000:  BCF    FD8.1
01002:  MOVFF  03,617
01006:  MOVFF  02,616
0100A:  MOVFF  01,615
0100E:  MOVFF  00,614
01012:  MOVFF  CD,61B
01016:  MOVFF  CC,61A
0101A:  MOVFF  CB,619
0101E:  MOVFF  CA,618
01022:  RCALL  0AF0
01024:  MOVFF  03,102
01028:  MOVFF  02,101
0102C:  MOVFF  01,100
01030:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01034:  MOVLB  F
01036:  MOVF   x5A,W
01038:  ANDLW  3F
0103A:  MOVWF  01
0103C:  MOVLW  11
0103E:  MOVWF  x5A
01040:  BTFSS  x5B.7
01042:  BRA    1052
01044:  MOVF   01,W
01046:  SUBLW  11
01048:  BZ    1052
0104A:  BSF    x5B.0
0104C:  NOP   
0104E:  BTFSC  x5B.0
01050:  BRA    104E
....................             read_adc(ADC_START_ONLY);
01052:  BSF    x5B.0
01054:  NOP   
....................             state = 4;
01056:  MOVLW  04
01058:  MOVLB  1
0105A:  MOVWF  x51
....................          break;
0105C:  BRA    1276
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0105E:  MOVLB  F
01060:  BTFSC  x5B.0
01062:  BRA    1060
01064:  MOVFF  F5F,02
01068:  MOVFF  F5E,01
0106C:  MOVFF  02,5BA
01070:  MOVFF  01,5B9
01074:  MOVFF  02,615
01078:  MOVFF  01,614
0107C:  MOVLB  0
0107E:  RCALL  09C4
01080:  MOVFF  03,613
01084:  MOVFF  02,612
01088:  MOVFF  01,611
0108C:  MOVFF  00,610
01090:  MOVFF  D9,617
01094:  MOVFF  D8,616
01098:  MOVFF  D7,615
0109C:  MOVFF  D6,614
010A0:  RCALL  09FA
010A2:  MOVFF  03,5BC
010A6:  MOVFF  02,5BB
010AA:  MOVFF  01,5BA
010AE:  MOVFF  00,5B9
010B2:  BCF    FD8.1
010B4:  MOVFF  03,617
010B8:  MOVFF  02,616
010BC:  MOVFF  01,615
010C0:  MOVFF  00,614
010C4:  MOVFF  D5,61B
010C8:  MOVFF  D4,61A
010CC:  MOVFF  D3,619
010D0:  MOVFF  D2,618
010D4:  RCALL  0AF0
010D6:  MOVFF  03,106
010DA:  MOVFF  02,105
010DE:  MOVFF  01,104
010E2:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
010E6:  MOVLB  F
010E8:  MOVF   x5A,W
010EA:  ANDLW  3F
010EC:  MOVWF  01
010EE:  MOVLW  1B
010F0:  MOVWF  x5A
010F2:  BTFSS  x5B.7
010F4:  BRA    1104
010F6:  MOVF   01,W
010F8:  SUBLW  1B
010FA:  BZ    1104
010FC:  BSF    x5B.0
010FE:  NOP   
01100:  BTFSC  x5B.0
01102:  BRA    1100
....................             read_adc(ADC_START_ONLY);
01104:  BSF    x5B.0
01106:  NOP   
....................             state = 5;
01108:  MOVLW  05
0110A:  MOVLB  1
0110C:  MOVWF  x51
....................          break;
0110E:  BRA    1276
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01110:  MOVLB  F
01112:  BTFSC  x5B.0
01114:  BRA    1112
01116:  MOVFF  F5F,02
0111A:  MOVFF  F5E,01
0111E:  MOVFF  02,5BA
01122:  MOVFF  01,5B9
01126:  MOVFF  02,615
0112A:  MOVFF  01,614
0112E:  MOVLB  0
01130:  RCALL  09C4
01132:  MOVFF  03,613
01136:  MOVFF  02,612
0113A:  MOVFF  01,611
0113E:  MOVFF  00,610
01142:  MOVFF  E1,617
01146:  MOVFF  E0,616
0114A:  MOVFF  DF,615
0114E:  MOVFF  DE,614
01152:  RCALL  09FA
01154:  MOVFF  03,5BC
01158:  MOVFF  02,5BB
0115C:  MOVFF  01,5BA
01160:  MOVFF  00,5B9
01164:  BCF    FD8.1
01166:  MOVFF  03,617
0116A:  MOVFF  02,616
0116E:  MOVFF  01,615
01172:  MOVFF  00,614
01176:  MOVFF  DD,61B
0117A:  MOVFF  DC,61A
0117E:  MOVFF  DB,619
01182:  MOVFF  DA,618
01186:  RCALL  0AF0
01188:  MOVFF  03,10A
0118C:  MOVFF  02,109
01190:  MOVFF  01,108
01194:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
01198:  MOVLB  F
0119A:  MOVF   x5A,W
0119C:  ANDLW  3F
0119E:  MOVWF  01
011A0:  MOVLW  1A
011A2:  MOVWF  x5A
011A4:  BTFSS  x5B.7
011A6:  BRA    11B6
011A8:  MOVF   01,W
011AA:  SUBLW  1A
011AC:  BZ    11B6
011AE:  BSF    x5B.0
011B0:  NOP   
011B2:  BTFSC  x5B.0
011B4:  BRA    11B2
....................             read_adc(ADC_START_ONLY);
011B6:  BSF    x5B.0
011B8:  NOP   
....................             state = 6;
011BA:  MOVLW  06
011BC:  MOVLB  1
011BE:  MOVWF  x51
....................          break;
011C0:  BRA    1276
011C2:  MOVLB  0
....................          
....................          default:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
011C4:  MOVLB  F
011C6:  BTFSC  x5B.0
011C8:  BRA    11C6
011CA:  MOVFF  F5F,02
011CE:  MOVFF  F5E,01
011D2:  MOVFF  02,5BA
011D6:  MOVFF  01,5B9
011DA:  MOVFF  02,615
011DE:  MOVFF  01,614
011E2:  MOVLB  0
011E4:  CALL   09C4
011E8:  MOVFF  03,613
011EC:  MOVFF  02,612
011F0:  MOVFF  01,611
011F4:  MOVFF  00,610
011F8:  MOVFF  E9,617
011FC:  MOVFF  E8,616
01200:  MOVFF  E7,615
01204:  MOVFF  E6,614
01208:  CALL   09FA
0120C:  MOVFF  03,5BC
01210:  MOVFF  02,5BB
01214:  MOVFF  01,5BA
01218:  MOVFF  00,5B9
0121C:  BCF    FD8.1
0121E:  MOVFF  03,617
01222:  MOVFF  02,616
01226:  MOVFF  01,615
0122A:  MOVFF  00,614
0122E:  MOVFF  E5,61B
01232:  MOVFF  E4,61A
01236:  MOVFF  E3,619
0123A:  MOVFF  E2,618
0123E:  RCALL  0AF0
01240:  MOVFF  03,10E
01244:  MOVFF  02,10D
01248:  MOVFF  01,10C
0124C:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
01250:  MOVLB  F
01252:  MOVF   x5A,W
01254:  ANDLW  3F
01256:  MOVWF  01
01258:  MOVLW  06
0125A:  MOVWF  x5A
0125C:  BTFSS  x5B.7
0125E:  BRA    126E
01260:  MOVF   01,W
01262:  SUBLW  06
01264:  BZ    126E
01266:  BSF    x5B.0
01268:  NOP   
0126A:  BTFSC  x5B.0
0126C:  BRA    126A
....................             read_adc(ADC_START_ONLY);
0126E:  BSF    x5B.0
01270:  NOP   
....................             state = 0;
01272:  MOVLB  1
01274:  CLRF   x51
....................          break;   
01276:  MOVLB  F
....................       }
....................    }
01278:  MOVLB  0
0127A:  GOTO   6A8E (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, unsigned int32 sinRawCounts, unsigned int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
*
02D1C:  MOVLB  5
02D1E:  MOVF   xC2,W
02D20:  MULLW  19
02D22:  MOVF   FF3,W
02D24:  CLRF   xD4
02D26:  MOVWF  xD3
02D28:  MOVLW  0F
02D2A:  ADDWF  xD3,W
02D2C:  MOVWF  FE9
02D2E:  MOVLW  01
02D30:  ADDWFC xD4,W
02D32:  MOVWF  FEA
02D34:  MOVFF  5C6,5DA
02D38:  MOVFF  5C5,5D9
02D3C:  MOVFF  5C4,5D8
02D40:  MOVFF  5C3,5D7
02D44:  MOVLB  0
02D46:  CALL   12F4
02D4A:  MOVFF  00,FEF
02D4E:  MOVFF  01,FEC
02D52:  MOVFF  02,FEC
02D56:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02D5A:  MOVLB  5
02D5C:  MOVF   xC2,W
02D5E:  MULLW  19
02D60:  MOVF   FF3,W
02D62:  CLRF   xD4
02D64:  MOVWF  xD3
02D66:  MOVLW  04
02D68:  ADDWF  xD3,W
02D6A:  MOVWF  01
02D6C:  MOVLW  00
02D6E:  ADDWFC xD4,W
02D70:  MOVWF  03
02D72:  MOVF   01,W
02D74:  ADDLW  0F
02D76:  MOVWF  FE9
02D78:  MOVLW  01
02D7A:  ADDWFC 03,W
02D7C:  MOVWF  FEA
02D7E:  MOVFF  5CA,5DA
02D82:  MOVFF  5C9,5D9
02D86:  MOVFF  5C8,5D8
02D8A:  MOVFF  5C7,5D7
02D8E:  MOVLB  0
02D90:  CALL   12F4
02D94:  MOVFF  00,FEF
02D98:  MOVFF  01,FEC
02D9C:  MOVFF  02,FEC
02DA0:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02DA4:  MOVLB  5
02DA6:  MOVF   xC2,W
02DA8:  MULLW  19
02DAA:  MOVF   FF3,W
02DAC:  CLRF   xD4
02DAE:  MOVWF  xD3
02DB0:  MOVLW  08
02DB2:  ADDWF  xD3,W
02DB4:  MOVWF  01
02DB6:  MOVLW  00
02DB8:  ADDWFC xD4,W
02DBA:  MOVWF  03
02DBC:  MOVF   01,W
02DBE:  ADDLW  0F
02DC0:  MOVWF  01
02DC2:  MOVLW  01
02DC4:  ADDWFC 03,F
02DC6:  MOVFF  01,5D3
02DCA:  MOVFF  03,5D4
02DCE:  MOVF   xC2,W
02DD0:  MULLW  19
02DD2:  MOVF   FF3,W
02DD4:  CLRF   xD6
02DD6:  MOVWF  xD5
02DD8:  MOVLW  0F
02DDA:  ADDWF  xD5,W
02DDC:  MOVWF  FE9
02DDE:  MOVLW  01
02DE0:  ADDWFC xD6,W
02DE2:  MOVWF  FEA
02DE4:  MOVFF  FEF,610
02DE8:  MOVFF  FEC,611
02DEC:  MOVFF  FEC,612
02DF0:  MOVFF  FEC,613
02DF4:  MOVF   xC2,W
02DF6:  MULLW  10
02DF8:  MOVF   FF3,W
02DFA:  CLRF   xDC
02DFC:  MOVWF  xDB
02DFE:  MOVLW  08
02E00:  ADDWF  xDB,W
02E02:  MOVWF  01
02E04:  MOVLW  00
02E06:  ADDWFC xDC,W
02E08:  MOVWF  03
02E0A:  MOVF   01,W
02E0C:  ADDLW  62
02E0E:  MOVWF  FE9
02E10:  MOVLW  00
02E12:  ADDWFC 03,W
02E14:  MOVWF  FEA
02E16:  MOVFF  FEF,614
02E1A:  MOVFF  FEC,01
02E1E:  MOVFF  FEC,02
02E22:  MOVFF  FEC,03
02E26:  MOVFF  03,617
02E2A:  MOVFF  02,616
02E2E:  MOVFF  01,615
02E32:  MOVLB  0
02E34:  CALL   09FA
02E38:  MOVFF  03,617
02E3C:  MOVFF  02,616
02E40:  MOVFF  01,615
02E44:  MOVFF  00,614
02E48:  MOVLB  5
02E4A:  MOVF   xC2,W
02E4C:  MULLW  10
02E4E:  MOVF   FF3,W
02E50:  CLRF   xDC
02E52:  MOVWF  xDB
02E54:  MOVLW  62
02E56:  ADDWF  xDB,W
02E58:  MOVWF  FE9
02E5A:  MOVLW  00
02E5C:  ADDWFC xDC,W
02E5E:  MOVWF  FEA
02E60:  MOVFF  FEF,618
02E64:  MOVFF  FEC,01
02E68:  MOVFF  FEC,02
02E6C:  MOVFF  FEC,03
02E70:  BCF    FD8.1
02E72:  MOVFF  03,61B
02E76:  MOVFF  02,61A
02E7A:  MOVFF  01,619
02E7E:  MOVLB  0
02E80:  CALL   0AF0
02E84:  MOVFF  5D4,FEA
02E88:  MOVFF  5D3,FE9
02E8C:  MOVFF  00,FEF
02E90:  MOVFF  01,FEC
02E94:  MOVFF  02,FEC
02E98:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
02E9C:  MOVLB  5
02E9E:  MOVF   xC2,W
02EA0:  MULLW  19
02EA2:  MOVF   FF3,W
02EA4:  CLRF   xD4
02EA6:  MOVWF  xD3
02EA8:  MOVLW  0C
02EAA:  ADDWF  xD3,W
02EAC:  MOVWF  01
02EAE:  MOVLW  00
02EB0:  ADDWFC xD4,W
02EB2:  MOVWF  03
02EB4:  MOVF   01,W
02EB6:  ADDLW  0F
02EB8:  MOVWF  01
02EBA:  MOVLW  01
02EBC:  ADDWFC 03,F
02EBE:  MOVFF  01,5D3
02EC2:  MOVFF  03,5D4
02EC6:  MOVF   xC2,W
02EC8:  MULLW  19
02ECA:  MOVF   FF3,W
02ECC:  CLRF   xD6
02ECE:  MOVWF  xD5
02ED0:  MOVLW  04
02ED2:  ADDWF  xD5,W
02ED4:  MOVWF  01
02ED6:  MOVLW  00
02ED8:  ADDWFC xD6,W
02EDA:  MOVWF  03
02EDC:  MOVF   01,W
02EDE:  ADDLW  0F
02EE0:  MOVWF  FE9
02EE2:  MOVLW  01
02EE4:  ADDWFC 03,W
02EE6:  MOVWF  FEA
02EE8:  MOVFF  FEF,610
02EEC:  MOVFF  FEC,611
02EF0:  MOVFF  FEC,612
02EF4:  MOVFF  FEC,613
02EF8:  MOVF   xC2,W
02EFA:  MULLW  10
02EFC:  MOVF   FF3,W
02EFE:  CLRF   xDA
02F00:  MOVWF  xD9
02F02:  MOVLW  0C
02F04:  ADDWF  xD9,W
02F06:  MOVWF  01
02F08:  MOVLW  00
02F0A:  ADDWFC xDA,W
02F0C:  MOVWF  03
02F0E:  MOVF   01,W
02F10:  ADDLW  62
02F12:  MOVWF  FE9
02F14:  MOVLW  00
02F16:  ADDWFC 03,W
02F18:  MOVWF  FEA
02F1A:  MOVFF  FEF,614
02F1E:  MOVFF  FEC,01
02F22:  MOVFF  FEC,02
02F26:  MOVFF  FEC,03
02F2A:  MOVFF  03,617
02F2E:  MOVFF  02,616
02F32:  MOVFF  01,615
02F36:  MOVLB  0
02F38:  CALL   09FA
02F3C:  MOVFF  03,617
02F40:  MOVFF  02,616
02F44:  MOVFF  01,615
02F48:  MOVFF  00,614
02F4C:  MOVLB  5
02F4E:  MOVF   xC2,W
02F50:  MULLW  10
02F52:  MOVF   FF3,W
02F54:  CLRF   xDA
02F56:  MOVWF  xD9
02F58:  MOVLW  04
02F5A:  ADDWF  xD9,W
02F5C:  MOVWF  01
02F5E:  MOVLW  00
02F60:  ADDWFC xDA,W
02F62:  MOVWF  03
02F64:  MOVF   01,W
02F66:  ADDLW  62
02F68:  MOVWF  FE9
02F6A:  MOVLW  00
02F6C:  ADDWFC 03,W
02F6E:  MOVWF  FEA
02F70:  MOVFF  FEF,618
02F74:  MOVFF  FEC,01
02F78:  MOVFF  FEC,02
02F7C:  MOVFF  FEC,03
02F80:  BCF    FD8.1
02F82:  MOVFF  03,61B
02F86:  MOVFF  02,61A
02F8A:  MOVFF  01,619
02F8E:  MOVLB  0
02F90:  CALL   0AF0
02F94:  MOVFF  5D4,FEA
02F98:  MOVFF  5D3,FE9
02F9C:  MOVFF  00,FEF
02FA0:  MOVFF  01,FEC
02FA4:  MOVFF  02,FEC
02FA8:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
02FAC:  MOVLB  5
02FAE:  CLRF   xCE
02FB0:  CLRF   xCD
02FB2:  CLRF   xCC
02FB4:  CLRF   xCB
02FB6:  CLRF   xD2
02FB8:  CLRF   xD1
02FBA:  CLRF   xD0
02FBC:  MOVLW  7F
02FBE:  MOVWF  xCF
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
02FC0:  MOVF   xC2,W
02FC2:  MULLW  19
02FC4:  MOVF   FF3,W
02FC6:  CLRF   xD4
02FC8:  MOVWF  xD3
02FCA:  MOVLW  10
02FCC:  ADDWF  xD3,W
02FCE:  MOVWF  01
02FD0:  MOVLW  00
02FD2:  ADDWFC xD4,W
02FD4:  MOVWF  03
02FD6:  MOVF   01,W
02FD8:  ADDLW  0F
02FDA:  MOVWF  01
02FDC:  MOVLW  01
02FDE:  ADDWFC 03,F
02FE0:  MOVFF  01,5D3
02FE4:  MOVFF  03,5D4
02FE8:  MOVFF  5D2,613
02FEC:  MOVFF  5D1,612
02FF0:  MOVFF  5D0,611
02FF4:  MOVFF  5CF,610
02FF8:  MOVLW  AA
02FFA:  MOVLB  6
02FFC:  MOVWF  x17
02FFE:  MOVLW  27
03000:  MOVWF  x16
03002:  MOVLW  1F
03004:  MOVWF  x15
03006:  MOVLW  86
03008:  MOVWF  x14
0300A:  MOVLB  0
0300C:  CALL   09FA
03010:  MOVFF  03,5D8
03014:  MOVFF  02,5D7
03018:  MOVFF  01,5D6
0301C:  MOVFF  00,5D5
03020:  MOVLB  5
03022:  MOVF   xC2,W
03024:  MULLW  19
03026:  MOVF   FF3,W
03028:  CLRF   xDA
0302A:  MOVWF  xD9
0302C:  MOVLW  08
0302E:  ADDWF  xD9,W
03030:  MOVWF  01
03032:  MOVLW  00
03034:  ADDWFC xDA,W
03036:  MOVWF  03
03038:  MOVF   01,W
0303A:  ADDLW  0F
0303C:  MOVWF  FE9
0303E:  MOVLW  01
03040:  ADDWFC 03,W
03042:  MOVWF  FEA
03044:  MOVFF  FEF,5D9
03048:  MOVFF  FEC,5DA
0304C:  MOVFF  FEC,5DB
03050:  MOVFF  FEC,5DC
03054:  MOVF   xC2,W
03056:  MULLW  19
03058:  MOVF   FF3,W
0305A:  CLRF   xDE
0305C:  MOVWF  xDD
0305E:  MOVLW  0C
03060:  ADDWF  xDD,W
03062:  MOVWF  01
03064:  MOVLW  00
03066:  ADDWFC xDE,W
03068:  MOVWF  03
0306A:  MOVF   01,W
0306C:  ADDLW  0F
0306E:  MOVWF  FE9
03070:  MOVLW  01
03072:  ADDWFC 03,W
03074:  MOVWF  FEA
03076:  MOVFF  FEF,00
0307A:  MOVFF  FEC,01
0307E:  MOVFF  FEC,02
03082:  MOVFF  FEC,03
03086:  MOVFF  03,5E0
0308A:  MOVFF  02,5DF
0308E:  MOVFF  01,5DE
03092:  MOVFF  00,5DD
03096:  MOVFF  5DC,5E4
0309A:  MOVFF  5DB,5E3
0309E:  MOVFF  5DA,5E2
030A2:  MOVFF  5D9,5E1
030A6:  MOVFF  03,5E8
030AA:  MOVFF  02,5E7
030AE:  MOVFF  01,5E6
030B2:  MOVFF  00,5E5
030B6:  MOVLB  0
030B8:  GOTO   1A32
030BC:  MOVFF  5D8,613
030C0:  MOVFF  5D7,612
030C4:  MOVFF  5D6,611
030C8:  MOVFF  5D5,610
030CC:  MOVFF  03,617
030D0:  MOVFF  02,616
030D4:  MOVFF  01,615
030D8:  MOVFF  00,614
030DC:  CALL   09FA
030E0:  MOVFF  5D4,FEA
030E4:  MOVFF  5D3,FE9
030E8:  MOVFF  00,FEF
030EC:  MOVFF  01,FEC
030F0:  MOVFF  02,FEC
030F4:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( polePitch * adcVals[ch].npoles );
030F8:  MOVLB  5
030FA:  MOVF   xC2,W
030FC:  MULLW  19
030FE:  MOVF   FF3,W
03100:  CLRF   xD4
03102:  MOVWF  xD3
03104:  MOVLW  10
03106:  ADDWF  xD3,W
03108:  MOVWF  01
0310A:  MOVLW  00
0310C:  ADDWFC xD4,W
0310E:  MOVWF  03
03110:  MOVF   01,W
03112:  ADDLW  0F
03114:  MOVWF  FE9
03116:  MOVLW  01
03118:  ADDWFC 03,W
0311A:  MOVWF  FEA
0311C:  MOVFF  FEF,5D3
03120:  MOVFF  FEC,5D4
03124:  MOVFF  FEC,5D5
03128:  MOVFF  FEC,5D6
0312C:  MOVF   xC2,W
0312E:  MULLW  19
03130:  MOVF   FF3,W
03132:  CLRF   xD8
03134:  MOVWF  xD7
03136:  MOVLW  14
03138:  ADDWF  xD7,W
0313A:  MOVWF  01
0313C:  MOVLW  00
0313E:  ADDWFC xD8,W
03140:  MOVWF  03
03142:  MOVF   01,W
03144:  ADDLW  0F
03146:  MOVWF  FE9
03148:  MOVLW  01
0314A:  ADDWFC 03,W
0314C:  MOVWF  FEA
0314E:  MOVF   FEF,W
03150:  MOVLB  6
03152:  CLRF   x15
03154:  MOVWF  x14
03156:  MOVLB  0
03158:  CALL   09C4
0315C:  MOVFF  5D2,613
03160:  MOVFF  5D1,612
03164:  MOVFF  5D0,611
03168:  MOVFF  5CF,610
0316C:  MOVFF  03,617
03170:  MOVFF  02,616
03174:  MOVFF  01,615
03178:  MOVFF  00,614
0317C:  CALL   09FA
03180:  MOVFF  FEA,5D8
03184:  MOVFF  FE9,5D7
03188:  BCF    FD8.1
0318A:  MOVFF  5D6,617
0318E:  MOVFF  5D5,616
03192:  MOVFF  5D4,615
03196:  MOVFF  5D3,614
0319A:  MOVFF  03,61B
0319E:  MOVFF  02,61A
031A2:  MOVFF  01,619
031A6:  MOVFF  00,618
031AA:  CALL   0AF0
031AE:  MOVFF  5D8,FEA
031B2:  MOVFF  5D7,FE9
031B6:  MOVFF  03,5CE
031BA:  MOVFF  02,5CD
031BE:  MOVFF  01,5CC
031C2:  MOVFF  00,5CB
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
031C6:  MOVLB  5
031C8:  MOVF   xC2,W
031CA:  MULLW  19
031CC:  MOVF   FF3,W
031CE:  CLRF   xD4
031D0:  MOVWF  xD3
031D2:  MOVLW  15
031D4:  ADDWF  xD3,W
031D6:  MOVWF  01
031D8:  MOVLW  00
031DA:  ADDWFC xD4,W
031DC:  MOVWF  03
031DE:  MOVF   01,W
031E0:  ADDLW  0F
031E2:  MOVWF  01
031E4:  MOVLW  01
031E6:  ADDWFC 03,F
031E8:  MOVFF  01,5D3
031EC:  MOVFF  03,5D4
031F0:  MOVF   xC2,W
031F2:  MULLW  18
031F4:  MOVF   FF3,W
031F6:  CLRF   xD6
031F8:  MOVWF  xD5
031FA:  MOVLW  14
031FC:  ADDWF  xD5,W
031FE:  MOVWF  01
03200:  MOVLW  00
03202:  ADDWFC xD6,W
03204:  MOVWF  03
03206:  MOVF   01,W
03208:  ADDLW  82
0320A:  MOVWF  FE9
0320C:  MOVLW  00
0320E:  ADDWFC 03,W
03210:  MOVWF  FEA
03212:  MOVFF  FEF,614
03216:  MOVFF  FEC,01
0321A:  MOVFF  FEC,02
0321E:  MOVFF  FEC,03
03222:  MOVFF  5CE,613
03226:  MOVFF  5CD,612
0322A:  MOVFF  5CC,611
0322E:  MOVFF  5CB,610
03232:  MOVFF  03,617
03236:  MOVFF  02,616
0323A:  MOVFF  01,615
0323E:  MOVLB  0
03240:  CALL   09FA
03244:  MOVFF  03,5D8
03248:  MOVFF  02,5D7
0324C:  MOVFF  01,5D6
03250:  MOVFF  00,5D5
03254:  MOVFF  03,5E4
03258:  MOVFF  02,5E3
0325C:  MOVFF  01,5E2
03260:  MOVFF  00,5E1
03264:  MOVLB  5
03266:  CLRF   xE8
03268:  CLRF   xE7
0326A:  MOVLW  20
0326C:  MOVWF  xE6
0326E:  MOVLW  81
03270:  MOVWF  xE5
03272:  MOVLB  0
03274:  CALL   2A1E
03278:  MOVFF  03,5D8
0327C:  MOVFF  02,5D7
03280:  MOVFF  01,5D6
03284:  MOVFF  00,5D5
03288:  MOVLB  5
0328A:  MOVF   xC2,W
0328C:  MULLW  18
0328E:  MOVF   FF3,W
03290:  CLRF   xDA
03292:  MOVWF  xD9
03294:  MOVLW  10
03296:  ADDWF  xD9,W
03298:  MOVWF  01
0329A:  MOVLW  00
0329C:  ADDWFC xDA,W
0329E:  MOVWF  03
032A0:  MOVF   01,W
032A2:  ADDLW  82
032A4:  MOVWF  FE9
032A6:  MOVLW  00
032A8:  ADDWFC 03,W
032AA:  MOVWF  FEA
032AC:  MOVFF  FEF,614
032B0:  MOVFF  FEC,01
032B4:  MOVFF  FEC,02
032B8:  MOVFF  FEC,03
032BC:  MOVFF  5CE,613
032C0:  MOVFF  5CD,612
032C4:  MOVFF  5CC,611
032C8:  MOVFF  5CB,610
032CC:  MOVFF  03,617
032D0:  MOVFF  02,616
032D4:  MOVFF  01,615
032D8:  MOVLB  0
032DA:  CALL   09FA
032DE:  MOVFF  03,5DC
032E2:  MOVFF  02,5DB
032E6:  MOVFF  01,5DA
032EA:  MOVFF  00,5D9
032EE:  MOVFF  03,5E4
032F2:  MOVFF  02,5E3
032F6:  MOVFF  01,5E2
032FA:  MOVFF  00,5E1
032FE:  MOVLB  5
03300:  CLRF   xE8
03302:  CLRF   xE7
03304:  CLRF   xE6
03306:  MOVLW  81
03308:  MOVWF  xE5
0330A:  MOVLB  0
0330C:  CALL   2A1E
03310:  MOVFF  FEA,5DA
03314:  MOVFF  FE9,5D9
03318:  BCF    FD8.1
0331A:  MOVFF  5D8,617
0331E:  MOVFF  5D7,616
03322:  MOVFF  5D6,615
03326:  MOVFF  5D5,614
0332A:  MOVFF  03,61B
0332E:  MOVFF  02,61A
03332:  MOVFF  01,619
03336:  MOVFF  00,618
0333A:  CALL   0AF0
0333E:  MOVFF  5DA,FEA
03342:  MOVFF  5D9,FE9
03346:  MOVFF  03,5D8
0334A:  MOVFF  02,5D7
0334E:  MOVFF  01,5D6
03352:  MOVFF  00,5D5
03356:  MOVLB  5
03358:  MOVF   xC2,W
0335A:  MULLW  18
0335C:  MOVF   FF3,W
0335E:  CLRF   xDC
03360:  MOVWF  xDB
03362:  MOVLW  0C
03364:  ADDWF  xDB,W
03366:  MOVWF  01
03368:  MOVLW  00
0336A:  ADDWFC xDC,W
0336C:  MOVWF  03
0336E:  MOVF   01,W
03370:  ADDLW  82
03372:  MOVWF  FE9
03374:  MOVLW  00
03376:  ADDWFC 03,W
03378:  MOVWF  FEA
0337A:  MOVFF  FEF,614
0337E:  MOVFF  FEC,01
03382:  MOVFF  FEC,02
03386:  MOVFF  FEC,03
0338A:  MOVFF  5CE,613
0338E:  MOVFF  5CD,612
03392:  MOVFF  5CC,611
03396:  MOVFF  5CB,610
0339A:  MOVFF  03,617
0339E:  MOVFF  02,616
033A2:  MOVFF  01,615
033A6:  MOVLB  0
033A8:  CALL   09FA
033AC:  MOVFF  03,5DE
033B0:  MOVFF  02,5DD
033B4:  MOVFF  01,5DC
033B8:  MOVFF  00,5DB
033BC:  MOVFF  03,5E4
033C0:  MOVFF  02,5E3
033C4:  MOVFF  01,5E2
033C8:  MOVFF  00,5E1
033CC:  MOVLB  5
033CE:  CLRF   xE8
033D0:  CLRF   xE7
033D2:  MOVLW  40
033D4:  MOVWF  xE6
033D6:  MOVLW  80
033D8:  MOVWF  xE5
033DA:  MOVLB  0
033DC:  CALL   2A1E
033E0:  MOVFF  FEA,5DC
033E4:  MOVFF  FE9,5DB
033E8:  BCF    FD8.1
033EA:  MOVFF  5D8,617
033EE:  MOVFF  5D7,616
033F2:  MOVFF  5D6,615
033F6:  MOVFF  5D5,614
033FA:  MOVFF  03,61B
033FE:  MOVFF  02,61A
03402:  MOVFF  01,619
03406:  MOVFF  00,618
0340A:  CALL   0AF0
0340E:  MOVFF  5DC,FEA
03412:  MOVFF  5DB,FE9
03416:  MOVFF  03,5D8
0341A:  MOVFF  02,5D7
0341E:  MOVFF  01,5D6
03422:  MOVFF  00,5D5
03426:  MOVLB  5
03428:  MOVF   xC2,W
0342A:  MULLW  18
0342C:  MOVF   FF3,W
0342E:  CLRF   xDE
03430:  MOVWF  xDD
03432:  MOVLW  08
03434:  ADDWF  xDD,W
03436:  MOVWF  01
03438:  MOVLW  00
0343A:  ADDWFC xDE,W
0343C:  MOVWF  03
0343E:  MOVF   01,W
03440:  ADDLW  82
03442:  MOVWF  FE9
03444:  MOVLW  00
03446:  ADDWFC 03,W
03448:  MOVWF  FEA
0344A:  MOVFF  FEF,614
0344E:  MOVFF  FEC,01
03452:  MOVFF  FEC,02
03456:  MOVFF  FEC,03
0345A:  MOVFF  5CE,613
0345E:  MOVFF  5CD,612
03462:  MOVFF  5CC,611
03466:  MOVFF  5CB,610
0346A:  MOVFF  03,617
0346E:  MOVFF  02,616
03472:  MOVFF  01,615
03476:  MOVLB  0
03478:  CALL   09FA
0347C:  MOVFF  03,5E0
03480:  MOVFF  02,5DF
03484:  MOVFF  01,5DE
03488:  MOVFF  00,5DD
0348C:  MOVFF  03,5E4
03490:  MOVFF  02,5E3
03494:  MOVFF  01,5E2
03498:  MOVFF  00,5E1
0349C:  MOVLB  5
0349E:  CLRF   xE8
034A0:  CLRF   xE7
034A2:  CLRF   xE6
034A4:  MOVLW  80
034A6:  MOVWF  xE5
034A8:  MOVLB  0
034AA:  CALL   2A1E
034AE:  MOVFF  FEA,5DE
034B2:  MOVFF  FE9,5DD
034B6:  BCF    FD8.1
034B8:  MOVFF  5D8,617
034BC:  MOVFF  5D7,616
034C0:  MOVFF  5D6,615
034C4:  MOVFF  5D5,614
034C8:  MOVFF  03,61B
034CC:  MOVFF  02,61A
034D0:  MOVFF  01,619
034D4:  MOVFF  00,618
034D8:  CALL   0AF0
034DC:  MOVFF  5DE,FEA
034E0:  MOVFF  5DD,FE9
034E4:  MOVFF  03,5D8
034E8:  MOVFF  02,5D7
034EC:  MOVFF  01,5D6
034F0:  MOVFF  00,5D5
034F4:  MOVLB  5
034F6:  MOVF   xC2,W
034F8:  MULLW  18
034FA:  MOVF   FF3,W
034FC:  CLRF   xE0
034FE:  MOVWF  xDF
03500:  MOVLW  04
03502:  ADDWF  xDF,W
03504:  MOVWF  01
03506:  MOVLW  00
03508:  ADDWFC xE0,W
0350A:  MOVWF  03
0350C:  MOVF   01,W
0350E:  ADDLW  82
03510:  MOVWF  FE9
03512:  MOVLW  00
03514:  ADDWFC 03,W
03516:  MOVWF  FEA
03518:  MOVFF  FEF,614
0351C:  MOVFF  FEC,01
03520:  MOVFF  FEC,02
03524:  MOVFF  FEC,03
03528:  MOVFF  5CE,613
0352C:  MOVFF  5CD,612
03530:  MOVFF  5CC,611
03534:  MOVFF  5CB,610
03538:  MOVFF  03,617
0353C:  MOVFF  02,616
03540:  MOVFF  01,615
03544:  MOVLB  0
03546:  CALL   09FA
0354A:  MOVFF  FEA,5E0
0354E:  MOVFF  FE9,5DF
03552:  BCF    FD8.1
03554:  MOVFF  5D8,617
03558:  MOVFF  5D7,616
0355C:  MOVFF  5D6,615
03560:  MOVFF  5D5,614
03564:  MOVFF  03,61B
03568:  MOVFF  02,61A
0356C:  MOVFF  01,619
03570:  MOVFF  00,618
03574:  CALL   0AF0
03578:  MOVFF  5E0,FEA
0357C:  MOVFF  5DF,FE9
03580:  MOVFF  03,617
03584:  MOVFF  02,616
03588:  MOVFF  01,615
0358C:  MOVFF  00,614
03590:  MOVLB  5
03592:  MOVF   xC2,W
03594:  MULLW  18
03596:  MOVF   FF3,W
03598:  CLRF   xE2
0359A:  MOVWF  xE1
0359C:  MOVLW  82
0359E:  ADDWF  xE1,W
035A0:  MOVWF  FE9
035A2:  MOVLW  00
035A4:  ADDWFC xE2,W
035A6:  MOVWF  FEA
035A8:  MOVFF  FEF,618
035AC:  MOVFF  FEC,01
035B0:  MOVFF  FEC,02
035B4:  MOVFF  FEC,03
035B8:  BCF    FD8.1
035BA:  MOVFF  03,61B
035BE:  MOVFF  02,61A
035C2:  MOVFF  01,619
035C6:  MOVLB  0
035C8:  CALL   0AF0
035CC:  MOVFF  5D4,FEA
035D0:  MOVFF  5D3,FE9
035D4:  MOVFF  00,FEF
035D8:  MOVFF  01,FEC
035DC:  MOVFF  02,FEC
035E0:  MOVFF  03,FEC
....................    
....................    PID[ch].PVold = PID[ch].PV;
035E4:  MOVLB  5
035E6:  MOVF   xC2,W
035E8:  MULLW  20
035EA:  MOVF   FF3,W
035EC:  CLRF   xD4
035EE:  MOVWF  xD3
035F0:  MOVLW  14
035F2:  ADDWF  xD3,W
035F4:  MOVWF  01
035F6:  MOVLW  00
035F8:  ADDWFC xD4,W
035FA:  MOVWF  03
035FC:  MOVF   01,W
035FE:  ADDLW  20
03600:  MOVWF  01
03602:  MOVLW  00
03604:  ADDWFC 03,F
03606:  MOVFF  01,5D3
0360A:  MOVFF  03,5D4
0360E:  MOVF   xC2,W
03610:  MULLW  20
03612:  MOVF   FF3,W
03614:  CLRF   xD6
03616:  MOVWF  xD5
03618:  MOVLW  10
0361A:  ADDWF  xD5,W
0361C:  MOVWF  01
0361E:  MOVLW  00
03620:  ADDWFC xD6,W
03622:  MOVWF  03
03624:  MOVF   01,W
03626:  ADDLW  20
03628:  MOVWF  FE9
0362A:  MOVLW  00
0362C:  ADDWFC 03,W
0362E:  MOVWF  FEA
03630:  MOVFF  FEF,00
03634:  MOVFF  FEC,01
03638:  MOVFF  FEC,02
0363C:  MOVFF  FEC,03
03640:  MOVFF  5D4,FEA
03644:  MOVFF  5D3,FE9
03648:  MOVFF  00,FEF
0364C:  MOVFF  01,FEC
03650:  MOVFF  02,FEC
03654:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03658:  MOVF   xC2,W
0365A:  MULLW  20
0365C:  MOVF   FF3,W
0365E:  CLRF   xD4
03660:  MOVWF  xD3
03662:  MOVLW  10
03664:  ADDWF  xD3,W
03666:  MOVWF  01
03668:  MOVLW  00
0366A:  ADDWFC xD4,W
0366C:  MOVWF  03
0366E:  MOVF   01,W
03670:  ADDLW  20
03672:  MOVWF  01
03674:  MOVLW  00
03676:  ADDWFC 03,F
03678:  MOVFF  01,5D3
0367C:  MOVFF  03,5D4
03680:  MOVF   xC2,W
03682:  MULLW  19
03684:  MOVF   FF3,W
03686:  CLRF   xD6
03688:  MOVWF  xD5
0368A:  MOVLW  15
0368C:  ADDWF  xD5,W
0368E:  MOVWF  01
03690:  MOVLW  00
03692:  ADDWFC xD6,W
03694:  MOVWF  03
03696:  MOVF   01,W
03698:  ADDLW  0F
0369A:  MOVWF  FE9
0369C:  MOVLW  01
0369E:  ADDWFC 03,W
036A0:  MOVWF  FEA
036A2:  MOVFF  FEF,00
036A6:  MOVFF  FEC,01
036AA:  MOVFF  FEC,02
036AE:  MOVFF  FEC,03
036B2:  MOVFF  5D4,FEA
036B6:  MOVFF  5D3,FE9
036BA:  MOVFF  00,FEF
036BE:  MOVFF  01,FEC
036C2:  MOVFF  02,FEC
036C6:  MOVFF  03,FEC
036CA:  MOVLB  0
036CC:  GOTO   37A8 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    if (!smData.adcBusy)
*
001E0:  MOVLB  1
001E2:  BTFSC  x4F.1
001E4:  BRA    0218
....................    {
....................       smData.adcBusy = true;
001E6:  BSF    x4F.1
....................       switch (smData.channel)
001E8:  MOVF   x50,W
001EA:  XORLW  00
001EC:  MOVLB  0
001EE:  BZ    01F6
001F0:  XORLW  01
001F2:  BZ    0206
001F4:  BRA    0212
....................       {
....................          case 0:
....................             ads_write_command_block(1, ADSstart);
001F6:  MOVLW  01
001F8:  MOVLB  6
001FA:  MOVWF  x24
001FC:  MOVLW  08
001FE:  MOVWF  x25
00200:  MOVLB  0
00202:  RCALL  01C8
....................          break;
00204:  BRA    0212
....................          
....................          case 1:
....................             ads_write_command_block(0, ADSstart);
00206:  MOVLB  6
00208:  CLRF   x24
0020A:  MOVLW  08
0020C:  MOVWF  x25
0020E:  MOVLB  0
00210:  RCALL  01C8
....................          break;
....................       }
....................       smData.adcBusy = false;
00212:  MOVLB  1
00214:  BCF    x4F.1
....................       smData.dataReady = true;
00216:  BSF    x4F.0
....................    }
00218:  MOVLB  0
0021A:  GOTO   02DC (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
.................... {
....................    if (smData.dataReady)
*
036D0:  MOVLB  1
036D2:  BTFSS  x4F.0
036D4:  BRA    37AA
....................    {
....................       unsigned int32 sinRaw=0;
....................       unsigned int32 cosRaw=0;
....................       int8 ch=0;
036D6:  MOVLB  5
036D8:  CLRF   xBC
036DA:  CLRF   xBB
036DC:  CLRF   xBA
036DE:  CLRF   xB9
036E0:  CLRF   xC0
036E2:  CLRF   xBF
036E4:  CLRF   xBE
036E6:  CLRF   xBD
036E8:  CLRF   xC1
....................       
....................       smData.adcBusy = true;
036EA:  MOVLB  1
036EC:  BSF    x4F.1
....................       switch (smData.channel)
036EE:  MOVF   x50,W
036F0:  XORLW  00
036F2:  MOVLB  0
036F4:  BZ    36F8
036F6:  BRA    373A
....................       {
....................          case 0:
....................             ch = 0;
036F8:  MOVLB  5
036FA:  CLRF   xC1
....................             sinRaw = ads_read_data(0);
036FC:  CLRF   xC2
036FE:  MOVLB  0
03700:  CALL   12AE
03704:  MOVFF  03,5BC
03708:  MOVFF  02,5BB
0370C:  MOVFF  01,5BA
03710:  MOVFF  00,5B9
....................             cosRaw = ads_read_data(1);
03714:  MOVLW  01
03716:  MOVLB  5
03718:  MOVWF  xC2
0371A:  MOVLB  0
0371C:  CALL   12AE
03720:  MOVFF  03,5C0
03724:  MOVFF  02,5BF
03728:  MOVFF  01,5BE
0372C:  MOVFF  00,5BD
....................             smData.channel = 1;
03730:  MOVLW  01
03732:  MOVLB  1
03734:  MOVWF  x50
....................          break;
03736:  BRA    377A
03738:  MOVLB  0
....................          
....................          default:
....................             ch = 1;
0373A:  MOVLW  01
0373C:  MOVLB  5
0373E:  MOVWF  xC1
....................             sinRaw = ads_read_data(2);
03740:  MOVLW  02
03742:  MOVWF  xC2
03744:  MOVLB  0
03746:  CALL   12AE
0374A:  MOVFF  03,5BC
0374E:  MOVFF  02,5BB
03752:  MOVFF  01,5BA
03756:  MOVFF  00,5B9
....................             cosRaw = ads_read_data(3);
0375A:  MOVLW  03
0375C:  MOVLB  5
0375E:  MOVWF  xC2
03760:  MOVLB  0
03762:  CALL   12AE
03766:  MOVFF  03,5C0
0376A:  MOVFF  02,5BF
0376E:  MOVFF  01,5BE
03772:  MOVFF  00,5BD
....................             smData.channel = 0;
03776:  MOVLB  1
03778:  CLRF   x50
....................          break;
....................       }
....................       smData.adcBusy = false;
0377A:  BCF    x4F.1
....................       smData.dataReady = false;
0377C:  BCF    x4F.0
....................       sensor_process_data(ch, sinRaw, cosRaw);
0377E:  MOVFF  5C1,5C2
03782:  MOVFF  5BC,5C6
03786:  MOVFF  5BB,5C5
0378A:  MOVFF  5BA,5C4
0378E:  MOVFF  5B9,5C3
03792:  MOVFF  5C0,5CA
03796:  MOVFF  5BF,5C9
0379A:  MOVFF  5BE,5C8
0379E:  MOVFF  5BD,5C7
037A2:  MOVLB  0
037A4:  GOTO   2D1C
037A8:  MOVLB  1
....................    }
037AA:  MOVLB  0
037AC:  GOTO   6A92 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0071A:  MOVLB  5
0071C:  CLRF   xB9
0071E:  CLRF   xBA
00720:  CLRF   xBB
00722:  CLRF   xBC
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
00724:  CLRF   xBD
00726:  MOVF   xBD,W
00728:  SUBLW  03
0072A:  BNC   0758
....................    {
....................       switch (magPP)
....................       {         
....................          case 1:
....................             rc0=KMXP1000reg0config;
0072C:  MOVLW  38
0072E:  MOVWF  xB9
....................             rc1=KMXP1000reg1config;
00730:  MOVLW  10
00732:  MOVWF  xBA
....................             rc2=KMXP1000reg2config;
00734:  MOVLW  30
00736:  MOVWF  xBB
....................             rc3=KMXP1000reg3config;
00738:  CLRF   xBC
....................          break;
....................          
....................          case 2:
....................             rc0=KMXP2000reg0config;
....................             rc1=KMXP2000reg1config;
....................             rc2=KMXP2000reg2config;
....................             rc3=KMXP2000reg3config;
....................          break;
....................          
....................          default:
....................             rc0=reg0config;
....................             rc1=reg1config;
....................             rc2=reg2config;
....................             rc3=reg3config;      
....................          break;
....................       }
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
0073A:  MOVFF  5BD,5BE
0073E:  MOVFF  5B9,5BF
00742:  MOVFF  5BA,5C0
00746:  MOVFF  5BB,5C1
0074A:  MOVFF  5BC,5C2
0074E:  MOVLB  0
00750:  BRA    06B8
00752:  MOVLB  5
00754:  INCF   xBD,F
00756:  BRA    0726
....................    }   
00758:  MOVLB  0
0075A:  GOTO   07BE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0075E:  MOVLW  00
00760:  MOVLB  F
00762:  MOVWF  x53
00764:  MOVLW  40
00766:  MOVWF  x0C
00768:  MOVLW  00
0076A:  MOVWF  x14
0076C:  MOVLW  03
0076E:  MOVWF  x1C
00770:  MOVLW  0F
00772:  MOVWF  x21
00774:  MOVLW  00
00776:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00778:  MOVLW  08
0077A:  MOVWF  x55
0077C:  CLRF   x56
0077E:  CLRF   x52
00780:  SETF   x57
00782:  CLRF   F61
00784:  MOVLW  94
00786:  MOVWF  x5B
....................    output_high(EN_EXC);
00788:  MOVLW  E8
0078A:  MOVWF  F8B
0078C:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
0078E:  MOVF   x5A,W
00790:  ANDLW  3F
00792:  MOVWF  01
00794:  MOVLW  06
00796:  MOVWF  x5A
00798:  BTFSS  x5B.7
0079A:  BRA    07AA
0079C:  MOVF   01,W
0079E:  SUBLW  06
007A0:  BZ    07AA
007A2:  BSF    x5B.0
007A4:  NOP   
007A6:  BTFSC  x5B.0
007A8:  BRA    07A6
....................    delay_ms(10);
007AA:  MOVLW  0A
007AC:  MOVLB  5
007AE:  MOVWF  xBA
007B0:  MOVLB  0
007B2:  RCALL  03AC
....................    read_adc(ADC_START_ONLY);
007B4:  MOVLB  F
007B6:  BSF    x5B.0
007B8:  NOP   
....................    setup_external_ADCs();
007BA:  MOVLB  0
007BC:  BRA    071A
....................    intTimeoutReg = sensorSampleRate;
007BE:  MOVLB  1
007C0:  CLRF   x4E
007C2:  MOVLW  32
007C4:  MOVWF  x4D
007C6:  MOVLB  0
007C8:  GOTO   6A7E (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... //!#include <control.h>
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
007EE:  MOVLB  5
007F0:  MOVF   xBA,W
007F2:  SUBLW  03
007F4:  BTFSS  FD8.0
007F6:  BRA    0964
....................    {
....................       for (int i = 0; i <numParam; i ++)
007F8:  CLRF   xBB
007FA:  MOVF   xBB,W
007FC:  SUBLW  06
007FE:  BNC   084E
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00800:  CLRF   xDE
00802:  MOVFF  5BA,5DD
00806:  CLRF   xE0
00808:  MOVLW  B5
0080A:  MOVWF  xDF
0080C:  MOVLB  0
0080E:  RCALL  07CC
00810:  MOVFF  02,5BD
00814:  MOVFF  01,5BC
00818:  MOVLW  06
0081A:  MOVLB  5
0081C:  ADDWF  xBC,F
0081E:  MOVLW  00
00820:  ADDWFC xBD,F
00822:  CLRF   xDE
00824:  MOVFF  5BB,5DD
00828:  CLRF   xE0
0082A:  MOVLW  19
0082C:  MOVWF  xDF
0082E:  MOVLB  0
00830:  RCALL  07CC
00832:  MOVF   01,W
00834:  MOVLB  5
00836:  ADDWF  xBC,F
00838:  MOVF   02,W
0083A:  ADDWFC xBD,F
0083C:  MOVLW  52
0083E:  ADDWF  xBC,W
00840:  MOVWF  FE9
00842:  MOVLW  01
00844:  ADDWFC xBD,W
00846:  MOVWF  FEA
00848:  CLRF   FEF
0084A:  INCF   xBB,F
0084C:  BRA    07FA
....................       }
....................       SERcmd[recNum].t = 0;
0084E:  CLRF   xDE
00850:  MOVFF  5BA,5DD
00854:  CLRF   xE0
00856:  MOVLW  B5
00858:  MOVWF  xDF
0085A:  MOVLB  0
0085C:  RCALL  07CC
0085E:  MOVFF  01,5BC
00862:  MOVLW  05
00864:  MOVLB  5
00866:  ADDWF  01,W
00868:  MOVWF  01
0086A:  MOVLW  00
0086C:  ADDWFC 02,W
0086E:  MOVWF  03
00870:  MOVF   01,W
00872:  ADDLW  52
00874:  MOVWF  FE9
00876:  MOVLW  01
00878:  ADDWFC 03,W
0087A:  MOVWF  FEA
0087C:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
0087E:  CLRF   xDE
00880:  MOVFF  5BA,5DD
00884:  CLRF   xE0
00886:  MOVLW  B5
00888:  MOVWF  xDF
0088A:  MOVLB  0
0088C:  RCALL  07CC
0088E:  MOVFF  01,5BC
00892:  MOVLW  01
00894:  MOVLB  5
00896:  ADDWF  01,W
00898:  MOVWF  01
0089A:  MOVLW  00
0089C:  ADDWFC 02,W
0089E:  MOVWF  03
008A0:  MOVF   01,W
008A2:  ADDLW  52
008A4:  MOVWF  FE9
008A6:  MOVLW  01
008A8:  ADDWFC 03,W
008AA:  MOVWF  FEA
008AC:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
008AE:  CLRF   xDE
008B0:  MOVFF  5BA,5DD
008B4:  CLRF   xE0
008B6:  MOVLW  B5
008B8:  MOVWF  xDF
008BA:  MOVLB  0
008BC:  RCALL  07CC
008BE:  MOVFF  01,5BC
008C2:  MOVLW  02
008C4:  MOVLB  5
008C6:  ADDWF  01,W
008C8:  MOVWF  01
008CA:  MOVLW  00
008CC:  ADDWFC 02,W
008CE:  MOVWF  03
008D0:  MOVF   01,W
008D2:  ADDLW  52
008D4:  MOVWF  FE9
008D6:  MOVLW  01
008D8:  ADDWFC 03,W
008DA:  MOVWF  FEA
008DC:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
008DE:  CLRF   xDE
008E0:  MOVFF  5BA,5DD
008E4:  CLRF   xE0
008E6:  MOVLW  B5
008E8:  MOVWF  xDF
008EA:  MOVLB  0
008EC:  RCALL  07CC
008EE:  MOVFF  01,5BC
008F2:  MOVLW  03
008F4:  MOVLB  5
008F6:  ADDWF  01,W
008F8:  MOVWF  01
008FA:  MOVLW  00
008FC:  ADDWFC 02,W
008FE:  MOVWF  03
00900:  MOVF   01,W
00902:  ADDLW  52
00904:  MOVWF  FE9
00906:  MOVLW  01
00908:  ADDWFC 03,W
0090A:  MOVWF  FEA
0090C:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
0090E:  CLRF   xDE
00910:  MOVFF  5BA,5DD
00914:  CLRF   xE0
00916:  MOVLW  B5
00918:  MOVWF  xDF
0091A:  MOVLB  0
0091C:  RCALL  07CC
0091E:  MOVFF  01,5BC
00922:  MOVLW  04
00924:  MOVLB  5
00926:  ADDWF  01,W
00928:  MOVWF  01
0092A:  MOVLW  00
0092C:  ADDWFC 02,W
0092E:  MOVWF  03
00930:  MOVF   01,W
00932:  ADDLW  52
00934:  MOVWF  FE9
00936:  MOVLW  01
00938:  ADDWFC 03,W
0093A:  MOVWF  FEA
0093C:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
0093E:  CLRF   xDE
00940:  MOVFF  5BA,5DD
00944:  CLRF   xE0
00946:  MOVLW  B5
00948:  MOVWF  xDF
0094A:  MOVLB  0
0094C:  RCALL  07CC
0094E:  MOVLW  52
00950:  MOVLB  5
00952:  ADDWF  01,W
00954:  MOVWF  FE9
00956:  MOVLW  01
00958:  ADDWFC 02,W
0095A:  MOVWF  FEA
0095C:  BCF    FEF.0
....................       retData[0] = '\0';
0095E:  MOVLB  4
00960:  CLRF   x28
00962:  MOVLB  5
....................    }
00964:  MOVLB  0
00966:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
03D3A:  MOVLB  5
03D3C:  CLRF   xDE
03D3E:  MOVFF  426,5DD
03D42:  CLRF   xE0
03D44:  MOVLW  B5
03D46:  MOVWF  xDF
03D48:  MOVLB  0
03D4A:  CALL   07CC
03D4E:  MOVFF  02,5BB
03D52:  MOVFF  01,5BA
03D56:  MOVLW  52
03D58:  MOVLB  5
03D5A:  ADDWF  01,W
03D5C:  MOVWF  FE9
03D5E:  MOVLW  01
03D60:  ADDWFC 02,W
03D62:  MOVWF  FEA
03D64:  BTFSC  FEF.0
03D66:  BRA    3D88
....................    {
....................       if (SRI == SWI) return FALSE;
03D68:  MOVLB  4
03D6A:  MOVF   x27,W
03D6C:  SUBWF  x26,W
03D6E:  BNZ   3D76
03D70:  MOVLW  00
03D72:  MOVWF  01
03D74:  BRA    3D8E
....................       SRI +=1;
03D76:  MOVLW  01
03D78:  ADDWF  x26,F
....................       if (SRI >= numRecords) SRI=0;
03D7A:  MOVF   x26,W
03D7C:  SUBLW  03
03D7E:  BC    3D82
03D80:  CLRF   x26
03D82:  MOVLB  0
03D84:  BRA    3D3A
03D86:  MOVLB  5
....................    }
....................    return TRUE;
03D88:  MOVLW  01
03D8A:  MOVWF  01
03D8C:  MOVLB  4
03D8E:  MOVLB  0
03D90:  GOTO   668E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
037E4:  MOVLW  01
037E6:  MOVLB  4
037E8:  ADDWF  x27,F
....................    if (SWI >= numRecords) SWI=0;
037EA:  MOVF   x27,W
037EC:  SUBLW  03
037EE:  BC    37F2
037F0:  CLRF   x27
037F2:  MOVLB  0
037F4:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4CB
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xCB.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
037F6:  MOVLW  93
037F8:  MOVWF  F89
037FA:  BSF    F84.5
037FC:  MOVLB  E
037FE:  BTFSS  xC8.4
03800:  BRA    37FE
03802:  MOVLW  93
03804:  MOVWF  F89
03806:  BSF    F84.5
03808:  MOVLB  5
0380A:  MOVFF  5C0,F99
0380E:  NOP   
03810:  BTFSS  F9D.1
03812:  BRA    3810
03814:  MOVLW  93
03816:  MOVWF  F89
03818:  BCF    F84.5
0381A:  MOVLB  0
0381C:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xC8,W
000F6:  ADDLW  8C
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,627
00104:  MOVFF  FE9,626
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  627,FEA
00110:  MOVFF  626,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xC8,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xC8,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xC8
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xCA.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
037B0:  CLRF   03
037B2:  MOVLB  4
037B4:  MOVF   xC9,W
037B6:  ADDLW  8C
037B8:  MOVWF  FE9
037BA:  MOVLW  04
037BC:  ADDWFC 03,W
037BE:  MOVWF  FEA
037C0:  MOVFF  FEF,5BA
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
037C4:  MOVLW  01
037C6:  ADDWF  xC9,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
037C8:  MOVF   xC9,W
037CA:  SUBLW  3B
037CC:  BC    37D0
037CE:  CLRF   xC9
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
037D0:  MOVF   xC8,W
037D2:  SUBWF  xC9,W
037D4:  BNZ   37D8
037D6:  BCF    xCA.0
....................    return data;
037D8:  MOVLB  5
037DA:  MOVFF  5BA,01
037DE:  MOVLB  0
037E0:  GOTO   3884 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
03842:  MOVLB  4
03844:  BTFSS  xCA.0
03846:  BRA    3D34
03848:  MOVLB  5
0384A:  CLRF   xDE
0384C:  MOVFF  427,5DD
03850:  CLRF   xE0
03852:  MOVLW  B5
03854:  MOVWF  xDF
03856:  MOVLB  0
03858:  CALL   07CC
0385C:  MOVFF  02,5BB
03860:  MOVFF  01,5BA
03864:  MOVLW  52
03866:  MOVLB  5
03868:  ADDWF  01,W
0386A:  MOVWF  01
0386C:  MOVLW  01
0386E:  ADDWFC 02,W
03870:  MOVWF  03
03872:  MOVFF  01,FE9
03876:  MOVWF  FEA
03878:  BTFSS  FEF.0
0387A:  BRA    3880
0387C:  MOVLB  4
0387E:  BRA    3D34
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
03880:  MOVLB  0
03882:  BRA    37B0
03884:  MOVFF  01,5B9
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
03888:  MOVLB  5
0388A:  MOVF   xB9,W
0388C:  SUBLW  0D
0388E:  BZ    3896
03890:  MOVF   xB9,W
03892:  SUBLW  20
03894:  BNZ   3898
....................       {
....................       }
03896:  BRA    3D2E
....................       else if (rxChar == UART_SOT_CHAR)
03898:  MOVF   xB9,W
0389A:  SUBLW  7E
0389C:  BNZ   38E0
....................       {
....................          resetSERcmd(SWI);
0389E:  MOVFF  427,5BA
038A2:  MOVLB  0
038A4:  CALL   07EE
....................          SERcmd[SWI].t = rxChar;
038A8:  MOVLB  5
038AA:  CLRF   xDE
038AC:  MOVFF  427,5DD
038B0:  CLRF   xE0
038B2:  MOVLW  B5
038B4:  MOVWF  xDF
038B6:  MOVLB  0
038B8:  CALL   07CC
038BC:  MOVFF  01,5BA
038C0:  MOVLW  05
038C2:  MOVLB  5
038C4:  ADDWF  01,W
038C6:  MOVWF  01
038C8:  MOVLW  00
038CA:  ADDWFC 02,W
038CC:  MOVWF  03
038CE:  MOVF   01,W
038D0:  ADDLW  52
038D2:  MOVWF  FE9
038D4:  MOVLW  01
038D6:  ADDWFC 03,W
038D8:  MOVWF  FEA
038DA:  MOVFF  5B9,FEF
....................       }
038DE:  BRA    3D2E
....................       else if (rxChar >= oneByteCmdTestValue)
038E0:  MOVF   xB9,W
038E2:  SUBLW  7F
038E4:  BC    3950
....................       {
....................          resetSERcmd(SWI);
038E6:  MOVFF  427,5BA
038EA:  MOVLB  0
038EC:  CALL   07EE
....................          SERcmd[SWI].t = rxChar;
038F0:  MOVLB  5
038F2:  CLRF   xDE
038F4:  MOVFF  427,5DD
038F8:  CLRF   xE0
038FA:  MOVLW  B5
038FC:  MOVWF  xDF
038FE:  MOVLB  0
03900:  CALL   07CC
03904:  MOVFF  01,5BA
03908:  MOVLW  05
0390A:  MOVLB  5
0390C:  ADDWF  01,W
0390E:  MOVWF  01
03910:  MOVLW  00
03912:  ADDWFC 02,W
03914:  MOVWF  03
03916:  MOVF   01,W
03918:  ADDLW  52
0391A:  MOVWF  FE9
0391C:  MOVLW  01
0391E:  ADDWFC 03,W
03920:  MOVWF  FEA
03922:  MOVFF  5B9,FEF
....................          SERcmd[SWI].full = TRUE;
03926:  CLRF   xDE
03928:  MOVFF  427,5DD
0392C:  CLRF   xE0
0392E:  MOVLW  B5
03930:  MOVWF  xDF
03932:  MOVLB  0
03934:  CALL   07CC
03938:  MOVLW  52
0393A:  MOVLB  5
0393C:  ADDWF  01,W
0393E:  MOVWF  FE9
03940:  MOVLW  01
03942:  ADDWFC 02,W
03944:  MOVWF  FEA
03946:  BSF    FEF.0
....................          setNextSERWriteIndex();
03948:  MOVLB  0
0394A:  RCALL  37E4
....................       }
0394C:  BRA    3D2C
0394E:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
03950:  MOVF   xB9,W
03952:  SUBLW  0A
03954:  BTFSS  FD8.2
03956:  BRA    3A5C
....................       {
....................          SERcmd[SWI].full = TRUE;
03958:  CLRF   xDE
0395A:  MOVFF  427,5DD
0395E:  CLRF   xE0
03960:  MOVLW  B5
03962:  MOVWF  xDF
03964:  MOVLB  0
03966:  CALL   07CC
0396A:  MOVLW  52
0396C:  MOVLB  5
0396E:  ADDWF  01,W
03970:  MOVWF  FE9
03972:  MOVLW  01
03974:  ADDWFC 02,W
03976:  MOVWF  FEA
03978:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
0397A:  CLRF   xDE
0397C:  MOVFF  427,5DD
03980:  CLRF   xE0
03982:  MOVLW  B5
03984:  MOVWF  xDF
03986:  MOVLB  0
03988:  CALL   07CC
0398C:  MOVFF  01,5BA
03990:  MOVLW  04
03992:  MOVLB  5
03994:  ADDWF  01,W
03996:  MOVWF  01
03998:  MOVLW  00
0399A:  ADDWFC 02,W
0399C:  MOVWF  03
0399E:  MOVF   01,W
039A0:  ADDLW  52
039A2:  MOVWF  01
039A4:  MOVLW  01
039A6:  ADDWFC 03,F
039A8:  MOVFF  01,5BA
039AC:  MOVFF  03,5BB
039B0:  CLRF   xDE
039B2:  MOVFF  427,5DD
039B6:  CLRF   xE0
039B8:  MOVLW  B5
039BA:  MOVWF  xDF
039BC:  MOVLB  0
039BE:  CALL   07CC
039C2:  MOVFF  01,5BC
039C6:  MOVLW  02
039C8:  MOVLB  5
039CA:  ADDWF  01,W
039CC:  MOVWF  01
039CE:  MOVLW  00
039D0:  ADDWFC 02,W
039D2:  MOVWF  03
039D4:  MOVF   01,W
039D6:  ADDLW  52
039D8:  MOVWF  FE9
039DA:  MOVLW  01
039DC:  ADDWFC 03,W
039DE:  MOVWF  FEA
039E0:  MOVFF  FEF,5BC
039E4:  MOVFF  5BB,FEA
039E8:  MOVFF  5BA,FE9
039EC:  MOVFF  5BC,FEF
....................          SERcmd[SWI].chrIndex = 0;
039F0:  CLRF   xDE
039F2:  MOVFF  427,5DD
039F6:  CLRF   xE0
039F8:  MOVLW  B5
039FA:  MOVWF  xDF
039FC:  MOVLB  0
039FE:  CALL   07CC
03A02:  MOVFF  01,5BA
03A06:  MOVLW  01
03A08:  MOVLB  5
03A0A:  ADDWF  01,W
03A0C:  MOVWF  01
03A0E:  MOVLW  00
03A10:  ADDWFC 02,W
03A12:  MOVWF  03
03A14:  MOVF   01,W
03A16:  ADDLW  52
03A18:  MOVWF  FE9
03A1A:  MOVLW  01
03A1C:  ADDWFC 03,W
03A1E:  MOVWF  FEA
03A20:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
03A22:  CLRF   xDE
03A24:  MOVFF  427,5DD
03A28:  CLRF   xE0
03A2A:  MOVLW  B5
03A2C:  MOVWF  xDF
03A2E:  MOVLB  0
03A30:  CALL   07CC
03A34:  MOVFF  01,5BA
03A38:  MOVLW  02
03A3A:  MOVLB  5
03A3C:  ADDWF  01,W
03A3E:  MOVWF  01
03A40:  MOVLW  00
03A42:  ADDWFC 02,W
03A44:  MOVWF  03
03A46:  MOVF   01,W
03A48:  ADDLW  52
03A4A:  MOVWF  FE9
03A4C:  MOVLW  01
03A4E:  ADDWFC 03,W
03A50:  MOVWF  FEA
03A52:  CLRF   FEF
....................          setNextSERWriteIndex();
03A54:  MOVLB  0
03A56:  RCALL  37E4
....................       }
03A58:  BRA    3D2C
03A5A:  MOVLB  5
....................       else if (rxChar == delimiter)
03A5C:  MOVF   xB9,W
03A5E:  SUBLW  2C
03A60:  BNZ   3B1E
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
03A62:  CLRF   xDE
03A64:  MOVFF  427,5DD
03A68:  CLRF   xE0
03A6A:  MOVLW  B5
03A6C:  MOVWF  xDF
03A6E:  MOVLB  0
03A70:  CALL   07CC
03A74:  MOVFF  02,5BB
03A78:  MOVFF  01,5BA
03A7C:  MOVLW  02
03A7E:  MOVLB  5
03A80:  ADDWF  01,W
03A82:  MOVWF  01
03A84:  MOVLW  00
03A86:  ADDWFC 02,W
03A88:  MOVWF  03
03A8A:  MOVF   01,W
03A8C:  ADDLW  52
03A8E:  MOVWF  FE9
03A90:  MOVLW  01
03A92:  ADDWFC 03,W
03A94:  MOVWF  FEA
03A96:  MOVF   FEF,W
03A98:  SUBLW  05
03A9A:  BNC   3B06
....................          {
....................             SERcmd[SWI].paramIndex +=1;
03A9C:  CLRF   xDE
03A9E:  MOVFF  427,5DD
03AA2:  CLRF   xE0
03AA4:  MOVLW  B5
03AA6:  MOVWF  xDF
03AA8:  MOVLB  0
03AAA:  CALL   07CC
03AAE:  MOVFF  01,5BA
03AB2:  MOVLW  02
03AB4:  MOVLB  5
03AB6:  ADDWF  01,W
03AB8:  MOVWF  01
03ABA:  MOVLW  00
03ABC:  ADDWFC 02,W
03ABE:  MOVWF  03
03AC0:  MOVF   01,W
03AC2:  ADDLW  52
03AC4:  MOVWF  FE9
03AC6:  MOVLW  01
03AC8:  ADDWFC 03,W
03ACA:  MOVWF  FEA
03ACC:  MOVLW  01
03ACE:  ADDWF  FEF,W
03AD0:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
03AD2:  CLRF   xDE
03AD4:  MOVFF  427,5DD
03AD8:  CLRF   xE0
03ADA:  MOVLW  B5
03ADC:  MOVWF  xDF
03ADE:  MOVLB  0
03AE0:  CALL   07CC
03AE4:  MOVFF  01,5BA
03AE8:  MOVLW  01
03AEA:  MOVLB  5
03AEC:  ADDWF  01,W
03AEE:  MOVWF  01
03AF0:  MOVLW  00
03AF2:  ADDWFC 02,W
03AF4:  MOVWF  03
03AF6:  MOVF   01,W
03AF8:  ADDLW  52
03AFA:  MOVWF  FE9
03AFC:  MOVLW  01
03AFE:  ADDWFC 03,W
03B00:  MOVWF  FEA
03B02:  CLRF   FEF
....................          }
03B04:  BRA    3B1C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
03B06:  MOVFF  427,5BA
03B0A:  MOVLB  0
03B0C:  CALL   07EE
....................             fprintf(SERIAL, retData);
03B10:  MOVLW  04
03B12:  MOVWF  FEA
03B14:  MOVLW  28
03B16:  MOVWF  FE9
03B18:  RCALL  381E
03B1A:  MOVLB  5
....................          }
....................       }
03B1C:  BRA    3D2E
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
03B1E:  CLRF   xDE
03B20:  MOVFF  427,5DD
03B24:  CLRF   xE0
03B26:  MOVLW  B5
03B28:  MOVWF  xDF
03B2A:  MOVLB  0
03B2C:  CALL   07CC
03B30:  MOVFF  02,5BB
03B34:  MOVFF  01,5BA
03B38:  MOVLW  01
03B3A:  MOVLB  5
03B3C:  ADDWF  01,W
03B3E:  MOVWF  01
03B40:  MOVLW  00
03B42:  ADDWFC 02,W
03B44:  MOVWF  03
03B46:  MOVF   01,W
03B48:  ADDLW  52
03B4A:  MOVWF  FE9
03B4C:  MOVLW  01
03B4E:  ADDWFC 03,W
03B50:  MOVWF  FEA
03B52:  MOVF   FEF,W
03B54:  SUBLW  18
03B56:  BTFSS  FD8.0
03B58:  BRA    3D18
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
03B5A:  CLRF   xDE
03B5C:  MOVFF  427,5DD
03B60:  CLRF   xE0
03B62:  MOVLW  B5
03B64:  MOVWF  xDF
03B66:  MOVLB  0
03B68:  CALL   07CC
03B6C:  MOVFF  02,5BB
03B70:  MOVFF  01,5BA
03B74:  MOVLW  06
03B76:  MOVLB  5
03B78:  ADDWF  xBA,F
03B7A:  MOVLW  00
03B7C:  ADDWFC xBB,F
03B7E:  CLRF   xDE
03B80:  MOVFF  427,5DD
03B84:  CLRF   xE0
03B86:  MOVLW  B5
03B88:  MOVWF  xDF
03B8A:  MOVLB  0
03B8C:  CALL   07CC
03B90:  MOVFF  02,5BD
03B94:  MOVFF  01,5BC
03B98:  MOVLW  02
03B9A:  MOVLB  5
03B9C:  ADDWF  01,W
03B9E:  MOVWF  01
03BA0:  MOVLW  00
03BA2:  ADDWFC 02,W
03BA4:  MOVWF  03
03BA6:  MOVF   01,W
03BA8:  ADDLW  52
03BAA:  MOVWF  FE9
03BAC:  MOVLW  01
03BAE:  ADDWFC 03,W
03BB0:  MOVWF  FEA
03BB2:  CLRF   xDE
03BB4:  MOVFF  FEF,5DD
03BB8:  CLRF   xE0
03BBA:  MOVLW  19
03BBC:  MOVWF  xDF
03BBE:  MOVLB  0
03BC0:  CALL   07CC
03BC4:  MOVFF  02,03
03BC8:  MOVF   01,W
03BCA:  MOVLB  5
03BCC:  ADDWF  xBA,F
03BCE:  MOVF   02,W
03BD0:  ADDWFC xBB,F
03BD2:  CLRF   xDE
03BD4:  MOVFF  427,5DD
03BD8:  CLRF   xE0
03BDA:  MOVLW  B5
03BDC:  MOVWF  xDF
03BDE:  MOVLB  0
03BE0:  CALL   07CC
03BE4:  MOVFF  01,5BC
03BE8:  MOVLW  01
03BEA:  MOVLB  5
03BEC:  ADDWF  01,W
03BEE:  MOVWF  01
03BF0:  MOVLW  00
03BF2:  ADDWFC 02,W
03BF4:  MOVWF  03
03BF6:  MOVF   01,W
03BF8:  ADDLW  52
03BFA:  MOVWF  FE9
03BFC:  MOVLW  01
03BFE:  ADDWFC 03,W
03C00:  MOVWF  FEA
03C02:  MOVF   FEF,W
03C04:  ADDWF  xBA,W
03C06:  MOVWF  01
03C08:  MOVLW  00
03C0A:  ADDWFC xBB,W
03C0C:  MOVWF  03
03C0E:  MOVF   01,W
03C10:  ADDLW  52
03C12:  MOVWF  FE9
03C14:  MOVLW  01
03C16:  ADDWFC 03,W
03C18:  MOVWF  FEA
03C1A:  MOVFF  5B9,FEF
....................             SERcmd[SWI].chrIndex += 1;
03C1E:  CLRF   xDE
03C20:  MOVFF  427,5DD
03C24:  CLRF   xE0
03C26:  MOVLW  B5
03C28:  MOVWF  xDF
03C2A:  MOVLB  0
03C2C:  CALL   07CC
03C30:  MOVFF  01,5BA
03C34:  MOVLW  01
03C36:  MOVLB  5
03C38:  ADDWF  01,W
03C3A:  MOVWF  01
03C3C:  MOVLW  00
03C3E:  ADDWFC 02,W
03C40:  MOVWF  03
03C42:  MOVF   01,W
03C44:  ADDLW  52
03C46:  MOVWF  FE9
03C48:  MOVLW  01
03C4A:  ADDWFC 03,W
03C4C:  MOVWF  FEA
03C4E:  MOVLW  01
03C50:  ADDWF  FEF,W
03C52:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
03C54:  CLRF   xDE
03C56:  MOVFF  427,5DD
03C5A:  CLRF   xE0
03C5C:  MOVLW  B5
03C5E:  MOVWF  xDF
03C60:  MOVLB  0
03C62:  CALL   07CC
03C66:  MOVFF  02,5BB
03C6A:  MOVFF  01,5BA
03C6E:  MOVLW  06
03C70:  MOVLB  5
03C72:  ADDWF  xBA,F
03C74:  MOVLW  00
03C76:  ADDWFC xBB,F
03C78:  CLRF   xDE
03C7A:  MOVFF  427,5DD
03C7E:  CLRF   xE0
03C80:  MOVLW  B5
03C82:  MOVWF  xDF
03C84:  MOVLB  0
03C86:  CALL   07CC
03C8A:  MOVFF  02,5BD
03C8E:  MOVFF  01,5BC
03C92:  MOVLW  02
03C94:  MOVLB  5
03C96:  ADDWF  01,W
03C98:  MOVWF  01
03C9A:  MOVLW  00
03C9C:  ADDWFC 02,W
03C9E:  MOVWF  03
03CA0:  MOVF   01,W
03CA2:  ADDLW  52
03CA4:  MOVWF  FE9
03CA6:  MOVLW  01
03CA8:  ADDWFC 03,W
03CAA:  MOVWF  FEA
03CAC:  CLRF   xDE
03CAE:  MOVFF  FEF,5DD
03CB2:  CLRF   xE0
03CB4:  MOVLW  19
03CB6:  MOVWF  xDF
03CB8:  MOVLB  0
03CBA:  CALL   07CC
03CBE:  MOVFF  02,03
03CC2:  MOVF   01,W
03CC4:  MOVLB  5
03CC6:  ADDWF  xBA,F
03CC8:  MOVF   02,W
03CCA:  ADDWFC xBB,F
03CCC:  CLRF   xDE
03CCE:  MOVFF  427,5DD
03CD2:  CLRF   xE0
03CD4:  MOVLW  B5
03CD6:  MOVWF  xDF
03CD8:  MOVLB  0
03CDA:  CALL   07CC
03CDE:  MOVFF  01,5BC
03CE2:  MOVLW  01
03CE4:  MOVLB  5
03CE6:  ADDWF  01,W
03CE8:  MOVWF  01
03CEA:  MOVLW  00
03CEC:  ADDWFC 02,W
03CEE:  MOVWF  03
03CF0:  MOVF   01,W
03CF2:  ADDLW  52
03CF4:  MOVWF  FE9
03CF6:  MOVLW  01
03CF8:  ADDWFC 03,W
03CFA:  MOVWF  FEA
03CFC:  MOVF   FEF,W
03CFE:  ADDWF  xBA,W
03D00:  MOVWF  01
03D02:  MOVLW  00
03D04:  ADDWFC xBB,W
03D06:  MOVWF  03
03D08:  MOVF   01,W
03D0A:  ADDLW  52
03D0C:  MOVWF  FE9
03D0E:  MOVLW  01
03D10:  ADDWFC 03,W
03D12:  MOVWF  FEA
03D14:  CLRF   FEF
....................          }
03D16:  BRA    3D2E
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
03D18:  MOVFF  427,5BA
03D1C:  MOVLB  0
03D1E:  CALL   07EE
....................             fprintf(SERIAL, retData);
03D22:  MOVLW  04
03D24:  MOVWF  FEA
03D26:  MOVLW  28
03D28:  MOVWF  FE9
03D2A:  RCALL  381E
03D2C:  MOVLB  5
....................          }
....................       }
03D2E:  MOVLB  0
03D30:  BRA    3842
03D32:  MOVLB  4
....................    }          
03D34:  MOVLB  0
03D36:  GOTO   6A96 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00968:  MOVLB  5
0096A:  CLRF   xB9
0096C:  MOVF   xB9,W
0096E:  SUBLW  03
00970:  BNC   0980
....................    {
....................       resetSERcmd(i);
00972:  MOVFF  5B9,5BA
00976:  MOVLB  0
00978:  RCALL  07EE
0097A:  MOVLB  5
0097C:  INCF   xB9,F
0097E:  BRA    096C
....................    }
....................    enable_interrupts(INT_RDA);
00980:  MOVLB  E
00982:  BSF    xC0.5
00984:  MOVLB  0
00986:  GOTO   6A82 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... //!#include <pid.h>
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
0098A:  MOVLB  E
0098C:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
0098E:  MOVLW  01
00990:  MOVWF  FD1
00992:  MOVLW  07
00994:  MOVWF  FCE
00996:  CLRF   FCF
00998:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
0099A:  MOVLB  1
0099C:  CLRF   x44
0099E:  CLRF   x43
009A0:  CLRF   x42
009A2:  CLRF   x41
....................    timeoutReg1 = 0;
009A4:  CLRF   x48
009A6:  CLRF   x47
009A8:  CLRF   x46
009AA:  CLRF   x45
....................    timeoutReg2 = 0;
009AC:  CLRF   x4C
009AE:  CLRF   x4B
009B0:  CLRF   x4A
009B2:  CLRF   x49
....................    intTimeoutReg = 50;
009B4:  CLRF   x4E
009B6:  MOVLW  32
009B8:  MOVWF  x4D
....................    enable_interrupts(INT_TIMER1);
009BA:  MOVLB  E
009BC:  BSF    xC1.0
009BE:  MOVLB  0
009C0:  GOTO   6A86 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0021E:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00220:  MOVLW  0B
00222:  MOVWF  FCD
00224:  MOVLW  DB
00226:  MOVWF  FCC
00228:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0022A:  MOVLB  1
0022C:  MOVF   x44,F
0022E:  BNZ   023E
00230:  MOVF   x43,F
00232:  BNZ   023E
00234:  MOVF   x42,F
00236:  BNZ   023E
00238:  MOVF   x41,W
0023A:  SUBLW  0A
0023C:  BC    024C
0023E:  MOVLW  0A
00240:  SUBWF  x41,F
00242:  MOVLW  00
00244:  SUBWFB x42,F
00246:  SUBWFB x43,F
00248:  SUBWFB x44,F
0024A:  BRA    0254
0024C:  CLRF   x44
0024E:  CLRF   x43
00250:  CLRF   x42
00252:  CLRF   x41
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00254:  MOVF   x48,F
00256:  BNZ   0266
00258:  MOVF   x47,F
0025A:  BNZ   0266
0025C:  MOVF   x46,F
0025E:  BNZ   0266
00260:  MOVF   x45,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x45,F
0026A:  MOVLW  00
0026C:  SUBWFB x46,F
0026E:  SUBWFB x47,F
00270:  SUBWFB x48,F
00272:  BRA    027C
00274:  CLRF   x48
00276:  CLRF   x47
00278:  CLRF   x46
0027A:  CLRF   x45
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
0027C:  MOVF   x4C,F
0027E:  BNZ   028E
00280:  MOVF   x4B,F
00282:  BNZ   028E
00284:  MOVF   x4A,F
00286:  BNZ   028E
00288:  MOVF   x49,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x49,F
00292:  MOVLW  00
00294:  SUBWFB x4A,F
00296:  SUBWFB x4B,F
00298:  SUBWFB x4C,F
0029A:  BRA    02A4
0029C:  CLRF   x4C
0029E:  CLRF   x4B
002A0:  CLRF   x4A
002A2:  CLRF   x49
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002A4:  MOVF   x4D,F
002A6:  BNZ   02AC
002A8:  MOVF   x4E,F
002AA:  BZ    02E8
....................    {
....................       timeCounter+=10;
002AC:  MOVLW  0A
002AE:  MOVLB  4
002B0:  ADDWF  xCE,F
002B2:  MOVLW  00
002B4:  ADDWFC xCF,F
002B6:  ADDWFC xD0,F
002B8:  ADDWFC xD1,F
....................       if (timeCounter >= intTimeoutReg)
002BA:  MOVF   xD1,F
002BC:  BNZ   02D8
002BE:  MOVF   xD0,F
002C0:  BNZ   02D8
002C2:  MOVLB  1
002C4:  MOVF   x4E,W
002C6:  MOVLB  4
002C8:  SUBWF  xCF,W
002CA:  BNC   02E6
002CC:  BNZ   02D8
002CE:  MOVLB  1
002D0:  MOVF   x4D,W
002D2:  MOVLB  4
002D4:  SUBWF  xCE,W
002D6:  BNC   02E6
....................       {
....................          sensor_monitor_interrupt_task();
002D8:  MOVLB  0
002DA:  BRA    01E0
....................          timeCounter = 0;
002DC:  MOVLB  4
002DE:  CLRF   xD1
002E0:  CLRF   xD0
002E2:  CLRF   xCF
002E4:  CLRF   xCE
002E6:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {VOLTAGE, MAGSENS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MAGSENS, MAGSENS};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
002E8:  MOVLB  E
002EA:  BCF    xC9.0
002EC:  MOVLB  0
002EE:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... #define NUM_COMMANDS 18
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {VOLTAGE|MAGSENS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|volts|position|all}
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[NUM_COMMANDS] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
03EBE:  MOVLW  04
03EC0:  MOVLB  5
03EC2:  MOVWF  xE2
03EC4:  MOVLW  28
03EC6:  MOVWF  xE1
03EC8:  MOVLB  0
03ECA:  RCALL  3E46
03ECC:  MOVFF  02,03
03ED0:  MOVF   01,W
03ED2:  ADDLW  28
03ED4:  MOVLB  5
03ED6:  MOVWF  xC5
03ED8:  MOVLW  04
03EDA:  ADDWFC 02,W
03EDC:  MOVWF  xC6
03EDE:  MOVFF  FE8,4CD
03EE2:  MOVFF  5C5,4CC
03EE6:  MOVLW  F2
03EE8:  MOVWF  FF6
03EEA:  MOVLW  02
03EEC:  MOVWF  FF7
03EEE:  MOVLB  0
03EF0:  RCALL  3E9E
03EF2:  MOVLW  2C
03EF4:  MOVLB  5
03EF6:  MOVWF  xDD
03EF8:  MOVLB  0
03EFA:  RCALL  3E7E
....................    return SUCCESS;
03EFC:  MOVLW  00
03EFE:  MOVWF  01
03F00:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
03F02:  MOVLW  04
03F04:  MOVLB  5
03F06:  MOVWF  xE2
03F08:  MOVLW  28
03F0A:  MOVWF  xE1
03F0C:  MOVLB  0
03F0E:  RCALL  3E46
03F10:  MOVFF  02,03
03F14:  MOVF   01,W
03F16:  ADDLW  28
03F18:  MOVLB  5
03F1A:  MOVWF  xC5
03F1C:  MOVLW  04
03F1E:  ADDWFC 02,W
03F20:  MOVWF  xC6
03F22:  MOVFF  FE8,4CD
03F26:  MOVFF  5C5,4CC
03F2A:  MOVLW  FC
03F2C:  MOVWF  FF6
03F2E:  MOVLW  02
03F30:  MOVWF  FF7
03F32:  MOVLB  0
03F34:  RCALL  3E9E
03F36:  MOVLW  2C
03F38:  MOVLB  5
03F3A:  MOVWF  xDD
03F3C:  MOVLB  0
03F3E:  RCALL  3E7E
....................    return SUCCESS;
03F40:  MOVLW  00
03F42:  MOVWF  01
03F44:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
043D0:  MOVLB  5
043D2:  CLRF   xDE
043D4:  MOVFF  5B8,5DD
043D8:  CLRF   xE0
043DA:  MOVLW  B5
043DC:  MOVWF  xDF
043DE:  MOVLB  0
043E0:  CALL   07CC
043E4:  MOVFF  02,5C7
043E8:  MOVFF  01,5C6
043EC:  MOVLW  06
043EE:  MOVLB  5
043F0:  ADDWF  xC6,F
043F2:  MOVLW  00
043F4:  ADDWFC xC7,F
043F6:  MOVLW  32
043F8:  ADDWF  xC6,W
043FA:  MOVWF  01
043FC:  MOVLW  00
043FE:  ADDWFC xC7,W
04400:  MOVWF  03
04402:  MOVF   01,W
04404:  ADDLW  52
04406:  MOVWF  01
04408:  MOVLW  01
0440A:  ADDWFC 03,F
0440C:  MOVFF  01,5C6
04410:  MOVFF  03,5C7
04414:  MOVFF  03,5E0
04418:  MOVFF  01,5DF
0441C:  MOVLB  0
0441E:  RCALL  3F46
04420:  MOVF   01,F
04422:  BNZ   442C
04424:  MOVLW  02
04426:  MOVWF  01
04428:  BRA    4536
0442A:  BRA    4488
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0442C:  MOVLB  5
0442E:  CLRF   xDE
04430:  MOVFF  5B8,5DD
04434:  CLRF   xE0
04436:  MOVLW  B5
04438:  MOVWF  xDF
0443A:  MOVLB  0
0443C:  CALL   07CC
04440:  MOVFF  02,5C7
04444:  MOVFF  01,5C6
04448:  MOVLW  06
0444A:  MOVLB  5
0444C:  ADDWF  xC6,F
0444E:  MOVLW  00
04450:  ADDWFC xC7,F
04452:  MOVLW  32
04454:  ADDWF  xC6,W
04456:  MOVWF  01
04458:  MOVLW  00
0445A:  ADDWFC xC7,W
0445C:  MOVWF  03
0445E:  MOVF   01,W
04460:  ADDLW  52
04462:  MOVWF  01
04464:  MOVLW  01
04466:  ADDWFC 03,F
04468:  MOVFF  01,5C6
0446C:  MOVFF  03,5C7
04470:  MOVFF  03,5E0
04474:  MOVFF  01,5DF
04478:  CLRF   xE2
0447A:  CLRF   xE1
0447C:  MOVLW  0A
0447E:  MOVWF  xE3
04480:  MOVLB  0
04482:  RCALL  4036
04484:  MOVFF  01,5C5
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'X');
04488:  MOVLW  01
0448A:  MOVLB  5
0448C:  SUBWF  xC5,W
0448E:  MOVWF  xC7
04490:  CLRF   xC9
04492:  MOVLW  60
04494:  MOVWF  xC8
04496:  MOVLB  0
04498:  RCALL  439A
0449A:  BTFSC  01.0
0449C:  BRA    44DA
0449E:  MOVLW  04
044A0:  MOVLB  5
044A2:  MOVWF  xE2
044A4:  MOVLW  28
044A6:  MOVWF  xE1
044A8:  MOVLB  0
044AA:  RCALL  3E46
044AC:  MOVFF  02,03
044B0:  MOVF   01,W
044B2:  ADDLW  28
044B4:  MOVLB  5
044B6:  MOVWF  xC6
044B8:  MOVLW  04
044BA:  ADDWFC 02,W
044BC:  MOVWF  xC7
044BE:  MOVFF  FE8,4CD
044C2:  MOVFF  5C6,4CC
044C6:  MOVLW  58
044C8:  MOVWF  xDD
044CA:  MOVLB  0
044CC:  RCALL  3E7E
044CE:  MOVLW  2C
044D0:  MOVLB  5
044D2:  MOVWF  xDD
044D4:  MOVLB  0
044D6:  RCALL  3E7E
044D8:  BRA    4532
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'Y');
044DA:  MOVLW  01
044DC:  MOVLB  5
044DE:  SUBWF  xC5,W
044E0:  MOVWF  xC7
044E2:  CLRF   xC9
044E4:  MOVLW  60
044E6:  MOVWF  xC8
044E8:  MOVLB  0
044EA:  RCALL  439A
044EC:  BTFSS  01.0
044EE:  BRA    452C
044F0:  MOVLW  04
044F2:  MOVLB  5
044F4:  MOVWF  xE2
044F6:  MOVLW  28
044F8:  MOVWF  xE1
044FA:  MOVLB  0
044FC:  RCALL  3E46
044FE:  MOVFF  02,03
04502:  MOVF   01,W
04504:  ADDLW  28
04506:  MOVLB  5
04508:  MOVWF  xC6
0450A:  MOVLW  04
0450C:  ADDWFC 02,W
0450E:  MOVWF  xC7
04510:  MOVFF  FE8,4CD
04514:  MOVFF  5C6,4CC
04518:  MOVLW  59
0451A:  MOVWF  xDD
0451C:  MOVLB  0
0451E:  RCALL  3E7E
04520:  MOVLW  2C
04522:  MOVLB  5
04524:  MOVWF  xDD
04526:  MOVLB  0
04528:  RCALL  3E7E
0452A:  BRA    4532
....................    else return INV_PARAM;
0452C:  MOVLW  02
0452E:  MOVWF  01
04530:  BRA    4536
....................    
....................    return SUCCESS;
04532:  MOVLW  00
04534:  MOVWF  01
04536:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0457A:  MOVLB  5
0457C:  CLRF   xDE
0457E:  MOVFF  5B8,5DD
04582:  CLRF   xE0
04584:  MOVLW  B5
04586:  MOVWF  xDF
04588:  MOVLB  0
0458A:  CALL   07CC
0458E:  MOVFF  02,5C8
04592:  MOVFF  01,5C7
04596:  MOVLW  06
04598:  MOVLB  5
0459A:  ADDWF  xC7,F
0459C:  MOVLW  00
0459E:  ADDWFC xC8,F
045A0:  MOVLW  32
045A2:  ADDWF  xC7,W
045A4:  MOVWF  01
045A6:  MOVLW  00
045A8:  ADDWFC xC8,W
045AA:  MOVWF  03
045AC:  MOVF   01,W
045AE:  ADDLW  52
045B0:  MOVWF  01
045B2:  MOVLW  01
045B4:  ADDWFC 03,F
045B6:  MOVFF  01,5C7
045BA:  MOVFF  03,5C8
045BE:  MOVFF  03,5E0
045C2:  MOVFF  01,5DF
045C6:  MOVLB  0
045C8:  RCALL  3F46
045CA:  MOVF   01,F
045CC:  BNZ   45D6
045CE:  MOVLW  02
045D0:  MOVWF  01
045D2:  BRA    4728
045D4:  BRA    4632
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
045D6:  MOVLB  5
045D8:  CLRF   xDE
045DA:  MOVFF  5B8,5DD
045DE:  CLRF   xE0
045E0:  MOVLW  B5
045E2:  MOVWF  xDF
045E4:  MOVLB  0
045E6:  CALL   07CC
045EA:  MOVFF  02,5C8
045EE:  MOVFF  01,5C7
045F2:  MOVLW  06
045F4:  MOVLB  5
045F6:  ADDWF  xC7,F
045F8:  MOVLW  00
045FA:  ADDWFC xC8,F
045FC:  MOVLW  32
045FE:  ADDWF  xC7,W
04600:  MOVWF  01
04602:  MOVLW  00
04604:  ADDWFC xC8,W
04606:  MOVWF  03
04608:  MOVF   01,W
0460A:  ADDLW  52
0460C:  MOVWF  01
0460E:  MOVLW  01
04610:  ADDWFC 03,F
04612:  MOVFF  01,5C7
04616:  MOVFF  03,5C8
0461A:  MOVFF  03,5E0
0461E:  MOVFF  01,5DF
04622:  CLRF   xE2
04624:  CLRF   xE1
04626:  MOVLW  0A
04628:  MOVWF  xE3
0462A:  MOVLB  0
0462C:  RCALL  4036
0462E:  MOVFF  01,5C5
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
04632:  MOVLB  5
04634:  CLRF   xDE
04636:  MOVFF  5B8,5DD
0463A:  CLRF   xE0
0463C:  MOVLW  B5
0463E:  MOVWF  xDF
04640:  MOVLB  0
04642:  CALL   07CC
04646:  MOVFF  02,5C8
0464A:  MOVFF  01,5C7
0464E:  MOVLW  06
04650:  MOVLB  5
04652:  ADDWF  xC7,F
04654:  MOVLW  00
04656:  ADDWFC xC8,F
04658:  MOVLW  4B
0465A:  ADDWF  xC7,W
0465C:  MOVWF  01
0465E:  MOVLW  00
04660:  ADDWFC xC8,W
04662:  MOVWF  03
04664:  MOVF   01,W
04666:  ADDLW  52
04668:  MOVWF  01
0466A:  MOVLW  01
0466C:  ADDWFC 03,F
0466E:  MOVFF  01,5C7
04672:  MOVFF  03,5C8
04676:  MOVFF  03,5E2
0467A:  MOVFF  01,5E1
0467E:  MOVLB  0
04680:  CALL   3E46
04684:  MOVFF  02,03
04688:  MOVF   01,W
0468A:  SUBLW  01
0468C:  BNZ   4692
0468E:  MOVF   03,F
04690:  BZ    469A
04692:  MOVLW  02
04694:  MOVWF  01
04696:  BRA    4728
04698:  BRA    46DC
....................    else arg2 = SERcmd[rec].p[3];
0469A:  MOVLB  5
0469C:  CLRF   xDE
0469E:  MOVFF  5B8,5DD
046A2:  CLRF   xE0
046A4:  MOVLW  B5
046A6:  MOVWF  xDF
046A8:  MOVLB  0
046AA:  CALL   07CC
046AE:  MOVFF  02,5C8
046B2:  MOVFF  01,5C7
046B6:  MOVLW  06
046B8:  MOVLB  5
046BA:  ADDWF  xC7,F
046BC:  MOVLW  00
046BE:  ADDWFC xC8,F
046C0:  MOVLW  4B
046C2:  ADDWF  xC7,W
046C4:  MOVWF  01
046C6:  MOVLW  00
046C8:  ADDWFC xC8,W
046CA:  MOVWF  03
046CC:  MOVF   01,W
046CE:  ADDLW  52
046D0:  MOVWF  01
046D2:  MOVLW  01
046D4:  ADDWFC 03,F
046D6:  MOVFF  01,5C6
046DA:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
046DC:  MOVLB  5
046DE:  MOVF   xC6,W
046E0:  SUBLW  58
046E2:  BNZ   46FC
046E4:  MOVLW  01
046E6:  SUBWF  xC5,W
046E8:  MOVWF  xC7
046EA:  MOVWF  xDE
046EC:  CLRF   xDF
046EE:  CLRF   xE1
046F0:  MOVLW  60
046F2:  MOVWF  xE0
046F4:  MOVLB  0
046F6:  RCALL  4538
046F8:  BRA    4724
046FA:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
046FC:  MOVF   xC6,W
046FE:  SUBLW  59
04700:  BNZ   471C
04702:  MOVLW  01
04704:  SUBWF  xC5,W
04706:  MOVWF  xC7
04708:  MOVWF  xDE
0470A:  MOVLW  01
0470C:  MOVWF  xDF
0470E:  CLRF   xE1
04710:  MOVLW  60
04712:  MOVWF  xE0
04714:  MOVLB  0
04716:  RCALL  4538
04718:  BRA    4724
0471A:  MOVLB  5
....................    else return INV_PARAM;
0471C:  MOVLW  02
0471E:  MOVWF  01
04720:  MOVLB  0
04722:  BRA    4728
....................    
....................    return SUCCESS;
04724:  MOVLW  00
04726:  MOVWF  01
04728:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0472A:  MOVLB  5
0472C:  CLRF   xDE
0472E:  MOVFF  5B8,5DD
04732:  CLRF   xE0
04734:  MOVLW  B5
04736:  MOVWF  xDF
04738:  MOVLB  0
0473A:  CALL   07CC
0473E:  MOVFF  02,5C7
04742:  MOVFF  01,5C6
04746:  MOVLW  06
04748:  MOVLB  5
0474A:  ADDWF  xC6,F
0474C:  MOVLW  00
0474E:  ADDWFC xC7,F
04750:  MOVLW  32
04752:  ADDWF  xC6,W
04754:  MOVWF  01
04756:  MOVLW  00
04758:  ADDWFC xC7,W
0475A:  MOVWF  03
0475C:  MOVF   01,W
0475E:  ADDLW  52
04760:  MOVWF  01
04762:  MOVLW  01
04764:  ADDWFC 03,F
04766:  MOVFF  01,5C6
0476A:  MOVFF  03,5C7
0476E:  MOVFF  03,5E0
04772:  MOVFF  01,5DF
04776:  MOVLB  0
04778:  CALL   3F46
0477C:  MOVF   01,F
0477E:  BNZ   4788
04780:  MOVLW  02
04782:  MOVWF  01
04784:  BRA    488E
04786:  BRA    47E4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04788:  MOVLB  5
0478A:  CLRF   xDE
0478C:  MOVFF  5B8,5DD
04790:  CLRF   xE0
04792:  MOVLW  B5
04794:  MOVWF  xDF
04796:  MOVLB  0
04798:  CALL   07CC
0479C:  MOVFF  02,5C7
047A0:  MOVFF  01,5C6
047A4:  MOVLW  06
047A6:  MOVLB  5
047A8:  ADDWF  xC6,F
047AA:  MOVLW  00
047AC:  ADDWFC xC7,F
047AE:  MOVLW  32
047B0:  ADDWF  xC6,W
047B2:  MOVWF  01
047B4:  MOVLW  00
047B6:  ADDWFC xC7,W
047B8:  MOVWF  03
047BA:  MOVF   01,W
047BC:  ADDLW  52
047BE:  MOVWF  01
047C0:  MOVLW  01
047C2:  ADDWFC 03,F
047C4:  MOVFF  01,5C6
047C8:  MOVFF  03,5C7
047CC:  MOVFF  03,5E0
047D0:  MOVFF  01,5DF
047D4:  CLRF   xE2
047D6:  CLRF   xE1
047D8:  MOVLW  0A
047DA:  MOVWF  xE3
047DC:  MOVLB  0
047DE:  RCALL  4036
047E0:  MOVFF  01,5C5
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "VOLTAGE,");
047E4:  MOVLW  01
047E6:  MOVLB  5
047E8:  SUBWF  xC5,W
047EA:  MOVWF  xC7
047EC:  CLRF   xC9
047EE:  MOVLW  61
047F0:  MOVWF  xC8
047F2:  MOVLB  0
047F4:  RCALL  439A
047F6:  BTFSC  01.0
047F8:  BRA    4834
047FA:  MOVLW  04
047FC:  MOVLB  5
047FE:  MOVWF  xE2
04800:  MOVLW  28
04802:  MOVWF  xE1
04804:  MOVLB  0
04806:  CALL   3E46
0480A:  MOVFF  02,03
0480E:  MOVF   01,W
04810:  ADDLW  28
04812:  MOVLB  5
04814:  MOVWF  xC6
04816:  MOVLW  04
04818:  ADDWFC 02,W
0481A:  MOVWF  xC7
0481C:  MOVFF  FE8,4CD
04820:  MOVFF  5C6,4CC
04824:  MOVLW  02
04826:  MOVWF  FF6
04828:  MOVLW  03
0482A:  MOVWF  FF7
0482C:  MOVLB  0
0482E:  CALL   3E9E
04832:  BRA    488A
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MAGSENS,");
04834:  MOVLW  01
04836:  MOVLB  5
04838:  SUBWF  xC5,W
0483A:  MOVWF  xC7
0483C:  CLRF   xC9
0483E:  MOVLW  61
04840:  MOVWF  xC8
04842:  MOVLB  0
04844:  RCALL  439A
04846:  BTFSS  01.0
04848:  BRA    4884
0484A:  MOVLW  04
0484C:  MOVLB  5
0484E:  MOVWF  xE2
04850:  MOVLW  28
04852:  MOVWF  xE1
04854:  MOVLB  0
04856:  CALL   3E46
0485A:  MOVFF  02,03
0485E:  MOVF   01,W
04860:  ADDLW  28
04862:  MOVLB  5
04864:  MOVWF  xC6
04866:  MOVLW  04
04868:  ADDWFC 02,W
0486A:  MOVWF  xC7
0486C:  MOVFF  FE8,4CD
04870:  MOVFF  5C6,4CC
04874:  MOVLW  0C
04876:  MOVWF  FF6
04878:  MOVLW  03
0487A:  MOVWF  FF7
0487C:  MOVLB  0
0487E:  CALL   3E9E
04882:  BRA    488A
....................    else return INV_PARAM;
04884:  MOVLW  02
04886:  MOVWF  01
04888:  BRA    488E
....................    
....................    return SUCCESS;
0488A:  MOVLW  00
0488C:  MOVWF  01
0488E:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_voltage = "VOLTAGE";
04890:  MOVLW  56
04892:  MOVLB  5
04894:  MOVWF  xCA
04896:  MOVLW  4F
04898:  MOVWF  xCB
0489A:  MOVLW  4C
0489C:  MOVWF  xCC
0489E:  MOVLW  54
048A0:  MOVWF  xCD
048A2:  MOVLW  41
048A4:  MOVWF  xCE
048A6:  MOVLW  47
048A8:  MOVWF  xCF
048AA:  MOVLW  45
048AC:  MOVWF  xD0
048AE:  CLRF   xD1
048B0:  MOVLW  05
048B2:  MOVWF  xC9
048B4:  MOVLW  CA
048B6:  MOVWF  xC8
....................    char *s_magsens = "MAGSENS";
048B8:  MOVLW  4D
048BA:  MOVWF  xD4
048BC:  MOVLW  41
048BE:  MOVWF  xD5
048C0:  MOVLW  47
048C2:  MOVWF  xD6
048C4:  MOVLW  53
048C6:  MOVWF  xD7
048C8:  MOVLW  45
048CA:  MOVWF  xD8
048CC:  MOVLW  4E
048CE:  MOVWF  xD9
048D0:  MOVLW  53
048D2:  MOVWF  xDA
048D4:  CLRF   xDB
048D6:  MOVLW  05
048D8:  MOVWF  xD3
048DA:  MOVLW  D4
048DC:  MOVWF  xD2
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
048DE:  CLRF   xDE
048E0:  MOVFF  5B8,5DD
048E4:  CLRF   xE0
048E6:  MOVLW  B5
048E8:  MOVWF  xDF
048EA:  MOVLB  0
048EC:  CALL   07CC
048F0:  MOVFF  02,5DD
048F4:  MOVFF  01,5DC
048F8:  MOVLW  06
048FA:  MOVLB  5
048FC:  ADDWF  xDC,F
048FE:  MOVLW  00
04900:  ADDWFC xDD,F
04902:  MOVLW  32
04904:  ADDWF  xDC,W
04906:  MOVWF  01
04908:  MOVLW  00
0490A:  ADDWFC xDD,W
0490C:  MOVWF  03
0490E:  MOVF   01,W
04910:  ADDLW  52
04912:  MOVWF  01
04914:  MOVLW  01
04916:  ADDWFC 03,F
04918:  MOVFF  01,5DC
0491C:  MOVFF  03,5DD
04920:  MOVFF  03,5E0
04924:  MOVFF  01,5DF
04928:  MOVLB  0
0492A:  CALL   3F46
0492E:  MOVF   01,F
04930:  BNZ   493A
04932:  MOVLW  02
04934:  MOVWF  01
04936:  BRA    4AB0
04938:  BRA    4998
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0493A:  MOVLB  5
0493C:  CLRF   xDE
0493E:  MOVFF  5B8,5DD
04942:  CLRF   xE0
04944:  MOVLW  B5
04946:  MOVWF  xDF
04948:  MOVLB  0
0494A:  CALL   07CC
0494E:  MOVFF  02,5DD
04952:  MOVFF  01,5DC
04956:  MOVLW  06
04958:  MOVLB  5
0495A:  ADDWF  xDC,F
0495C:  MOVLW  00
0495E:  ADDWFC xDD,F
04960:  MOVLW  32
04962:  ADDWF  xDC,W
04964:  MOVWF  01
04966:  MOVLW  00
04968:  ADDWFC xDD,W
0496A:  MOVWF  03
0496C:  MOVF   01,W
0496E:  ADDLW  52
04970:  MOVWF  01
04972:  MOVLW  01
04974:  ADDWFC 03,F
04976:  MOVFF  01,5DC
0497A:  MOVFF  03,5DD
0497E:  MOVFF  03,5E0
04982:  MOVFF  01,5DF
04986:  CLRF   xE2
04988:  CLRF   xE1
0498A:  MOVLW  0A
0498C:  MOVWF  xE3
0498E:  MOVLB  0
04990:  CALL   4036
04994:  MOVFF  01,5C5
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
04998:  MOVLB  5
0499A:  CLRF   xDE
0499C:  MOVFF  5B8,5DD
049A0:  CLRF   xE0
049A2:  MOVLW  B5
049A4:  MOVWF  xDF
049A6:  MOVLB  0
049A8:  CALL   07CC
049AC:  MOVFF  02,5DD
049B0:  MOVFF  01,5DC
049B4:  MOVLW  06
049B6:  MOVLB  5
049B8:  ADDWF  xDC,F
049BA:  MOVLW  00
049BC:  ADDWFC xDD,F
049BE:  MOVLW  4B
049C0:  ADDWF  xDC,W
049C2:  MOVWF  01
049C4:  MOVLW  00
049C6:  ADDWFC xDD,W
049C8:  MOVWF  03
049CA:  MOVF   01,W
049CC:  ADDLW  52
049CE:  MOVWF  01
049D0:  MOVLW  01
049D2:  ADDWFC 03,F
049D4:  MOVFF  01,5DC
049D8:  MOVFF  03,5DD
049DC:  MOVFF  03,5E2
049E0:  MOVFF  01,5E1
049E4:  MOVLB  0
049E6:  CALL   3E46
049EA:  MOVFF  02,03
049EE:  MOVF   01,W
049F0:  BNZ   49FE
049F2:  MOVF   03,F
049F4:  BNZ   49FE
049F6:  MOVLW  02
049F8:  MOVWF  01
049FA:  BRA    4AB0
049FC:  BRA    4A44
....................    else arg2 = SERcmd[rec].p[3];
049FE:  MOVLB  5
04A00:  CLRF   xDE
04A02:  MOVFF  5B8,5DD
04A06:  CLRF   xE0
04A08:  MOVLW  B5
04A0A:  MOVWF  xDF
04A0C:  MOVLB  0
04A0E:  CALL   07CC
04A12:  MOVFF  02,5DD
04A16:  MOVFF  01,5DC
04A1A:  MOVLW  06
04A1C:  MOVLB  5
04A1E:  ADDWF  xDC,F
04A20:  MOVLW  00
04A22:  ADDWFC xDD,F
04A24:  MOVLW  4B
04A26:  ADDWF  xDC,W
04A28:  MOVWF  01
04A2A:  MOVLW  00
04A2C:  ADDWFC xDD,W
04A2E:  MOVWF  03
04A30:  MOVF   01,W
04A32:  ADDLW  52
04A34:  MOVWF  01
04A36:  MOVLW  01
04A38:  ADDWFC 03,F
04A3A:  MOVFF  01,5C6
04A3E:  MOVFF  03,5C7
04A42:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_voltage, arg2)) chMode[arg1-1] = VOLTAGE;
04A44:  MOVFF  5C9,5DE
04A48:  MOVFF  5C8,5DD
04A4C:  MOVFF  5C7,5E0
04A50:  MOVFF  5C6,5DF
04A54:  CALL   3DCE
04A58:  MOVF   01,F
04A5A:  BNZ   4A74
04A5C:  MOVLW  01
04A5E:  MOVLB  5
04A60:  SUBWF  xC5,W
04A62:  MOVWF  xDC
04A64:  MOVWF  xDE
04A66:  CLRF   xDF
04A68:  CLRF   xE1
04A6A:  MOVLW  61
04A6C:  MOVWF  xE0
04A6E:  MOVLB  0
04A70:  RCALL  4538
04A72:  BRA    4AAC
....................    else if (0 == strcmp(s_magsens, arg2)) chMode[arg1-1] = MAGSENS;
04A74:  MOVFF  5D3,5DE
04A78:  MOVFF  5D2,5DD
04A7C:  MOVFF  5C7,5E0
04A80:  MOVFF  5C6,5DF
04A84:  CALL   3DCE
04A88:  MOVF   01,F
04A8A:  BNZ   4AA6
04A8C:  MOVLW  01
04A8E:  MOVLB  5
04A90:  SUBWF  xC5,W
04A92:  MOVWF  xDC
04A94:  MOVWF  xDE
04A96:  MOVLW  01
04A98:  MOVWF  xDF
04A9A:  CLRF   xE1
04A9C:  MOVLW  61
04A9E:  MOVWF  xE0
04AA0:  MOVLB  0
04AA2:  RCALL  4538
04AA4:  BRA    4AAC
....................    else return INV_PARAM;
04AA6:  MOVLW  02
04AA8:  MOVWF  01
04AAA:  BRA    4AB0
....................    
....................    return SUCCESS;
04AAC:  MOVLW  00
04AAE:  MOVWF  01
04AB0:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04D3C:  MOVLB  5
04D3E:  CLRF   xDE
04D40:  MOVFF  5B8,5DD
04D44:  CLRF   xE0
04D46:  MOVLW  B5
04D48:  MOVWF  xDF
04D4A:  MOVLB  0
04D4C:  CALL   07CC
04D50:  MOVFF  02,5C8
04D54:  MOVFF  01,5C7
04D58:  MOVLW  06
04D5A:  MOVLB  5
04D5C:  ADDWF  xC7,F
04D5E:  MOVLW  00
04D60:  ADDWFC xC8,F
04D62:  MOVLW  32
04D64:  ADDWF  xC7,W
04D66:  MOVWF  01
04D68:  MOVLW  00
04D6A:  ADDWFC xC8,W
04D6C:  MOVWF  03
04D6E:  MOVF   01,W
04D70:  ADDLW  52
04D72:  MOVWF  01
04D74:  MOVLW  01
04D76:  ADDWFC 03,F
04D78:  MOVFF  01,5C7
04D7C:  MOVFF  03,5C8
04D80:  MOVFF  03,5E0
04D84:  MOVFF  01,5DF
04D88:  MOVLB  0
04D8A:  CALL   3F46
04D8E:  MOVF   01,F
04D90:  BNZ   4D9A
04D92:  MOVLW  02
04D94:  MOVWF  01
04D96:  BRA    5014
04D98:  BRA    4DF8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04D9A:  MOVLB  5
04D9C:  CLRF   xDE
04D9E:  MOVFF  5B8,5DD
04DA2:  CLRF   xE0
04DA4:  MOVLW  B5
04DA6:  MOVWF  xDF
04DA8:  MOVLB  0
04DAA:  CALL   07CC
04DAE:  MOVFF  02,5C8
04DB2:  MOVFF  01,5C7
04DB6:  MOVLW  06
04DB8:  MOVLB  5
04DBA:  ADDWF  xC7,F
04DBC:  MOVLW  00
04DBE:  ADDWFC xC8,F
04DC0:  MOVLW  32
04DC2:  ADDWF  xC7,W
04DC4:  MOVWF  01
04DC6:  MOVLW  00
04DC8:  ADDWFC xC8,W
04DCA:  MOVWF  03
04DCC:  MOVF   01,W
04DCE:  ADDLW  52
04DD0:  MOVWF  01
04DD2:  MOVLW  01
04DD4:  ADDWFC 03,F
04DD6:  MOVFF  01,5C7
04DDA:  MOVFF  03,5C8
04DDE:  MOVFF  03,5E0
04DE2:  MOVFF  01,5DF
04DE6:  CLRF   xE2
04DE8:  CLRF   xE1
04DEA:  MOVLW  0A
04DEC:  MOVWF  xE3
04DEE:  MOVLB  0
04DF0:  CALL   4036
04DF4:  MOVFF  01,5C5
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
04DF8:  MOVLB  5
04DFA:  CLRF   xDE
04DFC:  MOVFF  5B8,5DD
04E00:  CLRF   xE0
04E02:  MOVLW  B5
04E04:  MOVWF  xDF
04E06:  MOVLB  0
04E08:  CALL   07CC
04E0C:  MOVFF  02,5C8
04E10:  MOVFF  01,5C7
04E14:  MOVLW  06
04E16:  MOVLB  5
04E18:  ADDWF  xC7,F
04E1A:  MOVLW  00
04E1C:  ADDWFC xC8,F
04E1E:  MOVLW  4B
04E20:  ADDWF  xC7,W
04E22:  MOVWF  01
04E24:  MOVLW  00
04E26:  ADDWFC xC8,W
04E28:  MOVWF  03
04E2A:  MOVF   01,W
04E2C:  ADDLW  52
04E2E:  MOVWF  01
04E30:  MOVLW  01
04E32:  ADDWFC 03,F
04E34:  MOVFF  01,5C7
04E38:  MOVFF  03,5C8
04E3C:  MOVFF  03,5E2
04E40:  MOVFF  01,5E1
04E44:  MOVLB  0
04E46:  CALL   3E46
04E4A:  MOVFF  02,03
04E4E:  MOVF   01,W
04E50:  SUBLW  01
04E52:  BNZ   4E58
04E54:  MOVF   03,F
04E56:  BZ    4E60
04E58:  MOVLW  02
04E5A:  MOVWF  01
04E5C:  BRA    5014
04E5E:  BRA    4EA0
....................    else arg2 = SERcmd[rec].p[3][0];
04E60:  MOVLB  5
04E62:  CLRF   xDE
04E64:  MOVFF  5B8,5DD
04E68:  CLRF   xE0
04E6A:  MOVLW  B5
04E6C:  MOVWF  xDF
04E6E:  MOVLB  0
04E70:  CALL   07CC
04E74:  MOVFF  02,5C8
04E78:  MOVFF  01,5C7
04E7C:  MOVLW  06
04E7E:  MOVLB  5
04E80:  ADDWF  xC7,F
04E82:  MOVLW  00
04E84:  ADDWFC xC8,F
04E86:  MOVLW  4B
04E88:  ADDWF  xC7,F
04E8A:  MOVLW  00
04E8C:  ADDWFC xC8,F
04E8E:  MOVLW  52
04E90:  ADDWF  xC7,W
04E92:  MOVWF  FE9
04E94:  MOVLW  01
04E96:  ADDWFC xC8,W
04E98:  MOVWF  FEA
04E9A:  MOVFF  FEF,5C6
04E9E:  MOVLB  0
....................    
....................    /*** GET P, I, or D VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kP);
04EA0:  MOVLB  5
04EA2:  MOVF   xC6,W
04EA4:  SUBLW  50
04EA6:  BNZ   4F14
04EA8:  MOVLW  04
04EAA:  MOVWF  xE2
04EAC:  MOVLW  28
04EAE:  MOVWF  xE1
04EB0:  MOVLB  0
04EB2:  CALL   3E46
04EB6:  MOVFF  02,03
04EBA:  MOVF   01,W
04EBC:  ADDLW  28
04EBE:  MOVLB  5
04EC0:  MOVWF  xC7
04EC2:  MOVLW  04
04EC4:  ADDWFC 02,W
04EC6:  MOVWF  xC8
04EC8:  MOVLW  01
04ECA:  SUBWF  xC5,W
04ECC:  MULLW  20
04ECE:  MOVF   FF3,W
04ED0:  CLRF   xCA
04ED2:  MOVWF  xC9
04ED4:  MOVLW  20
04ED6:  ADDWF  xC9,W
04ED8:  MOVWF  FE9
04EDA:  MOVLW  00
04EDC:  ADDWFC xCA,W
04EDE:  MOVWF  FEA
04EE0:  MOVFF  FEF,5D0
04EE4:  MOVFF  FEC,5D1
04EE8:  MOVFF  FEC,5D2
04EEC:  MOVFF  FEC,5D3
04EF0:  MOVFF  5C8,4CD
04EF4:  MOVFF  5C7,4CC
04EF8:  MOVLW  89
04EFA:  MOVWF  FE9
04EFC:  MOVLW  02
04EFE:  MOVWF  xD4
04F00:  MOVLB  0
04F02:  RCALL  4B8A
04F04:  MOVLW  2C
04F06:  MOVLB  5
04F08:  MOVWF  xDD
04F0A:  MOVLB  0
04F0C:  CALL   3E7E
04F10:  BRA    5010
04F12:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kI);
04F14:  MOVF   xC6,W
04F16:  SUBLW  49
04F18:  BNZ   4F8E
04F1A:  MOVLW  04
04F1C:  MOVWF  xE2
04F1E:  MOVLW  28
04F20:  MOVWF  xE1
04F22:  MOVLB  0
04F24:  CALL   3E46
04F28:  MOVF   01,W
04F2A:  ADDLW  28
04F2C:  MOVLB  5
04F2E:  MOVWF  xC7
04F30:  MOVLW  04
04F32:  ADDWFC 02,W
04F34:  MOVWF  xC8
04F36:  MOVLW  01
04F38:  SUBWF  xC5,W
04F3A:  MULLW  20
04F3C:  MOVF   FF3,W
04F3E:  CLRF   xCA
04F40:  MOVWF  xC9
04F42:  MOVLW  04
04F44:  ADDWF  xC9,W
04F46:  MOVWF  01
04F48:  MOVLW  00
04F4A:  ADDWFC xCA,W
04F4C:  MOVWF  03
04F4E:  MOVF   01,W
04F50:  ADDLW  20
04F52:  MOVWF  FE9
04F54:  MOVLW  00
04F56:  ADDWFC 03,W
04F58:  MOVWF  FEA
04F5A:  MOVFF  FEF,5D0
04F5E:  MOVFF  FEC,5D1
04F62:  MOVFF  FEC,5D2
04F66:  MOVFF  FEC,5D3
04F6A:  MOVFF  5C8,4CD
04F6E:  MOVFF  5C7,4CC
04F72:  MOVLW  89
04F74:  MOVWF  FE9
04F76:  MOVLW  02
04F78:  MOVWF  xD4
04F7A:  MOVLB  0
04F7C:  RCALL  4B8A
04F7E:  MOVLW  2C
04F80:  MOVLB  5
04F82:  MOVWF  xDD
04F84:  MOVLB  0
04F86:  CALL   3E7E
04F8A:  BRA    5010
04F8C:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kD);
04F8E:  MOVF   xC6,W
04F90:  SUBLW  44
04F92:  BNZ   5008
04F94:  MOVLW  04
04F96:  MOVWF  xE2
04F98:  MOVLW  28
04F9A:  MOVWF  xE1
04F9C:  MOVLB  0
04F9E:  CALL   3E46
04FA2:  MOVF   01,W
04FA4:  ADDLW  28
04FA6:  MOVLB  5
04FA8:  MOVWF  xC7
04FAA:  MOVLW  04
04FAC:  ADDWFC 02,W
04FAE:  MOVWF  xC8
04FB0:  MOVLW  01
04FB2:  SUBWF  xC5,W
04FB4:  MULLW  20
04FB6:  MOVF   FF3,W
04FB8:  CLRF   xCA
04FBA:  MOVWF  xC9
04FBC:  MOVLW  08
04FBE:  ADDWF  xC9,W
04FC0:  MOVWF  01
04FC2:  MOVLW  00
04FC4:  ADDWFC xCA,W
04FC6:  MOVWF  03
04FC8:  MOVF   01,W
04FCA:  ADDLW  20
04FCC:  MOVWF  FE9
04FCE:  MOVLW  00
04FD0:  ADDWFC 03,W
04FD2:  MOVWF  FEA
04FD4:  MOVFF  FEF,5D0
04FD8:  MOVFF  FEC,5D1
04FDC:  MOVFF  FEC,5D2
04FE0:  MOVFF  FEC,5D3
04FE4:  MOVFF  5C8,4CD
04FE8:  MOVFF  5C7,4CC
04FEC:  MOVLW  89
04FEE:  MOVWF  FE9
04FF0:  MOVLW  02
04FF2:  MOVWF  xD4
04FF4:  MOVLB  0
04FF6:  RCALL  4B8A
04FF8:  MOVLW  2C
04FFA:  MOVLB  5
04FFC:  MOVWF  xDD
04FFE:  MOVLB  0
05000:  CALL   3E7E
05004:  BRA    5010
05006:  MOVLB  5
....................    else return INV_PARAM;
05008:  MOVLW  02
0500A:  MOVWF  01
0500C:  MOVLB  0
0500E:  BRA    5014
....................    
....................    return SUCCESS;
05010:  MOVLW  00
05012:  MOVWF  01
05014:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05338:  MOVLB  5
0533A:  CLRF   xDE
0533C:  MOVFF  5B8,5DD
05340:  CLRF   xE0
05342:  MOVLW  B5
05344:  MOVWF  xDF
05346:  MOVLB  0
05348:  CALL   07CC
0534C:  MOVFF  02,5CC
05350:  MOVFF  01,5CB
05354:  MOVLW  06
05356:  MOVLB  5
05358:  ADDWF  xCB,F
0535A:  MOVLW  00
0535C:  ADDWFC xCC,F
0535E:  MOVLW  32
05360:  ADDWF  xCB,W
05362:  MOVWF  01
05364:  MOVLW  00
05366:  ADDWFC xCC,W
05368:  MOVWF  03
0536A:  MOVF   01,W
0536C:  ADDLW  52
0536E:  MOVWF  01
05370:  MOVLW  01
05372:  ADDWFC 03,F
05374:  MOVFF  01,5CB
05378:  MOVFF  03,5CC
0537C:  MOVFF  03,5E0
05380:  MOVFF  01,5DF
05384:  MOVLB  0
05386:  CALL   3F46
0538A:  MOVF   01,F
0538C:  BNZ   5396
0538E:  MOVLW  02
05390:  MOVWF  01
05392:  BRA    5640
05394:  BRA    53F4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05396:  MOVLB  5
05398:  CLRF   xDE
0539A:  MOVFF  5B8,5DD
0539E:  CLRF   xE0
053A0:  MOVLW  B5
053A2:  MOVWF  xDF
053A4:  MOVLB  0
053A6:  CALL   07CC
053AA:  MOVFF  02,5CC
053AE:  MOVFF  01,5CB
053B2:  MOVLW  06
053B4:  MOVLB  5
053B6:  ADDWF  xCB,F
053B8:  MOVLW  00
053BA:  ADDWFC xCC,F
053BC:  MOVLW  32
053BE:  ADDWF  xCB,W
053C0:  MOVWF  01
053C2:  MOVLW  00
053C4:  ADDWFC xCC,W
053C6:  MOVWF  03
053C8:  MOVF   01,W
053CA:  ADDLW  52
053CC:  MOVWF  01
053CE:  MOVLW  01
053D0:  ADDWFC 03,F
053D2:  MOVFF  01,5CB
053D6:  MOVFF  03,5CC
053DA:  MOVFF  03,5E0
053DE:  MOVFF  01,5DF
053E2:  CLRF   xE2
053E4:  CLRF   xE1
053E6:  MOVLW  0A
053E8:  MOVWF  xE3
053EA:  MOVLB  0
053EC:  CALL   4036
053F0:  MOVFF  01,5C5
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
053F4:  MOVLB  5
053F6:  CLRF   xDE
053F8:  MOVFF  5B8,5DD
053FC:  CLRF   xE0
053FE:  MOVLW  B5
05400:  MOVWF  xDF
05402:  MOVLB  0
05404:  CALL   07CC
05408:  MOVFF  02,5CC
0540C:  MOVFF  01,5CB
05410:  MOVLW  06
05412:  MOVLB  5
05414:  ADDWF  xCB,F
05416:  MOVLW  00
05418:  ADDWFC xCC,F
0541A:  MOVLW  4B
0541C:  ADDWF  xCB,W
0541E:  MOVWF  01
05420:  MOVLW  00
05422:  ADDWFC xCC,W
05424:  MOVWF  03
05426:  MOVF   01,W
05428:  ADDLW  52
0542A:  MOVWF  01
0542C:  MOVLW  01
0542E:  ADDWFC 03,F
05430:  MOVFF  01,5CB
05434:  MOVFF  03,5CC
05438:  MOVFF  03,5E2
0543C:  MOVFF  01,5E1
05440:  MOVLB  0
05442:  CALL   3E46
05446:  MOVFF  02,03
0544A:  MOVF   01,W
0544C:  SUBLW  01
0544E:  BNZ   5454
05450:  MOVF   03,F
05452:  BZ    545C
05454:  MOVLW  02
05456:  MOVWF  01
05458:  BRA    5640
0545A:  BRA    549C
....................    else arg2 = SERcmd[rec].p[3][0];
0545C:  MOVLB  5
0545E:  CLRF   xDE
05460:  MOVFF  5B8,5DD
05464:  CLRF   xE0
05466:  MOVLW  B5
05468:  MOVWF  xDF
0546A:  MOVLB  0
0546C:  CALL   07CC
05470:  MOVFF  02,5CC
05474:  MOVFF  01,5CB
05478:  MOVLW  06
0547A:  MOVLB  5
0547C:  ADDWF  xCB,F
0547E:  MOVLW  00
05480:  ADDWFC xCC,F
05482:  MOVLW  4B
05484:  ADDWF  xCB,F
05486:  MOVLW  00
05488:  ADDWFC xCC,F
0548A:  MOVLW  52
0548C:  ADDWF  xCB,W
0548E:  MOVWF  FE9
05490:  MOVLW  01
05492:  ADDWFC xCC,W
05494:  MOVWF  FEA
05496:  MOVFF  FEF,5C6
0549A:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
0549C:  MOVLB  5
0549E:  CLRF   xDE
054A0:  MOVFF  5B8,5DD
054A4:  CLRF   xE0
054A6:  MOVLW  B5
054A8:  MOVWF  xDF
054AA:  MOVLB  0
054AC:  CALL   07CC
054B0:  MOVFF  02,5CC
054B4:  MOVFF  01,5CB
054B8:  MOVLW  06
054BA:  MOVLB  5
054BC:  ADDWF  xCB,F
054BE:  MOVLW  00
054C0:  ADDWFC xCC,F
054C2:  MOVLW  64
054C4:  ADDWF  xCB,W
054C6:  MOVWF  01
054C8:  MOVLW  00
054CA:  ADDWFC xCC,W
054CC:  MOVWF  03
054CE:  MOVF   01,W
054D0:  ADDLW  52
054D2:  MOVWF  01
054D4:  MOVLW  01
054D6:  ADDWFC 03,F
054D8:  MOVFF  01,5CB
054DC:  MOVFF  03,5CC
054E0:  MOVFF  03,5CF
054E4:  MOVFF  01,5CE
054E8:  CLRF   xD1
054EA:  CLRF   xD0
054EC:  MOVLB  0
054EE:  RCALL  5016
054F0:  MOVFF  03,613
054F4:  MOVFF  02,612
054F8:  MOVFF  01,611
054FC:  MOVFF  00,610
05500:  CALL   1CD8
05504:  MOVFF  02,5CC
05508:  MOVFF  01,5CB
0550C:  MOVFF  02,5CF
05510:  MOVFF  01,5CE
05514:  RCALL  5276
05516:  MOVF   01,F
05518:  BNZ   5522
0551A:  MOVLW  02
0551C:  MOVWF  01
0551E:  BRA    5640
05520:  BRA    5586
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
05522:  MOVLB  5
05524:  CLRF   xDE
05526:  MOVFF  5B8,5DD
0552A:  CLRF   xE0
0552C:  MOVLW  B5
0552E:  MOVWF  xDF
05530:  MOVLB  0
05532:  CALL   07CC
05536:  MOVFF  02,5CC
0553A:  MOVFF  01,5CB
0553E:  MOVLW  06
05540:  MOVLB  5
05542:  ADDWF  xCB,F
05544:  MOVLW  00
05546:  ADDWFC xCC,F
05548:  MOVLW  64
0554A:  ADDWF  xCB,W
0554C:  MOVWF  01
0554E:  MOVLW  00
05550:  ADDWFC xCC,W
05552:  MOVWF  03
05554:  MOVF   01,W
05556:  ADDLW  52
05558:  MOVWF  01
0555A:  MOVLW  01
0555C:  ADDWFC 03,F
0555E:  MOVFF  01,5CB
05562:  MOVFF  03,5CC
05566:  MOVFF  03,5CF
0556A:  MOVFF  01,5CE
0556E:  CLRF   xD1
05570:  CLRF   xD0
05572:  MOVLB  0
05574:  RCALL  5016
05576:  MOVFF  03,5CA
0557A:  MOVFF  02,5C9
0557E:  MOVFF  01,5C8
05582:  MOVFF  00,5C7
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
05586:  MOVLB  5
05588:  MOVF   xC6,W
0558A:  SUBLW  50
0558C:  BNZ   55B8
0558E:  MOVLW  01
05590:  SUBWF  xC5,W
05592:  MULLW  20
05594:  MOVF   FF3,W
05596:  CLRF   xCC
05598:  MOVWF  xCB
0559A:  MOVLW  20
0559C:  ADDWF  xCB,W
0559E:  MOVWF  FE9
055A0:  MOVLW  00
055A2:  ADDWFC xCC,W
055A4:  MOVWF  FEA
055A6:  MOVFF  5C7,FEF
055AA:  MOVFF  5C8,FEC
055AE:  MOVFF  5C9,FEC
055B2:  MOVFF  5CA,FEC
055B6:  BRA    563A
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
055B8:  MOVF   xC6,W
055BA:  SUBLW  49
055BC:  BNZ   55F4
055BE:  MOVLW  01
055C0:  SUBWF  xC5,W
055C2:  MULLW  20
055C4:  MOVF   FF3,W
055C6:  CLRF   xCC
055C8:  MOVWF  xCB
055CA:  MOVLW  04
055CC:  ADDWF  xCB,W
055CE:  MOVWF  01
055D0:  MOVLW  00
055D2:  ADDWFC xCC,W
055D4:  MOVWF  03
055D6:  MOVF   01,W
055D8:  ADDLW  20
055DA:  MOVWF  FE9
055DC:  MOVLW  00
055DE:  ADDWFC 03,W
055E0:  MOVWF  FEA
055E2:  MOVFF  5C7,FEF
055E6:  MOVFF  5C8,FEC
055EA:  MOVFF  5C9,FEC
055EE:  MOVFF  5CA,FEC
055F2:  BRA    563A
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
055F4:  MOVF   xC6,W
055F6:  SUBLW  44
055F8:  BNZ   5630
055FA:  MOVLW  01
055FC:  SUBWF  xC5,W
055FE:  MULLW  20
05600:  MOVF   FF3,W
05602:  CLRF   xCC
05604:  MOVWF  xCB
05606:  MOVLW  08
05608:  ADDWF  xCB,W
0560A:  MOVWF  01
0560C:  MOVLW  00
0560E:  ADDWFC xCC,W
05610:  MOVWF  03
05612:  MOVF   01,W
05614:  ADDLW  20
05616:  MOVWF  FE9
05618:  MOVLW  00
0561A:  ADDWFC 03,W
0561C:  MOVWF  FEA
0561E:  MOVFF  5C7,FEF
05622:  MOVFF  5C8,FEC
05626:  MOVFF  5C9,FEC
0562A:  MOVFF  5CA,FEC
0562E:  BRA    563A
....................    else return INV_PARAM;
05630:  MOVLW  02
05632:  MOVWF  01
05634:  MOVLB  0
05636:  BRA    5640
05638:  MOVLB  5
....................    
....................    return SUCCESS;
0563A:  MOVLW  00
0563C:  MOVWF  01
0563E:  MOVLB  0
05640:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05642:  MOVLB  5
05644:  CLRF   xDE
05646:  MOVFF  5B8,5DD
0564A:  CLRF   xE0
0564C:  MOVLW  B5
0564E:  MOVWF  xDF
05650:  MOVLB  0
05652:  CALL   07CC
05656:  MOVFF  02,5C7
0565A:  MOVFF  01,5C6
0565E:  MOVLW  06
05660:  MOVLB  5
05662:  ADDWF  xC6,F
05664:  MOVLW  00
05666:  ADDWFC xC7,F
05668:  MOVLW  32
0566A:  ADDWF  xC6,W
0566C:  MOVWF  01
0566E:  MOVLW  00
05670:  ADDWFC xC7,W
05672:  MOVWF  03
05674:  MOVF   01,W
05676:  ADDLW  52
05678:  MOVWF  01
0567A:  MOVLW  01
0567C:  ADDWFC 03,F
0567E:  MOVFF  01,5C6
05682:  MOVFF  03,5C7
05686:  MOVFF  03,5E0
0568A:  MOVFF  01,5DF
0568E:  MOVLB  0
05690:  CALL   3F46
05694:  MOVF   01,F
05696:  BNZ   56A0
05698:  MOVLW  02
0569A:  MOVWF  01
0569C:  BRA    5776
0569E:  BRA    56FE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
056A0:  MOVLB  5
056A2:  CLRF   xDE
056A4:  MOVFF  5B8,5DD
056A8:  CLRF   xE0
056AA:  MOVLW  B5
056AC:  MOVWF  xDF
056AE:  MOVLB  0
056B0:  CALL   07CC
056B4:  MOVFF  02,5C7
056B8:  MOVFF  01,5C6
056BC:  MOVLW  06
056BE:  MOVLB  5
056C0:  ADDWF  xC6,F
056C2:  MOVLW  00
056C4:  ADDWFC xC7,F
056C6:  MOVLW  32
056C8:  ADDWF  xC6,W
056CA:  MOVWF  01
056CC:  MOVLW  00
056CE:  ADDWFC xC7,W
056D0:  MOVWF  03
056D2:  MOVF   01,W
056D4:  ADDLW  52
056D6:  MOVWF  01
056D8:  MOVLW  01
056DA:  ADDWFC 03,F
056DC:  MOVFF  01,5C6
056E0:  MOVFF  03,5C7
056E4:  MOVFF  03,5E0
056E8:  MOVFF  01,5DF
056EC:  CLRF   xE2
056EE:  CLRF   xE1
056F0:  MOVLW  0A
056F2:  MOVWF  xE3
056F4:  MOVLB  0
056F6:  CALL   4036
056FA:  MOVFF  01,5C5
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%f,", PID[arg1-1].SP);
056FE:  MOVLW  04
05700:  MOVLB  5
05702:  MOVWF  xE2
05704:  MOVLW  28
05706:  MOVWF  xE1
05708:  MOVLB  0
0570A:  CALL   3E46
0570E:  MOVF   01,W
05710:  ADDLW  28
05712:  MOVLB  5
05714:  MOVWF  xC6
05716:  MOVLW  04
05718:  ADDWFC 02,W
0571A:  MOVWF  xC7
0571C:  MOVLW  01
0571E:  SUBWF  xC5,W
05720:  MULLW  20
05722:  MOVF   FF3,W
05724:  CLRF   xC9
05726:  MOVWF  xC8
05728:  MOVLW  0C
0572A:  ADDWF  xC8,W
0572C:  MOVWF  01
0572E:  MOVLW  00
05730:  ADDWFC xC9,W
05732:  MOVWF  03
05734:  MOVF   01,W
05736:  ADDLW  20
05738:  MOVWF  FE9
0573A:  MOVLW  00
0573C:  ADDWFC 03,W
0573E:  MOVWF  FEA
05740:  MOVFF  FEF,5D0
05744:  MOVFF  FEC,5D1
05748:  MOVFF  FEC,5D2
0574C:  MOVFF  FEC,5D3
05750:  MOVFF  5C7,4CD
05754:  MOVFF  5C6,4CC
05758:  MOVLW  89
0575A:  MOVWF  FE9
0575C:  MOVLW  02
0575E:  MOVWF  xD4
05760:  MOVLB  0
05762:  CALL   4B8A
05766:  MOVLW  2C
05768:  MOVLB  5
0576A:  MOVWF  xDD
0576C:  MOVLB  0
0576E:  CALL   3E7E
....................    return SUCCESS;
05772:  MOVLW  00
05774:  MOVWF  01
05776:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05778:  MOVLB  5
0577A:  CLRF   xDE
0577C:  MOVFF  5B8,5DD
05780:  CLRF   xE0
05782:  MOVLW  B5
05784:  MOVWF  xDF
05786:  MOVLB  0
05788:  CALL   07CC
0578C:  MOVFF  02,5CB
05790:  MOVFF  01,5CA
05794:  MOVLW  06
05796:  MOVLB  5
05798:  ADDWF  xCA,F
0579A:  MOVLW  00
0579C:  ADDWFC xCB,F
0579E:  MOVLW  32
057A0:  ADDWF  xCA,W
057A2:  MOVWF  01
057A4:  MOVLW  00
057A6:  ADDWFC xCB,W
057A8:  MOVWF  03
057AA:  MOVF   01,W
057AC:  ADDLW  52
057AE:  MOVWF  01
057B0:  MOVLW  01
057B2:  ADDWFC 03,F
057B4:  MOVFF  01,5CA
057B8:  MOVFF  03,5CB
057BC:  MOVFF  03,5E0
057C0:  MOVFF  01,5DF
057C4:  MOVLB  0
057C6:  CALL   3F46
057CA:  MOVF   01,F
057CC:  BNZ   57D6
057CE:  MOVLW  02
057D0:  MOVWF  01
057D2:  BRA    595E
057D4:  BRA    5834
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
057D6:  MOVLB  5
057D8:  CLRF   xDE
057DA:  MOVFF  5B8,5DD
057DE:  CLRF   xE0
057E0:  MOVLW  B5
057E2:  MOVWF  xDF
057E4:  MOVLB  0
057E6:  CALL   07CC
057EA:  MOVFF  02,5CB
057EE:  MOVFF  01,5CA
057F2:  MOVLW  06
057F4:  MOVLB  5
057F6:  ADDWF  xCA,F
057F8:  MOVLW  00
057FA:  ADDWFC xCB,F
057FC:  MOVLW  32
057FE:  ADDWF  xCA,W
05800:  MOVWF  01
05802:  MOVLW  00
05804:  ADDWFC xCB,W
05806:  MOVWF  03
05808:  MOVF   01,W
0580A:  ADDLW  52
0580C:  MOVWF  01
0580E:  MOVLW  01
05810:  ADDWFC 03,F
05812:  MOVFF  01,5CA
05816:  MOVFF  03,5CB
0581A:  MOVFF  03,5E0
0581E:  MOVFF  01,5DF
05822:  CLRF   xE2
05824:  CLRF   xE1
05826:  MOVLW  0A
05828:  MOVWF  xE3
0582A:  MOVLB  0
0582C:  CALL   4036
05830:  MOVFF  01,5C5
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
05834:  MOVLB  5
05836:  CLRF   xDE
05838:  MOVFF  5B8,5DD
0583C:  CLRF   xE0
0583E:  MOVLW  B5
05840:  MOVWF  xDF
05842:  MOVLB  0
05844:  CALL   07CC
05848:  MOVFF  02,5CB
0584C:  MOVFF  01,5CA
05850:  MOVLW  06
05852:  MOVLB  5
05854:  ADDWF  xCA,F
05856:  MOVLW  00
05858:  ADDWFC xCB,F
0585A:  MOVLW  4B
0585C:  ADDWF  xCA,W
0585E:  MOVWF  01
05860:  MOVLW  00
05862:  ADDWFC xCB,W
05864:  MOVWF  03
05866:  MOVF   01,W
05868:  ADDLW  52
0586A:  MOVWF  01
0586C:  MOVLW  01
0586E:  ADDWFC 03,F
05870:  MOVFF  01,5CA
05874:  MOVFF  03,5CB
05878:  MOVFF  03,5CF
0587C:  MOVFF  01,5CE
05880:  CLRF   xD1
05882:  CLRF   xD0
05884:  MOVLB  0
05886:  CALL   5016
0588A:  MOVFF  03,613
0588E:  MOVFF  02,612
05892:  MOVFF  01,611
05896:  MOVFF  00,610
0589A:  CALL   1CD8
0589E:  MOVFF  02,5CB
058A2:  MOVFF  01,5CA
058A6:  MOVFF  02,5CF
058AA:  MOVFF  01,5CE
058AE:  RCALL  5276
058B0:  MOVF   01,F
058B2:  BNZ   58BC
058B4:  MOVLW  02
058B6:  MOVWF  01
058B8:  BRA    595E
058BA:  BRA    5922
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
058BC:  MOVLB  5
058BE:  CLRF   xDE
058C0:  MOVFF  5B8,5DD
058C4:  CLRF   xE0
058C6:  MOVLW  B5
058C8:  MOVWF  xDF
058CA:  MOVLB  0
058CC:  CALL   07CC
058D0:  MOVFF  02,5CB
058D4:  MOVFF  01,5CA
058D8:  MOVLW  06
058DA:  MOVLB  5
058DC:  ADDWF  xCA,F
058DE:  MOVLW  00
058E0:  ADDWFC xCB,F
058E2:  MOVLW  4B
058E4:  ADDWF  xCA,W
058E6:  MOVWF  01
058E8:  MOVLW  00
058EA:  ADDWFC xCB,W
058EC:  MOVWF  03
058EE:  MOVF   01,W
058F0:  ADDLW  52
058F2:  MOVWF  01
058F4:  MOVLW  01
058F6:  ADDWFC 03,F
058F8:  MOVFF  01,5CA
058FC:  MOVFF  03,5CB
05900:  MOVFF  03,5CF
05904:  MOVFF  01,5CE
05908:  CLRF   xD1
0590A:  CLRF   xD0
0590C:  MOVLB  0
0590E:  CALL   5016
05912:  MOVFF  03,5C9
05916:  MOVFF  02,5C8
0591A:  MOVFF  01,5C7
0591E:  MOVFF  00,5C6
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
05922:  MOVLW  01
05924:  MOVLB  5
05926:  SUBWF  xC5,W
05928:  MULLW  20
0592A:  MOVF   FF3,W
0592C:  CLRF   xCB
0592E:  MOVWF  xCA
05930:  MOVLW  0C
05932:  ADDWF  xCA,W
05934:  MOVWF  01
05936:  MOVLW  00
05938:  ADDWFC xCB,W
0593A:  MOVWF  03
0593C:  MOVF   01,W
0593E:  ADDLW  20
05940:  MOVWF  FE9
05942:  MOVLW  00
05944:  ADDWFC 03,W
05946:  MOVWF  FEA
05948:  MOVFF  5C6,FEF
0594C:  MOVFF  5C7,FEC
05950:  MOVFF  5C8,FEC
05954:  MOVFF  5C9,FEC
....................    
....................    return SUCCESS;
05958:  MOVLW  00
0595A:  MOVWF  01
0595C:  MOVLB  0
0595E:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05960:  MOVLB  5
05962:  CLRF   xDE
05964:  MOVFF  5B8,5DD
05968:  CLRF   xE0
0596A:  MOVLW  B5
0596C:  MOVWF  xDF
0596E:  MOVLB  0
05970:  CALL   07CC
05974:  MOVFF  02,5C7
05978:  MOVFF  01,5C6
0597C:  MOVLW  06
0597E:  MOVLB  5
05980:  ADDWF  xC6,F
05982:  MOVLW  00
05984:  ADDWFC xC7,F
05986:  MOVLW  32
05988:  ADDWF  xC6,W
0598A:  MOVWF  01
0598C:  MOVLW  00
0598E:  ADDWFC xC7,W
05990:  MOVWF  03
05992:  MOVF   01,W
05994:  ADDLW  52
05996:  MOVWF  01
05998:  MOVLW  01
0599A:  ADDWFC 03,F
0599C:  MOVFF  01,5C6
059A0:  MOVFF  03,5C7
059A4:  MOVFF  03,5E0
059A8:  MOVFF  01,5DF
059AC:  MOVLB  0
059AE:  CALL   3F46
059B2:  MOVF   01,F
059B4:  BNZ   59BE
059B6:  MOVLW  02
059B8:  MOVWF  01
059BA:  BRA    5CD0
059BC:  BRA    5A1C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
059BE:  MOVLB  5
059C0:  CLRF   xDE
059C2:  MOVFF  5B8,5DD
059C6:  CLRF   xE0
059C8:  MOVLW  B5
059CA:  MOVWF  xDF
059CC:  MOVLB  0
059CE:  CALL   07CC
059D2:  MOVFF  02,5C7
059D6:  MOVFF  01,5C6
059DA:  MOVLW  06
059DC:  MOVLB  5
059DE:  ADDWF  xC6,F
059E0:  MOVLW  00
059E2:  ADDWFC xC7,F
059E4:  MOVLW  32
059E6:  ADDWF  xC6,W
059E8:  MOVWF  01
059EA:  MOVLW  00
059EC:  ADDWFC xC7,W
059EE:  MOVWF  03
059F0:  MOVF   01,W
059F2:  ADDLW  52
059F4:  MOVWF  01
059F6:  MOVLW  01
059F8:  ADDWFC 03,F
059FA:  MOVFF  01,5C6
059FE:  MOVFF  03,5C7
05A02:  MOVFF  03,5E0
05A06:  MOVFF  01,5DF
05A0A:  CLRF   xE2
05A0C:  CLRF   xE1
05A0E:  MOVLW  0A
05A10:  MOVWF  xE3
05A12:  MOVLB  0
05A14:  CALL   4036
05A18:  MOVFF  01,5C5
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
05A1C:  MOVLW  04
05A1E:  MOVLB  5
05A20:  MOVWF  xE2
05A22:  MOVLW  28
05A24:  MOVWF  xE1
05A26:  MOVLB  0
05A28:  CALL   3E46
05A2C:  MOVFF  02,03
05A30:  MOVF   01,W
05A32:  ADDLW  28
05A34:  MOVLB  5
05A36:  MOVWF  xC6
05A38:  MOVLW  04
05A3A:  ADDWFC 02,W
05A3C:  MOVWF  xC7
05A3E:  MOVLW  01
05A40:  SUBWF  xC5,W
05A42:  MULLW  18
05A44:  MOVF   FF3,W
05A46:  CLRF   xC9
05A48:  MOVWF  xC8
05A4A:  MOVLW  82
05A4C:  ADDWF  xC8,W
05A4E:  MOVWF  FE9
05A50:  MOVLW  00
05A52:  ADDWFC xC9,W
05A54:  MOVWF  FEA
05A56:  MOVFF  FEF,5D0
05A5A:  MOVFF  FEC,5D1
05A5E:  MOVFF  FEC,5D2
05A62:  MOVFF  FEC,5D3
05A66:  MOVFF  5C7,4CD
05A6A:  MOVFF  5C6,4CC
05A6E:  MOVLW  89
05A70:  MOVWF  FE9
05A72:  MOVLW  02
05A74:  MOVWF  xD4
05A76:  MOVLB  0
05A78:  CALL   4B8A
05A7C:  MOVLW  2C
05A7E:  MOVLB  5
05A80:  MOVWF  xDD
05A82:  MOVLB  0
05A84:  CALL   3E7E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
05A88:  MOVLW  04
05A8A:  MOVLB  5
05A8C:  MOVWF  xE2
05A8E:  MOVLW  28
05A90:  MOVWF  xE1
05A92:  MOVLB  0
05A94:  CALL   3E46
05A98:  MOVF   01,W
05A9A:  ADDLW  28
05A9C:  MOVLB  5
05A9E:  MOVWF  xC6
05AA0:  MOVLW  04
05AA2:  ADDWFC 02,W
05AA4:  MOVWF  xC7
05AA6:  MOVLW  01
05AA8:  SUBWF  xC5,W
05AAA:  MULLW  18
05AAC:  MOVF   FF3,W
05AAE:  CLRF   xC9
05AB0:  MOVWF  xC8
05AB2:  MOVLW  04
05AB4:  ADDWF  xC8,W
05AB6:  MOVWF  01
05AB8:  MOVLW  00
05ABA:  ADDWFC xC9,W
05ABC:  MOVWF  03
05ABE:  MOVF   01,W
05AC0:  ADDLW  82
05AC2:  MOVWF  FE9
05AC4:  MOVLW  00
05AC6:  ADDWFC 03,W
05AC8:  MOVWF  FEA
05ACA:  MOVFF  FEF,5D0
05ACE:  MOVFF  FEC,5D1
05AD2:  MOVFF  FEC,5D2
05AD6:  MOVFF  FEC,5D3
05ADA:  MOVFF  5C7,4CD
05ADE:  MOVFF  5C6,4CC
05AE2:  MOVLW  89
05AE4:  MOVWF  FE9
05AE6:  MOVLW  02
05AE8:  MOVWF  xD4
05AEA:  MOVLB  0
05AEC:  CALL   4B8A
05AF0:  MOVLW  2C
05AF2:  MOVLB  5
05AF4:  MOVWF  xDD
05AF6:  MOVLB  0
05AF8:  CALL   3E7E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
05AFC:  MOVLW  04
05AFE:  MOVLB  5
05B00:  MOVWF  xE2
05B02:  MOVLW  28
05B04:  MOVWF  xE1
05B06:  MOVLB  0
05B08:  CALL   3E46
05B0C:  MOVF   01,W
05B0E:  ADDLW  28
05B10:  MOVLB  5
05B12:  MOVWF  xC6
05B14:  MOVLW  04
05B16:  ADDWFC 02,W
05B18:  MOVWF  xC7
05B1A:  MOVLW  01
05B1C:  SUBWF  xC5,W
05B1E:  MULLW  18
05B20:  MOVF   FF3,W
05B22:  CLRF   xC9
05B24:  MOVWF  xC8
05B26:  MOVLW  08
05B28:  ADDWF  xC8,W
05B2A:  MOVWF  01
05B2C:  MOVLW  00
05B2E:  ADDWFC xC9,W
05B30:  MOVWF  03
05B32:  MOVF   01,W
05B34:  ADDLW  82
05B36:  MOVWF  FE9
05B38:  MOVLW  00
05B3A:  ADDWFC 03,W
05B3C:  MOVWF  FEA
05B3E:  MOVFF  FEF,5D0
05B42:  MOVFF  FEC,5D1
05B46:  MOVFF  FEC,5D2
05B4A:  MOVFF  FEC,5D3
05B4E:  MOVFF  5C7,4CD
05B52:  MOVFF  5C6,4CC
05B56:  MOVLW  89
05B58:  MOVWF  FE9
05B5A:  MOVLW  02
05B5C:  MOVWF  xD4
05B5E:  MOVLB  0
05B60:  CALL   4B8A
05B64:  MOVLW  2C
05B66:  MOVLB  5
05B68:  MOVWF  xDD
05B6A:  MOVLB  0
05B6C:  CALL   3E7E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
05B70:  MOVLW  04
05B72:  MOVLB  5
05B74:  MOVWF  xE2
05B76:  MOVLW  28
05B78:  MOVWF  xE1
05B7A:  MOVLB  0
05B7C:  CALL   3E46
05B80:  MOVF   01,W
05B82:  ADDLW  28
05B84:  MOVLB  5
05B86:  MOVWF  xC6
05B88:  MOVLW  04
05B8A:  ADDWFC 02,W
05B8C:  MOVWF  xC7
05B8E:  MOVLW  01
05B90:  SUBWF  xC5,W
05B92:  MULLW  18
05B94:  MOVF   FF3,W
05B96:  CLRF   xC9
05B98:  MOVWF  xC8
05B9A:  MOVLW  0C
05B9C:  ADDWF  xC8,W
05B9E:  MOVWF  01
05BA0:  MOVLW  00
05BA2:  ADDWFC xC9,W
05BA4:  MOVWF  03
05BA6:  MOVF   01,W
05BA8:  ADDLW  82
05BAA:  MOVWF  FE9
05BAC:  MOVLW  00
05BAE:  ADDWFC 03,W
05BB0:  MOVWF  FEA
05BB2:  MOVFF  FEF,5D0
05BB6:  MOVFF  FEC,5D1
05BBA:  MOVFF  FEC,5D2
05BBE:  MOVFF  FEC,5D3
05BC2:  MOVFF  5C7,4CD
05BC6:  MOVFF  5C6,4CC
05BCA:  MOVLW  89
05BCC:  MOVWF  FE9
05BCE:  MOVLW  02
05BD0:  MOVWF  xD4
05BD2:  MOVLB  0
05BD4:  CALL   4B8A
05BD8:  MOVLW  2C
05BDA:  MOVLB  5
05BDC:  MOVWF  xDD
05BDE:  MOVLB  0
05BE0:  CALL   3E7E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
05BE4:  MOVLW  04
05BE6:  MOVLB  5
05BE8:  MOVWF  xE2
05BEA:  MOVLW  28
05BEC:  MOVWF  xE1
05BEE:  MOVLB  0
05BF0:  CALL   3E46
05BF4:  MOVF   01,W
05BF6:  ADDLW  28
05BF8:  MOVLB  5
05BFA:  MOVWF  xC6
05BFC:  MOVLW  04
05BFE:  ADDWFC 02,W
05C00:  MOVWF  xC7
05C02:  MOVLW  01
05C04:  SUBWF  xC5,W
05C06:  MULLW  18
05C08:  MOVF   FF3,W
05C0A:  CLRF   xC9
05C0C:  MOVWF  xC8
05C0E:  MOVLW  10
05C10:  ADDWF  xC8,W
05C12:  MOVWF  01
05C14:  MOVLW  00
05C16:  ADDWFC xC9,W
05C18:  MOVWF  03
05C1A:  MOVF   01,W
05C1C:  ADDLW  82
05C1E:  MOVWF  FE9
05C20:  MOVLW  00
05C22:  ADDWFC 03,W
05C24:  MOVWF  FEA
05C26:  MOVFF  FEF,5D0
05C2A:  MOVFF  FEC,5D1
05C2E:  MOVFF  FEC,5D2
05C32:  MOVFF  FEC,5D3
05C36:  MOVFF  5C7,4CD
05C3A:  MOVFF  5C6,4CC
05C3E:  MOVLW  89
05C40:  MOVWF  FE9
05C42:  MOVLW  02
05C44:  MOVWF  xD4
05C46:  MOVLB  0
05C48:  CALL   4B8A
05C4C:  MOVLW  2C
05C4E:  MOVLB  5
05C50:  MOVWF  xDD
05C52:  MOVLB  0
05C54:  CALL   3E7E
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
05C58:  MOVLW  04
05C5A:  MOVLB  5
05C5C:  MOVWF  xE2
05C5E:  MOVLW  28
05C60:  MOVWF  xE1
05C62:  MOVLB  0
05C64:  CALL   3E46
05C68:  MOVF   01,W
05C6A:  ADDLW  28
05C6C:  MOVLB  5
05C6E:  MOVWF  xC6
05C70:  MOVLW  04
05C72:  ADDWFC 02,W
05C74:  MOVWF  xC7
05C76:  MOVLW  01
05C78:  SUBWF  xC5,W
05C7A:  MULLW  18
05C7C:  MOVF   FF3,W
05C7E:  CLRF   xC9
05C80:  MOVWF  xC8
05C82:  MOVLW  14
05C84:  ADDWF  xC8,W
05C86:  MOVWF  01
05C88:  MOVLW  00
05C8A:  ADDWFC xC9,W
05C8C:  MOVWF  03
05C8E:  MOVF   01,W
05C90:  ADDLW  82
05C92:  MOVWF  FE9
05C94:  MOVLW  00
05C96:  ADDWFC 03,W
05C98:  MOVWF  FEA
05C9A:  MOVFF  FEF,5D0
05C9E:  MOVFF  FEC,5D1
05CA2:  MOVFF  FEC,5D2
05CA6:  MOVFF  FEC,5D3
05CAA:  MOVFF  5C7,4CD
05CAE:  MOVFF  5C6,4CC
05CB2:  MOVLW  89
05CB4:  MOVWF  FE9
05CB6:  MOVLW  02
05CB8:  MOVWF  xD4
05CBA:  MOVLB  0
05CBC:  CALL   4B8A
05CC0:  MOVLW  2C
05CC2:  MOVLB  5
05CC4:  MOVWF  xDD
05CC6:  MOVLB  0
05CC8:  CALL   3E7E
....................    
....................    return SUCCESS;
05CCC:  MOVLW  00
05CCE:  MOVWF  01
05CD0:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05CD2:  MOVLB  5
05CD4:  CLRF   xDE
05CD6:  MOVFF  5B8,5DD
05CDA:  CLRF   xE0
05CDC:  MOVLW  B5
05CDE:  MOVWF  xDF
05CE0:  MOVLB  0
05CE2:  CALL   07CC
05CE6:  MOVFF  02,5C8
05CEA:  MOVFF  01,5C7
05CEE:  MOVLW  06
05CF0:  MOVLB  5
05CF2:  ADDWF  xC7,F
05CF4:  MOVLW  00
05CF6:  ADDWFC xC8,F
05CF8:  MOVLW  32
05CFA:  ADDWF  xC7,W
05CFC:  MOVWF  01
05CFE:  MOVLW  00
05D00:  ADDWFC xC8,W
05D02:  MOVWF  03
05D04:  MOVF   01,W
05D06:  ADDLW  52
05D08:  MOVWF  01
05D0A:  MOVLW  01
05D0C:  ADDWFC 03,F
05D0E:  MOVFF  01,5C7
05D12:  MOVFF  03,5C8
05D16:  MOVFF  03,5E0
05D1A:  MOVFF  01,5DF
05D1E:  MOVLB  0
05D20:  CALL   3F46
05D24:  MOVF   01,F
05D26:  BNZ   5D30
05D28:  MOVLW  02
05D2A:  MOVWF  01
05D2C:  BRA    6124
05D2E:  BRA    5D8E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05D30:  MOVLB  5
05D32:  CLRF   xDE
05D34:  MOVFF  5B8,5DD
05D38:  CLRF   xE0
05D3A:  MOVLW  B5
05D3C:  MOVWF  xDF
05D3E:  MOVLB  0
05D40:  CALL   07CC
05D44:  MOVFF  02,5C8
05D48:  MOVFF  01,5C7
05D4C:  MOVLW  06
05D4E:  MOVLB  5
05D50:  ADDWF  xC7,F
05D52:  MOVLW  00
05D54:  ADDWFC xC8,F
05D56:  MOVLW  32
05D58:  ADDWF  xC7,W
05D5A:  MOVWF  01
05D5C:  MOVLW  00
05D5E:  ADDWFC xC8,W
05D60:  MOVWF  03
05D62:  MOVF   01,W
05D64:  ADDLW  52
05D66:  MOVWF  01
05D68:  MOVLW  01
05D6A:  ADDWFC 03,F
05D6C:  MOVFF  01,5C7
05D70:  MOVFF  03,5C8
05D74:  MOVFF  03,5E0
05D78:  MOVFF  01,5DF
05D7C:  CLRF   xE2
05D7E:  CLRF   xE1
05D80:  MOVLW  0A
05D82:  MOVWF  xE3
05D84:  MOVLB  0
05D86:  CALL   4036
05D8A:  MOVFF  01,5C5
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05D8E:  MOVLB  5
05D90:  CLRF   xDE
05D92:  MOVFF  5B8,5DD
05D96:  CLRF   xE0
05D98:  MOVLW  B5
05D9A:  MOVWF  xDF
05D9C:  MOVLB  0
05D9E:  CALL   07CC
05DA2:  MOVFF  02,5C8
05DA6:  MOVFF  01,5C7
05DAA:  MOVLW  06
05DAC:  MOVLB  5
05DAE:  ADDWF  xC7,F
05DB0:  MOVLW  00
05DB2:  ADDWFC xC8,F
05DB4:  MOVLW  4B
05DB6:  ADDWF  xC7,W
05DB8:  MOVWF  01
05DBA:  MOVLW  00
05DBC:  ADDWFC xC8,W
05DBE:  MOVWF  03
05DC0:  MOVF   01,W
05DC2:  ADDLW  52
05DC4:  MOVWF  01
05DC6:  MOVLW  01
05DC8:  ADDWFC 03,F
05DCA:  MOVFF  01,5C7
05DCE:  MOVFF  03,5C8
05DD2:  MOVFF  03,5E2
05DD6:  MOVFF  01,5E1
05DDA:  MOVLB  0
05DDC:  CALL   3E46
05DE0:  MOVFF  02,03
05DE4:  MOVF   01,W
05DE6:  SUBLW  01
05DE8:  BNZ   5DEE
05DEA:  MOVF   03,F
05DEC:  BZ    5DF6
05DEE:  MOVLW  02
05DF0:  MOVWF  01
05DF2:  BRA    6124
05DF4:  BRA    5E36
....................    else arg2 = SERcmd[rec].p[3][0];
05DF6:  MOVLB  5
05DF8:  CLRF   xDE
05DFA:  MOVFF  5B8,5DD
05DFE:  CLRF   xE0
05E00:  MOVLW  B5
05E02:  MOVWF  xDF
05E04:  MOVLB  0
05E06:  CALL   07CC
05E0A:  MOVFF  02,5C8
05E0E:  MOVFF  01,5C7
05E12:  MOVLW  06
05E14:  MOVLB  5
05E16:  ADDWF  xC7,F
05E18:  MOVLW  00
05E1A:  ADDWFC xC8,F
05E1C:  MOVLW  4B
05E1E:  ADDWF  xC7,F
05E20:  MOVLW  00
05E22:  ADDWFC xC8,F
05E24:  MOVLW  52
05E26:  ADDWF  xC7,W
05E28:  MOVWF  FE9
05E2A:  MOVLW  01
05E2C:  ADDWFC xC8,W
05E2E:  MOVWF  FEA
05E30:  MOVFF  FEF,5C6
05E34:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
05E36:  MOVLB  5
05E38:  MOVF   xC6,W
05E3A:  SUBLW  30
05E3C:  BNZ   5EAC
05E3E:  MOVLW  04
05E40:  MOVWF  xE2
05E42:  MOVLW  28
05E44:  MOVWF  xE1
05E46:  MOVLB  0
05E48:  CALL   3E46
05E4C:  MOVFF  02,03
05E50:  MOVF   01,W
05E52:  ADDLW  28
05E54:  MOVLB  5
05E56:  MOVWF  xC7
05E58:  MOVLW  04
05E5A:  ADDWFC 02,W
05E5C:  MOVWF  xC8
05E5E:  MOVLW  01
05E60:  SUBWF  xC5,W
05E62:  MULLW  18
05E64:  MOVF   FF3,W
05E66:  CLRF   xCA
05E68:  MOVWF  xC9
05E6A:  MOVLW  82
05E6C:  ADDWF  xC9,W
05E6E:  MOVWF  FE9
05E70:  MOVLW  00
05E72:  ADDWFC xCA,W
05E74:  MOVWF  FEA
05E76:  MOVFF  FEF,5D0
05E7A:  MOVFF  FEC,5D1
05E7E:  MOVFF  FEC,5D2
05E82:  MOVFF  FEC,5D3
05E86:  MOVFF  5C8,4CD
05E8A:  MOVFF  5C7,4CC
05E8E:  MOVLW  89
05E90:  MOVWF  FE9
05E92:  MOVLW  02
05E94:  MOVWF  xD4
05E96:  MOVLB  0
05E98:  CALL   4B8A
05E9C:  MOVLW  2C
05E9E:  MOVLB  5
05EA0:  MOVWF  xDD
05EA2:  MOVLB  0
05EA4:  CALL   3E7E
05EA8:  BRA    6120
05EAA:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
05EAC:  MOVF   xC6,W
05EAE:  SUBLW  31
05EB0:  BNZ   5F28
05EB2:  MOVLW  04
05EB4:  MOVWF  xE2
05EB6:  MOVLW  28
05EB8:  MOVWF  xE1
05EBA:  MOVLB  0
05EBC:  CALL   3E46
05EC0:  MOVF   01,W
05EC2:  ADDLW  28
05EC4:  MOVLB  5
05EC6:  MOVWF  xC7
05EC8:  MOVLW  04
05ECA:  ADDWFC 02,W
05ECC:  MOVWF  xC8
05ECE:  MOVLW  01
05ED0:  SUBWF  xC5,W
05ED2:  MULLW  18
05ED4:  MOVF   FF3,W
05ED6:  CLRF   xCA
05ED8:  MOVWF  xC9
05EDA:  MOVLW  04
05EDC:  ADDWF  xC9,W
05EDE:  MOVWF  01
05EE0:  MOVLW  00
05EE2:  ADDWFC xCA,W
05EE4:  MOVWF  03
05EE6:  MOVF   01,W
05EE8:  ADDLW  82
05EEA:  MOVWF  FE9
05EEC:  MOVLW  00
05EEE:  ADDWFC 03,W
05EF0:  MOVWF  FEA
05EF2:  MOVFF  FEF,5D0
05EF6:  MOVFF  FEC,5D1
05EFA:  MOVFF  FEC,5D2
05EFE:  MOVFF  FEC,5D3
05F02:  MOVFF  5C8,4CD
05F06:  MOVFF  5C7,4CC
05F0A:  MOVLW  89
05F0C:  MOVWF  FE9
05F0E:  MOVLW  02
05F10:  MOVWF  xD4
05F12:  MOVLB  0
05F14:  CALL   4B8A
05F18:  MOVLW  2C
05F1A:  MOVLB  5
05F1C:  MOVWF  xDD
05F1E:  MOVLB  0
05F20:  CALL   3E7E
05F24:  BRA    6120
05F26:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
05F28:  MOVF   xC6,W
05F2A:  SUBLW  32
05F2C:  BNZ   5FA4
05F2E:  MOVLW  04
05F30:  MOVWF  xE2
05F32:  MOVLW  28
05F34:  MOVWF  xE1
05F36:  MOVLB  0
05F38:  CALL   3E46
05F3C:  MOVF   01,W
05F3E:  ADDLW  28
05F40:  MOVLB  5
05F42:  MOVWF  xC7
05F44:  MOVLW  04
05F46:  ADDWFC 02,W
05F48:  MOVWF  xC8
05F4A:  MOVLW  01
05F4C:  SUBWF  xC5,W
05F4E:  MULLW  18
05F50:  MOVF   FF3,W
05F52:  CLRF   xCA
05F54:  MOVWF  xC9
05F56:  MOVLW  08
05F58:  ADDWF  xC9,W
05F5A:  MOVWF  01
05F5C:  MOVLW  00
05F5E:  ADDWFC xCA,W
05F60:  MOVWF  03
05F62:  MOVF   01,W
05F64:  ADDLW  82
05F66:  MOVWF  FE9
05F68:  MOVLW  00
05F6A:  ADDWFC 03,W
05F6C:  MOVWF  FEA
05F6E:  MOVFF  FEF,5D0
05F72:  MOVFF  FEC,5D1
05F76:  MOVFF  FEC,5D2
05F7A:  MOVFF  FEC,5D3
05F7E:  MOVFF  5C8,4CD
05F82:  MOVFF  5C7,4CC
05F86:  MOVLW  89
05F88:  MOVWF  FE9
05F8A:  MOVLW  02
05F8C:  MOVWF  xD4
05F8E:  MOVLB  0
05F90:  CALL   4B8A
05F94:  MOVLW  2C
05F96:  MOVLB  5
05F98:  MOVWF  xDD
05F9A:  MOVLB  0
05F9C:  CALL   3E7E
05FA0:  BRA    6120
05FA2:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
05FA4:  MOVF   xC6,W
05FA6:  SUBLW  33
05FA8:  BNZ   6020
05FAA:  MOVLW  04
05FAC:  MOVWF  xE2
05FAE:  MOVLW  28
05FB0:  MOVWF  xE1
05FB2:  MOVLB  0
05FB4:  CALL   3E46
05FB8:  MOVF   01,W
05FBA:  ADDLW  28
05FBC:  MOVLB  5
05FBE:  MOVWF  xC7
05FC0:  MOVLW  04
05FC2:  ADDWFC 02,W
05FC4:  MOVWF  xC8
05FC6:  MOVLW  01
05FC8:  SUBWF  xC5,W
05FCA:  MULLW  18
05FCC:  MOVF   FF3,W
05FCE:  CLRF   xCA
05FD0:  MOVWF  xC9
05FD2:  MOVLW  0C
05FD4:  ADDWF  xC9,W
05FD6:  MOVWF  01
05FD8:  MOVLW  00
05FDA:  ADDWFC xCA,W
05FDC:  MOVWF  03
05FDE:  MOVF   01,W
05FE0:  ADDLW  82
05FE2:  MOVWF  FE9
05FE4:  MOVLW  00
05FE6:  ADDWFC 03,W
05FE8:  MOVWF  FEA
05FEA:  MOVFF  FEF,5D0
05FEE:  MOVFF  FEC,5D1
05FF2:  MOVFF  FEC,5D2
05FF6:  MOVFF  FEC,5D3
05FFA:  MOVFF  5C8,4CD
05FFE:  MOVFF  5C7,4CC
06002:  MOVLW  89
06004:  MOVWF  FE9
06006:  MOVLW  02
06008:  MOVWF  xD4
0600A:  MOVLB  0
0600C:  CALL   4B8A
06010:  MOVLW  2C
06012:  MOVLB  5
06014:  MOVWF  xDD
06016:  MOVLB  0
06018:  CALL   3E7E
0601C:  BRA    6120
0601E:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
06020:  MOVF   xC6,W
06022:  SUBLW  34
06024:  BNZ   609C
06026:  MOVLW  04
06028:  MOVWF  xE2
0602A:  MOVLW  28
0602C:  MOVWF  xE1
0602E:  MOVLB  0
06030:  CALL   3E46
06034:  MOVF   01,W
06036:  ADDLW  28
06038:  MOVLB  5
0603A:  MOVWF  xC7
0603C:  MOVLW  04
0603E:  ADDWFC 02,W
06040:  MOVWF  xC8
06042:  MOVLW  01
06044:  SUBWF  xC5,W
06046:  MULLW  18
06048:  MOVF   FF3,W
0604A:  CLRF   xCA
0604C:  MOVWF  xC9
0604E:  MOVLW  10
06050:  ADDWF  xC9,W
06052:  MOVWF  01
06054:  MOVLW  00
06056:  ADDWFC xCA,W
06058:  MOVWF  03
0605A:  MOVF   01,W
0605C:  ADDLW  82
0605E:  MOVWF  FE9
06060:  MOVLW  00
06062:  ADDWFC 03,W
06064:  MOVWF  FEA
06066:  MOVFF  FEF,5D0
0606A:  MOVFF  FEC,5D1
0606E:  MOVFF  FEC,5D2
06072:  MOVFF  FEC,5D3
06076:  MOVFF  5C8,4CD
0607A:  MOVFF  5C7,4CC
0607E:  MOVLW  89
06080:  MOVWF  FE9
06082:  MOVLW  02
06084:  MOVWF  xD4
06086:  MOVLB  0
06088:  CALL   4B8A
0608C:  MOVLW  2C
0608E:  MOVLB  5
06090:  MOVWF  xDD
06092:  MOVLB  0
06094:  CALL   3E7E
06098:  BRA    6120
0609A:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
0609C:  MOVF   xC6,W
0609E:  SUBLW  35
060A0:  BNZ   6118
060A2:  MOVLW  04
060A4:  MOVWF  xE2
060A6:  MOVLW  28
060A8:  MOVWF  xE1
060AA:  MOVLB  0
060AC:  CALL   3E46
060B0:  MOVF   01,W
060B2:  ADDLW  28
060B4:  MOVLB  5
060B6:  MOVWF  xC7
060B8:  MOVLW  04
060BA:  ADDWFC 02,W
060BC:  MOVWF  xC8
060BE:  MOVLW  01
060C0:  SUBWF  xC5,W
060C2:  MULLW  18
060C4:  MOVF   FF3,W
060C6:  CLRF   xCA
060C8:  MOVWF  xC9
060CA:  MOVLW  14
060CC:  ADDWF  xC9,W
060CE:  MOVWF  01
060D0:  MOVLW  00
060D2:  ADDWFC xCA,W
060D4:  MOVWF  03
060D6:  MOVF   01,W
060D8:  ADDLW  82
060DA:  MOVWF  FE9
060DC:  MOVLW  00
060DE:  ADDWFC 03,W
060E0:  MOVWF  FEA
060E2:  MOVFF  FEF,5D0
060E6:  MOVFF  FEC,5D1
060EA:  MOVFF  FEC,5D2
060EE:  MOVFF  FEC,5D3
060F2:  MOVFF  5C8,4CD
060F6:  MOVFF  5C7,4CC
060FA:  MOVLW  89
060FC:  MOVWF  FE9
060FE:  MOVLW  02
06100:  MOVWF  xD4
06102:  MOVLB  0
06104:  CALL   4B8A
06108:  MOVLW  2C
0610A:  MOVLB  5
0610C:  MOVWF  xDD
0610E:  MOVLB  0
06110:  CALL   3E7E
06114:  BRA    6120
06116:  MOVLB  5
....................    else return INV_PARAM;
06118:  MOVLW  02
0611A:  MOVWF  01
0611C:  MOVLB  0
0611E:  BRA    6124
....................    
....................    return SUCCESS;
06120:  MOVLW  00
06122:  MOVWF  01
06124:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06126:  MOVLB  5
06128:  CLRF   xDE
0612A:  MOVFF  5B8,5DD
0612E:  CLRF   xE0
06130:  MOVLW  B5
06132:  MOVWF  xDF
06134:  MOVLB  0
06136:  CALL   07CC
0613A:  MOVFF  02,5CC
0613E:  MOVFF  01,5CB
06142:  MOVLW  06
06144:  MOVLB  5
06146:  ADDWF  xCB,F
06148:  MOVLW  00
0614A:  ADDWFC xCC,F
0614C:  MOVLW  32
0614E:  ADDWF  xCB,W
06150:  MOVWF  01
06152:  MOVLW  00
06154:  ADDWFC xCC,W
06156:  MOVWF  03
06158:  MOVF   01,W
0615A:  ADDLW  52
0615C:  MOVWF  01
0615E:  MOVLW  01
06160:  ADDWFC 03,F
06162:  MOVFF  01,5CB
06166:  MOVFF  03,5CC
0616A:  MOVFF  03,5E0
0616E:  MOVFF  01,5DF
06172:  MOVLB  0
06174:  CALL   3F46
06178:  MOVF   01,F
0617A:  BNZ   6184
0617C:  MOVLW  02
0617E:  MOVWF  01
06180:  BRA    64E8
06182:  BRA    61E2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06184:  MOVLB  5
06186:  CLRF   xDE
06188:  MOVFF  5B8,5DD
0618C:  CLRF   xE0
0618E:  MOVLW  B5
06190:  MOVWF  xDF
06192:  MOVLB  0
06194:  CALL   07CC
06198:  MOVFF  02,5CC
0619C:  MOVFF  01,5CB
061A0:  MOVLW  06
061A2:  MOVLB  5
061A4:  ADDWF  xCB,F
061A6:  MOVLW  00
061A8:  ADDWFC xCC,F
061AA:  MOVLW  32
061AC:  ADDWF  xCB,W
061AE:  MOVWF  01
061B0:  MOVLW  00
061B2:  ADDWFC xCC,W
061B4:  MOVWF  03
061B6:  MOVF   01,W
061B8:  ADDLW  52
061BA:  MOVWF  01
061BC:  MOVLW  01
061BE:  ADDWFC 03,F
061C0:  MOVFF  01,5CB
061C4:  MOVFF  03,5CC
061C8:  MOVFF  03,5E0
061CC:  MOVFF  01,5DF
061D0:  CLRF   xE2
061D2:  CLRF   xE1
061D4:  MOVLW  0A
061D6:  MOVWF  xE3
061D8:  MOVLB  0
061DA:  CALL   4036
061DE:  MOVFF  01,5C5
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
061E2:  MOVLB  5
061E4:  CLRF   xDE
061E6:  MOVFF  5B8,5DD
061EA:  CLRF   xE0
061EC:  MOVLW  B5
061EE:  MOVWF  xDF
061F0:  MOVLB  0
061F2:  CALL   07CC
061F6:  MOVFF  02,5CC
061FA:  MOVFF  01,5CB
061FE:  MOVLW  06
06200:  MOVLB  5
06202:  ADDWF  xCB,F
06204:  MOVLW  00
06206:  ADDWFC xCC,F
06208:  MOVLW  4B
0620A:  ADDWF  xCB,W
0620C:  MOVWF  01
0620E:  MOVLW  00
06210:  ADDWFC xCC,W
06212:  MOVWF  03
06214:  MOVF   01,W
06216:  ADDLW  52
06218:  MOVWF  01
0621A:  MOVLW  01
0621C:  ADDWFC 03,F
0621E:  MOVFF  01,5CB
06222:  MOVFF  03,5CC
06226:  MOVFF  03,5E2
0622A:  MOVFF  01,5E1
0622E:  MOVLB  0
06230:  CALL   3E46
06234:  MOVFF  02,03
06238:  MOVF   01,W
0623A:  SUBLW  01
0623C:  BNZ   6242
0623E:  MOVF   03,F
06240:  BZ    624A
06242:  MOVLW  02
06244:  MOVWF  01
06246:  BRA    64E8
06248:  BRA    628A
....................    else arg2 = SERcmd[rec].p[3][0];
0624A:  MOVLB  5
0624C:  CLRF   xDE
0624E:  MOVFF  5B8,5DD
06252:  CLRF   xE0
06254:  MOVLW  B5
06256:  MOVWF  xDF
06258:  MOVLB  0
0625A:  CALL   07CC
0625E:  MOVFF  02,5CC
06262:  MOVFF  01,5CB
06266:  MOVLW  06
06268:  MOVLB  5
0626A:  ADDWF  xCB,F
0626C:  MOVLW  00
0626E:  ADDWFC xCC,F
06270:  MOVLW  4B
06272:  ADDWF  xCB,F
06274:  MOVLW  00
06276:  ADDWFC xCC,F
06278:  MOVLW  52
0627A:  ADDWF  xCB,W
0627C:  MOVWF  FE9
0627E:  MOVLW  01
06280:  ADDWFC xCC,W
06282:  MOVWF  FEA
06284:  MOVFF  FEF,5C6
06288:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
0628A:  MOVLB  5
0628C:  CLRF   xDE
0628E:  MOVFF  5B8,5DD
06292:  CLRF   xE0
06294:  MOVLW  B5
06296:  MOVWF  xDF
06298:  MOVLB  0
0629A:  CALL   07CC
0629E:  MOVFF  02,5CC
062A2:  MOVFF  01,5CB
062A6:  MOVLW  06
062A8:  MOVLB  5
062AA:  ADDWF  xCB,F
062AC:  MOVLW  00
062AE:  ADDWFC xCC,F
062B0:  MOVLW  4B
062B2:  ADDWF  xCB,W
062B4:  MOVWF  01
062B6:  MOVLW  00
062B8:  ADDWFC xCC,W
062BA:  MOVWF  03
062BC:  MOVF   01,W
062BE:  ADDLW  52
062C0:  MOVWF  01
062C2:  MOVLW  01
062C4:  ADDWFC 03,F
062C6:  MOVFF  01,5CB
062CA:  MOVFF  03,5CC
062CE:  MOVFF  03,5CF
062D2:  MOVFF  01,5CE
062D6:  CLRF   xD1
062D8:  CLRF   xD0
062DA:  MOVLB  0
062DC:  CALL   5016
062E0:  MOVFF  03,613
062E4:  MOVFF  02,612
062E8:  MOVFF  01,611
062EC:  MOVFF  00,610
062F0:  CALL   1CD8
062F4:  MOVFF  02,5CC
062F8:  MOVFF  01,5CB
062FC:  MOVFF  02,5CF
06300:  MOVFF  01,5CE
06304:  CALL   5276
06308:  MOVF   01,F
0630A:  BNZ   6314
0630C:  MOVLW  02
0630E:  MOVWF  01
06310:  BRA    64E8
06312:  BRA    637A
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06314:  MOVLB  5
06316:  CLRF   xDE
06318:  MOVFF  5B8,5DD
0631C:  CLRF   xE0
0631E:  MOVLW  B5
06320:  MOVWF  xDF
06322:  MOVLB  0
06324:  CALL   07CC
06328:  MOVFF  02,5CC
0632C:  MOVFF  01,5CB
06330:  MOVLW  06
06332:  MOVLB  5
06334:  ADDWF  xCB,F
06336:  MOVLW  00
06338:  ADDWFC xCC,F
0633A:  MOVLW  64
0633C:  ADDWF  xCB,W
0633E:  MOVWF  01
06340:  MOVLW  00
06342:  ADDWFC xCC,W
06344:  MOVWF  03
06346:  MOVF   01,W
06348:  ADDLW  52
0634A:  MOVWF  01
0634C:  MOVLW  01
0634E:  ADDWFC 03,F
06350:  MOVFF  01,5CB
06354:  MOVFF  03,5CC
06358:  MOVFF  03,5CF
0635C:  MOVFF  01,5CE
06360:  CLRF   xD1
06362:  CLRF   xD0
06364:  MOVLB  0
06366:  CALL   5016
0636A:  MOVFF  03,5CA
0636E:  MOVFF  02,5C9
06372:  MOVFF  01,5C8
06376:  MOVFF  00,5C7
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
0637A:  MOVLB  5
0637C:  MOVF   xC6,W
0637E:  SUBLW  30
06380:  BNZ   63AC
06382:  MOVLW  01
06384:  SUBWF  xC5,W
06386:  MULLW  18
06388:  MOVF   FF3,W
0638A:  CLRF   xCC
0638C:  MOVWF  xCB
0638E:  MOVLW  82
06390:  ADDWF  xCB,W
06392:  MOVWF  FE9
06394:  MOVLW  00
06396:  ADDWFC xCC,W
06398:  MOVWF  FEA
0639A:  MOVFF  5C7,FEF
0639E:  MOVFF  5C8,FEC
063A2:  MOVFF  5C9,FEC
063A6:  MOVFF  5CA,FEC
063AA:  BRA    64E2
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
063AC:  MOVF   xC6,W
063AE:  SUBLW  31
063B0:  BNZ   63E8
063B2:  MOVLW  01
063B4:  SUBWF  xC5,W
063B6:  MULLW  18
063B8:  MOVF   FF3,W
063BA:  CLRF   xCC
063BC:  MOVWF  xCB
063BE:  MOVLW  04
063C0:  ADDWF  xCB,W
063C2:  MOVWF  01
063C4:  MOVLW  00
063C6:  ADDWFC xCC,W
063C8:  MOVWF  03
063CA:  MOVF   01,W
063CC:  ADDLW  82
063CE:  MOVWF  FE9
063D0:  MOVLW  00
063D2:  ADDWFC 03,W
063D4:  MOVWF  FEA
063D6:  MOVFF  5C7,FEF
063DA:  MOVFF  5C8,FEC
063DE:  MOVFF  5C9,FEC
063E2:  MOVFF  5CA,FEC
063E6:  BRA    64E2
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
063E8:  MOVF   xC6,W
063EA:  SUBLW  32
063EC:  BNZ   6424
063EE:  MOVLW  01
063F0:  SUBWF  xC5,W
063F2:  MULLW  18
063F4:  MOVF   FF3,W
063F6:  CLRF   xCC
063F8:  MOVWF  xCB
063FA:  MOVLW  08
063FC:  ADDWF  xCB,W
063FE:  MOVWF  01
06400:  MOVLW  00
06402:  ADDWFC xCC,W
06404:  MOVWF  03
06406:  MOVF   01,W
06408:  ADDLW  82
0640A:  MOVWF  FE9
0640C:  MOVLW  00
0640E:  ADDWFC 03,W
06410:  MOVWF  FEA
06412:  MOVFF  5C7,FEF
06416:  MOVFF  5C8,FEC
0641A:  MOVFF  5C9,FEC
0641E:  MOVFF  5CA,FEC
06422:  BRA    64E2
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
06424:  MOVF   xC6,W
06426:  SUBLW  33
06428:  BNZ   6460
0642A:  MOVLW  01
0642C:  SUBWF  xC5,W
0642E:  MULLW  18
06430:  MOVF   FF3,W
06432:  CLRF   xCC
06434:  MOVWF  xCB
06436:  MOVLW  0C
06438:  ADDWF  xCB,W
0643A:  MOVWF  01
0643C:  MOVLW  00
0643E:  ADDWFC xCC,W
06440:  MOVWF  03
06442:  MOVF   01,W
06444:  ADDLW  82
06446:  MOVWF  FE9
06448:  MOVLW  00
0644A:  ADDWFC 03,W
0644C:  MOVWF  FEA
0644E:  MOVFF  5C7,FEF
06452:  MOVFF  5C8,FEC
06456:  MOVFF  5C9,FEC
0645A:  MOVFF  5CA,FEC
0645E:  BRA    64E2
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
06460:  MOVF   xC6,W
06462:  SUBLW  34
06464:  BNZ   649C
06466:  MOVLW  01
06468:  SUBWF  xC5,W
0646A:  MULLW  18
0646C:  MOVF   FF3,W
0646E:  CLRF   xCC
06470:  MOVWF  xCB
06472:  MOVLW  10
06474:  ADDWF  xCB,W
06476:  MOVWF  01
06478:  MOVLW  00
0647A:  ADDWFC xCC,W
0647C:  MOVWF  03
0647E:  MOVF   01,W
06480:  ADDLW  82
06482:  MOVWF  FE9
06484:  MOVLW  00
06486:  ADDWFC 03,W
06488:  MOVWF  FEA
0648A:  MOVFF  5C7,FEF
0648E:  MOVFF  5C8,FEC
06492:  MOVFF  5C9,FEC
06496:  MOVFF  5CA,FEC
0649A:  BRA    64E2
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
0649C:  MOVF   xC6,W
0649E:  SUBLW  35
064A0:  BNZ   64D8
064A2:  MOVLW  01
064A4:  SUBWF  xC5,W
064A6:  MULLW  18
064A8:  MOVF   FF3,W
064AA:  CLRF   xCC
064AC:  MOVWF  xCB
064AE:  MOVLW  14
064B0:  ADDWF  xCB,W
064B2:  MOVWF  01
064B4:  MOVLW  00
064B6:  ADDWFC xCC,W
064B8:  MOVWF  03
064BA:  MOVF   01,W
064BC:  ADDLW  82
064BE:  MOVWF  FE9
064C0:  MOVLW  00
064C2:  ADDWFC 03,W
064C4:  MOVWF  FEA
064C6:  MOVFF  5C7,FEF
064CA:  MOVFF  5C8,FEC
064CE:  MOVFF  5C9,FEC
064D2:  MOVFF  5CA,FEC
064D6:  BRA    64E2
....................    else return INV_PARAM;
064D8:  MOVLW  02
064DA:  MOVWF  01
064DC:  MOVLB  0
064DE:  BRA    64E8
064E0:  MOVLB  5
....................    
....................    return SUCCESS;
064E2:  MOVLW  00
064E4:  MOVWF  01
064E6:  MOVLB  0
064E8:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    
....................    return SUCCESS;
064EA:  MOVLW  00
064EC:  MOVWF  01
064EE:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
064F0:  MOVLW  00
064F2:  MOVWF  01
064F4:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    
....................    return SUCCESS;
064F6:  MOVLW  00
064F8:  MOVWF  01
064FA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
064FC:  MOVLW  00
064FE:  MOVWF  01
06500:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
06502:  MOVLW  00
06504:  MOVWF  01
06506:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
05276:  MOVLB  5
05278:  BCF    xD0.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
0527A:  CLRF   xD1
0527C:  MOVFF  5CF,5E2
05280:  MOVFF  5CE,5E1
05284:  MOVLB  0
05286:  CALL   3E46
0528A:  MOVFF  02,03
0528E:  MOVF   01,W
05290:  MOVF   03,F
05292:  BNZ   529E
05294:  MOVF   01,W
05296:  MOVLB  5
05298:  SUBWF  xD1,W
0529A:  BC    5330
0529C:  MOVLB  0
....................       if (!isdigit(arg[i])){
0529E:  MOVLB  5
052A0:  MOVF   xD1,W
052A2:  ADDWF  xCE,W
052A4:  MOVWF  FE9
052A6:  MOVLW  00
052A8:  ADDWFC xCF,W
052AA:  MOVWF  FEA
052AC:  MOVFF  FEF,5D2
052B0:  MOVF   xD2,W
052B2:  SUBLW  2F
052B4:  BC    52BC
052B6:  MOVF   xD2,W
052B8:  SUBLW  39
052BA:  BC    5328
....................          // Check for negative sign
....................          if ('-' != arg[i]){
052BC:  MOVF   xD1,W
052BE:  ADDWF  xCE,W
052C0:  MOVWF  FE9
052C2:  MOVLW  00
052C4:  ADDWFC xCF,W
052C6:  MOVWF  FEA
052C8:  MOVF   FEF,W
052CA:  SUBLW  2D
052CC:  BZ    52F8
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
052CE:  MOVF   xD1,W
052D0:  ADDWF  xCE,W
052D2:  MOVWF  FE9
052D4:  MOVLW  00
052D6:  ADDWFC xCF,W
052D8:  MOVWF  FEA
052DA:  MOVF   FEF,W
052DC:  SUBLW  2E
052DE:  BZ    52E8
052E0:  MOVLW  00
052E2:  MOVWF  01
052E4:  BRA    5334
052E6:  BRA    52F6
....................             else if  (decimal) return FALSE;
052E8:  BTFSS  xD0.0
052EA:  BRA    52F4
052EC:  MOVLW  00
052EE:  MOVWF  01
052F0:  BRA    5334
052F2:  BRA    52F6
....................             else decimal = TRUE;
052F4:  BSF    xD0.0
....................          }
052F6:  BRA    5328
....................          else if (0 != i) return FALSE;
052F8:  MOVF   xD1,F
052FA:  BZ    5304
052FC:  MOVLW  00
052FE:  MOVWF  01
05300:  BRA    5334
05302:  BRA    5328
....................          else if (1 == strlen(arg)) return FALSE;
05304:  MOVFF  5CF,5E2
05308:  MOVFF  5CE,5E1
0530C:  MOVLB  0
0530E:  CALL   3E46
05312:  MOVFF  02,03
05316:  MOVF   01,W
05318:  SUBLW  01
0531A:  BNZ   532A
0531C:  MOVF   03,F
0531E:  BNZ   532A
05320:  MOVLW  00
05322:  MOVWF  01
05324:  MOVLB  5
05326:  BRA    5334
05328:  MOVLB  0
....................       }
0532A:  MOVLB  5
0532C:  INCF   xD1,F
0532E:  BRA    527C
....................    }
....................    return TRUE;
05330:  MOVLW  01
05332:  MOVWF  01
05334:  MOVLB  0
05336:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
03F46:  MOVFF  5E0,5E2
03F4A:  MOVFF  5DF,5E1
03F4E:  RCALL  3E46
03F50:  MOVFF  02,03
03F54:  MOVF   01,W
03F56:  SUBLW  01
03F58:  BNZ   3F5E
03F5A:  MOVF   03,F
03F5C:  BZ    3F66
03F5E:  MOVLW  00
03F60:  MOVWF  01
03F62:  BRA    3F94
03F64:  BRA    3F8C
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
03F66:  MOVLB  5
03F68:  MOVFF  5DF,FE9
03F6C:  MOVFF  5E0,FEA
03F70:  MOVF   FEF,W
03F72:  SUBLW  31
03F74:  BZ    3F8E
03F76:  MOVFF  5DF,FE9
03F7A:  MOVFF  5E0,FEA
03F7E:  MOVF   FEF,W
03F80:  SUBLW  32
03F82:  BZ    3F8E
03F84:  MOVLW  00
03F86:  MOVWF  01
03F88:  MOVLB  0
03F8A:  BRA    3F94
03F8C:  MOVLB  5
....................     return TRUE;
03F8E:  MOVLW  01
03F90:  MOVWF  01
03F92:  MOVLB  0
03F94:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
03D94:  MOVLB  5
03D96:  MOVF   xC4,W
03D98:  SUBLW  2F
03D9A:  BC    3DAC
03D9C:  MOVF   xC4,W
03D9E:  SUBLW  39
03DA0:  BNC   3DAC
03DA2:  MOVLW  30
03DA4:  SUBWF  xC4,W
03DA6:  MOVWF  01
03DA8:  BRA    3DC8
03DAA:  BRA    3DC8
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
03DAC:  MOVF   xC4,W
03DAE:  SUBLW  40
03DB0:  BC    3DC4
03DB2:  MOVF   xC4,W
03DB4:  SUBLW  46
03DB6:  BNC   3DC4
03DB8:  MOVLW  41
03DBA:  SUBWF  xC4,W
03DBC:  ADDLW  0A
03DBE:  MOVWF  01
03DC0:  BRA    3DC8
03DC2:  BRA    3DC8
....................    else return 0xFF;
03DC4:  MOVLW  FF
03DC6:  MOVWF  01
03DC8:  MOVLB  0
03DCA:  GOTO   65B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
06508:  MOVLB  5
0650A:  CLRF   xDE
0650C:  MOVFF  5BA,5DD
06510:  CLRF   xE0
06512:  MOVLW  B5
06514:  MOVWF  xDF
06516:  MOVLB  0
06518:  CALL   07CC
0651C:  MOVFF  02,5C4
06520:  MOVFF  01,5C3
06524:  MOVLW  06
06526:  MOVLB  5
06528:  ADDWF  xC3,F
0652A:  MOVLW  00
0652C:  ADDWFC xC4,F
0652E:  MOVLW  52
06530:  ADDWF  xC3,W
06532:  MOVWF  01
06534:  MOVLW  01
06536:  ADDWFC xC4,W
06538:  MOVWF  03
0653A:  MOVFF  01,5BB
0653E:  MOVWF  xBC
06540:  CLRF   xDE
06542:  MOVFF  5BA,5DD
06546:  CLRF   xE0
06548:  MOVLW  B5
0654A:  MOVWF  xDF
0654C:  MOVLB  0
0654E:  CALL   07CC
06552:  MOVFF  02,5C6
06556:  MOVFF  01,5C5
0655A:  MOVLW  06
0655C:  MOVLB  5
0655E:  ADDWF  xC5,F
06560:  MOVLW  00
06562:  ADDWFC xC6,F
06564:  MOVLW  19
06566:  ADDWF  xC5,W
06568:  MOVWF  01
0656A:  MOVLW  00
0656C:  ADDWFC xC6,W
0656E:  MOVWF  03
06570:  MOVF   01,W
06572:  ADDLW  52
06574:  MOVWF  01
06576:  MOVLW  01
06578:  ADDWFC 03,F
0657A:  MOVFF  01,5BD
0657E:  MOVFF  03,5BE
06582:  MOVLW  CF
06584:  MOVWF  F87
06586:  MOVFF  F8C,5BF
0658A:  CLRF   xC0
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
....................    int8 _devID = input_a();
....................    int8 devID = 0;
....................    
....................    if (hwID == cmd_adr[0]){
0658C:  MOVFF  5BB,FE9
06590:  MOVFF  5BC,FEA
06594:  MOVF   FEF,W
06596:  SUBLW  44
06598:  BNZ   6658
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
0659A:  MOVLW  01
0659C:  ADDWF  xBB,W
0659E:  MOVWF  FE9
065A0:  MOVLW  00
065A2:  ADDWFC xBC,W
065A4:  MOVWF  FEA
065A6:  MOVFF  FEF,5C4
065AA:  MOVLB  0
065AC:  GOTO   3D94
065B0:  MOVFF  01,5C3
065B4:  MOVLB  5
065B6:  MOVF   xC0,W
065B8:  ANDLW  0F
065BA:  SUBWF  01,W
065BC:  BNZ   6650
....................          for (int i=0; i < NUM_COMMANDS; i++)
065BE:  CLRF   xC1
065C0:  MOVF   xC1,W
065C2:  SUBLW  11
065C4:  BNC   6648
....................          {
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
065C6:  MOVF   xC1,W
065C8:  MULLW  04
065CA:  MOVF   FF3,W
065CC:  CLRF   xC4
065CE:  MOVWF  xC3
065D0:  MOVLW  D2
065D2:  ADDWF  xC3,W
065D4:  MOVWF  FE9
065D6:  MOVLW  04
065D8:  ADDWFC xC4,W
065DA:  MOVWF  FEA
065DC:  MOVFF  FEC,5E0
065E0:  MOVF   FED,F
065E2:  MOVFF  FEF,5DF
065E6:  MOVFF  5BE,5DE
065EA:  MOVFF  5BD,5DD
065EE:  MOVLB  0
065F0:  CALL   3DCE
065F4:  MOVF   01,F
065F6:  BNZ   6642
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
065F8:  MOVLB  5
065FA:  MOVF   xC1,W
065FC:  MULLW  04
065FE:  MOVF   FF3,W
06600:  CLRF   xC4
06602:  MOVWF  xC3
06604:  MOVLW  02
06606:  ADDWF  xC3,W
06608:  MOVWF  01
0660A:  MOVLW  00
0660C:  ADDWFC xC4,W
0660E:  MOVWF  03
06610:  MOVF   01,W
06612:  ADDLW  D2
06614:  MOVWF  01
06616:  MOVLW  04
06618:  ADDWFC 03,F
0661A:  MOVFF  01,5C3
0661E:  MOVFF  03,5C4
06622:  MOVFF  03,FEA
06626:  MOVFF  01,FE9
0662A:  MOVFF  5BA,5B8
0662E:  MOVLB  0
06630:  CALL   00BC
06634:  MOVFF  01,5C2
....................                return return_code;
06638:  MOVLB  5
0663A:  MOVFF  5C2,01
0663E:  BRA    665C
06640:  MOVLB  0
....................             }
06642:  MOVLB  5
06644:  INCF   xC1,F
06646:  BRA    65C0
....................          }
....................          return INV_CMD; // INVALID_CMD
06648:  MOVLW  01
0664A:  MOVWF  01
0664C:  BRA    665C
....................       } else return 254; // NOT THIS ADDRESS
0664E:  BRA    6656
06650:  MOVLW  FE
06652:  MOVWF  01
06654:  BRA    665C
....................    } else return 255; // NOT THIS DEVICE TYPE
06656:  BRA    665C
06658:  MOVLW  FF
0665A:  MOVWF  01
0665C:  MOVLB  0
0665E:  GOTO   6698 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
0668A:  GOTO   3D3A
0668E:  MOVF   01,F
06690:  BZ    676A
....................    {
....................       int8 return_code = command_parser(SRI);
06692:  MOVFF  426,5BA
06696:  BRA    6508
06698:  MOVFF  01,5B9
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0669C:  MOVLW  04
0669E:  MOVLB  5
066A0:  MOVWF  xE2
066A2:  MOVLW  28
066A4:  MOVWF  xE1
066A6:  MOVLB  0
066A8:  CALL   3E46
066AC:  MOVF   01,W
066AE:  ADDLW  28
066B0:  MOVLB  5
066B2:  MOVWF  xBA
066B4:  MOVLW  04
066B6:  ADDWFC 02,W
066B8:  MOVWF  xBB
066BA:  MOVF   xB9,W
066BC:  MULLW  03
066BE:  MOVF   FF3,W
066C0:  CLRF   xBD
066C2:  MOVWF  xBC
066C4:  MOVLW  01
066C6:  ADDWF  xBC,W
066C8:  MOVWF  01
066CA:  MOVLW  00
066CC:  ADDWFC xBD,W
066CE:  MOVWF  03
066D0:  MOVF   01,W
066D2:  ADDLW  85
066D4:  MOVWF  FE9
066D6:  MOVLW  05
066D8:  ADDWFC 03,W
066DA:  MOVWF  FEA
066DC:  MOVFF  FEC,5BD
066E0:  MOVF   FED,F
066E2:  MOVFF  FEF,5BC
066E6:  MOVFF  5BB,4CD
066EA:  MOVFF  5BA,4CC
066EE:  MOVFF  4CD,FEA
066F2:  MOVFF  4CC,FE9
066F6:  CLRF   FEF
066F8:  MOVFF  5BD,FEA
066FC:  MOVFF  5BC,FE9
06700:  MOVLB  0
06702:  BRA    6662
....................       fprintf(SERIAL, "%s,%s", SERcmd[SRI].p[0], retData);
06704:  MOVLB  5
06706:  CLRF   xDE
06708:  MOVFF  426,5DD
0670C:  CLRF   xE0
0670E:  MOVLW  B5
06710:  MOVWF  xDF
06712:  MOVLB  0
06714:  CALL   07CC
06718:  MOVFF  02,5BB
0671C:  MOVFF  01,5BA
06720:  MOVLW  06
06722:  MOVLB  5
06724:  ADDWF  xBA,F
06726:  MOVLW  00
06728:  ADDWFC xBB,F
0672A:  MOVLW  52
0672C:  ADDWF  xBA,W
0672E:  MOVWF  01
06730:  MOVLW  01
06732:  ADDWFC xBB,W
06734:  MOVWF  03
06736:  MOVFF  01,5BC
0673A:  MOVWF  xBD
0673C:  MOVWF  FEA
0673E:  MOVFF  01,FE9
06742:  MOVLB  0
06744:  CALL   381E
06748:  MOVLW  2C
0674A:  MOVLB  5
0674C:  MOVWF  xC0
0674E:  MOVLB  0
06750:  CALL   37F6
06754:  MOVLW  04
06756:  MOVWF  FEA
06758:  MOVLW  28
0675A:  MOVWF  FE9
0675C:  CALL   381E
....................       
....................       resetSERcmd(SRI);
06760:  MOVFF  426,5BA
06764:  CALL   07EE
06768:  BRA    668A
....................    }
0676A:  GOTO   6A98 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... void main()
0676E:  CLRF   FF8
06770:  BCF    FF2.5
06772:  BSF    07.7
06774:  MOVLB  E
06776:  MOVLW  55
06778:  MOVWF  x9B
0677A:  MOVLW  AA
0677C:  MOVWF  x9B
0677E:  BCF    x9B.0
06780:  MOVLW  17
06782:  MOVWF  xB0
06784:  MOVLW  09
06786:  MOVWF  x8A
06788:  MOVLW  0A
0678A:  MOVWF  x8B
0678C:  MOVLW  11
0678E:  MOVWF  xEB
06790:  MOVLW  12
06792:  MOVWF  xED
06794:  MOVLW  09
06796:  MOVWF  xF8
06798:  MOVLW  55
0679A:  MOVWF  x9B
0679C:  MOVLW  AA
0679E:  MOVWF  x9B
067A0:  BSF    x9B.0
067A2:  CLRF   xD8
067A4:  CLRF   xD5
067A6:  CLRF   xD7
067A8:  MOVLW  08
067AA:  MOVWF  xD9
067AC:  MOVLW  60
067AE:  MOVWF  xD3
067B0:  MOVLW  AA
067B2:  MOVLB  0
067B4:  MOVWF  xF2
067B6:  MOVLB  1
067B8:  CLRF   x44
067BA:  CLRF   x43
067BC:  CLRF   x42
067BE:  CLRF   x41
067C0:  CLRF   x48
067C2:  CLRF   x47
067C4:  CLRF   x46
067C6:  CLRF   x45
067C8:  CLRF   x4C
067CA:  CLRF   x4B
067CC:  CLRF   x4A
067CE:  CLRF   x49
067D0:  CLRF   x4E
067D2:  CLRF   x4D
067D4:  MOVLB  E
067D6:  BCF    x91.5
067D8:  MOVLW  00
067DA:  MOVWF  x90
067DC:  MOVLW  0F
067DE:  MOVWF  x8E
067E0:  MOVLW  2A
067E2:  MOVWF  x91
067E4:  MOVLW  F4
067E6:  MOVWF  F88
067E8:  MOVWF  F88
067EA:  MOVWF  F88
067EC:  MOVLB  4
067EE:  CLRF   x26
067F0:  CLRF   x27
067F2:  CLRF   xC8
067F4:  CLRF   xC9
067F6:  BCF    xCA.0
067F8:  CLRF   xCB
067FA:  BSF    F9E.3
067FC:  MOVLW  7C
067FE:  MOVWF  F9A
06800:  MOVLW  00
06802:  MOVWF  F9B
06804:  MOVLW  A6
06806:  MOVWF  F9D
06808:  MOVLW  90
0680A:  MOVWF  F9C
0680C:  MOVLW  93
0680E:  MOVWF  F89
06810:  BCF    F84.5
06812:  CLRF   xCD
06814:  CLRF   xCC
06816:  CLRF   xD1
06818:  CLRF   xD0
0681A:  CLRF   xCF
0681C:  CLRF   xCE
0681E:  MOVLB  F
06820:  CLRF   x0C
06822:  CLRF   x14
06824:  CLRF   x1C
06826:  CLRF   x21
06828:  CLRF   x29
0682A:  CLRF   x35
0682C:  CLRF   x36
0682E:  CLRF   x37
06830:  CLRF   x34
06832:  CLRF   x31
06834:  CLRF   x32
06836:  CLRF   x33
06838:  CLRF   x30
0683A:  MOVLW  3E
0683C:  MOVLB  4
0683E:  MOVWF  xD5
06840:  MOVLW  BE
06842:  MOVWF  xD4
06844:  MOVLW  3F
06846:  MOVWF  xD9
06848:  MOVLW  02
0684A:  MOVWF  xD8
0684C:  MOVLW  43
0684E:  MOVWF  xDD
06850:  MOVLW  D0
06852:  MOVWF  xDC
06854:  MOVLW  45
06856:  MOVWF  xE1
06858:  MOVLW  7A
0685A:  MOVWF  xE0
0685C:  MOVLW  47
0685E:  MOVWF  xE5
06860:  MOVLW  2A
06862:  MOVWF  xE4
06864:  MOVLW  48
06866:  MOVWF  xE9
06868:  MOVLW  90
0686A:  MOVWF  xE8
0686C:  MOVLW  4D
0686E:  MOVWF  xED
06870:  MOVLW  3C
06872:  MOVWF  xEC
06874:  MOVLW  53
06876:  MOVWF  xF1
06878:  MOVLW  38
0687A:  MOVWF  xF0
0687C:  MOVLW  56
0687E:  MOVWF  xF5
06880:  MOVLW  42
06882:  MOVWF  xF4
06884:  MOVLW  57
06886:  MOVWF  xF9
06888:  MOVLW  78
0688A:  MOVWF  xF8
0688C:  MOVLW  59
0688E:  MOVWF  xFD
06890:  MOVLW  60
06892:  MOVWF  xFC
06894:  MOVLW  5C
06896:  MOVLB  5
06898:  MOVWF  x01
0689A:  MOVLW  D2
0689C:  MOVWF  x00
0689E:  MOVLW  61
068A0:  MOVWF  x05
068A2:  MOVLW  26
068A4:  MOVWF  x04
068A6:  MOVLW  64
068A8:  MOVWF  x09
068AA:  MOVLW  EA
068AC:  MOVWF  x08
068AE:  MOVLW  64
068B0:  MOVWF  x0D
068B2:  MOVLW  F0
068B4:  MOVWF  x0C
068B6:  MOVLW  64
068B8:  MOVWF  x11
068BA:  MOVLW  F6
068BC:  MOVWF  x10
068BE:  MOVLW  64
068C0:  MOVWF  x15
068C2:  MOVLW  FC
068C4:  MOVWF  x14
068C6:  MOVLW  65
068C8:  MOVWF  x19
068CA:  MOVLW  02
068CC:  MOVWF  x18
068CE:  BRA    6A32
068D0:  DATA 02,00
068D2:  DATA 1A,00
068D4:  DATA 00,02
068D6:  DATA 00,60
068D8:  DATA 02,03
068DA:  DATA 08,C0
068DC:  DATA 00,05
068DE:  DATA 80,7F
068E0:  DATA 00,00
068E2:  DATA 00,7F
068E4:  DATA 0B,C0
068E6:  DATA 00,05
068E8:  DATA 80,7F
068EA:  DATA 00,00
068EC:  DATA 00,7F
068EE:  DATA 07,C0
068F0:  DATA 00,01
068F2:  DATA 80,7F
068F4:  DATA 17,C0
068F6:  DATA 00,01
068F8:  DATA 80,7F
068FA:  DATA 17,C0
068FC:  DATA 00,01
068FE:  DATA 80,7F
06900:  DATA 07,C0
06902:  DATA 00,01
06904:  DATA 80,7F
06906:  DATA 07,C0
06908:  DATA 00,01
0690A:  DATA 80,7F
0690C:  DATA 07,C0
0690E:  DATA 00,01
06910:  DATA 80,7F
06912:  DATA 07,C0
06914:  DATA 00,01
06916:  DATA 80,7F
06918:  DATA 07,C0
0691A:  DATA 00,01
0691C:  DATA 80,7F
0691E:  DATA 07,C0
06920:  DATA 00,01
06922:  DATA 80,7F
06924:  DATA 0B,C0
06926:  DATA 00,32
06928:  DATA 41,0F
0692A:  DATA 00,03
0692C:  DATA 01,4F
0692E:  DATA 00,00
06930:  DATA 00,3C
06932:  DATA 44,8C
06934:  DATA 00,02
06936:  DATA 04,D2
06938:  DATA 1A,05
0693A:  DATA 02,04
0693C:  DATA D6,1D
0693E:  DATA 05,02
06940:  DATA 04,DA
06942:  DATA 20,05
06944:  DATA 02,04
06946:  DATA DE,27
06948:  DATA 05,02
0694A:  DATA 04,E2
0694C:  DATA 2E,05
0694E:  DATA 02,04
06950:  DATA E6,36
06952:  DATA 05,02
06954:  DATA 04,EA
06956:  DATA 3E,05
06958:  DATA 02,04
0695A:  DATA EE,43
0695C:  DATA 05,02
0695E:  DATA 04,F2
06960:  DATA 48,05
06962:  DATA 02,04
06964:  DATA F6,4C
06966:  DATA 05,02
06968:  DATA 04,FA
0696A:  DATA 50,05
0696C:  DATA 02,04
0696E:  DATA FE,57
06970:  DATA 05,02
06972:  DATA 05,02
06974:  DATA 5D,05
06976:  DATA 02,05
06978:  DATA 06,63
0697A:  DATA 05,02
0697C:  DATA 05,0A
0697E:  DATA 69,05
06980:  DATA 02,05
06982:  DATA 0E,6F
06984:  DATA 05,02
06986:  DATA 05,12
06988:  DATA 74,05
0698A:  DATA 02,05
0698C:  DATA 16,7D
0698E:  DATA 05,9E
06990:  DATA 05,1A
06992:  DATA 67,72
06994:  DATA 00,67
06996:  DATA 73,00
06998:  DATA 67,43
0699A:  DATA 68,4D
0699C:  DATA 61,70
0699E:  DATA 00,73
069A0:  DATA 43,68
069A2:  DATA 4D,61
069A4:  DATA 70,00
069A6:  DATA 67,43
069A8:  DATA 68,4D
069AA:  DATA 6F,64
069AC:  DATA 65,00
069AE:  DATA 73,43
069B0:  DATA 68,4D
069B2:  DATA 6F,64
069B4:  DATA 65,00
069B6:  DATA 67,50
069B8:  DATA 49,44
069BA:  DATA 00,73
069BC:  DATA 50,49
069BE:  DATA 44,00
069C0:  DATA 67,53
069C2:  DATA 50,00
069C4:  DATA 73,53
069C6:  DATA 50,00
069C8:  DATA 67,53
069CA:  DATA 43,61
069CC:  DATA 6C,73
069CE:  DATA 00,67
069D0:  DATA 53,43
069D2:  DATA 61,6C
069D4:  DATA 00,73
069D6:  DATA 53,43
069D8:  DATA 61,6C
069DA:  DATA 00,67
069DC:  DATA 4D,43
069DE:  DATA 61,6C
069E0:  DATA 00,73
069E2:  DATA 4D,43
069E4:  DATA 61,6C
069E6:  DATA 00,67
069E8:  DATA 4D,6F
069EA:  DATA 6E,00
069EC:  DATA 67,50
069EE:  DATA 49,44
069F0:  DATA 64,61
069F2:  DATA 74,61
069F4:  DATA 00,67
069F6:  DATA 49,50
069F8:  DATA 64,61
069FA:  DATA 74,61
069FC:  DATA 00,00
069FE:  DATA 8E,05
06A00:  DATA 01,96
06A02:  DATA 05,02
06A04:  DATA A6,05
06A06:  DATA 53,55
06A08:  DATA 43,43
06A0A:  DATA 45,53
06A0C:  DATA 53,00
06A0E:  DATA 49,4E
06A10:  DATA 56,41
06A12:  DATA 4C,49
06A14:  DATA 44,20
06A16:  DATA 43,4F
06A18:  DATA 4D,4D
06A1A:  DATA 41,4E
06A1C:  DATA 44,00
06A1E:  DATA 49,4E
06A20:  DATA 56,41
06A22:  DATA 4C,49
06A24:  DATA 44,20
06A26:  DATA 50,41
06A28:  DATA 52,41
06A2A:  DATA 4D,45
06A2C:  DATA 54,45
06A2E:  DATA 52,00
06A30:  DATA 00,00
06A32:  MOVLW  00
06A34:  MOVWF  FF8
06A36:  MOVLW  68
06A38:  MOVWF  FF7
06A3A:  MOVLW  D0
06A3C:  MOVWF  FF6
06A3E:  TBLRD*+
06A40:  MOVF   FF5,W
06A42:  MOVWF  00
06A44:  XORLW  00
06A46:  BZ    6A6E
06A48:  TBLRD*+
06A4A:  MOVF   FF5,W
06A4C:  MOVWF  01
06A4E:  BTFSC  FE8.7
06A50:  BRA    6A5C
06A52:  ANDLW  3F
06A54:  MOVWF  FEA
06A56:  TBLRD*+
06A58:  MOVFF  FF5,FE9
06A5C:  BTFSC  01.6
06A5E:  TBLRD*+
06A60:  BTFSS  01.6
06A62:  TBLRD*+
06A64:  MOVFF  FF5,FEE
06A68:  DCFSNZ 00,F
06A6A:  BRA    6A3E
06A6C:  BRA    6A60
06A6E:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
06A70:  MOVLB  0
06A72:  GOTO   0316
....................    params_init();                // load parameters
06A76:  GOTO   05BE
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
06A7A:  GOTO   075E
.................... //!   control_init();               // initialize the output control DACs
....................    serial_init();                // setup the serial port
06A7E:  GOTO   0968
....................    event_timer_init();
06A82:  GOTO   098A
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
06A86:  MOVLW  C0
06A88:  IORWF  FF2,F
.................... 
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
06A8A:  GOTO   0D68
....................       sensor_monitor_task();     //get magnetoresistive sensor data
06A8E:  GOTO   36D0
.................... //!      control_task();            //output control
....................       serial_task();             //serial port 
06A92:  GOTO   3842
....................       command_handler_task();    //execute commands
06A96:  BRA    668A
.................... //!      signed int32 x_sin = (signed int32)adcVals[0].sinCounts;
.................... //!      signed int32 x_cos = (signed int32)adcVals[0].cosCounts;
....................       
.................... //!      signed int32 y_sin = (signed int32)adcVals[1].sinCounts;
.................... //!      signed int32 y_cos = (signed int32)adcVals[1].cosCounts;
....................       
.................... //!      fprintf(SERIAL, "x_sin=%Ld ; x_cos=%Ld ; y_sin=%Ld ; y_cos=%Ld\n",x_sin,x_cos,y_sin,y_cos);
....................       delay_ms(500);
06A98:  MOVLW  02
06A9A:  MOVLB  5
06A9C:  MOVWF  xB9
06A9E:  MOVLW  FA
06AA0:  MOVWF  xBA
06AA2:  MOVLB  0
06AA4:  CALL   03AC
06AA8:  MOVLB  5
06AAA:  DECFSZ xB9,F
06AAC:  BRA    6A9E
06AAE:  MOVLB  0
06AB0:  BRA    6A8A
....................    }
.................... }
06AB2:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
